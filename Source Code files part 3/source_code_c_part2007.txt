k callback, object asyncState) {
            return this.BeginInvoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndGetMessageDetails(System.IAsyncResult asyncResult, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void GetMessageDetailsAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags) {
            this.GetMessageDetailsAsync(UserWebID, UserGamerTag, MessageID, SetFlags, UnsetFlags, null);
        }
        
        /// <remarks/>
        public void GetMessageDetailsAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, object userState) {
            if ((this.GetMessageDetailsOperationCompleted == null)) {
                this.GetMessageDetailsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMessageDetailsOperationCompleted);
            }
            this.InvokeAsync("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, this.GetMessageDetailsOperationCompleted, userState);
        }
        
        private void OnGetMessageDetailsOperationCompleted(object arg) {
            if ((this.GetMessageDetailsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMessageDetailsCompleted(this, new GetMessageDetailsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint EnumMessages([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag});
            Summary = ((WCMessageSummary[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumMessages(byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndEnumMessages(System.IAsyncResult asyncResult, out WCMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void EnumMessagesAsync(byte[] UserWebID, string UserGamerTag) {
            this.EnumMessagesAsync(UserWebID, UserGamerTag, null);
        }
        
        /// <remarks/>
        public void EnumMessagesAsync(byte[] UserWebID, string UserGamerTag, object userState) {
            if ((this.EnumMessagesOperationCompleted == null)) {
                this.EnumMessagesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumMessagesOperationCompleted);
            }
            this.InvokeAsync("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag}, this.EnumMessagesOperationCompleted, userState);
        }
        
        private void OnEnumMessagesOperationCompleted(object arg) {
            if ((this.EnumMessagesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumMessagesCompleted(this, new EnumMessagesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCRecipientResult {
        
        private string userField;
        
        private uint messageIDField;
        
        /// <remarks/>
        public string User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                return this.messageIDField;
            }
            set {
                this.messageIDField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCMessageSummary {
        
        private string senderField;
        
        private ulong senderContextField;
        
        private System.DateTime sentTimeField;
        
        private uint messageIDField;
        
        private WCMessageFlags messageFlagsField;
        
        private uint senderTitleIDField;
        
        private ushort expireMinutesField;
        
        private ushort detailsSizeField;
        
        private WCMessageType messageTypeField;
        
        /// <remarks/>
        public string Sender {
            get {
                return this.senderField;
            }
            set {
                this.senderField = value;
            }
        }
        
        /// <remarks/>
        public ulong SenderContext {
            get {
                return this.senderContextField;
            }
            set {
                this.senderContextField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime SentTime {
            get {
                return this.sentTimeField;
            }
            set {
                this.sentTimeField = value;
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                return this.messageIDField;
            }
            set {
                this.messageIDField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageFlags MessageFlags {
            get {
                return this.messageFlagsField;
            }
            set {
                this.messageFlagsField = value;
            }
        }
        
        /// <remarks/>
        public uint SenderTitleID {
            get {
                return this.senderTitleIDField;
            }
            set {
                this.senderTitleIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort ExpireMinutes {
            get {
                return this.expireMinutesField;
            }
            set {
                this.expireMinutesField = value;
            }
        }
        
        /// <remarks/>
        public ushort DetailsSize {
            get {
                return this.detailsSizeField;
            }
            set {
                this.detailsSizeField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageType MessageType {
            get {
                return this.messageTypeField;
            }
            set {
                this.messageTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageFlags {
        
        /// <remarks/>
        Required = 1,
        
        /// <remarks/>
        Recommended = 2,
        
        /// <remarks/>
        HasVoice = 4,
        
        /// <remarks/>
        HasText = 8,
        
        /// <remarks/>
        Read = 16,
        
        /// <remarks/>
        NonExportable = 32,
        
        /// <remarks/>
        TeamContext = 64,
        
        /// <remarks/>
        CompContext = 128,
        
        /// <remarks/>
        AlternateTitle = 256,
        
        /// <remarks/>
        Marketing = 512,
        
        /// <remarks/>
        MSReserved0 = 1024,
        
        /// <remarks/>
        MSReserved1 = 2048,
        
        /// <remarks/>
        MSReserved2 = 4096,
        
        /// <remarks/>
        MSReserved3 = 8192,
        
        /// <remarks/>
        MSReserved4 = 16384,
        
        /// <remarks/>
        MSReserved5 = 32768,
        
        /// <remarks/>
        MSReserved6 = 65536,
        
        /// <remarks/>
        MSReserved7 = 131072,
        
        /// <remarks/>
        MSReserved8 = 262144,
        
        /// <remarks/>
        MSReserved9 = 524288,
        
        /// <remarks/>
        MSReserved10 = 1048576,
        
        /// <remarks/>
        MSReserved11 = 2097152,
        
        /// <remarks/>
        MSReserved12 = 4194304,
        
        /// <remarks/>
        MSReserved13 = 8388608,
        
        /// <remarks/>
        TitleReserved0 = 16777216,
        
        /// <remarks/>
        TitleReserved1 = 33554432,
        
        /// <remarks/>
        TitleReserved2 = 67108864,
        
        /// <remarks/>
        TitleReserved3 = 134217728,
        
        /// <remarks/>
        TitleReserved4 = 268435456,
        
        /// <remarks/>
        TitleReserved5 = 536870912,
        
        /// <remarks/>
        TitleReserved6 = 1073741824,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageType {
        
        /// <remarks/>
        Invalid,
        
        /// <remarks/>
        TitleCustom,
        
        /// <remarks/>
        FriendRequest,
        
        /// <remarks/>
        GameInvite,
        
        /// <remarks/>
        TeamRecruit,
        
        /// <remarks/>
        CompReminder,
        
        /// <remarks/>
        CompRequest,
        
        /// <remarks/>
        LiveMessage,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCUserTitle {
        
        private uint titleIDField;
        
        private System.DateTime lastLogonTimeField;
        
        private WCUserTitleFlags flagsField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastLogonTime {
            get {
                return this.lastLogonTimeField;
            }
            set {
                this.lastLogonTimeField = value;
            }
        }
        
        /// <remarks/>
        public WCUserTitleFlags Flags {
            get {
                return this.flagsField;
            }
            set {
                this.flagsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCUserTitleFlags {
        
        /// <remarks/>
        AcceptMarketing = 1,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCTitleWideMessageSummary {
        
        private uint titleIDField;
        
        private ulong senderContextField;
        
        private System.DateTime sentTimeField;
        
        private uint regionField;
        
        private uint messageIDField;
        
        private WCMessageFlags messageFlagsField;
        
        private ushort expireMinutesField;
        
        private ushort detailsSizeField;
        
        private WCMessageType messageTypeField;
        
        private string senderNameField;
        
        private string descriptionField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public ulong SenderContext {
            get {
                return this.senderContextField;
            }
            set {
                this.senderContextField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime SentTime {
            get {
                return this.sentTimeField;
            }
            set {
                this.sentTimeField = value;
            }
        }
        
        /// <remarks/>
        public uint Region {
            get {
                return this.regionField;
            }
            set {
                this.regionField = value;
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                return this.messageIDField;
            }
            set {
                this.messageIDField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageFlags MessageFlags {
            get {
                return this.messageFlagsField;
            }
            set {
                this.messageFlagsField = value;
            }
        }
        
        /// <remarks/>
        public ushort ExpireMinutes {
            get {
                return this.expireMinutesField;
            }
            set {
                this.expireMinutesField = value;
            }
        }
        
        /// <remarks/>
        public ushort DetailsSize {
            get {
                return this.detailsSizeField;
            }
            set {
                this.detailsSizeField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageType MessageType {
            get {
                return this.messageTypeField;
            }
            set {
                this.messageTypeField = value;
            }
        }
        
        /// <remarks/>
        public string SenderName {
            get {
                return this.senderNameField;
            }
            set {
                this.senderNameField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCLanguageString {
        
        private string localeField;
        
        private string stringField;
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public string String {
            get {
                return this.stringField;
            }
            set {
                this.stringField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCLocalizedString {
        
        private byte propIDField;
        
        private string defaultLocaleField;
        
        private WCLanguageString[] langStringField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public string DefaultLocale {
            get {
                return this.defaultLocaleField;
            }
            set {
                this.defaultLocaleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LangString")]
        public WCLanguageString[] LangString {
            get {
                return this.langStringField;
            }
            set {
                this.langStringField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCMessageAttachment {
        
        private byte propIDField;
        
        private WCAttachFlags flagsField;
        
        private byte[] dataField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public WCAttachFlags Flags {
            get {
                return this.flagsField;
            }
            set {
                this.flagsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCAttachFlags {
        
        /// <remarks/>
        NonExportable = 1,
        
        /// <remarks/>
        Directory = 2,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCStringIdProp {
        
        private byte propIDField;
        
        private uint valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public uint Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCBoolProp {
        
        private byte propIDField;
        
        private bool valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public bool Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCAttachmentProp {
        
        private byte propIDField;
        
        private uint attachSizeField;
        
        private WCAttachFlags attachFlagsField;
        
        private string attachUrlField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public uint AttachSize {
            get {
                return this.attachSizeField;
            }
            set {
                this.attachSizeField = value;
            }
        }
        
        /// <remarks/>
        public WCAttachFlags AttachFlags {
            get {
                return this.attachFlagsField;
            }
            set {
                this.attachFlagsField = value;
            }
        }
        
        /// <remarks/>
        public string AttachUrl {
            get {
                return this.attachUrlField;
            }
            set {
                this.attachUrlField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCBinaryProp {
        
        private byte propIDField;
        
        private byte[] valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCTimeProp {
        
        private byte propIDField;
        
        private System.DateTime valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCStringProp {
        
        private byte propIDField;
        
        private string valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCQwordProp {
        
        private byte propIDField;
        
        private ulong valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public ulong Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCDwordProp {
        
        private byte propIDField;
        
        private uint valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public uint Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCWordProp {
        
        private byte propIDField;
        
        private ushort valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCByteProp {
        
        private byte propIDField;
        
        private byte valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public byte Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCNullProp {
        
        private byte propIDField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCMessageDetails {
        
        private WCNullProp[] nullPropField;
        
        private WCByteProp[] bytePropField;
        
        private WCWordProp[] wordPropField;
        
        private WCDwordProp[] dwordPropField;
        
        private WCQwordProp[] qwordPropField;
        
        private WCStringProp[] stringPropField;
        
        private WCTimeProp[] timePropField;
        
        private WCBinaryProp[] binaryPropField;
        
        private WCAttachmentProp[] attachmentPropField;
        
        private WCBoolProp[] boolPropField;
        
        private WCStringIdProp[] stringIdPropField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("NullProp")]
        public WCNullProp[] NullProp {
            get {
                return this.nullPropField;
            }
            set {
                this.nullPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ByteProp")]
        public WCByteProp[] ByteProp {
            get {
                return this.bytePropField;
            }
            set {
                this.bytePropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("WordProp")]
        public WCWordProp[] WordProp {
            get {
                return this.wordPropField;
            }
            set {
                this.wordPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DwordProp")]
        public WCDwordProp[] DwordProp {
            get {
                return this.dwordPropField;
            }
            set {
                this.dwordPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("QwordProp")]
        public WCQwordProp[] QwordProp {
            get {
                return this.qwordPropField;
            }
            set {
                this.qwordPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringProp")]
        public WCStringProp[] StringProp {
            get {
                return this.stringPropField;
            }
            set {
                this.stringPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("TimeProp")]
        public WCTimeProp[] TimeProp {
            get {
                return this.timePropField;
            }
            set {
                this.timePropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BinaryProp")]
        public WCBinaryProp[] BinaryProp {
            get {
                return this.binaryPropField;
            }
            set {
                this.binaryPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AttachmentProp")]
        public WCAttachmentProp[] AttachmentProp {
            get {
                return this.attachmentPropField;
            }
            set {
                this.attachmentPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BoolProp")]
        public WCBoolProp[] BoolProp {
            get {
                return this.boolPropField;
            }
            set {
                this.boolPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringIdProp")]
        public WCStringIdProp[] StringIdProp {
            get {
                return this.stringIdPropField;
            }
            set {
                this.stringIdPropField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCDeleteSysMsgFlags {
        
        /// <remarks/>
        RevokeAll = 1,
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCDeleteMsgFlags {
        
        /// <remarks/>
        BlockSender = 1,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMessageStringCompletedEventHandler(object sender, GetMessageStringCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMessageStringCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMessageStringCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeTitleUserMessageCompletedEventHandler(object sender, RevokeTitleUserMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RevokeTitleUserMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RevokeTitleUserMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendTitleUserMessageCompletedEventHandler(object sender, SendTitleUserMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendTitleUserMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendTitleUserMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCRecipientResult[] RecipResult {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCRecipientResult[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendTitleWideMessageCompletedEventHandler(object sender, SendTitleWideMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendTitleWideMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendTitleWideMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ushort Delay {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ushort)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteTitleWideMessageCompletedEventHandler(object sender, DeleteTitleWideMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteTitleWideMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteTitleWideMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTitleWideMessageDetailsCompletedEventHandler(object sender, GetTitleWideMessageDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTitleWideMessageDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTitleWideMessageDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCTitleWideMessageSummary Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCTitleWideMessageSummary)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public WCMessageDetails Details {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageDetails)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumTitleWideMessagesCompletedEventHandler(object sender, EnumTitleWideMessagesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumTitleWideMessagesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumTitleWideMessagesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCTitleWideMessageSummary[] Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCTitleWideMessageSummary[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetMessageFlagsCompletedEventHandler(object sender, SetMessageFlagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetMessageFlagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetMessageFlagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumUserTitlesCompletedEventHandler(object sender, EnumUserTitlesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumUserTitlesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumUserTitlesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCUserTitle[] Title {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCUserTitle[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteUserTitleCompletedEventHandler(object sender, DeleteUserTitleCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteUserTitleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteUserTitleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeMessageCompletedEventHandler(object sender, RevokeMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RevokeMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RevokeMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendMessageCompletedEventHandler(object sender, SendMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCRecipientResult[] RecipResult {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCRecipientResult[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteMessageCompletedEventHandler(object sender, DeleteMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMessageDetailsCompletedEventHandler(object sender, GetMessageDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMessageDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMessageDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCMessageSummary Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageSummary)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public WCMessageDetails Details {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageDetails)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumMessagesCompletedEventHandler(object sender, EnumMessagesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumMessagesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumMessagesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCMessageSummary[] Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageSummary[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wshelper_none_12.4.56.0_none_6da0353643f7de53
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wshelper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d.manifest
XP_MANIFEST_PATH=manifests\msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d.cat
XP_CATALOG_PATH=manifests\msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d.cat
XP_PAYLOAD_PATH=msil_wshelper_no-public-key_12.4.56.0_x-ww_4066644d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wshelper,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\Storage.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Storage {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="StorageSoap", Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class Storage : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetTitleQuotaOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReadUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReadTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback WriteUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback WriteTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback RevokeTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback RevokeUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateTitleFilesOperationCompleted;
        
        /// <remarks/>
        public Storage() {
            this.Url = "http://xewbcaiis001:12000/storage/storage.asmx";
        }
        
        /// <remarks/>
        public event GetTitleQuotaCompletedEventHandler GetTitleQuotaCompleted;
        
        /// <remarks/>
        public event ReadUserFileCompletedEventHandler ReadUserFileCompleted;
        
        /// <remarks/>
        public event ReadTitleFileCompletedEventHandler ReadTitleFileCompleted;
        
        /// <remarks/>
        public event WriteUserFileCompletedEventHandler WriteUserFileCompleted;
        
        /// <remarks/>
        public event WriteTitleFileCompletedEventHandler WriteTitleFileCompleted;
        
        /// <remarks/>
        public event DeleteUserFileCompletedEventHandler DeleteUserFileCompleted;
        
        /// <remarks/>
        public event DeleteTitleFileCompletedEventHandler DeleteTitleFileCompleted;
        
        /// <remarks/>
        public event RevokeTitleFileCompletedEventHandler RevokeTitleFileCompleted;
        
        /// <remarks/>
        public event RevokeUserFileCompletedEventHandler RevokeUserFileCompleted;
        
        /// <remarks/>
        public event EnumerateTitleFilesCompletedEventHandler EnumerateTitleFilesCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/GetTitleQuota", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public QuotaInfo GetTitleQuota(uint titleID) {
            object[] results = this.Invoke("GetTitleQuota", new object[] {
                        titleID});
            return ((QuotaInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleQuota(uint titleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleQuota", new object[] {
                        titleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public QuotaInfo EndGetTitleQuota(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((QuotaInfo)(results[0]));
        }
        
        /// <remarks/>
        public void GetTitleQuotaAsync(uint titleID) {
            this.GetTitleQuotaAsync(titleID, null);
        }
        
        /// <remarks/>
        public void GetTitleQuotaAsync(uint titleID, object userState) {
            if ((this.GetTitleQuotaOperationCompleted == null)) {
                this.GetTitleQuotaOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTitleQuotaOperationCompleted);
            }
            this.InvokeAsync("GetTitleQuota", new object[] {
                        titleID}, this.GetTitleQuotaOperationCompleted, userState);
        }
        
        private void OnGetTitleQuotaOperationCompleted(object arg) {
            if ((this.GetTitleQuotaCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTitleQuotaCompleted(this, new GetTitleQuotaCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/ReadUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ReadFileInfo ReadUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate) {
            object[] results = this.Invoke("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate});
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReadFileInfo EndReadUserFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public void ReadUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate) {
            this.ReadUserFileAsync(titleID, webID, gamerTag, fileName, ifModifiedSinceDate, null);
        }
        
        /// <remarks/>
        public void ReadUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate, object userState) {
            if ((this.ReadUserFileOperationCompleted == null)) {
                this.ReadUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadUserFileOperationCompleted);
            }
            this.InvokeAsync("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate}, this.ReadUserFileOperationCompleted, userState);
        }
        
        private void OnReadUserFileOperationCompleted(object arg) {
            if ((this.ReadUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadUserFileCompleted(this, new ReadUserFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/ReadTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ReadFileInfo ReadTitleFile(uint titleID, string fileName, System.DateTime ifModifiedSinceDate) {
            object[] results = this.Invoke("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate});
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadTitleFile(uint titleID, string fileName, System.DateTime ifModifiedSinceDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReadFileInfo EndReadTitleFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public void ReadTitleFileAsync(uint titleID, string fileName, System.DateTime ifModifiedSinceDate) {
            this.ReadTitleFileAsync(titleID, fileName, ifModifiedSinceDate, null);
        }
        
        /// <remarks/>
        public void ReadTitleFileAsync(uint titleID, string fileName, System.DateTime ifModifiedSinceDate, object userState) {
            if ((this.ReadTitleFileOperationCompleted == null)) {
                this.ReadTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadTitleFileOperationCompleted);
            }
            this.InvokeAsync("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate}, this.ReadTitleFileOperationCompleted, userState);
        }
        
        private void OnReadTitleFileOperationCompleted(object arg) {
            if ((this.ReadTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadTitleFileCompleted(this, new ReadTitleFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/WriteUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void WriteUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] data, System.DateTime expirationDate) {
            this.Invoke("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndWriteUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void WriteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate) {
            this.WriteUserFileAsync(titleID, webID, gamerTag, fileName, contentType, data, expirationDate, null);
        }
        
        /// <remarks/>
        public void WriteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, object userState) {
            if ((this.WriteUserFileOperationCompleted == null)) {
                this.WriteUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWriteUserFileOperationCompleted);
            }
            this.InvokeAsync("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, this.WriteUserFileOperationCompleted, userState);
        }
        
        private void OnWriteUserFileOperationCompleted(object arg) {
            if ((this.WriteUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WriteUserFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/WriteTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void WriteTitleFile(uint titleID, string fileName, FileContentTypeEnum contentType, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] data, System.DateTime expirationDate) {
            this.Invoke("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteTitleFile(uint titleID, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndWriteTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void WriteTitleFileAsync(uint titleID, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate) {
            this.WriteTitleFileAsync(titleID, fileName, contentType, data, expirationDate, null);
        }
        
        /// <remarks/>
        public void WriteTitleFileAsync(uint titleID, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, object userState) {
            if ((this.WriteTitleFileOperationCompleted == null)) {
                this.WriteTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWriteTitleFileOperationCompleted);
            }
            this.InvokeAsync("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, this.WriteTitleFileOperationCompleted, userState);
        }
        
        private void OnWriteTitleFileOperationCompleted(object arg) {
            if ((this.WriteTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WriteTitleFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/DeleteUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName) {
            this.Invoke("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName) {
            this.DeleteUserFileAsync(titleID, webID, gamerTag, fileName, null);
        }
        
        /// <remarks/>
        public void DeleteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, object userState) {
            if ((this.DeleteUserFileOperationCompleted == null)) {
                this.DeleteUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteUserFileOperationCompleted);
            }
            this.InvokeAsync("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, this.DeleteUserFileOperationCompleted, userState);
        }
        
        private void OnDeleteUserFileOperationCompleted(object arg) {
            if ((this.DeleteUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteUserFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/DeleteTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteTitleFile(uint titleID, string fileName) {
            this.Invoke("DeleteTitleFile", new object[] {
                        titleID,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTitleFile(uint titleID, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTitleFile", new object[] {
                        titleID,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteTitleFileAsync(uint titleID, string fileName) {
            this.DeleteTitleFileAsync(titleID, fileName, null);
        }
        
        /// <remarks/>
        public void DeleteTitleFileAsync(uint titleID, string fileName, object userState) {
            if ((this.DeleteTitleFileOperationCompleted == null)) {
                this.DeleteTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteTitleFileOperationCompleted);
            }
            this.InvokeAsync("DeleteTitleFile", new object[] {
                        titleID,
                        fileName}, this.DeleteTitleFileOperationCompleted, userState);
        }
        
        private void OnDeleteTitleFileOperationCompleted(object arg) {
            if ((this.DeleteTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteTitleFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/RevokeTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeTitleFile(uint titleID, string fileName) {
            this.Invoke("RevokeTitleFile", new object[] {
                        titleID,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeTitleFile(uint titleID, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeTitleFile", new object[] {
                        titleID,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RevokeTitleFileAsync(uint titleID, string fileName) {
            this.RevokeTitleFileAsync(titleID, fileName, null);
        }
        
        /// <remarks/>
        public void RevokeTitleFileAsync(uint titleID, string fileName, object userState) {
            if ((this.RevokeTitleFileOperationCompleted == null)) {
                this.RevokeTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRevokeTitleFileOperationCompleted);
            }
            this.InvokeAsync("RevokeTitleFile", new object[] {
                        titleID,
                        fileName}, this.RevokeTitleFileOperationCompleted, userState);
        }
        
        private void OnRevokeTitleFileOperationCompleted(object arg) {
            if ((this.RevokeTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RevokeTitleFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/RevokeUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName) {
            this.Invoke("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RevokeUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName) {
            this.RevokeUserFileAsync(titleID, webID, gamerTag, fileName, null);
        }
        
        /// <remarks/>
        public void RevokeUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, object userState) {
            if ((this.RevokeUserFileOperationCompleted == null)) {
                this.RevokeUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRevokeUserFileOperationCompleted);
            }
            this.InvokeAsync("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, this.RevokeUserFileOperationCompleted, userState);
        }
        
        private void OnRevokeUserFileOperationCompleted(object arg) {
            if ((this.RevokeUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RevokeUserFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/EnumerateTitleFiles", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public FileEnumerationInfo[] EnumerateTitleFiles(uint titleID, string fileQuery, System.DateTime ifModifiedSince) {
            object[] results = this.Invoke("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince});
            return ((FileEnumerationInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateTitleFiles(uint titleID, string fileQuery, System.DateTime ifModifiedSince, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince}, callback, asyncState);
        }
        
        /// <remarks/>
        public FileEnumerationInfo[] EndEnumerateTitleFiles(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FileEnumerationInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateTitleFilesAsync(uint titleID, string fileQuery, System.DateTime ifModifiedSince) {
            this.EnumerateTitleFilesAsync(titleID, fileQuery, ifModifiedSince, null);
        }
        
        /// <remarks/>
        public void EnumerateTitleFilesAsync(uint titleID, string fileQuery, System.DateTime ifModifiedSince, object userState) {
            if ((this.EnumerateTitleFilesOperationCompleted == null)) {
                this.EnumerateTitleFilesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateTitleFilesOperationCompleted);
            }
            this.InvokeAsync("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince}, this.EnumerateTitleFilesOperationCompleted, userState);
        }
        
        private void OnEnumerateTitleFilesOperationCompleted(object arg) {
            if ((this.EnumerateTitleFilesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateTitleFilesCompleted(this, new EnumerateTitleFilesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class QuotaInfo {
        
        private ulong maxFileSizeField;
        
        private ulong totalBytesMaxField;
        
        private ulong totalBytesUsedField;
        
        private uint totalFilesMaxField;
        
        private uint totalFilesUsedField;
        
        /// <remarks/>
        public ulong MaxFileSize {
            get {
                return this.maxFileSizeField;
            }
            set {
                this.maxFileSizeField = value;
            }
        }
        
        /// <remarks/>
        public ulong TotalBytesMax {
            get {
                return this.totalBytesMaxField;
            }
            set {
                this.totalBytesMaxField = value;
            }
        }
        
        /// <remarks/>
        public ulong TotalBytesUsed {
            get {
                return this.totalBytesUsedField;
            }
            set {
                this.totalBytesUsedField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalFilesMax {
            get {
                return this.totalFilesMaxField;
            }
            set {
                this.totalFilesMaxField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalFilesUsed {
            get {
                return this.totalFilesUsedField;
            }
            set {
                this.totalFilesUsedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class FileEnumerationInfo {
        
        private uint titleIDField;
        
        private uint titleVersionField;
        
        private string gamerTagField;
        
        private byte userCountryIDField;
        
        private uint fileSizeField;
        
        private System.DateTime creationDateField;
        
        private System.DateTime modifiedDateField;
        
        private string fileNameField;
        
        private FileContentTypeEnum fileContentTypeField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleVersion {
            get {
                return this.titleVersionField;
            }
            set {
                this.titleVersionField = value;
            }
        }
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public byte UserCountryID {
            get {
                return this.userCountryIDField;
            }
            set {
                this.userCountryIDField = value;
            }
        }
        
        /// <remarks/>
        public uint FileSize {
            get {
                return this.fileSizeField;
            }
            set {
                this.fileSizeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationDate {
            get {
                return this.creationDateField;
            }
            set {
                this.creationDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ModifiedDate {
            get {
                return this.modifiedDateField;
            }
            set {
                this.modifiedDateField = value;
            }
        }
        
        /// <remarks/>
        public string FileName {
            get {
                return this.fileNameField;
            }
            set {
                this.fileNameField = value;
            }
        }
        
        /// <remarks/>
        public FileContentTypeEnum FileContentType {
            get {
                return this.fileContentTypeField;
            }
            set {
                this.fileContentTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public enum FileContentTypeEnum {
        
        /// <remarks/>
        Package,
        
        /// <remarks/>
        Blob,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class ReadFileInfo {
        
        private bool fileNotModifiedField;
        
        private uint titleIDField;
        
        private uint titleVersionField;
        
        private string gamerTagField;
        
        private byte userCountryIDField;
        
        private uint fileSizeField;
        
        private System.DateTime creationDateField;
        
        private byte[] fileDataField;
        
        private FileContentTypeEnum fileContentTypeField;
        
        /// <remarks/>
        public bool FileNotModified {
            get {
                return this.fileNotModifiedField;
            }
            set {
                this.fileNotModifiedField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleVersion {
            get {
                return this.titleVersionField;
            }
            set {
                this.titleVersionField = value;
            }
        }
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public byte UserCountryID {
            get {
                return this.userCountryIDField;
            }
            set {
                this.userCountryIDField = value;
            }
        }
        
        /// <remarks/>
        public uint FileSize {
            get {
                return this.fileSizeField;
            }
            set {
                this.fileSizeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationDate {
            get {
                return this.creationDateField;
            }
            set {
                this.creationDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] FileData {
            get {
                return this.fileDataField;
            }
            set {
                this.fileDataField = value;
            }
        }
        
        /// <remarks/>
        public FileContentTypeEnum FileContentType {
            get {
                return this.fileContentTypeField;
            }
            set {
                this.fileContentTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTitleQuotaCompletedEventHandler(object sender, GetTitleQuotaCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTitleQuotaCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTitleQuotaCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public QuotaInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((QuotaInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReadUserFileCompletedEventHandler(object sender, ReadUserFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadUserFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadUserFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ReadFileInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ReadFileInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReadTitleFileCompletedEventHandler(object sender, ReadTitleFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadTitleFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadTitleFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ReadFileInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ReadFileInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WriteUserFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WriteTitleFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteUserFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteTitleFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeTitleFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeUserFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateTitleFilesCompletedEventHandler(object sender, EnumerateTitleFilesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateTitleFilesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateTitleFilesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FileEnumerationInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FileEnumerationInfo[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\Teams.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Teams {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="TeamsSoap", Namespace="http://websvc.xboxlive.com/Teams/")]
    public partial class Teams : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback CreateTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveTeamMemberOperationCompleted;
        
        private System.Threading.SendOrPostCallback ManageTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback ManageTeamMemberOperationCompleted;
        
        private System.Threading.SendOrPostCallback RecruitTeamMemberOperationCompleted;
        
        private System.Threading.SendOrPostCallback JoinTeamOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamInfoOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamMembersOperationCompleted;
        
        /// <remarks/>
        public Teams() {
            this.Url = "http://xewbcaiis001:12000/teams/teams.asmx";
        }
        
        /// <remarks/>
        public event CreateTeamCompletedEventHandler CreateTeamCompleted;
        
        /// <remarks/>
        public event DeleteTeamCompletedEventHandler DeleteTeamCompleted;
        
        /// <remarks/>
        public event RemoveTeamMemberCompletedEventHandler RemoveTeamMemberCompleted;
        
        /// <remarks/>
        public event ManageTeamCompletedEventHandler ManageTeamCompleted;
        
        /// <remarks/>
        public event ManageTeamMemberCompletedEventHandler ManageTeamMemberCompleted;
        
        /// <remarks/>
        public event RecruitTeamMemberCompletedEventHandler RecruitTeamMemberCompleted;
        
        /// <remarks/>
        public event JoinTeamCompletedEventHandler JoinTeamCompleted;
        
        /// <remarks/>
        public event GetTeamInfoCompletedEventHandler GetTeamInfoCompleted;
        
        /// <remarks/>
        public event GetTeamMembersCompletedEventHandler GetTeamMembersCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/CreateTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] teamData, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] creatorData) {
            this.Invoke("CreateTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        maxMembers,
                        description,
                        motto,
                        URL,
                        teamData,
                        creatorData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateTeam(uint titleId, byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, byte[] teamData, byte[] creatorData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        maxMembers,
                        description,
                        motto,
                        URL,
                        teamData,
                        creatorData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, byte[] teamData, byte[] creatorData) {
            this.CreateTeamAsync(titleId, webId, gamerTag, teamName, maxMembers, description, motto, URL, teamData, creatorData, null);
        }
        
        /// <remarks/>
        public void CreateTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint maxMembers, string description, string motto, string URL, byte[] teamData, byte[] creatorData, object userState) {
            if ((this.CreateTeamOperationCompleted == null)) {
                this.CreateTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateTeamOperationCompleted);
            }
            this.InvokeAsync("CreateTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        maxMembers,
                        description,
                        motto,
                        URL,
                        teamData,
                        creatorData}, this.CreateTeamOperationCompleted, userState);
        }
        
        private void OnCreateTeamOperationCompleted(object arg) {
            if ((this.CreateTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/DeleteTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName) {
            this.Invoke("DeleteTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTeam(uint titleId, byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName) {
            this.DeleteTeamAsync(titleId, webId, gamerTag, teamName, null);
        }
        
        /// <remarks/>
        public void DeleteTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, object userState) {
            if ((this.DeleteTeamOperationCompleted == null)) {
                this.DeleteTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteTeamOperationCompleted);
            }
            this.InvokeAsync("DeleteTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, this.DeleteTeamOperationCompleted, userState);
        }
        
        private void OnDeleteTeamOperationCompleted(object arg) {
            if ((this.DeleteTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/RemoveTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveTeamMember(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string memberGamerTag) {
            this.Invoke("RemoveTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveTeamMember(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveTeamMember(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RemoveTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag) {
            this.RemoveTeamMemberAsync(titleId, webId, gamerTag, teamName, memberGamerTag, null);
        }
        
        /// <remarks/>
        public void RemoveTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, object userState) {
            if ((this.RemoveTeamMemberOperationCompleted == null)) {
                this.RemoveTeamMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveTeamMemberOperationCompleted);
            }
            this.InvokeAsync("RemoveTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag}, this.RemoveTeamMemberOperationCompleted, userState);
        }
        
        private void OnRemoveTeamMemberOperationCompleted(object arg) {
            if ((this.RemoveTeamMemberCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveTeamMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/ManageTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ManageTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] teamData) {
            this.Invoke("ManageTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        newTeamName,
                        description,
                        motto,
                        URL,
                        teamData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginManageTeam(uint titleId, byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, byte[] teamData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ManageTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        newTeamName,
                        description,
                        motto,
                        URL,
                        teamData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndManageTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ManageTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, byte[] teamData) {
            this.ManageTeamAsync(titleId, webId, gamerTag, teamName, newTeamName, description, motto, URL, teamData, null);
        }
        
        /// <remarks/>
        public void ManageTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string newTeamName, string description, string motto, string URL, byte[] teamData, object userState) {
            if ((this.ManageTeamOperationCompleted == null)) {
                this.ManageTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnManageTeamOperationCompleted);
            }
            this.InvokeAsync("ManageTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        newTeamName,
                        description,
                        motto,
                        URL,
                        teamData}, this.ManageTeamOperationCompleted, userState);
        }
        
        private void OnManageTeamOperationCompleted(object arg) {
            if ((this.ManageTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ManageTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/ManageTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ManageTeamMember(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] memberData) {
            this.Invoke("ManageTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginManageTeamMember(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ManageTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndManageTeamMember(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ManageTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData) {
            this.ManageTeamMemberAsync(titleId, webId, gamerTag, teamName, memberGamerTag, memberPriv, memberData, null);
        }
        
        /// <remarks/>
        public void ManageTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, object userState) {
            if ((this.ManageTeamMemberOperationCompleted == null)) {
                this.ManageTeamMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnManageTeamMemberOperationCompleted);
            }
            this.InvokeAsync("ManageTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, this.ManageTeamMemberOperationCompleted, userState);
        }
        
        private void OnManageTeamMemberOperationCompleted(object arg) {
            if ((this.ManageTeamMemberCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ManageTeamMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/RecruitTeamMember", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RecruitTeamMember(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] memberData) {
            this.Invoke("RecruitTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRecruitTeamMember(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RecruitTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRecruitTeamMember(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RecruitTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData) {
            this.RecruitTeamMemberAsync(titleId, webId, gamerTag, teamName, memberGamerTag, memberPriv, memberData, null);
        }
        
        /// <remarks/>
        public void RecruitTeamMemberAsync(uint titleId, byte[] webId, string gamerTag, string teamName, string memberGamerTag, uint memberPriv, byte[] memberData, object userState) {
            if ((this.RecruitTeamMemberOperationCompleted == null)) {
                this.RecruitTeamMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRecruitTeamMemberOperationCompleted);
            }
            this.InvokeAsync("RecruitTeamMember", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        memberGamerTag,
                        memberPriv,
                        memberData}, this.RecruitTeamMemberOperationCompleted, userState);
        }
        
        private void OnRecruitTeamMemberOperationCompleted(object arg) {
            if ((this.RecruitTeamMemberCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RecruitTeamMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/JoinTeam", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void JoinTeam(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, byte answer) {
            this.Invoke("JoinTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginJoinTeam(uint titleId, byte[] webId, string gamerTag, string teamName, byte answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("JoinTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndJoinTeam(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void JoinTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, byte answer) {
            this.JoinTeamAsync(titleId, webId, gamerTag, teamName, answer, null);
        }
        
        /// <remarks/>
        public void JoinTeamAsync(uint titleId, byte[] webId, string gamerTag, string teamName, byte answer, object userState) {
            if ((this.JoinTeamOperationCompleted == null)) {
                this.JoinTeamOperationCompleted = new System.Threading.SendOrPostCallback(this.OnJoinTeamOperationCompleted);
            }
            this.InvokeAsync("JoinTeam", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        answer}, this.JoinTeamOperationCompleted, userState);
        }
        
        private void OnJoinTeamOperationCompleted(object arg) {
            if ((this.JoinTeamCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.JoinTeamCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/GetTeamInfo", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TeamInfo[] GetTeamInfo(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName) {
            object[] results = this.Invoke("GetTeamInfo", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName});
            return ((TeamInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamInfo(uint titleId, byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamInfo", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public TeamInfo[] EndGetTeamInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TeamInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamInfoAsync(uint titleId, byte[] webId, string gamerTag, string teamName) {
            this.GetTeamInfoAsync(titleId, webId, gamerTag, teamName, null);
        }
        
        /// <remarks/>
        public void GetTeamInfoAsync(uint titleId, byte[] webId, string gamerTag, string teamName, object userState) {
            if ((this.GetTeamInfoOperationCompleted == null)) {
                this.GetTeamInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamInfoOperationCompleted);
            }
            this.InvokeAsync("GetTeamInfo", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, this.GetTeamInfoOperationCompleted, userState);
        }
        
        private void OnGetTeamInfoOperationCompleted(object arg) {
            if ((this.GetTeamInfoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamInfoCompleted(this, new GetTeamInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Teams/GetTeamMembers", RequestNamespace="http://websvc.xboxlive.com/Teams/", ResponseNamespace="http://websvc.xboxlive.com/Teams/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TeamMember[] GetTeamMembers(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName) {
            object[] results = this.Invoke("GetTeamMembers", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName});
            return ((TeamMember[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamMembers(uint titleId, byte[] webId, string gamerTag, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamMembers", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public TeamMember[] EndGetTeamMembers(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TeamMember[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamMembersAsync(uint titleId, byte[] webId, string gamerTag, string teamName) {
            this.GetTeamMembersAsync(titleId, webId, gamerTag, teamName, null);
        }
        
        /// <remarks/>
        public void GetTeamMembersAsync(uint titleId, byte[] webId, string gamerTag, string teamName, object userState) {
            if ((this.GetTeamMembersOperationCompleted == null)) {
                this.GetTeamMembersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamMembersOperationCompleted);
            }
            this.InvokeAsync("GetTeamMembers", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName}, this.GetTeamMembersOperationCompleted, userState);
        }
        
        private void OnGetTeamMembersOperationCompleted(object arg) {
            if ((this.GetTeamMembersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamMembersCompleted(this, new GetTeamMembersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Teams/")]
    public partial class TeamInfo {
        
        private string nameField;
        
        private string descriptionField;
        
        private string mottoField;
        
        private string uRLField;
        
        private ulong createdField;
        
        private uint numMembersField;
        
        private byte[] dataField;
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public string motto {
            get {
                return this.mottoField;
            }
            set {
                this.mottoField = value;
            }
        }
        
        /// <remarks/>
        public string URL {
            get {
                return this.uRLField;
            }
            set {
                this.uRLField = value;
            }
        }
        
        /// <remarks/>
        public ulong created {
            get {
                return this.createdField;
            }
            set {
                this.createdField = value;
            }
        }
        
        /// <remarks/>
        public uint numMembers {
            get {
                return this.numMembersField;
            }
            set {
                this.numMembersField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Teams/")]
    public partial class TeamMember {
        
        private string gamertagField;
        
        private bool memberField;
        
        private uint privilegesField;
        
        private byte[] dataField;
        
        private ulong joinedField;
        
        /// <remarks/>
        public string gamertag {
            get {
                return this.gamertagField;
            }
            set {
                this.gamertagField = value;
            }
        }
        
        /// <remarks/>
        public bool member {
            get {
                return this.memberField;
            }
            set {
                this.memberField = value;
            }
        }
        
        /// <remarks/>
        public uint privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
        
        /// <remarks/>
        public ulong joined {
            get {
                return this.joinedField;
            }
            set {
                this.joinedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveTeamMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ManageTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ManageTeamMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RecruitTeamMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void JoinTeamCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamInfoCompletedEventHandler(object sender, GetTeamInfoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TeamInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TeamInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamMembersCompletedEventHandler(object sender, GetTeamMembersCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamMembersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamMembersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TeamMember[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TeamMember[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\Stats.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Stats {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="StatsSoap", Namespace="http://websvc.xboxlive.com/Stats/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBEntry[]))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBAttribute[]))]
    public partial class Stats : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback DeleteXUIDFromLBOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteXUIDFromAllLBsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLBListOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLBListByTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateLBOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLBNearGamerTagOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLBForGamerTagsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLBDetailsForGamerTagsOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateTeamLBOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamLBNearTeamNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamLBForTeamNamesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTeamLBDetailsForTeamNamesOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateLBRawOperationCompleted;
        
        /// <remarks/>
        public Stats() {
            this.Url = "https://websvc.xboxlive.com/stats/stats.asmx";
        }
        
        /// <remarks/>
        public event DeleteXUIDFromLBCompletedEventHandler DeleteXUIDFromLBCompleted;
        
        /// <remarks/>
        public event DeleteXUIDFromAllLBsCompletedEventHandler DeleteXUIDFromAllLBsCompleted;
        
        /// <remarks/>
        public event GetLBListCompletedEventHandler GetLBListCompleted;
        
        /// <remarks/>
        public event GetLBListByTypeCompletedEventHandler GetLBListByTypeCompleted;
        
        /// <remarks/>
        public event EnumerateLBCompletedEventHandler EnumerateLBCompleted;
        
        /// <remarks/>
        public event GetLBNearGamerTagCompletedEventHandler GetLBNearGamerTagCompleted;
        
        /// <remarks/>
        public event GetLBForGamerTagsCompletedEventHandler GetLBForGamerTagsCompleted;
        
        /// <remarks/>
        public event GetLBDetailsForGamerTagsCompletedEventHandler GetLBDetailsForGamerTagsCompleted;
        
        /// <remarks/>
        public event EnumerateTeamLBCompletedEventHandler EnumerateTeamLBCompleted;
        
        /// <remarks/>
        public event GetTeamLBNearTeamNameCompletedEventHandler GetTeamLBNearTeamNameCompleted;
        
        /// <remarks/>
        public event GetTeamLBForTeamNamesCompletedEventHandler GetTeamLBForTeamNamesCompleted;
        
        /// <remarks/>
        public event GetTeamLBDetailsForTeamNamesCompletedEventHandler GetTeamLBDetailsForTeamNamesCompleted;
        
        /// <remarks/>
        public event EnumerateLBRawCompletedEventHandler EnumerateLBRawCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/DeleteXUIDFromLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DeleteXUIDStatus DeleteXUIDFromLB(uint uiTitleID, uint uiLbId, ulong xuid) {
            object[] results = this.Invoke("DeleteXUIDFromLB", new object[] {
                        uiTitleID,
                        uiLbId,
                        xuid});
            return ((DeleteXUIDStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteXUIDFromLB(uint uiTitleID, uint uiLbId, ulong xuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteXUIDFromLB", new object[] {
                        uiTitleID,
                        uiLbId,
                        xuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public DeleteXUIDStatus EndDeleteXUIDFromLB(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((DeleteXUIDStatus)(results[0]));
        }
        
        /// <remarks/>
        public void DeleteXUIDFromLBAsync(uint uiTitleID, uint uiLbId, ulong xuid) {
            this.DeleteXUIDFromLBAsync(uiTitleID, uiLbId, xuid, null);
        }
        
        /// <remarks/>
        public void DeleteXUIDFromLBAsync(uint uiTitleID, uint uiLbId, ulong xuid, object userState) {
            if ((this.DeleteXUIDFromLBOperationCompleted == null)) {
                this.DeleteXUIDFromLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteXUIDFromLBOperationCompleted);
            }
            this.InvokeAsync("DeleteXUIDFromLB", new object[] {
                        uiTitleID,
                        uiLbId,
                        xuid}, this.DeleteXUIDFromLBOperationCompleted, userState);
        }
        
        private void OnDeleteXUIDFromLBOperationCompleted(object arg) {
            if ((this.DeleteXUIDFromLBCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteXUIDFromLBCompleted(this, new DeleteXUIDFromLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/DeleteXUIDFromAllLBs", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DeleteXUIDStatus DeleteXUIDFromAllLBs(uint uiTitleID, ulong xuid) {
            object[] results = this.Invoke("DeleteXUIDFromAllLBs", new object[] {
                        uiTitleID,
                        xuid});
            return ((DeleteXUIDStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteXUIDFromAllLBs(uint uiTitleID, ulong xuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteXUIDFromAllLBs", new object[] {
                        uiTitleID,
                        xuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public DeleteXUIDStatus EndDeleteXUIDFromAllLBs(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((DeleteXUIDStatus)(results[0]));
        }
        
        /// <remarks/>
        public void DeleteXUIDFromAllLBsAsync(uint uiTitleID, ulong xuid) {
            this.DeleteXUIDFromAllLBsAsync(uiTitleID, xuid, null);
        }
        
        /// <remarks/>
        public void DeleteXUIDFromAllLBsAsync(uint uiTitleID, ulong xuid, object userState) {
            if ((this.DeleteXUIDFromAllLBsOperationCompleted == null)) {
                this.DeleteXUIDFromAllLBsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteXUIDFromAllLBsOperationCompleted);
            }
            this.InvokeAsync("DeleteXUIDFromAllLBs", new object[] {
                        uiTitleID,
                        xuid}, this.DeleteXUIDFromAllLBsOperationCompleted, userState);
        }
        
        private void OnDeleteXUIDFromAllLBsOperationCompleted(object arg) {
            if ((this.DeleteXUIDFromAllLBsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteXUIDFromAllLBsCompleted(this, new DeleteXUIDFromAllLBsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBList", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LBInfo[] GetLBList(uint TitleID, out uint ValidSeconds) {
            object[] results = this.Invoke("GetLBList", new object[] {
                        TitleID});
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLBList(uint TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLBList", new object[] {
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public LBInfo[] EndGetLBList(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetLBListAsync(uint TitleID) {
            this.GetLBListAsync(TitleID, null);
        }
        
        /// <remarks/>
        public void GetLBListAsync(uint TitleID, object userState) {
            if ((this.GetLBListOperationCompleted == null)) {
                this.GetLBListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBListOperationCompleted);
            }
            this.InvokeAsync("GetLBList", new object[] {
                        TitleID}, this.GetLBListOperationCompleted, userState);
        }
        
        private void OnGetLBListOperationCompleted(object arg) {
            if ((this.GetLBListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBListCompleted(this, new GetLBListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBListByType", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LBInfo[] GetLBListByType(uint TitleID, LBType LeaderboardType, out uint ValidSeconds) {
            object[] results = this.Invoke("GetLBListByType", new object[] {
                        TitleID,
                        LeaderboardType});
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLBListByType(uint TitleID, LBType LeaderboardType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLBListByType", new object[] {
                        TitleID,
                        LeaderboardType}, callback, asyncState);
        }
        
        /// <remarks/>
        public LBInfo[] EndGetLBListByType(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetLBListByTypeAsync(uint TitleID, LBType LeaderboardType) {
            this.GetLBListByTypeAsync(TitleID, LeaderboardType, null);
        }
        
        /// <remarks/>
        public void GetLBListByTypeAsync(uint TitleID, LBType LeaderboardType, object userState) {
            if ((this.GetLBListByTypeOperationCompleted == null)) {
                this.GetLBListByTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBListByTypeOperationCompleted);
            }
            this.InvokeAsync("GetLBListByType", new object[] {
                        TitleID,
                        LeaderboardType}, this.GetLBListByTypeOperationCompleted, userState);
        }
        
        private void OnGetLBListByTypeOperationCompleted(object arg) {
            if ((this.GetLBListByTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBListByTypeCompleted(this, new GetLBListByTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults EnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds) {
            object[] results = this.Invoke("EnumerateLB", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateLB", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries}, callback, asyncState);
        }
        
        /// <remarks/>
        public DetailedLBResults EndEnumerateLB(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries) {
            this.EnumerateLBAsync(TitleID, LBID, StartIndex, MaxEntries, null);
        }
        
        /// <remarks/>
        public void EnumerateLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState) {
            if ((this.EnumerateLBOperationCompleted == null)) {
                this.EnumerateLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateLBOperationCompleted);
            }
            this.InvokeAsync("EnumerateLB", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries}, this.EnumerateLBOperationCompleted, userState);
        }
        
        private void OnEnumerateLBOperationCompleted(object arg) {
            if ((this.EnumerateLBCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateLBCompleted(this, new EnumerateLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBNearGamerTag", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, out uint ValidSeconds) {
            object[] results = this.Invoke("GetLBNearGamerTag", new object[] {
                        TitleID,
                        LBID,
                        GamerTag,
                        NumAbove,
                        NumBelow});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLBNearGamerTag", new object[] {
                        TitleID,
                        LBID,
                        GamerTag,
                        NumAbove,
                        NumBelow}, callback, asyncState);
        }
        
        /// <remarks/>
        public DetailedLBResults EndGetLBNearGamerTag(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetLBNearGamerTagAsync(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow) {
            this.GetLBNearGamerTagAsync(TitleID, LBID, GamerTag, NumAbove, NumBelow, null);
        }
        
        /// <remarks/>
        public void GetLBNearGamerTagAsync(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, object userState) {
            if ((this.GetLBNearGamerTagOperationCompleted == null)) {
                this.GetLBNearGamerTagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBNearGamerTagOperationCompleted);
            }
            this.InvokeAsync("GetLBNearGamerTag", new object[] {
                        TitleID,
                        LBID,
                        GamerTag,
                        NumAbove,
                        NumBelow}, this.GetLBNearGamerTagOperationCompleted, userState);
        }
        
        private void OnGetLBNearGamerTagOperationCompleted(object arg) {
            if ((this.GetLBNearGamerTagCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBNearGamerTagCompleted(this, new GetLBNearGamerTagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public LBResults GetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, out uint ValidSeconds) {
            object[] results = this.Invoke("GetLBForGamerTags", new object[] {
                        TitleID,
                        LBID,
                        GamerTagList});
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLBForGamerTags", new object[] {
                        TitleID,
                        LBID,
                        GamerTagList}, callback, asyncState);
        }
        
        /// <remarks/>
        public LBResults EndGetLBForGamerTags(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetLBForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList) {
            this.GetLBForGamerTagsAsync(TitleID, LBID, GamerTagList, null);
        }
        
        /// <remarks/>
        public void GetLBForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList, object userState) {
            if ((this.GetLBForGamerTagsOperationCompleted == null)) {
                this.GetLBForGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBForGamerTagsOperationCompleted);
            }
            this.InvokeAsync("GetLBForGamerTags", new object[] {
                        TitleID,
                        LBID,
                        GamerTagList}, this.GetLBForGamerTagsOperationCompleted, userState);
        }
        
        private void OnGetLBForGamerTagsOperationCompleted(object arg) {
            if ((this.GetLBForGamerTagsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBForGamerTagsCompleted(this, new GetLBForGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBDetailsForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, out uint ValidSeconds) {
            object[] results = this.Invoke("GetLBDetailsForGamerTags", new object[] {
                        TitleID,
                        LBID,
                        GamerTagList});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLBDetailsForGamerTags", new object[] {
                        TitleID,
                        LBID,
                        GamerTagList}, callback, asyncState);
        }
        
        /// <remarks/>
        public DetailedLBResults EndGetLBDetailsForGamerTags(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetLBDetailsForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList) {
            this.GetLBDetailsForGamerTagsAsync(TitleID, LBID, GamerTagList, null);
        }
        
        /// <remarks/>
        public void GetLBDetailsForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList, object userState) {
            if ((this.GetLBDetailsForGamerTagsOperationCompleted == null)) {
                this.GetLBDetailsForGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBDetailsForGamerTagsOperationCompleted);
            }
            this.InvokeAsync("GetLBDetailsForGamerTags", new object[] {
                        TitleID,
                        LBID,
                        GamerTagList}, this.GetLBDetailsForGamerTagsOperationCompleted, userState);
        }
        
        private void OnGetLBDetailsForGamerTagsOperationCompleted(object arg) {
            if ((this.GetLBDetailsForGamerTagsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBDetailsForGamerTagsCompleted(this, new GetLBDetailsForGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateTeamLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults EnumerateTeamLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds) {
            object[] results = this.Invoke("EnumerateTeamLB", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateTeamLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateTeamLB", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries}, callback, asyncState);
        }
        
        /// <remarks/>
        public DetailedLBResults EndEnumerateTeamLB(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateTeamLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries) {
            this.EnumerateTeamLBAsync(TitleID, LBID, StartIndex, MaxEntries, null);
        }
        
        /// <remarks/>
        public void EnumerateTeamLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState) {
            if ((this.EnumerateTeamLBOperationCompleted == null)) {
                this.EnumerateTeamLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateTeamLBOperationCompleted);
            }
            this.InvokeAsync("EnumerateTeamLB", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries}, this.EnumerateTeamLBOperationCompleted, userState);
        }
        
        private void OnEnumerateTeamLBOperationCompleted(object arg) {
            if ((this.EnumerateTeamLBCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateTeamLBCompleted(this, new EnumerateTeamLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBNearTeamName", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetTeamLBNearTeamName(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, out uint ValidSeconds) {
            object[] results = this.Invoke("GetTeamLBNearTeamName", new object[] {
                        TitleID,
                        LBID,
                        TeamName,
                        NumAbove,
                        NumBelow});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamLBNearTeamName(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamLBNearTeamName", new object[] {
                        TitleID,
                        LBID,
                        TeamName,
                        NumAbove,
                        NumBelow}, callback, asyncState);
        }
        
        /// <remarks/>
        public DetailedLBResults EndGetTeamLBNearTeamName(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamLBNearTeamNameAsync(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow) {
            this.GetTeamLBNearTeamNameAsync(TitleID, LBID, TeamName, NumAbove, NumBelow, null);
        }
        
        /// <remarks/>
        public void GetTeamLBNearTeamNameAsync(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, object userState) {
            if ((this.GetTeamLBNearTeamNameOperationCompleted == null)) {
                this.GetTeamLBNearTeamNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBNearTeamNameOperationCompleted);
            }
            this.InvokeAsync("GetTeamLBNearTeamName", new object[] {
                        TitleID,
                        LBID,
                        TeamName,
                        NumAbove,
                        NumBelow}, this.GetTeamLBNearTeamNameOperationCompleted, userState);
        }
        
        private void OnGetTeamLBNearTeamNameOperationCompleted(object arg) {
            if ((this.GetTeamLBNearTeamNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamLBNearTeamNameCompleted(this, new GetTeamLBNearTeamNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBForTeamNames", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public LBResults GetTeamLBForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, out uint ValidSeconds) {
            object[] results = this.Invoke("GetTeamLBForTeamNames", new object[] {
                        TitleID,
                        LBID,
                        TeamNameList});
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamLBForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamLBForTeamNames", new object[] {
                        TitleID,
                        LBID,
                        TeamNameList}, callback, asyncState);
        }
        
        /// <remarks/>
        public LBResults EndGetTeamLBForTeamNames(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamLBForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList) {
            this.GetTeamLBForTeamNamesAsync(TitleID, LBID, TeamNameList, null);
        }
        
        /// <remarks/>
        public void GetTeamLBForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList, object userState) {
            if ((this.GetTeamLBForTeamNamesOperationCompleted == null)) {
                this.GetTeamLBForTeamNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBForTeamNamesOperationCompleted);
            }
            this.InvokeAsync("GetTeamLBForTeamNames", new object[] {
                        TitleID,
                        LBID,
                        TeamNameList}, this.GetTeamLBForTeamNamesOperationCompleted, userState);
        }
        
        private void OnGetTeamLBForTeamNamesOperationCompleted(object arg) {
            if ((this.GetTeamLBForTeamNamesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamLBForTeamNamesCompleted(this, new GetTeamLBForTeamNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBDetailsForTeamNames", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetTeamLBDetailsForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, out uint ValidSeconds) {
            object[] results = this.Invoke("GetTeamLBDetailsForTeamNames", new object[] {
                        TitleID,
                        LBID,
                        TeamNameList});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTeamLBDetailsForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTeamLBDetailsForTeamNames", new object[] {
                        TitleID,
                        LBID,
                        TeamNameList}, callback, asyncState);
        }
        
        /// <remarks/>
        public DetailedLBResults EndGetTeamLBDetailsForTeamNames(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetTeamLBDetailsForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList) {
            this.GetTeamLBDetailsForTeamNamesAsync(TitleID, LBID, TeamNameList, null);
        }
        
        /// <remarks/>
        public void GetTeamLBDetailsForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList, object userState) {
            if ((this.GetTeamLBDetailsForTeamNamesOperationCompleted == null)) {
                this.GetTeamLBDetailsForTeamNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBDetailsForTeamNamesOperationCompleted);
            }
            this.InvokeAsync("GetTeamLBDetailsForTeamNames", new object[] {
                        TitleID,
                        LBID,
                        TeamNameList}, this.GetTeamLBDetailsForTeamNamesOperationCompleted, userState);
        }
        
        private void OnGetTeamLBDetailsForTeamNamesOperationCompleted(object arg) {
            if ((this.GetTeamLBDetailsForTeamNamesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamLBDetailsForTeamNamesCompleted(this, new GetTeamLBDetailsForTeamNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLBRaw", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RawLBResults EnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds) {
            object[] results = this.Invoke("EnumerateLBRaw", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries});
            ValidSeconds = ((uint)(results[1]));
            return ((RawLBResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateLBRaw", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries}, callback, asyncState);
        }
        
        /// <remarks/>
        public RawLBResults EndEnumerateLBRaw(System.IAsyncResult asyncResult, out uint ValidSeconds) {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((RawLBResults)(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateLBRawAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries) {
            this.EnumerateLBRawAsync(TitleID, LBID, StartIndex, MaxEntries, null);
        }
        
        /// <remarks/>
        public void EnumerateLBRawAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState) {
            if ((this.EnumerateLBRawOperationCompleted == null)) {
                this.EnumerateLBRawOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateLBRawOperationCompleted);
            }
            this.InvokeAsync("EnumerateLBRaw", new object[] {
                        TitleID,
                        LBID,
                        StartIndex,
                        MaxEntries}, this.EnumerateLBRawOperationCompleted, userState);
        }
        
        private void OnEnumerateLBRawOperationCompleted(object arg) {
            if ((this.EnumerateLBRawCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateLBRawCompleted(this, new EnumerateLBRawCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public enum DeleteXUIDStatus {
        
        /// <remarks/>
        Success,
        
        /// <remarks/>
        Warning_No_OP,
        
        /// <remarks/>
        Error_Invalid_Xuid,
        
        /// <remarks/>
        Error_Invalid_Title,
        
        /// <remarks/>
        Error_Invalid_Lb_ID,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class LBInfo {
        
        private uint lBIDField;
        
        private LBResetType resetTypeField;
        
        private StatsLocalizedName[] localizedLBNameField;
        
        private LBAttributeInfo[] attributeInfoField;
        
        /// <remarks/>
        public uint LBID {
            get {
                return this.lBIDField;
            }
            set {
                this.lBIDField = value;
            }
        }
        
        /// <remarks/>
        public LBResetType ResetType {
            get {
                return this.resetTypeField;
            }
            set {
                this.resetTypeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public StatsLocalizedName[] LocalizedLBName {
            get {
                return this.localizedLBNameField;
            }
            set {
                this.localizedLBNameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LBAttributeInfo[] AttributeInfo {
            get {
                return this.attributeInfoField;
            }
            set {
                this.attributeInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public enum LBResetType {
        
        /// <remarks/>
        Never,
        
        /// <remarks/>
        Weekly,
        
        /// <remarks/>
        Monthly,
        
        /// <remarks/>
        Bimonthly,
        
        /// <remarks/>
        Quarterly,
        
        /// <remarks/>
        Semiannually,
        
        /// <remarks/>
        Annually,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class StatsLocalizedName {
        
        private string localeField;
        
        private string displayNameField;
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayName {
            get {
                return this.displayNameField;
            }
            set {
                this.displayNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class RawLBAttribute {
        
        private uint idField;
        
        private object vField;
        
        /// <remarks/>
        public uint ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public object V {
            get {
                return this.vField;
            }
            set {
                this.vField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class RawLBEntry {
        
        private string gField;
        
        private uint rField;
        
        private RawLBAttribute[] aField;
        
        /// <remarks/>
        public string G {
            get {
                return this.gField;
            }
            set {
                this.gField = value;
            }
        }
        
        /// <remarks/>
        public uint R {
            get {
                return this.rField;
            }
            set {
                this.rField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public RawLBAttribute[] A {
            get {
                return this.aField;
            }
            set {
                this.aField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class RawLBResults {
        
        private RawLBEntry[] entriesField;
        
        private System.DateTime lBLastResetDateField;
        
        private uint totalLBEntriesField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public RawLBEntry[] Entries {
            get {
                return this.entriesField;
            }
            set {
                this.entriesField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LBLastResetDate {
            get {
                return this.lBLastResetDateField;
            }
            set {
                this.lBLastResetDateField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalLBEntries {
            get {
                return this.totalLBEntriesField;
            }
            set {
                this.totalLBEntriesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class LBEntry {
        
        private string gField;
        
        private uint rField;
        
        /// <remarks/>
        public string G {
            get {
                return this.gField;
            }
            set {
                this.gField = value;
            }
        }
        
        /// <remarks/>
        public uint R {
            get {
                return this.rField;
            }
            set {
                this.rField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class LBResults {
        
        private LBEntry[] entriesField;
        
        private System.DateTime lBLastResetDateField;
        
        private uint totalLBEntriesField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LBEntry[] Entries {
            get {
                return this.entriesField;
            }
            set {
                this.entriesField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LBLastResetDate {
            get {
                return this.lBLastResetDateField;
            }
            set {
                this.lBLastResetDateField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalLBEntries {
            get {
                return this.totalLBEntriesField;
            }
            set {
                this.totalLBEntriesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class LBEntryAttribute {
        
        private string idField;
        
        private string vField;
        
        /// <remarks/>
        public string ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string V {
            get {
                return this.vField;
            }
            set {
                this.vField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class DetailedLBEntry {
        
        private string gField;
        
        private uint rField;
        
        private LBEntryAttribute[] fField;
        
        /// <remarks/>
        public string G {
            get {
                return this.gField;
            }
            set {
                this.gField = value;
            }
        }
        
        /// <remarks/>
        public uint R {
            get {
                return this.rField;
            }
            set {
                this.rField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LBEntryAttribute[] F {
            get {
                return this.fField;
            }
            set {
                this.fField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class DetailedLBResults {
        
        private DetailedLBEntry[] entriesField;
        
        private System.DateTime lBLastResetDateField;
        
        private uint totalLBEntriesField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public DetailedLBEntry[] Entries {
            get {
                return this.entriesField;
            }
            set {
                this.entriesField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LBLastResetDate {
            get {
                return this.lBLastResetDateField;
            }
            set {
                this.lBLastResetDateField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalLBEntries {
            get {
                return this.totalLBEntriesField;
            }
            set {
                this.totalLBEntriesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public partial class LBAttributeInfo {
        
        private string idField;
        
        private AttributeUnit unitField;
        
        private StatsLocalizedName[] localizedAttrNameField;
        
        /// <remarks/>
        public string ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public AttributeUnit Unit {
            get {
                return this.unitField;
            }
            set {
                this.unitField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public StatsLocalizedName[] LocalizedAttrName {
            get {
                return this.localizedAttrNameField;
            }
            set {
                this.localizedAttrNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public enum AttributeUnit {
        
        /// <remarks/>
        Integer,
        
        /// <remarks/>
        Float,
        
        /// <remarks/>
        Percent,
        
        /// <remarks/>
        GamerTag,
        
        /// <remarks/>
        TimeStamp,
        
        /// <remarks/>
        MilliSeconds,
        
        /// <remarks/>
        TenMilliSeconds,
        
        /// <remarks/>
        HundredMilliSeconds,
        
        /// <remarks/>
        Seconds,
        
        /// <remarks/>
        Minutes,
        
        /// <remarks/>
        Hours,
        
        /// <remarks/>
        Days,
        
        /// <remarks/>
        String,
        
        /// <remarks/>
        Team,
        
        /// <remarks/>
        MaxAttributeUnit,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
    public enum LBType {
        
        /// <remarks/>
        Regular,
        
        /// <remarks/>
        RegularTeam,
        
        /// <remarks/>
        CompetitionTemplate,
        
        /// <remarks/>
        CompetitionTemplateTeam,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteXUIDFromLBCompletedEventHandler(object sender, DeleteXUIDFromLBCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteXUIDFromLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteXUIDFromLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DeleteXUIDStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DeleteXUIDStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteXUIDFromAllLBsCompletedEventHandler(object sender, DeleteXUIDFromAllLBsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteXUIDFromAllLBsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteXUIDFromAllLBsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DeleteXUIDStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DeleteXUIDStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBListCompletedEventHandler(object sender, GetLBListCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLBListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LBInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LBInfo[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBListByTypeCompletedEventHandler(object sender, GetLBListByTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBListByTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLBListByTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LBInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LBInfo[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateLBCompletedEventHandler(object sender, EnumerateLBCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DetailedLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBNearGamerTagCompletedEventHandler(object sender, GetLBNearGamerTagCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBNearGamerTagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLBNearGamerTagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DetailedLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBForGamerTagsCompletedEventHandler(object sender, GetLBForGamerTagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBForGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLBForGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBDetailsForGamerTagsCompletedEventHandler(object sender, GetLBDetailsForGamerTagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBDetailsForGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLBDetailsForGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DetailedLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateTeamLBCompletedEventHandler(object sender, EnumerateTeamLBCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateTeamLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateTeamLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DetailedLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamLBNearTeamNameCompletedEventHandler(object sender, GetTeamLBNearTeamNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamLBNearTeamNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamLBNearTeamNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DetailedLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamLBForTeamNamesCompletedEventHandler(object sender, GetTeamLBForTeamNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamLBForTeamNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamLBForTeamNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamLBDetailsForTeamNamesCompletedEventHandler(object sender, GetTeamLBDetailsForTeamNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamLBDetailsForTeamNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTeamLBDetailsForTeamNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DetailedLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateLBRawCompletedEventHandler(object sender, EnumerateLBRawCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateLBRawCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateLBRawCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public RawLBResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RawLBResults)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public uint ValidSeconds {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\DBLoad.cpp ===
#include "stdio.h"
#include "windows.h"
#include "Engine.h"
#include "Report.h"
#include "FBLogFile.h"


FWriter glogfile("E:\\tool\\missing.log");
FWriter reportfile("E:\\tool\\report.log");


void ProcessFBLOG()
{
	Engine eng;
	
/*	printf( "Deleting All records from DB \n");
	eng.ClearDB(); // empty the database.

	printf( "Loading Server 1 logs to DB \n");
	eng.LoadAllFileToDB ("E:\\tool\\serverlog\\s1","Feedback*.log","[FBServer].[dbo].[Feedback]"); // LOAD all logs from server1
	printf( "Loading Server 2 logs to DB \n");
	eng.LoadAllFileToDB ("E:\\tool\\serverlog\\s2","Feedback*.log","[FBServer].[dbo].[Feedback]"); // LOAD all logs from server2

	printf( "Loading Client logs to DB \n");
	eng.LoadAllFileToDB ("E:\\tool\\clientlog\\p200","p*.txt" ,"[FBServer].[dbo].[p200]");
	
	  */
/*	printf( "Loading Client logs to DB \n");
	eng.LoadAllFileToDB ("E:\\tool\\clientlog\\p500","p*.txt" ,"[FBServer].[dbo].[p500]");
*/
	printf( "Generating report \n");
	eng.Stats ();
	Report rt;
	rt.Init ();
	rt.RecordNotFound();
	rt.ErrorRecords ();
	rt.NOof500RecFound ();

	

}

void main()
{
	HRESULT  hr = S_OK;
	glogfile.Init ();
	reportfile.Init ();
	
	int opt =8;
	Engine eng;

   if(FAILED(::CoInitialize(NULL))) 
      return; 

   {
	   switch(opt)
	   {
		case 1:eng.LoadFileToDB("E:\\TESTTOOLS\\comparetool\\log\\server\\feedbacklog020320110.log","[FBServer].[dbo].[Feedback]");
			break;
		case 2:
			eng.ClearDB();
			break;
		case 3:
			eng.LoadFileToDB("E:\\TESTTOOLS\\comparetool\\log\\client\\P200\\Passed200.txt","[FBServer].[dbo].[p200]");
			break;
		case 4:
			eng.LoadAllFileToDB ("E:\\TESTTOOLS\\comparetool\\log\\server","Feedback*.log","[FBServer].[dbo].[Feedback]");
			break;
		case 5:
			eng.LoadAllFileToDB ("E:\\TESTTOOLS\\comparetool\\log\\client\\P200","*.txt" ,"[FBServer].[dbo].[p200]");
			break;
		case 6:
			eng.Stats ();
			break;
		case 7:
			printf( " total rec : %d \n",eng.NickNameCount("pankaj"));
				break;
		case 8: // this is the main option that will 
				ProcessFBLOG();
				break;
		default:
			printf("hello world");
			break;
	   }

	   
   }
      
   ::CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\Engine.h ===
//Engine



class Engine
{
public:
	Engine();
	~Engine();
//	void VerifyClientLog(char* szfile);
	void ClearDB();
	void LoadFileToDB(char * szfile,char* Tablename);
	void LoadAllFileToDB(char * szdir,char * Wildcard,char* Tablename);
//	void VerifyALL(char * szdir,char * Wildcard);
	void Stats();
	int NickNameCount(char * name);


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\CommonConfigTest\InstanceEventArgs.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Text;
//using xonline.common;
using xonline.common.config;
using System.Data.SqlClient;

namespace CommonConfigLoader
{
    [Serializable]
    public class InstanceEventArgs : EventArgs
    {
        private string message;
        private DateTime timestamp;
        private string instanceID;
        private string threadID;
        private string machineName;
        private TimeSpan duration;

        public InstanceEventArgs(string s)
        {
            timestamp = DateTime.Now;
            message = s;
        }

        public InstanceEventArgs(string msg, string machine, string instance, string thread, TimeSpan interval)
        {
            timestamp = DateTime.Now;
            message = msg;
            machineName = machine;
            instanceID = instance;
            threadID = thread;
            duration = interval;
        }

        public string Message
        {
            get { return message; }
            set { message = value; }
        }

        public DateTime TimeStamp
        {
            get { return timestamp; }
            set { timestamp = value; }
        }

        public string InstanceID
        {
            get { return instanceID; }
            set { instanceID = value; }
        }

        public string ThreadID
        {
            get { return threadID; }
            set { threadID = value; }
        }

        public string MachineName
        {
            get { return machineName; }
            set { machineName = value; }
        }

        public TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\Engine.cpp ===
#include "Engine.h"
#include "FBLogFile.h"
#include "FBServerDB.h"

extern FWriter reportfile;

Engine::Engine()
{
}

Engine::~Engine()
{
}

void Engine::LoadFileToDB(char * szfile,char* Tablename)
{
	FBRecord rec;
	FBServerDB dbobj;
	FBLogFile  Logfile; 

	dbobj.Init(); // Open database.
	Logfile.Init(szfile); // load log file

	while(!Logfile.IsEOF())
	{
		rec=Logfile.NextPUID();
		if(dbobj.AddRec (rec,Tablename)==-1)
		{
			printf("Bad Rec in %s ",szfile);
		}
	}

	Logfile.UnInit();
	dbobj.UnInit ();


}

void Engine::ClearDB()
{
	FBServerDB dbobj;

	dbobj.Init();
	try
	{
	dbobj.ClearAll ("[FBServer].[dbo].[Feedback]");
	dbobj.ClearAll ("[FBServer].[dbo].[p200]");
	}catch(...)
	{
		// error
	}
	dbobj.UnInit ();

}

int Engine::NickNameCount(char * name)
{
	int count;
	FBServerDB dbobj;

	dbobj.Init();
	count = dbobj.Getcount(name);
	dbobj.UnInit ();
	return count;
}

void Engine::Stats()
{
	FBServerDB dbobj;
	char tmp[500];

	dbobj.Init();

	sprintf(tmp," Total records ON Server: %d\n",dbobj.Count("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG Nickname Server: %d \n",dbobj.Nickname ("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG GamePlay Server: %d \n",dbobj.GamePlay ("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG Screaming Server: %d \n",dbobj.Screaming("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG Harassment Server: %d \n",dbobj.Harassment("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total NEG Lewdness Server: %d \n",dbobj.Lewdness("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total POS Attitude Server: %d \n",dbobj.Attitude("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total POS Session Server: %d \n",dbobj.Session("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total Invalid Feedback Server: %d \n",dbobj.BadType("[FBServer].[dbo].[Feedback]"));
	reportfile.writeLine(tmp);

	///////////
	sprintf(tmp," Total records ON Client: %d\n",dbobj.Count("[FBServer].[dbo].[p200]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG Nickname Client: %d \n",dbobj.Nickname ("[FBServer].[dbo].[p200]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total NEG GamePlay Client: %d \n",dbobj.GamePlay ("[FBServer].[dbo].[p200]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG Screaming Client: %d \n",dbobj.Screaming("[FBServer].[dbo].[p200]"));
	reportfile.writeLine(tmp);
	sprintf(tmp," Total NEG Harassment Client: %d \n",dbobj.Harassment("[FBServer].[dbo].[p200]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total NEG Lewdness Client: %d \n",dbobj.Lewdness("[FBServer].[dbo].[p200]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total POS Attitude Client: %d \n",dbobj.Attitude("[FBServer].[dbo].[p200]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total POS Session Client: %d \n",dbobj.Session("[FBServer].[dbo].[p200]"));
	reportfile.writeLine (tmp);
	sprintf(tmp," Total Invalid Feedback Client: %d \n",dbobj.BadType("[FBServer].[dbo].[p200]"));
	reportfile.writeLine (tmp);




	dbobj.UnInit ();

}

/*void Engine::VerifyClientLog(char* szfile)
{
	FBRecord rec;
	FBServerDB dbobj;
	FBLogFile  Logfile; 

	dbobj.Init(); // Open database.
	Logfile.Init(szfile); // load log file

	int TotalCount =0;
	int RecFound=0;

	while(!Logfile.IsEOF())
	{
		TotalCount++;
		rec=Logfile.NextPUID();
		if(dbobj.FindRec (rec)==0)
			RecFound++;	
	}

	Logfile.UnInit();
	dbobj.UnInit ();

	printf("Total Rec : %d\tRecFound: %d\n",TotalCount,RecFound);

}
*/

void Engine::LoadAllFileToDB(char * szdir,char * Wildcard,char* Tablename)
{
	WIN32_FIND_DATA tmpFileData; 
	HANDLE hSearch; 
	int fno=0;
	char szdata[MAX_PATH];
	BOOL fFinished = FALSE; 

	strcpy(szdata,szdir);
	strcat(szdata,"\\");
	strcat(szdata,Wildcard);
	hSearch = FindFirstFile(szdata, &tmpFileData); 
	if (hSearch != INVALID_HANDLE_VALUE) 
	{ 
		while (!fFinished) 
		{
			fno++;
			strcpy(szdata,szdir);
			strcat(szdata,"\\");
			strcat(szdata,tmpFileData.cFileName);
			LoadFileToDB(szdata,Tablename);

			if (!FindNextFile(hSearch, &tmpFileData)) 
			{
				if (GetLastError() == ERROR_NO_MORE_FILES) 
				{ 
					fFinished=true;
				} 
				
			}
		

		}
	}
	FindClose(hSearch);

}


/*void Engine::VerifyALL(char * szdir,char * Wildcard)
{
	WIN32_FIND_DATA tmpFileData; 
	HANDLE hSearch; 
	int fno=0;
	char szdata[MAX_PATH];
	BOOL fFinished = FALSE; 

	strcpy(szdata,szdir);
	strcat(szdata,"\\");
	strcat(szdata,Wildcard);
	hSearch = FindFirstFile(szdata, &tmpFileData); 
	if (hSearch != INVALID_HANDLE_VALUE) 
	{ 
		while (!fFinished) 
		{
			fno++;
			strcpy(szdata,szdir);
			strcat(szdata,"\\");
			strcat(szdata,tmpFileData.cFileName);
			VerifyClientLog(szdata);

			if (!FindNextFile(hSearch, &tmpFileData)) 
			{
				if (GetLastError() == ERROR_NO_MORE_FILES) 
				{ 
					fFinished=true;
				} 
				
			}
		

		}
	}
	FindClose(hSearch);


}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\UserAccount.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace UserAccount {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback LinkUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback LinkedGamerTagsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserSettingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetInfoSharingOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAccountStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
        
        /// <remarks/>
        public UserAccount() {
            this.Url = "http://xewbcaiis001:12000/UserAccount/UserAccount.asmx";
        }
        
        /// <remarks/>
        public event LinkUserCompletedEventHandler LinkUserCompleted;
        
        /// <remarks/>
        public event LinkedGamerTagsCompletedEventHandler LinkedGamerTagsCompleted;
        
        /// <remarks/>
        public event GetUserSettingsCompletedEventHandler GetUserSettingsCompleted;
        
        /// <remarks/>
        public event SetInfoSharingCompletedEventHandler SetInfoSharingCompleted;
        
        /// <remarks/>
        public event GetAccountStatusCompletedEventHandler GetAccountStatusCompleted;
        
        /// <remarks/>
        public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkUser", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool LinkUser([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
            object[] results = this.Invoke("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLinkUser(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndLinkUser(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void LinkUserAsync(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
            this.LinkUserAsync(WebID, GamerTag, Owner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CardNumber, null);
        }
        
        /// <remarks/>
        public void LinkUserAsync(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, object userState) {
            if ((this.LinkUserOperationCompleted == null)) {
                this.LinkUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkUserOperationCompleted);
            }
            this.InvokeAsync("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber}, this.LinkUserOperationCompleted, userState);
        }
        
        private void OnLinkUserOperationCompleted(object arg) {
            if ((this.LinkUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LinkUserCompleted(this, new LinkUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID) {
            object[] results = this.Invoke("LinkedGamerTags", new object[] {
                        WebID});
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLinkedGamerTags(byte[] WebID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LinkedGamerTags", new object[] {
                        WebID}, callback, asyncState);
        }
        
        /// <remarks/>
        public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void LinkedGamerTagsAsync(byte[] WebID) {
            this.LinkedGamerTagsAsync(WebID, null);
        }
        
        /// <remarks/>
        public void LinkedGamerTagsAsync(byte[] WebID, object userState) {
            if ((this.LinkedGamerTagsOperationCompleted == null)) {
                this.LinkedGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkedGamerTagsOperationCompleted);
            }
            this.InvokeAsync("LinkedGamerTags", new object[] {
                        WebID}, this.LinkedGamerTagsOperationCompleted, userState);
        }
        
        private void OnLinkedGamerTagsOperationCompleted(object arg) {
            if ((this.LinkedGamerTagsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LinkedGamerTagsCompleted(this, new LinkedGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserSettings", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint GetUserSettings([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag) {
            object[] results = this.Invoke("GetUserSettings", new object[] {
                        WebID,
                        GamerTag});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserSettings(byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserSettings", new object[] {
                        WebID,
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndGetUserSettings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserSettingsAsync(byte[] WebID, string GamerTag) {
            this.GetUserSettingsAsync(WebID, GamerTag, null);
        }
        
        /// <remarks/>
        public void GetUserSettingsAsync(byte[] WebID, string GamerTag, object userState) {
            if ((this.GetUserSettingsOperationCompleted == null)) {
                this.GetUserSettingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserSettingsOperationCompleted);
            }
            this.InvokeAsync("GetUserSettings", new object[] {
                        WebID,
                        GamerTag}, this.GetUserSettingsOperationCompleted, userState);
        }
        
        private void OnGetUserSettingsOperationCompleted(object arg) {
            if ((this.GetUserSettingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserSettingsCompleted(this, new GetUserSettingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/SetInfoSharing", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool SetInfoSharing([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
            object[] results = this.Invoke("SetInfoSharing", new object[] {
                        WebID,
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetInfoSharing(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetInfoSharing", new object[] {
                        WebID,
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndSetInfoSharing(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void SetInfoSharingAsync(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
            this.SetInfoSharingAsync(WebID, GamerTag, acceptMSInfo, acceptPartnerInfo, null);
        }
        
        /// <remarks/>
        public void SetInfoSharingAsync(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo, object userState) {
            if ((this.SetInfoSharingOperationCompleted == null)) {
                this.SetInfoSharingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetInfoSharingOperationCompleted);
            }
            this.InvokeAsync("SetInfoSharing", new object[] {
                        WebID,
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo}, this.SetInfoSharingOperationCompleted, userState);
        }
        
        private void OnSetInfoSharingOperationCompleted(object arg) {
            if ((this.SetInfoSharingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetInfoSharingCompleted(this, new SetInfoSharingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetAccountStatus", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserAccountStatus GetAccountStatus([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        WebID,
                        GamerTag});
            return ((UserAccountStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        WebID,
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserAccountStatus EndGetAccountStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserAccountStatus)(results[0]));
        }
        
        /// <remarks/>
        public void GetAccountStatusAsync(byte[] WebID, string GamerTag) {
            this.GetAccountStatusAsync(WebID, GamerTag, null);
        }
        
        /// <remarks/>
        public void GetAccountStatusAsync(byte[] WebID, string GamerTag, object userState) {
            if ((this.GetAccountStatusOperationCompleted == null)) {
                this.GetAccountStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountStatusOperationCompleted);
            }
            this.InvokeAsync("GetAccountStatus", new object[] {
                        WebID,
                        GamerTag}, this.GetAccountStatusOperationCompleted, userState);
        }
        
        private void OnGetAccountStatusOperationCompleted(object arg) {
            if ((this.GetAccountStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountStatusCompleted(this, new GetAccountStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserAuthorization", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserAuthorization GetUserAuthorization(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag) {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                        titleId,
                        webId,
                        gamerTag});
            return ((UserAuthorization)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserAuthorization(uint titleId, byte[] webId, string gamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserAuthorization", new object[] {
                        titleId,
                        webId,
                        gamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserAuthorization EndGetUserAuthorization(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserAuthorization)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(uint titleId, byte[] webId, string gamerTag) {
            this.GetUserAuthorizationAsync(titleId, webId, gamerTag, null);
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(uint titleId, byte[] webId, string gamerTag, object userState) {
            if ((this.GetUserAuthorizationOperationCompleted == null)) {
                this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
            }
            this.InvokeAsync("GetUserAuthorization", new object[] {
                        titleId,
                        webId,
                        gamerTag}, this.GetUserAuthorizationOperationCompleted, userState);
        }
        
        private void OnGetUserAuthorizationOperationCompleted(object arg) {
            if ((this.GetUserAuthorizationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class LinkInfo {
        
        private string gamerTagField;
        
        private bool ownerField;
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public bool Owner {
            get {
                return this.ownerField;
            }
            set {
                this.ownerField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class UserAuthorization {
        
        private bool acceptedTermsOfServiceField;
        
        private bool isVoiceBannedField;
        
        private bool isSuspendedField;
        
        private bool[] privilegesField;
        
        private uint[] servicesField;
        
        /// <remarks/>
        public bool acceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool isVoiceBanned {
            get {
                return this.isVoiceBannedField;
            }
            set {
                this.isVoiceBannedField = value;
            }
        }
        
        /// <remarks/>
        public bool isSuspended {
            get {
                return this.isSuspendedField;
            }
            set {
                this.isSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool[] privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint[] services {
            get {
                return this.servicesField;
            }
            set {
                this.servicesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public partial class UserAccountStatus {
        
        private bool acceptMSInfoField;
        
        private bool acceptPartnerInfoField;
        
        private bool forceNameChangeField;
        
        private bool voiceBannedField;
        
        private System.DateTime voiceBannedUntilField;
        
        private bool nicknameBannedField;
        
        private bool accountSuspendedField;
        
        private System.DateTime accountSuspendedUntilField;
        
        /// <remarks/>
        public bool acceptMSInfo {
            get {
                return this.acceptMSInfoField;
            }
            set {
                this.acceptMSInfoField = value;
            }
        }
        
        /// <remarks/>
        public bool acceptPartnerInfo {
            get {
                return this.acceptPartnerInfoField;
            }
            set {
                this.acceptPartnerInfoField = value;
            }
        }
        
        /// <remarks/>
        public bool forceNameChange {
            get {
                return this.forceNameChangeField;
            }
            set {
                this.forceNameChangeField = value;
            }
        }
        
        /// <remarks/>
        public bool voiceBanned {
            get {
                return this.voiceBannedField;
            }
            set {
                this.voiceBannedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime voiceBannedUntil {
            get {
                return this.voiceBannedUntilField;
            }
            set {
                this.voiceBannedUntilField = value;
            }
        }
        
        /// <remarks/>
        public bool nicknameBanned {
            get {
                return this.nicknameBannedField;
            }
            set {
                this.nicknameBannedField = value;
            }
        }
        
        /// <remarks/>
        public bool accountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime accountSuspendedUntil {
            get {
                return this.accountSuspendedUntilField;
            }
            set {
                this.accountSuspendedUntilField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LinkUserCompletedEventHandler(object sender, LinkUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LinkUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LinkUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LinkedGamerTagsCompletedEventHandler(object sender, LinkedGamerTagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LinkedGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LinkedGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LinkInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LinkInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserSettingsCompletedEventHandler(object sender, GetUserSettingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserSettingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserSettingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetInfoSharingCompletedEventHandler(object sender, SetInfoSharingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetInfoSharingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetInfoSharingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountStatusCompletedEventHandler(object sender, GetAccountStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAccountStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserAccountStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserAccountStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserAuthorization Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserAuthorization)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\CommonConfigTest\CommonConfigLoader.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Text;
//using xonline.common;
using xonline.common.config;
using System.Data.SqlClient;

namespace CommonConfigLoader
{
    [Serializable]
    public class CommonConfigLoader : MarshalByRefObject
    {
        public event EventHandler<InstanceEventArgs> InstanceCallback;
        public DateTime TestStartTime;
        public string SettingKey;
        public string ServerKey;
        public string InterfaceKey;
        public bool running;
        public Dictionary<long, long> Histogram;
        public List<long> Data = new List<long>();
        private Object threadLock = new Object();
        private float nanoSecperTick;

        public void Init()
        {
            //string NpdbServer = STF.common.config.Config.NpdbServer;
            //STF.common.config.Config.CheckForUpdates();

            foreach (string s in Setting.DynamicSettings)
            {
                try
                {
                    string temp = Config.GetSetting(s);
                }
                catch (Exception /*e*/)
                {
                    //Console.WriteLine(e.Message);
                }

                //Console.WriteLine(temp);
            }
            for (ulong i = 0; i < 419; i++)
            {
                uint partition = Config.GetBucketNum(Interface.xarbInh, i);
                IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, partition);
            }
            //Console.WriteLine(NpdbServer);

            return;
        }

        public void Init(int numSettings)
        {
            string[] dynamicSettings = Setting.DynamicSettings;

            for (int i=0; i < numSettings; i++)
            {
                try
                {
                    string temp = Config.GetSetting(dynamicSettings[i]);
                    //Console.WriteLine(temp);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                }

            }

            for (ulong i=0; i < 419; i++)
            {
                uint partition = Config.GetBucketNum(Interface.xarbInh, i);
                IBucketServer bucket = Config.GetBucketServer(Interface.xarbInh, partition);
            }

            return;
        }

        /// <summary>
        /// Subscribes to a list of custom settings plus an additional number of dynamic settings.
        /// </summary>
        /// <param name="customSettingList"></param>
        /// <param name="numAdditionalSettings"></param>
        public void Init(string[] customSettingList, int numAdditionalSettings)
        {
            Histogram = new Dictionary<long, long>();
            nanoSecperTick = (1000F * 1000F * 1000F) / System.Diagnostics.Stopwatch.Frequency;
            //Console.WriteLine("Frequency is {0} nanoseconds per tick. {1}", nanoSecperTick, System.Diagnostics.Stopwatch.Frequency);
            string iface = Interface.xarbInh;
            string[] dynamicSettings = Setting.DynamicSettings;
            //Subscribe to Dynamic Settings...
            for (int i = 0; i < numAdditionalSettings; i++)
            {
                try
                {
                    string temp = Config.GetSetting(dynamicSettings[i]);
                    //Console.WriteLine(temp);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                }

            }
            // Subscribe to custom dynamic settings...
            foreach (string s in customSettingList)
            {
                SettingChangeFilter.RegisterDynamicSetting(s);
                Config.GetSetting(s);
            }

            // Subscribe to interface buckets
            for (ulong i = 0; i < Config.GetBucketCount(iface); i++)
            {
                uint partition = Config.GetBucketNum(iface, i);
                IBucketServer bucket = Config.GetBucketServer(iface, partition);
            }

            //Virtual interfaces
            //string[] servers = Config.GetServerListByInterface(iface);
            //IVirtualInterfaceInfo virtualInfo = Config.GetVirtualInterface(VirtualInterface.authsg);

            for (int i=0;i<1;i++)
            {
                Thread a1 = new Thread(new ParameterizedThreadStart(WorkerLoop));
                a1.Start(i);
            }
        }

        void WorkerLoop(object ThreadID)
        {
            running = true;
            string currentSettingVal;
            DateTime currentServerVal;
            string currentInterfaceVal;
            string currentInterfaceBucketVal;
            long settingElapsedTime, serverElapsedTime, interfaceElapsedTime, interfaceBucketElapsedTime;
            while (running)
            {
                //DateTime start = DateTime.Now;
                System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch();
                watch.Start();
                //OnRaiseInstanceEvent(new InstanceEventArgs("Start", Environment.MachineName, AppDomain.CurrentDomain.FriendlyName, ThreadID.ToString()));
                //Console.WriteLine("{4} {0}:{1}.{2}.{3}", "Start", Environment.MachineName, AppDomain.CurrentDomain.FriendlyName, ThreadID.ToString(),DateTime.Now);
                //NPDBTest.logResult(DateTime.Now, "Start", Environment.MachineName, AppDomain.CurrentDomain.FriendlyName, ThreadID.ToString());
                currentSettingVal = Config.GetSetting(SettingKey);
                watch.Stop();
                settingElapsedTime = watch.ElapsedTicks;
                if (DateTime.Parse(currentSettingVal) < DateTime.Now.Subtract(new TimeSpan(0, 3, 0)))
                {
                    Console.WriteLine("GetSetting returned value over 3 mins old! {0} {1}", DateTime.Parse(currentSettingVal), DateTime.Now.Subtract(new TimeSpan(0, 3, 0)));
                }
                //NPDBTest.logResult(DateTime.Now, "Stop", Environment.MachineName, AppDomain.CurrentDomain.FriendlyName, ThreadID.ToString());
                //TimeSpan interval = new TimeSpan(start.Ticks - DateTime.Now.Ticks);
                //Data.Add(key);

                // Server List
                int siteId = 0;
                int serverId = 0;
                watch.Reset();
                watch.Start();
                Config.GetServerInfo(ServerKey, out siteId, out serverId);
                watch.Stop();
                serverElapsedTime = watch.ElapsedTicks;
                currentServerVal = NPDBTest.GetSecondsAsDateTime(this.TestStartTime, serverId);
                if (currentServerVal < DateTime.Now.Subtract(new TimeSpan(0, 3, 0)))
                {
                    Console.WriteLine("GetServerInfo returned value over 3 mins old! {0} {1}", currentServerVal, DateTime.Now.Subtract(new TimeSpan(0, 3, 0)));
                }

                // Interface List
                watch.Reset();
                watch.Start();
                IInterfaceInfo interfaceInfo = Config.GetInterface(ServerKey,InterfaceKey);
                watch.Stop();
                interfaceElapsedTime = watch.ElapsedTicks;
                if ((interfaceInfo != null) && (interfaceInfo.Info1 != null))
                {
                    currentInterfaceVal = interfaceInfo.Info1;
                    if (DateTime.Parse(currentInterfaceVal) < DateTime.Now.Subtract(new TimeSpan(0, 3, 0)))
                    {
                        Console.WriteLine("GetInterface returned value over 3 mins old! {0} {1}", currentInterfaceVal, DateTime.Now.Subtract(new TimeSpan(0, 3, 0)));
                    }
                }
                else
                {
                    Console.WriteLine("Could Not Retrieve the Interface ({0}).", InterfaceKey);
                }

                // Interface Bucket List
                watch.Reset();
                watch.Start();
                IBucketServer interfaceBucketInfo = Config.GetBucketServer(InterfaceKey,0);
                watch.Stop();
                interfaceBucketElapsedTime = watch.ElapsedTicks;
                if ((interfaceBucketInfo != null) && (interfaceBucketInfo.Info1 != null))
                {
                    currentInterfaceVal = interfaceBucketInfo.Info1;
                    if (DateTime.Parse(currentInterfaceVal) < DateTime.Now.Subtract(new TimeSpan(0, 3, 0)))
                    {
                        Console.WriteLine("GetInterface returned value over 3 mins old! {0} {1}", currentInterfaceVal, DateTime.Now.Subtract(new TimeSpan(0, 3, 0)));
                    }
                }
                else
                {
                    Console.WriteLine("Could Not Retrieve the Interface Bucket ({0}).", InterfaceKey);
                }

                lock (Histogram)
                {
                    long cnt;
                    long key = (long)((settingElapsedTime * nanoSecperTick)/10000);  // resolution is in 10s of microseconds
                    //int key = (int)watch.ElapsedMilliseconds;
                    if (Histogram.TryGetValue(key, out cnt))
                    {
                        cnt++;
                        Histogram[key] = cnt;
                    }
                    else
                    {
                        Histogram.Add(key, 1);
                    }
                    key = (long)((serverElapsedTime * nanoSecperTick) / 10000);  // resolution is in 10s of microseconds
                    //int key = (int)watch.ElapsedMilliseconds;
                    if (Histogram.TryGetValue(key, out cnt))
                    {
                        cnt++;
                        Histogram[key] = cnt;
                    }
                    else
                    {
                        Histogram.Add(key, 1);
                    }
                    key = (long)((interfaceElapsedTime * nanoSecperTick) / 10000);  // resolution is in 10s of microseconds
                    //int key = (int)watch.ElapsedMilliseconds;
                    if (Histogram.TryGetValue(key, out cnt))
                    {
                        cnt++;
                        Histogram[key] = cnt;
                    }
                    else
                    {
                        Histogram.Add(key, 1);
                    }
                }
                
                OnRaiseInstanceEvent(new InstanceEventArgs("Finish", Environment.MachineName, AppDomain.CurrentDomain.FriendlyName, ThreadID.ToString(),watch.Elapsed));
                Thread.Sleep(1);
            }
        }

        protected virtual void OnRaiseInstanceEvent(InstanceEventArgs e)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<InstanceEventArgs> handler = InstanceCallback;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(this, e);
            }
        }

        public void SetNPDBCallback(NPDBTest npdb)
        {
            npdb.InstanceCallback += new EventHandler<InstanceEventArgs>(npdb_InstanceCallback);
        }

        void npdb_InstanceCallback(object sender, InstanceEventArgs e)
        {
            if (e.Message == "Terminate")
            {
                running = false;
            }
        }


    }

    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\FBLogFile.h ===
//FBLogFile
#include "stdio.h"
#include "windows.h"
#include "FBServerDB.h"

class FWriter
{

	FILE* pFile;
	char* m_fname;
public:
	FWriter();
	FWriter(char * filename);
	~FWriter();
	int Init();
	writeLine(char * line);
	write(char* data);

};


class FBLogFile
{

protected:
	FILE *stream;
	ULONGLONG strtoull(char* data,char** end);
	virtual void Decode(const char * data , ULONGLONG* SendPUID,ULONGLONG* TargetPUID,unsigned int* TitleID,int* FBType,char* nickname);


public:
	FBLogFile();
	~FBLogFile();

	int Init(char* FileName);
	void UnInit();

	virtual FBRecord FirstRec(void){return FBRecord();}
	virtual FBRecord NextPUID();
	virtual int GetNext(char* rec);
	bool IsEOF();


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\common\wshelper\objd\i386\ToolsMgmt.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ToolsManagement {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ToolsMgmtSoap", Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ToolsMgmt : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetActionTableOperationCompleted;
        
        private System.Threading.SendOrPostCallback BeginWorkOperationCompleted;
        
        private System.Threading.SendOrPostCallback WorkFilesReadyOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetWorkStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddActionOperationCompleted;
        
        private System.Threading.SendOrPostCallback ExecuteJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetJobStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetActionStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetActionResultOperationCompleted;
        
        private System.Threading.SendOrPostCallback CleanupJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetJobLogOperationCompleted;
        
        /// <remarks/>
        public ToolsMgmt() {
            this.Url = "http://paulram002:12000/wctoolsmgmt/toolsmgmt.asmx";
        }
        
        /// <remarks/>
        public event GetActionTableCompletedEventHandler GetActionTableCompleted;
        
        /// <remarks/>
        public event BeginWorkCompletedEventHandler BeginWorkCompleted;
        
        /// <remarks/>
        public event WorkFilesReadyCompletedEventHandler WorkFilesReadyCompleted;
        
        /// <remarks/>
        public event GetWorkStatusCompletedEventHandler GetWorkStatusCompleted;
        
        /// <remarks/>
        public event CreateJobCompletedEventHandler CreateJobCompleted;
        
        /// <remarks/>
        public event AddActionCompletedEventHandler AddActionCompleted;
        
        /// <remarks/>
        public event ExecuteJobCompletedEventHandler ExecuteJobCompleted;
        
        /// <remarks/>
        public event CancelJobCompletedEventHandler CancelJobCompleted;
        
        /// <remarks/>
        public event GetJobStatusCompletedEventHandler GetJobStatusCompleted;
        
        /// <remarks/>
        public event GetActionStatusCompletedEventHandler GetActionStatusCompleted;
        
        /// <remarks/>
        public event GetActionResultCompletedEventHandler GetActionResultCompleted;
        
        /// <remarks/>
        public event CleanupJobCompletedEventHandler CleanupJobCompleted;
        
        /// <remarks/>
        public event GetJobLogCompletedEventHandler GetJobLogCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionTable", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetActionTable() {
            object[] results = this.Invoke("GetActionTable", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionTable(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionTable", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetActionTable(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionTableAsync() {
            this.GetActionTableAsync(null);
        }
        
        /// <remarks/>
        public void GetActionTableAsync(object userState) {
            if ((this.GetActionTableOperationCompleted == null)) {
                this.GetActionTableOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionTableOperationCompleted);
            }
            this.InvokeAsync("GetActionTable", new object[0], this.GetActionTableOperationCompleted, userState);
        }
        
        private void OnGetActionTableOperationCompleted(object arg) {
            if ((this.GetActionTableCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionTableCompleted(this, new GetActionTableCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/BeginWork", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public BeginWorkResult BeginWork(BeginWorkInfo bwi) {
            object[] results = this.Invoke("BeginWork", new object[] {
                        bwi});
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBeginWork(BeginWorkInfo bwi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BeginWork", new object[] {
                        bwi}, callback, asyncState);
        }
        
        /// <remarks/>
        public BeginWorkResult EndBeginWork(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public void BeginWorkAsync(BeginWorkInfo bwi) {
            this.BeginWorkAsync(bwi, null);
        }
        
        /// <remarks/>
        public void BeginWorkAsync(BeginWorkInfo bwi, object userState) {
            if ((this.BeginWorkOperationCompleted == null)) {
                this.BeginWorkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBeginWorkOperationCompleted);
            }
            this.InvokeAsync("BeginWork", new object[] {
                        bwi}, this.BeginWorkOperationCompleted, userState);
        }
        
        private void OnBeginWorkOperationCompleted(object arg) {
            if ((this.BeginWorkCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BeginWorkCompleted(this, new BeginWorkCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/WorkFilesReady", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public WorkFilesReadyResult WorkFilesReady(WorkFilesReadyInfo wfri) {
            object[] results = this.Invoke("WorkFilesReady", new object[] {
                        wfri});
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWorkFilesReady(WorkFilesReadyInfo wfri, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WorkFilesReady", new object[] {
                        wfri}, callback, asyncState);
        }
        
        /// <remarks/>
        public WorkFilesReadyResult EndWorkFilesReady(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public void WorkFilesReadyAsync(WorkFilesReadyInfo wfri) {
            this.WorkFilesReadyAsync(wfri, null);
        }
        
        /// <remarks/>
        public void WorkFilesReadyAsync(WorkFilesReadyInfo wfri, object userState) {
            if ((this.WorkFilesReadyOperationCompleted == null)) {
                this.WorkFilesReadyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWorkFilesReadyOperationCompleted);
            }
            this.InvokeAsync("WorkFilesReady", new object[] {
                        wfri}, this.WorkFilesReadyOperationCompleted, userState);
        }
        
        private void OnWorkFilesReadyOperationCompleted(object arg) {
            if ((this.WorkFilesReadyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WorkFilesReadyCompleted(this, new WorkFilesReadyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetWorkStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetWorkStatusResult GetWorkStatus(GetWorkStatusInfo gwsi) {
            object[] results = this.Invoke("GetWorkStatus", new object[] {
                        gwsi});
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetWorkStatus(GetWorkStatusInfo gwsi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetWorkStatus", new object[] {
                        gwsi}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetWorkStatusResult EndGetWorkStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public void GetWorkStatusAsync(GetWorkStatusInfo gwsi) {
            this.GetWorkStatusAsync(gwsi, null);
        }
        
        /// <remarks/>
        public void GetWorkStatusAsync(GetWorkStatusInfo gwsi, object userState) {
            if ((this.GetWorkStatusOperationCompleted == null)) {
                this.GetWorkStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetWorkStatusOperationCompleted);
            }
            this.InvokeAsync("GetWorkStatus", new object[] {
                        gwsi}, this.GetWorkStatusOperationCompleted, userState);
        }
        
        private void OnGetWorkStatusOperationCompleted(object arg) {
            if ((this.GetWorkStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetWorkStatusCompleted(this, new GetWorkStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CreateJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long CreateJob(string description, out JobInfo jobInfo) {
            object[] results = this.Invoke("CreateJob", new object[] {
                        description});
            jobInfo = ((JobInfo)(results[1]));
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateJob(string description, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateJob", new object[] {
                        description}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndCreateJob(System.IAsyncResult asyncResult, out JobInfo jobInfo) {
            object[] results = this.EndInvoke(asyncResult);
            jobInfo = ((JobInfo)(results[1]));
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void CreateJobAsync(string description) {
            this.CreateJobAsync(description, null);
        }
        
        /// <remarks/>
        public void CreateJobAsync(string description, object userState) {
            if ((this.CreateJobOperationCompleted == null)) {
                this.CreateJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateJobOperationCompleted);
            }
            this.InvokeAsync("CreateJob", new object[] {
                        description}, this.CreateJobOperationCompleted, userState);
        }
        
        private void OnCreateJobOperationCompleted(object arg) {
            if ((this.CreateJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateJobCompleted(this, new CreateJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/AddAction", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int AddAction(ActionInfo actionInfo) {
            object[] results = this.Invoke("AddAction", new object[] {
                        actionInfo});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddAction(ActionInfo actionInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddAction", new object[] {
                        actionInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndAddAction(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void AddActionAsync(ActionInfo actionInfo) {
            this.AddActionAsync(actionInfo, null);
        }
        
        /// <remarks/>
        public void AddActionAsync(ActionInfo actionInfo, object userState) {
            if ((this.AddActionOperationCompleted == null)) {
                this.AddActionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddActionOperationCompleted);
            }
            this.InvokeAsync("AddAction", new object[] {
                        actionInfo}, this.AddActionOperationCompleted, userState);
        }
        
        private void OnAddActionOperationCompleted(object arg) {
            if ((this.AddActionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddActionCompleted(this, new AddActionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/ExecuteJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ExecuteJob(long jobId) {
            object[] results = this.Invoke("ExecuteJob", new object[] {
                        jobId});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExecuteJob(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExecuteJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndExecuteJob(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ExecuteJobAsync(long jobId) {
            this.ExecuteJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void ExecuteJobAsync(long jobId, object userState) {
            if ((this.ExecuteJobOperationCompleted == null)) {
                this.ExecuteJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExecuteJobOperationCompleted);
            }
            this.InvokeAsync("ExecuteJob", new object[] {
                        jobId}, this.ExecuteJobOperationCompleted, userState);
        }
        
        private void OnExecuteJobOperationCompleted(object arg) {
            if ((this.ExecuteJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExecuteJobCompleted(this, new ExecuteJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CancelJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CancelJob(long jobId) {
            this.Invoke("CancelJob", new object[] {
                        jobId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelJob(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelJob(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CancelJobAsync(long jobId) {
            this.CancelJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void CancelJobAsync(long jobId, object userState) {
            if ((this.CancelJobOperationCompleted == null)) {
                this.CancelJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelJobOperationCompleted);
            }
            this.InvokeAsync("CancelJob", new object[] {
                        jobId}, this.CancelJobOperationCompleted, userState);
        }
        
        private void OnCancelJobOperationCompleted(object arg) {
            if ((this.CancelJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelJobCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetJobStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public JobState GetJobStatus(long jobId) {
            object[] results = this.Invoke("GetJobStatus", new object[] {
                        jobId});
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetJobStatus(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetJobStatus", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public JobState EndGetJobStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public void GetJobStatusAsync(long jobId) {
            this.GetJobStatusAsync(jobId, null);
        }
        
        /// <remarks/>
        public void GetJobStatusAsync(long jobId, object userState) {
            if ((this.GetJobStatusOperationCompleted == null)) {
                this.GetJobStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetJobStatusOperationCompleted);
            }
            this.InvokeAsync("GetJobStatus", new object[] {
                        jobId}, this.GetJobStatusOperationCompleted, userState);
        }
        
        private void OnGetJobStatusOperationCompleted(object arg) {
            if ((this.GetJobStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetJobStatusCompleted(this, new GetJobStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public JobState GetActionStatus(long jobId, int rank) {
            object[] results = this.Invoke("GetActionStatus", new object[] {
                        jobId,
                        rank});
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionStatus(long jobId, int rank, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionStatus", new object[] {
                        jobId,
                        rank}, callback, asyncState);
        }
        
        /// <remarks/>
        public JobState EndGetActionStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionStatusAsync(long jobId, int rank) {
            this.GetActionStatusAsync(jobId, rank, null);
        }
        
        /// <remarks/>
        public void GetActionStatusAsync(long jobId, int rank, object userState) {
            if ((this.GetActionStatusOperationCompleted == null)) {
                this.GetActionStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionStatusOperationCompleted);
            }
            this.InvokeAsync("GetActionStatus", new object[] {
                        jobId,
                        rank}, this.GetActionStatusOperationCompleted, userState);
        }
        
        private void OnGetActionStatusOperationCompleted(object arg) {
            if ((this.GetActionStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionStatusCompleted(this, new GetActionStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionResult", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ActionResult GetActionResult(long jobId, int rank) {
            object[] results = this.Invoke("GetActionResult", new object[] {
                        jobId,
                        rank});
            return ((ActionResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionResult(long jobId, int rank, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionResult", new object[] {
                        jobId,
                        rank}, callback, asyncState);
        }
        
        /// <remarks/>
        public ActionResult EndGetActionResult(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ActionResult)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionResultAsync(long jobId, int rank) {
            this.GetActionResultAsync(jobId, rank, null);
        }
        
        /// <remarks/>
        public void GetActionResultAsync(long jobId, int rank, object userState) {
            if ((this.GetActionResultOperationCompleted == null)) {
                this.GetActionResultOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionResultOperationCompleted);
            }
            this.InvokeAsync("GetActionResult", new object[] {
                        jobId,
                        rank}, this.GetActionResultOperationCompleted, userState);
        }
        
        private void OnGetActionResultOperationCompleted(object arg) {
            if ((this.GetActionResultCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionResultCompleted(this, new GetActionResultCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CleanupJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool CleanupJob(ulong jobId) {
            object[] results = this.Invoke("CleanupJob", new object[] {
                        jobId});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCleanupJob(ulong jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CleanupJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndCleanupJob(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void CleanupJobAsync(ulong jobId) {
            this.CleanupJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void CleanupJobAsync(ulong jobId, object userState) {
            if ((this.CleanupJobOperationCompleted == null)) {
                this.CleanupJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCleanupJobOperationCompleted);
            }
            this.InvokeAsync("CleanupJob", new object[] {
                        jobId}, this.CleanupJobOperationCompleted, userState);
        }
        
        private void OnCleanupJobOperationCompleted(object arg) {
            if ((this.CleanupJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CleanupJobCompleted(this, new CleanupJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetJobLog", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetJobLog(int jobId, out JobLogEntry[] jobLog) {
            object[] results = this.Invoke("GetJobLog", new object[] {
                        jobId});
            jobLog = ((JobLogEntry[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetJobLog(int jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetJobLog", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetJobLog(System.IAsyncResult asyncResult, out JobLogEntry[] jobLog) {
            object[] results = this.EndInvoke(asyncResult);
            jobLog = ((JobLogEntry[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetJobLogAsync(int jobId) {
            this.GetJobLogAsync(jobId, null);
        }
        
        /// <remarks/>
        public void GetJobLogAsync(int jobId, object userState) {
            if ((this.GetJobLogOperationCompleted == null)) {
                this.GetJobLogOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetJobLogOperationCompleted);
            }
            this.InvokeAsync("GetJobLog", new object[] {
                        jobId}, this.GetJobLogOperationCompleted, userState);
        }
        
        private void OnGetJobLogOperationCompleted(object arg) {
            if ((this.GetJobLogCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetJobLogCompleted(this, new GetJobLogCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class BeginWorkInfo {
        
        private uint workTypeField;
        
        private string titleIdField;
        
        /// <remarks/>
        public uint workType {
            get {
                return this.workTypeField;
            }
            set {
                this.workTypeField = value;
            }
        }
        
        /// <remarks/>
        public string titleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class JobLogEntry {
        
        private System.DateTime loggedField;
        
        private int levelField;
        
        private string logField;
        
        /// <remarks/>
        public System.DateTime logged {
            get {
                return this.loggedField;
            }
            set {
                this.loggedField = value;
            }
        }
        
        /// <remarks/>
        public int level {
            get {
                return this.levelField;
            }
            set {
                this.levelField = value;
            }
        }
        
        /// <remarks/>
        public string log {
            get {
                return this.logField;
            }
            set {
                this.logField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ActionResult {
        
        private JobState stateField;
        
        private int returnCodeField;
        
        private string consoleOutputField;
        
        /// <remarks/>
        public JobState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public int returnCode {
            get {
                return this.returnCodeField;
            }
            set {
                this.returnCodeField = value;
            }
        }
        
        /// <remarks/>
        public string consoleOutput {
            get {
                return this.consoleOutputField;
            }
            set {
                this.consoleOutputField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public enum JobState {
        
        /// <remarks/>
        Created,
        
        /// <remarks/>
        Pending,
        
        /// <remarks/>
        Download,
        
        /// <remarks/>
        Running,
        
        /// <remarks/>
        Canceled,
        
        /// <remarks/>
        Complete,
        
        /// <remarks/>
        Failed,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class Parameter {
        
        private string nameField;
        
        private string valueField;
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ActionInfo {
        
        private long jobIdField;
        
        private string toolFileNameField;
        
        private Parameter[] parametersField;
        
        private string[] filesField;
        
        /// <remarks/>
        public long jobId {
            get {
                return this.jobIdField;
            }
            set {
                this.jobIdField = value;
            }
        }
        
        /// <remarks/>
        public string toolFileName {
            get {
                return this.toolFileNameField;
            }
            set {
                this.toolFileNameField = value;
            }
        }
        
        /// <remarks/>
        public Parameter[] parameters {
            get {
                return this.parametersField;
            }
            set {
                this.parametersField = value;
            }
        }
        
        /// <remarks/>
        public string[] files {
            get {
                return this.filesField;
            }
            set {
                this.filesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class JobInfo {
        
        private long jobIdField;
        
        private ulong spaceAvailableField;
        
        private string uploadPathField;
        
        /// <remarks/>
        public long jobId {
            get {
                return this.jobIdField;
            }
            set {
                this.jobIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong spaceAvailable {
            get {
                return this.spaceAvailableField;
            }
            set {
                this.spaceAvailableField = value;
            }
        }
        
        /// <remarks/>
        public string uploadPath {
            get {
                return this.uploadPathField;
            }
            set {
                this.uploadPathField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class GetWorkStatusResult {
        
        private bool workCompleteField;
        
        private int returnCodeField;
        
        private string consoleOutputField;
        
        /// <remarks/>
        public bool workComplete {
            get {
                return this.workCompleteField;
            }
            set {
                this.workCompleteField = value;
            }
        }
        
        /// <remarks/>
        public int returnCode {
            get {
                return this.returnCodeField;
            }
            set {
                this.returnCodeField = value;
            }
        }
        
        /// <remarks/>
        public string consoleOutput {
            get {
                return this.consoleOutputField;
            }
            set {
                this.consoleOutputField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class GetWorkStatusInfo {
        
        private ulong workIdField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class WorkFilesReadyResult {
        
        private bool successField;
        
        /// <remarks/>
        public bool success {
            get {
                return this.successField;
            }
            set {
                this.successField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class WorkFilesReadyInfo {
        
        private ulong workIdField;
        
        private string relativePathField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
        
        /// <remarks/>
        public string relativePath {
            get {
                return this.relativePathField;
            }
            set {
                this.relativePathField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class BeginWorkResult {
        
        private ulong workIdField;
        
        private ulong spaceAvailableField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong spaceAvailable {
            get {
                return this.spaceAvailableField;
            }
            set {
                this.spaceAvailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionTableCompletedEventHandler(object sender, GetActionTableCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionTableCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionTableCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BeginWorkCompletedEventHandler(object sender, BeginWorkCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BeginWorkCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BeginWorkCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public BeginWorkResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((BeginWorkResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WorkFilesReadyCompletedEventHandler(object sender, WorkFilesReadyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WorkFilesReadyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WorkFilesReadyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public WorkFilesReadyResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WorkFilesReadyResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetWorkStatusCompletedEventHandler(object sender, GetWorkStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetWorkStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetWorkStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetWorkStatusResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetWorkStatusResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateJobCompletedEventHandler(object sender, CreateJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public JobInfo jobInfo {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobInfo)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddActionCompletedEventHandler(object sender, AddActionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddActionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddActionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ExecuteJobCompletedEventHandler(object sender, ExecuteJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ExecuteJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ExecuteJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelJobCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetJobStatusCompletedEventHandler(object sender, GetJobStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetJobStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetJobStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public JobState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionStatusCompletedEventHandler(object sender, GetActionStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public JobState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionResultCompletedEventHandler(object sender, GetActionResultCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionResultCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionResultCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ActionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ActionResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CleanupJobCompletedEventHandler(object sender, CleanupJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CleanupJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CleanupJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetJobLogCompletedEventHandler(object sender, GetJobLogCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetJobLogCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetJobLogCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public JobLogEntry[] jobLog {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobLogEntry[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\FBLogFile.cpp ===
#include "FBLogFile.h"



ULONGLONG FBLogFile::strtoull(char* data,char** end)
{
	ULONGLONG val=0;
	char ch;

	for(;(ch=*data)!='\0';data++)
	{

		
		if(ch>='0' && ch<='9')
		{
			val= val*16+(ch-'0');
		}
		else if(ch>='A'&&ch<='F')
		{
			val = val*16 + 10+ (ch-'A');
		}
		else if(ch>='a'&&ch<='f')
		{
			val = val*16 + 10+ (ch-'a');
		}
		else
			break;


	}

	*end= data;
    return val;
}


void FBLogFile::Decode(const char * data , ULONGLONG* SendPUID,ULONGLONG* TargetPUID,unsigned int* TitleID,int* FBType,char* nickname)
{
	char* tmp;
	int retval=0;

	retval=strlen(data);
	if(retval>2)
	{
			tmp = strstr(data,"0x");

		if(tmp !=NULL)
		{
			retval=0;
			retval = strlen(tmp);
			if(retval >2)
				*SendPUID=strtoull(tmp+2,&tmp);

			retval=0;
			retval = strlen(tmp);
			if(retval>3)
				*TargetPUID=strtoull(tmp+3,&tmp);

			retval=0;
			retval = strlen(tmp);
			if(retval>3)
				*TitleID=strtoull(tmp+3,&tmp);

			retval=0;
			retval = strlen(tmp);
			if(retval>1)
				*FBType=strtoull(tmp+1,&tmp);

			retval=0;
			retval = strlen(tmp);
			if(retval>1)
				strcpy(nickname,tmp+1);
		}
	}
}


FBLogFile::FBLogFile()
{
	stream = NULL;
}

FBLogFile::~FBLogFile()
{
	if(stream !=NULL)
		if( fclose( stream ) );
}

int FBLogFile::Init(char* FileName)
{
	if( (stream  = fopen( FileName, "r" )) == NULL ) 
		return -1;

	return 0;
}

void  FBLogFile::UnInit()
{
	


	if(stream !=NULL)
		fclose( stream );
		  
	stream = NULL;
}


FBRecord FBLogFile::NextPUID()
{
	FBRecord tmp;
	char str[400];

	GetNext(str);
	Decode(str,&tmp.SendPUID,&tmp.TargetPUID,&tmp.TitleID,&tmp.FBType,tmp.sznickname);

	return  tmp;

}

int FBLogFile::GetNext(char* rec)
{
	char	ch[2];
	int nord;
	ch[1]='\0'; 
	rec[0]='\0';
	
	while(ch[0]!=10 && !feof( stream ))
	{
		if(nord = fread(ch,sizeof(char),1,stream) !=1)
		{
			if( ferror( stream ) ) 
			{
				printf( "Read error" );
				return false;
			}
      
		}
		
		if(ch[0]!=10)
		{
			strcat(rec,ch);
		}
	}
	
	
	return true;
} 


bool FBLogFile::IsEOF()
{
	if(feof( stream ))
		return true;
	else
		return false;
}


/////////////writer class


FWriter::FWriter()
{
	m_fname=NULL;
}

FWriter::FWriter(char * filename)
{
	m_fname= filename;
}

FWriter::~FWriter()
{
	if(pFile!=NULL)
		fclose(pFile);
}

int FWriter::Init()
{
	if(m_fname!=NULL)
	{
		
		pFile =fopen(m_fname,"w+t");
		
	}
	return 1;
}

int FWriter::writeLine(char * line)
{
	int nowritten;
	if(pFile!=NULL)
	{
		if(strlen(line)>0)
		{
			nowritten = fputs( line, pFile );
			nowritten =fputs( "\n", pFile );
		}
	}
	
	return 1;
}

int FWriter::write(char* sdata )
{
	int nowritten;
	if(pFile!=NULL)
	{
		if(strlen(sdata)>0)
		{
			nowritten = fputs( sdata, pFile );
			
		}
	}
	
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\Report.cpp ===
//Report
#include "FBLogFile.h"
#include "Report.h"
#include "comutil.h"

extern FWriter glogfile;
extern FWriter reportfile;



void Report:: Parse_Print(_bstr_t sendPuid,_bstr_t TargetPuid,long Titleid ,int FBType, _bstr_t Nickname)
{
	char data[300];
	char temp[256];
	char *t1 ,*m_szNickname;
	ULONGLONG val;


	val = _atoi64((char*)sendPuid);
	_ui64toa(val,temp,16);
	strcpy(data,"0x");
	strcat(data,temp);
	strcat(data,":");

	if(val!=0)
	{

		val = _atoi64((char*)TargetPuid);
		_ui64toa(val,temp,16);
		strcat(data,"0x");
		strcat(data,temp);
		strcat(data,",");

		_ui64toa(Titleid ,temp,16);
		strcat(data,"0x");
		strcat(data,temp);
		strcat(data,",");

		_itoa(FBType,temp,10);
		strcat(data,temp);
		
		m_szNickname= (char*)Nickname;
		if(m_szNickname!= NULL && strlen(m_szNickname)>0)
		{
			strcat(data,",");
			strcat(data,m_szNickname);
			
		}
		

		glogfile.writeLine (data);
	}

}

Report::Report():strCnn("Provider=sqloledb;Data Source=pankajndbox;Initial Catalog=FBServer;User Id=test;Password=;")
{



}


int Report::Init()
{
	try
	{
		HRESULT hr = S_OK;
		hr = pConnection.CreateInstance(__uuidof(Connection));
		
		if(FAILED(hr))
		  return -1;
		hr = pConnection->Open(strCnn,"","",adConnectUnspecified);
      
		if(FAILED(hr))
		  return -1;

		pConnection->CommandTimeout = 120;
	}catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

Report::~Report()
{
	
	HRESULT hr = S_OK;

	try
	{
		
		 hr =pConnection->Close(); 
	}
	catch(_com_error &e)
	{
	 // handle error	
	}
	
}
int Report::NOof500RecFound()
{
	HRESULT hr;
	int count =0;
	_RecordsetPtr prec;
	string Query= "SELECT * from [p500] where [p500].[SendPuid] NOT IN (Select [p200].[SendPuid] from [p200]) and [p500].[SendPuid] IN (Select [Feedback].[SendPuid] from [Feedback])";
	
	try
	{
		prec =pConnection->Execute(Query.data(),NULL,adCmdText);
		int count=prec->GetRecordCount();
		hr=prec->MoveFirst();
		//for (int i=0;i<count;i++)
		glogfile.writeLine ("No of 500 BAD request found on server :-");
		while(!prec->EndOfFile)
		{
			count++;
			
			_bstr_t send,target, Nickname;
			int titleid,type ;
			
			send = (_bstr_t)prec->Fields->Item[0L]->Value;
			target= (_bstr_t)(prec->Fields->Item[1L]->Value);
			titleid= (long)prec->Fields->Item[2L]->Value;
			type= (long) prec->Fields->Item[3L]->Value;
			Nickname = (_bstr_t)prec->Fields->Item[4L]->Value;
			
			
			Parse_Print(send,target,titleid,type,Nickname);
			
			hr= prec->MoveNext();
			
		}
		char tmp [200];
		sprintf(tmp,"No of 500 Bad request found on server:- %d",count);
		reportfile.writeLine (tmp);

	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;

}

int Report::RecordNotFound()
{
	HRESULT hr;
	int count =0;
	_RecordsetPtr prec;
	string Query= "SELECT * from [p200] where [p200].[SendPuid] not IN (Select [Feedback].[SendPuid] from [Feedback])";
	
	try
	{
		prec =pConnection->Execute(Query.data(),NULL,adCmdText);
		int count=prec->GetRecordCount();
		hr=prec->MoveFirst();
		//for (int i=0;i<count;i++)
		glogfile.writeLine ("Records sent by client but not found on server :-");
		while(!prec->EndOfFile)
		{
			count++;
			
			_bstr_t send,target, Nickname;
			int titleid,type ;
			
			send = (_bstr_t)prec->Fields->Item[0L]->Value;
			target= (_bstr_t)(prec->Fields->Item[1L]->Value);
			titleid= (long)prec->Fields->Item[2L]->Value;
			type= (long) prec->Fields->Item[3L]->Value;
			Nickname = (_bstr_t)prec->Fields->Item[4L]->Value;
			
			Parse_Print(send,target,titleid,type,Nickname);
			
			hr= prec->MoveNext();
			
		}
		char tmp [200];
		sprintf(tmp,"Records missing on server:- %d",count);
		reportfile.writeLine (tmp);

	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;

}

Report::ErrorRecords()
{
	HRESULT hr;
	int count =0;
	_RecordsetPtr prec;
	char Query[]=  "difference"; 
	
	try
	{
		glogfile.writeLine ("Corrupt Records on server :-");
		prec =pConnection->Execute(Query,NULL,adCmdStoredProc);
		int count=prec->GetRecordCount();
		hr=prec->MoveFirst();
		//for (int i=0;i<count;i++)
		while(!prec->EndOfFile)
		{
			_bstr_t send,target, Nickname;
			int titleid,type ;
			count++;
			send = (_bstr_t)prec->Fields->Item[0L]->Value;
			target= (_bstr_t)(prec->Fields->Item[1L]->Value);
			titleid= (long)prec->Fields->Item[2L]->Value;
			type= (long) prec->Fields->Item[3L]->Value;
			Nickname = (_bstr_t)prec->Fields->Item[4L]->Value;
			
			Parse_Print(send,target,titleid,type,Nickname);
			
			hr= prec->MoveNext();
			
		}

		char tmp [200];
		sprintf(tmp,"Corrupt Records on server:-%d",count);
		reportfile.writeLine (tmp);
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	catch(...)
	{
		// error
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\FBServerDB.h ===
//FBServerDB

#include "windows.h"
#import "C:\Program Files\Common Files\System\ADO\msado15.dll" \
    no_namespace rename("EOF", "EndOfFile")

#pragma warning (disable:4786)
#include <list>
#include <string>
#include <iostream>

using namespace std ;

#ifndef FBSERVERDB
#define FBSERVERDB
class FBRecord
{

public:
	ULONGLONG SendPUID,TargetPUID;
	unsigned int TitleID;
	int FBType;
	char sznickname[256];

	// function
	FBRecord();
	FBRecord(FBRecord&);
	~FBRecord();
	FBRecord operator=(FBRecord&);

};







class FBServerDB
{
	_ConnectionPtr pConnection;
	_bstr_t strCnn;

public:
	FBServerDB();
	~FBServerDB();
	int Init();
	int UnInit();
	int AddRec( FBRecord&,char* Tablename );
	int FindRec(FBRecord&);
	int ClearAll(char* Tablename);
	int Getcount(char* nickname);
	// all the functions returns no of records in the table.
	int Count(char* Tablename);
	int Nickname(char* Tablename);
	int GamePlay(char* Tablename);
	int Screaming(char* Tablename);
	int Harassment(char* Tablename);
	int Lewdness(char* Tablename);
	int Attitude(char* Tablename);
	int Session(char* Tablename);
	int BadType(char* Tablename);
};


#endif FBSERVERDB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\CommonConfigTest\NPDBTest.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Text;
//using xonline.common;
using xonline.common.config;
using System.Data.SqlClient;

namespace CommonConfigLoader
{
    [Serializable]
    public class NPDBTest
    {
        public DateTime TestStartTime;
        public static string SettingKey;
        public static string SettingValue;
        public string[] SettingList = { "Test1" };
        public static string ServerKey;
        public static string ServerValue;
        public string[] ServerList = { "TestServer1" };
        public static string InterfaceKey;
        public static string InterfaceValue;
        public string[] InterfaceList = { "TestInterface1" };
        public static string InterfaceBucketKey;
        public static string InterfaceBucketValue;
        public Dictionary<long, long> Histogram;
        public List<CommonConfigLoader> Instances;
        public Timer UpdateTimer;

        public event EventHandler<InstanceEventArgs> InstanceCallback;

        public NPDBTest()
        {
            UpdateTimer = new Timer(new TimerCallback(UpdateTimer_tick));

        }


        static void Main(string[] args)
        {
            ///////////////////////////////
            if (System.Diagnostics.Stopwatch.IsHighResolution)
            {
                Console.WriteLine("Operations timed using the system's high-resolution performance counter.");
            }
            else
            {
                Console.WriteLine("Operations timed using the DateTime class.");
            }

            long frequency = System.Diagnostics.Stopwatch.Frequency;
            Console.WriteLine("  Timer frequency in ticks per second = {0}",
                frequency);
            float nanosecPerTick = (1000F * 1000F * 1000F) / frequency;
            Console.WriteLine("  Timer is accurate within {0} nanoseconds",
                nanosecPerTick);

            ///////////////////////////////
            int poolSize = 0;

            NPDBTest npdbTest = new NPDBTest();
            npdbTest.TestStartTime = DateTime.Now;

            npdbTest.Histogram = new Dictionary<long, long>();
            npdbTest.CreateSetting(npdbTest.SettingList[0], "test");
            NPDBTest.SettingKey = npdbTest.SettingList[0];
            npdbTest.CreateServer(npdbTest.ServerList[0], GetDateTimeAsInt(DateTime.Now, npdbTest.TestStartTime));
            NPDBTest.ServerKey = npdbTest.ServerList[0];
            npdbTest.CreateInterface(npdbTest.InterfaceList[0], npdbTest.ServerList[0], "test");
            NPDBTest.InterfaceKey = npdbTest.InterfaceList[0];
            npdbTest.CreateInterfaceBucket(npdbTest.InterfaceList[0], npdbTest.ServerList[0], "test");


            if (args.Length == 1)
            {
                poolSize = Convert.ToInt32(args[0]);
            }
            else
            {
                return;
            }

            if (poolSize == 0)
            {
                npdbTest.Instances = new List<CommonConfigLoader>(1);

                CommonConfigLoader config = new CommonConfigLoader();
                npdbTest.Instances.Add(config);
                config.TestStartTime = npdbTest.TestStartTime;
                config.SettingKey = npdbTest.SettingList[0];
                config.ServerKey = npdbTest.ServerList[0];
                config.InterfaceKey = npdbTest.InterfaceList[0];
                config.InstanceCallback += new EventHandler<InstanceEventArgs>(npdbTest.config_InstanceCallback);
                Config.InterfaceChange += new InterfaceChangeEventHandler(interfaceChangeCallback);
                Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(interfacebucketChangeCallback);
                config.SetNPDBCallback(npdbTest);

                npdbTest.UpdateSetting(npdbTest.SettingList[0], DateTime.Now.ToString());
                npdbTest.UpdateServer(npdbTest.ServerList[0], GetDateTimeAsInt(DateTime.Now, npdbTest.TestStartTime));
                npdbTest.UpdateInterface(npdbTest.InterfaceList[0], DateTime.Now.ToString());
                npdbTest.UpdateInterfaceBucket(npdbTest.InterfaceList[0], DateTime.Now.ToString());

                // Start Timer...
                npdbTest.UpdateTimer.Change(30000, 30000);

                // Start up each item closer to the same time...
                CommonConfigLoader item = config;
                item.Init(npdbTest.SettingList, 10);
                //Thread.Sleep(20000);
                //npdbTest.UpdateSetting(npdbTest.SettingList[0], DateTime.Now.ToLongDateString());



                //Console.Write("Hit Enter to quit");
                Console.ReadLine();
                npdbTest.UpdateTimer.Dispose();  // Stop the timer
                npdbTest.OnRaiseInstanceEvent(new InstanceEventArgs("Terminate"));

                //Console.WriteLine("--------------------------");
                try
                {
                    item.running = false;
                    //combine results

                    foreach (KeyValuePair<long, long> entry in item.Histogram)
                    {
                        //Console.WriteLine("{0} : {1}", entry.Key, entry.Value);
                        long cnt;
                        if (npdbTest.Histogram.TryGetValue(entry.Key, out cnt))
                        {
                            npdbTest.Histogram[entry.Key] = cnt + entry.Value;
                        }
                        else
                        {
                            npdbTest.Histogram.Add(entry.Key, entry.Value);
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Lost reference to item." + e.Message);
                }
            }
            else
            {
                npdbTest.Instances = new List<CommonConfigLoader>(poolSize);

                for (int iConns = 0; iConns < poolSize; iConns++)
                {
                    npdbTest.CreateInstance(iConns);
                }
                npdbTest.UpdateSetting(npdbTest.SettingList[0], DateTime.Now.ToString());
                npdbTest.UpdateServer(npdbTest.ServerList[0], GetDateTimeAsInt(DateTime.Now, npdbTest.TestStartTime));
                npdbTest.UpdateInterface(npdbTest.InterfaceList[0], DateTime.Now.ToString());
                npdbTest.UpdateInterfaceBucket(npdbTest.InterfaceList[0], DateTime.Now.ToString());

                // Start Timer...
                npdbTest.UpdateTimer.Change(30000, 30000);

                // Start up each item closer to the same time...
                foreach (CommonConfigLoader item in npdbTest.Instances)
                {
                    item.Init(npdbTest.SettingList, 10);
                }
                //Thread.Sleep(20000);
                //npdbTest.UpdateSetting(npdbTest.SettingList[0], DateTime.Now.ToLongDateString());



                //Console.Write("Hit Enter to quit");
                Console.ReadLine();
                npdbTest.UpdateTimer.Dispose();  // Stop the timer
                npdbTest.OnRaiseInstanceEvent(new InstanceEventArgs("Terminate"));

                //Console.WriteLine("--------------------------");
                foreach (CommonConfigLoader item in npdbTest.Instances)
                {
                    try
                    {
                        item.running = false;
                        //combine results

                        foreach (KeyValuePair<long, long> entry in item.Histogram)
                        {
                            //Console.WriteLine("{0} : {1}", entry.Key, entry.Value);
                            long cnt;
                            if (npdbTest.Histogram.TryGetValue(entry.Key, out cnt))
                            {
                                npdbTest.Histogram[entry.Key] = cnt + entry.Value;
                            }
                            else
                            {
                                npdbTest.Histogram.Add(entry.Key, entry.Value);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Lost reference to item." + e.Message);
                    }
                }
            }
            Console.WriteLine("--------------------------");
            //display
            System.IO.StreamWriter outfile = new System.IO.StreamWriter("Results.csv", false);
            foreach (KeyValuePair<long, long> entry in npdbTest.Histogram)
            {
                //Console.WriteLine("{0} : {1}", entry.Key, entry.Value);
                outfile.WriteLine("{0},{1}", entry.Key, entry.Value);
            }
            outfile.Close();
        }

        private void UpdateTimer_tick(object sender)
        {
            //Console.WriteLine("Updated time!!! {0}",DateTime.Now.ToString());
            UpdateSetting(SettingList[0], DateTime.Now.ToString());
            UpdateServer(ServerList[0], GetDateTimeAsInt(DateTime.Now, this.TestStartTime));
            UpdateInterface(InterfaceList[0], DateTime.Now.ToString());
            UpdateInterfaceBucket(InterfaceList[0], DateTime.Now.ToString());
        }

        void CreateInstance(object threadID)
        {
            Console.WriteLine("AppDomain" + threadID.ToString() + " " + DateTime.Now.ToString());
            string dllPath = AppDomain.CurrentDomain.BaseDirectory.Remove(AppDomain.CurrentDomain.BaseDirectory.LastIndexOf("\\")) + "\\Suites\\";

            AppDomainSetup setup = new AppDomainSetup();
            setup.ApplicationBase = AppDomain.CurrentDomain.BaseDirectory;
            setup.ApplicationName = "CommonConfigLoader";
            setup.PrivateBinPath = AppDomain.CurrentDomain.BaseDirectory + ";" + dllPath + ";" + AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
            setup.DisallowPublisherPolicy = true;


            AppDomain domain = AppDomain.CreateDomain("CommonConfigLoader" + threadID.ToString(), null, setup);

            // get an instance of the cross domain test suite loader
            CommonConfigLoader config = (CommonConfigLoader)domain.CreateInstanceFromAndUnwrap(typeof(CommonConfigLoader).Module.Name,
                    typeof(CommonConfigLoader).FullName);
            Instances.Add(config);
            config.TestStartTime = this.TestStartTime;
            config.SettingKey = this.SettingList[0];
            config.ServerKey = this.ServerList[0];
            config.InterfaceKey = this.InterfaceList[0];
            config.InstanceCallback += new EventHandler<InstanceEventArgs>(config_InstanceCallback);
            config.SetNPDBCallback(this);
            //config.Init(SettingList, 10);
            //config.Init(10);
            Console.WriteLine("Thread {0} finished.", threadID.ToString());

        }

        void config_InstanceCallback(object sender, InstanceEventArgs e)
        {
            //Console.WriteLine("{4} {0}:{1}.{2}.{3} {5}", e.Message, e.MachineName, e.InstanceID, e.ThreadID, e.TimeStamp, e.Duration.Ticks);
            //long cnt=1;
            int key = (int)e.Duration.Ticks / 50;
            /*
            if (Histogram.TryGetValue(key, out cnt))
            {
                Histogram[key] = cnt++;
            }
            else
            {
                Histogram.Add(key, cnt);
            }*/
            Console.Write("\r{0}  --  Press <Enter> to Quit               ", key);
        }

        static void  interfaceChangeCallback(object sender, InterfaceChangeEventArgs e)
        {
        }

        static void interfacebucketChangeCallback(object sender, InterfaceBucketChangeEventArgs e)
        {
        }

        static public void logResult(DateTime timeStamp, string msg, string machine, string instanceID, string threadID)
        {
            Console.WriteLine("{0} {1}.{2}.{3}: {4}", timeStamp.ToLongDateString(), machine, instanceID, threadID, msg);
        }

        void CreateSetting(string SettingName, string Value)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("select vc_value from t_settings where vc_setting='{0}'", SettingName);
                object dbValue = sqlCommand.ExecuteScalar();
                if (dbValue == null)
                {
                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("insert into t_settings values ('{0}','{1}')", SettingName, Value);
                    sqlCommand.ExecuteNonQuery();
                }
                else
                {
                    if (dbValue.ToString() != Value)
                    {
                        UpdateSetting(SettingName, Value);
                    }
                }
            }
        }

        void UpdateSetting(string SettingName, string Value)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("update t_settings set vc_value = '{0}' where vc_setting = '{1}'", Value, SettingName);
                sqlCommand.ExecuteNonQuery();
            }
        }

        void CreateServer(string ServerName, int ServerId)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("select vc_server from t_servers where vc_server='{0}'", ServerName);
                object dbValue = sqlCommand.ExecuteScalar();
                if (dbValue == null)
                {
                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("select top 1 vc_environment from t_environments where b_current=1");
                    string EnvironmentName = (string)sqlCommand.ExecuteScalar();
                    if (EnvironmentName == null)
                        EnvironmentName = "xblob";

                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("insert into t_servers values ('{0}','{1}',1,'online',{2})", EnvironmentName, ServerName, ServerId);
                    sqlCommand.ExecuteNonQuery();
                }
                else
                {
                    if (dbValue.ToString() != ServerId.ToString())
                    {
                        UpdateServer(ServerName, ServerId);
                    }
                }

                // Create t_server_nics entry so we can look up the interface
                sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("select vc_server from t_server_nics where vc_server='{0}' and vc_nic_role='middle_tier'", ServerName);
                dbValue = sqlCommand.ExecuteScalar();
                if (dbValue == null)
                {
                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("select top 1 vc_environment from t_environments where b_current=1");
                    string EnvironmentName = (string)sqlCommand.ExecuteScalar();
                    if (EnvironmentName == null)
                        EnvironmentName = "xblob";

                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText =
                        String.Format("insert into	t_server_nics (vc_environment,vc_server,vc_nic_role,vc_ip) values ('{0}','{1}','middle_tier','127.0.0.1')",
                                    EnvironmentName, ServerName);
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }

        void UpdateServer(string ServerName, int ServerId)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("update t_servers set i_server_id = {0} where vc_server = '{1}'", ServerId, ServerName);
                sqlCommand.ExecuteNonQuery();
            }
        }

        void CreateInterface(string InterfaceName, string ServerName, string Value)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("select vc_interface from t_interfaces where vc_interface='{0}'", InterfaceName);
                object dbValue = sqlCommand.ExecuteScalar();
                if (dbValue == null)
                {
                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("select top 1 vc_component from t_components");
                    string ComponentName = (string)sqlCommand.ExecuteScalar();
                    if (ComponentName == null)
                        ComponentName = "aamodule";

                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = 
                        String.Format("insert into	t_interfaces (vc_interface,vc_component,vc_nic_role,vc_protocol,vc_info1) values ('{0}','{1}','middle_tier','sql','{2}')", 
                                    InterfaceName, ComponentName, Value);
                    sqlCommand.ExecuteNonQuery();
                }
                else
                {
                    if (dbValue.ToString() != Value)
                    {
                        UpdateInterface(InterfaceName, Value);
                    }
                }

                // Add an entry to t_server_interfaces so we can look up the interface
                sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("select vc_interface from t_server_interfaces where vc_interface='{0}' and vc_server='{1}'", InterfaceName, ServerName);
                dbValue = sqlCommand.ExecuteScalar();
                if (dbValue == null)
                {
                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("select top 1 vc_environment from t_environments where b_current=1");
                    string EnvironmentName = (string)sqlCommand.ExecuteScalar();
                    if (EnvironmentName == null)
                        EnvironmentName = "xblob";

                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("insert into t_server_interfaces values ('{0}','{1}','{2}')", EnvironmentName, ServerName, InterfaceName);
                    sqlCommand.ExecuteNonQuery();
                }
            }
        }

        void UpdateInterface(string InterfaceName, string Value)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("update t_interfaces set vc_info1 = '{0}' where vc_interface = '{1}'", Value, InterfaceName);
                sqlCommand.ExecuteNonQuery();
            }
        }

        void CreateInterfaceBucket(string InterfaceName, string ServerName, string Value)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();
                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("select vc_interface from t_interface_buckets where vc_interface='{0}'", InterfaceName);
                object dbValue = sqlCommand.ExecuteScalar();
                if (dbValue == null)
                {
                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = String.Format("select top 1 vc_environment from t_environments where b_current=1");
                    string EnvironmentName = (string)sqlCommand.ExecuteScalar();
                    if (EnvironmentName == null)
                        EnvironmentName = "xblob";

                    sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText =
                        String.Format("insert into	t_interface_buckets	values ('{0}','{1}',0,0,'{2}','{2}','{3}','{4}','','','')",
                                    EnvironmentName, InterfaceName, ServerName, DateTime.Now, Value);
                    sqlCommand.ExecuteNonQuery();
                }
                else
                {
                    if (dbValue.ToString() != Value)
                    {
                        UpdateInterface(InterfaceName, Value);
                    }
                }
            }
        }

        void UpdateInterfaceBucket(string InterfaceName, string Value)
        {
            using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
            {
                cxn.Open();

                SqlCommand sqlCommand = cxn.CreateCommand();
                sqlCommand.CommandText = String.Format("update t_interface_buckets set vc_info1 = '{0}' where vc_interface = '{1}'", Value, InterfaceName);
                sqlCommand.ExecuteNonQuery();
            }
        }

        protected virtual void OnRaiseInstanceEvent(InstanceEventArgs e)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<InstanceEventArgs> handler = InstanceCallback;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(this, e);
            }
        }

        public static int GetDateTimeAsInt(DateTime newTime, DateTime startTime)
        {
            TimeSpan timeDiff;
            if (newTime > startTime)
                timeDiff = newTime - startTime;
            else
                timeDiff = startTime - newTime;
            return (int)timeDiff.TotalSeconds;
        }

        public static DateTime GetSecondsAsDateTime(DateTime startTime, int secondsCount)
        {
            TimeSpan secondsDiff = new TimeSpan(0, 0, secondsCount);
            DateTime realTime = startTime + secondsDiff;
            return realTime;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\FBServerDB.cpp ===
#include "FBServerDB.h"



FBRecord::FBRecord()
{
	SendPUID=0;
	TargetPUID=0;
	TitleID=0;
	FBType=0;
	sznickname[0]='\0';
}


FBRecord::FBRecord(FBRecord& rd)
{
	SendPUID=rd.SendPUID ;
	TargetPUID=rd.TargetPUID ;
	TitleID=rd.TitleID ;
	FBType=rd.FBType ;
	strcpy(sznickname, rd.sznickname);

}
FBRecord::~FBRecord()
{
}

FBRecord FBRecord::operator=(FBRecord& rd )
{
	SendPUID=rd.SendPUID ;
	TargetPUID=rd.TargetPUID ;
	TitleID=rd.TitleID ;
	FBType=rd.FBType ;
	strcpy(sznickname,rd.sznickname);

	return (*this);
}



//////////FBSERVERDB///////////////

FBServerDB::FBServerDB():strCnn("Provider=sqloledb;Data Source=pankajndbox;Initial Catalog=FBServer;User Id=test;Password=;")
{
	
}
FBServerDB::~FBServerDB(){
}


int FBServerDB::UnInit()
{
	HRESULT hr = S_OK;

	try
	{
		
		 hr =pConnection->Close(); 
	}
	catch(_com_error &e)
	{
	 // handle error	
	}
	 return hr;
}




int FBServerDB::Init()
{
	try
	{
		HRESULT hr = S_OK;
		hr = pConnection.CreateInstance(__uuidof(Connection));
		
		if(FAILED(hr))
		  return -1;
		hr = pConnection->Open(strCnn,"","",adConnectUnspecified);
      
		if(FAILED(hr))
		  return -1;
	}catch(_com_error &e)
	{
		return -1;
	}
	return 0;

}
int FBServerDB::AddRec( FBRecord& rec ,char* Tablename)
{
	char Query[510] ="INSERT INTO ";
	char data[50];
	try
	{
		
		

		strcat(Query,Tablename);
		strcat(Query,"([SendPuid], [TargetPuid], [titleID], [FBType], [Nickname])VALUES(");
		_ui64toa(rec.SendPUID,data,10);
		strcat(Query,data);
		strcat(Query,",");

		_ui64toa(rec.TargetPUID,data,10);
		strcat(Query,data);
		strcat(Query,",");

	
		_itoa(rec.TitleID,data,10);
		strcat(Query,data);
		strcat(Query,",");
		
		_itoa(rec.FBType ,data,10);
		strcat(Query,data);
		strcat(Query,",");

		strcat(Query,"'");
		strcat(Query,rec.sznickname);
		strcat(Query,"')");
      
	


		pConnection->Execute(Query,NULL,adCmdText);
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;

}
int FBServerDB::FindRec(FBRecord& fbrec)
{
	_RecordsetPtr prec;
	//SELECT [SendPuid], [TargetPuid], [titleID], [FBType], [Nickname] FROM [FBServer].[dbo].[Feedback]
	char Query[610] ="SELECT [SendPuid], [TargetPuid], [titleID], [FBType], [Nickname] FROM [FBServer].[dbo].[Feedback] WHERE";
	char data[50];
	_ui64toa(fbrec.SendPUID,data,10);
	strcat(Query," [SendPuid]=");
	strcat(Query,data);
	strcat(Query,"AND");

	_ui64toa(fbrec.TargetPUID,data,10);
	strcat(Query," [TargetPuid]=");
	strcat(Query,data);
	strcat(Query,"AND");


	_itoa(fbrec.TitleID,data,10);
	strcat(Query," [titleID]=");
	strcat(Query,data);
	strcat(Query,"AND");
	
	_itoa(fbrec.FBType ,data,10);
	strcat(Query," [FBType]=");
	strcat(Query,data);
	strcat(Query,"AND");

	
	strcat(Query," [Nickname]=");
	strcat(Query,"'");
	strcat(Query,fbrec.sznickname);
	strcat(Query,"'");

	///
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);

		if(prec->RecordCount !=0 )
			return 0;
		
	}
	catch(_com_error &e)
	{
		// error 
	}
	return -1;


	
}
int FBServerDB:: Getcount(char* nickname)
{
	_RecordsetPtr prec;
	char Query[255] = "SELECT count(*) FROM [FBServer].[dbo].[Feedback] where [Nickname] like '%";

	strcat(Query,nickname);
	strcat(Query,"%'");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}


int FBServerDB::Count(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[70] = "SELECT count(*) FROM";
	strcat(Query,Tablename);
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;

}


int FBServerDB::Nickname(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[70] = "SELECT count(*) FROM " ;// [FBServer].[dbo].[Feedback] where [FBType]=0";

	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=0");

	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;

}

int FBServerDB::GamePlay(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM";// [FBServer].[dbo].[Feedback] where [FBType]=1";

	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=1");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

int FBServerDB::Screaming(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM ";//[FBServer].[dbo].[Feedback] where [FBType]=2";
	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=2");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

int FBServerDB::Harassment(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM ";//[FBServer].[dbo].[Feedback] where [FBType]=3";
	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=3");

	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

int FBServerDB::Lewdness(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM ";//[FBServer].[dbo].[Feedback] where [FBType]=4";
	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=4");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

int FBServerDB::Attitude(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM" ;//[FBServer].[dbo].[Feedback] where [FBType]=5";
	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=5");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

int FBServerDB::Session(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM ";//[FBServer].[dbo].[Feedback] where [FBType]=6";
	strcat(Query,Tablename);
	strcat(Query,"where [FBType]=0");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}

int FBServerDB::BadType(char* Tablename)
{
	_RecordsetPtr prec;
	char Query[80] = "SELECT count(*) FROM ";//[FBServer].[dbo].[Feedback] where [FBType]>6";
	strcat(Query,Tablename);
	strcat(Query,"where [FBType]>6");
	try
	{
		prec =pConnection->Execute(Query,NULL,adCmdText);
		if(prec->RecordCount !=0 )
		{
			_variant_t val;
			int i;

			val =prec->Fields->Item[0L]->Value;
			i=(long)val;
			return i;
			
		}
		
	}
	catch(_com_error &e)
	{
		return -1;
	}
	return 0;
}



int FBServerDB:: ClearAll(char* Tablename)
{
	char Query[100] = "DELETE FROM ";
	strcat(Query,Tablename);
	try
	{
		pConnection->Execute(Query,NULL,adCmdText);

	}
	catch(_com_error &e)
	{
		return -1;
	}
	catch(...)
	{

	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DBLoad\Report.h ===
//Report
#include "windows.h"
#import "C:\Program Files\Common Files\System\ADO\msado15.dll" \
    no_namespace rename("EOF", "EndOfFile")

#pragma warning (disable:4786)
#include <list>
#include <string>
#include <iostream>

using namespace std ;


class Report
{
	_ConnectionPtr pConnection;
	_bstr_t strCnn;

	void Parse_Print(_bstr_t sendPuid,_bstr_t TargetPuid,long Titleid ,int FBType, _bstr_t Nickname);
public:

	Report();
	int Init();
	~Report();
	int RecordNotFound();
	int NOof500RecFound();
	int ErrorRecords();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT.StfTests\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT.StfTests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT\DDT.cs ===
using System;
using DDT;

namespace DDTTestRunner
{
    public class Program
    {
        public static void Usage()
        {
            Console.WriteLine("Usage : DDT <DDT XML> [args]");
        }

        public static void PrintException(Exception e)
        {
            ConsoleColor color = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(e);
            Console.ForegroundColor = color;
        }

        public static int Main(string[] args)
        {
            if (args.Length < 1)
            {
                Usage();
                return 0;
            }

            DDTEnvironment env = new DDTEnvironment();

            // Prepare the rest of the args to be sent to the script
            string[] newArgs = new string[args.Length - 1];
            for (int i = 1;i < args.Length;i++)
            {
                newArgs[i] = args[i];
            }

            env.DefineVariable("args", newArgs);

            Object output = null;
            try
            {
                output = env.Source(args[0]);
            }
            catch (Exception e)
            {
                PrintException(e);
                return 1;
            }

            // If it's a testsuite file, execute the test suite
            int retval = 0;            
            if ((output != null) && (output is DDTTestSuite))
            {
                DDTTestSuite testSuite = (DDTTestSuite)output;
                
                int passed = 0;
                int failed = 0;
                String result = "PASS";
                foreach (DDTTestCaseInfo test in testSuite.TestCases)
                {
                    Console.WriteLine("-------------Start Test : " + 
                                      test.Name);
                    
                    try
                    {
                        testSuite.ExecuteTestCase(test);
                        result = "PASS";
                        passed++;
                    }
                    catch (Exception e)
                    {
                        PrintException(e);

                        result = "FAIL";
                        failed++;
                    }
                    finally
                    {
                        Console.WriteLine("-------------End Test : " 
                                          + test.Name + 
                                          " : " + result + "\n\n");
                    }
                }
                
                Console.WriteLine("Summary : Passed={0}, Failed={1}",
                                  passed, failed);

                if (failed > 0)
                {
                    retval = 1; // Failure
                }
            }
            
            return retval;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT.StfTests\DDTStfLogger.cs ===
using System;
using DDT;
using ServerTestFramework;

namespace DDT.StfTests
{
    // Route DDT logging to STF logging
    public class DDTStfLogger : IDDTLogger
    {
        private DDTLogLevel level = DDTLogLevel.Info;

        private static DDTStfLogger _logger = new DDTStfLogger();

        public static DDTStfLogger GetInstance()
        {
            return _logger;
        }

        void IDDTLogger.Log(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Log)
            {
                Global.RO.Info(format, args);
            }
        }

        void IDDTLogger.Info(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Info)
            {
                Global.RO.Info(format, args);
            }
        } 

        void IDDTLogger.Warn(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Warn)
            {
                Global.RO.Warn(format, args);
            }
        } 

        void IDDTLogger.Error(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Error)
            {
                Global.RO.Error(format, args);
            }
        } 

        DDTLogLevel IDDTLogger.GetLogLevel()
        {
            return level;
        }
        
        void IDDTLogger.SetLogLevel(DDTLogLevel l)
        {
            level = l;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTActionAttribute.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;


namespace DDT
{
    public class DDTActionAttribute : Attribute
    {
        public String Name = String.Empty;

        public DDTActionAttribute() { }

        public DDTActionAttribute(String name)
        {
            Name = name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTAction.cs ===
using System;

namespace DDT
{
    /// <summary>
    /// Use DDTAction to write simple actions that won't change the
    /// execution enviornment
    /// </summary>
    public abstract class DDTAction : DDTEnvironmentAction
    {
        public override Object Invoke(DDTEnvironment e)
        {
            return Invoke();
        }

        public abstract Object Invoke();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTActionCollection.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace DDT
{
    public abstract class DDTActionCollection
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTArrayReference.cs ===
using System;

namespace DDT
{
    public class DDTArrayReference : IDDTReference
    {
        protected Array array;
        protected Int64 []index;

        public DDTArrayReference(Array array, 
                                 Int64[] index)
        {
            this.array = array;
            this.index = index;
        }
        
        Object IDDTReference.GetValue()
        {
            try
            {
                return array.GetValue(this.index);
            }
            catch (Exception e)
            {
                String msg = e.Message;
                Exception inner = e;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                    inner = e.InnerException;
                }

                throw new DDTException(msg);
            }
        }

        void IDDTReference.SetValue(Object val)
        {
            try
            {
                array.SetValue(val, this.index);
            }
            catch (Exception e)
            {
                String msg = e.Message;
                Exception inner = e;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                    inner = e.InnerException;
                }

                throw new DDTException(msg);
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTBreak.cs ===
using System;

namespace DDT
{
    public class DDTBreak {}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDT.StfTests\DDTTestBaseGroup.cs ===
using System;
using System.Reflection;

using DDT;
using ServerTestFramework;


namespace DDT.StfTests
{
    public class DDTTestBaseGroup : TestNode
    {
        private DDTTestSuite testSuite = null;

        public DDTTestBaseGroup(String testCaseXml)
        {
            // Set the STF Logger interface
            DDTGlobal.SetLogger(DDTStfLogger.GetInstance());
            
            // Load the test cases from the test XML file
            testSuite = 
                DDTTestSuite.GetTestSuite(testCaseXml);

            foreach (DDTTestCaseInfo test in testSuite.TestCases)
            {
                // Dynamically add a STF test case
                AddChild(new DDTStfTest(testSuite,
                                   test));
            }

            
            // Map the DDT test suite name to the Test group name
            this.Name = testSuite.Name;
        }

        public class DDTStfTest : TestBase
        {
            private DDTTestSuite testSuite;
            private DDTTestCaseInfo test;

            public DDTStfTest(DDTTestSuite testSuite, 
                              DDTTestCaseInfo test) : base(test.Name)
            {
                this.testSuite = testSuite;
                this.test = test;

                if (this.test.Ignore)
                {
                    // Set the base TestNode Ignored property
                    this.FunctionalData = new FunctionalNodeData(this);
                    this.FunctionalData.Ignored = true;
                }
            }

            protected override void Execute()
            {
                testSuite.ExecuteTestCase(test);
                
                // If no exceptions have been thrown so far it's a success
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTActionInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;

namespace DDT
{
    public class DDTActionInfo
    {
        public Type ActionType = null;
        public Dictionary<String, FieldInfo> ActionParameters = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTConsoleLogger.cs ===
using System;

namespace DDT
{
    public class DDTConsoleLogger : IDDTLogger
    {
        private DDTLogLevel level = DDTLogLevel.Log;

        void IDDTLogger.Log(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Log)
            {
                Console.WriteLine(String.Format(format, args));
            }
        }

        void IDDTLogger.Info(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Info)
            {
                Console.WriteLine(String.Format("INFO : " + format, args));
            }
        } 

        void IDDTLogger.Warn(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Warn)
            {
                Console.WriteLine(String.Format("WARN : " + format, args));
            }
        } 

        void IDDTLogger.Error(String format, params Object[] args)
        {
            if (level >= DDTLogLevel.Error)
            {
                Console.WriteLine(String.Format("ERROR : " + format, args));
            }
        } 

        DDTLogLevel IDDTLogger.GetLogLevel()
        {
            return level;
        }
        
        void IDDTLogger.SetLogLevel(DDTLogLevel l)
        {
            level = l;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTBuiltInActionCollection.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Text.RegularExpressions;

namespace DDT
{
    [DDTDoc("DDT Built-in Action Collection")]
    public class DDTBuiltInActionCollection : DDTActionCollection
    {
        [DDTAction]
        [DDTDoc("Does nothing")]
        public class Br : DDTAction
        {
            public override Object Invoke()
            {
                return null;
            }
        }

        [DDTAction]
        [DDTDoc("Sets the logging level for the Global Logger")]
        public class Echo : DDTAction
        {
            [DDTParam(Position = 0)]
            [DDTDoc("Logging Level - Error, Warn, Info or Log")]
            public DDTLogLevel Level = DDTLogLevel.Log;
            
            public override Object Invoke()
            {
                DDTGlobal.RO.Info("Echo : Setting Log Level to '" + 
                                  Level + "'");
                DDTGlobal.RO.SetLogLevel(Level);
                return null;
            }
        }

        [DDTAction]
        [DDTDoc("Prints a message")]
        public class Write : DDTAction
        {
            [DDTParam]
            [DDTDoc("Output format string")]
            public String Format = String.Empty;
            
            [DDTParam]
            [DDTDoc("Output Level - Error, Warn, Info or Log")]
            public DDTLogLevel Level = DDTLogLevel.Log;

            [DDTParam]
            [DDTDoc("Object parameters to be output")]
            public DDTParamList Params = new DDTParamList();

            public override Object Invoke()
            {
                String msg = String.Empty;
                

                // If a format string is specified use it
                // Otherwise just concat the objects provided
                if (Format != String.Empty)
                {
                    Object[] objects = new Object[Params.Values.Count];

                    int i = 0;
                    foreach (Object o in Params.Values)
                    {
                        objects[i++] = o;
                    }

                    msg = String.Format(Format, objects);
                }
                else
                {
                    foreach (Object o in Params.Values)
                    {
                        msg += o.ToString();
                    }
                }

                switch (Level)
                {
                case DDTLogLevel.Error:
                    DDTGlobal.RO.Error(msg);
                    break;

                case DDTLogLevel.Warn:
                    DDTGlobal.RO.Warn(msg);
                    break;

                case DDTLogLevel.Info:
                    DDTGlobal.RO.Info(msg);
                    break;

                case DDTLogLevel.Log:
                    DDTGlobal.RO.Log(msg);
                    break;
                }
                
                return null;
            }
        }


        [DDTAction]
        [DDTDoc("Formats a string")]
        public class Format : DDTAction
        {
            [DDTParam]
            [DDTDoc("Output format string")]
            public String format = String.Empty;
            
            [DDTParam]
            [DDTDoc("Object parameters to be formatted")]
            public DDTParamList Params = new DDTParamList();

            public override Object Invoke()
            {
                String msg = String.Empty;
                
                // If a format string is specified use it
                // Otherwise just concat the objects provided
                if (format != String.Empty)
                {
                    // Handle some basic escape sequences
                    format = format.Replace("\\r", "\r");
                    format = format.Replace("\\n", "\n");
                    format = format.Replace("\\t", "\t");
                    format = format.Replace("\\b", "\b");


                    Object[] objects = new Object[Params.Values.Count];

                    int i = 0;
                    foreach (Object o in Params.Values)
                    {
                        objects[i++] = o;
                    }

                    msg = String.Format(format, objects);
                }
                else
                {
                    foreach (Object o in Params.Values)
                    {
                        msg += o.ToString();
                    }
                }

                return msg;
            }
        }

        [DDTAction]
        [DDTDoc("Creates a new variable in the current environment\n" +
                "  Example : <Define a=\"10\" b=\"0.5\"/> creates variable\n" +
                "  'a' with value 10 and 'b' with value 0.5")]
        public class Define : DDTEnvironmentAction
        {
            // All variable parameters are put into this
            [DDTParam]
            [DDTDoc("Variables parameter list")]
            public DDTParamList Params = new DDTParamList();

            public override Object Invoke(DDTEnvironment e)
            {
                if (Params.Parameters.Count == 0)
                {
                    throw new DDTException("Define : No variables specified");
                }

                // Define the variable values in the environment

                // Assign attribute parameters first 
                Object lastValue = null;                
                foreach (String paramName in Params.Parameters)
                {
                    // Don't process params which are positional parameters
                    if (paramName.StartsWith("$"))
                    {
                        continue;
                    }

                    bool isReserved;
                    if (!DDTHelper.IsValidVariableName(paramName, 
                                                       out isReserved))
                    {
                        if (isReserved)
                        {
                            throw new DDTException
                                ("Define : '" + paramName + "' " + 
                                 "is a reserved name and cannot be " +
                                 "used as a variable name");
                        }
                        else
                        {
                            throw new DDTException
                                ("Define : Invalid variable name : '" +
                                 paramName + "'");
                        }
                    }

                    e.DefineVariable(paramName, Params[paramName]);
                    lastValue = Params[paramName];
                }

                // Process child node parameters
                bool varSeen = false;
                String varName = String.Empty;
                int pos = 0;
                foreach (String paramName in Params.Parameters)
                {
                    // Process only position parameters which start with
                    // "$"
                    if (paramName.StartsWith("$"))
                    {
                        // Positional parameters
                        // Alternate between variable and values
                        if (varSeen)
                        {
                            Object value = Params[paramName];
                            varSeen = false;
                            
                            e.DefineVariable(varName, value);
                            lastValue = value;
                        }
                        else
                        {
                            if (Params[paramName].GetType() !=
                                typeof(String))
                            {
                                throw new DDTException(
                                    "Define : Expected variable name at " +
                                    "position " + pos + ", but got an " +
                                    "Object of type : " + 
                                    Params[paramName].GetType());
                            }
                            
                            varName = (String)Params[paramName];
                            bool isReserved;
                            if (!DDTHelper.IsValidVariableName(varName,
                                                               out isReserved))
                            {
                                if (isReserved)
                                {
                                    throw new DDTException
                                        ("Define : '" + varName + "' " + 
                                         "is a reserved name and cannot be " +
                                         "used as a variable name");
                                }
                                else
                                {
                                    throw new DDTException
                                        ("Define : Invalid variable name : '" +
                                         varName + "'");
                                }
                            }
                            
                            varSeen = true;
                        }
                        
                        pos++;
                    }
                }

                // We should get out of the above loop in a clean state
                if (varSeen)
                {
                    throw new DDTException(
                        "Define : Variable '" + varName + "' has no " +
                        "corresponding value specified");
                }

                // Return the last value set
                return lastValue;
            }
        }

        [DDTAction]
        [DDTDoc("Set variables specified as parameters to the given values\n" +
                "  Example : <Set a=\"10\" b=\"0.5\"/> sets existing \n" + 
                "  variables 'a' with value 10 and 'b' with value 0.5 \n" +
                "  If 'a' or 'b' do not exist Set will throw an exception")]
        public class Set : DDTEnvironmentAction
        {
            // All variable parameters are put into this
            [DDTParam]
            [DDTDoc("Variables parameter list")]
            public DDTParamList Params = new DDTParamList();

            public override Object Invoke(DDTEnvironment e)
            {
                if (Params.Parameters.Count == 0)
                {
                    throw new DDTException("Set : No variables specified");
                }

                // Set the variable values in the environment

                // Assign attribute parameters first 
                Object lastValue = null;                
                foreach (String paramName in Params.Parameters)
                {
                    // Don't process positional parameters, which begin
                    // with $
                    if (!paramName.StartsWith("$"))
                    {
                        bool isReserved;
                        if (!DDTHelper.IsValidVariableName(paramName, 
                                                           out isReserved))
                        {
                            if (isReserved)
                            {
                                throw new DDTException
                                    ("Set : '" + paramName + "' " + 
                                     "is a reserved name and cannot be " +
                                     "used as a variable name");
                            }
                            else
                            {
                                throw new DDTException
                                    ("Set : Invalid variable name : '" +
                                     paramName + "'");
                            }
                        }                        

                        e.SetVariable(paramName, Params[paramName]);
                        lastValue = Params[paramName];
                    }
                }

                // Process child node parameters
                bool varSeen = false;
                String varName = String.Empty;
                int pos = 0;
                foreach (String paramName in Params.Parameters)
                {
                    // Process only position parameters which start with
                    // "$"
                    if (paramName.StartsWith("$"))
                    {
                        // Positional parameters
                        // Alternate between variable and values
                        if (varSeen)
                        {
                            Object value = Params[paramName];
                            varSeen = false;
                            
                            e.SetVariable(varName, value);
                            lastValue = value;
                        }
                        else
                        {
                            if (Params[paramName].GetType() !=
                                typeof(String))
                            {
                                throw new DDTException(
                                    "Set : Expected variable name at " +
                                    "position " + pos + ", but got an " +
                                    "Object of type : " + 
                                    Params[paramName].GetType());
                            }
                            
                            varName = (String)Params[paramName];
                            bool isReserved;
                            if (!DDTHelper.IsValidVariableName(varName,
                                                               out isReserved))
                            {
                                if (isReserved)
                                {
                                    throw new DDTException
                                        ("Set : '" + varName + "' " + 
                                         "is a reserved name and cannot be " +
                                         "used as a variable name");
                                }
                                else
                                {
                                    throw new DDTException
                                        ("Set : Invalid variable name : '" +
                                         varName + "'");
                                }
                            }
                            
                            varSeen = true;
                        }
                        
                        pos++;
                    }
                }

                // We should get out of the above loop in a clean state
                if (varSeen)
                {
                    throw new DDTException(
                        "Set : Variable '" + varName + "' has no " +
                        "corresponding value specified");
                }

                // Return the last value set
                return lastValue;
            }
        }


        [DDTAction]
        [DDTDoc("Let creates a new environment with the given variables\n" +
                "  and executes sub actions in that environment.\n" + 
                "  The return value is the value of the last sub action")]
        public class Let : DDTXmlAction
        {
            // All variable parameters are put into this
            [DDTParam]
            [DDTDoc("Variables List")]
            public DDTParamList Params = new DDTParamList();

            DDTEnvironment letEnv = null;
            int index = 0;

            public override Object Invoke(DDTEnvironment e)
            {
                // Create a new environment
                // and execute the sub actions in it
                letEnv = new DDTEnvironment(e);
                foreach (String varName in Params.Parameters)
                {
                    letEnv.DefineVariable(varName, Params[varName]);
                }                
                
                return RunContinuation(null);
            }

            // Continue the sub actions of Let across continuations
            private Object RunContinuation(Object state)
            {                
                // Value of the last sub action will be returned
                Object lastValue = null;
                bool inContinuation = (state != null);
             
                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        letEnv);

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {
                    // Restart the execution from index
                    for (int i = index; i < this.SubActionNodes.Count;i++)
                    {
                        XmlNode subAction = (XmlNode)this.SubActionNodes[i];

                        if (inContinuation)
                        {
                            inContinuation = false;
                            lastValue = DDTContinuation.EndContinuation();
                        }
                        else
                        {
                            lastValue = letEnv.ExecuteAction(subAction);
                        }

                        index++;
                    }
                }

                // Return the last value set
                return lastValue;
            }
        }
        
        [DDTAction]
        [DDTDoc("Initialize the random number generator")]
        public class Rand : DDTAction
        {
            [DDTParam]
            [DDTDoc("Random number Seed")]
            public int Seed = 0;
            
            public override Object Invoke()
            {
                if (Seed == 0)
                {
                    Random r = new Random();
                    Seed = r.Next();
                }

                DDTGlobal.RO.Info("Rand : Using Seed : " + Seed);

                return new Random(Seed);
            }
        }

        // Maintain a list of conditions that is evaluated when needed
        // in the given environment
        [DDTAction]
        [DDTDoc("Define a set of conditions to be evaluated when needed\n" + 
                "  Used to specify constraints in 'Choose' and 'Action' " +
                "actions")]
        public class Requires : DDTXmlAction
        {
            public override Object Invoke(DDTEnvironment e)
            {
                return new DDTConstraints(this.SubActionNodes);
            }
        }

        // Generate combination of variable values
        [DDTAction]
        [DDTDoc("Iterates through all values of its parameters and \n" + 
                "  executes it's body for combinations of the values\n\n" + 
                "  Example : \n" +
                "     <Choose x=\"{1,2,3}\" \n" +
                "             y=\"{1,2,3}\"> \n" + 
                "       <Write msg=\"%x %y\"/>\n" + 
                "     </Choose>\n\n" + 
                "  Displays \n\n" +
                "  1 1\n" +
                "  1 2\n" +
                "  1 3\n" +
                "  2 1\n" +                 
                "  2 2\n" +
                "  2 3\n" +
                "  3 1\n" +
                "  3 2\n" +                
                "  3 3\n" +
                "\n" + 
                "  Notice how %x and %y in the body have been replaced by \n"+ 
                "  values of parameters x and y")]
        public class Choose : DDTXmlAction
        {
            [DDTParam]
            [DDTDoc("Combination type - 'all' or 'pairwise'")]
            public String type = "all";
            
            [DDTParam(Name="return")]
            [DDTDoc("Choose's return value  - 'all', 'last' or 'none'")]
            public String returnType = "all";

            [DDTParam(ImpliedSource="Rand")]
            [DDTDoc("Random number generator")]
            public Random Rand = null;

            [DDTParam]
            [DDTDoc("Variables List")]
            public DDTParamList Params = new DDTParamList();

            // Filter to choose only pairwise combinations
            public class PairwiseFilter : IDDTCrossFilter
            {
                Hashtable pairMap = new Hashtable();
                int currentScore = 0;
                
                int coverPairs(ArrayList values, bool getScoresOnly)
                {
                    int score = 0;
                    for (int i = 0;i < values.Count;i++)
                    {
                        for (int j = i+1;j < values.Count;j++)
                        {
                            String pairString = 
                                i.ToString() + ":" +
                                values[i].ToString() + "," + 
                                j.ToString() + ":" +
                                values[j].ToString();
                            
                            if (!pairMap.ContainsKey(pairString))
                            {
                                score++;
                                
                                if (!getScoresOnly)
                                {
                                    pairMap[pairString] = 1;
                                }
                            }
                        }                    
                    }

                    return score;
                }

                bool IDDTCrossFilter.Allow(ArrayList values)
                {
                    bool isUseful = false;

                    // Consider the number of pairs we cover.
                    // Cover the higher score pairs first
                    // and then the next highest scored pairs in the next pass
                    // until we cover only single score ones

                    int score = coverPairs(values, true);
                    
                    if (currentScore == 0)
                    {
                        currentScore = score;
                    }

                    if (score >= currentScore)
                    {
                        coverPairs(values, false);
                        isUseful = true;
                    }

                    return isUseful;
                }

                bool IDDTCrossFilter.Done
                {
                    get
                    {
                        return (((currentScore--) == 1) ? true : false);
                    }
                }

                void IDDTCrossFilter.Reset()
                {
                    pairMap.Clear();
                    currentScore = 0;
                }
            }
            

            private String[] getValues(String valueString)
            {
                // Replace with a more complicated sequence processing later
                return valueString.Split(new char[] {','});
            }

            private void replaceVariable(XmlNode node,
                                         String variable,
                                         String value)
            {
                // Text nodes don't have attributes
                if (node.Attributes == null)
                {
                    return;
                }

                // Do replacement in the attribute values
                foreach (XmlAttribute attribute in node.Attributes)
                {
                    // Replace "%variable" with "value"
                    attribute.Value = attribute.Value.Replace("%" + variable,
                                                              value);
                }

                // Recursively do replacement in child nodes if there are any
                foreach (XmlNode child in node.ChildNodes)
                {
                    replaceVariable(child, variable, value);
                }
            }

            public override Object Invoke(DDTEnvironment e)
            {
                this.env = e;

                // Mapping beween variables and their possible values
                ArrayList valuesList = new ArrayList();

                type = type.ToLower();
                returnType = returnType.ToLower();

                if ((type != "all") &&
                    (type != "any") &&
                    (type != "pairwise"))
                {
                    throw new DDTException(
                        "Choose : Unknown 'Type' : " + type);
                }
                
                if ((returnType != "all")  && 
                    (returnType != "none") &&
                    (returnType != "last"))
                {
                    throw new DDTException(
                        "Choose : Unknown 'Return' : " + 
                        returnType);
                }

                // Get the list of values from the list
                foreach (String param in Params.Parameters)
                {
                    bool isReserved;
                    if (!DDTHelper.IsValidVariableName(param, 
                                                       out isReserved))
                    {
                        if (isReserved)
                        {
                            throw new DDTException
                                ("Choose : '" + param + "' " + 
                                 "is a reserved name and cannot be " +
                                 "used as a variable name");
                        }
                        else
                        {
                            throw new DDTException
                                ("Choose : Invalid variable name : '" +
                                 param + "'");
                        }
                    }

                    Type paramType = Params[param].GetType();

                    if ((paramType.GetInterface("IEnumerable")  
                         == null) ||
                        (paramType == typeof(String)))
                    {
                        // Non-list type
                        throw new DDTException(
                            "Choose : Value for '" + param + "' is not " + 
                            "a enumerable type");
                    }
                    else
                    {
                        // Some enumerable type. Each member will be a choice
                        valuesList.Add(Params[param]);
                    }
                }
                                    
                if (Params.Parameters.Count == 0)
                {
                    throw new DDTException("Choose : No variables specified");
                }

                if ((Params.Parameters.Count == 1) && 
                    (type != "all") && (type != "any"))
                {
                    throw new DDTException(
                        "Choose : 'Type' has to be 'all' or 'any'" +
                        "when there is only one variable");
                }

                // Check if the first sub-action is a 'Requires'
                // If so, add it as a constraint in the parameter generation
                DDTConstraints constraints = null;
                if ((this.SubActionNodes.Count > 0) &&
                    (((XmlNode)this.SubActionNodes[0]).Name.ToLower()
                     == "requires"))
                {
                    constraints = 
                        (DDTConstraints)e.ExecuteAction(
                            (XmlNode)this.SubActionNodes[0]);

                    // Unlink the 'Requires' action from the subactions
                    this.SubActionNodes = 
                        this.SubActionNodes.GetRange(
                            1,
                            this.SubActionNodes.Count - 1);
                }
                
                IDDTCrossFilter filter = null;
                if (type == "pairwise")
                {
                    filter = new PairwiseFilter();
                }

                // Initialize the cross product matrix specifying all the
                // constraints and filter
                // crossProduct also handles defining the variables to the
                // current value as part of constraints validation
                crossProduct = DDTCross.Initialize(e,
                                                   Params.Parameters,
                                                   valuesList,
                                                   (type == "any"),
                                                   Rand,
                                                   constraints,
                                                   filter);

                returnValue = null;
                if (returnType == "all")
                {
                    returnValue = new ArrayList();
                }
                
                return RunContinuation(null);
            }

            public enum ChooseState
            {
                Moving,
                Executing,
                Completed
            }

            // States of the continuation
            Object returnValue = null;
            
            private DDTEnvironment env = null;
            private DDTCross crossProduct = null; 
            private ChooseState state = ChooseState.Moving;
            private ArrayList subActions = null;
            private int actionIndex = 0;

            
            // Run the Choose body across continuations
            private Object RunContinuation(Object context)
            {
                // Get the last value from the previous continuation
                Object output = DDTContinuation.EndContinuation();
                bool inContinuation = (context != null);
             
                // Store the continuation point
                DDTContinuationContext continuation =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        env);

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(continuation))
                {                                          
                    do
                    {
                        switch (state)
                        {
                            case ChooseState.Moving:
                            {
                                bool move;
                                
                                if (!inContinuation)
                                {
                                    move = crossProduct.MoveNext();
                                }
                                else
                                {
                                    move = (bool)output;
                                    inContinuation = false;
                                }
                                
                                if (!move)
                                {
                                    state = ChooseState.Completed;
                                    break;
                                }
                                                                
                                ArrayList values = crossProduct.Current();
                                
                                // Replace all %var with variable value string
                                subActions = new ArrayList();
                                foreach (XmlNode childNode in 
                                         this.SubActionNodes)
                                {
                                    XmlNode subAction = childNode.Clone();
                                    
                                    int i = 0;
                                    foreach (String var in Params.Parameters)
                                    {
                                        String value = values[i++].ToString();
                                        replaceVariable(subAction, var, value);
                                    }
                                    
                                    subActions.Add(subAction);
                                }
                                
                                actionIndex = 0;
                                state = ChooseState.Executing;
                            
                                break;
                            }

                            case ChooseState.Executing:
                            {
                                // Process previous value from continuation
                                if (inContinuation)
                                {
                                    inContinuation = false;
                                    
                                    HandleBreakContinue(output);
                                    
                                    if (state != ChooseState.Executing)
                                    {
                                        break;
                                    }
                                }
                                
                                for (int i = actionIndex;
                                     i < subActions.Count;
                                     i++)
                                {
                                    actionIndex++;
                                    XmlNode subAction = (XmlNode)subActions[i];
                                    
                                    // This can result in a continuation
                                    output = env.ExecuteAction(subAction);
                                    
                                    HandleBreakContinue(output);
                                    
                                    if (state != ChooseState.Executing)
                                    {
                                        break;
                                    }
                                }
                                
                                if (state == ChooseState.Executing)
                                {
                                    state = ChooseState.Moving;
                                }
                                
                                break;
                            }
                            
                        } // switch 
                    } while (state != ChooseState.Completed);
                }
                
                return returnValue;
            }

            private void HandleBreakContinue(Object output)
            {
                if (output == null)
                {
                    return;
                }
                
                // Handle break or continue
                if (output.GetType() == typeof(DDTBreak))
                {
                    actionIndex = 0;
                    state = ChooseState.Completed;
                }
                else if (output.GetType() == typeof(DDTContinue))
                {
                    actionIndex = 0;
                    state = ChooseState.Moving;
                }
                else
                {                            
                    if (returnType == "all")
                    {
                        ((ArrayList)returnValue).Add(output);
                    }
                    else if (returnType == "last")
                    {
                        returnValue = output;
                    }
                }
            }            

        }

        // RChoose - Recursive Choose
        [DDTAction]
        [DDTDoc("Recursive Choose. Similar to Choose but a parameter \n" +
                "  can take values specified by previous  parameters \n\n" + 
                "  Example : \n" +
                "     <RChoose x=\"{1,2,3}\" \n" +
                "              y=\"{%x,2,3}\"> \n" + 
                "       <Write msg=\"%x %y\"/>\n" + 
                "     </RChoose>\n\n" + 
                "  Displays \n\n" +
                "  1 1\n" +
                "  1 2\n" +
                "  1 3\n" +
                "  2 2\n" +                 
                "  2 2\n" +
                "  2 3\n" +
                "  3 3\n" +
                "  3 2\n" +                
                "  3 3\n" +
                "\n" + 
                "  Notice how y can refer to %x \n")]
        public class RChoose : DDTXmlMacro
        {
            public override Object Invoke(DDTEnvironment e)
            {
                String returnType = "all";
                String type = "all";

                // Mapping beween variables and their possible values
                ArrayList variables = new ArrayList();
                ArrayList values = new ArrayList();

                bool typeSeen = false;                
                bool returnSeen = false;
                bool varSeen = false;
                foreach (XmlAttribute attribute in this.MacroNode.Attributes)
                {
                    if (attribute.Name.ToLower() == "type")
                    {
                        if (typeSeen)
                        {
                            throw new DDTException(
                                "RChoose : Parameter 'type' already set");
                        }

                        type = attribute.Value.ToLower();
                        
                        if (type == "pairwise")
                        {
                            throw new DDTException(
                                "RChoose : 'pairwise' is not supported type " +
                                "for RChoose");                                
                        }
    
                        if ((type != "all") &&
                            (type != "any"))
                        {
                            throw new DDTException(
                                "RChoose : Unsupported 'type' : " + type);
                        }
                        
                        typeSeen = true;
                    }
                    else if (attribute.Name.ToLower() == "return")
                    {
                        if (returnSeen)
                        {
                            throw new DDTException(
                                "RChoose : Parameter 'return' already set");
                        }
                        else
                        {
                            returnType = attribute.Value.ToLower();
                            
                            if ((returnType == "all")  || 
                                (returnType == "none") ||
                                (returnType == "last"))
                            {
                                returnSeen = true;
                            }
                            else
                            {
                                throw new DDTException(
                                    "RChoose : Unknown 'Return' : " + 
                                    returnType);
                            }
                        }
                    }    
                    else
                    {
                        String varName = attribute.Name;

                        if (variables.Contains(varName))
                        {
                            throw new DDTException(
                                String.Format("RChoose : Variable {0} " +
                                              "already defined", varName));
                        }
                        else
                        {
                            variables.Add(varName);

                            if (attribute.Value == String.Empty)
                            {
                                throw new DDTException(
                                    String.Format(
                                        "RChoose : Value of '{0}' " + 
                                        "can't be empty", varName));  
                            }

                            // Store the values list
                            values.Add(attribute.Value);
                        }

                        // Some variable has been seen
                        varSeen = true;
                    }
                }
                
                if (!varSeen)
                {
                    throw new DDTException("RChoose : No variables specified");
                }
                

                XmlDocument ownerDoc = this.MacroNode.OwnerDocument;
                if (variables.Count == 1)
                {
                    // Only one variable - RChoose(x) is same as Choose(x)
                    XmlElement chooseNode = ownerDoc.CreateElement("Choose");

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              chooseNode,
                                              "type",
                                              type);

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              chooseNode,
                                              "return",
                                              returnType);

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              chooseNode,
                                              (String)variables[0],
                                              (String)values[0]);

                    foreach (XmlNode child in this.MacroNode.ChildNodes)
                    {
                        chooseNode.AppendChild(child.Clone());
                    }
                    
                    return e.ExecuteAction(chooseNode);
                }
                else
                {
                    // Multiple variables
                    // Convert RChoose(x1, x2, ..., returnType) to 
                    // Choose(x1, returnType)(RChoose (x2,...., returnType))
                    
                    // Construct the outer Choose node
                    XmlElement outerChooseNode = 
                        ownerDoc.CreateElement("Choose");


                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              outerChooseNode,
                                              "type",
                                              type);

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              outerChooseNode,
                                              "return",
                                              returnType);

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              outerChooseNode,
                                              (String)variables[0],
                                              (String)values[0]);


                    // Construct the inner RChoose node
                    XmlElement innerRChooseNode =  
                        ownerDoc.CreateElement("RChoose");

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              innerRChooseNode,
                                              "type",
                                              type);

                    DDTHelper.AddXmlAttribute(ownerDoc,
                                              innerRChooseNode,
                                              "return",
                                              returnType);
                    
                    for (int i = 1;i < values.Count;i++)
                    {
                        DDTHelper.AddXmlAttribute(ownerDoc,
                                                  innerRChooseNode,
                                                  (String)variables[i],
                                                  (String)values[i]);
                    }
                    
                    // Add the body of the orignal RChoose to the inner 
                    // RChoose
                    foreach (XmlNode child in this.MacroNode.ChildNodes)
                    {
                        innerRChooseNode.AppendChild(child.Clone());
                    }                    

                    outerChooseNode.AppendChild(innerRChooseNode);
                                                
                    return e.ExecuteAction(outerChooseNode);
                }
            }
        }
        
        [DDTAction]
        [DDTDoc("Assert a particular condition. Throws an Exception if " +
                "condition is false")]
        public class Assert : DDTEnvironmentAction
        {
            [DDTParam(Required=true, Position = 0)]
            [DDTDoc("Boolean expression : Ex. \"$a gt 10\" \n\n")]
            public bool Exp = false;

            public override Object Invoke(DDTEnvironment e)
            {
                if (!Exp)
                {
                    throw new Exception("Assert : Condition failed");
                }
                else
                {
                    return true;
                }
            }
        }

        [DDTAction]
        [DDTDoc("Add numeric and string values")]
        public class Add : DDTAction
        {
            [DDTParam]
            [DDTDoc("Variable parameter list")]
            public DDTParamList Params = new DDTParamList();

            public override Object Invoke()
            {
                if (Params.Values.Count < 2)
                {
                    throw new DDTException(
                        "Add : Not enough parameters. Got only " +
                        Params.Values.Count);
                }

                Object result = 
                    DDTHelper.AddObjects(Params.Values[0], Params.Values[1]);
                for (int i = 2;i < Params.Values.Count;i++)
                {
                    result = DDTHelper.AddObjects(result, Params.Values[i]);
                }

                return result;
            }
        }

        [DDTAction]
        [DDTDoc("Subtract numeric values")]
        public class Sub : DDTAction
        {
            [DDTParam]
            [DDTDoc("Variable parameter list")]
            public DDTParamList Params = new DDTParamList();

            public override Object Invoke()
            {
                if (Params.Values.Count < 1)
                {
                    throw new DDTException(
                        "Sub : Not enough parameters. Got only " +
                        Params.Values.Count);
                }

                Object result = null;
                if (Params.Values.Count == 1)
                {
                    result = DDTHelper.SubtractNumbers((Object)0, 
                                                       Params.Values[0]);  
                }
                else
                {
                    result = DDTHelper.SubtractNumbers(Params.Values[0], 
                                                       Params.Values[1]);
                }

                for (int i = 2;i < Params.Values.Count;i++)
                {
                    result = DDTHelper.SubtractNumbers(result, 
                                                       Params.Values[i]);
                }

                return result;
            }
        }

        [DDTAction]
        [DDTDoc("Increments a variable by given value\n" + 
                "  <Inc var=\"i\" inc=\"2\"/> is a macro for \n" +
                "  <Add var=\"i\" a=\"$i\" b=\"2\"/> and \n\n" +
                "  <Inc var=\"i\"/> is a macro for \n" +
                "  <Add var=\"i\" a=\"$i\" b=\"1\"/>")]
        public class Inc : DDTXmlMacro
        {            
            public override Object Invoke(DDTEnvironment e)
            {
                String varName = String.Empty;
                String incVal = String.Empty;
                
                if (this.MacroNode.ChildNodes.Count != 0)
                {
                    throw new DDTException("Inc : No subactions expected");
                }
                
                foreach (XmlAttribute attribute in this.MacroNode.Attributes)
                {
                    if (attribute.Name.ToLower() == "var")
                    {
                        if (varName != String.Empty)
                        {
                            throw new DDTException(
                                "Inc : 'var' already specified");
                        }
                        else
                        {
                            varName = attribute.Value;
                        }
                    }
                    else if (attribute.Name.ToLower() == "inc")
                    {
                        if (incVal != String.Empty)
                        {
                            throw new DDTException(
                                "Inc : 'inc' already specified");
                        }
                        else
                        {
                            incVal = attribute.Value;
                        }
                    }
                }
                
                if (varName == String.Empty)
                {
                    throw new DDTException("Inc : No 'var' parameter " + 
                                           "specified");
                }

                // Create the required Add command and execute it
                if (incVal == String.Empty)
                {
                    incVal = "1";
                }
                
                XmlDocument ownerDoc = this.MacroNode.OwnerDocument;
                XmlNode addActionNode = ownerDoc.CreateElement("Add");

                DDTHelper.AddXmlAttribute(ownerDoc,addActionNode,
                                          "var", varName);

                DDTHelper.AddXmlAttribute(ownerDoc,addActionNode,
                                          "a", "$" + varName);

                DDTHelper.AddXmlAttribute(ownerDoc,addActionNode,
                                          "b", incVal);
                                
                return e.ExecuteAction(addActionNode);
            }
        }       


        [DDTAction]
        [DDTDoc("Decrements a variable by given value\n" + 
                "  <Dec var=\"i\" dec=\"2\"/> is a macro for \n" +
                "  <Sub var=\"i\" a=\"$i\" b=\"2\"/> and \n\n" +
                "  <Dec var=\"i\"/> is a macro for \n" +
                "  <Sub var=\"i\" a=\"$i\" b=\"1\"/>")]
        public class Dec : DDTXmlMacro
        {            
            public override Object Invoke(DDTEnvironment e)
            {
                String varName = String.Empty;
                String decVal = String.Empty;
                
                if (this.MacroNode.ChildNodes.Count != 0)
                {
                    throw new DDTException("Dec : No subactions expected");
                }
                
                foreach (XmlAttribute attribute in this.MacroNode.Attributes)
                {
                    if (attribute.Name.ToLower() == "var")
                    {
                        if (varName != String.Empty)
                        {
                            throw new DDTException(
                                "Dec : 'var' already specified");
                        }
                        else
                        {
                            varName = attribute.Value;
                        }
                    }
                    else if (attribute.Name.ToLower() == "dec")
                    {
                        if (decVal != String.Empty)
                        {
                            throw new DDTException(
                                "Dec : 'dec' already specified");
                        }
                        else
                        {
                            decVal = attribute.Value;
                        }
                    }
                }

                if (varName == String.Empty)
                {
                    throw new DDTException("Dec : No 'var' parameter " + 
                                           "specified");
                }
                
                // Create the required Add command and execute it
                if (decVal == String.Empty)
                {
                    decVal = "1";
                }

                XmlDocument ownerDoc = this.MacroNode.OwnerDocument;
                XmlNode subActionNode = ownerDoc.CreateElement("Sub");

                DDTHelper.AddXmlAttribute(ownerDoc,subActionNode,
                                          "var", varName);

                DDTHelper.AddXmlAttribute(ownerDoc,subActionNode,
                                          "a", "$" + varName);

                DDTHelper.AddXmlAttribute(ownerDoc,subActionNode,
                                          "b", decVal);

                return e.ExecuteAction(subActionNode);
            }
        }       


        [DDTAction]
        [DDTDoc("Takes in multiple actions. Executes actions until \n" +
                "  a successful action is executed. If all actions fail \n " +
                "  Or fails with the exception thrown by the last action")]
        public class Or : DDTXmlAction
        {
            private DDTEnvironment e = null;
            private int index = 0;

            public override Object Invoke(DDTEnvironment e)
            {
                if (this.SubActionNodes.Count == 0)
                {
                    throw new DDTException(
                        "Or : Requires atleast one sub action");
                }

                this.e = e;
                return RunContinuation(null);
            }

            private Object RunContinuation(Object state)
            {                              
                // Execute individual actions in the 
                // body
                Exception lastException = null;
                bool result = false;
                Object o = null;

                bool inContinuation = (state != null);

                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        e);

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {
                    for (int i = this.index;i < this.SubActionNodes.Count;i++)
                    {
                        XmlNode subAction = (XmlNode)this.SubActionNodes[i];

                        try 
                        {
                            if (inContinuation)
                            {
                                inContinuation = false;
                                o = DDTContinuation.EndContinuation();
                            }
                            else
                            {
                                o = e.ExecuteAction(subAction);
                            }
                            result = true;
                        }
                        catch (DDTException)
                        {
                            // These are errors while setting up execution. 
                            // Don't handle them
                            // Throw them up as execution errors
                            throw;
                        }
                        catch (Exception ae)
                        {
                            // These are failures in action execution
                            lastException = ae;
                        }
                        
                        // If one of the actions is successful, don't execute
                        // the rest of the actions
                        if (result)
                        {
                            break;
                        }
                        
                        index++;                    
                    }
                }

                if (!result)
                {   
                    // None of the actions were successful 
                    // Fail the Or action itself with the last exception
                    throw lastException;
                }
                
                // On success return the value of the last statement
                return o;
            }            
        }

        [DDTAction]
        [DDTDoc("Takes one action in the body. If the action is successful\n"+
                "  Not will throw an exception. Otherwise it is successful\n" +
                "  Return value on success is null")]
        public class Not : DDTXmlAction
        {
            private DDTEnvironment e = null;

            public override Object Invoke(DDTEnvironment e)
            {
                // Not takes only one child
                if (this.SubActionNodes.Count != 1)
                {
                    throw new 
                        DDTException("NOT : One sub action expected. " +
                                     "But got " + 
                                     this.SubActionNodes.Count);
                }
                
                this.e = e;
                return RunContinuation(null);
            }

            private Object RunContinuation(Object state)
            {
                // Execute the action
                bool result = true;
                bool inContinuation = (state != null);
                
                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        e);

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {                
                    try
                    {
                        if (inContinuation)
                        {
                            inContinuation = false;
                            DDTContinuation.EndContinuation();
                        }
                        else
                        {
                            e.ExecuteAction((XmlNode)this.SubActionNodes[0]);
                        }
                    }
                    catch (DDTException)
                    {
                        // Something went wrong in setting up execution
                        throw;
                    }
                    catch (Exception)
                    {
                        // Something went wrong in Execution
                        result = false;
                    }
                }
                
                if (result)
                {
                    throw new Exception("NOT : Condition action expected " +
                                        "to fail, but succeeded");
                }
                
                return null;
            }
        }



        [DDTAction]
        [DDTDoc("Break out of a iterative loop like Choose or While")]
        public class Break : DDTAction
        {
            public override Object Invoke()
            {
                return new DDTBreak();
            }
        }

        [DDTAction]
        [DDTDoc("Continue to the next iteration of a iterative loop like \n" +
                "  Choose or While")]
        public class Continue : DDTAction
        {
            public override Object Invoke()
            {
                return new DDTContinue();
            }
        }

        [DDTAction]
        [DDTDoc("If all the parameters evaluate to true it executes the \n" +
                "  first sub-action. Otherwise executes the second \n" + 
                "  sub-action if present\n")]
        public class If : DDTXmlAction
        {
            [DDTParam]
            [DDTDoc("Optional Condition expression : Ex. \"$a gt 10\" \n\n")]
            public DDTParamList Params = new DDTParamList();

            private DDTEnvironment e = null;
            private int trueIndex, falseIndex;


            public override Object Invoke(DDTEnvironment e)
            {
                if (Params.Values.Count > 0)
                {
                    trueIndex = 0;
                    falseIndex = 1;
                }
                else
                {
                    trueIndex = 1;
                    falseIndex = 2;
                }

                // If needs atleast one sub-actions and upto 
                // three sub-actions
                if (this.SubActionNodes.Count <= trueIndex)
                {
                    throw new 
                        DDTException("If : Not enough sub-actions. Got only : "
                                     + this.SubActionNodes.Count);
                }
                
                if (this.SubActionNodes.Count > (falseIndex + 1))
                {
                    throw new 
                        DDTException("If : Too many sub-actions. " +
                                     "Expected " + (falseIndex + 1) +
                                     " but got " + 
                                     this.SubActionNodes.Count);
                }

                this.e = e;
                return RunContinuation(null);
            }


            private Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);

                // Evaluate the first sub-action
                bool result = false;

                if (Params.Values.Count > 0)
                {
                    int i = 0;
                    result = true;
                    foreach (Object exp in Params.Values)
                    {
                        if ((exp == null) || (exp.GetType() != typeof(bool)))
                        {
                            throw new DDTException
                                ("If : Expression '" + 
                                 (String)Params.Parameters[i] + 
                                 "' does not evaluate to a bool");
                        }
                        
                        result = result && (bool)exp;
                        i++;
                    }
                }
                else
                {                                    
                    Object output = null;

                    DDTContinuationContext context =
                        DDTContinuation.PushContinuation(
                            new DDTContinuationCallback(this.RunContinuation),
                            e);

                    using (DDTContinuationContextGuard guard = 
                           new DDTContinuationContextGuard(context))
                    {
                        if (inContinuation)
                        {
                            inContinuation = false;
                            output = DDTContinuation.EndContinuation();
                        }
                        else                        
                        {
                            output = 
                                e.ExecuteAction(
                                    (XmlNode)this.SubActionNodes[0]);
                        }
                    }
                 
                    if (output is bool)
                    {
                        result = (bool)output;
                    }
                    else
                    {
                        throw new DDTException
                            ("If : Boolean expression expected for condition");
                    }
                }

                // If comparison succeeds evalaute the next
                // sub action else the next to next subaction if present

                // We don't setup continuation here because we are just going
                // to return the action result anyway

                Object o = null;
                if (result)
                {
                    o = e.ExecuteAction(
                        (XmlNode)this.SubActionNodes[trueIndex]);
                }
                else
                {
                    if (this.SubActionNodes.Count > falseIndex)
                    {
                        o = e.ExecuteAction(
                            (XmlNode)this.SubActionNodes[falseIndex]);
                    }
                }

                return o;
            }
        }        

        [DDTAction]
        [DDTDoc("While all the parameters evaulated to true execute the \n" +
                "  sub-actions")]
        public class While : DDTXmlMacro
        {
            private ArrayList subActionNodes = null;
            private DDTEnvironment e = null;
            private int startIndex = 0;
            private int offset = 0;
            private Object returnValue = null; 

            public enum WhileState
            {
                EvalCondition,
                Executing,
                Completed
            }

            private WhileState whileState = WhileState.EvalCondition;

            public override Object Invoke(DDTEnvironment e)
            {
                // Consider only the non-comments nodes
                subActionNodes = new ArrayList();
                foreach (XmlNode child in this.MacroNode.ChildNodes)
                {
                    if (child.Name.ToLower() == "#comment")
                    {
                        continue;
                    }
                    
                    // Split text nodes
                    if (child.Name.ToLower() == "#text")
                    {
                        ArrayList textNodes = 
                            DDTHelper.SplitTextNode(child);
                        
                        subActionNodes.AddRange(textNodes);
                    }
                    else
                    {
                        subActionNodes.Add(child);
                    }
                }
                
                // See if a condition attribute has been specified
                if (this.MacroNode.Attributes.Count > 0)
                {
                    startIndex = 0;
                }
                else
                {
                    startIndex = 1;

                    // While with Condition expression 
                    // needs atleast one condition sub action
                    if (subActionNodes.Count < 1)
                    {
                        throw new 
                            DDTException("While : Atleast one sub action " +
                                         " needed when no condition " + 
                                         "attributes are present");
                    }
                }
                                
                this.e = e;
                return RunContinuation(null);
            }
                
            private Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);
                
                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        e);
                
                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {                
                    do
                    {
                        switch (whileState)
                        {
                            case WhileState.EvalCondition:
                            {
                                bool result = false;
                                
                                // Execute the while condition
                                if (this.MacroNode.Attributes.Count > 0)
                                {
                                    int i = 0;
                                    result = true;
                                    foreach (XmlAttribute cond in 
                                             this.MacroNode.Attributes)
                                    {
                                        String exp = cond.Value;
                                        
                                        Object r = 
                                            DDTHelper.EvalExpression(e, 
                                                                     exp);
                                        if ((r == null) ||
                                            (r.GetType() != typeof(bool)))
                                        {
                                            throw new DDTException
                                                ("While : Expression '" + 
                                                 cond.Name + 
                                                 "' does not evaluate to a " + 
                                                 "bool");
                                        }
                                        
                                        result = result && (bool)r;
                                        i++;
                                    }
                                }
                                else
                                {
                                    // No condition expression provided
                                    // Evaluate the first sub-action
                                    Object output = null;
                                    if (inContinuation)
                                    {
                                        inContinuation = false;
                                        output = 
                                            DDTContinuation.EndContinuation();
                                    }
                                    else
                                    {
                                        output = 
                                            e.ExecuteAction((XmlNode)
                                                            subActionNodes[0]);
                                    }
                                    
                                    if (output is bool)
                                    {
                                        result = (bool)output;
                                    }
                                    else
                                    {
                                        throw new DDTException
                                            ("While : Boolean expression " + 
                                             "expected for condition");
                                    }
                                }
                                
                                whileState = result ? 
                                    WhileState.Executing :
                                    WhileState.Completed;
                                
                                break;
                            }
                            
                            case WhileState.Executing:
                            {
                                // Evaluate the rest of the actions if result 
                                // is true
                                for (int i = startIndex + offset;
                                     i < subActionNodes.Count;
                                     i++)
                                {
                                    Object o = null;

                                    if (inContinuation)
                                    {
                                        inContinuation = false;
                                        o = DDTContinuation.EndContinuation();
                                    }
                                    else
                                    {
                                        o = e.ExecuteAction(
                                            (XmlNode)subActionNodes[i]);
                                    }
                                    
                                    // Handle break or continue
                                    if ((o != null) && 
                                        (o.GetType() == typeof(DDTBreak)))
                                    {
                                        offset = 0;
                                        whileState = WhileState.Completed;
                                        break;
                                    }
                                    else if ((o != null) && 
                                             (o.GetType() == 
                                              typeof(DDTContinue)))
                                    {
                                        offset = 0;
                                        whileState = WhileState.EvalCondition;
                                        break;
                                    }
                                    else
                                    {
                                        // Return value of while is 
                                        // the las action that isn't 
                                        // break or continue
                                        returnValue = o;
                                    }
                                                                        
                                    offset++;
                                }
                                
                                offset = 0;
                                whileState = WhileState.EvalCondition;
                                break;
                            }
                            
                        } // switch

                    } while (whileState != WhileState.Completed);

                } // using

                
                return returnValue;
            }
        }        

        [DDTAction]
        [DDTDoc("Executes all actions in the body. Used to group actions \n" +
                "  under a single block for use in 'If' actions.\n" + 
                "  Returns the value of the last action")]
        public class Begin : DDTXmlAction
        {
            private DDTEnvironment e = null;
            private int index = 0;

            public override Object Invoke(DDTEnvironment e)
            {
                this.e = e;
                return RunContinuation(null);
            }

            private Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);

                // Execute the sub actions in the begin block
                Object o = null;

                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        e);

                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {                
                    for (int i = index;i < this.SubActionNodes.Count;i++)
                    {
                        XmlNode subAction = (XmlNode)this.SubActionNodes[i];

                        if (inContinuation)
                        {
                            inContinuation = false;
                            o = DDTContinuation.EndContinuation();
                        }
                        else
                        {
                            o = e.ExecuteAction(subAction);
                        }
                        
                        // If we encounter break or continue,
                        // we stop processing other actions
                        if ((o != null) &&
                            ((o.GetType() == typeof(DDTBreak)) || 
                             (o.GetType() == typeof(DDTContinue))))
                        {
                            break;
                        }

                        index++;
                    }
                }
                
                // Return value of begin is the value from the last action
                return o;
            }
        }

        [DDTAction]
        [DDTDoc("Executes the top level action from the XML in the specified "+
                "path")]
        public class Source : DDTEnvironmentAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("XML file path")]
            public String Path = String.Empty;

            public override Object Invoke(DDTEnvironment e)
            {
                return e.Source(Path);
            }
        }

        [DDTAction]
        [DDTDoc("Loads Actions from an Assembly in the specified path")]
        public class Load : DDTEnvironmentAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("Actions assembly path")]
            public String Path = String.Empty;

            public override Object Invoke(DDTEnvironment e)
            {
                if (Path == String.Empty)
                {
                    throw new 
                        DDTException("Load : Path not found");
                }
                                
                e.LoadActionsFromAssembly(Path);

                return null;
            }            
        }


        [DDTAction]
        [DDTDoc("Displays documentation of a loaded action")]
        public class Help : DDTEnvironmentAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("Action name")]
            public String Action = String.Empty;

            public override Object Invoke(DDTEnvironment e)
            {
                if (Action == String.Empty)
                {
                    throw new 
                        DDTException("Help : Action not specified");
                }
                
                e.DisplayDoc(Action);

                return null;
            }
        }


        [DDTAction]
        [DDTDoc("Displays all actions in an actions assembly")]
        public class ListActions : DDTEnvironmentAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("Action assembly path")]
            public String Path = String.Empty;

            public override Object Invoke(DDTEnvironment e)
            {
                if (Path == String.Empty)
                {
                    throw new 
                        DDTException("ListActions : Path not specified");
                }
                
                e.ListActions(Path);

                return null;
            }
        }

        [DDTAction]
        [DDTDoc("Suspend execution for the specified time")]
        public class Sleep : DDTAction
        {
            [DDTParam(Position = 0)]
            [DDTDoc("Time to sleep in seconds")]
            public int Sec = 1;

            [DDTParam(Position = 1)]
            [DDTDoc("Time to sleep in milliseconds")]
            public int Msec = 0;
            
            public override Object Invoke()
            {
                DDTGlobal.RO.Info("Sleep : Sleeping for " + Sec + 
                                  " seconds and " + Msec + 
                                  " milliseconds...");
                Thread.Sleep(Sec * 1000 + Msec);

                return null;
            }
        }

        [DDTAction]
        [DDTDoc("Get the List length")]
        public class Length : DDTAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("List object")]
            public IEnumerable List = null;

            public override Object Invoke()
            {
                int length = 0;

                if (List == null)
                {
                    throw new Exception("Length : Parameter 'List' is null");
                }
                
                // O(n)
                foreach (Object element in List)
                {
                    length++;
                }

                return length;
            }
        }

        [DDTAction]
        [DDTDoc("Index into a List")]
        public class Index : DDTAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("List object")]
            public IEnumerable List = null;

            [DDTParam(Required = true, Position = 1)]
            [DDTDoc("List Index")]
            public int index = 0;

            public override Object Invoke()
            {
                if (List == null)
                {
                    throw new Exception("Index : Parameter 'List' is null");
                }            
                
                if (index < 0)
                {
                    throw new Exception("Index : Index out of range : " +
                                        index);
                }

                int i = 0;
                foreach (Object element in List)
                {
                    if (i++ == index)
                    {
                        return element;
                    }
                }
                
                throw new Exception("Index : Index out of range : " +
                                    index);
            }
        }

        [DDTAction]
        [DDTDoc("Catch a particular type of exception")]
        public class Catch : DDTXmlAction
        {
            [DDTParam(Name="Exception", Required = true)]
            [DDTDoc("Type of the exception to catch")]
            public String ExceptionString = String.Empty;

            [DDTParam]
            [DDTDoc("Whether it's an error if the Exception is not seen")]
            public bool Required = false;

            private DDTEnvironment e = null;
            private Type eType = null;
            private int index = 0;

            public override Object Invoke(DDTEnvironment e)
            {
                // Get the exception type
                eType = DDTHelper.SearchType(ExceptionString);
                
                if (eType == null)
                {
                    throw new DDTException("Catch : Unknown type : '" + 
                                           ExceptionString + 
                                           "'");
                }

                this.e = e;
                return RunContinuation(null);
            }

            
            private Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);
                Exception exception = null;

                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        e);

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {                                
                    try
                    {                    
                        for (int i = index;i < this.SubActionNodes.Count;i++)
                        {
                            XmlNode subAction = 
                                (XmlNode)this.SubActionNodes[i];
                            
                            if (inContinuation)
                            {
                                inContinuation = false;
                                DDTContinuation.EndContinuation();
                            }
                            else
                            {
                                e.ExecuteAction(subAction);
                            }

                            index++;
                        }
                    }
                    catch (Exception ex)
                    {
                        // Do not catch coninuation exceptions
                        if (ex is DDTContinuationException)
                        {
                            throw;
                        }

                        if (ex.GetType() == typeof(DDTExtendedException))
                        {
                            ex = ex.GetBaseException();
                        }

                        if ((ex.GetType() == eType) || 
                            (ex.GetType().IsSubclassOf(eType)))
                        {
                            exception = ex;
                        }
                        else
                        {
                            // Throw unhandled exception
                            throw;
                        }
                    }
                }

                if ((Required) && (exception == null))
                {
                    throw new Exception
                        ("Catch : Did not get required exception '" + 
                         ExceptionString + "'");
                }
                
                return exception;
            }
        }

        [DDTAction]
        [DDTDoc("Throw an exception")]
        public class Throw : DDTAction
        {
            [DDTParam(Name="Exception", ImpliedSource="Catch",
                      Required = true, Position = 0)]
            [DDTDoc("Exception to throw")]
            public Exception ExceptionObject = null;
            
            public override Object Invoke()
            {
                if (ExceptionObject == null)
                {
                    throw new DDTException(
                        "Throw : Cannot throw 'null' object");
                }

                throw ExceptionObject;
            }
        }

        // XML related actions
        [DDTAction]
        [DDTDoc("Get the subactons specified as a XML string without " +
                "any processing. The XML must be well-formed")]
        public class Quote : DDTXmlAction
        {            
            public override Object Invoke(DDTEnvironment e)
            {
                String xmlStr = String.Empty;

                foreach (XmlNode child in this.SubActionNodes)
                {
                    xmlStr += child.OuterXml;
                }

                return xmlStr;
            }
        }

        // Actions related to asynchronous execution
        [DDTAction]
        [DDTDoc("Mark an action block to be continued in the worker thread " +
                "when an asyncronous operation is performed")]
        public class Async : DDTXmlAction
        {
            // The index of the currently executing sub-action
            protected int index = 0;
            
            protected DDTContinuationResult result = 
            new DDTContinuationResult();

            protected DDTEnvironment env = null;

            public Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);
                Object output = null;

                // All the stuff is done in a continuation context
                // which is saved if the subaction decides to stop execution
                // in the current thread
                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        new DDTContinuationCanary());

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {

                    try
                    {
                        // Start from where we left off
                        for (int i = index;i < this.SubActionNodes.Count;i++)
                        {
                            XmlNode subAction = 
                                (XmlNode)this.SubActionNodes[i];
                            
                            if (inContinuation)
                            {
                                output = DDTContinuation.EndContinuation();
                                inContinuation = false;
                            }
                            else
                            {                            
                                output = env.ExecuteAction(subAction);
                            }

                            index++;                            
                        }                   
                        
                        // Set the Async result to the result
                        // of the last sub action and set the Async result
                        // as completed
                        this.result.Complete(output, null);                 
                    }
                    catch (DDTContinuationException)
                    {
                        // Some sub action was started asynchronously
                        // result is in incomplete state
                    }
                    catch (Exception e)
                    {                   
                        if (inContinuation)
                        {
                            inContinuation = false;
                            // Store the exception in the async result
                            this.result.Complete(null, e);
                        }
                        else
                        {
                            // If we are not in continuation throw the
                            // exception immediately
                            throw;
                        }
                    }
                }

                // return the Async result back
                return this.result;
            }

            public override object Invoke(DDTEnvironment e)
            {
                this.env = e;
                return RunContinuation(null);
            }            
        }
        
        [DDTAction]
        [DDTDoc("Execute the subactions in a separate worker thread")]        
        public class Parallel : DDTXmlAction
        {
            private DDTEnvironment env = null;
            private int index = 0;

            private DDTContinuationResult result = 
            new DDTContinuationResult();

            private delegate Object ParallelDelegate();            
            private ParallelDelegate pDelegate = null;

            public override Object Invoke(DDTEnvironment e)
            {
                // Create a new environment for Parallel so that
                // variables defined within it do not trample with
                // other parallel executions
                this.env = new DDTEnvironment(e);
                
                // Invoke the subaction in a separate thread
                pDelegate  = new ParallelDelegate(this.InvokeDelegate);
                pDelegate.BeginInvoke(
                    new AsyncCallback(this.EndDelegate),
                    null);

                return result;
            }

            // Marke the parallel block as completed
            private void EndDelegate(IAsyncResult result)
            {
                pDelegate.EndInvoke(result);
            }

            // Just run the continuation method
            private Object InvokeDelegate()
            {
                return RunContinuation(null);
            }

            public Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);
                Object output = null;

                // All the stuff is done in a continuation context
                // which is saved if the subaction decides to stop execution
                // in the current thread
                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        new DDTContinuationCanary());

                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {

                    try
                    {
                        // Start from where we left off
                        for (int i = index;i < this.SubActionNodes.Count;i++)
                        {
                            XmlNode subAction = 
                                (XmlNode)this.SubActionNodes[i];
                            
                            if (inContinuation)
                            {
                                inContinuation = false;
                                output = DDTContinuation.EndContinuation();
                            }
                            else
                            {                            
                                output = env.ExecuteAction(subAction);
                            }

                            index++;                            
                        }                   
                        
                        // Set the Async result to the result
                        // of the last sub action and set the Async result
                        // as completed
                        this.result.Complete(output, null);                 
                    }
                    catch (DDTContinuationException)
                    {
                        // Some sub action was started asynchronously
                        // result is in incomplete state
                    }
                    catch (Exception e)
                    {                   
                        if (inContinuation)
                        {
                            inContinuation = false;
                            // Store the exception in the async result
                            this.result.Complete(null, e);
                        }
                        else
                        {
                            // If we are not in continuation throw the
                            // exception immediately
                            throw;
                        }
                    }
                }

                // return the Async result back
                return this.result;
            }
            
        }

        [DDTAction("Get-AsyncResult")]
        [DDTDoc("Wait for an asynchronous operation to complete and get " + 
                "its result")]
        public class Get_AsyncResult : DDTAction
        {
            [DDTParam(Required = true, Position = 0)]
            [DDTDoc("The IAsyncResult object")]
            public IAsyncResult Async = null;

            public override Object Invoke()
            {
                if (Async == null)
                {
                    throw new DDTException("Get-AsyncResult : " + 
                                           "'Async' object is null");
                }

                // Wait for the asyncronous operation to complete
                // if it's not already completed
                if (!Async.IsCompleted)
                {
                    Async.AsyncWaitHandle.WaitOne();
                }
                
                // Return the async result state
                return Async.AsyncState;
            }
        }
        
    } // class BuiltInActionCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuationCanary.cs ===
using System;

namespace DDT
{
    /// <summary>
    /// Just a type to indicate boundaries in the Continuatons stack
    /// </summary>    
    public class DDTContinuationCanary
    {
        // empty
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuationCallback.cs ===
using System;

namespace DDT
{
    // Delegate for setting a continuation point
    public delegate Object DDTContinuationCallback(Object state);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuationContext.cs ===
using System;

namespace DDT
{
    /// <summary>
    /// Class to maintain a Continuation callback and the context object
    /// </summary>    
    public class DDTContinuationContext
    {
        public DDTContinuationCallback Continuation = null;
        public Object Context = null;

        public DDTContinuationContext(DDTContinuationCallback continuation,
                                      Object context)
        {
            Continuation = continuation;
            Context = context;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuationContextGuard.cs ===
using System;

namespace DDT
{
    // A class to manage the life cycle of a DDTContinuationContext
    // For use by DDTXmlAtion classes
    public class DDTContinuationContextGuard : IDisposable
    {
        DDTContinuationContext context = null;

        public DDTContinuationContextGuard(DDTContinuationContext context)
        {
            this.context = context;
        }

        public void Dispose()
        {
            DDTContinuationContext context = 
                DDTContinuation.PopContinuation();

            if (context != this.context)
            {
                throw new DDTException
                    ("Internal Error : Mismatched Continuation contexts" +
                     " in stack");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTConstraints.cs ===
using System;
using System.Collections;
using System.Xml;

namespace DDT
{
    /// <summary>
    /// Class to hold a set of conditions and evalaute it later as needed
    /// </summary>    
    public class DDTConstraints
    {
        private ArrayList subActionNodes = null;

        public DDTConstraints(ArrayList subActionNodes)
        {
            this.subActionNodes = subActionNodes;
        }

        /// <summary>
        /// Evaluate the Constraints block in the given environment
        /// Returns true if all boolean values of sub actions are true
        /// and there were no exceptions thrown by the sub actions.
        /// </summary>        
        public bool Evaluate(DDTEnvironment e)
        {
            EvaluateContext context = new EvaluateContext();
            context.env = e;
            context.index = 0;
            return (bool)RunContinuation(context);
        }

        public class EvaluateContext
        {
            public DDTEnvironment env = null;
            public int index = 0;
            public bool inContinuation = false;
        }

        private bool getResult(Object returnVal)
        {
            bool result = true;

            if (returnVal == null)
            {
                return true;
            }

            // bool values should be true
            if (returnVal.GetType() == typeof(bool))
            {
                bool r = (bool)returnVal;
                    
                if (r == false)
                {
                    result = false;
                }
            }
            else if (returnVal.GetType().GetInterface("IEnumerable") 
                     != null)
            {
                // There might be list of bool values 
                // All of them should be true                
                ArrayList flattenedList = 
                    DDTHelper.Flatten((IEnumerable)returnVal);
                
                foreach (Object element in flattenedList)
                {
                    if (element == null)
                    {
                        continue;
                    }
                    
                    if (element.GetType() == typeof(bool))
                    {
                        bool b = (bool)element;
                        
                        if (b == false)
                        {
                            result = false;
                            break;
                        }
                    }
                }
            }

            return result;
        }

        private Object RunContinuation(Object state)
        {
            EvaluateContext context = (EvaluateContext)state;
            bool inContinuation = context.inContinuation;                
            Object returnVal = null;
            bool result = true;

            context.inContinuation = true;
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(this.RunContinuation),
                    context);
            
            // The guard takes care of popping the continuation
            // context when we are done with the operations
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {
                for (int i = context.index;i < this.subActionNodes.Count;i++)
                {
                    XmlNode subAction = (XmlNode)this.subActionNodes[i];

                    if (inContinuation)
                    {
                        inContinuation = false;
                        returnVal = DDTContinuation.EndContinuation();
                    }
                    else
                    {
                        returnVal = context.env.ExecuteAction(subAction);
                    }
                    
                    result = getResult(returnVal);

                    // Exit when we encounter the first false value
                    // The rest of the sub actions are not evaluated
                    if (!result)
                    {
                        break;
                    }                    
                    
                    context.index++;
                }
            }
            
            return result;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuation.cs ===
using System;
using System.Threading;

using System.Collections.Generic;

namespace DDT
{
    public class DDTContinuation
    {
        // Continuations information per thread
        [ThreadStatic]
        private static Stack<DDTContinuationContext> continuations;

        [ThreadStatic]
        private static Exception currentException;

        [ThreadStatic]
        private static Object currentResult;
        
        // Store the current continuation point
        public static DDTContinuationContext 
        PushContinuation(DDTContinuationCallback continuation,
                         Object state)
        {
            if (continuations == null)
            {
                continuations = new Stack<DDTContinuationContext>();
            }

            DDTContinuationContext context = 
                new DDTContinuationContext(continuation, state);
            
            continuations.Push(context);

            return context;
        }

        // Pop the next Continuation Context
        public static DDTContinuationContext PopContinuation()
        {
            if (continuations == null)
            {
                return null;
            }

            if (continuations.Count > 0)
            {
                return continuations.Pop();
            }
            else
            {
                return null;
            }
        }

        // Peek into the continuations stack
        public static DDTContinuationContext TopContinuation()
        {
            if (continuations == null)
            {
                return null;
            }

            if (continuations.Count > 0)
            {
                return continuations.Peek();
            }
            else
            {
                return null;
            }
        }

        // Remove all continuations
        public static void ResetContinuations()
        {
            continuations.Clear();
        }

        
        // Create a AsyncCallback with Continuation
        // This is only for use by the Async action implementor
        public static AsyncCallback Callback
        {
            get
            {
                return new AsyncCallback(DDTContinuation.HandleAsyncCallback);
            }
        }

        // State is the continuation stack that is passed on as the state
        // for the asynchronous callback
        // This is only for use by the Async action implementor
        public static Object State(DDTContinuationCallback callback)
        {
            DDTContinuationContext[] array = continuations.ToArray();
                
            // Clone the continuation stack
            Stack<DDTContinuationContext> clone
                = new Stack<DDTContinuationContext>();
            
            for (int i = array.Length - 1; i >=0; i--)
            {
                clone.Push(array[i]);
            }

            // Add the current callback to the cloned stack
            DDTContinuationContext context = 
                new DDTContinuationContext(callback, null);
            clone.Push(context);
            
            return clone;            
        }

        // Called as the last step from an async action implementation
        // This is only for use by the Async action implementor
        public static Object Continue()
        {
            throw new DDTContinuationException("Async action was started");
        }


        // Get the current Continuation result and reset the result
        public static Object EndContinuation()
        {
            Exception ex = currentException;
            Object result = currentResult;

            currentException = null;
            currentResult = null;

            if (ex != null)
            {
                throw ex;
            }
            
            return result;
        }

        // This will be called in the context of the worker thread
        public static void HandleAsyncCallback(IAsyncResult result)
        {           
            // Reset the current result and exception
            currentResult = null;
            currentException = null;

            // Make the continuations stack passed in as the stack for the 
            // current thread
            continuations
                = (Stack<DDTContinuationContext>)result.AsyncState;


            DDTContinuationContext context  = PopContinuation();
            int index = 0;
            while (context != null)
            {
                try
                {
                    if (index++ == 0)
                    {
                        // Send the async result to the
                        // first continuation, which is the action that
                        // started the async operation
                        currentResult = context.Continuation(result);
                    }
                    else
                    {
                        // Do the continuation callback
                        currentResult = context.Continuation(context.Context);
                    }

                    // Clear the exception if execution was successful
                    currentException = null;

                    // An async block puts the continuation canary
                    // to indicate continuation stops at that level
                    // of the continuation stack
                    if ((context.Context != null) &&
                        (context.Context.GetType()
                         == typeof(DDTContinuationCanary)))
                    {
                        break;
                    }
                }
                catch (Exception e)
                {
                    currentException = e;
                }

                context  = PopContinuation();
            }
            
            // This worker thread is done - Clear Exception and result 
            currentResult = null;
            currentException = null;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinue.cs ===
using System;

namespace DDT
{
    public class DDTContinue {}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuationException.cs ===
using System;

namespace DDT
{
    /// <summary>
    /// The sole purpose of this exception is to unwind the call stack when an 
    /// asynchronous action is started
    /// Like a DDTException you should never catch it in your action
    /// unless you know what you are doing
    /// </summary>
    public class DDTContinuationException : DDTException
    {
        public DDTContinuationException(String msg) : base(msg)
        {
            // empty
        }

        public DDTContinuationException(String msg, Exception inner) : 
            base(msg, inner)
        {
            // empty
        }

        public DDTContinuationException(String msg,
                                        String ddtStackTrace,
                                        DDTEnvironment env,
                                        Exception inner) : 
            base(msg, ddtStackTrace, env, inner)
        {
            // empty
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTDocAttribute.cs ===
using System;

namespace DDT
{
    public class DDTDocAttribute : Attribute
    {
        public String Message = String.Empty;

        public DDTDocAttribute() { }
        
        public DDTDocAttribute(String msg)
        {
            Message = msg;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTCross.cs ===
using System;
using System.Collections;

namespace DDT
{
    /// <summary>
    /// Calculate cross product of sequences
    /// </summary>    
    public class DDTCross
    {
        private DDTEnvironment e = null;
        private DDTConstraints constraints = null;
        
        private ArrayList variables = null;        
        private ArrayList enumerators = new ArrayList();
        
        private bool initialized = false;

        // Optional filter for values generated
        private IDDTCrossFilter filter = null;


        // Check whether the current set of values satisfies the constraints
        private bool satisfiesConstraints(ArrayList values)
        {
            // Set the value of the variables in the current environment
            int i = 0;
            foreach (String var in this.variables)
            {
                this.e.DefineVariable(var, values[i++]);
            }

            if (this.constraints == null)
            {
                // No constraints
                return true;
            }
            else
            {
                // Evaluate the 'Constraints' block in the environment
                // with the new variables defined                
                return this.constraints.Evaluate(e);
            }
        }
        
        /// <summary>
        /// Create a DDTCross object
        /// </summary>        
        public static DDTCross Initialize(DDTEnvironment e,
                                          ArrayList variables,
                                          ArrayList valuesList,
                                          bool chooseOne,
                                          Random rand,
                                          DDTConstraints constraints,
                                          IDDTCrossFilter filter)
        {
            DDTCross cross = new DDTCross();
            
            cross.e = e;
            cross.variables = variables;

            cross.constraints = constraints;
            cross.filter = filter;
            
            foreach (IEnumerable values in valuesList)
            {
                cross.enumerators.Add(values.GetEnumerator());
            }

            // If we need only one value
            // Randomly choose a value and make it the
            // only value of the enumeration
            if (chooseOne)
            {
                ArrayList randomValuesList = new ArrayList();

                // If the random number generator has not been initialized
                // yet, initialize it
                // Executing it as a action stores the same Random
                // number generator for future use
                if (rand == null)
                {
                    rand = (Random)e.ExecuteAction("<Rand/>");
                }
                
                // Get the full combination list that satisfy
                // the given constraints
                ArrayList fullCombination = new ArrayList();                
                while (cross.MoveNext())
                {
                    fullCombination.Add(cross.Current());
                }

                if (fullCombination.Count == 0)
                {
                    // There are no values. Just add an empty list
                    randomValuesList.Add(new ArrayList());
                }
                else
                {
                    int index = rand.Next(fullCombination.Count);
                    ArrayList selectedValues = 
                        (ArrayList)fullCombination[index];
                    
                    foreach (Object o in selectedValues)
                    {
                        ArrayList singleValueList = new ArrayList();
                        singleValueList.Add(o);

                        randomValuesList.Add(singleValueList);
                    }                    
                }
                
                // Re-initialize the enumerators list
                // with the singleton enumerators
                cross.enumerators = new ArrayList();
                cross.initialized = false;
                foreach (IEnumerable values in randomValuesList)
                {
                    cross.enumerators.Add(values.GetEnumerator());
                }
            }

            return cross;
        }

        /// <summary>
        /// Get the current set of values in the cross product
        /// </summary>        
        public ArrayList Current()
        {
            ArrayList current = new ArrayList();

            foreach (IEnumerator e in this.enumerators)
            {
                current.Add(e.Current);
            }

            return current;
        }

        /// <summary>
        /// Move to the next set of values in the cross product
        /// </summary>        
        public bool MoveNext()
        {
            return (bool)MoveNextContinuation(null);
        }

        public Object MoveNextContinuation(Object state)
        {
            bool moved = false;
            bool inContinuation = (state != null);

            while (true)
            {
                moved = false;            
                ArrayList current = null;
                bool satisfies = false;
                do // Do till we find a value allowed by the filter
                {

                    // If we came back from a continuation
                    // see if the last constraint was satisfied
                    if (inContinuation)
                    {
                        inContinuation = false;
                        moved = true;

                        // Get the result returned by satifisyConstraints
                        // in the continuation
                        satisfies = 
                            (bool)DDTContinuation.EndContinuation();
                        
                        current = Current();

                        continue;
                    }

                    // This is the part where non-Continuation execution starts
                    moved = false;
                    
                    // We haven't been initialized yet
                    if (!this.initialized)
                    {
                        bool allNonEmpty = true;
                        
                        foreach (IEnumerator enm in this.enumerators)
                        {
                            // Even if one of the enumerators is empty
                            // return empty result back
                            if (!enm.MoveNext())
                            {
                                allNonEmpty = false;
                            }
                        }
                        
                        this.initialized = true;                
                        moved = allNonEmpty;
                    }
                    else
                    {
                        // Move the last element. If it's false, 
                        // move the previous element
                        // and so on...
                        int i = this.enumerators.Count - 1;
                        do
                        {
                            IEnumerator enm = (IEnumerator)this.enumerators[i];
                            
                            if (enm.MoveNext())
                            {
                                moved = true;
                            }
                            else
                            {
                                i--;
                            }
                        } while ((i >= 0 ) && (!moved));
                        
                        if (moved)
                        {
                            // Reset all subsequent counters than the one 
                            // successfully moved
                            for (int j = i+1;j < this.enumerators.Count;j++)
                            {
                                IEnumerator enm = 
                                    (IEnumerator)this.enumerators[j];
                                enm.Reset();
                                enm.MoveNext();
                            }
                        }
                    }
                
                    // Move until we find a allowed value or reach the end
                    if (moved)
                    {
                        current = Current();

                        // Save the position for continuation
                        DDTContinuationContext context =
                            DDTContinuation.PushContinuation(
                                new DDTContinuationCallback(
                                    this.MoveNextContinuation),
                                current);

                        // The guard takes care of popping the continuation
                        // context when we are done with the operations
                        using (DDTContinuationContextGuard guard = 
                               new DDTContinuationContextGuard(context))
                        {                        

                            // See if we satisfy the constraints
                            // This can result in a continuation
                            satisfies = satisfiesConstraints(current);
                        }
                    }
                    
                } while ((moved) &&
                         ((!satisfies) || 
                          ((this.filter != null) &&
                           (!this.filter.Allow(current)))));


                // If we reached the end of combinations
                // See if we need another pass                    
                if ((!moved) && 
                    (this.filter != null) && 
                    (!this.filter.Done))
                {
                    foreach (IEnumerator enm in this.enumerators)
                    {
                        enm.Reset();
                        this.initialized = false;
                    }
                }
                else
                {
                    // We are done
                    break;
                }
            }
            
            return moved;
        }

        /// <summary>
        /// Reset cross product enumeration
        /// </summary>        
        public void Reset()
        {
            foreach (IEnumerator e in this.enumerators)
            {
                e.Reset();
            }

            if (this.filter != null)
            {
                this.filter.Reset();
            }

            // Move it before the first element
            this.initialized = false;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTEnvironmentAction.cs ===
using System;
using System.Collections;

namespace DDT
{
    /// <summary>
    /// Use DDTEnvironmentAction to write actions that will change the
    /// execution environment
    /// </summary>    
    public abstract class DDTEnvironmentAction
    {
        public Hashtable _SeenParameters = null;

        public abstract Object Invoke(DDTEnvironment e);

        public bool ParameterExists(String name)
        {
            if (_SeenParameters != null)
            {
                return (_SeenParameters.ContainsKey(name.ToLower()));
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTContinuationResult.cs ===
using System;
using System.Threading;

namespace DDT
{
    public class DDTContinuationResult : IAsyncResult
    {
        private ManualResetEvent completedEvent = null;        
        private byte completed = 0;
        
        private Object result = null;
        private Exception exception = null;
        
        // Mark the async operation as Complete
        // Called by the async handler method
        public void Complete(Object result, Exception exception)
        {
            this.result = result;
            this.exception = exception;

            completed = 1;
            
            if (completedEvent != null)
            {
                completedEvent.Set();
            }
        }


        // IAsyncResult interface property implementations
        public object AsyncState
        {
            get
            {
                if (exception != null)
                {
                    throw new Exception("Async execution threw an exception : "
                                        + exception.Message,
                                        exception);
                }
                
                return result;
            }
        }
        
        public bool CompletedSynchronously
        {
            get
            {
                return(false);
            }
        }

        public bool IsCompleted
        {
            get
            {
                return (Thread.VolatileRead(ref completed) == 1);
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
            { 
                if (completedEvent == null)
                {
                    bool done = IsCompleted;
                    ManualResetEvent mre = new ManualResetEvent(done);

                    if (Interlocked.CompareExchange(
                            ref completedEvent, mre, null) != null)
                    {
                        // Another thread created this event
                        mre.Close();
                    }
                    else
                    {
                        if (!done && IsCompleted)
                        {
                            // If the operation wasn't done when we created
                            // the event but is now
                            completedEvent.Set();
                        }
                    }
                }

                return completedEvent;
            }
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTException.cs ===
using System;


namespace DDT
{
    /// <summary>
    /// Allows us to differentiate problems while setting up an action
    /// for execution versus problem in execution
    /// </summary>    
    public class DDTException : Exception
    {
        protected string ddtStackTrace = String.Empty;

        public DDTEnvironment LastEnv = null;
        
        public DDTException(String msg) : base(msg)
        {
            // empty
        }

        public DDTException(String msg, 
                            Exception inner) : base(msg, inner)
        {
            // empty
        }
        
        public DDTException(String msg,
                            String ddtStackTrace,
                            DDTEnvironment env,
                            Exception inner) : base(msg, inner)
        {
            this.ddtStackTrace = ddtStackTrace;
            this.LastEnv = env;
        }

        public override string StackTrace
        {
            get
            {
                return this.ddtStackTrace;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionList.cs ===
using System;
using System.Collections; 

namespace DDT
{
    /// <summary>
    /// Encapsulation of a parameter list and the parameter modifier
    /// (whether passed by reference)
    /// </summary>    
    public class DDTExpressionList
    {
        protected ArrayList valueList = new ArrayList();
        protected ArrayList modifierList = new ArrayList();

        public ArrayList ValueList
        {
            get
            {
                return valueList;
            }
        }

        public ArrayList ModifierList
        {
            get
            {
                return modifierList;
            }            
        }

        public int Count
        {
            get
            {
                return valueList.Count;
            }
        }

        public void AddValue(Object val)
        {
            valueList.Add(val);
            modifierList.Add(DDTHelper.ValueTypes.Value);
        }

        public void AddReference(IDDTReference reference)
        {
            valueList.Add(reference);
            modifierList.Add(DDTHelper.ValueTypes.Reference);
        }

        public bool HasReferenceObjects()
        {
            bool hasRefs = false;

            foreach (DDTHelper.ValueTypes valueType in modifierList)
            {
                if (valueType == DDTHelper.ValueTypes.Reference)
                {
                    hasRefs = true;
                    break;
                }
            }
            
            return hasRefs;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExecuteActionContext.cs ===
using System;
using System.Collections;
using System.Xml;

namespace DDT
{
    // The possible states ExecuteAction can (re)start in
    public enum ExecuteActionState
    {
        Initial,
        EvalTextNode,
        ProcessParameters,
        InvokeAction,
        AssignOutput,
        Completed
    }

    /// <summary>
    /// Maintain state of action execution across continuations
    /// </summary>    
    public class DDTExecuteActionContext
    {
        public XmlNode XmlNode = null;
        public ExecuteActionState State = ExecuteActionState.Initial;
        
        public String ActionNodeName = String.Empty;

        // Variables for EvalTextNode state
        public ArrayList TextNodes = null;
        public int TextNodeIndex = 0;
        
        // Variables for ProcessParameters state
        public bool ProcessingParameters = false;
        
        public bool ProcessChildNodes = false;
        public DDTActionInfo ActionInfo = null;
        public DDTEnvironmentAction Action = null;
        public String OutputVariableName = String.Empty;
        public Hashtable SeenParameters = null;
        public int ChildNodeIndex = 0;
        public int ParameterPosition = 0;
        public int ParameterTextNodeIndex = 0;
        public bool ProcessingTextNodeParameter = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTGlobal.cs ===
using System;

namespace DDT
{
    public class DDTGlobal
    {
        public static IDDTLogger RO = new DDTConsoleLogger();

        public static void SetLogger(IDDTLogger logger)
        {
            lock (RO)
            {
                RO = logger;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTFieldReference.cs ===
using System;
using System.Reflection;

namespace DDT
{
    public class DDTFieldReference : IDDTReference
    {
        protected FieldInfo field;
        protected Object source;

        public DDTFieldReference(FieldInfo field, 
                                 Object source)
        {
            this.field = field;
            this.source = source;
        }
        
        Object IDDTReference.GetValue()
        {
            try
            {
                return field.GetValue(this.source);
            }
            catch (Exception e)
            {
                String msg = e.Message;
                Exception inner = e;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                    inner = e.InnerException;
                }

                throw new DDTException(msg);
            }
        }

        void IDDTReference.SetValue(Object val)
        {
            try
            {
                field.SetValue(this.source, val);
            }
            catch (Exception e)
            {
                String msg = e.Message;
                Exception inner = e;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                    inner = e.InnerException;
                }

                throw new DDTException(msg);
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExtendedException.cs ===
using System;
using System.Runtime.Serialization;
using System.Collections;
using System.Security.Permissions;

namespace DDT
{
    public class DDTExtendedException : Exception
    {
        protected String ddtStackTrace = String.Empty;
        protected Exception baseException = null;

        public DDTEnvironment LastEnv = null;

        public DDTExtendedException(Exception baseException,
                                    String ddtStackTrace,
                                    DDTEnvironment env) :
            base(baseException.Message, baseException.InnerException)
        {
            this.baseException = baseException;
            this.ddtStackTrace = ddtStackTrace;
            this.LastEnv = env;
        }
        
        public override IDictionary Data
        {
            get
            {
                return baseException.Data;
            }
        }

        public override Exception GetBaseException()
        {
            return this.baseException;
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info,
                                           StreamingContext context)
        {
            baseException.GetObjectData(info, context);
        }

        public override string HelpLink
        {
            get
            {
                return baseException.HelpLink;
            }
        }

        public override  string Source
        {
            get
            {
                return baseException.Source;
            }
            set
            {
                baseException.Source = value;
            }
        }

        public override string StackTrace
        {
            get
            {
                return ddtStackTrace;
            }
        }

        public override string Message
        {
            get
            {
                return baseException.Message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTModelAction.cs ===
using System;
using System.Collections;
using System.Xml;

namespace DDT
{
    public class DDTModelAction
    {
        public String Name = String.Empty;
        public int Weight = 1;
        private DDTEnvironment enclosingEnv = null;
        private ArrayList subActionNodes = null;
        private DDTConstraints constraints = null;

        // Constructor
        public DDTModelAction(DDTEnvironment e,
                              ArrayList subActionNodes,
                              String name,
                              int weight,
                              DDTConstraints constraints)
        {
            if (weight < 1)
            {
                throw new Exception("Invalid weight : " + weight);
            }

            this.enclosingEnv = e;
            this.subActionNodes = subActionNodes;
            this.Name = name;
            this.Weight = weight;
            this.constraints = constraints;
        }

        // Check whether the constraints(if any) are satisfied in the 
        // current environment state
        public bool ConstraintsSatisfied()
        {
            if (this.constraints == null)
            {
                return true;
            }
            else
            {
                return this.constraints.Evaluate(this.enclosingEnv);
            }
        }
        
        // Execute the model action in a new environment
        // The sub actions may be executed across continuations
        public Object Execute()
        {
            // Create a new environment and execute the sub actions in it
            DDTEnvironment env = new DDTEnvironment(this.enclosingEnv);

            ExecuteContext context = new ExecuteContext();
            context.e = env;
            
            return ExecuteContinuation(context);                
        }
            
        public class ExecuteContext
        {
            public DDTEnvironment e;
            public int index = 0;
            public bool inContinuation = false;
        }

        private Object ExecuteContinuation(Object state)
        {
            ExecuteContext context = (ExecuteContext)state;
            bool inContinuation = context.inContinuation;

            Object returnVal = null;

            context.inContinuation = true;
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(ExecuteContinuation),
                    context);
            
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {   
                for (int i = context.index;i < this.subActionNodes.Count;i++)
                {
                    XmlNode subAction = (XmlNode)this.subActionNodes[i];
                    
                    if (inContinuation)
                    {
                        // Complete the action that started the continuation
                        inContinuation = false;
                        returnVal = DDTContinuation.EndContinuation();
                    }
                    else
                    {
                        returnVal = context.e.ExecuteAction(subAction);
                    }

                    context.index++;
                }
            }

            // Return value is the return from the last action
            return returnVal;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTParamAttribute.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace DDT
{
    public class DDTParamAttribute : Attribute
    {
        public String Name = String.Empty;
        public String ImpliedSource = String.Empty;
        public bool Required = false;
        public int Position = -1;

        public DDTParamAttribute() { }

        public DDTParamAttribute(String name)
        {
            Name = name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTModel.cs ===
using System;
using System.Collections;
using System.Xml;

namespace DDT
{
    public class DDTModel
    {
        private ArrayList subActionNodes = null;
        private ArrayList actions = null;
        private DDTEnvironment enclosingEnv = null;
        
        protected DDTEnvironment modelEnv = null;

        protected int index = 0;

        // Get the list of Model variables
        public ArrayList Variables
        {
            get
            {
                if (modelEnv != null)
                {
                    // Return only public variables and not the action
                    // output variables and other special variables
                    // which begin with a $
                    ArrayList validVars = new ArrayList();
                    foreach (String var in modelEnv.Variables.Keys)
                    {
                        bool isReserved;
                        if (DDTHelper.IsValidVariableName(var, 
                                                          out isReserved))
                        {
                            validVars.Add(var);
                        }
                    }

                    return validVars;
                }
                else
                {
                    return new ArrayList();
                }
            }            
        }

        // Allow read access to model variables
        public Object this [String varName]
        {
            get
            {
                // Allow only model variables to be queried
                DDTEnvironment env = this.modelEnv.GetVarEnv(varName);

                if ((env == null) || (env != this.modelEnv))
                {
                    throw new Exception
                        ("Uknown model variable : '" + varName + "'");
                }
                
                return this.modelEnv.GetVariable(varName);
            }
        }

        public DDTModel(DDTEnvironment enclosingEnv,
                        ArrayList subActionNodes)
        {            
            this.enclosingEnv = enclosingEnv;
            this.subActionNodes = subActionNodes;
            
            // Initialize model state and actions
            Reset();
        }

        // Re-Initialize the model state and actions
        public void Reset()
        {
            this.actions = new ArrayList();

            // Create a new environment for the Model
            this.modelEnv = new DDTEnvironment(this.enclosingEnv);
                        
            this.index = 0;
            ResetContinuation(null);
        }
        
        public Object ResetContinuation(Object state)
        {
            bool inContinuation = (state != null);

            // Execute the sub actions in the model's new environment
            // This will define the model variables and the model actions
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(ResetContinuation),
                    this.modelEnv);
            
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {
                for (int i = this.index;i < this.subActionNodes.Count;i++)
                {
                    XmlNode subAction = (XmlNode)this.subActionNodes[i];
                    
                    Object a = null;                    
                    if (inContinuation)
                    {
                        inContinuation = false;
                        a = DDTContinuation.EndContinuation();
                    }
                    else
                    {
                        a = this.modelEnv.ExecuteAction(subAction);
                    }
                
                    if (a == null)
                    {
                        continue;
                    }
                    
                    if (a.GetType() == typeof(DDTModelAction))
                    {
                        this.Add((DDTModelAction)a);
                    }
                    else if (a.GetType().GetInterface("IEnumerable") != null)
                    {
                        ArrayList flattenedList = 
                            DDTHelper.Flatten((IEnumerable)a);
                        
                        foreach (Object element in flattenedList)
                        {
                            if (element == null)
                            {
                                continue;
                            }
                            
                            if (element.GetType() == typeof(DDTModelAction))
                            {
                                this.Add((DDTModelAction)element);
                            }
                        }
                    }

                    this.index++;
                } // for
            } // using 

            // Return the current model object back
            return this;
        }

        // Add a model action to the actions list
        public void Add(DDTModelAction action)
        {
            // Make sure there isn't an action of the same name
            foreach (DDTModelAction a in this.actions)
            {
                if (a.Name == action.Name)
                {
                    throw new DDTException(
                        "Duplicate Action : '" + a.Name + "'");
                }
            }

            this.actions.Add(action);
        }

        // Check whether the model is in a state where no actions are possible
        public bool InFinalState()
        {
            FinalStateContext context = new FinalStateContext();
            return (bool)InFinalStateContinuation(context);
        }
        
        public class FinalStateContext
        {
            public int index = 0;
            public bool inContinuation = false;
        }

        public Object InFinalStateContinuation(Object state)
        {
            FinalStateContext context = (FinalStateContext)state;
            bool inContinuation = context.inContinuation;
            bool inFinalState = true;

            context.inContinuation = true;
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(InFinalStateContinuation),
                    context);
            
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {
                for (int i = context.index;i < this.actions.Count;i++)
                {                    
                    DDTModelAction action = (DDTModelAction)this.actions[i];

                    bool satisfied;

                    if (inContinuation)
                    {
                        inContinuation = false;
                        satisfied = (bool)DDTContinuation.EndContinuation();
                    }
                    else
                    {
                        satisfied = action.ConstraintsSatisfied();
                    }

                    if (satisfied)
                    {
                        // Atleast one action is possible
                        inFinalState = false;
                        break;
                    }
                    
                    context.index++;                    
                } // for
            } // using
            
            return inFinalState;
        }

        // Randomly choose and execute a model action based on the
        // constraints and weights of the actions
        public Object ChooseAndExecute(Random rand)
        {
            if (this.actions == null)
            {
                return null;
            }

            ChooseAndExecuteContext context = new ChooseAndExecuteContext();
            context.rand = rand;

            return ChooseAndExecuteContinuation(context);
        }

        public class ChooseAndExecuteContext
        {
            public Random rand = null;
            public bool inContinuation = false;
            public int actionIndex = 0;
            public ArrayList validActions = new ArrayList();
        }

        private Object ChooseAndExecuteContinuation(Object state)
        {
            ChooseAndExecuteContext context = (ChooseAndExecuteContext)state;
            bool inContinuation = context.inContinuation;

            context.inContinuation = true;
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(ChooseAndExecuteContinuation),
                    context);
            
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {               
                // Get the subset of actions that satisfy the constraints
                for (int i = context.actionIndex;i < this.actions.Count;i++)
                {
                    DDTModelAction action = (DDTModelAction)actions[i];

                    bool satisfied = false;
                    if (inContinuation)
                    {
                        inContinuation = false;
                        satisfied = (bool)DDTContinuation.EndContinuation();
                    }
                    else
                    {
                        // This can potentially start a new continuation
                        satisfied = action.ConstraintsSatisfied();
                    }

                    if (satisfied)
                    {
                        context.validActions.Add(action);
                    }

                    context.actionIndex++;
                }
            }

            if (context.validActions.Count == 0)
            {
                // In a final state. No actions possible
                throw new InvalidOperationException(
                    "Model in final state. No more actions possible");
            }

            // Calculate the total weight of valid actions
            int totalWeight = 0;
            foreach (DDTModelAction action in context.validActions)
            {
                totalWeight += action.Weight;
            }
            
            // Choose a random number from 1 to totalWeight
            int r = context.rand.Next((int)totalWeight) + 1;
            
            // Return the action where the random number lies
            int currentWeight = 0;
            foreach (DDTModelAction action in context.validActions)
            {
                currentWeight += action.Weight;

                if (currentWeight >= r)
                {                 
                    DDTGlobal.RO.Log("\n---Executing Action : " + 
                                     action.Name + " ---");

                    // We don't execute this within a continuation
                    // since we don't have anything else to do here
                    return action.Execute();
                }
            }
            
            // We shouldn't come here
            throw new Exception("ChooseAndExecute : internal error!!");
        }

        // Run a model till a final state is reached
        // Should be used for model that can go into a loop
        public Object Run(int maxSteps, Random rand)
        {            
            RunContext context = new RunContext();

            context.maxSteps = maxSteps;
            context.rand = rand;
            return RunContinuation(context);
        }
        
        public enum RunState
        {
            CheckFinal,
            ModelStep,
            Completed
        }

        public class RunContext
        {
            public Random rand = null;
            public RunState runState = RunState.CheckFinal;
            public int maxSteps = 0;
            public int numSteps = 0;
            public bool inContinuation = false;
        }

        public Object RunContinuation(Object state)
        {
            RunContext context = (RunContext)state;
            bool inContinuation = context.inContinuation;
            
            Object output = null;
            
            context.inContinuation = true;
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(RunContinuation),
                    context);
            
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {   
                do
                {
                    switch (context.runState)
                    {
                        case RunState.CheckFinal:
                        {
                            bool done = false;

                            if (inContinuation)
                            {
                                inContinuation = false;
                                done = (bool)DDTContinuation.EndContinuation();
                            }
                            else
                            {
                                done = this.InFinalState();
                            }
                            
                            context.runState = (done) ? 
                                RunState.Completed : 
                                RunState.ModelStep;
                            break;
                        }

                        case RunState.ModelStep:
                        {
                            if (inContinuation)
                            {
                                inContinuation = false;
                                output = DDTContinuation.EndContinuation();
                            }
                            else
                            {
                                output = ChooseAndExecute(context.rand);
                            }
                            
                            if ((++context.numSteps) >= context.maxSteps)
                            {
                                // Maximum number of steps exceeded
                                context.runState = RunState.Completed;
                            }
                            else
                            {
                                context.runState = RunState.CheckFinal;
                            }
                            break;
                        }
                    }
                } while (context.runState != RunState.Completed);
            }
            
            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTEnvironment.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;

namespace DDT
{
    public class DDTEnvironment
    {
        // Variables for handling Action and Action execution
        public Dictionary<String, DDTActionInfo> Actions = 
            new Dictionary<String, DDTActionInfo>();
        public Dictionary<String, Object> Variables = 
            new Dictionary<String, Object>();
        
        // Track assemblies already loaded into this environment
        protected ArrayList LoadedAssemblyPaths = new ArrayList();

        // Link to the enclosing Environment
        protected DDTEnvironment EnclosingEnv = null;

        // Walk the chain of Envs and returns the variable from the
        // closes one
        public Object GetVariable(String var)
        {
            if (Variables.ContainsKey(var))
            {
                return Variables[var];
            }
            else
            {
                if (EnclosingEnv == null)
                {
                    throw new DDTException("Unknown variable : '$" +
                                           var + "'");                    
                }
                else
                {
                    // Search in the enclosing Environment
                    try
                    {                            
                        return EnclosingEnv.GetVariable(var);
                    }
                    catch (Exception)
                    {
                        throw;
                    }
                }
            }            
        }

        // Set - Sets a variable only if it already exists
        // Otherwise it throws an Exception
        public void SetVariable(String var, Object value)
        {
            DDTEnvironment e = GetVarEnv(var);

            if (e != null)
            {
                e.Variables[var] = value;                
            }
            else
            {
                throw new DDTException("Unknown variable : '$" +
                                           var + "'");
            }        
        }

        // Define a new variable in the current Env
        // Can potentially hide a variable of the same name in the enclosing 
        // Env
        public void DefineVariable(String var, Object value)
        {
            this.Variables[var] = value;
        }

        // Return the reference to the variable
        // which can then be set elsewhere
        public IDDTReference GetVariableReference(String var)
        {
            if (!Variables.ContainsKey(var))
            {
                throw new DDTException("Unknown variable : '$" +
                                       var + "'");                    
            }
            
            return new DDTVariableReference(this, var);            
        }

        // Walk the chain of Envs and return the Env where var is found
        public DDTEnvironment GetVarEnv(String var)
        {
            if (Variables.ContainsKey(var))
            {
                return this;
            }
            else if (EnclosingEnv == null)
            {
                return null;
            }
            else
            {
                return EnclosingEnv.GetVarEnv(var);
            }                
        }

        // Walk the chain of Envs and return the Env where action 
        // is found
        public DDTEnvironment GetActionEnv(String actionName)
        {
            if (Actions.ContainsKey(actionName.ToLower()))
            {
                return this;
            }
            else if (EnclosingEnv == null)
            {
                return null;
            }
            else
            {
                return EnclosingEnv.GetActionEnv(actionName);
            }                
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public DDTEnvironment()
        {
            // Add the built-in actions in the top-level environment only
            // (Environment which is constructed without any enclosing env-s)
            AddActionCollection(typeof(DDTBuiltInActionCollection));
            AddActionCollection(typeof(DDTTestCaseActionCollection));
            AddActionCollection(typeof(DDTModelActionCollection));            

            // Mark the core assembly as loaded after loading the built-ins
            lock (this.LoadedAssemblyPaths)
            {
                this.LoadedAssemblyPaths.Add(
                    Assembly.GetExecutingAssembly().Location);
            }
        }

        /// <summary>
        /// Create an Env enclosed in the given engine
        /// </summary>        
        public DDTEnvironment(DDTEnvironment e)
        {
            this.EnclosingEnv = e;
        }


        // Get the documentation on Action Collection, Action
        private String getDocAttributeString(Type t)
        {
            String docString = String.Empty;

            Object[] attributes =
                t.GetCustomAttributes(typeof(DDTDocAttribute), true);

            if (attributes != null)
            {
                foreach (DDTDocAttribute doc in attributes)
                {
                    docString += doc.Message + "\n";
                }
            }

            return docString;
        }

        // Get the documentation on Action Parameter
        private String getDocAttributeString(FieldInfo f)
        {
            String docString = String.Empty;

            Object[] attributes =
                f.GetCustomAttributes(typeof(DDTDocAttribute), true);

            if (attributes != null)
            {
                foreach (DDTDocAttribute doc in attributes)
                {
                    docString += doc.Message + "\n";
                }
            }

            return docString;
        }

        // Get the DDTParam attribute for a parameter field
        private DDTParamAttribute getParamAttribute(FieldInfo fieldInfo)
        {
            Object[] paramAttributes =
                fieldInfo.GetCustomAttributes(
                    typeof(DDTParamAttribute),
                    true);
                
            if ((paramAttributes == null) || (paramAttributes.Length == 0))
            {
                return null;
            }
            else
            {
                // Just take the first DDTParamAttribute
                return (DDTParamAttribute)paramAttributes[0];
            }
        }

        /// <summary>
        /// Add actions present in a Action Collection
        /// </summary>
        /// <param name="actionCollection">DDTActionCollection class</param>
        public void AddActionCollection(Type actionCollectionType)
        {
            if (!actionCollectionType.IsSubclassOf(
                    typeof(DDTActionCollection)))
            {
                return;
            }

            // Get the List of Actions from the actionCollectionClass
            Type[] actions = actionCollectionType.GetNestedTypes();
            
            // Get the DDTAction classes in the action collection
            foreach (Type action in actions)
            {
                // Skip types which do not look like DDTEnvironmentAction 
                if (!action.IsClass ||
                    !action.IsSubclassOf(typeof(DDTEnvironmentAction)))
                {
                    continue;
                }

                // See if there is a DDTActionAttribute
                Object[] attributes =
                 action.GetCustomAttributes(typeof(DDTActionAttribute), true);

                if ((attributes == null) || (attributes.Length == 0))
                {
                    continue;
                }

                // Just use the first DDTActionAttribute
                DDTActionAttribute actionAttribute =
                        (DDTActionAttribute)attributes[0];

                if (actionAttribute.Name == String.Empty)
                {
                    actionAttribute.Name = action.Name;
                }

                DDTActionInfo actionInfo = new DDTActionInfo();
                actionInfo.ActionType = action;
                actionInfo.ActionParameters =
                    new Dictionary<string, FieldInfo>();

                // Get the Action Parameter fields
                FieldInfo[] fieldInfos = action.GetFields(
                        System.Reflection.BindingFlags.Instance |
                        System.Reflection.BindingFlags.NonPublic |
                        System.Reflection.BindingFlags.Public);

                foreach (FieldInfo field in fieldInfos)
                {                    
                    DDTParamAttribute paramAttribute =
                        getParamAttribute(field);
                    
                    if (paramAttribute == null)
                    {
                        continue;
                    }

                    if (paramAttribute.Name == String.Empty)
                    {
                        paramAttribute.Name = field.Name;
                    }

                    paramAttribute.Name = paramAttribute.Name.ToLower();

                    // Check for the type of special parameters 'params'
                    if (paramAttribute.Name == "params")
                    {
                        if (field.FieldType != typeof(DDTParamList))
                        {
                            throw new Exception(
                                "Special parameter 'params' must be of type "+ 
                                "'DDTParamList' but is of type '" + 
                                field.FieldType.Name + "'");
                        }

                        if (paramAttribute.ImpliedSource != String.Empty)
                        {
                            throw new Exception(
                                "Special parameter 'params' cannot have " +
                                "an ImpliedSource but is specified as '" + 
                                paramAttribute.ImpliedSource + "'");
                        }
                    }

                    actionInfo.ActionParameters[paramAttribute.Name] 
                        = field;
                }

                // Create an association between the action name and the
                // action class type

                // Change qualifiedActionName when namespaces are needed
                String qualifiedActionName = actionAttribute.Name;
                qualifiedActionName = qualifiedActionName.ToLower();

                // Load the action in the current Env
                if (Actions.ContainsKey(qualifiedActionName))
                {
                    throw new DDTException("Duplicate Action : " +
                                           actionAttribute.Name);
                }
                
                Actions[qualifiedActionName.ToLower()] = actionInfo;
            }
        }

        // Check whether an assembly from a given path is already loaded
        private bool isAssemblyLoaded(String path)
        {
            FileInfo fileInfo = new FileInfo(path);

            lock (this.LoadedAssemblyPaths)
            {
                foreach (String loadedPath in LoadedAssemblyPaths)
                {
                    if (loadedPath.ToLower() == fileInfo.FullName.ToLower())
                    {
                        return true;
                    }
                }
            }
            
            return false;
        }

        /// <summary>
        /// Load actions from an assembly
        /// </summary>
        public void LoadActionsFromAssembly(String path)
        {
            // Don't load actions from assemblies that are already loaded
            if (isAssemblyLoaded(path))
            {
                return;
            }

            Assembly assembly = Assembly.LoadFrom(path);
            
            if (assembly != null)
            {
                Type[] types = assembly.GetTypes();
                
                foreach (Type t in types)
                {
                    if (t.IsSubclassOf(typeof(DDTActionCollection)))
                    {
                        this.AddActionCollection(t);
                    }
                }

                lock (this.LoadedAssemblyPaths)
                {
                    this.LoadedAssemblyPaths.Add(assembly.Location);
                }
            }
        }        

        /// <summary>
        /// Load actions from multiple assemblies
        /// </summary>        
        public void LoadActionsFromAssemblies(String[] paths)
        {
            foreach (String path in paths)
            {
                LoadActionsFromAssembly(path);
            }        
        }

        /// <summary>
        /// Print out the information of Actions currently loaded
        /// </summary>
        public void _DumpActions()
        {
            foreach (String name in Actions.Keys)
            {
                DDTActionInfo actionInfo = Actions[name];

                Console.WriteLine("Action  " + name);
                Console.WriteLine("{");

                foreach (String parameter in 
                         actionInfo.ActionParameters.Keys)
                {
                    FieldInfo field = actionInfo.ActionParameters[parameter];

                    Console.WriteLine("     " + field.FieldType 
                                      + " " + parameter + "; ");
                    
                }
                Console.WriteLine("}\n");
            }
        }

        // Assigns the value from source or it's member to 
        // a field in an object
        private void assignObjectOrMemberValue(Object target, 
                                               String fieldName,
                                               FieldInfo fieldInfo, 
                                               String sourceName,
                                               Object source)
        {                
            if ((source == null) && (fieldInfo.FieldType.IsValueType))
            {
                throw new DDTException(
                    "Cannot set value type parameter '" + fieldName +
                    "' to null");
            }

            try
            {
                fieldInfo.SetValue(target, source);
            }
            catch (Exception)
            {
                // Find field or property with name matching the
                // parameter
                bool memberFound = false;
                String memberName = String.Empty;
                Object memberVal = null;
                
                memberFound = 
                    DDTHelper.GetFieldOrPropertyValue(source,
                                                      fieldName,
                                                      false,
                                                      out memberName,
                                                      out memberVal);

                if (memberFound)
                {
                    try
                    {
                        fieldInfo.SetValue(target, 
                                           memberVal);
                    }
                    catch
                    {
                        throw new DDTException(
                            "Could not set Parameter '" +
                            fieldName + 
                            "' from '" + sourceName + 
                            "' or it's member '" +
                            memberName + "'");
                    }                       
                }
                else 
                {
                    throw new DDTException(
                        "Could not set Parameter '" +
                        fieldName + 
                        "' from '" + sourceName +
                        "' or any of it's members");
                }
            }
        }


        // Get the parameter whose positon is specified in DDTParam
        // attribute as the given position value
        private FieldInfo getParameterByPosition(DDTActionInfo actionInfo,
                                                 int pos,
                                                 out String paramName)
        {
            FieldInfo fieldInfo = null;
            paramName = String.Empty;

            foreach (String parameter in actionInfo.ActionParameters.Keys)
            {
                fieldInfo = actionInfo.ActionParameters[parameter];
                
                DDTParamAttribute paramAttribute =
                    getParamAttribute(fieldInfo);

                if (paramAttribute.Position == pos)
                {
                    paramName = parameter;
                    return fieldInfo;
                }
            }

            return null;
        }

        // Set a positional parameter
        private void setParameterAtPosition(DDTActionInfo actionInfo,
                                            DDTEnvironmentAction action,
                                            int pos,
                                            Object valueObject,
                                            Hashtable seenParameters)
        {
            // Find the parameter corresponding to the
            // position
            String parameter;
            FieldInfo fieldInfo = 
                getParameterByPosition(actionInfo, 
                                       pos,
                                       out parameter);
            
            if (fieldInfo != null)
            {
                if (seenParameters.ContainsKey(parameter))
                {
                    throw new DDTException
                        ("Parameter at positon '"+ pos + 
                         "' is already set in attributes");
                }
                
                // Set the parameter value
                assignObjectOrMemberValue(action, 
                                          parameter,
                                          fieldInfo, 
                                          "Position " + pos,
                                          valueObject);

                seenParameters[parameter] = 1;
            }
            else
            {
                // No positional parameter found
                // Stuff it in variable parameter list
                if (!actionInfo.ActionParameters.ContainsKey(
                        "params"))
                {
                    throw new DDTException(
                        "Unexpected parameter at position : " + 
                        pos);
                }
                
                // Assign the parameter in params
                FieldInfo paramListField = 
                    actionInfo.ActionParameters["params"];
                
                DDTParamList paramList = (DDTParamList)
                    paramListField.GetValue(action);
                
                // Create a new one if the default one is null
                if (paramList == null)
                {
                    paramList = new DDTParamList();
                    paramListField.SetValue(action, paramList);
                }                                
                
                // Set the parameter name to a special variable parameter name
                paramList["$PositionalParameter" + pos]
                    = valueObject;
                
                seenParameters["params"] = 1;
            }            
        }


        // Process the parameters and values in the XML and assign it to the 
        // action parameters
        private Object processParametersContinuation(Object state)
        {
            DDTExecuteActionContext context = (DDTExecuteActionContext)state;
            
            if (!context.ProcessingParameters)
            {
                // Maintain a list of parameters that have been seen
                // in the XML
                context.SeenParameters = new Hashtable();
                
                // Store the seen parameters as part of action, so that
                // the action Invoke can check whether a parameter has been set
                context.Action._SeenParameters = context.SeenParameters;

                // Go through the action attributes and set the action
                // parameters
                foreach (XmlAttribute attribute in context.XmlNode.Attributes)
                {
                    // Get the parameter
                    String parameter = attribute.Name.ToLower();
                    String value = attribute.Value;

                    // Check for duplicate parameters
                    if (context.SeenParameters.ContainsKey(parameter))
                    {
                        throw new 
                            DDTException("Duplicate parameter '" +
                                         parameter + "'");
                    }
                    
                    // Indicate to store the output value to a variable
                    if (parameter == "var")
                    {
                        value = value.Trim();
                        
                        bool isReserved;
                        if (!DDTHelper.IsValidVariableName(value, 
                                                           out isReserved))
                        {
                            if (isReserved)
                            {
                                throw new DDTException(
                                    "'" + value + "' is a reserved word " + 
                                    "and connot be used as a variable name");
                            }
                            else
                            {
                                throw new DDTException(
                                    "Invalid variable name : '" + value + "'");
                            }
                        }
                        
                        context.OutputVariableName = value;
                        context.SeenParameters[parameter] = 1;
                        continue;
                    }

                    // Parameter cannot be called params, which is reserved
                    // for variable parameter list
                    if (parameter == "params")
                    {
                        throw new DDTException(
                            "Parameters 'params' may not be set directly");
                    }
                    
                    if (!context.ActionInfo.ActionParameters.
                        ContainsKey(parameter))
                    {
                        // Preserve case for variable parameters
                        parameter = attribute.Name;
                        
                        // Check whether there is the special parameter
                        // 'params' which is a catch all for all unknown
                        // parameters
                        if (!context.ActionInfo.ActionParameters.
                            ContainsKey("params"))
                        {
                            throw new DDTException("Parameter '" + parameter +
                                                   "' not recognized");
                        }

                        // Assign the parameter in params
                        FieldInfo paramListField = 
                            context.ActionInfo.ActionParameters["params"];
                        
                        DDTParamList paramList = (DDTParamList)
                            paramListField.GetValue(context.Action);
                        
                        // Create a new one if the default one is null
                        if (paramList == null)
                        {
                            paramList = new DDTParamList();
                            paramListField.SetValue(context.Action, paramList);
                        }
                        
                        if (paramList.Contains(parameter))
                        {
                            throw new DDTException(
                                "Duplicate Parameter '" + parameter + "'");
                        }

                        // Get the value specified in the value string
                        paramList[parameter] = 
                            DDTHelper.EvalExpression(this, value);
                    
                        context.SeenParameters["params"] = 1;
                    }        
                    else
                    {
                        // Get the parameter type info to convert the
                        // value string to that type
                        FieldInfo fieldInfo = 
                            context.ActionInfo.ActionParameters[parameter];
                        
                        Object valueObject = null;
                    
                        // Get the value specified in the value string
                        valueObject = 
                            DDTHelper.EvalExpression(this, value);
                    
                    
                        if (valueObject != null)
                        {
                            // Convert the value to the target type
                            Object coercedValue = 
                                DDTHelper.CoerceType(valueObject,
                                                     fieldInfo.FieldType);
                            
                            if (coercedValue != null)
                            {
                                valueObject = coercedValue; 
                            }
                        }

                        // Set the parameter value
                        assignObjectOrMemberValue(context.Action, 
                                                  parameter,
                                                  fieldInfo, 
                                                  value,
                                                  valueObject);
                        
                        // And remember as seen
                        context.SeenParameters[parameter] = 1;
                    }
                }
            }

            // Process positional parameters which are specified as child
            // nodes to the current node. This will be skipped for
            // DDTXmlAction and DDTXmlMacro which do their own
            // processing of the child nodes
            if (context.ProcessChildNodes)
            {
                Object valueObject = null;

                // Set the current parameter when the continuaton was called
                if (context.ProcessingParameters)
                {
                    valueObject = DDTContinuation.EndContinuation();
                    
                    setParameterAtPosition(
                        context.ActionInfo,
                        context.Action,
                        context.ParameterPosition,
                        valueObject,
                        context.SeenParameters);
                    
                    context.ParameterPosition++;

                    if (context.ProcessingTextNodeParameter)
                    {
                        context.ParameterTextNodeIndex++;
                    }
                    else
                    {
                        context.ChildNodeIndex++;
                    }
                }


                // Set processing flag to true so that we directly
                // come here if we are called back in a continuation
                context.ProcessingParameters = true;    

                DDTContinuationContext continuation =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(
                            this.processParametersContinuation),
                        context);
                
                // The guard takes care of popping the continuation
                // context when we are done with the context block
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(continuation))
                {                        

                    for (int i = context.ChildNodeIndex;
                         i < context.XmlNode.ChildNodes.Count;
                         i++)
                    {                    
                        XmlNode childNode = 
                            (XmlNode)context.XmlNode.ChildNodes[i];
                        
                        if (childNode.Name.ToLower() == "#comment")
                        {
                            context.ChildNodeIndex++;
                            
                            // Don't increment ParameterPosition
                            
                            continue;
                        }
                        
                        if (childNode.Name.ToLower() == "#text")
                        {
                            context.ProcessingTextNodeParameter = true;

                            // Split the nodes into separate text nodes 
                            // as needed
                            ArrayList textNodes = 
                                DDTHelper.SplitTextNode(childNode);
                            
                            // Execute the text nodes and assign
                            // their value to the parameters
                            for (int j = context.ParameterTextNodeIndex;
                                 j < textNodes.Count;
                                 j++)
                            {
                                XmlNode textNode = (XmlNode)textNodes[j];
                                
                                // Evaluate the text node
                                valueObject = this.ExecuteAction(textNode);
                                
                                setParameterAtPosition(
                                    context.ActionInfo,
                                    context.Action,
                                    context.ParameterPosition,
                                    valueObject,
                                    context.SeenParameters);
                                
                                context.ParameterPosition++;
                                context.ParameterTextNodeIndex++;
                            }

                            context.ProcessingTextNodeParameter = false; 
                            context.ParameterTextNodeIndex = 0;
                        }
                        else
                        {
                            // It's an action. Execute it
                            valueObject = this.ExecuteAction(childNode);
                            
                            setParameterAtPosition(
                                context.ActionInfo,
                                context.Action,
                                context.ParameterPosition,
                                valueObject,
                                context.SeenParameters);
                            
                            context.ParameterPosition++;
                        }
                        
                        context.ChildNodeIndex++;
                    } // for
                } // using
            } // if (context.ProcessChildNodes)
            

            // Set the implied value(if any) for all parameters
            // that haven't been explicitly set
            foreach (String parameter in 
                     context.ActionInfo.ActionParameters.Keys)
            {
                // Skip parameter which have explivity been set
                if (context.SeenParameters.ContainsKey(parameter))
                {
                    continue;
                }
                    
                // Get the implied value source if any
                FieldInfo fieldInfo =
                    context.ActionInfo.ActionParameters[parameter];
                
                DDTParamAttribute paramAttribute =
                    getParamAttribute(fieldInfo);
                
                paramAttribute.ImpliedSource = 
                    paramAttribute.ImpliedSource.ToLower();
                
                if (paramAttribute.ImpliedSource == String.Empty)
                {
                    // No ImpliedSource
                    continue;
                }

                String varName = "$" + paramAttribute.ImpliedSource;
                
                // See if an action has been executed which
                // has produced the implied value
                DDTEnvironment e = this.GetVarEnv(varName);
                if (e == null)
                {
                    // Could not find action output variable
                    continue;
                }

                // Assign the implied value or it's matching member value 
                // to the parameter
                assignObjectOrMemberValue(context.Action, 
                                          parameter,
                                          fieldInfo, 
                                          ("ImpliedSource '" + 
                                           paramAttribute.ImpliedSource + 
                                           "'"),
                                          e.Variables[varName]);

                // Now the parameter has gotten a value assigned
                context.SeenParameters[parameter] = 1;
            }
            

            // Check whether all required parameters have been set
            foreach (String parameter in 
                     context.ActionInfo.ActionParameters.Keys)
            {
                // Get the implied value source if any
                FieldInfo fieldInfo =
                    context.ActionInfo.ActionParameters[parameter];
                
                DDTParamAttribute paramAttribute =
                    getParamAttribute(fieldInfo);
                
                if (paramAttribute.Required)
                {
                    if (!context.SeenParameters.ContainsKey(parameter))
                    {
                        if (paramAttribute.ImpliedSource == String.Empty)
                        {
                            if (parameter != "params")
                            {
                                // We are missing some regular parameter
                                throw new
                                    DDTException("Required parameter '" +
                                                 parameter + "' is not set");
                            }
                            else
                            {
                                // We are missing the variable parameters
                               throw new DDTException(
                                   "Missing variable parameter list");
                            }
                        }
                        else
                        {
                            throw new
                                DDTException(
                                    "ImpliedSource '" + 
                                    paramAttribute.ImpliedSource + "'" +
                                    " for parameter '" + parameter + "'" +
                                    " has not yet been executed and parameter"+
                                    " not set explicitly");
                        }
                    }
                }              
            }

            return context.OutputVariableName;
        }

        // Get the text representation of top level XML node
        private String getXmlNodeText(XmlNode node)
        {
            String text;

            if (node.NodeType != XmlNodeType.Element)
            {
                text = node.OuterXml;
            }
            else
            {
                text = "<" + node.Name;
                foreach (XmlAttribute attrib in node.Attributes)
                {
                    text += " " + attrib.Name + "=\"" + attrib.Value + "\"";
                }

                if (node.Attributes.Count > 0)
                {
                    text += " ";
                }

                if (node.ChildNodes.Count > 0)
                {
                    text += ">";
                }
                else
                {
                    text += "/>";
                }
            }
            
            return text;
        }
        

        /// <summary>
        /// Execute an action from the actioncollection given the 
        /// Action invocation XML
        /// </summary>
        /// <param name="ActionXml">Action XML</param>
        /// <returns> The output of the action executed </returns>
        public Object ExecuteAction(string actionXml)
        {
            XmlDocument xmlDoc = new DDTXmlDocument();
            xmlDoc.LoadXml(actionXml);
            
            return ExecuteAction(xmlDoc.FirstChild);
        }

        public Object ExecuteAction(XmlNode xmlNode)
        {
            BackTraceContext context = new BackTraceContext();
            context.XmlNode = xmlNode;
            
            return ExecuteActionWithBackTraceContinuation(context);
        }

        // Context for calling ExecuteAtion with Back trace across 
        // continuations
        protected class BackTraceContext
        {
            public XmlNode XmlNode = null;            
            public bool InContinuation = false;
        }
        
        private Object ExecuteActionWithBackTraceContinuation(Object state)
        {            
            BackTraceContext context = (BackTraceContext)state;            

            try
            {
                if (context.InContinuation)
                {
                    // Just get the current continuation result
                    // This might hrow an exception if an exception
                    // is being propagated
                    return DDTContinuation.EndContinuation();
                }
                else
                {
                    context.InContinuation = true;
                    
                    DDTContinuationContext continuation =
                        DDTContinuation.PushContinuation(
                            new DDTContinuationCallback(
                                this.ExecuteActionWithBackTraceContinuation),
                            context);
                    
                    using (DDTContinuationContextGuard guard = 
                           new DDTContinuationContextGuard(continuation))
                    {
                        return executeActionInner(context.XmlNode);
                    }
                } 
            }
            catch (Exception e)
            {
                if (context.XmlNode is IXmlLineInfo)
                {
                    // Augmet the stack trace with line info of the
                    // XML node currently being executed
                    IXmlLineInfo lineInfo = (IXmlLineInfo)context.XmlNode;
                    String stackTrace = e.StackTrace;
                       
                    String newStackTrace = String.Empty;
                    
                    // Only display if there is line and file information
                    if ((lineInfo.LineNumber != 0) && 
                        (context.XmlNode.OwnerDocument.BaseURI 
                         != String.Empty))
                    {
                        if (stackTrace != String.Empty)
                        {
                            newStackTrace += "\n";
                        }
                        
                        newStackTrace += "   at " + 
                            getXmlNodeText(context.XmlNode);
                        newStackTrace += " in " + 
                            context.XmlNode.OwnerDocument.BaseURI +
                            " :line " + lineInfo.LineNumber;
                    }

                    // Don't mask DDTContinuationException and DDTException 
                    // since they have special meaning to the framework
                    if (e is DDTContinuationException)
                    {
                        DDTContinuationException cont = 
                            (DDTContinuationException)e;

                        if (cont.LastEnv != this)
                        {
                            stackTrace += newStackTrace;
                        }

                        throw new DDTContinuationException(e.Message,
                                                           stackTrace,
                                                           this,
                                                           e.InnerException);
                    }
                    else if (e is DDTException)
                    {
                        DDTException ddt = (DDTException)e;

                        if (ddt.LastEnv != this)
                        {
                            stackTrace += newStackTrace;
                        }

                        throw new DDTException(e.Message,
                                               stackTrace,
                                               this,
                                               e.InnerException);
                    }
                    else 
                    {
                        if (e is DDTExtendedException)
                        {
                            // See if the current environment is already in the
                            // back trace. If so, don't augment the stack trace
                            DDTExtendedException ext = 
                                (DDTExtendedException)e;

                            if (ext.LastEnv != this)
                            {
                                stackTrace += newStackTrace;
                            }
                        }
                        else
                        {
                            stackTrace += newStackTrace;
                        }
                        
                        // Throw a DDTExtendedException with the augmented
                        // stack trace
                        throw new DDTExtendedException(e,
                                                       stackTrace,
                                                       this);
                    }
                }
                
                throw e;
            }
        }
        
        // executeAction can take place across continuations
        private Object executeActionContinuation(Object state)
        {
            Object output = DDTContinuation.EndContinuation();
            DDTExecuteActionContext context = (DDTExecuteActionContext)state;
            
            XmlNode xmlNode = context.XmlNode;
            String actionNodeName = xmlNode.Name.ToLower();
            
            while (context.State != ExecuteActionState.Completed)
            {
                switch (context.State)
                {
                    case ExecuteActionState.Initial:
                    {
                        if ((xmlNode.NodeType != XmlNodeType.Comment) &&
                            (xmlNode.NodeType != XmlNodeType.Text) &&
                            (xmlNode.NodeType != XmlNodeType.Element))
                        {
                            throw new DDTException("Unexpected XML node : " +
                                                   xmlNode.OuterXml + "in '" +
                                                   xmlNode.OwnerDocument.
                                                   BaseURI + "'");
                        }

                        // XML Comments - Do nothing
                        if (actionNodeName == "#comment")
                        {
                            return null;
                        }
                        
                        // If it's a text evaluate and return the value
                        if (actionNodeName == "#text")
                        {
                            // Evaluate each line of the text node separately
                            
                            // Split/Jointext nodes as needed
                            context.TextNodes = 
                                DDTHelper.SplitTextNode(xmlNode);

                            context.State = ExecuteActionState.EvalTextNode;
                        }
                        else
                        {
                            context.State = 
                                ExecuteActionState.ProcessParameters;
                        }

                        break;
                    }

                    case ExecuteActionState.EvalTextNode:
                    {                                                    
                        // Save the continuation context
                        DDTContinuationContext continuation =
                            DDTContinuation.PushContinuation(
                                new DDTContinuationCallback(
                                    this.executeActionContinuation),
                                context);
                        
                        // The guard takes care of popping the continuation
                        // context when we are done with the context block
                        using (DDTContinuationContextGuard guard = 
                               new DDTContinuationContextGuard(continuation))
                        {                        
                            // Evaluate the text nodes in the continuation
                            // context
                            while (context.TextNodeIndex < 
                                   context.TextNodes.Count)
                            {
                                XmlNode textNode = (XmlNode)
                                    context.TextNodes[context.TextNodeIndex++];
                            
                                output = 
                                    DDTHelper.EvalExpression(
                                        this,
                                        textNode.Value.Trim());
                            }
                        }
                        
                        context.State = ExecuteActionState.Completed;
                        break;
                    }

                    case ExecuteActionState.ProcessParameters:
                    {
                        // On continuation we will go to the next state
                        context.State = ExecuteActionState.InvokeAction;

                        // actionName might be different from 
                        // actionNodeName ifwe implement namespaces later
                        String actionName = actionNodeName;
                        
                        // Get the action info from the element name
                        // Walk the engine heirarchy and find the one with 
                        // the action defined
                        DDTEnvironment e = GetActionEnv(actionName);
                        if (e == null)
                        {
                            throw new DDTException("Action '" + 
                                                   xmlNode.Name +
                                                   "' not recognized");
                        }
                        
                        // Get the action info from the engine 
                        // where it was defined
                        context.ActionInfo = e.Actions[actionName];
                        
                        // Create an instance of the Action class
                        context.Action = (DDTEnvironmentAction)
                            Activator.CreateInstance(
                                context.ActionInfo.ActionType);
                        
                        context.OutputVariableName = String.Empty;
                        
                        // Do action type specific parameter processing
                        if (context.Action.GetType().IsSubclassOf(
                                typeof(DDTXmlMacro)))
                        {
                            // XML Macro. Pass the entire XML node 
                            // to the macro action
                            DDTXmlMacro xmlMacro = (DDTXmlMacro)context.Action;
                            xmlMacro.MacroNode = xmlNode;
                        }
                        else if (context.Action.GetType().IsSubclassOf(
                                     typeof(DDTXmlAction)))
                        {
                            // Process the parameter attributes in the node 
                            // Don't process the child nodes
                            context.ProcessChildNodes = false;
                            processParametersContinuation(context);
                            
                            // XML action. Pass the child nodes to the action
                            // skipping the comment nodes and splitting
                            // the text nodes to separate lines
                            DDTXmlAction xmlAction = 
                                (DDTXmlAction)context.Action;
                            
                            xmlAction.SubActionNodes = new ArrayList();
                            
                            foreach (XmlNode child in xmlNode.ChildNodes)
                            {
                                if (child.Name.ToLower() == "#comment")
                                {
                                    continue;
                                }
                                
                                if (child.Name.ToLower() == "#text")
                                {
                                    // Create separate nodes for each line
                                    // of a text node
                                    ArrayList textNodes = 
                                        DDTHelper.SplitTextNode(child);
                                    xmlAction.SubActionNodes.AddRange(
                                        textNodes);
                                }
                                else
                                {
                                    xmlAction.SubActionNodes.Add(child);
                                }
                            }
                        }
                        else 
                        {                            
                            // Save the continuation context
                            DDTContinuationContext continuation =
                                DDTContinuation.PushContinuation(
                                    new DDTContinuationCallback(
                                        this.executeActionContinuation),
                                    context);
                            
                            // The guard takes care of popping the continuation
                            // context when we are done with the context block
                            using (DDTContinuationContextGuard guard = 
                                   new DDTContinuationContextGuard
                                   (continuation))
                            {
                                // DDTAction and DDTEnvironmentAction
                                // Process the parameter attributes in the 
                                // node. Also process the child nodes for 
                                // positional parameters
                                context.ProcessChildNodes = true;
                                processParametersContinuation(context);
                            }
                        }                        
                        
                        break;
                    }

                    case ExecuteActionState.InvokeAction:
                    {
                        // Change the state before invoking the action
                        // In case the action wants continuation we will
                        // continue from the next state
                        context.State = ExecuteActionState.AssignOutput;

                        // Save the continuation context
                        DDTContinuationContext continuation =
                            DDTContinuation.PushContinuation(
                                new DDTContinuationCallback(
                                    this.executeActionContinuation),
                                context);
                        
                        // The guard takes care of popping the continuation
                        // context when we are done with the context block
                        using (DDTContinuationContextGuard guard = 
                               new DDTContinuationContextGuard(continuation))
                        {
                            // Invoke the action                            
                            output = context.Action.Invoke(this);
                        }
                        
                        break;
                    }

                    case ExecuteActionState.AssignOutput:
                    {                        
                        // Store the action output in a special variable 
                        // for use in ImpliedSource
                        String specialVarName = "$" + actionNodeName;
                        this.DefineVariable(specialVarName, output);
                        
                        // Store the output in a variable if specified
                        // Output variables created
                        
                        // If variable is already defined we overwrite 
                        // the existing variable in the engine where it was 
                        // defined
                        // If not we define a new variable in the current 
                        // environment                        
                        if (context.OutputVariableName != String.Empty)
                        {            
                            DDTEnvironment varEnv = 
                                this.GetVarEnv(context.OutputVariableName);
                
                            if (varEnv != null)
                            {
                                varEnv.SetVariable(context.OutputVariableName, 
                                                   output);
                            }
                            else
                            {
                                this.DefineVariable(context.OutputVariableName,
                                                    output);
                            }
                        }                         
                        
                        context.State = ExecuteActionState.Completed;
                        break;
                    }
                } // switch
            } // while
            
            return output;
        }
        
        // Private method which does all the heavy lifting
        private Object executeActionInner(XmlNode xmlNode)
        {
            // Create the variable to maintain execution context
            // across continuations
            DDTExecuteActionContext context = new DDTExecuteActionContext();
            
            context.XmlNode = xmlNode;
            return executeActionContinuation(context);
        }        

        
        /// <summary>
        /// Execute actions from a XML file
        /// </summary>        
        public Object Source(String path)
        {
            XmlDocument xmlDoc = new DDTXmlDocument();
            xmlDoc.Load(path);
                
            // Skip comments
            XmlNode node = xmlDoc.FirstChild;
            while ((node != null) && (node.Name.ToLower() == "#comment"))
            {
                node = node.NextSibling;
            }
            
            if (node == null)
            {
                // No actions found in file
                return null;
            }
            
            // Execute the first action in the file
            // And only one top-level node can be there
            return ExecuteAction(node);
        }

        /// <summary>
        /// Lists the actions in an actions assembly without loading 
        /// the actions
        /// </summary>        
        public void ListActions(String path)
        {
            // TODO : Refactor with code in AdddActionCollection
            Assembly assembly = Assembly.LoadFrom(path);
            
            if (assembly == null)
            {
                return;
            } 

            Type[] types = assembly.GetTypes();
                
            foreach (Type t in types)
            {
                if (!t.IsSubclassOf(typeof(DDTActionCollection)))
                {
                    continue;
                }

                DDTGlobal.RO.Log(t.Name + " : ");
                
                /// Display the action collection documentation
                String doc = getDocAttributeString(t);
                DDTGlobal.RO.Log(doc);

                // Get the List of Actions
                Type[] actions = t.GetNestedTypes();
                
                // Get the DDTAction classes in the action collection
                foreach (Type action in actions)
                {
                    // Skip types which do not look like 
                    // DDTEnvironmentAction 
                    if (!action.IsClass ||
                        !action.IsSubclassOf(typeof(DDTEnvironmentAction)))
                    {
                        continue;
                    }
                    
                    // See if there is a DDTActionAttribute
                    Object[] attributes =
                        action.GetCustomAttributes(
                            typeof(DDTActionAttribute), 
                            true); 
                    
                    if ((attributes == null) || 
                        (attributes.Length == 0))
                    {
                        continue;
                    }
                    
                    // Just use the first DDTActionAttribute
                    DDTActionAttribute actionAttribute =
                        (DDTActionAttribute)attributes[0];
                    
                    String actionName = action.Name;
                    if (actionAttribute.Name != String.Empty)
                    {
                        actionName = actionAttribute.Name;
                    }

                    DDTGlobal.RO.Log("  " + actionName);
                }
                                    
                // End of the current action collection
                DDTGlobal.RO.Log("\n");
            }
        }


        /// <summary>
        /// Display the documentation for an action and it's parameters
        /// from the DDTDoc attribute
        /// </summary>        
        public void DisplayDoc(String actionName)
        {
            String normalizedName = actionName.ToLower();

            // Get the action info from the element name
            DDTEnvironment e = GetActionEnv(normalizedName);
            if (e == null)
            {
                throw new Exception("Action '" + actionName +
                                    "' not recognized");
            }

            DDTActionInfo actionInfo = e.Actions[normalizedName];
            
            // Display the help for the action
            String doc = getDocAttributeString(actionInfo.ActionType);
            
            // Replace { with {{ so that it doesn't interfere with formatting
            // of Logging
            doc = doc.Replace("{", "{{");
            doc = doc.Replace("}", "}}");

            DDTGlobal.RO.Log("\n" + actionName + " : ");
            DDTGlobal.RO.Log("  " + doc);

            // Create an instance of the Action class to get 
            // default values of parameters
            DDTEnvironmentAction action = (DDTEnvironmentAction)
                Activator.CreateInstance(actionInfo.ActionType);
            
            DDTGlobal.RO.Log("  Parameters : \n");

            if (actionInfo.ActionParameters.Keys.Count == 0)
            {
                DDTGlobal.RO.Log("    None.\n");
            }

            foreach (KeyValuePair<String, FieldInfo> kvp in 
                     actionInfo.ActionParameters)
            {
                FieldInfo fieldInfo = kvp.Value;
                String paramDoc = getDocAttributeString(fieldInfo);
                DDTParamAttribute paramAttribute = 
                    getParamAttribute(fieldInfo);

                String paramName = kvp.Key;
                String qualifiers = String.Empty;

                // Get the required, optional, implied source
                // and default values
                if (paramAttribute.Required)
                {
                    qualifiers += "Required";
                }
                else
                {
                    qualifiers += "Optional";                    
                }
                
                if (paramAttribute.ImpliedSource != String.Empty)
                {
                    qualifiers += ", Implied Source = " + 
                        paramAttribute.ImpliedSource;                        
                }

                DDTGlobal.RO.Log("    " + paramName + " : ");
                DDTGlobal.RO.Log("      Type          : " + 
                                 fieldInfo.FieldType.Name);
                DDTGlobal.RO.Log("      Properties    : " + 
                                 qualifiers);
                
                if (!paramAttribute.Required)
                {
                    // Print Default value if parameter is optional
                    DDTGlobal.RO.Log("      Default Value : " + 
                                     fieldInfo.GetValue(action));
                }

                if (paramAttribute.Position != -1)
                {
                    DDTGlobal.RO.Log("      Position      : " + 
                                     paramAttribute.Position);
                }

                DDTGlobal.RO.Log("      Description   : " + 
                                 paramDoc);
            }            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTParamList.cs ===
using System;
using System.Collections;

namespace DDT
{
    public class DDTParamList
    {
        private ArrayList parameters = new ArrayList();
        private ArrayList values = new ArrayList();

        public Object this[String parameter]
        {
            get
            {
                int index = parameters.IndexOf(parameter);

                if (index >= 0)
                {
                    return values[index];
                }
                else
                {
                    throw new Exception("Unknown parameter '" + 
                                        parameter + "'");
                }
            }
            set
            {
                int index = parameters.IndexOf(parameter);

                if (index == -1)
                {
                    // New parameter. Add the parameter and value at the end
                    parameters.Add(parameter);
                    values.Add(value);
                }
                else
                {
                    // Parameter already present
                    values[index] = value;
                }
            }            
        }

        public bool Contains(String parameter)
        {
            return parameters.Contains(parameter);
        }

        public ArrayList Parameters
        {
            get
            {
                return parameters;
            }
        }

        public ArrayList Values
        {
            get
            {
                return values;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTModelActionCollection.cs ===
using System;
using System.Xml;
using System.Collections;


namespace DDT
{
    [DDTDoc("DDT Action Collection for Model based testing")]
    public class DDTModelActionCollection : DDTActionCollection
    {	
        //--------Actions to create Action and Model objects ----------
        [DDTAction]
        [DDTDoc("Define a model action")]
        public class Action : DDTXmlAction
        {
            [DDTParam(Required=true)]
            [DDTDoc("Name of the action")]
            public String Name = String.Empty;

            [DDTParam]
            [DDTDoc("Weight assigned to this model action")]
            public int Weight = 1;

            public override Object Invoke(DDTEnvironment e)
            {
                // Ignore 0 weight actions
                if (Weight < 1)
                {
                    return null;
                }
                else
                {
                    // See if there is a constraint specified for this action 
                    DDTConstraints constraints = null;

                    if ((this.SubActionNodes.Count > 0) &&
                        (((XmlNode)this.SubActionNodes[0]).Name.ToLower()
                         == "requires"))
                    {
                        constraints = 
                            (DDTConstraints)e.ExecuteAction(
                                (XmlNode)this.SubActionNodes[0]);
                        
                        // Unlink the 'Requires' action from the subactions
                        this.SubActionNodes = 
                            this.SubActionNodes.GetRange(
                                1,
                                this.SubActionNodes.Count - 1);
                    }
                    

                    return new DDTModelAction(e, 
                                              this.SubActionNodes, 
                                              Name,
                                              Weight,
                                              constraints);
                }
            }
        }

        [DDTAction]
        [DDTDoc("Action to describe a Model")]
        public class Model : DDTXmlAction
        {
            public override Object Invoke(DDTEnvironment e)
            {
                // Go through all the child actions
                // Model Actions are executed and the actions
                // are added with the given weight
                return new DDTModel(e, this.SubActionNodes);
            }
        }


        //----------------Actions that work on a Model object ----------------
        [DDTAction("Model-Step")]
        [DDTDoc("Execute a single step in the model execution")]
        public class Model_Step : DDTEnvironmentAction
        {
            [DDTParam(Required = true, ImpliedSource = "Model", Position = 0)]
            [DDTDoc("Model object")]
            public DDTModel Model = null;

            [DDTParam(ImpliedSource="Rand")]
            [DDTDoc("Random number generator")]
            public Random Rand = null;

            public override Object Invoke(DDTEnvironment e)
            {
                // If Rand is uninitialized, Initialize it now
                if (Rand == null)
                {
                    Rand = (Random)e.ExecuteAction("<Rand/>");
                }               

                return Model.ChooseAndExecute(Rand);
            }
        }

        [DDTAction("Model-Done")]
        [DDTDoc("Return whether model is in final state and no actions \n" + 
                "  are possible from this state")]
        public class Model_Done : DDTEnvironmentAction
        {
            [DDTParam(Required = true, ImpliedSource = "Model", Position = 0)]
            [DDTDoc("Model object")]
            public DDTModel Model = null;

            public override Object Invoke(DDTEnvironment e)
            {
                return Model.InFinalState();
            }
        }

        [DDTAction("Model-Run")]
        [DDTDoc("Run a model until a final state is reached or " +
                "  a certain number of actions have been executed")] 
        public class Model_Run : DDTEnvironmentAction
        {
            [DDTParam(Required = true, ImpliedSource = "Model", Position = 0)]
            [DDTDoc("Model object")]
            public DDTModel Model = null;
            
            [DDTParam(Required=true, Position = 1)]
            [DDTDoc("Maximum number of actions to execute")]
            public int MaxSteps = 0;

            [DDTParam(ImpliedSource="Rand")]
            [DDTDoc("Random number generator")]
            public Random Rand = null;

            public override Object Invoke(DDTEnvironment e)
            {
                // If Rand is uninitialized, Initialize it now
                if (Rand == null)
                {
                    Rand = (Random)e.ExecuteAction("<Rand/>");
                }               

                return Model.Run(MaxSteps, Rand);
            }
            
        }

        [DDTAction("Model-Reset")]
        [DDTDoc("Reset the Model to it's initial state")]
        public class Model_Reset : DDTEnvironmentAction
        {
            [DDTParam(Required = true, ImpliedSource = "Model", Position = 0)]
            [DDTDoc("Model object")]
            public DDTModel Model = null;
            
            public override Object Invoke(DDTEnvironment e)
            {
                Model.Reset();
                return Model;
            }            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTObjectMethod.cs ===
using System;
using System.Reflection;

namespace DDT
{
    /// <summary>
    /// Method, object pair. Sort of like the Function pointer/delegate
    /// </summary>    
    public class DDTObjectMethod
    {
        public Object Obj = null;
        public Type ObjType = null;
        public String MethodName = String.Empty;
        
        // For static and instance methods
        public DDTObjectMethod(Object o, String m)
        {
            this.Obj = o;
            this.ObjType = o.GetType();
            this.MethodName = m;
        }

        // Use for static methods
        public DDTObjectMethod(Type t,
                               String m)
        {
            this.ObjType = t;
            this.MethodName = m;
        }

        // Invoke a non-generic method
        public Object Invoke(Object[] parameters, Type[] signature)
        {
            // Find the method by parameter signature
            MethodInfo methodInfo = this.ObjType.GetMethod(this.MethodName, 
                                                           signature);

            if (methodInfo == null)
            {
                String paramTypes =  "(";
                
                for (int i = 0;i < signature.Length;i++)
                {
                    paramTypes += signature[i].Name;
                    
                    if (i < signature.Length - 1)
                    {
                        paramTypes += ", ";
                    }
                }
                paramTypes += ")";
                
                throw new DDTException(
                    "Cannot not find an overload for " + 
                    "method '" + this.MethodName + "' with signature : " +
                    paramTypes);
            }

            // Invoke the method with the parameters
            try
            {
                Object returnValue = methodInfo.Invoke(this.Obj, parameters);
                return returnValue;
            }
            catch (Exception e)
            {
                String msg = e.Message;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                }

                throw new DDTException(msg);
            }                
        }

        // Invoke a generic method
        public Object Invoke(Object[] parameters, 
                             Type[] signature, 
                             Type[] types)
        {
            // Find the method which matches the generic type list
            MethodInfo[] methods = this.ObjType.GetMethods();
            MethodInfo methodInfo = null;
            
            foreach (MethodInfo method in methods)
            {
                if (method.Name == this.MethodName)
                {
                    if (!method.IsGenericMethod)
                    {
                        continue;
                    }
                    
                    Type[] typeArguments = method.GetGenericArguments();
                    if (typeArguments.Length == types.Length)
                    {
                        try
                        {
                            methodInfo = method.MakeGenericMethod(types);
                        }
                        catch (Exception) 
                        {
                        }

                        break;
                    }
                }
            }

            if (methodInfo == null)
            {
                String paramTypes =  "{";
                
                for (int i = 0;i < types.Length;i++)
                {
                    paramTypes += types[i].Name;
                    
                    if (i < types.Length - 1)
                    {
                        paramTypes += ", ";
                    }
                }
                paramTypes += "}";
                
                throw new DDTException(
                    String.Format(
                        "Cannot apply generic types {0} to method '{1}'",
                        paramTypes,
                        this.MethodName));
            }

            // Invoke the method with the parameters
            Object returnValue = null;
            try
            {
                returnValue = methodInfo.Invoke(this.Obj, parameters);
            }
            catch (Exception)
            {
                String genericTypes =  "{";
                
                for (int i = 0;i < types.Length;i++)
                {
                    genericTypes += types[i].Name;
                    
                    if (i < types.Length - 1)
                    {
                        genericTypes += ", ";
                    }
                }
                genericTypes += "}";

                String paramTypes =  "(";
                
                for (int i = 0;i < signature.Length;i++)
                {
                    paramTypes += signature[i].Name;
                    
                    if (i < signature.Length - 1)
                    {
                        paramTypes += ", ";
                    }
                }
                paramTypes += ")";
                
                throw new DDTException(
                    "Cannot apply generic method '" + 
                    this.MethodName + genericTypes + 
                    "' on parameters with signature : " +
                    paramTypes);
            }

            return returnValue;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTPropertyReference.cs ===
using System;
using System.Reflection;

namespace DDT
{
    public class DDTPropertyReference : IDDTReference
    {
        protected PropertyInfo property;
        protected Object source;
        protected Object[] index;

        public DDTPropertyReference(PropertyInfo property, 
                                    Object source, 
                                    Object[] index)
        {
            this.property = property;
            this.source = source;
            this.index = index;
        }
        
        Object IDDTReference.GetValue()
        {
            try
            {
                return property.GetValue(this.source, this.index);
            }
            catch (Exception e)
            {
                String msg = e.Message;
                Exception inner = e;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                    inner = e.InnerException;
                }
                
                throw new DDTException(msg, inner);
            }
        }

        void IDDTReference.SetValue(Object val)
        {
            try
            {
                property.SetValue(this.source, val, this.index);
            }
            catch (Exception e)
            {
                String msg = e.Message;
                Exception inner = e;
                if (e.InnerException != null)
                {
                    msg = e.InnerException.Message;
                    inner = e.InnerException;
                }

                throw new DDTException(msg, inner);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTTestCaseInfo.cs ===
using System;
using System.Collections;
using System.Xml;

namespace DDT
{
    public class DDTTestCaseInfo
    {
        public String Name = String.Empty;
        public bool Ignore = false;

        public ArrayList TestActionNodes = new ArrayList();

        public void AddActionNode(XmlNode action)
        {
            TestActionNodes.Add(action);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTVariableReference.cs ===
using System;

namespace DDT
{
    public class DDTVariableReference : IDDTReference
    {
        protected DDTEnvironment env;
        protected String varName;

        public DDTVariableReference(DDTEnvironment env,
                                    String varName)
        {
            this.env = env;
            this.varName = varName;
        }
        
        Object IDDTReference.GetValue()
        {
            return this.env.GetVariable(this.varName);
        }

        void IDDTReference.SetValue(Object val)
        {
            env.SetVariable(this.varName, val);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTXmlAction.cs ===
using System;
using System.Collections;

namespace DDT
{
    /// <summary>
    /// Use DDTXmlAction to write complex actions that take other actions
    /// as sub actions
    //  The action can also change the execution environment 
    /// </summary>
    public abstract class DDTXmlAction : DDTEnvironmentAction
    {
        // Sub actions list
        public ArrayList SubActionNodes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTTestSuite.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace DDT
{
    public class DDTTestSuite
    {
        private DDTEnvironment env = null;
        public String Name = String.Empty;
        public ArrayList TestCases = new ArrayList();

        public int TestCasesCount
        {
            get {return TestCases.Count;}
        }

        public DDTTestSuite(DDTEnvironment e)
        {
            this.env = e;
        }

        /// <summary>
        /// Load a test suite from a XML file
        /// </summary>        
        public static DDTTestSuite GetTestSuite(String testCaseXml)
        {
            // Load the test suite from the test case XML file
            // using the DDTEnvironment - Wicked
            DDTEnvironment testSuiteEnv = new DDTEnvironment();

            Object o = 
                testSuiteEnv.ExecuteAction(
                    "<Source path=\"" + testCaseXml + "\"/>");

            if ((o == null) || (o.GetType() != typeof(DDTTestSuite)))
            {
                throw new  Exception(testCaseXml + " does not contain " +
                                    "TestSuite as the root node");
            }
            
            DDTTestSuite testSuite = (DDTTestSuite)o; 
            testSuite.env = testSuiteEnv;

            return testSuite;
        }
                                   
        /// <summary>
        /// Execute the given test case
        /// </summary>
        /// <param name="test">Test Case Info</param>
        public Object ExecuteTestCase(DDTTestCaseInfo test)
        {   
            if (test.Ignore)
            {
                DDTGlobal.RO.Warn("Skippping ignored test : " + test.Name);
                return null;
            }
            
            // Create a new Environment and run the test
            // case in it
            DDTEnvironment e = new DDTEnvironment(this.env);
            
            ExecuteTestCaseContext context = new ExecuteTestCaseContext();
            context.e = e;
            context.test = test;

            return ExecuteTestCaseContinuation(context);
        }

        public class ExecuteTestCaseContext
        {
            public DDTEnvironment e = null;
            public DDTTestCaseInfo test = null;
            public int index = 0;
            public bool inContinuation = false;
        }

        private Object ExecuteTestCaseContinuation(Object state)
        {
            ExecuteTestCaseContext context = (ExecuteTestCaseContext)state;
            bool inContinuation = context.inContinuation;

            Object lastValue = null;

            context.inContinuation = true;
            DDTContinuationContext continuation =
                DDTContinuation.PushContinuation(
                    new DDTContinuationCallback(ExecuteTestCaseContinuation),
                    context);
            
            using (DDTContinuationContextGuard guard = 
                   new DDTContinuationContextGuard(continuation))
            {   
                for (int i = context.index;
                     i < context.test.TestActionNodes.Count;
                     i++)
                {
                    XmlNode actionXmlNode = 
                        (XmlNode)context.test.TestActionNodes[i];

                    if (inContinuation)
                    {
                        // Complete the last action if we are in a 
                        // continuation
                        inContinuation = false;
                        lastValue = DDTContinuation.EndContinuation();
                    }
                    else
                    {
                        lastValue = context.e.ExecuteAction(actionXmlNode);
                    }

                    context.index++;
                }
            }

            // Return the last value seen
            return lastValue;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTHelper.cs ===
using System;
using System.Collections;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Xml;

using System.Reflection;

using Oopc.Generated;

namespace DDT
{
    public class DDTHelper
    {
        protected static String[] reservedNames =
        {
            "null",
            "true",
            "false",
            "new",
            "ref",
            "and",
            "or",
            "lt",
            "gt",
            "ll",
            "rr"                        
        };

        public static bool IsValidVariableName(String var, out bool isReserved)
        {
            bool result = false;
            isReserved = false;
                        
            Match m = 
                Regex.Match(var, 
                            @"^([a-zA-Z_][a-zA-Z_0-9]*)$");
            
            if (m.Success)
            {
                // Make sure it's not a reserved word
                if (Array.IndexOf(DDTHelper.reservedNames, var) != -1)
                {
                    result = false;
                    isReserved = true;
                }
                else
                {
                    result = true;
                }
            }

            return result;
        }

        // Return true if all paranthesis are matched
        // Doesn't check whether they are well-formed though
        private static bool hasLineEnded(String line, out bool inString)
        {
            // Track 3 types of paranheses
            int numParan = 0, numSquare = 0, numCurly = 0;
            
            // Track string beginning
            inString = false;

            // Check whether there is explicit extension
            if (line.TrimEnd().EndsWith("\\"))
            {
                return false;
            }

            foreach (char c in line)
            {
                if (inString)
                {
                    if (c == '\'')
                    {
                        inString = false;
                    }
                }
                else
                {
                    if (c == '\'')
                    {
                        inString = true;
                    }
                    else if (c == '(')
                    {
                        numParan++;
                    }
                    else if (c == ')')
                    {
                        numParan--;
                    }
                    else if (c == '[')
                    {
                        numSquare++;
                    }
                    else if (c == ']')
                    {
                        numSquare--;
                    }
                    else if (c == '{')
                    {
                        numCurly++;
                    }
                    else if (c == '}')
                    {
                        numCurly--;
                    }
                }
            }
            
            return ((!inString) && (numParan <= 0) && (numSquare <= 0) &&
                    (numCurly <= 0));
        }

        // Split a text element into separate XmlNode-s
        // Also join separate nodes if they are to be implicitly or
        // explicitly to be joined
        public static ArrayList SplitTextNode(XmlNode node)
        {
            // Create separate nodes for each line
            // of a text node
            XmlDocument ownerDoc = node.OwnerDocument;
            
            String[] subTexts = 
                node.Value.Split(new char[]{'\n'});
            
            // Join lines as one if needed            
            for (int i = 0;i < subTexts.Length;i++)
            {
                bool inString;
                if (!hasLineEnded(subTexts[i], out inString))
                {
                    if (inString)
                    {
                        throw new DDTException(
                            "Newline encountered in string constant");
                    }
                    
                    if (i < subTexts.Length - 1)
                    {
                        subTexts[i] = subTexts[i].TrimEnd();

                        if (subTexts[i].EndsWith("\\"))
                        {
                            // Remove the trailing \ before joining
                            subTexts[i] = 
                                subTexts[i].Substring(0,
                                                      subTexts[i].Length - 1);
                        }

                        // Join the current line with the next line
                        // so that the line number is that of the latter line
                        subTexts[i + 1] = subTexts[i] + subTexts[i + 1];
                        subTexts[i] = "";
                    }
                }
            }

            ArrayList nodes = new ArrayList();
            int subLineNumber = 0;
            foreach (String subText in subTexts)
            {
                if (subText.Trim() != String.Empty)
                {
                    XmlNode newNode = null;
                    
                    // Preserve line number info if present
                    if (node is IXmlLineInfo)
                    {
                        IXmlLineInfo lineInfo = 
                            (IXmlLineInfo)node;
                        
                        newNode = new DDTXmlText(
                            subText.Trim(),
                            ownerDoc,
                            lineInfo.LineNumber + subLineNumber,
                            0);
                    }
                    else
                    {
                        newNode = 
                            ownerDoc.CreateTextNode(subText);
                    }
                    
                    nodes.Add(newNode);
                }
                
                subLineNumber++;
            }

            return nodes;
        }


        // Hande String escape sequences
        public static String StringEscape(String str)
        {
            String newStr = String.Empty;
            for (int i = 0;i < str.Length;i++)
            {
                if (str[i] != '\\')
                {
                    newStr += str[i];
                }
                else
                {
                    if (i < str.Length - 1)
                    {
                        i++;
                        switch (str[i])
                        {
                        case '\\' : newStr += '\\'; break;
                        case '\'' : newStr += '\''; break;
                        case '0' : newStr += '\0'; break;
                        case 'a' : newStr += '\a'; break;
                        case 'b' : newStr += '\b'; break;
                        case 'f' : newStr += '\f'; break;
                        case 'n' : newStr += "\r\n"; break;
                        case 'r' : newStr += '\r'; break;
                        case 't' : newStr += '\t'; break;
                        case 'v' : newStr += '\v'; break;
                        default:                                 
                            throw new DDTException(
                                "Unknown escape sequence : '\\" +
                                str[i] + "'");
                        }                                
                    }
                }
            }                   
            
            return newStr;
        }

        // Gets the field or propety value by name
        // Returns true if fields is found, false otherwise
        public static bool GetFieldOrPropertyValue(Object source,
                                                   String fieldName,
                                                   bool caseSensitive,
                                                   out String memberName,
                                                   out Object memberVal)
        {
            memberName = String.Empty;
            memberVal = null;
            
            if (source == null)
            {
                return false;
            }

            Type t = source.GetType();
            
            // Find field or property with name matching the
            // parameter
            bool memberFound = false;
                            
            FieldInfo[] fields = 
                t.GetFields(
                    System.Reflection.BindingFlags.
                    Instance |
                    System.Reflection.BindingFlags.
                    Public);
            
            foreach (FieldInfo field in fields)
            {
                if ((field.Name == fieldName) ||
                    ((!caseSensitive) && 
                     (field.Name.ToLower() == fieldName.ToLower())))
                {
                    memberName = field.Name;
                    memberVal = field.GetValue(source);
                    
                    memberFound = true;
                    break;
                }
            }
            
            if (!memberFound)
            {
                // Search properties
                PropertyInfo[] properties = 
                    t.GetProperties(
                        System.Reflection.BindingFlags.
                        Instance |
                        System.Reflection.BindingFlags.
                        Public);
                
                foreach (PropertyInfo property in properties)
                {
                    if ((property.Name == fieldName) ||
                        ((!caseSensitive) && 
                         (property.Name.ToLower() == fieldName.ToLower())))
                    {
                        try
                        {
                            memberName = property.Name;
                            memberVal = property.GetValue(source, 
                                                          null);
                            
                            memberFound = true;
                            break;
                        }
                        catch (Exception )
                        {
                            // Property might be indexed
                            // In which case we just ignore it
                        }
                    }
                }
            }

            return memberFound;
        }               


        // Gets the field or property reference
        // Returns true if fields is found, false otherwise
        public static bool GetFieldOrPropertyReference(Object source,
                                                       String fieldName,
                                                       out Object reference)
        {
            reference = null;
            
            if (source == null)
            {
                return false;
            }

            Type t = source.GetType();
            
            // Find field or property with name matching the
            // parameter
            bool memberFound = false;
                            
            FieldInfo[] fields = 
                t.GetFields(
                    System.Reflection.BindingFlags.
                    Instance |
                    System.Reflection.BindingFlags.
                    Public);
            
            foreach (FieldInfo field in fields)
            {
                if (field.Name == fieldName)
                {
                    reference = 
                        new DDTFieldReference(field, source);
                    
                    memberFound = true;
                    break;
                }
            }
            
            if (!memberFound)
            {
                // Search properties
                PropertyInfo[] properties = 
                    t.GetProperties(
                        System.Reflection.BindingFlags.
                        Instance |
                        System.Reflection.BindingFlags.
                        Public);
                
                foreach (PropertyInfo property in properties)
                {
                    if (property.Name == fieldName)
                    {
                        try
                        {
                            reference = 
                                new DDTPropertyReference(property,
                                                         source, 
                                                         null);
                            
                            memberFound = true;
                            break;
                        }
                        catch (Exception )
                        {
                            // Property might be indexed
                            // In which case we just ignore it
                        }
                    }
                }
            }

            return memberFound;
        }               


        // Get the value of static field or property
        public static bool GetStaticFieldOrPropertyRef(Type t,
                                                       String fieldName,
                                                       out Object memberRef)
        {
            // Find static field or property with name matching the
            // parameter
            memberRef = null;
            bool memberFound = false;
                            
            FieldInfo[] fields = 
                t.GetFields(
                    System.Reflection.BindingFlags.
                    Static |                    
                    System.Reflection.BindingFlags.
                    Public);
            
            foreach (FieldInfo field in fields)
            {
                if (field.Name == fieldName)
                {
                    memberRef = new DDTFieldReference(field, null);
                    
                    memberFound = true;
                    break;
                }
            }
            
            if (!memberFound)
            {
                // Search properties
                PropertyInfo[] properties = 
                    t.GetProperties(
                        System.Reflection.BindingFlags.
                        Static |
                        System.Reflection.BindingFlags.
                        Public);
                
                foreach (PropertyInfo property in properties)
                {
                    if (property.Name == fieldName)
                    {
                        try
                        {
                            memberRef = new DDTPropertyReference(property,
                                                                 null,
                                                                 null);
                            memberFound = true;
                            break;
                        }
                        catch (Exception )
                        {
                            // Property might be indexed
                            // In which case we just ignore it
                        }
                    }
                }
            }

            return memberFound;
        }


        /// <summary>
        /// Whether the object has method with the given name. Case-sensitive
        /// </summary>        
        public static bool HasMethodByName(Object source,
                                           String name)
        {
            // Get all the methods in the object
            Type t = source.GetType();
            
            MethodInfo[] methods = t.GetMethods();
            foreach (MethodInfo method in methods)
            {
                if (method.Name == name)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Whether the type has static method with the given name
        /// Case-sensitive
        /// </summary>        
        public static bool HasStaticMethodByName(Type t,
                                                 String name)
        {
            MethodInfo[] methods = t.GetMethods(System.Reflection.BindingFlags.
                                                Static |
                                                System.Reflection.BindingFlags.
                                                Public);
            
            foreach (MethodInfo method in methods)
            {
                if (method.Name == name)
                {
                    return true;
                }
            }

            return false;
        }

        // Get an array list object from string of format [start..end]
        public static ArrayList GetRangeList(String expression,
                                             Symbol symbol,
                                             Object startVal, 
                                             Object endVal)
        {
            if (startVal.GetType() != endVal.GetType())
            {
                throw new DDTException(
                    String.Format("In Range List {0} : {1} and {2} " + 
                                  "are not of same type",
                                  DDTHelper.GetSymbolString(expression ,
                                                            symbol),
                                  startVal, endVal));
            }
            
            ArrayList valueList = new ArrayList();
            
            // Signed numbers
            if (startVal.GetType() == typeof(SByte))
            {
                for (SByte i = (SByte)startVal;i <= (SByte)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            else if (startVal.GetType() == typeof(Int16))
            {
                for (Int16 i = (Int16)startVal;i <= (Int16)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            else if (startVal.GetType() == typeof(Int32))
            {
                for (Int32 i = (Int32)startVal;i <= (Int32)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            else if (startVal.GetType() == typeof(Int64))
            {
                for (Int64 i = (Int64)startVal;i <= (Int64)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            // Unsigned numbers
            if (startVal.GetType() == typeof(Byte))
            {
                for (Byte i = (Byte)startVal;i <= (Byte)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            else if (startVal.GetType() == typeof(UInt16))
            {
                for (UInt16 i = (UInt16)startVal;i <= (UInt16)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            else if (startVal.GetType() == typeof(UInt32))
            {
                for (UInt32 i = (UInt32)startVal;i <= (UInt32)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            else if (startVal.GetType() == typeof(UInt64))
            {
                for (UInt64 i = (UInt64)startVal;i <= (UInt64)endVal;i++)
                {
                    valueList.Add(i);
                }
            }
            // Enum-s
            else if (startVal.GetType().IsEnum)
            {
                foreach (int i in Enum.GetValues(startVal.GetType()))
                {
                    if ((i >= (int)startVal) && (i <= (int)endVal))
                    {
                        valueList.Add(Enum.Parse(
                                          startVal.GetType(),
                                          i.ToString()));
                    }
                }
            }
            // Char-s
            else if (startVal.GetType() == typeof(Char))
            {
                for (Char c = (Char)startVal;c <= (Char)endVal; c++)
                {
                    valueList.Add(c);
                }
            }            
            
            return valueList;
        }               

        protected static Type[] NumericTypes 
        = new Type[]{typeof(byte),
                     typeof(sbyte),
                     typeof(ushort),
                     typeof(short),
                     typeof(uint),
                     typeof(int),
                     typeof(ulong),
                     typeof(long),
                     typeof(float),
                     typeof(double),
                     typeof(decimal)};

        public static bool CanAdd(Type t)
        {
            return ((t == typeof(string)) ||
                    (Array.IndexOf(NumericTypes, t) != -1));
        }

        public static bool IsNumber(Type t)
        {
            return  (Array.IndexOf(NumericTypes, t) != -1);
        }

        public static bool IsInteger(Type t)
        {
            int index = Array.IndexOf(NumericTypes, t);
            return ((index > 0) && (index < 8));
        }

        // Add two numbers or strings
        public static Object AddObjects(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.CanAdd(aType) || 
                !DDTHelper.CanAdd(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot add objects of type '{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if ((aType == typeof(string)) || 
                    (bType == typeof(string)))
                {
                    return (a.ToString() + b.ToString());
                }
                
                if (aType == typeof(decimal) || bType == typeof(decimal))
                {
                    return (decimal)Convert.ChangeType(a, typeof(decimal)) + 
                        (decimal)Convert.ChangeType(b, typeof(decimal));
                }
                
                if (aType == typeof(double) || bType == typeof(double))
                {
                    return (double)Convert.ChangeType(a, typeof(double)) + 
                        (double)Convert.ChangeType(b, typeof(double));
                }
                
                if (aType == typeof(float) || bType == typeof(float))
                {
                    return (float)Convert.ChangeType(a, typeof(float)) + 
                        (float)Convert.ChangeType(b, typeof(float));
                }
                
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) + 
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) + 
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) + 
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) + 
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) + 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) + 
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) + 
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) + 
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) + 
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot add objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // Increment a given numeric object while maintaining its type
        public static Object IncObject(Object a)
        {
            Type aType = a.GetType();

            if (!DDTHelper.IsNumber(aType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot increment object of type '{0}'",
                        aType.Name));
            }

            
            if (aType == typeof(decimal))
            {
                return (decimal)a + (decimal)1;
            }
            
            if (aType == typeof(double))
            {
                return (double)a + (double)1;
            }                
            
            if (aType == typeof(float))
            {
                return (float)a + (float)1;
            }                
            
            if (aType == typeof(ulong))
            {
                return (ulong)a + (ulong)1;
            }
                
            if (aType == typeof(long))
            {
                return (long)a + (long)1;
            }                
            
            if (aType == typeof(uint))
            {
                return (uint)a + (uint)1;
            }
            
            if (aType == typeof(int))
            {
                return (int)a + (int)1;
            }
            
            if (aType == typeof(ushort))
            {
                return (ushort)a + (ushort)1;
            }
            
            if (aType == typeof(short))
            {
                return (short)a + (short)1;
            }
            
            if (aType == typeof(byte))
            {
                return (byte)a + (byte)1;
            }
            
            if (aType == typeof(sbyte))
            {
                return (sbyte)a + (sbyte)1;
            }
            
            throw new DDTException(
                String.Format(
                    "Cannot increment object of type '{0}'", aType.Name));
        }

        // Subtract two numbers
        public static Object SubtractNumbers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsNumber(aType) || 
                !DDTHelper.IsNumber(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot subtract objects of type '{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(decimal) || bType == typeof(decimal))
                {
                    return (decimal)Convert.ChangeType(a, typeof(decimal)) - 
                        (decimal)Convert.ChangeType(b, typeof(decimal));
                }
                
                if (aType == typeof(double) || bType == typeof(double))
                {
                    return (double)Convert.ChangeType(a, typeof(double)) -
                        (double)Convert.ChangeType(b, typeof(double));
                }
                
                if (aType == typeof(float) || bType == typeof(float))
                {
                    return (float)Convert.ChangeType(a, typeof(float)) -
                        (float)Convert.ChangeType(b, typeof(float));
                }
                
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) - 
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) -
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) -
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) - 
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) -
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) - 
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) -
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) -
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) - 
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot subtract objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // Negate numbers
        public static Object NegateNumber(Object a)
        {
            Type aType = a.GetType();

            if (!DDTHelper.IsNumber(aType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot negate object of type '{0}'",
                        aType.Name));
            }

            
            if (aType == typeof(decimal))
            {
                return -(decimal)a;
            }
            
            if (aType == typeof(double))
            {
                return -(double)a;
            }                
            
            if (aType == typeof(float))
            {
                return -(float)a;
            }                
            
            if (aType == typeof(ulong))
            {
                throw new DDTException(
                    "Operator '-' cannot be applied to operand of type '" +
                    aType.Name + "'");
            }
                
            if (aType == typeof(long))
            {
                return -(long)a;
            }                
            
            if (aType == typeof(uint))
            {
                return -(uint)a;
            }
            
            if (aType == typeof(int))
            {
                return -(int)a;
            }
            
            if (aType == typeof(ushort))
            {
                return -(ushort)a;
            }
            
            if (aType == typeof(short))
            {
                return -(short)a;
            }
            
            if (aType == typeof(byte))
            {
                return -(byte)a;
            }
            
            if (aType == typeof(sbyte))
            {
                return -(sbyte)a;
            }
            
            throw new DDTException(
                String.Format(
                    "Cannot negate object of type '{0}'", aType.Name));
        }

        // Decrement a given numeric object while maintaining it's type
        public static Object DecObject(Object a)
        {
            Type aType = a.GetType();

            if (!DDTHelper.IsNumber(aType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot decrement object of type '{0}'",
                        aType.Name));
            }

            
            if (aType == typeof(decimal))
            {
                return (decimal)a - (decimal)1;
            }
            
            if (aType == typeof(double))
            {
                return (double)a - (double)1;
            }                
            
            if (aType == typeof(float))
            {
                return (float)a - (float)1;
            }                
            
            if (aType == typeof(ulong))
            {
                return (ulong)a - (ulong)1;
            }
                
            if (aType == typeof(long))
            {
                return (long)a - (long)1;
            }                
            
            if (aType == typeof(uint))
            {
                return (uint)a - (uint)1;
            }
            
            if (aType == typeof(int))
            {
                return (int)a - (int)1;
            }
            
            if (aType == typeof(ushort))
            {
                return (ushort)a - (ushort)1;
            }
            
            if (aType == typeof(short))
            {
                return (short)a - (short)1;
            }
            
            if (aType == typeof(byte))
            {
                return (byte)a - (byte)1;
            }
            
            if (aType == typeof(sbyte))
            {
                return (sbyte)a - (sbyte)1;
            }
            
            throw new DDTException(
                String.Format(
                    "Cannot decrement object of type '{0}'", aType.Name));
        }


        // Multiply two numbers
        public static Object MultiplyNumbers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsNumber(aType) || 
                !DDTHelper.IsNumber(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot multiply objects of type '{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(decimal) || bType == typeof(decimal))
                {
                    return (decimal)Convert.ChangeType(a, typeof(decimal)) *
                        (decimal)Convert.ChangeType(b, typeof(decimal));
                }
                
                if (aType == typeof(double) || bType == typeof(double))
                {
                    return (double)Convert.ChangeType(a, typeof(double)) *
                        (double)Convert.ChangeType(b, typeof(double));
                }
                
                if (aType == typeof(float) || bType == typeof(float))
                {
                    return (float)Convert.ChangeType(a, typeof(float)) *
                        (float)Convert.ChangeType(b, typeof(float));
                }
                
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) *
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) *
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) *
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) * 
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) *
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) *
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) *
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) *
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) * 
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot multiply objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // Divide two numbers
        public static Object DivideNumbers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsNumber(aType) || 
                !DDTHelper.IsNumber(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot divide objects of type '{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            // Make sure b is not zero
            if ((ulong)Convert.ChangeType(b, typeof(ulong)) == 0)
            {
                throw new DDTException("Divide by zero");
            }

            try
            {
                if (aType == typeof(decimal) || bType == typeof(decimal))
                {
                    return (decimal)Convert.ChangeType(a, typeof(decimal)) /
                        (decimal)Convert.ChangeType(b, typeof(decimal));
                }
                
                if (aType == typeof(double) || bType == typeof(double))
                {
                    return (double)Convert.ChangeType(a, typeof(double)) /
                        (double)Convert.ChangeType(b, typeof(double));
                }
                
                if (aType == typeof(float) || bType == typeof(float))
                {
                    return (float)Convert.ChangeType(a, typeof(float)) /
                        (float)Convert.ChangeType(b, typeof(float));
                }
                
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) /
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) /
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) /
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) / 
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) /
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) /
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) /
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) /
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) /
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot divide objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // First integer modulus second integer
        public static Object ModIntegers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsInteger(aType) || 
                !DDTHelper.IsInteger(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot get modulus of objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            // Make sure b is not zero
            if ((ulong)Convert.ChangeType(b, typeof(ulong)) == 0)
            {
                throw new DDTException("Modulus by zero");
            }

            try
            {
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) %
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) %
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) %
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) % 
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) %
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) %
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) %
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) %
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) % 
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot get modulus of objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }

        // Bit shift Left
        public static Object LeftShiftIntegers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsInteger(aType) || 
                !DDTHelper.IsInteger(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot left shift with objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            // b should be int or lesser
            if ((bType == typeof(ulong)) || 
                (bType == typeof(long)) || 
                (bType == typeof(uint)))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot left shift with objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) <<
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) <<
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(uint))
                {
                    return (uint)Convert.ChangeType(a, typeof(uint)) <<
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) <<
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) << 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) << 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) << 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) << 
                        (int)Convert.ChangeType(b, typeof(int));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot left shift with objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // Bit shift Right
        public static Object RightShiftIntegers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsInteger(aType) || 
                !DDTHelper.IsInteger(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot right shift with objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            // b should be int or lesser
            if ((bType == typeof(ulong)) || 
                (bType == typeof(long)) || 
                (bType == typeof(uint)))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot right shift with objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) >>
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) >>
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(uint))
                {
                    return (uint)Convert.ChangeType(a, typeof(uint)) >>
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) >>
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) >> 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) >> 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) >> 
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) >> 
                        (int)Convert.ChangeType(b, typeof(int));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot right shift with objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // Bitwise 'not' of an integer
        public static Object LogicalNotInteger(Object a)
        {
            Type aType = a.GetType();

            if (!DDTHelper.IsInteger(aType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot apply logical 'not' to object of type '{0}'",
                        aType.Name));
            }
            
            if (aType == typeof(ulong))
            {
                return ~(ulong)a;
            }
                
            if (aType == typeof(long))
            {
                return ~(long)a;
            }                
            
            if (aType == typeof(uint))
            {
                return ~(uint)a;
            }
            
            if (aType == typeof(int))
            {
                return ~(int)a;
            }
            
            if (aType == typeof(ushort))
            {
                return ~(ushort)a;
            }
            
            if (aType == typeof(short))
            {
                return ~(short)a;
            }
            
            if (aType == typeof(byte))
            {
                return ~(byte)a;
            }
            
            if (aType == typeof(sbyte))
            {
                return ~(sbyte)a;
            }
            
            throw new DDTException(
                String.Format(
                    "Cannot apply logical 'not' to object of type '{0}'", 
                    aType.Name));
        }

        // Do a bitwise 'and' of integers
        public static Object LogicalAndIntegers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsInteger(aType) || 
                !DDTHelper.IsInteger(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot apply logical 'and' to objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) &
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) &
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) &
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) &
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) &
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) &
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) &
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) &
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) &
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot apply logical 'and' to objects of type " + 
                    "'{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        // Do a bitwise 'xor' of integers
        public static Object LogicalXorIntegers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsInteger(aType) || 
                !DDTHelper.IsInteger(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot apply logical 'xor' to objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) ^
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) ^
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) ^
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) ^
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) ^
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) ^
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) ^
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) ^
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) ^
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot apply logical 'xor' to objects of type " + 
                    "'{0}' and '{1}'",
                    aType.Name, bType.Name));
        }

        // Do a bitwise 'or' of integers
        public static Object LogicalOrIntegers(Object a, Object b)
        {
            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsInteger(aType) || 
                !DDTHelper.IsInteger(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot apply logical 'or' to objects of type " +
                        "'{0}' and '{1}'",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    return (ulong)Convert.ChangeType(a, typeof(ulong)) |
                        (ulong)Convert.ChangeType(b, typeof(ulong));
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    return (long)Convert.ChangeType(a, typeof(long)) |
                        (long)Convert.ChangeType(b, typeof(long));
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        return (long)Convert.ChangeType(a, typeof(long)) |
                            (long)Convert.ChangeType(b, typeof(long));
                    }
                    else
                    {
                        return (uint)Convert.ChangeType(a, typeof(uint)) |
                            (uint)Convert.ChangeType(b, typeof(uint));
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    return (int)Convert.ChangeType(a, typeof(int)) |
                        (int)Convert.ChangeType(b, typeof(int));
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    return (ushort)Convert.ChangeType(a, typeof(ushort)) |
                        (ushort)Convert.ChangeType(b, typeof(ushort));
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    return (short)Convert.ChangeType(a, typeof(short)) |
                        (short)Convert.ChangeType(b, typeof(short));
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    return (byte)Convert.ChangeType(a, typeof(byte)) |
                        (byte)Convert.ChangeType(b, typeof(byte));
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    return (sbyte)Convert.ChangeType(a, typeof(sbyte)) |
                        (sbyte)Convert.ChangeType(b, typeof(sbyte));
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot apply logical 'or' to objects of type " + 
                    "'{0}' and '{1}'",
                    aType.Name, bType.Name));
        }

        // Promote numbers
        public static void PromoteNumbers(Object a, 
                                          Object b,
                                          out Object pa,
                                          out Object pb)
        {
            pa = null;
            pb = null;

            Type aType = a.GetType();
            Type bType = b.GetType();

            if (!DDTHelper.IsNumber(aType) || 
                !DDTHelper.IsNumber(bType))
            {
                throw new DDTException(
                    String.Format(
                        "Cannot match objects of type '{0}' and '{1}' " + 
                        "by promotion",
                        aType.Name, bType.Name));
            }

            try
            {
                if (aType == typeof(decimal) || bType == typeof(decimal))
                {
                    pa = Convert.ChangeType(a, typeof(decimal));
                    pb = Convert.ChangeType(b, typeof(decimal));
                    return;
                }
                
                if (aType == typeof(double) || bType == typeof(double))
                {
                    pa = Convert.ChangeType(a, typeof(double));
                    pb = Convert.ChangeType(b, typeof(double));
                    return;
                }
                
                if (aType == typeof(float) || bType == typeof(float))
                {
                    pa = Convert.ChangeType(a, typeof(float));
                    pb = Convert.ChangeType(b, typeof(float));
                    return;                    
                }
                
                if (aType == typeof(ulong) || bType == typeof(ulong))
                {
                    pa = Convert.ChangeType(a, typeof(ulong));
                    pb = Convert.ChangeType(b, typeof(ulong));
                    return;
                }
                
                if (aType == typeof(long) || bType == typeof(long))
                {
                    pa = Convert.ChangeType(a, typeof(long));
                    pb = Convert.ChangeType(b, typeof(long));
                    return;
                }
                
                if (aType == typeof(uint) || bType == typeof(uint))
                {
                    Type otherType = aType;
                    
                    if (aType == typeof(uint))
                    {
                        otherType = bType;
                    }
                    
                    if ((otherType == typeof(sbyte)) || 
                        (otherType == typeof(short)) || 
                        (otherType == typeof(int)))
                    {
                        pa = Convert.ChangeType(a, typeof(long));
                        pb = Convert.ChangeType(b, typeof(long));
                        return;
                    }
                    else
                    {
                        pa = Convert.ChangeType(a, typeof(uint));
                        pb = Convert.ChangeType(b, typeof(uint));
                        return;
                    }
                }
                
                if (aType == typeof(int) || bType == typeof(int))
                {
                    pa = Convert.ChangeType(a, typeof(int));
                    pb = Convert.ChangeType(b, typeof(int));
                    return;
                }
                
                if (aType == typeof(ushort) || bType == typeof(ushort))
                {
                    pa = Convert.ChangeType(a, typeof(ushort));
                    pb = Convert.ChangeType(b, typeof(ushort));
                    return;
                }
                
                if (aType == typeof(short) || bType == typeof(short))
                {
                    pa = Convert.ChangeType(a, typeof(short));
                    pb = Convert.ChangeType(b, typeof(short));
                    return;
                }
                
                if (aType == typeof(byte) || bType == typeof(byte))
                {
                    pa = Convert.ChangeType(a, typeof(byte));
                    pb = Convert.ChangeType(b, typeof(byte));
                    return;
                }
                
                if (aType == typeof(sbyte) || bType == typeof(sbyte))
                {
                    pa = Convert.ChangeType(a, typeof(sbyte));
                    pb = Convert.ChangeType(b, typeof(sbyte));
                    return;
                }
            }
            catch (Exception) {}

            throw new DDTException(
                String.Format(
                    "Cannot compare objects of type '{0}' and '{1}'",
                    aType.Name, bType.Name));
        }


        public enum ValueTypes
        {
            Value = 0,
            Reference = 1,
            Method = 2,
            List = 3,
            TypeList = 4,
            Other = 5
        }


        // Derefernce a reference element and return it's value
        // Adjust the value type passed in to ValueTypes.Value
        public static void Dereference(ref ValueTypes valueType,
                                       ref Object value)
        {
            if (valueType == ValueTypes.Reference)
            {
                if (value == null)
                {
                    throw new DDTException(
                        "Internal error : Reference value is null");
                }

                // Dereference
                if (value.GetType().GetInterface("IDDTReference") == null)
                {
                    throw new Exception(
                        "Internal error : " + 
                        "Reference expected but did not get one");
                }

                IDDTReference reference = (IDDTReference)value;
                
                value = reference.GetValue();
                valueType = ValueTypes.Value;
            }
        }

        // Get the number of dimensions from a string like [,,]
        private static int GetDimensions(String dimensionStr)
        {
            // Dimensions = Number of commas + 1
            int numDimensions = 1;
            foreach (Char c in dimensionStr)
            {
                if (c == ',')
                {
                    numDimensions++;
                }
            }

            return numDimensions;
        }


        private static String GetSymbolString(String expression, 
                                              Symbol symbol)
        {
            int start = 
                symbol.Children[0].Location.StartColumn + 1;

            int length = 
                symbol.Children[0].Location.EndColumn - start;
            
            return expression.Substring(start,length);
        }

        // Evaluate a parse tree - Mostly for internal use
        public static Object EvalSymbolTree(DDTEnvironment e,
                                            String expression,
                                            Symbol symbol,
                                            out ValueTypes valueType)
        {
            Object value = null;
            valueType = ValueTypes.Other;

            if (symbol.IsTerminal)
            {
                valueType = ValueTypes.Value;

                switch (symbol.Token)
                {
                case Tokens.Null:
                    value = null;
                    break;
                    
                case Tokens.Character:
                    value = (Char)symbol.TokenString[1];
                    break;
                    
                case Tokens.String:
                {
                    String str = 
                        symbol.TokenString.Substring(1, 
                                                     symbol.TokenString.Length 
                                                     - 2);

                    value = DDTHelper.StringEscape(str);
                    
                    break;
                }

                case Tokens.Boolean:
                    value = (symbol.TokenString == "true");
                    break;
                    
                case Tokens.Integer:
                    try
                    {
                        value = Convert.ChangeType(symbol.TokenString, 
                                                   typeof(Int32));
                    }
                    catch (Exception)
                    {
                        try
                        {
                            value = Convert.ChangeType(symbol.TokenString, 
                                                       typeof(Int64));
                        }
                        catch (Exception)
                        {
                            throw new DDTException(
                                "Number too long : " + symbol.TokenString);
                        }
                    }
                    break;

                case Tokens.Hexadecimal:
                    try
                    {
                        value = Int32.Parse(symbol.TokenString.Substring(2), 
                                            NumberStyles.HexNumber);
                    } catch (Exception){
                        try
                        {
                            value = Int64.Parse(
                                symbol.TokenString.Substring(2), 
                                NumberStyles.HexNumber);
                        }
                        catch (Exception){
                            throw new DDTException(
                                "Number too long : " + symbol.TokenString);
                        }
                    }                 
                    break;

                case Tokens.Float:
                    try
                    {
                        value = Convert.ChangeType(symbol.TokenString, 
                                                   typeof(double));
                    }
                    catch (Exception)
                    {
                        throw new DDTException("Invalid float : " + 
                                               symbol.TokenString);
                    }
                    break;                    

                default:
                    throw new DDTException("Unxpected token '" + 
                                        symbol.TokenString +
                                        "' at position : " + 
                                        symbol.Location.StartColumn);
                }
            }
            else
            {
                // Non-terminals - Look at the reduction id
                // and recursively evaluate the expression 
                switch (symbol.ReductionId)
                {
                case Reductions.Default:
                {
                    if (symbol.Children.Count > 0)
                    {
                        value = EvalSymbolTree(e, 
                                               expression,
                                               symbol.Children[0], 
                                               out valueType);
                    }
                    else if (symbol.NonTerminal == NonTerminals.ExpressionList)
                    {
                        valueType = ValueTypes.List;
                        value = new DDTExpressionList();
                    }
                    else
                    {
                        value = null;
                    }
                    break;
                }

                case Reductions.ListReduction:
                {
                    // Make sure there are no 'ref' modifiers in the list
                    // and get the list value
                    value = EvalSymbolTree(e,
                                           expression,
                                           symbol.Children[0],
                                           out valueType);

                    DDTExpressionList expList = (DDTExpressionList)value;

                    if (expList.HasReferenceObjects())
                    {
                        throw new DDTException(
                            "Invalid 'ref' specification in list");
                    }

                    valueType = ValueTypes.Value;
                    value = expList.ValueList;
                    
                    break;
                }

                case Reductions.RangeReduction:
                {
                    ValueTypes startType;
                    Object startVal = EvalSymbolTree(e, 
                                                     expression,
                                                     symbol.Children[0], 
                                                     out startType);
                    
                    // De-Reference if it's a reference type
                    DDTHelper.Dereference(ref startType, ref startVal);

                    if (startType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            String.Format(
                                "'{0}' does not evaluate to an object value",
                                DDTHelper.GetSymbolString(
                                    expression,
                                    symbol.Children[0])));
                    }

                    ValueTypes endType;
                    Object endVal = EvalSymbolTree(e, 
                                                   expression,
                                                   symbol.Children[1], 
                                                   out endType);
                    
                    // De-Reference if it's a reference type
                    DDTHelper.Dereference(ref endType, ref endVal);

                    if (endType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            String.Format(
                                "'{0}' does not evaluate to an object value",
                                DDTHelper.GetSymbolString(
                                    expression,
                                    symbol.Children[1])));
                    }
                    
                    valueType = ValueTypes.Value;
                    value = DDTHelper.GetRangeList(expression,
                                                   symbol,
                                                   startVal,
                                                   endVal);

                    break;
                }
                
                case Reductions.CastReduction:
                {
                    String typeName = symbol.Children[0].TokenString;
                    Type targetType = SearchType(typeName);
                    

                    if (targetType == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }

                    value = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[1], 
                                           out valueType);

                    // De-Reference if it's a reference type
                    DDTHelper.Dereference(ref valueType, ref value);
                    
                    if (valueType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            String.Format("'{0}' does not evaluate to an " + 
                                          "object value",
                                          DDTHelper.GetSymbolString(
                                              expression,
                                              symbol.Children[1])));
                    }
                    
                    value = DDTHelper.CoerceType(value, targetType);
                    if (value == null)
                    {
                        throw new DDTException(
                            String.Format(
                                "Cannot convert '{0}' to type '{1}'",
                                DDTHelper.GetSymbolString(expression,
                                                          symbol.Children[1]),
                                typeName));
                    }
                    
                    break;
                }
                
                case Reductions.DollarReduction:
                {
                    String variableName = symbol.Children[0].TokenString;
                    valueType = ValueTypes.Reference;
                    
                    // Field specified?
                    String[] fields = new String[0];
                    if (variableName.Contains("."))
                    {
                        fields = variableName.Split(new char[]{'.'});
                        variableName = fields[0];
                    }
                    
                    String currentVar = variableName;

                    // Get the engine that contains the variable
                    DDTEnvironment varEnv = e.GetVarEnv(variableName);
                    if (varEnv == null)
                    {
                        // Variable name not found
                        throw new
                            DDTException("Variable '$" + variableName +
                                         "' not defined");                    
                    }
                    else
                    {                
                        value = 
                            varEnv.GetVariableReference(variableName);
                    
                        for (int i = 1;i < fields.Length;i++)
                        {
                            Type variableType = value.GetType();
                            Object newValue;
                            
                            if (!DDTHelper.GetFieldOrPropertyReference(
                                    ((IDDTReference)value).GetValue(),
                                    fields[i],
                                    out newValue))
                            {
                                // Check for method if it's the last sub field
                                if ((i == fields.Length - 1) && 
                                    (DDTHelper.HasMethodByName(
                                        ((IDDTReference)value).GetValue(),
                                        fields[i])))
                                {
                                    newValue = new DDTObjectMethod(
                                        ((IDDTReference)value).GetValue(),
                                        fields[i]);
                                    
                                    valueType = ValueTypes.Method;
                                    // return value
                                }
                                else
                                {
                                    throw new 
                                        DDTException("Member '" 
                                                     + fields[i] + 
                                                     "' not found in '$" +
                                                     currentVar + "'");
                                }
                            }              

                            value = newValue;
                            currentVar += "." + fields[i];
                        }
                        
                    }                    

                    break;
                }
                
                case Reductions.MemberReduction:
                {                   
                    // Return a reference if the LHS is a reference
                    // Return a value if LHS is a value
                    String subFieldName = symbol.Children[1].TokenString;
                    
                    value = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0], 
                                           out valueType);
                    
                    
                    if ((valueType != ValueTypes.Value) && 
                        (valueType != ValueTypes.Reference))
                    {
                        throw new DDTException(
                            "Unexpected member reference : '" + 
                            subFieldName + "'");
                    }
                    
                    if (value == null)
                    {
                        throw new DDTException(
                            "Object reference is null while referencing : '" +
                            subFieldName + "'");
                    }
                        
                    String[] fields = subFieldName.Split(new char[]{'.'});
                    for (int i = 0;i < fields.Length;i++)
                    {
                        Type variableType = value.GetType();
                        Object newValue;

                        Object refVal = 
                            (valueType == ValueTypes.Value) ? 
                            value : 
                            ((IDDTReference)value).GetValue();
                        
                        if (!DDTHelper.GetFieldOrPropertyReference(
                                refVal,
                                fields[i],
                                out newValue))
                        {
                            // Check for mehtod if it's the last sub field
                            if ((i == fields.Length - 1) && 
                                (DDTHelper.HasMethodByName(refVal,
                                                           fields[i])))
                            {
                                newValue = new DDTObjectMethod(refVal, 
                                                               fields[i]);
                                valueType = ValueTypes.Method;
                                // return value
                            }
                            else
                            {
                                throw new 
                                    DDTException("Member '" 
                                                 + fields[i] + 
                                                 "' not found in type '" +
                                                 variableType.Name + "'");
                            }
                        }

                        value = (valueType == ValueTypes.Value) ? 
                            ((IDDTReference)newValue).GetValue() : newValue;
                    }
                    
                    break;
                }

                case Reductions.StaticMemberReduction:
                {
                    String typeName = symbol.Children[0].TokenString;
                    Type targetType = SearchType(typeName);
                    
                    if (targetType == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }
                    
                    String fieldName = symbol.Children[1].TokenString;
                    
                    valueType = ValueTypes.Reference;
                    if (!DDTHelper.GetStaticFieldOrPropertyRef(targetType,
                                                               fieldName,
                                                               out value))
                    {
                        if (DDTHelper.HasStaticMethodByName(targetType,
                                                            fieldName))
                        {
                            value = new DDTObjectMethod(targetType, fieldName);
                            valueType = ValueTypes.Method;
                        }
                        else
                        {
                            throw new 
                                DDTException("Static Member '" 
                                             + fieldName + "' not found");
                        }
                    }
                    break;
                }

                case Reductions.ArrayReduction:
                {
                    // Get the Value of the object being referenced
                    value = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0], 
                                           out valueType);

                    // De-Reference if it's a reference type
                    DDTHelper.Dereference(ref valueType, ref value);
                                        
                    if (valueType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            String.Format
                            ("{0} does not evaluate to a value",
                             DDTHelper.GetSymbolString(expression,
                                                       symbol.Children[0])));
                    }
                    
                    if (value == null)
                    {
                        throw new DDTException(
                            "Object reference is null while referencing " +
                            "index value");
                    }
                    
                    // Preliminary checks to see whether the type can be
                    // referenced
                    Type t = value.GetType();
                    if (t.IsValueType)
                    {
                        throw new DDTException("Cannot index value type");
                    }

                    
                    // Get the list of objects from expression list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[1],
                                                          out paramsType);
                    
                    // Reference parameters have no place in array index list
                    if (paramsList.HasReferenceObjects())
                    {
                        throw new DDTException(
                            "Invalid 'ref' specification in " + 
                            "array index list");
                    }

                    // Get Parameter and signature arrays
                    Object[] parameters = new Object[paramsList.Count];
                    Type[] signature = new Type[paramsList.Count];
                    int index = 0;
                    foreach (Object o in paramsList.ValueList)
                    {
                        parameters[index] = o;
                        signature[index++] = o.GetType();
                    }
                                      
                    // If it is an array type, index using the integer 
                    // parameters
                    if (typeof(Array).IsAssignableFrom(t))
                    {
                        Array a = (Array)value;
                        
                        try
                        {
                            Int64[] indices = new Int64[parameters.Length];
                            
                            for (int i = 0;i < parameters.Length;i++)
                            {
                                indices[i] = 
                                    (Int64)Convert.ChangeType(parameters[i],
                                                              typeof(Int64));
                            }

                            // Get the reference for the given array index
                            valueType = ValueTypes.Reference;
                            value = new DDTArrayReference(a, indices);
                        }
                        catch (Exception)
                        {
                            throw new DDTException(
                                "Invalid indices specified for array");
                        }                        
                    }
                    else
                    {                        
                        // Try to index with the given parameters
                        // with the indexer property
                        String indexPropertyName = String.Empty;
                        Object[] attributes = t.GetCustomAttributes(
                            typeof(DefaultMemberAttribute), true);
                        
                        if ((attributes == null) || (attributes.Length == 0))
                        {
                            indexPropertyName = "Item";
                        }
                        else
                        {
                            indexPropertyName = 
                                ((DefaultMemberAttribute)attributes[0]).
                                MemberName;
                        }
                        
                        PropertyInfo p = t.GetProperty(indexPropertyName,
                                                       signature);
                        
                        if (p == null)
                        {
                            String paramTypes =  "(";
                            
                            for (int i = 0;i < signature.Length;i++)
                            {
                                paramTypes += signature[i].Name;
                                
                                if (i < signature.Length - 1)
                                {
                                    paramTypes += ", ";
                                }
                            }
                            paramTypes += ")";
                            
                            throw new DDTException(
                                String.Format(
                                    "Indexer with given signature '{0}' " + 
                                    "not found",
                                    paramTypes)); 
                        }
                        
                        // Access the indexer with the given index objects
                        valueType = ValueTypes.Reference;
                        value = new DDTPropertyReference(p,
                                                         value, 
                                                         parameters);
                    }
                                        
                    break;
                }

                case Reductions.SingleParamReduction:
                {
                    ValueTypes paramType;
                    Object param;
                    
                    param = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0],
                                           out paramType);
                    
                    DDTHelper.Dereference(ref paramType, ref param);

                    if (paramType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            "List item does not evaluate to a value");
                    }
                    
                    DDTExpressionList expList = 
                        new DDTExpressionList();
                    expList.AddValue(param);

                    value = expList;
                    valueType = ValueTypes.List;

                    break;
                }
                
                case Reductions.ParamReduction:
                {
                    ValueTypes currentType;
                    value = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0],
                                           out currentType);
                    
                    DDTExpressionList expList = (DDTExpressionList)value;

                    ValueTypes newType;
                    Object newVal;
                    
                    newVal = EvalSymbolTree(e,
                                            expression,
                                            symbol.Children[1],
                                            out newType);
                    
                    DDTHelper.Dereference(ref newType, ref newVal);

                    if (newType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            "List item does not evaluate to a value");
                    }

                    valueType = ValueTypes.List;
                    expList.AddValue(newVal);
                    // value = expList
                    
                    break;
                }

                case Reductions.RefSingleParamReduction:
                {
                    ValueTypes paramType;
                    Object param;
                    
                    param = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0],
                                           out paramType);
                    
                    if (paramType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "Reference parameter does not evaluate " + 
                            "to a variable reference");
                    }
                    
                    DDTExpressionList expList = new DDTExpressionList();
                    expList.AddReference((IDDTReference)param);

                    value = expList;
                    valueType = ValueTypes.List;

                    break;
                }
                
                case Reductions.RefParamReduction:
                {
                    ValueTypes currentType;
                    value = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0],
                                           out currentType);
                    
                    DDTExpressionList expList = (DDTExpressionList)value;

                    ValueTypes newType;
                    Object newVal;
                    
                    newVal = EvalSymbolTree(e,
                                            expression,
                                            symbol.Children[1],
                                            out newType);
                    
                    if (newType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "Reference parameter does not evaluate " + 
                            "to a variable reference");
                    }

                    valueType = ValueTypes.List;
                    expList.AddReference((IDDTReference)newVal);
                    // value = expList
                     
                    break;
                }
                
                case Reductions.MethodReduction:
                {
                    ValueTypes methodType;
                    Object methodVal = EvalSymbolTree(e, 
                                                      expression,
                                                      symbol.Children[0],
                                                      out methodType);

                    if (methodType != ValueTypes.Method)
                    {
                        throw new DDTException(
                            String.Format("'{0}' is not a method " + 
                                          "but is used like one",
                                          DDTHelper.GetSymbolString(
                                              expression,
                                              symbol.Children[0])));
                    }
                    
                    // Get the list of objects from expression list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[1],
                                                          out paramsType);
                    
                    Object[] parameters = new Object[paramsList.Count];
                    Type[] signature = new Type[paramsList.Count];
                    int index = 0;                    
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Value)
                        {
                            parameters[index] = paramsList.ValueList[index];
                            signature[index] = parameters[index].GetType();
                        }
                        else
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            parameters[index] = reference.GetValue();

                            // Marke the parameter as reference type
                            signature[index] = 
                                parameters[index].GetType().MakeByRefType();
                        }

                        index++;
                    }

                    DDTObjectMethod objMethod = (DDTObjectMethod)methodVal;
                    
                    valueType = ValueTypes.Value;
                    value = objMethod.Invoke(parameters, signature);
                   
                    // Re-assign all parameters passed by reference
                    index = 0;
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Reference)
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            // Set the variable the reference points to
                            reference.SetValue(parameters[index]);
                        }
                        
                        index++;
                    }
                    
                    break;
                }

                case Reductions.GenericMethodReduction:
                {
                    ValueTypes methodType;
                    Object methodVal = EvalSymbolTree(e, 
                                                      expression,
                                                      symbol.Children[0],
                                                      out methodType);

                    if (methodType != ValueTypes.Method)
                    {
                        throw new DDTException(
                            String.Format("'{0}' is not a method " + 
                                          "but is used like one",
                                          DDTHelper.GetSymbolString(
                                              expression,
                                              symbol.Children[0])));
                    }
                    
                    // Get the Generic type list
                    // Get the generic type specifiers
                    ValueTypes typeListType;
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[1],
                                                            out typeListType);

                    Type[] types = new Type[typeList.Count];
                    for (int i = 0;i < typeList.Count;i++)
                    {
                        types[i] = (Type)typeList[i];
                    }                    

                    // Get the list of objects from expression list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[2],
                                                          out paramsType);
                    
                    Object[] parameters = new Object[paramsList.Count];
                    Type[] signature = new Type[paramsList.Count];
                    int index = 0;                    
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Value)
                        {
                            parameters[index] = paramsList.ValueList[index];
                            signature[index] = parameters[index].GetType();
                        }
                        else
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            parameters[index] = reference.GetValue();

                            // Marke the parameter as reference type
                            signature[index] = 
                                parameters[index].GetType().MakeByRefType();
                        }

                        index++;
                    }

                    DDTObjectMethod objMethod = (DDTObjectMethod)methodVal;
                                        
                    // Invoke the generic method by specifiying the 
                    // geneic types as well
                    valueType = ValueTypes.Value;
                    value = objMethod.Invoke(parameters, signature, types);
                   
                    // Re-assign all parameters passed by reference
                    index = 0;
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Reference)
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            // Set the variable the reference points to
                            reference.SetValue(parameters[index]);
                        }
                        
                        index++;
                    }
                    
                    break;
                }

                case Reductions.NewReduction:
                {
                    String typeName = symbol.Children[0].TokenString;
                    Type t = DDTHelper.SearchType(typeName);

                    if (t == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }

                    // See if there is a public constructor                    
                    if (t.GetConstructors().Length == 0)
                    {
                        throw new DDTException("No public constructors " +
                                               "found for " + t.Name);
                    }

                    // Get the parameter list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[1],
                                                          out paramsType);
                    
                    // Construct the parameter signature
                    Object[] parameters = new Object[paramsList.Count];
                    Type[] signature = new Type[paramsList.Count];
                    int index = 0;                    
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Value)
                        {
                            parameters[index] = paramsList.ValueList[index];
                            signature[index] = parameters[index].GetType();
                        }
                        else
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            parameters[index] = reference.GetValue();

                            // Marke the parameter as reference type
                            signature[index] = 
                                parameters[index].GetType().MakeByRefType();
                        }

                        index++;
                    }

                    
                    // Find the constructor with the given signature
                    ConstructorInfo cinfo = t.GetConstructor(signature);
                    if (cinfo == null)
                    {
                        String paramTypes =  "(";
                        
                        for (int i = 0;i < signature.Length;i++)
                        {
                            paramTypes += signature[i].Name;
                            
                            if (i < signature.Length - 1)
                            {
                                paramTypes += ", ";
                            }
                        }
                        paramTypes += ")";
                        
                        throw new DDTException(
                            "Cannot not find constructor with signature : " +
                            paramTypes);                        
                    }

                    value = cinfo.Invoke(parameters);
                    valueType = ValueTypes.Value;

                    // Re-assign all parameters passed by reference
                    index = 0;
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Reference)
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            // Set the variable the reference points to
                            reference.SetValue(parameters[index]);
                        }
                        
                        index++;
                    }

                    break;
                }

                case Reductions.ComparisonReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);
                    
                    if (lhsType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            String.Format(
                                "LHS of operator '{0}' does not evaluate " + 
                                "to a value", symbol.Children[1].TokenString));
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[2],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if (rhsType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            String.Format(
                                "RHS of operator '{0}' does not evaluate " + 
                                "to a value", symbol.Children[1].TokenString));
                    }
                    
                    // Set the value of the expression as the boolean result
                    // of comparison
                    value = CompareObjects(lhs,
                                           symbol.Children[1].TokenString,
                                           rhs);
                    valueType = ValueTypes.Value;

                    break;
                }
                
                case Reductions.NotReduction:
                {
                    value = EvalSymbolTree(e, 
                                           expression,
                                           symbol.Children[0],
                                           out valueType);
                    
                    DDTHelper.Dereference(ref valueType, ref value);

                    if ((valueType != ValueTypes.Value) ||
                        (value.GetType() != typeof(bool)))
                    {
                        throw new DDTException(
                            "Operand of operator '!' does not evaluate " + 
                            "to a bool value");
                    }

                    value = !((bool)value);

                    break;
                }

                case Reductions.AndReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((lhsType != ValueTypes.Value) || 
                        (lhs.GetType() != typeof(bool)))
                    {
                        throw new DDTException(
                            "LHS of operator 'and' does not evaluate " + 
                            "to a bool value");
                    }

                    // Evaluate rhs only if lhs is true
                    if ((bool)lhs == false)
                    {
                        value = false;
                        valueType = ValueTypes.Value;
                        break;
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((rhsType != ValueTypes.Value) || 
                        (rhs.GetType() != typeof(bool)))
                    {
                        throw new DDTException(
                            "RHS of operator 'and' does not evaluate " + 
                            "to a bool value");
                    }                    
                    
                    value = (bool)lhs && (bool)rhs;
                    valueType = ValueTypes.Value;

                    break;
                }

                case Reductions.OrReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((lhsType != ValueTypes.Value) || 
                        (lhs.GetType() != typeof(bool)))
                    {
                        throw new DDTException(
                            "LHS of operator 'or' does not evaluate " + 
                            "to a bool value");
                    }

                    // Evaluate rhs only if lhs is false
                    if ((bool)lhs == true)
                    {
                        value = true;
                        valueType = ValueTypes.Value;
                        break;
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((rhsType != ValueTypes.Value) || 
                        (rhs.GetType() != typeof(bool)))
                    {
                        throw new DDTException(
                            "RHS of operator 'or' does not evaluate " + 
                            "to a bool value");
                    }                    
                    
                    value = (bool)lhs || (bool)rhs;
                    valueType = ValueTypes.Value;
                    
                    break;
                }

                case Reductions.SumReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.CanAdd(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '+' does not evaluate " + 
                            "to a numeric or string value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.CanAdd(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '+' does not evaluate " + 
                            "to a numeric or string value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.AddObjects(lhs, rhs);

                    break;
                }

                case Reductions.DiffReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsNumber(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '-' does not evaluate " + 
                            "to a numeric value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsNumber(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '-' does not evaluate " + 
                            "to a numeric value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.SubtractNumbers(lhs, rhs);

                    break;
                }

                case Reductions.UnaryMinusReduction:
                {
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    DDTHelper.Dereference(ref operandType, ref operand);
                    
                    if ((!DDTHelper.IsNumber(operand.GetType())) ||
                        (operandType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "Operand for unary '-' does not evaluate " + 
                            "to a numeric value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.NegateNumber(operand);

                    break;
                }

                case Reductions.UnaryPlusReduction:
                {
                    // Just for the sake of completeness
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    DDTHelper.Dereference(ref operandType, ref operand);
                    
                    if ((!DDTHelper.IsNumber(operand.GetType())) ||
                        (operandType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "Operand for unary '+' does not evaluate " + 
                            "to a numeric value");
                    }

                    valueType = ValueTypes.Value;
                    value = operand;

                    break;
                }                

                case Reductions.PreIncReduction:
                {
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    // Operand needs to be a reference type
                    if (operandType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "Operand for '++' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value the variable refers to
                    IDDTReference reference = (IDDTReference)operand;

                    if (!DDTHelper.IsNumber(reference.GetValue().GetType()))
                    {
                        throw new DDTException(
                            "'++' cannot be applied to " +
                            "non-numeric type : " + 
                            reference.GetValue().GetType().Name);
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.IncObject(reference.GetValue());

                    // Increment the value the variable references
                    reference.SetValue(value);

                    break;
                }

                case Reductions.PreDecReduction:
                {
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    // Operand needs to be a reference type
                    if (operandType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "Operand for '--' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value the variable refers to
                    IDDTReference reference = (IDDTReference)operand;

                    if (!DDTHelper.IsNumber(reference.GetValue().GetType()))
                    {
                        throw new DDTException(
                            "'--' cannot be applied to " +
                            "non-numeric type : " + 
                            reference.GetValue().GetType().Name);
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.DecObject(reference.GetValue());

                    // Decrement the value the variable references
                    reference.SetValue(value);

                    break;
                }

                case Reductions.LogicalNotReduction:
                {
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    DDTHelper.Dereference(ref operandType, ref operand);
                    
                    if ((!DDTHelper.IsInteger(operand.GetType())) ||
                        (operandType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "Operand for '~' does not evaluate " + 
                            "to a integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.LogicalNotInteger(operand);

                    break;
                }

                case Reductions.PostIncReduction:
                {
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    // Operand needs to be a reference type
                    if (operandType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "Operand for '++' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value the variable refers to
                    IDDTReference reference = (IDDTReference)operand;

                    if (!DDTHelper.IsNumber(reference.GetValue().GetType()))
                    {
                        throw new DDTException(
                            "'++' cannot be applied to " +
                            "non-numeric type : " + 
                            reference.GetValue().GetType().Name);
                    }

                    // The value of the expression is the non-incremented value
                    valueType = ValueTypes.Value;
                    value = reference.GetValue();

                    // Increment the value the variable references
                    reference.SetValue(
                        DDTHelper.IncObject(reference.GetValue()));

                    break;
                }

                case Reductions.PostDecReduction:
                {
                    ValueTypes operandType;
                    Object operand = EvalSymbolTree(e, 
                                                    expression,
                                                    symbol.Children[0],
                                                    out operandType);

                    // Operand needs to be a reference type
                    if (operandType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "Operand for '--' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value the variable refers to
                    IDDTReference reference = (IDDTReference)operand;

                    if (!DDTHelper.IsNumber(reference.GetValue().GetType()))
                    {
                        throw new DDTException(
                            "'--' cannot be applied to " +
                            "non-numeric type : " + 
                            reference.GetValue().GetType().Name);
                    }

                    // The value of the expression is the non-decremeneted 
                    // value
                    valueType = ValueTypes.Value;
                    value = reference.GetValue();

                    // Decrement the value the variable references
                    reference.SetValue(
                        DDTHelper.DecObject(reference.GetValue()));

                    break;
                }

                case Reductions.MultReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsNumber(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '*' does not evaluate " + 
                            "to a numeric value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsNumber(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '*' does not evaluate " + 
                            "to a numeric value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.MultiplyNumbers(lhs, rhs);

                    break;
                }

                case Reductions.DivReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsNumber(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '*' does not evaluate " + 
                            "to a numeric value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsNumber(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '*' does not evaluate " + 
                            "to a numeric value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.DivideNumbers(lhs, rhs);

                    break;
                }

                case Reductions.ModReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsInteger(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '%' does not evaluate " + 
                            "to an integer value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '%' does not evaluate " + 
                            "to an integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.ModIntegers(lhs, rhs);

                    break;
                }

                case Reductions.LShiftReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsInteger(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator 'ls' does not evaluate " + 
                            "to an integer value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator 'ls' does not evaluate " + 
                            "to an integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.LeftShiftIntegers(lhs, rhs);

                    break;
                }

                case Reductions.RShiftReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsInteger(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator 'rs' does not evaluate " + 
                            "to an integer value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator 'rs' does not evaluate " + 
                            "to an integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.RightShiftIntegers(lhs, rhs);

                    break;
                }
                

                case Reductions.LogicalAndReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsInteger(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '^and' does not evaluate " + 
                            "to an integer value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '^and' does not evaluate " + 
                            "to an integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.LogicalAndIntegers(lhs, rhs);

                    break;
                }

                case Reductions.LogicalXorReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsInteger(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '^xor' does not evaluate " + 
                            "to an integer value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '^xor' does not evaluate " + 
                            "to an integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.LogicalXorIntegers(lhs, rhs);

                    break;
                }

                case Reductions.LogicalOrReduction:
                {
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    DDTHelper.Dereference(ref lhsType, ref lhs);

                    if ((!DDTHelper.IsInteger(lhs.GetType())) ||
                        (lhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "LHS of operator '^or' does not evaluate " + 
                            "to an integer value");
                    }

                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '^or' does not evaluate " + 
                            "to an integer value");
                    }

                    valueType = ValueTypes.Value;
                    value = DDTHelper.LogicalOrIntegers(lhs, rhs);

                    break;
                }

                case Reductions.AssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if (rhsType != ValueTypes.Value)
                    {
                        throw new DDTException(
                            "RHS of operator '=' does not evaluate " + 
                            "to a value");
                    }
                    
                    // Assign RHS to LHS
                    ((IDDTReference)lhs).SetValue(rhs);
                    
                    // Return the value of rhs as the value of the expression
                    valueType = ValueTypes.Value;
                    value = rhs;

                    break;                    
                }

                case Reductions.PlusAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '+=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.CanAdd(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '+=' does not evaluate " + 
                            "to a numeric or string value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.CanAdd(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '+=' does not evaluate " + 
                            "to a numeric or string value");
                    }
                    
                    // Add the LHS to the RHS value and store it in LHS
                    value = DDTHelper.AddObjects(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.MinusAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '-=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsNumber(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '-=' does not evaluate " + 
                            "to a numeric value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsNumber(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '-=' does not evaluate " + 
                            "to a value");
                    }
                    
                    // Subtract the RHS from the LHS value and store it in LHS
                    value = DDTHelper.SubtractNumbers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);                    
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.MultAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '*=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsNumber(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '*=' does not evaluate " + 
                            "to a numeric value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsNumber(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '*=' does not evaluate " + 
                            "to a numeric value");
                    }
                    
                    value = DDTHelper.MultiplyNumbers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);                    
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.DivAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '/=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsNumber(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '/=' does not evaluate " + 
                            "to a numeric value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsNumber(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '/=' does not evaluate " + 
                            "to a numeric value");
                    }
                    
                    value = DDTHelper.DivideNumbers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }


                case Reductions.ModAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '%=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsInteger(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '%=' does not evaluate " + 
                            "to an integer value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '%=' does not evaluate " + 
                            "to an integer value");
                    }
                    
                    value = DDTHelper.ModIntegers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.LShiftAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator 'ls=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsInteger(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator 'ls=' does not evaluate " + 
                            "to an integer value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator 'ls=' does not evaluate " + 
                            "to an integer value");
                    }
                    
                    value = DDTHelper.LeftShiftIntegers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }


                case Reductions.RShiftAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator 'rs=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsInteger(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator 'rs=' does not evaluate " + 
                            "to an integer value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator 'rs=' does not evaluate " + 
                            "to an integer value");
                    }
                    
                    value = DDTHelper.RightShiftIntegers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }


                case Reductions.AndAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '^and=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsInteger(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '^and=' does not evaluate "+
                            "to an integer value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '^and=' does not evaluate " + 
                            "to an integer value");
                    }
                    
                    value = DDTHelper.LogicalAndIntegers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.XorAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '^xor=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsInteger(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '^xor=' does not evaluate "+
                            "to an integer value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '^xor=' does not evaluate " + 
                            "to an integer value");
                    }
                    
                    value = DDTHelper.LogicalXorIntegers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.OrAssignmentReduction:
                {
                    // Get the reference of the LHS
                    ValueTypes lhsType;
                    Object lhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[0],
                                                out lhsType);

                    if (lhsType != ValueTypes.Reference)
                    {
                        throw new DDTException(
                            "LHS of operator '^or=' does not evaluate " + 
                            "to a variable reference");
                    }

                    // Get the value of LHS
                    Object lhsValue = ((IDDTReference)lhs).GetValue();

                    if (!DDTHelper.IsInteger(lhsValue.GetType()))
                    {
                        throw new DDTException(
                            "LHS value of operator '^or=' does not evaluate "+
                            "to an integer value");
                    }

                    // Get the value of the RHS
                    ValueTypes rhsType;
                    Object rhs = EvalSymbolTree(e, 
                                                expression,
                                                symbol.Children[1],
                                                out rhsType);

                    DDTHelper.Dereference(ref rhsType, ref rhs);

                    if ((!DDTHelper.IsInteger(rhs.GetType())) ||
                        (rhsType != ValueTypes.Value))
                    {
                        throw new DDTException(
                            "RHS of operator '^or=' does not evaluate " + 
                            "to an integer value");
                    }
                    
                    value = DDTHelper.LogicalOrIntegers(lhsValue, rhs);
                    ((IDDTReference)lhs).SetValue(value);
                    valueType = ValueTypes.Value;

                    break;                    
                }

                case Reductions.SingleTypeReduction:
                {
                    String typeName = symbol.Children[0].TokenString;
                    
                    Type targetType = SearchType(typeName);
                    
                    if (targetType == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }
                    
                    ArrayList typeList = new ArrayList();
                    typeList.Add(targetType);

                    
                    // Return a list with the single type
                    valueType = ValueTypes.TypeList;                    
                    value = typeList;
                    
                    break;
                }

                case Reductions.GenericSingleTypeReduction:
                {
                    String typeName = symbol.Children[0].TokenString;

                    // Get the Type list
                    ValueTypes typeListType;
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[1],
                                                            out typeListType);

                    Type[] types = new Type[typeList.Count];
                    for (int i = 0;i < typeList.Count;i++)
                    {
                        types[i] = (Type)typeList[i];
                    }
                    
                    // Get the specific type from the generic type
                    Type targetType = DDTHelper.SearchType(typeName + "`" + 
                                                  typeList.Count.ToString());
                    
                    if (targetType == null)
                    {
                        throw new DDTException(
                            "Could not find generic type '" + 
                            typeName +
                            "' with " + 
                            typeList.Count.ToString() + " generic type(s)");
                    }
                    
                    // Get the specific type from the generic type
                    targetType = targetType.MakeGenericType(types);
                    
                    // Return the new type list
                    ArrayList outerTypeList = new ArrayList();
                    outerTypeList.Add(targetType);
                     
                    // Return a list with the single type
                    valueType = ValueTypes.TypeList;                    
                    value = outerTypeList;
                    
                    break;
                }

                case Reductions.ArraySingleTypeReduction:
                {
                    String typeName = symbol.Children[0].TokenString;
                    
                    Type targetType = SearchType(typeName);
                    
                    if (targetType == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }
                    
                    // Get the array dimensions
                    String dimensionStr = symbol.Children[1].TokenString;
                    
                    // Count the number of ',' for the dimensions
                    int numDimensions = DDTHelper.GetDimensions(dimensionStr);
                    
                    ArrayList typeList = new ArrayList();
                    typeList.Add(targetType.MakeArrayType(numDimensions));
                    
                    // Return a list with the single type
                    valueType = ValueTypes.TypeList;                    
                    value = typeList;
                    
                    break;
                }

                case Reductions.GenericArraySingleTypeReduction:
                {
                    String typeName = symbol.Children[0].TokenString;

                    // Get the Type list
                    ValueTypes typeListType;
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[1],
                                                            out typeListType);

                    Type[] types = new Type[typeList.Count];
                    for (int i = 0;i < typeList.Count;i++)
                    {
                        types[i] = (Type)typeList[i];
                    }
                    
                    // Get the specific type from the generic type
                    Type targetType = DDTHelper.SearchType(typeName + "`" + 
                                                  typeList.Count.ToString());
                    
                    if (targetType == null)
                    {
                        throw new DDTException(
                            "Could not find generic type '" + 
                            typeName +
                            "' with " + 
                            typeList.Count.ToString() + " generic type(s)");
                    }
                    
                    // Get the specific type from the generic type
                    targetType = targetType.MakeGenericType(types);
                    
                    // Get the array Dimensions
                    String dimensionStr = symbol.Children[1].TokenString;
                    
                    // Count the number of ',' for the dimensions
                    int numDimensions = DDTHelper.GetDimensions(dimensionStr);
                    
                    // Make the type an array type
                    targetType = targetType.MakeArrayType(numDimensions);

                    // Return the new type list
                    ArrayList outerTypeList = new ArrayList();
                    outerTypeList.Add(targetType);
                     
                    // Return a list with the single type
                    valueType = ValueTypes.TypeList;                    
                    value = outerTypeList;
                    
                    break;                    
                }

                case Reductions.TypeListReduction:
                {
                    // Get the existing type list
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[0],
                                                            out valueType);
                    
                    // Get the new type to be added to the list
                    String typeName = symbol.Children[1].TokenString;
                    Type targetType = SearchType(typeName);
                    
                    if (targetType == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }                    
                    
                    // Return the augmented list
                    typeList.Add(targetType);
                    value = typeList;
                    
                    break;
                }
                
                case Reductions.GenericTypeListReduction:
                {
                    // Get the existing type list
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[0],
                                                            out valueType);
                    
                    // Get the new type name to be added to the list
                    String typeName = symbol.Children[1].TokenString;
                    
                    // Get the generic type list for the new type
                    ValueTypes newTypeListType;
                    ArrayList newTypeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(
                            e,
                            expression,
                            symbol.Children[2],
                            out newTypeListType);

                    Type[] types = new Type[newTypeList.Count];
                    for (int i = 0;i < newTypeList.Count;i++)
                    {
                        types[i] = (Type)newTypeList[i];
                    }
                    
                    // Get the specific type from the generic type
                    Type targetType = DDTHelper.SearchType(
                        typeName + "`" + 
                        newTypeList.Count.ToString());
                    
                    if (targetType == null)
                    {
                        throw new DDTException(
                            "Could not find generic type '" + 
                            typeName +
                            "' with " + 
                            newTypeList.Count.ToString() + " generic type(s)");
                    }
                    
                    // Get the specific type from the generic type
                    targetType = targetType.MakeGenericType(types);
                                        
                    // Return the augmented list
                    typeList.Add(targetType);
                    value = typeList;
                    
                    break;
                }
                
                case Reductions.ArrayTypeListReduction:
                {
                    // Get the existing type list
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[0],
                                                            out valueType);
                    
                    // Get the new type to be added to the list
                    String typeName = symbol.Children[1].TokenString;
                    
                    Type targetType = SearchType(typeName);
                    
                    if (targetType == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }
                    
                    // Get the array dimensions
                    String dimensionStr = symbol.Children[2].TokenString;
                    
                    // Count the number of ',' for the dimensions
                    int numDimensions = DDTHelper.GetDimensions(dimensionStr);
                    
                    // Return the type list with the new type added to it
                    typeList.Add(targetType.MakeArrayType(numDimensions));
                    value = typeList;
                    
                    break;
                }

                // Promise - I won't make it any more complicated
                case Reductions.GenericArrayTypeListReduction:
                {
                    // Get the existing type list
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[0],
                                                            out valueType);
                    
                    // Get the new type name to be added to the list
                    String typeName = symbol.Children[1].TokenString;
                    
                    // Get the generic type list for the new type
                    ValueTypes newTypeListType;
                    ArrayList newTypeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(
                            e,
                            expression,
                            symbol.Children[2],
                            out newTypeListType);

                    Type[] types = new Type[newTypeList.Count];
                    for (int i = 0;i < newTypeList.Count;i++)
                    {
                        types[i] = (Type)newTypeList[i];
                    }
                    
                    // Get the specific type from the generic type
                    Type targetType = DDTHelper.SearchType(
                        typeName + "`" + 
                        newTypeList.Count.ToString());
                    
                    if (targetType == null)
                    {
                        throw new DDTException(
                            "Could not find generic type '" + 
                            typeName +
                            "' with " + 
                            newTypeList.Count.ToString() + " generic type(s)");
                    }
                    
                    // Get the specific type from the generic type
                    targetType = targetType.MakeGenericType(types);
                              
                    // Get the array dimensions
                    String dimensionStr = symbol.Children[3].TokenString;
                    
                    // Count the number of ',' for the dimensions
                    int numDimensions = DDTHelper.GetDimensions(dimensionStr);
          
                    // Get the array type
                    targetType = targetType.MakeArrayType(numDimensions);

                    // Return the augmented list
                    typeList.Add(targetType);
                    value = typeList;
                    
                    break;
                }

                case Reductions.GenericNewReduction:
                {
                    // Get the base type
                    String typeName = symbol.Children[0].TokenString;

                    // Get the generic type specifiers
                    ValueTypes typeListType;
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[1],
                                                            out typeListType);

                    Type[] types = new Type[typeList.Count];
                    for (int i = 0;i < typeList.Count;i++)
                    {
                        types[i] = (Type)typeList[i];
                    }
                    
                    // Get the specific type from the generic type
                    Type t = DDTHelper.SearchType(typeName + "`" + 
                                                  typeList.Count.ToString());
                    
                    if (t == null)
                    {
                        throw new DDTException(
                            "Could not find generic type '" + 
                            typeName +
                            "' with " + 
                            typeList.Count.ToString() + " generic type(s)");
                    }
                    
                    if (!t.IsGenericType)
                    {
                        throw new DDTException("Type : '" + typeName + 
                                               "' is not a generic type");
                    }


                    
                    // Try to get the actual type with the generic types
                    // replaced
                    try
                    {
                        t = t.MakeGenericType(types);
                    }
                    catch (Exception)
                    {
                        String genericSignature =  "{";
                        
                        for (int j = 0;j < types.Length;j++)
                        {
                            genericSignature += types[j].Name;
                            
                            if (j < types.Length - 1)
                            {
                                genericSignature += ", ";
                            }
                        }
                        genericSignature += "}";

                        throw new DDTException(
                            String.Format(
                                "Cannot apply generic types {0} to '{1}'",
                                genericSignature,
                                typeName));
                    }


                    // See if there is a public constructor                    
                    if (t.GetConstructors().Length == 0)
                    {
                        throw new DDTException("No public constructors " +
                                               "found for " + t.Name);
                    }
                    
                    // Get the parameter list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[2],
                                                          out paramsType);
                    
                    // Construct the parameter signature
                    Object[] parameters = new Object[paramsList.Count];
                    Type[] signature = new Type[paramsList.Count];
                    int index = 0;                    
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Value)
                        {
                            parameters[index] = paramsList.ValueList[index];
                            signature[index] = parameters[index].GetType();
                        }
                        else
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            parameters[index] = reference.GetValue();

                            // Marke the parameter as reference type
                            signature[index] = 
                                parameters[index].GetType().MakeByRefType();
                        }

                        index++;
                    }

                    
                    // Find the constructor with the given signature
                    ConstructorInfo cinfo = t.GetConstructor(signature);
                    if (cinfo == null)
                    {
                        String paramTypes =  "(";
                        
                        for (int i = 0;i < signature.Length;i++)
                        {
                            paramTypes += signature[i].Name;
                            
                            if (i < signature.Length - 1)
                            {
                                paramTypes += ", ";
                            }
                        }
                        paramTypes += ")";
                        
                        throw new DDTException(
                            "Cannot not find constructor with signature : " +
                            paramTypes);                        
                    }

                    value = cinfo.Invoke(parameters);
                    valueType = ValueTypes.Value;

                    // Re-assign all parameters passed by reference
                    index = 0;
                    foreach (ValueTypes paramType in paramsList.ModifierList)
                    {
                        if (paramType == ValueTypes.Reference)
                        {
                            IDDTReference reference = 
                                (IDDTReference)paramsList.ValueList[index];

                            // Set the variable the reference points to
                            reference.SetValue(parameters[index]);
                        }
                        
                        index++;
                    }                    

                    break;
                }


                case Reductions.ArrayNewReduction:
                {
                    // Get the base type
                    String typeName = symbol.Children[0].TokenString;
                    Type t = DDTHelper.SearchType(typeName);

                    if (t == null)
                    {
                        throw new DDTException("Unknown type : " + typeName);
                    }

                    // Get the array index list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[1],
                                                          out paramsType);
                    
                    // Reference parameters have no place in array index list
                    if (paramsList.HasReferenceObjects())
                    {
                        throw new DDTException(
                            "Invalid 'ref' specification in " + 
                            "array index list");
                    }

                    // The expression list should be a list of integers
                    // all greater than 0
                    Int64[] indices = new Int64[paramsList.Count];
                    try
                    {                        
                        for (int i = 0;i < paramsList.Count;i++)
                        {
                            indices[i] = 
                                (Int64)Convert.ChangeType(
                                    paramsList.ValueList[i],
                                    typeof(Int64));
                        }
                    }                    
                    catch (Exception)
                    {
                        throw new DDTException(
                            "Invalid array index types specified");
                    }
                    
                    // Try to create an array of the given type
                    try
                    {
                        valueType = ValueTypes.Value;
                        value = Array.CreateInstance(t, indices);
                    }
                    catch (Exception)
                    {
                        throw new DDTException(
                            "Array index list has invalid items");
                    }

                    break;
                }                    


                case Reductions.GenericArrayNewReduction:
                {
                    // Get the base type
                    String typeName = symbol.Children[0].TokenString;

                    // Get the generic types list
                    ValueTypes typeListType;
                    ArrayList typeList = 
                        (ArrayList)DDTHelper.EvalSymbolTree(e,
                                                            expression,
                                                            symbol.Children[1],
                                                            out typeListType);

                    Type[] types = new Type[typeList.Count];
                    for (int i = 0;i < typeList.Count;i++)
                    {
                        types[i] = (Type)typeList[i];
                    }
                    
                    // Get the specific type from the generic type
                    Type t = DDTHelper.SearchType(typeName + "`" + 
                                                  typeList.Count.ToString());
                    
                    if (t == null)
                    {
                        throw new DDTException(
                            "Could not find generic type '" + 
                            typeName +
                            "' with " + 
                            typeList.Count.ToString() + " generic type(s)");
                    }
                    
                    if (!t.IsGenericType)
                    {
                        throw new DDTException("Type : '" + typeName + 
                                               "' is not a generic type");
                    }
                    
                    // Try to get the actual type with the generic types
                    // replaced
                    try
                    {
                        t = t.MakeGenericType(types);
                    }
                    catch (Exception)
                    {
                        String genericSignature =  "{";
                        
                        for (int j = 0;j < types.Length;j++)
                        {
                            genericSignature += types[j].Name;
                            
                            if (j < types.Length - 1)
                            {
                                genericSignature += ", ";
                            }
                        }
                        genericSignature += "}";

                        throw new DDTException(
                            String.Format(
                                "Cannot apply generic types {0} to '{1}'",
                                genericSignature,
                                typeName));
                    }

                    // Get the array index list
                    ValueTypes paramsType;
                    DDTExpressionList paramsList = 
                        (DDTExpressionList)EvalSymbolTree(e, 
                                                          expression,
                                                          symbol.Children[2],
                                                          out paramsType);
                    
                    // Reference parameters have no place in array index list
                    if (paramsList.HasReferenceObjects())
                    {
                        throw new DDTException(
                            "Invalid 'ref' specification in " + 
                            "array index list");
                    }

                    // The expression list should be a list of integers
                    // all greater than 0
                    Int64[] indices = new Int64[paramsList.Count];
                    try
                    {                        
                        for (int i = 0;i < paramsList.Count;i++)
                        {
                            indices[i] = 
                                (Int64)Convert.ChangeType(
                                    paramsList.ValueList[i],
                                    typeof(Int64));
                        }
                    }                    
                    catch (Exception)
                    {
                        throw new DDTException(
                            "Invalid array index types specified");
                    }
                    
                    // Try to create an array of the given type
                    try
                    {
                        valueType = ValueTypes.Value;
                        value = Array.CreateInstance(t, indices);
                    }
                    catch (Exception)
                    {
                        throw new DDTException(
                            "Array index list has invalid items");
                    }

                    break;
                }


                default:
                    throw new 
                        DDTException("Internal Error : Unknown reduction : '" +
                                     symbol.ReductionId + "'");
                }
            }

            // Return the expression value
            return value;                
        }

        // Evaluate an expression
        public static Object EvalExpression(DDTEnvironment e,
                                            String expression)
        {
            Object valueObject = null;
            String errorMsg = String.Empty;

            // Get the parse tree using the OOPC parser
            Symbol s = null;
            try
            {
                s = DDTExpressionParser.Parse(expression);
            }
            catch (DDTException d)
            {
                errorMsg = d.Message;
            }
            
            // Evaluate the parse tree if it's valid
            if ((errorMsg != String.Empty) || 
                (s == null))
            {
                // See if we can fallback to a string
                Match m = Regex.Match(expression, 
                                      @"^[a-zA-Z_0-9\.,\s\t\r\n\-\\\:]*$");

                if (m.Success)
                {
                    // Fallback to a string. No Error here
                    // Also handle string escape sequences
                    valueObject = DDTHelper.StringEscape(expression);
                    errorMsg = String.Empty;
                }
                else
                {
                    if (errorMsg == String.Empty)
                    {
                        errorMsg = "Invalid expression : '" + 
                            expression + "'";
                    }
                }
            }
            else if ((s.IsNonTerminal) && 
                     (s.NonTerminal == NonTerminals.Expression))
            {
                ValueTypes valueType;                            
                valueObject = EvalSymbolTree(e, 
                                             expression, 
                                             s, 
                                             out valueType);
                
                // Dereference if its a reference type and get the value
                DDTHelper.Dereference(ref valueType, ref valueObject);

                if (valueType != ValueTypes.Value)
                {
                    errorMsg = "'" + expression + "' does not evaluate " +
                        "to an object value";
                }
            }
            else
            {
                errorMsg = "Invalid expression : " + expression;
            }

            // Could not parse expression or fallback to a simple string
            if (errorMsg != String.Empty)
            {
                throw new DDTException(errorMsg);
            }
            
            return valueObject;
        }

        // Try our best to convert source to targetType
        public static Object CoerceType(Object source, Type targetType)
        {            
            if (targetType == typeof(Object))
            {
                return source;
            }
            else if (source.GetType() == typeof(string))
            {
                return DeserializeType(targetType, (String)source);
            }
            else
            {
                Object value = null;
                if ((source.GetType() == targetType) || 
                    (source.GetType().IsSubclassOf(targetType)))
                {
                    value = source;
                }
                else
                {
                    try
                    {
                        if (targetType.IsEnum)
                        {
                            value = Enum.Parse(targetType, source.ToString());
                        }
                        else if (source.GetType().GetInterface("IConvertible") 
                                 != null)
                        {
                            value = Convert.ChangeType(source, targetType);
                        }   
                    }
                    catch (Exception)
                    {                        
                    }
                }
                
                return value;
            }
        }


        /// <summary>
        /// Convert a  string to the value of the given type
        /// </summary>
        public static Object DeserializeType(Type type, 
                                             String s)
        {
            object value = null;

            try
            {
                if (type.IsEnum)
                {
                    value = Enum.Parse(type, s);
                }
                else if (type.IsValueType)
                {
                    value = Convert.ChangeType(s, type);
                }
                else if (type == typeof(string))
                {
                    value = s;
                }
            }
            catch (Exception)
            { 
            }

            return value;
        }

        // Search for typename in all loaded assemblies
        public static Type SearchType(String typeName)
        {
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            String[] typeParts = typeName.Split(new char[]{'.'});

            // Handle aliases to System types here
            switch (typeName)
            {

            case "byte":
                return typeof(byte);

            case "sbyte":
                return typeof(sbyte);

            case "ushort":
                return typeof(ushort);

            case "short":
                return typeof(short);

            case "uint":
                return typeof(uint);
                
            case "int":
                return typeof(int);

            case "ulong":
                return typeof(ulong);
                
            case "long":
                return typeof(long);

            case "char":
                return typeof(char);

            case "string":
                return typeof(string);

            case "bool":
                return typeof(bool);

            case "float":
                return typeof(float);

            case "double":
                return typeof(double);                

            case "decimal":
                return typeof(decimal);                
            }

            foreach (Assembly assembly in assemblies)
            {
                // Do a match with the short name
                Type[] types = assembly.GetTypes();                
                foreach (Type t in types)
                {
                    // Search for the type in the type parts
                    for (int i = 0;i < typeParts.Length;i++)
                    {
                        if (t.Name == typeParts[i])
                        {
                            if (typeParts.Length == 1)
                            {
                                // Just a simple name match
                                // Return the type
                                return t;
                            }
                            
                            // Else match everything before the match
                            // with the name space and everything afterwards
                            // with the nested types
                            if (i > 0)
                            {
                                // Match namespace only if the match is not
                                // the first part
                                String nameSpace = typeParts[0];

                                for (int j = 1;j < i;j++)
                                {
                                    nameSpace += "." + typeParts[j];
                                }

                                if (t.Namespace != nameSpace)
                                {
                                    // Namespace didn't match
                                    continue;
                                }
                            }                            

                            if (i == typeParts.Length - 1)
                            {
                                // No nested types specified
                                return t;
                            }

                            // Match nested type names if any
                            Type nestedType = t;
                            bool found = false;
                            for (int k = i+1;k < typeParts.Length;k++)
                            {
                                Type[] nestedTypes = 
                                    nestedType.GetNestedTypes();
                                
                                // Search for nested type by short names
                                foreach (Type nt in nestedTypes)
                                {
                                    if (nt.Name == typeParts[k])
                                    {
                                        nestedType = nt;
                                        found = true;
                                        break;
                                    }
                                }
                                
                                if (!found)
                                {
                                    nestedType = null;
                                    break;
                                }
                            }

                            if (found)
                            {
                                return nestedType;                            
                            }
                        }
                    }
                }
            }

            // Type not found
            return null;
        }


        // Flatten a nested list into a flat list
        public static ArrayList Flatten(IEnumerable e)
        {
            ArrayList f = new ArrayList();
            
            foreach (Object o in e)
            {
                if (o == null)
                {
                    continue;
                }

                // Recursively flatten
                if (o.GetType().GetInterface("IEnumerable") != null)
                {
                    ArrayList subList = Flatten((IEnumerable)o);
                    f.AddRange(subList);
                }
                else
                {
                    f.Add(o);
                }
            }
            
            return f;
        }

        // Compare two objects using the given operator
        public static bool CompareObjects(Object lhs,
                                          String opStr,
                                          Object rhs)
        {            
            bool passed = false;

            if ((lhs == null) || (rhs == null))
            {
                if ((lhs != null) && (lhs.GetType().IsValueType))
                {
                    throw new DDTException(
                        String.Format(
                            "LHS of operator '{0}' " + 
                            "is a value type({1}) and can't "+
                            "be compared to a null value", 
                            opStr,
                            lhs.GetType().Name));
                }
                
                if ((rhs != null) && (rhs.GetType().IsValueType))
                {
                    throw new DDTException(
                        String.Format(
                            "RHS of operator '{0}' " + 
                            "is a value type({1}) and can't "+
                            "be compared to a null value", 
                            opStr,
                            rhs.GetType().Name));
                }

                switch (opStr)
                {
                case "==" : 
                    passed = (lhs == rhs);
                    break;
                    
                case "!=":
                    passed = (lhs != rhs);
                    break;
                    
                default:
                    if (lhs == null)
                    {
                        throw new DDTException
                            ("LHS of '" + opStr + "' evaluates to null");
                    }
                    else
                    {
                        throw new DDTException
                            ("RHS of '" + opStr + "' evaluates to null");
                    }                        
                }

                return passed;
            }

            // Both LHS and RHS are non-null
            if (lhs.GetType() != rhs.GetType())
            {
                // If they are numbers promote LHS or RHS and then compare
                if ((DDTHelper.IsNumber(lhs.GetType())) && 
                    (DDTHelper.IsNumber(rhs.GetType())))
                {
                    PromoteNumbers(lhs, rhs, out lhs, out rhs);
                }
                else
                {
                    throw new DDTException(
                        String.Format(
                            "LHS({0}) and RHS({1}) are of " +
                            "different types", 
                            lhs.GetType(), 
                            rhs.GetType()));
                }
            }
            
            Type t = lhs.GetType();
            int result = 0;
            
            try
            {
                result = ((IComparable)lhs).CompareTo(rhs);
            }
            catch (Exception)
            {
                throw new DDTException(
                    "Cannot compare LHS and RHS " +
                    "of type '" + lhs.GetType() + "' using operator '" + 
                    opStr + "'");
            }
            
            // See if we pass the test
            switch (opStr)
            {
            case "==" :
                passed = (result == 0);
                break;
                
            case "!=" :
                passed = (result != 0);
                break;
                
            case "gt" :
                passed = (result > 0);
                break;
                
            case "gt=" :
                passed = (result >= 0);
                break;
                
            case "lt" :
                passed = (result < 0);
                break;
                
            case "lt=" :
                passed = (result <= 0);
                break;
                
            default:
                throw new Exception("Unknown operator : '" +
                                    opStr + "'");
            }
                
            return passed;
        }

        
        // General Xml helper methods
        public static void AddXmlAttribute(XmlDocument doc,
                                           XmlNode node,
                                           String name,
                                           String value)
        {
            XmlAttribute attribute = doc.CreateAttribute(name);
            attribute.Value = value;
            node.Attributes.Append(attribute);        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTXmlElement.cs ===
using System;
using System.Xml;

namespace DDT
{
    /// <summary>
    /// Extension to XmlElement to support line info for nodes
    /// </summary>    
    public class DDTXmlElement : XmlElement, IXmlLineInfo   
    {
        private int lineNumber;
        private int linePosition;

        public DDTXmlElement(string prefix, string localName,
                             string namespaceURI, XmlDocument doc)
            : this(prefix, localName, namespaceURI, doc, 0, 0)
        {
        }

        public DDTXmlElement(string prefix, string localName,
                             string namespaceURI, XmlDocument doc,
                             int lineNumber, int linePosition)
            : base(prefix, localName, namespaceURI, doc)
        {
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }

        // Recursively Clone the line info for all children
        public void CloneLineInfo(DDTXmlElement origNode)
        {
            lineNumber = origNode.lineNumber;
            linePosition = origNode.linePosition;

            // Clone line info for all attributes
            int attribIndex = 0;
            foreach (DDTXmlAttribute attrib in this.Attributes)
            {
                DDTXmlAttribute origAttrib = 
                    (DDTXmlAttribute)origNode.Attributes[attribIndex++];

                attrib.CloneLineInfo(origAttrib);
            }

            // Clone line info for children
            int childIndex = 0;
            foreach (XmlNode child in this.ChildNodes)
            {
                XmlNode origChild = origNode.ChildNodes[childIndex++];

                if (child is DDTXmlElement)
                {
                    DDTXmlElement ddtChild = (DDTXmlElement)child;
                    DDTXmlElement ddtOrigChild = (DDTXmlElement)origChild;

                    ddtChild.CloneLineInfo(ddtOrigChild);                    
                }
                else if (child is DDTXmlText)
                {
                    DDTXmlText textChild = (DDTXmlText)child;
                    textChild.CloneLineInfo((DDTXmlText)origChild);
                }
            }
        }
        

        public override XmlNode Clone()
        {
            DDTXmlElement node = (DDTXmlElement)base.Clone();
            node.CloneLineInfo(this);

            return node;
        }

        public bool HasLineInfo()
        {
            return true;
        }
        
        public int LineNumber
        {
            get
            {
                return lineNumber;
            }
        }

        public int LinePosition
        {
            get
            {
                return linePosition;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTXmlAttribute.cs ===
using System;
using System.Xml;

namespace DDT
{
    /// <summary>
    /// Extension to XmlAttribute to support line info for nodes
    /// </summary>    
    public class DDTXmlAttribute : XmlAttribute, IXmlLineInfo   
    {
        private int lineNumber;
        private int linePosition;

        public DDTXmlAttribute(string prefix, string localName,
                               string namespaceURI, XmlDocument doc)
            : this(prefix, localName, namespaceURI, doc, 0, 0)
        {
        }

        public DDTXmlAttribute(string prefix, string localName,
                               string namespaceURI, XmlDocument doc,
                               int lineNumber, int linePosition)
            : base(prefix, localName, namespaceURI, doc)
        {
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }

        // Clone the line info from original node
        public void CloneLineInfo(DDTXmlAttribute origNode)
        {
            lineNumber = origNode.lineNumber;
            linePosition = origNode.linePosition;
        }
        

        public override XmlNode Clone()
        {
            DDTXmlAttribute node = (DDTXmlAttribute)base.Clone();
            node.CloneLineInfo(this);

            return node;
        }

        public bool HasLineInfo()
        {
            return true;
        }
        
        public int LineNumber
        {
            get
            {
                return lineNumber;
            }
        }

        public int LinePosition
        {
            get
            {
                return linePosition;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTTestCaseActionCollection.cs ===
using System;
using System.Xml;
using System.Collections;

namespace DDT
{
    [DDTDoc("DDT Action Collection to manage DDT Test cases")]
    public class DDTTestCaseActionCollection : DDTActionCollection
    {
        [DDTAction]
        [DDTDoc("Defines a test suite with test cases within it")]
        public class TestSuite : DDTXmlAction
        {
            [DDTParam(Required = true)]
            [DDTDoc("Name of the TestSuite")]
            public String Name = String.Empty;

            private DDTEnvironment e = null;
            private DDTTestSuite testSuite = null;
            private int index = 0;

            public override Object Invoke(DDTEnvironment e)
            {    
                testSuite = new DDTTestSuite(e);            
                testSuite.Name = Name;
                
                this.e = e;
                return RunContinuation(null);
            }

            
            public Object RunContinuation(Object state)
            {
                bool inContinuation = (state != null);

                DDTContinuationContext context =
                    DDTContinuation.PushContinuation(
                        new DDTContinuationCallback(this.RunContinuation),
                        e);
                
                // The guard takes care of popping the continuation
                // context when we are done with the operations
                using (DDTContinuationContextGuard guard = 
                       new DDTContinuationContextGuard(context))
                {                

                    // Execute the sub-actions
                    // And add the test cases to the Test suite
                    for (int i = index;i < this.SubActionNodes.Count;i++)
                    {
                        XmlNode subAction = (XmlNode)this.SubActionNodes[i];
                        
                        Object o = null;
                        if (inContinuation)
                        {
                            inContinuation = false;
                            o = DDTContinuation.EndContinuation();
                        }
                        else
                        {
                            o = e.ExecuteAction(subAction);
                        }
                        
                        index++;
                        
                        if (o == null)
                        {
                            continue;
                        }
                        
                        // Add the result to the TestSuite if it's a valid
                        // test case
                        if (o.GetType().GetInterface("IEnumerable") != null)
                        {
                            ArrayList flattenedList = 
                                DDTHelper.Flatten((IEnumerable)o);
                            
                            foreach (Object element in flattenedList)
                            {
                                if (element == null)
                                {
                                    continue;
                                }
                                
                                if (element.GetType() == 
                                    typeof(DDTTestCaseInfo))
                                {
                                    testSuite.TestCases.Add(
                                        (DDTTestCaseInfo)element);
                                }
                            }
                        }
                        else if (o.GetType() == typeof(DDTTestCaseInfo))
                        {
                            testSuite.TestCases.Add((DDTTestCaseInfo)o);
                        }
                    }
                }

                return testSuite;
            }
        }

        [DDTAction]
        [DDTDoc("Defines a test case with set of actions within it")]
        public class TestCase : DDTXmlAction
        {
            [DDTParam(Required = true)]
            [DDTDoc("Name of the TestCase")]
            public String Name = String.Empty;

            [DDTParam]
            [DDTDoc("Whether to ignore this test case")]
            public bool Ignore = false;

            public override Object Invoke(DDTEnvironment e)
            {    
                DDTTestCaseInfo testCaseInfo = new DDTTestCaseInfo();
                testCaseInfo.Name = Name;
                testCaseInfo.Ignore = Ignore;

                // Save the child nodes for later execution
                foreach (XmlNode subAction in this.SubActionNodes)
                {
                    testCaseInfo.AddActionNode(subAction);
                }
                
                return testCaseInfo;
            }
        }

        [DDTAction]
        [DDTDoc("OBSOLETE!! Don't use!!!")]
        public class CompoundTestCase : DDTXmlAction
        {
            [DDTParam(Required = true)]
            [DDTDoc("Base name of the Compound TestCase")]
            public String Name = String.Empty;
            
            [DDTParam(Required = true)]
            [DDTDoc("Setup action name")]
            public String Setup = String.Empty;

            [DDTParam(Required = true)]
            [DDTDoc("Parameter to setup action")]
            public String Param = String.Empty;

            [DDTParam(Required = true)]
            [DDTDoc("Parameter value list to setup parameter")]
            public String Values = String.Empty;
            
            [DDTParam]
            [DDTDoc("Whether to ignore this test case")]
            public bool Ignore = false;
            
            public override Object Invoke(DDTEnvironment e)
            {    
                ArrayList testCases = new ArrayList(); // return value
                String[] setupParamValues = null;
                
                setupParamValues = Values.Split(new char[] {','});
                        
                // Get the individual actions from the child nodes
                ArrayList testActionsXml = new ArrayList();
                foreach (XmlNode subAction in this.SubActionNodes)
                {
                    testActionsXml.Add(subAction);
                }
                
                // Create multiple test cases, calling the setup action
                // with different param values each time, followed by the
                // regular test actions
                foreach (String setupParamValue in setupParamValues)
                {
                    String testCaseName = 
                        Name + "_" + setupParamValue;
                    
                    DDTTestCaseInfo testCase = new DDTTestCaseInfo();
                    testCase.Name = testCaseName;
                    testCase.Ignore = Ignore;
                
                    // Add the setup action XML node
                    String setupActionXml = 
                        "<" + Setup + " " +
                        Param + "=\"" +  setupParamValue + "\"/>";
                    
                    XmlDocument xmlDoc = new DDTXmlDocument();
                    xmlDoc.LoadXml(setupActionXml);

                    testCase.AddActionNode(xmlDoc.FirstChild);
                    
                    // Add the regaular test actions
                    foreach (XmlNode testActionXml in testActionsXml)
                    {
                        testCase.AddActionNode(testActionXml);
                    }
                    
                    // Add the test case to the test case list
                    testCases.Add(testCase);
                }
                
                // Return the list of test cases
                return testCases;
            }

        }
        
    } // class DDTTestCaseActionCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTXmlDocument.cs ===
using System;
using System.Xml;

namespace DDT
{
    /// <summary>
    /// Extension to XmlDocument to support line number info for nodes
    /// </summary>    
    public class DDTXmlDocument : XmlDocument
    {
        IXmlLineInfo lineInfo = null;

        public DDTXmlDocument() : base() {}

        public override XmlElement CreateElement(string prefix,
                                                 string localName,
                                                 string namespaceURI)
        {
            return (lineInfo != null) ?
                new DDTXmlElement(prefix, localName, namespaceURI, this,
                                  lineInfo.LineNumber, 
                                  lineInfo.LinePosition) : 
                new DDTXmlElement(prefix, localName, namespaceURI, this);
        }

        public override XmlText CreateTextNode(string text)
        {
            return (lineInfo != null) ?
                new DDTXmlText(text,
                               this,
                               lineInfo.LineNumber, 
                               lineInfo.LinePosition) : 
                new DDTXmlText(text, this);
        }

        public override XmlAttribute CreateAttribute(string prefix,
                                                     string localName,
                                                     string namespaceURI)
        {
            return (lineInfo != null) ?
                new DDTXmlAttribute(prefix, localName, namespaceURI, this,
                                    lineInfo.LineNumber, 
                                    lineInfo.LinePosition) : 
                new DDTXmlAttribute(prefix, localName, namespaceURI, this);
        }

        public override void Load(XmlReader reader)
        {
            if (reader is IXmlLineInfo)
            {
                lineInfo = (IXmlLineInfo)reader;
            }
            
            base.Load(reader);

            lineInfo = null;
        }            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTXmlMacro.cs ===
using System;
using System.Xml;

namespace DDT
{
    /// <summary>
    /// Use DDTXmlMacro to get the raw XML of the action
    //  The action can also change the execution environment 
    /// </summary>
    public abstract class DDTXmlMacro : DDTEnvironmentAction
    {
        public XmlNode MacroNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\IDDTCrossFilter.cs ===
using System;
using System.Collections;

namespace DDT
{
    public interface IDDTCrossFilter
    {
        bool Allow(ArrayList values);
        bool Done
        {
            get;
        }
        
        void Reset();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\IDDTLogger.cs ===
using System;

namespace DDT
{
    public enum DDTLogLevel
    {
        Error = 0,
        Warn = 1,
        Info = 2,
        Log  = 3
    }

    public interface IDDTLogger
    {
        void Log(string format, params Object[] args);
        void Info(string format, params Object[] args);
        void Warn(string format, params Object[] args);
        void Error(string format, params Object[] args);
        DDTLogLevel GetLogLevel();
        void SetLogLevel(DDTLogLevel l);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTXmlText.cs ===
using System;
using System.Xml;

namespace DDT
{
    /// <summary>
    /// Extension to XmlText to support line info for nodes
    /// </summary>    
    public class DDTXmlText : XmlText, IXmlLineInfo   
    {
        private int lineNumber;
        private int linePosition;

        public DDTXmlText(string strData, XmlDocument doc)
            : this(strData, doc, 0, 0)
        {
        }

        public DDTXmlText(string strData,
                          XmlDocument doc,
                          int lineNumber, int linePosition)
            : base(strData, doc)
        {
            this.lineNumber = lineNumber;
            this.linePosition = linePosition;
        }

        public void CloneLineInfo(DDTXmlText origNode)
        {
            lineNumber = origNode.lineNumber;
            linePosition = origNode.linePosition;
        }

        public override XmlNode Clone()
        {
            DDTXmlText node = (DDTXmlText)base.Clone();
            node.CloneLineInfo(this);
            
            return node;
        }

        public bool HasLineInfo()
        {
            return true;
        }
        
        public int LineNumber
        {
            get
            {
                return lineNumber;
            }
        }

        public int LinePosition
        {
            get
            {
                return linePosition;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\IDDTReference.cs ===
using System;

namespace DDT
{
    // Represents a reference to a value
    // So that the actual value can be changed using the reference
    // Used in assignment or passing parameter by reference
    public interface IDDTReference
    {
        Object GetValue();
        void SetValue(Object val);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\IToken.cs ===
//-----------------------------------------------------------------------
// <copyright file="IToken.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------


namespace Oopc.Generated
{
    /// <summary>
    /// Interface to a class representing a token. Used by the tokenizer.
    /// </summary>
    /// <typeparam name="TTokenEnum">Token enumeration.</typeparam>
    public interface IToken
    {
        void SetToken(Tokens token_type, string token_string, TextLocation text_location);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\DDTExpressionParser.cs ===
using System;
using System.IO;
using System.Collections.Generic;

using DDT;

namespace Oopc.Generated
{
    public class DDTExpressionParser
    {
        private static Pattern[] patternList = new Pattern[]
        {
            // Patterns ignored by the tokenizer
            new Pattern(Tokens.Whitespace, 
                                @"(\s+|\t+|\r+)", 
                                false, // stringCompare
                                true), // ignoreToken

            // Reserved words - Should be before Identifier
            // Since both of them match the same pattern
            // The 'true' value indicated we just need a string compare
            // and not a full blown RegEx match
            new Pattern(Tokens.Null, @"null", true),
            new Pattern(Tokens.New, @"new", true),
            new Pattern(Tokens.Ref, @"ref", true),
            new Pattern(Tokens.Not, @"!", true),
            new Pattern(Tokens.And, @"and", true),
            new Pattern(Tokens.Or, @"or", true),

            // Comparison operators should be before Identifier
            new Pattern(Tokens.Equal, @"==", true),
            new Pattern(Tokens.NotEqual, @"!=", true),
            new Pattern(Tokens.Lesser, @"lt", true),
            new Pattern(Tokens.Greater, @"gt", true),
            new Pattern(Tokens.LesserOrEqual, @"lt=", true),
            new Pattern(Tokens.GreaterOrEqual, @"gt=", true),

            // Bit level operators should be before Identifier
            new Pattern(Tokens.LShift, @"ll", true),
            new Pattern(Tokens.RShift, @"rr", true),

            new Pattern(Tokens.LogicalNot, @"~", true),
            new Pattern(Tokens.LogicalAnd, @"^and", true),
            new Pattern(Tokens.LogicalOr, @"^or", true),
            new Pattern(Tokens.LogicalXor, @"^xor", true),
            
            
            new Pattern(Tokens.Character, @"#."),
            new Pattern(Tokens.String, @"'(\\.|[^'])*'"),
            new Pattern(Tokens.Boolean, @"(true|false)"),
            new Pattern(Tokens.Integer, @"[+-]?[0-9]+"),
            new Pattern(Tokens.Hexadecimal, @"0x[0-9a-fA-F]+"),
            new Pattern(Tokens.Float, @"[+-]?[0-9]*[.][0-9]+"),
            new Pattern(Tokens.Identifier, 
                                @"[a-zA-Z_][a-zA-Z_0-9\.]*"),

            new Pattern(Tokens.Dollar, @"$", true),
            new Pattern(Tokens.LParan, @"(", true),
            new Pattern(Tokens.RParan, @")", true),
            new Pattern(Tokens.LSqr, @"[", true),
            new Pattern(Tokens.RSqr, @"]", true),
            new Pattern(Tokens.LCurly, @"{", true),
            new Pattern(Tokens.RCurly, @"}", true),
            new Pattern(Tokens.Comma, @",", true),
            new Pattern(Tokens.Dot, @".", true),
            new Pattern(Tokens.DotDot, @"..", true),

            new Pattern(Tokens.Plus, @"+", true),
            new Pattern(Tokens.Minus, @"-", true),
            new Pattern(Tokens.Mult, @"*", true),
            new Pattern(Tokens.Div, @"/", true),
            new Pattern(Tokens.Mod, @"%", true),

            new Pattern(Tokens.Assignment, @"=", true),
            new Pattern(Tokens.PlusAssignment, @"+=", true),
            new Pattern(Tokens.MinusAssignment, @"-=", true),
            new Pattern(Tokens.MultAssignment, @"*=", true),
            new Pattern(Tokens.DivAssignment, @"/=", true),
            new Pattern(Tokens.ModAssignment, @"%=", true),

            new Pattern(Tokens.LShiftAssignment, @"ll=", true),
            new Pattern(Tokens.RShiftAssignment, @"rr=", true),
            new Pattern(Tokens.AndAssignment, @"^and=", true),
            new Pattern(Tokens.OrAssignment, @"^or=", true),
            new Pattern(Tokens.XorAssignment, @"^xor=", true),

            new Pattern(Tokens.PlusPlus, @"++", true),
            new Pattern(Tokens.MinusMinus, @"--", true),

            new Pattern(Tokens.ArrayDimensions, @"\[[,\s\t\r\n]*\]"),

            new Pattern(Tokens.ColonColon, @"::", true)
        };
        
        private static void OnBadInputEncountered(String s)
        {
            throw new DDTException("Unexpected token at '" + s + "'");
        }

        public static Symbol Parse(String expression)
        {
            Tokenizer tokenizer = new Tokenizer(patternList, 
                                                new StringReader(expression));
            
            tokenizer.BadInputEncountered += 
                new Action<string>(OnBadInputEncountered);
            
            ShiftReduceParser parser = 
                new ShiftReduceParser(new ParserActionTable());
            
            Symbol root = parser.Parse(tokenizer);
            
            return root;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\ITokenizer.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="ITokenizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    /// <summary>
    /// Minimal interface to a tokenizer, called by the parser.
    /// </summary>
    /// <typeparam name="TTerminal">Terminal symbol (token) type.</typeparam>
    public interface ITokenizer
    {
        /// <summary>
        /// Gets the next terminal (token) from the input stream.
        /// </summary>
        /// <returns>Next token from the input stream, which will be the zero token to
        /// indicate EOF, or null if an error is encountered.</returns>
        Symbol NextToken();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\Pattern.cs ===
//-----------------------------------------------------------------------
// <copyright file="Pattern.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;
    using System.Text.RegularExpressions;
    
    /// <summary>
    /// A pattern to be matched by the tokenizer
    /// </summary>
    /// <typeparam name="TokenEnum">Type of the token enumeration.</typeparam>
    public class Pattern
    {
        private readonly Tokens tokenType;
        private readonly Regex regEx;
        private readonly bool ignoreToken;

        public readonly bool IsStringCompare;
        public readonly String StringPattern;

        /// <summary>
        /// Construct a pattern.
        /// </summary>
        /// <param name="token">Token type this pattern matches.</param>
        /// <param name="pattern">Regular expression string matching this token.</param>
        public Pattern(Tokens token, string pattern)
        {
            tokenType = token;
            regEx = new Regex("^" + pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant);
            ignoreToken = false;
            IsStringCompare = false;
        }

        /// <summary>
        /// Construct a pattern.
        /// </summary>
        /// <param name="token">Token type this pattern matches.</param>
        /// <param name="pattern">Regular expression string matching this token.</param>
        /// <param name="ignored">Whether this pattern should be discarded by the tokenizer (e.g. whitespace).</param>
        public Pattern(Tokens token, string pattern, bool stringCompare)
        {
            tokenType = token;
            this.IsStringCompare = stringCompare;

            if (stringCompare)
            {
                StringPattern = pattern;
            }
            else
            {
                regEx = new Regex("^" + pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant);
            }

            ignoreToken = false;
        }

        public Pattern(Tokens token, string pattern, bool stringCompare, bool ignored)
        {
            tokenType = token;
            this.IsStringCompare = stringCompare;

            if (stringCompare)
            {
                StringPattern = pattern;
            }
            else
            {
                regEx = new Regex("^" + pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant);
            }
           
            ignoreToken = ignored;
        }

        /// <summary>
        /// Match the start of an input with the current pattern
        /// </summary>        
        public String Match(String input)
        {
            if (IsStringCompare)
            {
                if (input.StartsWith(StringPattern))
                {
                    return StringPattern;
                }
                else
                {
                    return null;
                }
            }
            else
            {
                Match match = regEx.Match(input);

                if (match.Success)
                {
                    return match.Value;
                }
                else
                {
                    return null;
                }
            }
        }
            

        /// <summary>
        /// Gets the token this pattern matches.
        /// </summary>
        public Tokens Token
        {
            get { return tokenType; }
        }

        /// <summary>
        /// Gets a value indicating whether to ignore matches of this pattern (e.g. whitespace)
        /// </summary>
        public bool IsIgnored
        {
            get { return ignoreToken; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\IParserActionTable.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="IParserActionTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;
    using System.Collections.Generic;
    
    /// <summary>
    /// Interface to a parser action table
    /// </summary>
    /// <typeparam name="TTokenEnum">Value type holding the possible kinds of token, typically an enum.</typeparam>
    /// <typeparam name="TNonTermEnum">Value type holding the possible kinds of non-terminal, typically an enum.</typeparam>
    /// <typeparam name="TReductionEnum">Value type holding the possible reduction ids, typically an enum.</typeparam>
    public interface IParserActionTable<TTokenEnum, TNonTermEnum, TReductionEnum>
        where TTokenEnum : struct
        where TNonTermEnum : struct
        where TReductionEnum : struct
    {
        /// <summary>
        /// Gets the next action for the parser to perform
        /// </summary>
        /// <param name="current_state">Current state on top of the stack</param>
        /// <param name="input_token">Current input token</param>
        /// <returns>Action to perform</returns>
        ParserAction GetAction(int current_state, TTokenEnum input_token);

        /// <summary>
        /// Gets a reduction rule specified by number
        /// </summary>
        /// <param name="reduction_rule">Reduction rule to retrieve</param>
        /// <returns>Reduction rule</returns>
        ReductionRule<TNonTermEnum, TReductionEnum> GetReductionRule(int reduction_rule);

        /// <summary>
        /// Get which state to goto next following a reduction
        /// </summary>
        /// <param name="state">State currently on the top of the stack (following reduction)</param>
        /// <param name="non_terminal">The non-terminal produced by the reduction</param>
        /// <returns>New state to push on the stack</returns>
        int GetGoto(int state, TNonTermEnum non_terminal);

        /// <summary>
        /// Gets the initial state to start in.
        /// </summary>
        int InitialState { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\ParserActions.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="ParserActions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    /// <summary>
    /// Possible parser actions
    /// </summary>
    public enum ParserActions
    {
        /// <summary>
        /// Syntax error
        /// </summary>
        Error = 0,

        /// <summary>
        /// Shift the next symbol onto the stack
        /// </summary>
        Shift,

        /// <summary>
        /// Reduce via a reduction rule
        /// </summary>
        Reduce,

        /// <summary>
        /// Accept the input, stop parsing
        /// </summary>
        Accept
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\ParserAction.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="ParserAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;

    /// <summary>
    /// Represents an action of the parser (retreived from an IParserActionTable)
    /// </summary>
    public struct ParserAction
    {
        private readonly ParserActions action;
        private readonly int nextState;
        private readonly int reductionRule;

        /// <summary>
        /// Construct a parser action
        /// </summary>
        /// <param name="parser_action">The parser action</param>
        /// <param name="next_state">Next state for the parser</param>
        /// <param name="reduction_rule">Reduction rule to apply (in case of reduction)</param>
        public ParserAction(ParserActions parser_action, int next_state, int reduction_rule)
        {
            action = parser_action;
            nextState = next_state;
            reductionRule = reduction_rule;
        }

        /// <summary>
        /// Gets the action to perform
        /// </summary>
        public ParserActions Action
        {
            get { return action; }
        }

        /// <summary>
        /// Gets the next state number to enqueue
        /// </summary>
        public int NextState
        {
            get { return nextState; }
        }

        /// <summary>
        /// Gets the reduction rule number to apply
        /// </summary>
        public int ReductionRule
        {
            get { return reductionRule; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\ShiftReduceParser.cs ===
//-----------------------------------------------------------------------
// <copyright file="ShiftReduceParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// A shift-reduce parser
    /// </summary>
    public class ShiftReduceParser
    {
        private readonly IParserActionTable<Tokens, NonTerminals, Reductions> actionTable;
        private Stack<StackElement> parserStack;
        private Symbol currentToken;
 
        /// <summary>
        /// Construct a ShiftReduceParser
        /// </summary>
        /// <param name="action_table">Action table for this parser</param>
        public ShiftReduceParser(IParserActionTable<Tokens, NonTerminals, Reductions> action_table)
        {
            actionTable = action_table;
        }

        /// <summary>
        /// Gets the parser action table
        /// </summary>
        public IParserActionTable<Tokens, NonTerminals, Reductions> ActionTable
        {
            get { return actionTable; }
        }

        /// <summary>
        /// Gets the current token being considered by the parser
        /// </summary>
        public Symbol CurrentToken
        {
            get { return currentToken; }
        }

        /// <summary>
        /// Parse input token stream.
        /// If a syntax error is encountered, parsing aborts immediately and a null
        /// parse tree will be returned.
        /// </summary>
        /// <param name="tokenizer">Input token stream.</param>
        /// <returns>Root symbol of parse tree, or null if parsing failed.</returns>
        public Symbol Parse(ITokenizer tokenizer)
        {
            if (tokenizer == null)
            {
                throw new ArgumentNullException("tokenizer");
            }

            // Clear parser stack, push on start state, and grab the current (first) token of input
            parserStack = new Stack<StackElement>();
            parserStack.Push(new StackElement(null, this.actionTable.InitialState));
            currentToken = tokenizer.NextToken();

            // If the tokenizer encountered an error, also abort parsing
            if (currentToken == null)
            {
                return null;
            }

            // Main loop
            while (true)
            {
                ParserAction action = actionTable.GetAction(parserStack.Peek().State, currentToken.Token);
                switch (action.Action)
                {
                    case ParserActions.Accept:
                        return parserStack.Peek().Symbol;

                    case ParserActions.Error:
                        return null;

                    case ParserActions.Shift:
                        parserStack.Push(new StackElement(currentToken, action.NextState));
                        currentToken = tokenizer.NextToken();
                        if (currentToken == null)
                        {
                            return null;
                        }

                        break;

                    case ParserActions.Reduce:
                        Reduce(action);
                        break;
                }
            }
        }

        /// <summary>
        /// Reduce the stack by the given parser action, transition to appropriate new state
        /// </summary>
        /// <param name="action">Reduction action to apply</param>
        private void Reduce(ParserAction action)
        {
            ReductionRule<NonTerminals, Reductions> rule = actionTable.GetReductionRule(action.ReductionRule);

            Symbol non_terminal = new Symbol();
            non_terminal.SetNonTerminal(rule.NonTerminal, rule.ReductionId);

            List<Symbol> match_list = new List<Symbol>(rule.SymbolCount);
            for (int i = 0; i < rule.SymbolCount; i++)
            {
                Symbol symbol = parserStack.Pop().Symbol;
                if (symbol != null)
                {
                    match_list.Add(symbol);
                }
            }

            match_list.Reverse();

            foreach (int index in rule.Captures)
            {
                non_terminal.AddChild(match_list[index]);
            }

            int state = parserStack.Peek().State;
            parserStack.Push(new StackElement(non_terminal, actionTable.GetGoto(state, non_terminal.NonTerminal)));
        }

        /// <summary>
        /// An element of our state stack.
        /// </summary>
        private struct StackElement
        {
            private readonly Symbol symbol;
            private readonly int state;

            /// <summary>
            /// Construct a StackElement
            /// </summary>
            /// <param name="stack_symbol">Symbol.</param>
            /// <param name="stack_state">State.</param>
            public StackElement(Symbol stack_symbol, int stack_state)
            {
                symbol = stack_symbol;
                state = stack_state;
            }

            /// <summary>
            /// Gets the symbol in this stack element.
            /// </summary>
            public Symbol Symbol
            {
                get { return symbol; }
            }

            /// <summary>
            /// Gets the state in this stack element.
            /// </summary>
            public int State
            {
                get { return state; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\TextLocation.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="TextLocation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    /// <summary>
    /// Represents a location (maybe a span) within
    /// a text file
    /// </summary>
    public struct TextLocation
    {
        private readonly int startLine;
        private readonly int startColumn;
        private readonly int endLine;
        private readonly int endColumn;

        /// <summary>
        /// Construct a text span
        /// </summary>
        /// <param name="start_line">Start line for span</param>
        /// <param name="start_column">Start column for span</param>
        /// <param name="end_line">End line for span</param>
        /// <param name="end_column">End column for span</param>
        public TextLocation(int start_line, int start_column, int end_line, int end_column)
        {
            this.startLine = start_line;
            this.startColumn = start_column;
            this.endLine = end_line;
            this.endColumn = end_column;
        }

        /// <summary>
        /// Gets a value indicating whether this is the null location
        /// </summary>
        public bool IsNull
        {
            get { return (startLine == 0); }
        }

        /// <summary>
        /// Gets start line of text span
        /// </summary>
        public int StartLine
        {
            get { return startLine; }
        }

        /// <summary>
        /// Gets start column of text span
        /// </summary>
        public int StartColumn
        {
            get { return startColumn; }
        }

        /// <summary>
        /// Gets end line of text span
        /// </summary>
        public int EndLine
        {
            get { return endLine; }
        }

        /// <summary>
        /// Gets end column of text span
        /// </summary>
        public int EndColumn
        {
            get { return endColumn; }
        }

        /// <summary>
        /// Merge this location with another location to form a new span that is the union
        /// </summary>
        /// <param name="other">Other location to merge with</param>
        /// <returns>Merged span</returns>
        public TextLocation Merge(TextLocation other)
        {
            int start_line;
            int end_line;
            int start_column;
            int end_column;

            // Merging with a null text location is a no-op
            if (this.IsNull)
            {
                return other;
            }
            else if (other.IsNull)
            {
                return this;
            }

            // Start line and column is the earliest of the two
            if (this.StartLine < other.StartLine)
            {
                start_line = this.StartLine;
                start_column = this.StartColumn;
            }
            else if (this.StartLine == other.StartLine)
            {
                start_line = this.StartLine;
                start_column = this.StartColumn < other.StartColumn ? this.StartColumn : other.StartColumn;
            }
            else
            {
                start_line = other.StartLine;
                start_column = other.StartColumn;
            }

            // End line and column is the later of the two
            if (this.EndLine > other.EndLine)
            {
                end_line = this.EndLine;
                end_column = this.EndColumn;
            }
            else if (this.EndLine == other.EndLine)
            {
                end_line = this.EndLine;
                end_column = this.EndColumn > other.EndColumn ? this.EndColumn : other.EndColumn;
            }
            else
            {
                end_line = other.EndLine;
                end_column = other.EndColumn;
            }

            return new TextLocation(start_line, start_column, end_line, end_column);
        }

        /// <summary>
        /// Formats as string
        /// </summary>
        /// <returns>Formatted string</returns>
        public override string ToString()
        {
            if (IsNull)
            {
                return "";
            }
            else
            {
                return string.Format("({0},{1})", this.StartLine, this.StartColumn);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTHelp\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\ReductionRule.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="ReductionRule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;

    /// <summary>
    /// A reduction rule to apply.
    /// </summary>
    /// <typeparam name="TNonTermEnum">Value type indicating the kind of non-terminal, typically an enum.</typeparam>
    /// <typeparam name="TReductionNameEnum">Value type indicating the reduction kind that was applied, typically an enum.</typeparam>
    public class ReductionRule<TNonTermEnum, TReductionNameEnum>
        where TNonTermEnum : struct
        where TReductionNameEnum : struct
    {
        private readonly TNonTermEnum nonTerminal;
        private readonly TReductionNameEnum reductionId;
        private readonly int symbolCount;
        private readonly int[] captureList;

        /// <summary>
        /// Construct a reduction rule.
        /// </summary>
        /// <param name="non_terminal">Non-terminal this rule reduces the stack to.</param>
        /// <param name="symbol_count">Number of symbols to pop from the stack in reduction.</param>
        /// <param name="reduction_id">Identifier of this reduction.</param>
        public ReductionRule(TNonTermEnum non_terminal, int symbol_count, TReductionNameEnum reduction_id)
        {
            nonTerminal = non_terminal;
            symbolCount = symbol_count;
            captureList = new int[symbol_count];
            for (int i = 0; i < symbol_count; i++)
            {
                captureList[i] = i;
            }
            reductionId = reduction_id;
        }

        /// <summary>
        /// Construct a reduction rule with custom capture list.
        /// </summary>
        /// <param name="non_terminal">Non-terminal this rule reduces the stack to.</param>
        /// <param name="symbol_count">Number of symbols to pop from the stack in reduction.</param>
        /// <param name="captures">Array of indices of symbols to be captured.</param>
        /// <param name="reduction_id">Identifier of this reduction.</param>
        public ReductionRule(TNonTermEnum non_terminal, int symbol_count, int[] captures, TReductionNameEnum reduction_id)
        {
            nonTerminal = non_terminal;
            symbolCount = symbol_count;
            captureList = captures;
            reductionId = reduction_id;
        }

        /// <summary>
        /// Gets the non-terminal this rule reduces to.
        /// </summary>
        public TNonTermEnum NonTerminal
        {
            get { return nonTerminal; }
        }

        /// <summary>
        /// Gets the number of symbols to reduce by this rule.
        /// </summary>
        public int SymbolCount
        {
            get { return symbolCount; }
        }

        /// <summary>
        /// The identifier associated with this reduction (will be Default, unless
        /// it was specified explicitly in the grammar file).
        /// </summary>
        public TReductionNameEnum ReductionId
        {
            get { return reductionId; }
        }

        /// <summary>
        /// Gets the list of symbol indices to capture in this reducation.
        /// </summary>
        public ReadOnlyCollection<int> Captures
        {
            get { return new ReadOnlyCollection<int>(captureList); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\SymbolBase.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="SymbolBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;

    /// <summary>
    /// Base class for symbol class. Generated parsers should use a class
    /// dervied from this class to represent all symbols.
    /// </summary>
    /// <typeparam name="TTokenEnum">Type of token enumeration.</typeparam>
    /// <typeparam name="TNonTermEnum">Type of non-terminal enumeration.</typeparam>
    /// <typeparam name="TReductionEnum">Type of reduction id enumeration.</typeparam>
    /// <typeparam name="TSymbol">Type of the symbol class derived from this base class.</typeparam>
    public class SymbolBase<TTokenEnum, TNonTermEnum, TReductionEnum, TSymbol> : IToken
        where TTokenEnum : struct
        where TNonTermEnum : struct
        where TReductionEnum : struct
        where TSymbol : SymbolBase<TTokenEnum, TNonTermEnum, TReductionEnum, TSymbol>
    {
        private List<TSymbol> children;
        private Tokens token;
        private TNonTermEnum nonTerminal;
        private TReductionEnum reductionId;
        private string tokenString;
        private TextLocation location;
        private TSymbol parent;

        /// <summary>
        /// Gets a value indicating whether this symbol is a non-terminal.
        /// </summary>
        public bool IsNonTerminal
        {
            get { return (children != null); }
        }

        /// <summary>
        /// Gets a value indicating whether this symbol is a terminal.
        /// </summary>
        public bool IsTerminal
        {
            get { return (children == null); }
        }

        /// <summary>
        /// Gets the collection of children of this symbol (or null if this symbol is a terminal).
        /// </summary>
        public ReadOnlyCollection<TSymbol> Children
        {
            get { return (children != null) ? new ReadOnlyCollection<TSymbol>(children) : null; }
        }

        /// <summary>
        /// Gets the string for this token, or null if this symbol is a non-terminal.
        /// </summary>
        public string TokenString
        {
            get { return tokenString; }
        }

        /// <summary>
        /// Gets the parent of this token, or null if it has none.
        /// </summary>
        public TSymbol Parent
        {
            get { return parent; }
        }

        /// <summary>
        /// Gets the location in the input text stream for this token.
        /// </summary>
        public TextLocation Location
        {
            get { return location; }
        }

        /// <summary>
        /// Gets the token type for this symbol (invalid if this is a non-terminal).
        /// </summary>
        public Tokens Token
        {
            get { return token; }
        }

        /// <summary>
        /// Gets the non-terminal type for this symbol (invalid if this is a token).
        /// </summary>
        public TNonTermEnum NonTerminal
        {
            get { return nonTerminal; }
        }

        /// <summary>
        /// Gets the reduction id that generated this symbol (invalid if this is a token).
        /// </summary>
        public TReductionEnum ReductionId
        {
            get { return reductionId; }
        }

        /// <summary>
        /// Format as a string. This is the raw token string in the case of a token, or the
        /// non-terminal type in the case of a non-terminal.
        /// </summary>
        /// <returns>Formatted string.</returns>
        public override string ToString()
        {
            if (this.IsNonTerminal)
            {
                return nonTerminal.ToString();
            }
            else
            {
                return tokenString;
            }
        }

        /// <summary>
        /// Add a child symbol to this symbol (which must be a non-terminal).
        /// </summary>
        /// <param name="symbol">Child symbol to add.</param>
        public void AddChild(TSymbol symbol)
        {
            children.Add(symbol);
            symbol.parent = (TSymbol)this;
            symbol.parent = (TSymbol)this;
            location = Location.Merge(symbol.Location);
        }

        /// <summary>
        /// Recursively collapses this non-terminal by expanding out child non-terminals
        /// of the same type. This flattens out parse trees of the kind generated by rules
        /// such as:
        /// 
        /// items:
        ///     | items item
        ///     ;
        /// </summary>
        public void CollapseChain()
        {
            List<TSymbol> flattened_children = new List<TSymbol>();
            foreach (TSymbol child in Children)
            {
                if (child.IsNonTerminal && child.NonTerminal.Equals(this.NonTerminal))
                {
                    child.CollapseChain();
                    foreach (TSymbol grandchild in child.Children)
                    {
                        flattened_children.Add(grandchild);
                        grandchild.parent = (TSymbol)this;
                    }
                }
                else
                {
                    flattened_children.Add(child);
                }
            }

            children = flattened_children;
        }
        
        /// <summary>
        /// Recursively elide structural non-terminals of the given type, which
        /// only have one child. This flattens some parse trees.
        /// </summary>
        /// <param name="non_terminal">Non-terminal type to elide</param>
        public void Elide(TNonTermEnum non_terminal)
        {
            List<TSymbol> elided_children = new List<TSymbol>();
            foreach (TSymbol child in Children)
            {
                if (child.IsNonTerminal)
                {
                    child.Elide(non_terminal);
                    if (child.NonTerminal.Equals(non_terminal) && child.Children.Count == 1)
                    {
                        elided_children.Add(child.Children[0]);
                        child.Children[0].parent = (TSymbol)this;
                    }
                    else
                    {
                        elided_children.Add(child);
                    }
                }
                else
                {
                    elided_children.Add(child);
                }
            }

            children = elided_children;
        }

        /// <summary>
        /// Sets this symbol to be a token (terminal).
        /// </summary>
        /// <param name="token_type">Type of this token.</param>
        /// <param name="token_string">String value of this token.</param>
        /// <param name="text_location">Text location of this token.</param>
        public void SetToken(Tokens token_type, string token_string, TextLocation text_location)
        {
            children = null;
            token = token_type;
            tokenString = token_string;
            location = text_location;
        }

        /// <summary>
        /// Sets this symbol to be a non-terminal.
        /// </summary>
        /// <param name="non_term">Type of this non-terminal.</param>
        /// <param name="reduction_id">Reduction id which generated this non-terminal.</param>
        public void SetNonTerminal(TNonTermEnum non_term, TReductionEnum reduction_id)
        {
            children = new List<TSymbol>();
            nonTerminal = non_term;
            reductionId = reduction_id;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\Tokenizer.cs ===
//-----------------------------------------------------------------------
// <copyright file="Tokenizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.IO;

    /// <summary>
    /// Simple tokenizer.
    /// </summary>
    public class Tokenizer : ITokenizer
    {
        private IEnumerable<Pattern> patternList;
        private TextReader inputStream;
        private string currentLine;
        private int currentLineNumber;
        private int currentColumnNumber;

        /// <summary>
        /// Construct a tokenizer
        /// </summary>
        /// <param name="patterns">Patterns to match</param>
        /// <param name="input_stream">Input stream to consume</param>
        public Tokenizer(IEnumerable<Pattern> patterns, TextReader input_stream)
        {
            if (patterns == null)
            {
                throw new ArgumentNullException("patterns");
            }

            if (input_stream == null)
            {
                throw new ArgumentNullException("input_stream");
            }

            patternList = patterns;
            inputStream = input_stream;
            currentLineNumber = 0;
            currentColumnNumber = 0;
        }

        /// <summary>
        /// Raised when bad (unmatched) input is encountered.
        /// </summary>
        public event Action<string> BadInputEncountered;

        /// <summary>
        /// Gets the next terminal (token) from the input stream.
        /// </summary>
        /// <returns>Next token (which may be the zero EOF token), or null if error is encountered.</returns>
        public Symbol NextToken()
        {
            Symbol terminal = null;

            while (terminal == null)
            {
                // Suck up some more input if we need to, return null if we hit the end of the input
                if (currentLine == null || currentLine.Length == 0)
                {
                    do
                    {
                        currentLine = inputStream.ReadLine();
                        currentLineNumber++;
                        currentColumnNumber = 1;

                        // If no more data, make up a terminal with the null token to indicate EOF.
                        if (currentLine == null)
                        {
                            terminal = new Symbol();
                            terminal.SetToken(new Tokens(), null, new TextLocation(currentLineNumber, 0, currentLineNumber, 0));
                            return terminal;
                        }
                    }
                    while (currentLine.Length == 0);
                }

                // Find the longest match
                Pattern matching_pattern;
                String match = FindLongestMatch(out matching_pattern);

                // If we didn't match anything, then input must be invalid, so report error and bail
                if (match == null)
                {
                    if (BadInputEncountered != null)
                    {
                        BadInputEncountered(currentLine);
                        // BadInputEncountered(currentLine, new TextLocation(currentLineNumber, currentColumnNumber, currentLineNumber, currentColumnNumber));
                    }

                    return null;
                }

                // Generate a terminal for this match if it's not flagged as ignored
                if (!matching_pattern.IsIgnored)
                {
                    terminal = new Symbol();
                    terminal.SetToken(matching_pattern.Token, match, new TextLocation(currentLineNumber, currentColumnNumber - match.Length, currentLineNumber, currentColumnNumber - 1));
                }
            }

            return terminal;
        }

        /// <summary>
        /// Find the longest match at current position in the input stream
        /// </summary>
        /// <param name="matching_pattern">Will be set to the pattern which caused the match</param>
        /// <returns>Longest match found, or null if no match</returns>
        private String FindLongestMatch(out Pattern matching_pattern)
        {
            String longest_match = null;
            matching_pattern = null;
            
            foreach (Pattern pattern in patternList)
            {
                // See if we need to match at all if the pattern is a 
                // string match based one
                if ((pattern.IsStringCompare) && 
                    (longest_match != null) &&
                    (longest_match.Length > pattern.StringPattern.Length))
                {
                    continue;
                }

                String match = pattern.Match(currentLine);

                if ((match != null) && 
                    (longest_match == null || 
                     longest_match.Length < match.Length))
                {
                    longest_match = match;
                    matching_pattern = pattern;
                }
            }

            if (longest_match != null)
            {
                currentLine = currentLine.Substring(longest_match.Length);
                currentColumnNumber += longest_match.Length;
            }

            return longest_match;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTHelp\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\TestDDTActions\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\TestDDTActions\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\TestDDTActions\TestDDTActions.cs ===
using System;
using DDT;

namespace TestDDTActions
{
    public class TestDDTActionCollection : DDTActionCollection
    {
        [DDTAction]
        public class TestEcho : DDTAction
        {
            [DDTParam]
            public String Msg = String.Empty;

            public override Object Invoke()
            {
                DDTGlobal.RO.Log("TestEcho : " + Msg);
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTHelp\DDTHelp.cs ===
using System;
using DDT;

namespace DDTHelp
{
    public class Program
    {
        public static void Usage()
        {
            Console.WriteLine("Usage : DDTHelp <Actions DLL> " + 
                              "[Action Name(Optional)]");
        }

        public static void Main(string[] args)
        {
            if ((args.Length < 1) || (args.Length > 2))
            {
                Usage();
                return;
            }

            DDTEnvironment e = new DDTEnvironment();
            
            try
            {
                if (args.Length == 1)
                {
                    // Display actions without loading
                    e.ListActions(args[0]);
                }
                else
                {
                    e.LoadActionsFromAssembly(args[0]);
                    e.DisplayDoc(args[1]);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\UnitTests\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\UnitTests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\BDInstaller.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.ServiceProcess;
using Microsoft.Win32;


namespace xonline.test.deployment.automation.bdservice
{
    [RunInstaller(true)]
    public class BDInstaller : Installer
    {
        private ServiceProcessInstaller _processInstaller;
        private ServiceInstaller _bdServiceInstaller;

        public BDInstaller()
        {
            _processInstaller = new ServiceProcessInstaller();
            _processInstaller.Account = ServiceAccount.User;

            _bdServiceInstaller = new ServiceInstaller();
            _bdServiceInstaller.ServiceName = "BDService";
            _bdServiceInstaller.DisplayName = "Build Detector Service";
            _bdServiceInstaller.Description = "Detects new Xbox Live Service builds and performs custom actions.";
            _bdServiceInstaller.StartType = ServiceStartMode.Automatic;

            Installers.Add(_bdServiceInstaller);
            Installers.Add(_processInstaller);

            AfterInstall += new InstallEventHandler(BDInstaller_AfterInstall);
        }

        void BDInstaller_AfterInstall(object sender, InstallEventArgs e)
        {
            // Create the registry key required by this service
            using (RegistryKey settingsKey = Registry.LocalMachine.CreateSubKey("SYSTEM\\CurrentControlSet\\Services\\BDService\\Jobs")) { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\UnitTests\Program.cs ===
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Text;

using DDT;

namespace DDTUnitTest
{
    public class SampleTestActions : DDTActionCollection
    {
        public enum UserType
        {
            Silver = 0,
            Gold = 1
        }

        public class UserInt
        {
            private int _i = 0;
            public int i 
            {
                get {
                    return _i;
                }
                
                set {
                    _i = value;
                }
            }

            public int[] array = null;
            

            public String Name = String.Empty;


            public UserInt()
            {
                array = new int[10];
                for (int i = 0;i < 10;i++)
                {
                    array[i] = i * i;
                }
            }

            public static String GetPrefix()
            {
                return "Prefix";
            }

            public static int MAX_USERS = 1000000;

            public int TestMethod(int i)
            {
                return (i + 1);
            }

            public String TestMethod(String a, float b)
            {
                return a + b.ToString();
            }

            public void TestMethod(ref int i)
            {
                i++;
            }

            public void TestMethod(int i, out String s)
            {
                s = i.ToString();
            }

            public String GenericMethod<T>(T a)
            {
                return a.ToString();
            }

            // Have an overload for the generic method to try and 
            // confuse the parser
            public String GenericMethod(int i)
            {
                return i.ToString();
            }
        }

        [DDTAction]
        [DDTDoc("Creates a Xbox Live account")]
        public class CreateUser : DDTAction
        {
            [DDTParam]
            [DDTDoc("UserTier - Gold or Silver")]
            public UserType Type = UserType.Gold;

            [DDTParam]
            [DDTDoc("Gamertag")]
            public String GamerTag = "Test";

            [DDTParam]
            [DDTDoc("Passport Type")]
            public bool RealPassport = true;

            [DDTParam]
            [DDTDoc("Date of Birth")]
            public DateTime Date = DateTime.MinValue;

            public override Object Invoke()
            {
                UserInt u = new UserInt();

                Console.WriteLine("CreateUser(" + Type + ", " +
                                  GamerTag + ", " + RealPassport + ")");

                u.i = 10;
                u.Name = GamerTag;

                return u;
            }
        }

        [DDTAction]
        public class Increment : DDTAction
        {
            [DDTParam(ImpliedSource = "CreateUser", Required = true)]
            public int i = 0;

            public override Object Invoke()
            {
                Console.WriteLine("Increment(" + i + ")");
                return (i + 1);
            }
        }

        [DDTAction]
        [DDTDoc("Executes an asynchronous action")]
        public class LongTask : DDTAction
        {
            [DDTParam]
            public bool Error = false;

            public delegate void LongDelegate();

            public LongDelegate d = null;

            public void LongOperation()
            {
                System.Threading.Thread.Sleep(100);
            }

            public override Object Invoke()
            {
                d = new LongDelegate(LongOperation);
                d.BeginInvoke(DDTContinuation.Callback,
                              DDTContinuation.State(this.RunContinuation));

                return DDTContinuation.Continue();
            }
            
            public Object RunContinuation(Object state)
            {
                IAsyncResult result = (IAsyncResult)state;
                d.EndInvoke(result);

                if (Error)
                {
                    throw new Exception(
                        "LongTask : Error occured during operation");
                }
                
                return 1000;
            }
        }

    }

    public class Program
    {
        public static void Main(string[] args)
        {
            bool runAll = true;

            DDTTestSuite testSuite = 
                DDTTestSuite.GetTestSuite("DDTUnitTests.xml");

            if (args.Length > 0)
            {
                runAll = false;
            }

            foreach (DDTTestCaseInfo test in testSuite.TestCases)
            {
                if (!runAll)
                {
                    bool found = false;

                    foreach (String name in args)
                    {
                        if (name.ToLower() == test.Name.ToLower())
                        {
                            found = true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        continue;
                    }
                }

                Console.WriteLine("---Start Test : " + test.Name);
                testSuite.ExecuteTestCase(test);
                Console.WriteLine("---End Test : " + test.Name);
            }
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\DDT\DDTCore\DDTExpressionParser\DDTExpression.cs ===
//<auto-generated/>
//-----------------------------------------------------------------------
// <copyright file="DDTExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Oopc.Generated
{
    /// <summary>
    /// Token types (terminals) recognized by the tokenizer.
    /// </summary>
    public enum Tokens
    {
        EOF = 0,
        Whitespace = 1,
        Dollar = 2,
        Null = 3,
        Character = 4,
        String = 5,
        Boolean = 6,
        Integer = 7,
        Hexadecimal = 8,
        Float = 9,
        New = 10,
        Ref = 11,
        Identifier = 12,
        LParan = 13,
        RParan = 14,
        LSqr = 15,
        RSqr = 16,
        LCurly = 17,
        RCurly = 18,
        Comma = 19,
        Dot = 20,
        DotDot = 21,
        Plus = 22,
        Minus = 23,
        Mult = 24,
        Div = 25,
        Mod = 26,
        Equal = 27,
        NotEqual = 28,
        Lesser = 29,
        Greater = 30,
        LesserOrEqual = 31,
        GreaterOrEqual = 32,
        Not = 33,
        And = 34,
        Or = 35,
        Assignment = 36,
        PlusAssignment = 37,
        MinusAssignment = 38,
        MultAssignment = 39,
        DivAssignment = 40,
        ModAssignment = 41,
        LShift = 42,
        RShift = 43,
        LogicalNot = 44,
        LogicalAnd = 45,
        LogicalOr = 46,
        LogicalXor = 47,
        LShiftAssignment = 48,
        RShiftAssignment = 49,
        AndAssignment = 50,
        XorAssignment = 51,
        OrAssignment = 52,
        PlusPlus = 53,
        MinusMinus = 54,
        ArrayDimensions = 55,
        ColonColon = 56
    }

    /// <summary>
    /// Non-terminal types specified in the grammar.
    /// </summary>
    public enum NonTerminals
    {
        Expression = 0,
        AssignmentExp = 1,
        OrExp = 2,
        AndExp = 3,
        LogicalOrExp = 4,
        LogicalXorExp = 5,
        LogicalAndExp = 6,
        Equality = 7,
        Relational = 8,
        ShiftExp = 9,
        Term = 10,
        Factor = 11,
        Unary = 12,
        Primary = 13,
        ExpressionList = 14,
        TypeList = 15,
        NonEmptyExpressionList = 16,
        START = 17
    }

    /// <summary>
    /// Reduction identifiers specified in the grammar.
    /// </summary>
    public enum Reductions
    {
        Default = 0,
        AssignmentReduction = 1,
        PlusAssignmentReduction = 2,
        MinusAssignmentReduction = 3,
        MultAssignmentReduction = 4,
        DivAssignmentReduction = 5,
        ModAssignmentReduction = 6,
        LShiftAssignmentReduction = 7,
        RShiftAssignmentReduction = 8,
        AndAssignmentReduction = 9,
        XorAssignmentReduction = 10,
        OrAssignmentReduction = 11,
        OrReduction = 12,
        AndReduction = 13,
        LogicalOrReduction = 14,
        LogicalXorReduction = 15,
        LogicalAndReduction = 16,
        ComparisonReduction = 17,
        LShiftReduction = 18,
        RShiftReduction = 19,
        SumReduction = 20,
        DiffReduction = 21,
        MultReduction = 22,
        DivReduction = 23,
        ModReduction = 24,
        CastReduction = 25,
        UnaryMinusReduction = 26,
        UnaryPlusReduction = 27,
        NotReduction = 28,
        PreIncReduction = 29,
        PreDecReduction = 30,
        LogicalNotReduction = 31,
        MemberReduction = 32,
        MethodReduction = 33,
        GenericMethodReduction = 34,
        ArrayReduction = 35,
        StaticMemberReduction = 36,
        PostIncReduction = 37,
        PostDecReduction = 38,
        DollarReduction = 39,
        RangeReduction = 40,
        ListReduction = 41,
        NewReduction = 42,
        GenericNewReduction = 43,
        ArrayNewReduction = 44,
        GenericArrayNewReduction = 45,
        SingleParamReduction = 46,
        ParamReduction = 47,
        RefSingleParamReduction = 48,
        RefParamReduction = 49,
        SingleTypeReduction = 50,
        GenericSingleTypeReduction = 51,
        ArraySingleTypeReduction = 52,
        GenericArraySingleTypeReduction = 53,
        TypeListReduction = 54,
        GenericTypeListReduction = 55,
        ArrayTypeListReduction = 56,
        GenericArrayTypeListReduction = 57
    }

    /// <summary>
    /// Parser action table
    /// </summary>
    public sealed class ParserActionTable : IParserActionTable<Tokens, NonTerminals, Reductions>
    {
        public const int NumTokens = 57;
        public const int NumNonTerminals = 18;
        public const int NumStates = 166;


        private static readonly ParserAction[,] actionTable;
        private static readonly int[,] gotoTable;

        private static readonly ReductionRule<NonTerminals,Reductions>[] reductionRules =
        {
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.AssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.PlusAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.MinusAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.MultAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.DivAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.ModAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.LShiftAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.RShiftAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.AndAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.XorAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Expression, 3, new int[] {0, 2}, Reductions.OrAssignmentReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.AssignmentExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.AssignmentExp, 3, new int[] {0, 2}, Reductions.OrReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.OrExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.OrExp, 3, new int[] {0, 2}, Reductions.AndReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.AndExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.AndExp, 3, new int[] {0, 2}, Reductions.LogicalOrReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalOrExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalOrExp, 3, new int[] {0, 2}, Reductions.LogicalXorReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalXorExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalXorExp, 3, new int[] {0, 2}, Reductions.LogicalAndReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalAndExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalAndExp, 3, new int[] {0, 1, 2}, Reductions.ComparisonReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.LogicalAndExp, 3, new int[] {0, 1, 2}, Reductions.ComparisonReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Equality, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Equality, 3, new int[] {0, 1, 2}, Reductions.ComparisonReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Equality, 3, new int[] {0, 1, 2}, Reductions.ComparisonReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Equality, 3, new int[] {0, 1, 2}, Reductions.ComparisonReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Equality, 3, new int[] {0, 1, 2}, Reductions.ComparisonReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Relational, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Relational, 3, new int[] {0, 2}, Reductions.LShiftReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Relational, 3, new int[] {0, 2}, Reductions.RShiftReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.ShiftExp, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.ShiftExp, 3, new int[] {0, 2}, Reductions.SumReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.ShiftExp, 3, new int[] {0, 2}, Reductions.DiffReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Term, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Term, 3, new int[] {0, 2}, Reductions.MultReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Term, 3, new int[] {0, 2}, Reductions.DivReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Term, 3, new int[] {0, 2}, Reductions.ModReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 4, new int[] {1, 3}, Reductions.CastReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 2, new int[] {1}, Reductions.UnaryMinusReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 2, new int[] {1}, Reductions.UnaryPlusReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 2, new int[] {1}, Reductions.NotReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 2, new int[] {1}, Reductions.PreIncReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 2, new int[] {1}, Reductions.PreDecReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Factor, 2, new int[] {1}, Reductions.LogicalNotReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 3, new int[] {0, 2}, Reductions.MemberReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 4, new int[] {0, 2}, Reductions.MethodReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 7, new int[] {0, 2, 5}, Reductions.GenericMethodReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 4, new int[] {0, 2}, Reductions.ArrayReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 5, new int[] {1, 4}, Reductions.StaticMemberReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 2, new int[] {0}, Reductions.PostIncReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Unary, 2, new int[] {0}, Reductions.PostDecReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 3, new int[] {1}, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 2, new int[] {1}, Reductions.DollarReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 5, new int[] {1, 3}, Reductions.RangeReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 3, new int[] {1}, Reductions.ListReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 5, new int[] {1, 3}, Reductions.NewReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 8, new int[] {1, 3, 6}, Reductions.GenericNewReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 5, new int[] {1, 3}, Reductions.ArrayNewReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.Primary, 8, new int[] {1, 3, 6}, Reductions.GenericArrayNewReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.ExpressionList, 0, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.ExpressionList, 1, Reductions.Default),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 1, new int[] {0}, Reductions.SingleTypeReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 4, new int[] {0, 2}, Reductions.GenericSingleTypeReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 2, new int[] {0, 1}, Reductions.ArraySingleTypeReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 5, new int[] {0, 2, 4}, Reductions.GenericArraySingleTypeReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 3, new int[] {0, 2}, Reductions.TypeListReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 6, new int[] {0, 2, 4}, Reductions.GenericTypeListReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 4, new int[] {0, 2, 3}, Reductions.ArrayTypeListReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.TypeList, 7, new int[] {0, 2, 4, 6}, Reductions.GenericArrayTypeListReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.NonEmptyExpressionList, 1, new int[] {0}, Reductions.SingleParamReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.NonEmptyExpressionList, 3, new int[] {0, 2}, Reductions.ParamReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.NonEmptyExpressionList, 2, new int[] {1}, Reductions.RefSingleParamReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.NonEmptyExpressionList, 4, new int[] {0, 3}, Reductions.RefParamReduction),
            new ReductionRule<NonTerminals,Reductions>(NonTerminals.START, 1, Reductions.Default),

        };

        static ParserActionTable()
        {
            actionTable = new ParserAction[NumStates, NumTokens];

            // State 0
            actionTable[0, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[0, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[0, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[0, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[0, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[0, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[0, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[0, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[0, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[0, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[0, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[0, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[0, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[0, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[0, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[0, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[0, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[0, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 1
            actionTable[1, 0] = new ParserAction(ParserActions.Accept, 0, 0);    // EOF

            // State 2
            actionTable[2, 0] = new ParserAction(ParserActions.Reduce, 0, 0);    // EOF
            actionTable[2, 14] = new ParserAction(ParserActions.Reduce, 0, 0);    // RParan
            actionTable[2, 16] = new ParserAction(ParserActions.Reduce, 0, 0);    // RSqr
            actionTable[2, 18] = new ParserAction(ParserActions.Reduce, 0, 0);    // RCurly
            actionTable[2, 19] = new ParserAction(ParserActions.Reduce, 0, 0);    // Comma
            actionTable[2, 21] = new ParserAction(ParserActions.Reduce, 0, 0);    // DotDot
            actionTable[2, 35] = new ParserAction(ParserActions.Shift, 33, 0);    // Or
            actionTable[2, 36] = new ParserAction(ParserActions.Shift, 34, 0);    // Assignment
            actionTable[2, 37] = new ParserAction(ParserActions.Shift, 35, 0);    // PlusAssignment
            actionTable[2, 38] = new ParserAction(ParserActions.Shift, 36, 0);    // MinusAssignment
            actionTable[2, 39] = new ParserAction(ParserActions.Shift, 37, 0);    // MultAssignment
            actionTable[2, 40] = new ParserAction(ParserActions.Shift, 38, 0);    // DivAssignment
            actionTable[2, 41] = new ParserAction(ParserActions.Shift, 39, 0);    // ModAssignment
            actionTable[2, 48] = new ParserAction(ParserActions.Shift, 40, 0);    // LShiftAssignment
            actionTable[2, 49] = new ParserAction(ParserActions.Shift, 41, 0);    // RShiftAssignment
            actionTable[2, 50] = new ParserAction(ParserActions.Shift, 42, 0);    // AndAssignment
            actionTable[2, 51] = new ParserAction(ParserActions.Shift, 43, 0);    // XorAssignment
            actionTable[2, 52] = new ParserAction(ParserActions.Shift, 44, 0);    // OrAssignment

            // State 3
            actionTable[3, 0] = new ParserAction(ParserActions.Reduce, 0, 12);    // EOF
            actionTable[3, 14] = new ParserAction(ParserActions.Reduce, 0, 12);    // RParan
            actionTable[3, 16] = new ParserAction(ParserActions.Reduce, 0, 12);    // RSqr
            actionTable[3, 18] = new ParserAction(ParserActions.Reduce, 0, 12);    // RCurly
            actionTable[3, 19] = new ParserAction(ParserActions.Reduce, 0, 12);    // Comma
            actionTable[3, 21] = new ParserAction(ParserActions.Reduce, 0, 12);    // DotDot
            actionTable[3, 34] = new ParserAction(ParserActions.Shift, 45, 0);    // And
            actionTable[3, 35] = new ParserAction(ParserActions.Reduce, 0, 12);    // Or
            actionTable[3, 36] = new ParserAction(ParserActions.Reduce, 0, 12);    // Assignment
            actionTable[3, 37] = new ParserAction(ParserActions.Reduce, 0, 12);    // PlusAssignment
            actionTable[3, 38] = new ParserAction(ParserActions.Reduce, 0, 12);    // MinusAssignment
            actionTable[3, 39] = new ParserAction(ParserActions.Reduce, 0, 12);    // MultAssignment
            actionTable[3, 40] = new ParserAction(ParserActions.Reduce, 0, 12);    // DivAssignment
            actionTable[3, 41] = new ParserAction(ParserActions.Reduce, 0, 12);    // ModAssignment
            actionTable[3, 48] = new ParserAction(ParserActions.Reduce, 0, 12);    // LShiftAssignment
            actionTable[3, 49] = new ParserAction(ParserActions.Reduce, 0, 12);    // RShiftAssignment
            actionTable[3, 50] = new ParserAction(ParserActions.Reduce, 0, 12);    // AndAssignment
            actionTable[3, 51] = new ParserAction(ParserActions.Reduce, 0, 12);    // XorAssignment
            actionTable[3, 52] = new ParserAction(ParserActions.Reduce, 0, 12);    // OrAssignment

            // State 4
            actionTable[4, 0] = new ParserAction(ParserActions.Reduce, 0, 14);    // EOF
            actionTable[4, 14] = new ParserAction(ParserActions.Reduce, 0, 14);    // RParan
            actionTable[4, 16] = new ParserAction(ParserActions.Reduce, 0, 14);    // RSqr
            actionTable[4, 18] = new ParserAction(ParserActions.Reduce, 0, 14);    // RCurly
            actionTable[4, 19] = new ParserAction(ParserActions.Reduce, 0, 14);    // Comma
            actionTable[4, 21] = new ParserAction(ParserActions.Reduce, 0, 14);    // DotDot
            actionTable[4, 34] = new ParserAction(ParserActions.Reduce, 0, 14);    // And
            actionTable[4, 35] = new ParserAction(ParserActions.Reduce, 0, 14);    // Or
            actionTable[4, 36] = new ParserAction(ParserActions.Reduce, 0, 14);    // Assignment
            actionTable[4, 37] = new ParserAction(ParserActions.Reduce, 0, 14);    // PlusAssignment
            actionTable[4, 38] = new ParserAction(ParserActions.Reduce, 0, 14);    // MinusAssignment
            actionTable[4, 39] = new ParserAction(ParserActions.Reduce, 0, 14);    // MultAssignment
            actionTable[4, 40] = new ParserAction(ParserActions.Reduce, 0, 14);    // DivAssignment
            actionTable[4, 41] = new ParserAction(ParserActions.Reduce, 0, 14);    // ModAssignment
            actionTable[4, 46] = new ParserAction(ParserActions.Shift, 46, 0);    // LogicalOr
            actionTable[4, 48] = new ParserAction(ParserActions.Reduce, 0, 14);    // LShiftAssignment
            actionTable[4, 49] = new ParserAction(ParserActions.Reduce, 0, 14);    // RShiftAssignment
            actionTable[4, 50] = new ParserAction(ParserActions.Reduce, 0, 14);    // AndAssignment
            actionTable[4, 51] = new ParserAction(ParserActions.Reduce, 0, 14);    // XorAssignment
            actionTable[4, 52] = new ParserAction(ParserActions.Reduce, 0, 14);    // OrAssignment

            // State 5
            actionTable[5, 0] = new ParserAction(ParserActions.Reduce, 0, 16);    // EOF
            actionTable[5, 14] = new ParserAction(ParserActions.Reduce, 0, 16);    // RParan
            actionTable[5, 16] = new ParserAction(ParserActions.Reduce, 0, 16);    // RSqr
            actionTable[5, 18] = new ParserAction(ParserActions.Reduce, 0, 16);    // RCurly
            actionTable[5, 19] = new ParserAction(ParserActions.Reduce, 0, 16);    // Comma
            actionTable[5, 21] = new ParserAction(ParserActions.Reduce, 0, 16);    // DotDot
            actionTable[5, 34] = new ParserAction(ParserActions.Reduce, 0, 16);    // And
            actionTable[5, 35] = new ParserAction(ParserActions.Reduce, 0, 16);    // Or
            actionTable[5, 36] = new ParserAction(ParserActions.Reduce, 0, 16);    // Assignment
            actionTable[5, 37] = new ParserAction(ParserActions.Reduce, 0, 16);    // PlusAssignment
            actionTable[5, 38] = new ParserAction(ParserActions.Reduce, 0, 16);    // MinusAssignment
            actionTable[5, 39] = new ParserAction(ParserActions.Reduce, 0, 16);    // MultAssignment
            actionTable[5, 40] = new ParserAction(ParserActions.Reduce, 0, 16);    // DivAssignment
            actionTable[5, 41] = new ParserAction(ParserActions.Reduce, 0, 16);    // ModAssignment
            actionTable[5, 46] = new ParserAction(ParserActions.Reduce, 0, 16);    // LogicalOr
            actionTable[5, 47] = new ParserAction(ParserActions.Shift, 47, 0);    // LogicalXor
            actionTable[5, 48] = new ParserAction(ParserActions.Reduce, 0, 16);    // LShiftAssignment
            actionTable[5, 49] = new ParserAction(ParserActions.Reduce, 0, 16);    // RShiftAssignment
            actionTable[5, 50] = new ParserAction(ParserActions.Reduce, 0, 16);    // AndAssignment
            actionTable[5, 51] = new ParserAction(ParserActions.Reduce, 0, 16);    // XorAssignment
            actionTable[5, 52] = new ParserAction(ParserActions.Reduce, 0, 16);    // OrAssignment

            // State 6
            actionTable[6, 0] = new ParserAction(ParserActions.Reduce, 0, 18);    // EOF
            actionTable[6, 14] = new ParserAction(ParserActions.Reduce, 0, 18);    // RParan
            actionTable[6, 16] = new ParserAction(ParserActions.Reduce, 0, 18);    // RSqr
            actionTable[6, 18] = new ParserAction(ParserActions.Reduce, 0, 18);    // RCurly
            actionTable[6, 19] = new ParserAction(ParserActions.Reduce, 0, 18);    // Comma
            actionTable[6, 21] = new ParserAction(ParserActions.Reduce, 0, 18);    // DotDot
            actionTable[6, 34] = new ParserAction(ParserActions.Reduce, 0, 18);    // And
            actionTable[6, 35] = new ParserAction(ParserActions.Reduce, 0, 18);    // Or
            actionTable[6, 36] = new ParserAction(ParserActions.Reduce, 0, 18);    // Assignment
            actionTable[6, 37] = new ParserAction(ParserActions.Reduce, 0, 18);    // PlusAssignment
            actionTable[6, 38] = new ParserAction(ParserActions.Reduce, 0, 18);    // MinusAssignment
            actionTable[6, 39] = new ParserAction(ParserActions.Reduce, 0, 18);    // MultAssignment
            actionTable[6, 40] = new ParserAction(ParserActions.Reduce, 0, 18);    // DivAssignment
            actionTable[6, 41] = new ParserAction(ParserActions.Reduce, 0, 18);    // ModAssignment
            actionTable[6, 45] = new ParserAction(ParserActions.Shift, 48, 0);    // LogicalAnd
            actionTable[6, 46] = new ParserAction(ParserActions.Reduce, 0, 18);    // LogicalOr
            actionTable[6, 47] = new ParserAction(ParserActions.Reduce, 0, 18);    // LogicalXor
            actionTable[6, 48] = new ParserAction(ParserActions.Reduce, 0, 18);    // LShiftAssignment
            actionTable[6, 49] = new ParserAction(ParserActions.Reduce, 0, 18);    // RShiftAssignment
            actionTable[6, 50] = new ParserAction(ParserActions.Reduce, 0, 18);    // AndAssignment
            actionTable[6, 51] = new ParserAction(ParserActions.Reduce, 0, 18);    // XorAssignment
            actionTable[6, 52] = new ParserAction(ParserActions.Reduce, 0, 18);    // OrAssignment

            // State 7
            actionTable[7, 0] = new ParserAction(ParserActions.Reduce, 0, 20);    // EOF
            actionTable[7, 14] = new ParserAction(ParserActions.Reduce, 0, 20);    // RParan
            actionTable[7, 16] = new ParserAction(ParserActions.Reduce, 0, 20);    // RSqr
            actionTable[7, 18] = new ParserAction(ParserActions.Reduce, 0, 20);    // RCurly
            actionTable[7, 19] = new ParserAction(ParserActions.Reduce, 0, 20);    // Comma
            actionTable[7, 21] = new ParserAction(ParserActions.Reduce, 0, 20);    // DotDot
            actionTable[7, 27] = new ParserAction(ParserActions.Shift, 49, 0);    // Equal
            actionTable[7, 28] = new ParserAction(ParserActions.Shift, 50, 0);    // NotEqual
            actionTable[7, 34] = new ParserAction(ParserActions.Reduce, 0, 20);    // And
            actionTable[7, 35] = new ParserAction(ParserActions.Reduce, 0, 20);    // Or
            actionTable[7, 36] = new ParserAction(ParserActions.Reduce, 0, 20);    // Assignment
            actionTable[7, 37] = new ParserAction(ParserActions.Reduce, 0, 20);    // PlusAssignment
            actionTable[7, 38] = new ParserAction(ParserActions.Reduce, 0, 20);    // MinusAssignment
            actionTable[7, 39] = new ParserAction(ParserActions.Reduce, 0, 20);    // MultAssignment
            actionTable[7, 40] = new ParserAction(ParserActions.Reduce, 0, 20);    // DivAssignment
            actionTable[7, 41] = new ParserAction(ParserActions.Reduce, 0, 20);    // ModAssignment
            actionTable[7, 45] = new ParserAction(ParserActions.Reduce, 0, 20);    // LogicalAnd
            actionTable[7, 46] = new ParserAction(ParserActions.Reduce, 0, 20);    // LogicalOr
            actionTable[7, 47] = new ParserAction(ParserActions.Reduce, 0, 20);    // LogicalXor
            actionTable[7, 48] = new ParserAction(ParserActions.Reduce, 0, 20);    // LShiftAssignment
            actionTable[7, 49] = new ParserAction(ParserActions.Reduce, 0, 20);    // RShiftAssignment
            actionTable[7, 50] = new ParserAction(ParserActions.Reduce, 0, 20);    // AndAssignment
            actionTable[7, 51] = new ParserAction(ParserActions.Reduce, 0, 20);    // XorAssignment
            actionTable[7, 52] = new ParserAction(ParserActions.Reduce, 0, 20);    // OrAssignment

            // State 8
            actionTable[8, 0] = new ParserAction(ParserActions.Reduce, 0, 22);    // EOF
            actionTable[8, 14] = new ParserAction(ParserActions.Reduce, 0, 22);    // RParan
            actionTable[8, 16] = new ParserAction(ParserActions.Reduce, 0, 22);    // RSqr
            actionTable[8, 18] = new ParserAction(ParserActions.Reduce, 0, 22);    // RCurly
            actionTable[8, 19] = new ParserAction(ParserActions.Reduce, 0, 22);    // Comma
            actionTable[8, 21] = new ParserAction(ParserActions.Reduce, 0, 22);    // DotDot
            actionTable[8, 27] = new ParserAction(ParserActions.Reduce, 0, 22);    // Equal
            actionTable[8, 28] = new ParserAction(ParserActions.Reduce, 0, 22);    // NotEqual
            actionTable[8, 29] = new ParserAction(ParserActions.Shift, 51, 0);    // Lesser
            actionTable[8, 30] = new ParserAction(ParserActions.Shift, 52, 0);    // Greater
            actionTable[8, 31] = new ParserAction(ParserActions.Shift, 53, 0);    // LesserOrEqual
            actionTable[8, 32] = new ParserAction(ParserActions.Shift, 54, 0);    // GreaterOrEqual
            actionTable[8, 34] = new ParserAction(ParserActions.Reduce, 0, 22);    // And
            actionTable[8, 35] = new ParserAction(ParserActions.Reduce, 0, 22);    // Or
            actionTable[8, 36] = new ParserAction(ParserActions.Reduce, 0, 22);    // Assignment
            actionTable[8, 37] = new ParserAction(ParserActions.Reduce, 0, 22);    // PlusAssignment
            actionTable[8, 38] = new ParserAction(ParserActions.Reduce, 0, 22);    // MinusAssignment
            actionTable[8, 39] = new ParserAction(ParserActions.Reduce, 0, 22);    // MultAssignment
            actionTable[8, 40] = new ParserAction(ParserActions.Reduce, 0, 22);    // DivAssignment
            actionTable[8, 41] = new ParserAction(ParserActions.Reduce, 0, 22);    // ModAssignment
            actionTable[8, 45] = new ParserAction(ParserActions.Reduce, 0, 22);    // LogicalAnd
            actionTable[8, 46] = new ParserAction(ParserActions.Reduce, 0, 22);    // LogicalOr
            actionTable[8, 47] = new ParserAction(ParserActions.Reduce, 0, 22);    // LogicalXor
            actionTable[8, 48] = new ParserAction(ParserActions.Reduce, 0, 22);    // LShiftAssignment
            actionTable[8, 49] = new ParserAction(ParserActions.Reduce, 0, 22);    // RShiftAssignment
            actionTable[8, 50] = new ParserAction(ParserActions.Reduce, 0, 22);    // AndAssignment
            actionTable[8, 51] = new ParserAction(ParserActions.Reduce, 0, 22);    // XorAssignment
            actionTable[8, 52] = new ParserAction(ParserActions.Reduce, 0, 22);    // OrAssignment

            // State 9
            actionTable[9, 0] = new ParserAction(ParserActions.Reduce, 0, 25);    // EOF
            actionTable[9, 14] = new ParserAction(ParserActions.Reduce, 0, 25);    // RParan
            actionTable[9, 16] = new ParserAction(ParserActions.Reduce, 0, 25);    // RSqr
            actionTable[9, 18] = new ParserAction(ParserActions.Reduce, 0, 25);    // RCurly
            actionTable[9, 19] = new ParserAction(ParserActions.Reduce, 0, 25);    // Comma
            actionTable[9, 21] = new ParserAction(ParserActions.Reduce, 0, 25);    // DotDot
            actionTable[9, 27] = new ParserAction(ParserActions.Reduce, 0, 25);    // Equal
            actionTable[9, 28] = new ParserAction(ParserActions.Reduce, 0, 25);    // NotEqual
            actionTable[9, 29] = new ParserAction(ParserActions.Reduce, 0, 25);    // Lesser
            actionTable[9, 30] = new ParserAction(ParserActions.Reduce, 0, 25);    // Greater
            actionTable[9, 31] = new ParserAction(ParserActions.Reduce, 0, 25);    // LesserOrEqual
            actionTable[9, 32] = new ParserAction(ParserActions.Reduce, 0, 25);    // GreaterOrEqual
            actionTable[9, 34] = new ParserAction(ParserActions.Reduce, 0, 25);    // And
            actionTable[9, 35] = new ParserAction(ParserActions.Reduce, 0, 25);    // Or
            actionTable[9, 36] = new ParserAction(ParserActions.Reduce, 0, 25);    // Assignment
            actionTable[9, 37] = new ParserAction(ParserActions.Reduce, 0, 25);    // PlusAssignment
            actionTable[9, 38] = new ParserAction(ParserActions.Reduce, 0, 25);    // MinusAssignment
            actionTable[9, 39] = new ParserAction(ParserActions.Reduce, 0, 25);    // MultAssignment
            actionTable[9, 40] = new ParserAction(ParserActions.Reduce, 0, 25);    // DivAssignment
            actionTable[9, 41] = new ParserAction(ParserActions.Reduce, 0, 25);    // ModAssignment
            actionTable[9, 42] = new ParserAction(ParserActions.Shift, 55, 0);    // LShift
            actionTable[9, 43] = new ParserAction(ParserActions.Shift, 56, 0);    // RShift
            actionTable[9, 45] = new ParserAction(ParserActions.Reduce, 0, 25);    // LogicalAnd
            actionTable[9, 46] = new ParserAction(ParserActions.Reduce, 0, 25);    // LogicalOr
            actionTable[9, 47] = new ParserAction(ParserActions.Reduce, 0, 25);    // LogicalXor
            actionTable[9, 48] = new ParserAction(ParserActions.Reduce, 0, 25);    // LShiftAssignment
            actionTable[9, 49] = new ParserAction(ParserActions.Reduce, 0, 25);    // RShiftAssignment
            actionTable[9, 50] = new ParserAction(ParserActions.Reduce, 0, 25);    // AndAssignment
            actionTable[9, 51] = new ParserAction(ParserActions.Reduce, 0, 25);    // XorAssignment
            actionTable[9, 52] = new ParserAction(ParserActions.Reduce, 0, 25);    // OrAssignment

            // State 10
            actionTable[10, 0] = new ParserAction(ParserActions.Reduce, 0, 30);    // EOF
            actionTable[10, 14] = new ParserAction(ParserActions.Reduce, 0, 30);    // RParan
            actionTable[10, 16] = new ParserAction(ParserActions.Reduce, 0, 30);    // RSqr
            actionTable[10, 18] = new ParserAction(ParserActions.Reduce, 0, 30);    // RCurly
            actionTable[10, 19] = new ParserAction(ParserActions.Reduce, 0, 30);    // Comma
            actionTable[10, 21] = new ParserAction(ParserActions.Reduce, 0, 30);    // DotDot
            actionTable[10, 22] = new ParserAction(ParserActions.Shift, 57, 0);    // Plus
            actionTable[10, 23] = new ParserAction(ParserActions.Shift, 58, 0);    // Minus
            actionTable[10, 27] = new ParserAction(ParserActions.Reduce, 0, 30);    // Equal
            actionTable[10, 28] = new ParserAction(ParserActions.Reduce, 0, 30);    // NotEqual
            actionTable[10, 29] = new ParserAction(ParserActions.Reduce, 0, 30);    // Lesser
            actionTable[10, 30] = new ParserAction(ParserActions.Reduce, 0, 30);    // Greater
            actionTable[10, 31] = new ParserAction(ParserActions.Reduce, 0, 30);    // LesserOrEqual
            actionTable[10, 32] = new ParserAction(ParserActions.Reduce, 0, 30);    // GreaterOrEqual
            actionTable[10, 34] = new ParserAction(ParserActions.Reduce, 0, 30);    // And
            actionTable[10, 35] = new ParserAction(ParserActions.Reduce, 0, 30);    // Or
            actionTable[10, 36] = new ParserAction(ParserActions.Reduce, 0, 30);    // Assignment
            actionTable[10, 37] = new ParserAction(ParserActions.Reduce, 0, 30);    // PlusAssignment
            actionTable[10, 38] = new ParserAction(ParserActions.Reduce, 0, 30);    // MinusAssignment
            actionTable[10, 39] = new ParserAction(ParserActions.Reduce, 0, 30);    // MultAssignment
            actionTable[10, 40] = new ParserAction(ParserActions.Reduce, 0, 30);    // DivAssignment
            actionTable[10, 41] = new ParserAction(ParserActions.Reduce, 0, 30);    // ModAssignment
            actionTable[10, 42] = new ParserAction(ParserActions.Reduce, 0, 30);    // LShift
            actionTable[10, 43] = new ParserAction(ParserActions.Reduce, 0, 30);    // RShift
            actionTable[10, 45] = new ParserAction(ParserActions.Reduce, 0, 30);    // LogicalAnd
            actionTable[10, 46] = new ParserAction(ParserActions.Reduce, 0, 30);    // LogicalOr
            actionTable[10, 47] = new ParserAction(ParserActions.Reduce, 0, 30);    // LogicalXor
            actionTable[10, 48] = new ParserAction(ParserActions.Reduce, 0, 30);    // LShiftAssignment
            actionTable[10, 49] = new ParserAction(ParserActions.Reduce, 0, 30);    // RShiftAssignment
            actionTable[10, 50] = new ParserAction(ParserActions.Reduce, 0, 30);    // AndAssignment
            actionTable[10, 51] = new ParserAction(ParserActions.Reduce, 0, 30);    // XorAssignment
            actionTable[10, 52] = new ParserAction(ParserActions.Reduce, 0, 30);    // OrAssignment

            // State 11
            actionTable[11, 0] = new ParserAction(ParserActions.Reduce, 0, 33);    // EOF
            actionTable[11, 14] = new ParserAction(ParserActions.Reduce, 0, 33);    // RParan
            actionTable[11, 16] = new ParserAction(ParserActions.Reduce, 0, 33);    // RSqr
            actionTable[11, 18] = new ParserAction(ParserActions.Reduce, 0, 33);    // RCurly
            actionTable[11, 19] = new ParserAction(ParserActions.Reduce, 0, 33);    // Comma
            actionTable[11, 21] = new ParserAction(ParserActions.Reduce, 0, 33);    // DotDot
            actionTable[11, 22] = new ParserAction(ParserActions.Reduce, 0, 33);    // Plus
            actionTable[11, 23] = new ParserAction(ParserActions.Reduce, 0, 33);    // Minus
            actionTable[11, 24] = new ParserAction(ParserActions.Shift, 59, 0);    // Mult
            actionTable[11, 25] = new ParserAction(ParserActions.Shift, 60, 0);    // Div
            actionTable[11, 26] = new ParserAction(ParserActions.Shift, 61, 0);    // Mod
            actionTable[11, 27] = new ParserAction(ParserActions.Reduce, 0, 33);    // Equal
            actionTable[11, 28] = new ParserAction(ParserActions.Reduce, 0, 33);    // NotEqual
            actionTable[11, 29] = new ParserAction(ParserActions.Reduce, 0, 33);    // Lesser
            actionTable[11, 30] = new ParserAction(ParserActions.Reduce, 0, 33);    // Greater
            actionTable[11, 31] = new ParserAction(ParserActions.Reduce, 0, 33);    // LesserOrEqual
            actionTable[11, 32] = new ParserAction(ParserActions.Reduce, 0, 33);    // GreaterOrEqual
            actionTable[11, 34] = new ParserAction(ParserActions.Reduce, 0, 33);    // And
            actionTable[11, 35] = new ParserAction(ParserActions.Reduce, 0, 33);    // Or
            actionTable[11, 36] = new ParserAction(ParserActions.Reduce, 0, 33);    // Assignment
            actionTable[11, 37] = new ParserAction(ParserActions.Reduce, 0, 33);    // PlusAssignment
            actionTable[11, 38] = new ParserAction(ParserActions.Reduce, 0, 33);    // MinusAssignment
            actionTable[11, 39] = new ParserAction(ParserActions.Reduce, 0, 33);    // MultAssignment
            actionTable[11, 40] = new ParserAction(ParserActions.Reduce, 0, 33);    // DivAssignment
            actionTable[11, 41] = new ParserAction(ParserActions.Reduce, 0, 33);    // ModAssignment
            actionTable[11, 42] = new ParserAction(ParserActions.Reduce, 0, 33);    // LShift
            actionTable[11, 43] = new ParserAction(ParserActions.Reduce, 0, 33);    // RShift
            actionTable[11, 45] = new ParserAction(ParserActions.Reduce, 0, 33);    // LogicalAnd
            actionTable[11, 46] = new ParserAction(ParserActions.Reduce, 0, 33);    // LogicalOr
            actionTable[11, 47] = new ParserAction(ParserActions.Reduce, 0, 33);    // LogicalXor
            actionTable[11, 48] = new ParserAction(ParserActions.Reduce, 0, 33);    // LShiftAssignment
            actionTable[11, 49] = new ParserAction(ParserActions.Reduce, 0, 33);    // RShiftAssignment
            actionTable[11, 50] = new ParserAction(ParserActions.Reduce, 0, 33);    // AndAssignment
            actionTable[11, 51] = new ParserAction(ParserActions.Reduce, 0, 33);    // XorAssignment
            actionTable[11, 52] = new ParserAction(ParserActions.Reduce, 0, 33);    // OrAssignment

            // State 12
            actionTable[12, 0] = new ParserAction(ParserActions.Reduce, 0, 36);    // EOF
            actionTable[12, 14] = new ParserAction(ParserActions.Reduce, 0, 36);    // RParan
            actionTable[12, 16] = new ParserAction(ParserActions.Reduce, 0, 36);    // RSqr
            actionTable[12, 18] = new ParserAction(ParserActions.Reduce, 0, 36);    // RCurly
            actionTable[12, 19] = new ParserAction(ParserActions.Reduce, 0, 36);    // Comma
            actionTable[12, 21] = new ParserAction(ParserActions.Reduce, 0, 36);    // DotDot
            actionTable[12, 22] = new ParserAction(ParserActions.Reduce, 0, 36);    // Plus
            actionTable[12, 23] = new ParserAction(ParserActions.Reduce, 0, 36);    // Minus
            actionTable[12, 24] = new ParserAction(ParserActions.Reduce, 0, 36);    // Mult
            actionTable[12, 25] = new ParserAction(ParserActions.Reduce, 0, 36);    // Div
            actionTable[12, 26] = new ParserAction(ParserActions.Reduce, 0, 36);    // Mod
            actionTable[12, 27] = new ParserAction(ParserActions.Reduce, 0, 36);    // Equal
            actionTable[12, 28] = new ParserAction(ParserActions.Reduce, 0, 36);    // NotEqual
            actionTable[12, 29] = new ParserAction(ParserActions.Reduce, 0, 36);    // Lesser
            actionTable[12, 30] = new ParserAction(ParserActions.Reduce, 0, 36);    // Greater
            actionTable[12, 31] = new ParserAction(ParserActions.Reduce, 0, 36);    // LesserOrEqual
            actionTable[12, 32] = new ParserAction(ParserActions.Reduce, 0, 36);    // GreaterOrEqual
            actionTable[12, 34] = new ParserAction(ParserActions.Reduce, 0, 36);    // And
            actionTable[12, 35] = new ParserAction(ParserActions.Reduce, 0, 36);    // Or
            actionTable[12, 36] = new ParserAction(ParserActions.Reduce, 0, 36);    // Assignment
            actionTable[12, 37] = new ParserAction(ParserActions.Reduce, 0, 36);    // PlusAssignment
            actionTable[12, 38] = new ParserAction(ParserActions.Reduce, 0, 36);    // MinusAssignment
            actionTable[12, 39] = new ParserAction(ParserActions.Reduce, 0, 36);    // MultAssignment
            actionTable[12, 40] = new ParserAction(ParserActions.Reduce, 0, 36);    // DivAssignment
            actionTable[12, 41] = new ParserAction(ParserActions.Reduce, 0, 36);    // ModAssignment
            actionTable[12, 42] = new ParserAction(ParserActions.Reduce, 0, 36);    // LShift
            actionTable[12, 43] = new ParserAction(ParserActions.Reduce, 0, 36);    // RShift
            actionTable[12, 45] = new ParserAction(ParserActions.Reduce, 0, 36);    // LogicalAnd
            actionTable[12, 46] = new ParserAction(ParserActions.Reduce, 0, 36);    // LogicalOr
            actionTable[12, 47] = new ParserAction(ParserActions.Reduce, 0, 36);    // LogicalXor
            actionTable[12, 48] = new ParserAction(ParserActions.Reduce, 0, 36);    // LShiftAssignment
            actionTable[12, 49] = new ParserAction(ParserActions.Reduce, 0, 36);    // RShiftAssignment
            actionTable[12, 50] = new ParserAction(ParserActions.Reduce, 0, 36);    // AndAssignment
            actionTable[12, 51] = new ParserAction(ParserActions.Reduce, 0, 36);    // XorAssignment
            actionTable[12, 52] = new ParserAction(ParserActions.Reduce, 0, 36);    // OrAssignment

            // State 13
            actionTable[13, 0] = new ParserAction(ParserActions.Reduce, 0, 40);    // EOF
            actionTable[13, 13] = new ParserAction(ParserActions.Shift, 62, 0);    // LParan
            actionTable[13, 14] = new ParserAction(ParserActions.Reduce, 0, 40);    // RParan
            actionTable[13, 15] = new ParserAction(ParserActions.Shift, 63, 0);    // LSqr
            actionTable[13, 16] = new ParserAction(ParserActions.Reduce, 0, 40);    // RSqr
            actionTable[13, 17] = new ParserAction(ParserActions.Shift, 64, 0);    // LCurly
            actionTable[13, 18] = new ParserAction(ParserActions.Reduce, 0, 40);    // RCurly
            actionTable[13, 19] = new ParserAction(ParserActions.Reduce, 0, 40);    // Comma
            actionTable[13, 20] = new ParserAction(ParserActions.Shift, 65, 0);    // Dot
            actionTable[13, 21] = new ParserAction(ParserActions.Reduce, 0, 40);    // DotDot
            actionTable[13, 22] = new ParserAction(ParserActions.Reduce, 0, 40);    // Plus
            actionTable[13, 23] = new ParserAction(ParserActions.Reduce, 0, 40);    // Minus
            actionTable[13, 24] = new ParserAction(ParserActions.Reduce, 0, 40);    // Mult
            actionTable[13, 25] = new ParserAction(ParserActions.Reduce, 0, 40);    // Div
            actionTable[13, 26] = new ParserAction(ParserActions.Reduce, 0, 40);    // Mod
            actionTable[13, 27] = new ParserAction(ParserActions.Reduce, 0, 40);    // Equal
            actionTable[13, 28] = new ParserAction(ParserActions.Reduce, 0, 40);    // NotEqual
            actionTable[13, 29] = new ParserAction(ParserActions.Reduce, 0, 40);    // Lesser
            actionTable[13, 30] = new ParserAction(ParserActions.Reduce, 0, 40);    // Greater
            actionTable[13, 31] = new ParserAction(ParserActions.Reduce, 0, 40);    // LesserOrEqual
            actionTable[13, 32] = new ParserAction(ParserActions.Reduce, 0, 40);    // GreaterOrEqual
            actionTable[13, 34] = new ParserAction(ParserActions.Reduce, 0, 40);    // And
            actionTable[13, 35] = new ParserAction(ParserActions.Reduce, 0, 40);    // Or
            actionTable[13, 36] = new ParserAction(ParserActions.Reduce, 0, 40);    // Assignment
            actionTable[13, 37] = new ParserAction(ParserActions.Reduce, 0, 40);    // PlusAssignment
            actionTable[13, 38] = new ParserAction(ParserActions.Reduce, 0, 40);    // MinusAssignment
            actionTable[13, 39] = new ParserAction(ParserActions.Reduce, 0, 40);    // MultAssignment
            actionTable[13, 40] = new ParserAction(ParserActions.Reduce, 0, 40);    // DivAssignment
            actionTable[13, 41] = new ParserAction(ParserActions.Reduce, 0, 40);    // ModAssignment
            actionTable[13, 42] = new ParserAction(ParserActions.Reduce, 0, 40);    // LShift
            actionTable[13, 43] = new ParserAction(ParserActions.Reduce, 0, 40);    // RShift
            actionTable[13, 45] = new ParserAction(ParserActions.Reduce, 0, 40);    // LogicalAnd
            actionTable[13, 46] = new ParserAction(ParserActions.Reduce, 0, 40);    // LogicalOr
            actionTable[13, 47] = new ParserAction(ParserActions.Reduce, 0, 40);    // LogicalXor
            actionTable[13, 48] = new ParserAction(ParserActions.Reduce, 0, 40);    // LShiftAssignment
            actionTable[13, 49] = new ParserAction(ParserActions.Reduce, 0, 40);    // RShiftAssignment
            actionTable[13, 50] = new ParserAction(ParserActions.Reduce, 0, 40);    // AndAssignment
            actionTable[13, 51] = new ParserAction(ParserActions.Reduce, 0, 40);    // XorAssignment
            actionTable[13, 52] = new ParserAction(ParserActions.Reduce, 0, 40);    // OrAssignment
            actionTable[13, 53] = new ParserAction(ParserActions.Shift, 66, 0);    // PlusPlus
            actionTable[13, 54] = new ParserAction(ParserActions.Shift, 67, 0);    // MinusMinus

            // State 14
            actionTable[14, 0] = new ParserAction(ParserActions.Reduce, 0, 48);    // EOF
            actionTable[14, 13] = new ParserAction(ParserActions.Reduce, 0, 48);    // LParan
            actionTable[14, 14] = new ParserAction(ParserActions.Reduce, 0, 48);    // RParan
            actionTable[14, 15] = new ParserAction(ParserActions.Reduce, 0, 48);    // LSqr
            actionTable[14, 16] = new ParserAction(ParserActions.Reduce, 0, 48);    // RSqr
            actionTable[14, 17] = new ParserAction(ParserActions.Reduce, 0, 48);    // LCurly
            actionTable[14, 18] = new ParserAction(ParserActions.Reduce, 0, 48);    // RCurly
            actionTable[14, 19] = new ParserAction(ParserActions.Reduce, 0, 48);    // Comma
            actionTable[14, 20] = new ParserAction(ParserActions.Reduce, 0, 48);    // Dot
            actionTable[14, 21] = new ParserAction(ParserActions.Reduce, 0, 48);    // DotDot
            actionTable[14, 22] = new ParserAction(ParserActions.Reduce, 0, 48);    // Plus
            actionTable[14, 23] = new ParserAction(ParserActions.Reduce, 0, 48);    // Minus
            actionTable[14, 24] = new ParserAction(ParserActions.Reduce, 0, 48);    // Mult
            actionTable[14, 25] = new ParserAction(ParserActions.Reduce, 0, 48);    // Div
            actionTable[14, 26] = new ParserAction(ParserActions.Reduce, 0, 48);    // Mod
            actionTable[14, 27] = new ParserAction(ParserActions.Reduce, 0, 48);    // Equal
            actionTable[14, 28] = new ParserAction(ParserActions.Reduce, 0, 48);    // NotEqual
            actionTable[14, 29] = new ParserAction(ParserActions.Reduce, 0, 48);    // Lesser
            actionTable[14, 30] = new ParserAction(ParserActions.Reduce, 0, 48);    // Greater
            actionTable[14, 31] = new ParserAction(ParserActions.Reduce, 0, 48);    // LesserOrEqual
            actionTable[14, 32] = new ParserAction(ParserActions.Reduce, 0, 48);    // GreaterOrEqual
            actionTable[14, 34] = new ParserAction(ParserActions.Reduce, 0, 48);    // And
            actionTable[14, 35] = new ParserAction(ParserActions.Reduce, 0, 48);    // Or
            actionTable[14, 36] = new ParserAction(ParserActions.Reduce, 0, 48);    // Assignment
            actionTable[14, 37] = new ParserAction(ParserActions.Reduce, 0, 48);    // PlusAssignment
            actionTable[14, 38] = new ParserAction(ParserActions.Reduce, 0, 48);    // MinusAssignment
            actionTable[14, 39] = new ParserAction(ParserActions.Reduce, 0, 48);    // MultAssignment
            actionTable[14, 40] = new ParserAction(ParserActions.Reduce, 0, 48);    // DivAssignment
            actionTable[14, 41] = new ParserAction(ParserActions.Reduce, 0, 48);    // ModAssignment
            actionTable[14, 42] = new ParserAction(ParserActions.Reduce, 0, 48);    // LShift
            actionTable[14, 43] = new ParserAction(ParserActions.Reduce, 0, 48);    // RShift
            actionTable[14, 45] = new ParserAction(ParserActions.Reduce, 0, 48);    // LogicalAnd
            actionTable[14, 46] = new ParserAction(ParserActions.Reduce, 0, 48);    // LogicalOr
            actionTable[14, 47] = new ParserAction(ParserActions.Reduce, 0, 48);    // LogicalXor
            actionTable[14, 48] = new ParserAction(ParserActions.Reduce, 0, 48);    // LShiftAssignment
            actionTable[14, 49] = new ParserAction(ParserActions.Reduce, 0, 48);    // RShiftAssignment
            actionTable[14, 50] = new ParserAction(ParserActions.Reduce, 0, 48);    // AndAssignment
            actionTable[14, 51] = new ParserAction(ParserActions.Reduce, 0, 48);    // XorAssignment
            actionTable[14, 52] = new ParserAction(ParserActions.Reduce, 0, 48);    // OrAssignment
            actionTable[14, 53] = new ParserAction(ParserActions.Reduce, 0, 48);    // PlusPlus
            actionTable[14, 54] = new ParserAction(ParserActions.Reduce, 0, 48);    // MinusMinus

            // State 15
            actionTable[15, 12] = new ParserAction(ParserActions.Shift, 68, 0);    // Identifier

            // State 16
            actionTable[16, 0] = new ParserAction(ParserActions.Reduce, 0, 58);    // EOF
            actionTable[16, 13] = new ParserAction(ParserActions.Reduce, 0, 58);    // LParan
            actionTable[16, 14] = new ParserAction(ParserActions.Reduce, 0, 58);    // RParan
            actionTable[16, 15] = new ParserAction(ParserActions.Reduce, 0, 58);    // LSqr
            actionTable[16, 16] = new ParserAction(ParserActions.Reduce, 0, 58);    // RSqr
            actionTable[16, 17] = new ParserAction(ParserActions.Reduce, 0, 58);    // LCurly
            actionTable[16, 18] = new ParserAction(ParserActions.Reduce, 0, 58);    // RCurly
            actionTable[16, 19] = new ParserAction(ParserActions.Reduce, 0, 58);    // Comma
            actionTable[16, 20] = new ParserAction(ParserActions.Reduce, 0, 58);    // Dot
            actionTable[16, 21] = new ParserAction(ParserActions.Reduce, 0, 58);    // DotDot
            actionTable[16, 22] = new ParserAction(ParserActions.Reduce, 0, 58);    // Plus
            actionTable[16, 23] = new ParserAction(ParserActions.Reduce, 0, 58);    // Minus
            actionTable[16, 24] = new ParserAction(ParserActions.Reduce, 0, 58);    // Mult
            actionTable[16, 25] = new ParserAction(ParserActions.Reduce, 0, 58);    // Div
            actionTable[16, 26] = new ParserAction(ParserActions.Reduce, 0, 58);    // Mod
            actionTable[16, 27] = new ParserAction(ParserActions.Reduce, 0, 58);    // Equal
            actionTable[16, 28] = new ParserAction(ParserActions.Reduce, 0, 58);    // NotEqual
            actionTable[16, 29] = new ParserAction(ParserActions.Reduce, 0, 58);    // Lesser
            actionTable[16, 30] = new ParserAction(ParserActions.Reduce, 0, 58);    // Greater
            actionTable[16, 31] = new ParserAction(ParserActions.Reduce, 0, 58);    // LesserOrEqual
            actionTable[16, 32] = new ParserAction(ParserActions.Reduce, 0, 58);    // GreaterOrEqual
            actionTable[16, 34] = new ParserAction(ParserActions.Reduce, 0, 58);    // And
            actionTable[16, 35] = new ParserAction(ParserActions.Reduce, 0, 58);    // Or
            actionTable[16, 36] = new ParserAction(ParserActions.Reduce, 0, 58);    // Assignment
            actionTable[16, 37] = new ParserAction(ParserActions.Reduce, 0, 58);    // PlusAssignment
            actionTable[16, 38] = new ParserAction(ParserActions.Reduce, 0, 58);    // MinusAssignment
            actionTable[16, 39] = new ParserAction(ParserActions.Reduce, 0, 58);    // MultAssignment
            actionTable[16, 40] = new ParserAction(ParserActions.Reduce, 0, 58);    // DivAssignment
            actionTable[16, 41] = new ParserAction(ParserActions.Reduce, 0, 58);    // ModAssignment
            actionTable[16, 42] = new ParserAction(ParserActions.Reduce, 0, 58);    // LShift
            actionTable[16, 43] = new ParserAction(ParserActions.Reduce, 0, 58);    // RShift
            actionTable[16, 45] = new ParserAction(ParserActions.Reduce, 0, 58);    // LogicalAnd
            actionTable[16, 46] = new ParserAction(ParserActions.Reduce, 0, 58);    // LogicalOr
            actionTable[16, 47] = new ParserAction(ParserActions.Reduce, 0, 58);    // LogicalXor
            actionTable[16, 48] = new ParserAction(ParserActions.Reduce, 0, 58);    // LShiftAssignment
            actionTable[16, 49] = new ParserAction(ParserActions.Reduce, 0, 58);    // RShiftAssignment
            actionTable[16, 50] = new ParserAction(ParserActions.Reduce, 0, 58);    // AndAssignment
            actionTable[16, 51] = new ParserAction(ParserActions.Reduce, 0, 58);    // XorAssignment
            actionTable[16, 52] = new ParserAction(ParserActions.Reduce, 0, 58);    // OrAssignment
            actionTable[16, 53] = new ParserAction(ParserActions.Reduce, 0, 58);    // PlusPlus
            actionTable[16, 54] = new ParserAction(ParserActions.Reduce, 0, 58);    // MinusMinus

            // State 17
            actionTable[17, 0] = new ParserAction(ParserActions.Reduce, 0, 59);    // EOF
            actionTable[17, 13] = new ParserAction(ParserActions.Reduce, 0, 59);    // LParan
            actionTable[17, 14] = new ParserAction(ParserActions.Reduce, 0, 59);    // RParan
            actionTable[17, 15] = new ParserAction(ParserActions.Reduce, 0, 59);    // LSqr
            actionTable[17, 16] = new ParserAction(ParserActions.Reduce, 0, 59);    // RSqr
            actionTable[17, 17] = new ParserAction(ParserActions.Reduce, 0, 59);    // LCurly
            actionTable[17, 18] = new ParserAction(ParserActions.Reduce, 0, 59);    // RCurly
            actionTable[17, 19] = new ParserAction(ParserActions.Reduce, 0, 59);    // Comma
            actionTable[17, 20] = new ParserAction(ParserActions.Reduce, 0, 59);    // Dot
            actionTable[17, 21] = new ParserAction(ParserActions.Reduce, 0, 59);    // DotDot
            actionTable[17, 22] = new ParserAction(ParserActions.Reduce, 0, 59);    // Plus
            actionTable[17, 23] = new ParserAction(ParserActions.Reduce, 0, 59);    // Minus
            actionTable[17, 24] = new ParserAction(ParserActions.Reduce, 0, 59);    // Mult
            actionTable[17, 25] = new ParserAction(ParserActions.Reduce, 0, 59);    // Div
            actionTable[17, 26] = new ParserAction(ParserActions.Reduce, 0, 59);    // Mod
            actionTable[17, 27] = new ParserAction(ParserActions.Reduce, 0, 59);    // Equal
            actionTable[17, 28] = new ParserAction(ParserActions.Reduce, 0, 59);    // NotEqual
            actionTable[17, 29] = new ParserAction(ParserActions.Reduce, 0, 59);    // Lesser
            actionTable[17, 30] = new ParserAction(ParserActions.Reduce, 0, 59);    // Greater
            actionTable[17, 31] = new ParserAction(ParserActions.Reduce, 0, 59);    // LesserOrEqual
            actionTable[17, 32] = new ParserAction(ParserActions.Reduce, 0, 59);    // GreaterOrEqual
            actionTable[17, 34] = new ParserAction(ParserActions.Reduce, 0, 59);    // And
            actionTable[17, 35] = new ParserAction(ParserActions.Reduce, 0, 59);    // Or
            actionTable[17, 36] = new ParserAction(ParserActions.Reduce, 0, 59);    // Assignment
            actionTable[17, 37] = new ParserAction(ParserActions.Reduce, 0, 59);    // PlusAssignment
            actionTable[17, 38] = new ParserAction(ParserActions.Reduce, 0, 59);    // MinusAssignment
            actionTable[17, 39] = new ParserAction(ParserActions.Reduce, 0, 59);    // MultAssignment
            actionTable[17, 40] = new ParserAction(ParserActions.Reduce, 0, 59);    // DivAssignment
            actionTable[17, 41] = new ParserAction(ParserActions.Reduce, 0, 59);    // ModAssignment
            actionTable[17, 42] = new ParserAction(ParserActions.Reduce, 0, 59);    // LShift
            actionTable[17, 43] = new ParserAction(ParserActions.Reduce, 0, 59);    // RShift
            actionTable[17, 45] = new ParserAction(ParserActions.Reduce, 0, 59);    // LogicalAnd
            actionTable[17, 46] = new ParserAction(ParserActions.Reduce, 0, 59);    // LogicalOr
            actionTable[17, 47] = new ParserAction(ParserActions.Reduce, 0, 59);    // LogicalXor
            actionTable[17, 48] = new ParserAction(ParserActions.Reduce, 0, 59);    // LShiftAssignment
            actionTable[17, 49] = new ParserAction(ParserActions.Reduce, 0, 59);    // RShiftAssignment
            actionTable[17, 50] = new ParserAction(ParserActions.Reduce, 0, 59);    // AndAssignment
            actionTable[17, 51] = new ParserAction(ParserActions.Reduce, 0, 59);    // XorAssignment
            actionTable[17, 52] = new ParserAction(ParserActions.Reduce, 0, 59);    // OrAssignment
            actionTable[17, 53] = new ParserAction(ParserActions.Reduce, 0, 59);    // PlusPlus
            actionTable[17, 54] = new ParserAction(ParserActions.Reduce, 0, 59);    // MinusMinus

            // State 18
            actionTable[18, 0] = new ParserAction(ParserActions.Reduce, 0, 60);    // EOF
            actionTable[18, 13] = new ParserAction(ParserActions.Reduce, 0, 60);    // LParan
            actionTable[18, 14] = new ParserAction(ParserActions.Reduce, 0, 60);    // RParan
            actionTable[18, 15] = new ParserAction(ParserActions.Reduce, 0, 60);    // LSqr
            actionTable[18, 16] = new ParserAction(ParserActions.Reduce, 0, 60);    // RSqr
            actionTable[18, 17] = new ParserAction(ParserActions.Reduce, 0, 60);    // LCurly
            actionTable[18, 18] = new ParserAction(ParserActions.Reduce, 0, 60);    // RCurly
            actionTable[18, 19] = new ParserAction(ParserActions.Reduce, 0, 60);    // Comma
            actionTable[18, 20] = new ParserAction(ParserActions.Reduce, 0, 60);    // Dot
            actionTable[18, 21] = new ParserAction(ParserActions.Reduce, 0, 60);    // DotDot
            actionTable[18, 22] = new ParserAction(ParserActions.Reduce, 0, 60);    // Plus
            actionTable[18, 23] = new ParserAction(ParserActions.Reduce, 0, 60);    // Minus
            actionTable[18, 24] = new ParserAction(ParserActions.Reduce, 0, 60);    // Mult
            actionTable[18, 25] = new ParserAction(ParserActions.Reduce, 0, 60);    // Div
            actionTable[18, 26] = new ParserAction(ParserActions.Reduce, 0, 60);    // Mod
            actionTable[18, 27] = new ParserAction(ParserActions.Reduce, 0, 60);    // Equal
            actionTable[18, 28] = new ParserAction(ParserActions.Reduce, 0, 60);    // NotEqual
            actionTable[18, 29] = new ParserAction(ParserActions.Reduce, 0, 60);    // Lesser
            actionTable[18, 30] = new ParserAction(ParserActions.Reduce, 0, 60);    // Greater
            actionTable[18, 31] = new ParserAction(ParserActions.Reduce, 0, 60);    // LesserOrEqual
            actionTable[18, 32] = new ParserAction(ParserActions.Reduce, 0, 60);    // GreaterOrEqual
            actionTable[18, 34] = new ParserAction(ParserActions.Reduce, 0, 60);    // And
            actionTable[18, 35] = new ParserAction(ParserActions.Reduce, 0, 60);    // Or
            actionTable[18, 36] = new ParserAction(ParserActions.Reduce, 0, 60);    // Assignment
            actionTable[18, 37] = new ParserAction(ParserActions.Reduce, 0, 60);    // PlusAssignment
            actionTable[18, 38] = new ParserAction(ParserActions.Reduce, 0, 60);    // MinusAssignment
            actionTable[18, 39] = new ParserAction(ParserActions.Reduce, 0, 60);    // MultAssignment
            actionTable[18, 40] = new ParserAction(ParserActions.Reduce, 0, 60);    // DivAssignment
            actionTable[18, 41] = new ParserAction(ParserActions.Reduce, 0, 60);    // ModAssignment
            actionTable[18, 42] = new ParserAction(ParserActions.Reduce, 0, 60);    // LShift
            actionTable[18, 43] = new ParserAction(ParserActions.Reduce, 0, 60);    // RShift
            actionTable[18, 45] = new ParserAction(ParserActions.Reduce, 0, 60);    // LogicalAnd
            actionTable[18, 46] = new ParserAction(ParserActions.Reduce, 0, 60);    // LogicalOr
            actionTable[18, 47] = new ParserAction(ParserActions.Reduce, 0, 60);    // LogicalXor
            actionTable[18, 48] = new ParserAction(ParserActions.Reduce, 0, 60);    // LShiftAssignment
            actionTable[18, 49] = new ParserAction(ParserActions.Reduce, 0, 60);    // RShiftAssignment
            actionTable[18, 50] = new ParserAction(ParserActions.Reduce, 0, 60);    // AndAssignment
            actionTable[18, 51] = new ParserAction(ParserActions.Reduce, 0, 60);    // XorAssignment
            actionTable[18, 52] = new ParserAction(ParserActions.Reduce, 0, 60);    // OrAssignment
            actionTable[18, 53] = new ParserAction(ParserActions.Reduce, 0, 60);    // PlusPlus
            actionTable[18, 54] = new ParserAction(ParserActions.Reduce, 0, 60);    // MinusMinus

            // State 19
            actionTable[19, 0] = new ParserAction(ParserActions.Reduce, 0, 61);    // EOF
            actionTable[19, 13] = new ParserAction(ParserActions.Reduce, 0, 61);    // LParan
            actionTable[19, 14] = new ParserAction(ParserActions.Reduce, 0, 61);    // RParan
            actionTable[19, 15] = new ParserAction(ParserActions.Reduce, 0, 61);    // LSqr
            actionTable[19, 16] = new ParserAction(ParserActions.Reduce, 0, 61);    // RSqr
            actionTable[19, 17] = new ParserAction(ParserActions.Reduce, 0, 61);    // LCurly
            actionTable[19, 18] = new ParserAction(ParserActions.Reduce, 0, 61);    // RCurly
            actionTable[19, 19] = new ParserAction(ParserActions.Reduce, 0, 61);    // Comma
            actionTable[19, 20] = new ParserAction(ParserActions.Reduce, 0, 61);    // Dot
            actionTable[19, 21] = new ParserAction(ParserActions.Reduce, 0, 61);    // DotDot
            actionTable[19, 22] = new ParserAction(ParserActions.Reduce, 0, 61);    // Plus
            actionTable[19, 23] = new ParserAction(ParserActions.Reduce, 0, 61);    // Minus
            actionTable[19, 24] = new ParserAction(ParserActions.Reduce, 0, 61);    // Mult
            actionTable[19, 25] = new ParserAction(ParserActions.Reduce, 0, 61);    // Div
            actionTable[19, 26] = new ParserAction(ParserActions.Reduce, 0, 61);    // Mod
            actionTable[19, 27] = new ParserAction(ParserActions.Reduce, 0, 61);    // Equal
            actionTable[19, 28] = new ParserAction(ParserActions.Reduce, 0, 61);    // NotEqual
            actionTable[19, 29] = new ParserAction(ParserActions.Reduce, 0, 61);    // Lesser
            actionTable[19, 30] = new ParserAction(ParserActions.Reduce, 0, 61);    // Greater
            actionTable[19, 31] = new ParserAction(ParserActions.Reduce, 0, 61);    // LesserOrEqual
            actionTable[19, 32] = new ParserAction(ParserActions.Reduce, 0, 61);    // GreaterOrEqual
            actionTable[19, 34] = new ParserAction(ParserActions.Reduce, 0, 61);    // And
            actionTable[19, 35] = new ParserAction(ParserActions.Reduce, 0, 61);    // Or
            actionTable[19, 36] = new ParserAction(ParserActions.Reduce, 0, 61);    // Assignment
            actionTable[19, 37] = new ParserAction(ParserActions.Reduce, 0, 61);    // PlusAssignment
            actionTable[19, 38] = new ParserAction(ParserActions.Reduce, 0, 61);    // MinusAssignment
            actionTable[19, 39] = new ParserAction(ParserActions.Reduce, 0, 61);    // MultAssignment
            actionTable[19, 40] = new ParserAction(ParserActions.Reduce, 0, 61);    // DivAssignment
            actionTable[19, 41] = new ParserAction(ParserActions.Reduce, 0, 61);    // ModAssignment
            actionTable[19, 42] = new ParserAction(ParserActions.Reduce, 0, 61);    // LShift
            actionTable[19, 43] = new ParserAction(ParserActions.Reduce, 0, 61);    // RShift
            actionTable[19, 45] = new ParserAction(ParserActions.Reduce, 0, 61);    // LogicalAnd
            actionTable[19, 46] = new ParserAction(ParserActions.Reduce, 0, 61);    // LogicalOr
            actionTable[19, 47] = new ParserAction(ParserActions.Reduce, 0, 61);    // LogicalXor
            actionTable[19, 48] = new ParserAction(ParserActions.Reduce, 0, 61);    // LShiftAssignment
            actionTable[19, 49] = new ParserAction(ParserActions.Reduce, 0, 61);    // RShiftAssignment
            actionTable[19, 50] = new ParserAction(ParserActions.Reduce, 0, 61);    // AndAssignment
            actionTable[19, 51] = new ParserAction(ParserActions.Reduce, 0, 61);    // XorAssignment
            actionTable[19, 52] = new ParserAction(ParserActions.Reduce, 0, 61);    // OrAssignment
            actionTable[19, 53] = new ParserAction(ParserActions.Reduce, 0, 61);    // PlusPlus
            actionTable[19, 54] = new ParserAction(ParserActions.Reduce, 0, 61);    // MinusMinus

            // State 20
            actionTable[20, 0] = new ParserAction(ParserActions.Reduce, 0, 62);    // EOF
            actionTable[20, 13] = new ParserAction(ParserActions.Reduce, 0, 62);    // LParan
            actionTable[20, 14] = new ParserAction(ParserActions.Reduce, 0, 62);    // RParan
            actionTable[20, 15] = new ParserAction(ParserActions.Reduce, 0, 62);    // LSqr
            actionTable[20, 16] = new ParserAction(ParserActions.Reduce, 0, 62);    // RSqr
            actionTable[20, 17] = new ParserAction(ParserActions.Reduce, 0, 62);    // LCurly
            actionTable[20, 18] = new ParserAction(ParserActions.Reduce, 0, 62);    // RCurly
            actionTable[20, 19] = new ParserAction(ParserActions.Reduce, 0, 62);    // Comma
            actionTable[20, 20] = new ParserAction(ParserActions.Reduce, 0, 62);    // Dot
            actionTable[20, 21] = new ParserAction(ParserActions.Reduce, 0, 62);    // DotDot
            actionTable[20, 22] = new ParserAction(ParserActions.Reduce, 0, 62);    // Plus
            actionTable[20, 23] = new ParserAction(ParserActions.Reduce, 0, 62);    // Minus
            actionTable[20, 24] = new ParserAction(ParserActions.Reduce, 0, 62);    // Mult
            actionTable[20, 25] = new ParserAction(ParserActions.Reduce, 0, 62);    // Div
            actionTable[20, 26] = new ParserAction(ParserActions.Reduce, 0, 62);    // Mod
            actionTable[20, 27] = new ParserAction(ParserActions.Reduce, 0, 62);    // Equal
            actionTable[20, 28] = new ParserAction(ParserActions.Reduce, 0, 62);    // NotEqual
            actionTable[20, 29] = new ParserAction(ParserActions.Reduce, 0, 62);    // Lesser
            actionTable[20, 30] = new ParserAction(ParserActions.Reduce, 0, 62);    // Greater
            actionTable[20, 31] = new ParserAction(ParserActions.Reduce, 0, 62);    // LesserOrEqual
            actionTable[20, 32] = new ParserAction(ParserActions.Reduce, 0, 62);    // GreaterOrEqual
            actionTable[20, 34] = new ParserAction(ParserActions.Reduce, 0, 62);    // And
            actionTable[20, 35] = new ParserAction(ParserActions.Reduce, 0, 62);    // Or
            actionTable[20, 36] = new ParserAction(ParserActions.Reduce, 0, 62);    // Assignment
            actionTable[20, 37] = new ParserAction(ParserActions.Reduce, 0, 62);    // PlusAssignment
            actionTable[20, 38] = new ParserAction(ParserActions.Reduce, 0, 62);    // MinusAssignment
            actionTable[20, 39] = new ParserAction(ParserActions.Reduce, 0, 62);    // MultAssignment
            actionTable[20, 40] = new ParserAction(ParserActions.Reduce, 0, 62);    // DivAssignment
            actionTable[20, 41] = new ParserAction(ParserActions.Reduce, 0, 62);    // ModAssignment
            actionTable[20, 42] = new ParserAction(ParserActions.Reduce, 0, 62);    // LShift
            actionTable[20, 43] = new ParserAction(ParserActions.Reduce, 0, 62);    // RShift
            actionTable[20, 45] = new ParserAction(ParserActions.Reduce, 0, 62);    // LogicalAnd
            actionTable[20, 46] = new ParserAction(ParserActions.Reduce, 0, 62);    // LogicalOr
            actionTable[20, 47] = new ParserAction(ParserActions.Reduce, 0, 62);    // LogicalXor
            actionTable[20, 48] = new ParserAction(ParserActions.Reduce, 0, 62);    // LShiftAssignment
            actionTable[20, 49] = new ParserAction(ParserActions.Reduce, 0, 62);    // RShiftAssignment
            actionTable[20, 50] = new ParserAction(ParserActions.Reduce, 0, 62);    // AndAssignment
            actionTable[20, 51] = new ParserAction(ParserActions.Reduce, 0, 62);    // XorAssignment
            actionTable[20, 52] = new ParserAction(ParserActions.Reduce, 0, 62);    // OrAssignment
            actionTable[20, 53] = new ParserAction(ParserActions.Reduce, 0, 62);    // PlusPlus
            actionTable[20, 54] = new ParserAction(ParserActions.Reduce, 0, 62);    // MinusMinus

            // State 21
            actionTable[21, 0] = new ParserAction(ParserActions.Reduce, 0, 63);    // EOF
            actionTable[21, 13] = new ParserAction(ParserActions.Reduce, 0, 63);    // LParan
            actionTable[21, 14] = new ParserAction(ParserActions.Reduce, 0, 63);    // RParan
            actionTable[21, 15] = new ParserAction(ParserActions.Reduce, 0, 63);    // LSqr
            actionTable[21, 16] = new ParserAction(ParserActions.Reduce, 0, 63);    // RSqr
            actionTable[21, 17] = new ParserAction(ParserActions.Reduce, 0, 63);    // LCurly
            actionTable[21, 18] = new ParserAction(ParserActions.Reduce, 0, 63);    // RCurly
            actionTable[21, 19] = new ParserAction(ParserActions.Reduce, 0, 63);    // Comma
            actionTable[21, 20] = new ParserAction(ParserActions.Reduce, 0, 63);    // Dot
            actionTable[21, 21] = new ParserAction(ParserActions.Reduce, 0, 63);    // DotDot
            actionTable[21, 22] = new ParserAction(ParserActions.Reduce, 0, 63);    // Plus
            actionTable[21, 23] = new ParserAction(ParserActions.Reduce, 0, 63);    // Minus
            actionTable[21, 24] = new ParserAction(ParserActions.Reduce, 0, 63);    // Mult
            actionTable[21, 25] = new ParserAction(ParserActions.Reduce, 0, 63);    // Div
            actionTable[21, 26] = new ParserAction(ParserActions.Reduce, 0, 63);    // Mod
            actionTable[21, 27] = new ParserAction(ParserActions.Reduce, 0, 63);    // Equal
            actionTable[21, 28] = new ParserAction(ParserActions.Reduce, 0, 63);    // NotEqual
            actionTable[21, 29] = new ParserAction(ParserActions.Reduce, 0, 63);    // Lesser
            actionTable[21, 30] = new ParserAction(ParserActions.Reduce, 0, 63);    // Greater
            actionTable[21, 31] = new ParserAction(ParserActions.Reduce, 0, 63);    // LesserOrEqual
            actionTable[21, 32] = new ParserAction(ParserActions.Reduce, 0, 63);    // GreaterOrEqual
            actionTable[21, 34] = new ParserAction(ParserActions.Reduce, 0, 63);    // And
            actionTable[21, 35] = new ParserAction(ParserActions.Reduce, 0, 63);    // Or
            actionTable[21, 36] = new ParserAction(ParserActions.Reduce, 0, 63);    // Assignment
            actionTable[21, 37] = new ParserAction(ParserActions.Reduce, 0, 63);    // PlusAssignment
            actionTable[21, 38] = new ParserAction(ParserActions.Reduce, 0, 63);    // MinusAssignment
            actionTable[21, 39] = new ParserAction(ParserActions.Reduce, 0, 63);    // MultAssignment
            actionTable[21, 40] = new ParserAction(ParserActions.Reduce, 0, 63);    // DivAssignment
            actionTable[21, 41] = new ParserAction(ParserActions.Reduce, 0, 63);    // ModAssignment
            actionTable[21, 42] = new ParserAction(ParserActions.Reduce, 0, 63);    // LShift
            actionTable[21, 43] = new ParserAction(ParserActions.Reduce, 0, 63);    // RShift
            actionTable[21, 45] = new ParserAction(ParserActions.Reduce, 0, 63);    // LogicalAnd
            actionTable[21, 46] = new ParserAction(ParserActions.Reduce, 0, 63);    // LogicalOr
            actionTable[21, 47] = new ParserAction(ParserActions.Reduce, 0, 63);    // LogicalXor
            actionTable[21, 48] = new ParserAction(ParserActions.Reduce, 0, 63);    // LShiftAssignment
            actionTable[21, 49] = new ParserAction(ParserActions.Reduce, 0, 63);    // RShiftAssignment
            actionTable[21, 50] = new ParserAction(ParserActions.Reduce, 0, 63);    // AndAssignment
            actionTable[21, 51] = new ParserAction(ParserActions.Reduce, 0, 63);    // XorAssignment
            actionTable[21, 52] = new ParserAction(ParserActions.Reduce, 0, 63);    // OrAssignment
            actionTable[21, 53] = new ParserAction(ParserActions.Reduce, 0, 63);    // PlusPlus
            actionTable[21, 54] = new ParserAction(ParserActions.Reduce, 0, 63);    // MinusMinus

            // State 22
            actionTable[22, 0] = new ParserAction(ParserActions.Reduce, 0, 64);    // EOF
            actionTable[22, 13] = new ParserAction(ParserActions.Reduce, 0, 64);    // LParan
            actionTable[22, 14] = new ParserAction(ParserActions.Reduce, 0, 64);    // RParan
            actionTable[22, 15] = new ParserAction(ParserActions.Reduce, 0, 64);    // LSqr
            actionTable[22, 16] = new ParserAction(ParserActions.Reduce, 0, 64);    // RSqr
            actionTable[22, 17] = new ParserAction(ParserActions.Reduce, 0, 64);    // LCurly
            actionTable[22, 18] = new ParserAction(ParserActions.Reduce, 0, 64);    // RCurly
            actionTable[22, 19] = new ParserAction(ParserActions.Reduce, 0, 64);    // Comma
            actionTable[22, 20] = new ParserAction(ParserActions.Reduce, 0, 64);    // Dot
            actionTable[22, 21] = new ParserAction(ParserActions.Reduce, 0, 64);    // DotDot
            actionTable[22, 22] = new ParserAction(ParserActions.Reduce, 0, 64);    // Plus
            actionTable[22, 23] = new ParserAction(ParserActions.Reduce, 0, 64);    // Minus
            actionTable[22, 24] = new ParserAction(ParserActions.Reduce, 0, 64);    // Mult
            actionTable[22, 25] = new ParserAction(ParserActions.Reduce, 0, 64);    // Div
            actionTable[22, 26] = new ParserAction(ParserActions.Reduce, 0, 64);    // Mod
            actionTable[22, 27] = new ParserAction(ParserActions.Reduce, 0, 64);    // Equal
            actionTable[22, 28] = new ParserAction(ParserActions.Reduce, 0, 64);    // NotEqual
            actionTable[22, 29] = new ParserAction(ParserActions.Reduce, 0, 64);    // Lesser
            actionTable[22, 30] = new ParserAction(ParserActions.Reduce, 0, 64);    // Greater
            actionTable[22, 31] = new ParserAction(ParserActions.Reduce, 0, 64);    // LesserOrEqual
            actionTable[22, 32] = new ParserAction(ParserActions.Reduce, 0, 64);    // GreaterOrEqual
            actionTable[22, 34] = new ParserAction(ParserActions.Reduce, 0, 64);    // And
            actionTable[22, 35] = new ParserAction(ParserActions.Reduce, 0, 64);    // Or
            actionTable[22, 36] = new ParserAction(ParserActions.Reduce, 0, 64);    // Assignment
            actionTable[22, 37] = new ParserAction(ParserActions.Reduce, 0, 64);    // PlusAssignment
            actionTable[22, 38] = new ParserAction(ParserActions.Reduce, 0, 64);    // MinusAssignment
            actionTable[22, 39] = new ParserAction(ParserActions.Reduce, 0, 64);    // MultAssignment
            actionTable[22, 40] = new ParserAction(ParserActions.Reduce, 0, 64);    // DivAssignment
            actionTable[22, 41] = new ParserAction(ParserActions.Reduce, 0, 64);    // ModAssignment
            actionTable[22, 42] = new ParserAction(ParserActions.Reduce, 0, 64);    // LShift
            actionTable[22, 43] = new ParserAction(ParserActions.Reduce, 0, 64);    // RShift
            actionTable[22, 45] = new ParserAction(ParserActions.Reduce, 0, 64);    // LogicalAnd
            actionTable[22, 46] = new ParserAction(ParserActions.Reduce, 0, 64);    // LogicalOr
            actionTable[22, 47] = new ParserAction(ParserActions.Reduce, 0, 64);    // LogicalXor
            actionTable[22, 48] = new ParserAction(ParserActions.Reduce, 0, 64);    // LShiftAssignment
            actionTable[22, 49] = new ParserAction(ParserActions.Reduce, 0, 64);    // RShiftAssignment
            actionTable[22, 50] = new ParserAction(ParserActions.Reduce, 0, 64);    // AndAssignment
            actionTable[22, 51] = new ParserAction(ParserActions.Reduce, 0, 64);    // XorAssignment
            actionTable[22, 52] = new ParserAction(ParserActions.Reduce, 0, 64);    // OrAssignment
            actionTable[22, 53] = new ParserAction(ParserActions.Reduce, 0, 64);    // PlusPlus
            actionTable[22, 54] = new ParserAction(ParserActions.Reduce, 0, 64);    // MinusMinus

            // State 23
            actionTable[23, 12] = new ParserAction(ParserActions.Shift, 69, 0);    // Identifier

            // State 24
            actionTable[24, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[24, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[24, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[24, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[24, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[24, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[24, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[24, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[24, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[24, 12] = new ParserAction(ParserActions.Shift, 71, 0);    // Identifier
            actionTable[24, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[24, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[24, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[24, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[24, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[24, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[24, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[24, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[24, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 25
            actionTable[25, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[25, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[25, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[25, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[25, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[25, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[25, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[25, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[25, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[25, 12] = new ParserAction(ParserActions.Shift, 73, 0);    // Identifier
            actionTable[25, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[25, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[25, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[25, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[25, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[25, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[25, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[25, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[25, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 26
            actionTable[26, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[26, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[26, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[26, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[26, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[26, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[26, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[26, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[26, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[26, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[26, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[26, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[26, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[26, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[26, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[26, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[26, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[26, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[26, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[26, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[26, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[26, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 27
            actionTable[27, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[27, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[27, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[27, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[27, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[27, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[27, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[27, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[27, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[27, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[27, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[27, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[27, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[27, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[27, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[27, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[27, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[27, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 28
            actionTable[28, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[28, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[28, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[28, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[28, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[28, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[28, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[28, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[28, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[28, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[28, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[28, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[28, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[28, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[28, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[28, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[28, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[28, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 29
            actionTable[29, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[29, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[29, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[29, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[29, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[29, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[29, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[29, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[29, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[29, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[29, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[29, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[29, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[29, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[29, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[29, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[29, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[29, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 30
            actionTable[30, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[30, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[30, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[30, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[30, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[30, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[30, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[30, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[30, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[30, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[30, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[30, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[30, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[30, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[30, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[30, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[30, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[30, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 31
            actionTable[31, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[31, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[31, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[31, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[31, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[31, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[31, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[31, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[31, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[31, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[31, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[31, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[31, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[31, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[31, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[31, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[31, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[31, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 32
            actionTable[32, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[32, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[32, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[32, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[32, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[32, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[32, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[32, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[32, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[32, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[32, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[32, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[32, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[32, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[32, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[32, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[32, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[32, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 33
            actionTable[33, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[33, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[33, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[33, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[33, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[33, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[33, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[33, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[33, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[33, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[33, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[33, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[33, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[33, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[33, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[33, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[33, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[33, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 34
            actionTable[34, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[34, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[34, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[34, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[34, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[34, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[34, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[34, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[34, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[34, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[34, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[34, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[34, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[34, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[34, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[34, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[34, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[34, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 35
            actionTable[35, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[35, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[35, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[35, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[35, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[35, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[35, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[35, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[35, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[35, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[35, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[35, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[35, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[35, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[35, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[35, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[35, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[35, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 36
            actionTable[36, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[36, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[36, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[36, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[36, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[36, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[36, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[36, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[36, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[36, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[36, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[36, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[36, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[36, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[36, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[36, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[36, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[36, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 37
            actionTable[37, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[37, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[37, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[37, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[37, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[37, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[37, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[37, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[37, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[37, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[37, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[37, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[37, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[37, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[37, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[37, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[37, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[37, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 38
            actionTable[38, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[38, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[38, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[38, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[38, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[38, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[38, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[38, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[38, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[38, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[38, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[38, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[38, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[38, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[38, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[38, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[38, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[38, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 39
            actionTable[39, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[39, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[39, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[39, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[39, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[39, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[39, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[39, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[39, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[39, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[39, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[39, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[39, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[39, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[39, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[39, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[39, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[39, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 40
            actionTable[40, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[40, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[40, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[40, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[40, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[40, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[40, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[40, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[40, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[40, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[40, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[40, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[40, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[40, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[40, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[40, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[40, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[40, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 41
            actionTable[41, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[41, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[41, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[41, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[41, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[41, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[41, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[41, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[41, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[41, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[41, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[41, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[41, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[41, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[41, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[41, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[41, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[41, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 42
            actionTable[42, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[42, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[42, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[42, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[42, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[42, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[42, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[42, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[42, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[42, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[42, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[42, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[42, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[42, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[42, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[42, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[42, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[42, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 43
            actionTable[43, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[43, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[43, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[43, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[43, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[43, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[43, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[43, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[43, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[43, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[43, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[43, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[43, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[43, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[43, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[43, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[43, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[43, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 44
            actionTable[44, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[44, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[44, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[44, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[44, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[44, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[44, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[44, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[44, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[44, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[44, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[44, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[44, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[44, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[44, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[44, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[44, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[44, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 45
            actionTable[45, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[45, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[45, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[45, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[45, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[45, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[45, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[45, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[45, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[45, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[45, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[45, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[45, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[45, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[45, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[45, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[45, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[45, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 46
            actionTable[46, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[46, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[46, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[46, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[46, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[46, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[46, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[46, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[46, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[46, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[46, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[46, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[46, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[46, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[46, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[46, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[46, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[46, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 47
            actionTable[47, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[47, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[47, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[47, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[47, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[47, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[47, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[47, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[47, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[47, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[47, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[47, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[47, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[47, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[47, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[47, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[47, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[47, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 48
            actionTable[48, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[48, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[48, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[48, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[48, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[48, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[48, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[48, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[48, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[48, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[48, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[48, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[48, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[48, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[48, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[48, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[48, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[48, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 49
            actionTable[49, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[49, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[49, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[49, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[49, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[49, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[49, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[49, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[49, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[49, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[49, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[49, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[49, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[49, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[49, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[49, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[49, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[49, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 50
            actionTable[50, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[50, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[50, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[50, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[50, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[50, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[50, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[50, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[50, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[50, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[50, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[50, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[50, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[50, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[50, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[50, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[50, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[50, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 51
            actionTable[51, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[51, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[51, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[51, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[51, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[51, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[51, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[51, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[51, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[51, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[51, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[51, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[51, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[51, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[51, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[51, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[51, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[51, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 52
            actionTable[52, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[52, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[52, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[52, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[52, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[52, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[52, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[52, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[52, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[52, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[52, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[52, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[52, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[52, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[52, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[52, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[52, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[52, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 53
            actionTable[53, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[53, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[53, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[53, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[53, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[53, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[53, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[53, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[53, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[53, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[53, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[53, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[53, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[53, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[53, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[53, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[53, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[53, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 54
            actionTable[54, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[54, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[54, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[54, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[54, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[54, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[54, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[54, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[54, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[54, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[54, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[54, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[54, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[54, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[54, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[54, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[54, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[54, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 55
            actionTable[55, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[55, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[55, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[55, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[55, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[55, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[55, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[55, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[55, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[55, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[55, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[55, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[55, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[55, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[55, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[55, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[55, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[55, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 56
            actionTable[56, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[56, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[56, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[56, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[56, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[56, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[56, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[56, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[56, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[56, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[56, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[56, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[56, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[56, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[56, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[56, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[56, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[56, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 57
            actionTable[57, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[57, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[57, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[57, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[57, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[57, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[57, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[57, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[57, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[57, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[57, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[57, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[57, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[57, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[57, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[57, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[57, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[57, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 58
            actionTable[58, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[58, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[58, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[58, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[58, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[58, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[58, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[58, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[58, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[58, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[58, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[58, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[58, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[58, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[58, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[58, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[58, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[58, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 59
            actionTable[59, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[59, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[59, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[59, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[59, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[59, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[59, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[59, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[59, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[59, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[59, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[59, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[59, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[59, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[59, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[59, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[59, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[59, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 60
            actionTable[60, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[60, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[60, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[60, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[60, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[60, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[60, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[60, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[60, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[60, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[60, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[60, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[60, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[60, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[60, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[60, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[60, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[60, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 61
            actionTable[61, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[61, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[61, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[61, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[61, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[61, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[61, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[61, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[61, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[61, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[61, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[61, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[61, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[61, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[61, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[61, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[61, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[61, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 62
            actionTable[62, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[62, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[62, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[62, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[62, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[62, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[62, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[62, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[62, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[62, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[62, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[62, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[62, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[62, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[62, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[62, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[62, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[62, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[62, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[62, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[62, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[62, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 63
            actionTable[63, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[63, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[63, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[63, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[63, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[63, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[63, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[63, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[63, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[63, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[63, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[63, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[63, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[63, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[63, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[63, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[63, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[63, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[63, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[63, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[63, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[63, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 64
            actionTable[64, 12] = new ParserAction(ParserActions.Shift, 116, 0);    // Identifier

            // State 65
            actionTable[65, 12] = new ParserAction(ParserActions.Shift, 117, 0);    // Identifier

            // State 66
            actionTable[66, 0] = new ParserAction(ParserActions.Reduce, 0, 54);    // EOF
            actionTable[66, 13] = new ParserAction(ParserActions.Reduce, 0, 54);    // LParan
            actionTable[66, 14] = new ParserAction(ParserActions.Reduce, 0, 54);    // RParan
            actionTable[66, 15] = new ParserAction(ParserActions.Reduce, 0, 54);    // LSqr
            actionTable[66, 16] = new ParserAction(ParserActions.Reduce, 0, 54);    // RSqr
            actionTable[66, 17] = new ParserAction(ParserActions.Reduce, 0, 54);    // LCurly
            actionTable[66, 18] = new ParserAction(ParserActions.Reduce, 0, 54);    // RCurly
            actionTable[66, 19] = new ParserAction(ParserActions.Reduce, 0, 54);    // Comma
            actionTable[66, 20] = new ParserAction(ParserActions.Reduce, 0, 54);    // Dot
            actionTable[66, 21] = new ParserAction(ParserActions.Reduce, 0, 54);    // DotDot
            actionTable[66, 22] = new ParserAction(ParserActions.Reduce, 0, 54);    // Plus
            actionTable[66, 23] = new ParserAction(ParserActions.Reduce, 0, 54);    // Minus
            actionTable[66, 24] = new ParserAction(ParserActions.Reduce, 0, 54);    // Mult
            actionTable[66, 25] = new ParserAction(ParserActions.Reduce, 0, 54);    // Div
            actionTable[66, 26] = new ParserAction(ParserActions.Reduce, 0, 54);    // Mod
            actionTable[66, 27] = new ParserAction(ParserActions.Reduce, 0, 54);    // Equal
            actionTable[66, 28] = new ParserAction(ParserActions.Reduce, 0, 54);    // NotEqual
            actionTable[66, 29] = new ParserAction(ParserActions.Reduce, 0, 54);    // Lesser
            actionTable[66, 30] = new ParserAction(ParserActions.Reduce, 0, 54);    // Greater
            actionTable[66, 31] = new ParserAction(ParserActions.Reduce, 0, 54);    // LesserOrEqual
            actionTable[66, 32] = new ParserAction(ParserActions.Reduce, 0, 54);    // GreaterOrEqual
            actionTable[66, 34] = new ParserAction(ParserActions.Reduce, 0, 54);    // And
            actionTable[66, 35] = new ParserAction(ParserActions.Reduce, 0, 54);    // Or
            actionTable[66, 36] = new ParserAction(ParserActions.Reduce, 0, 54);    // Assignment
            actionTable[66, 37] = new ParserAction(ParserActions.Reduce, 0, 54);    // PlusAssignment
            actionTable[66, 38] = new ParserAction(ParserActions.Reduce, 0, 54);    // MinusAssignment
            actionTable[66, 39] = new ParserAction(ParserActions.Reduce, 0, 54);    // MultAssignment
            actionTable[66, 40] = new ParserAction(ParserActions.Reduce, 0, 54);    // DivAssignment
            actionTable[66, 41] = new ParserAction(ParserActions.Reduce, 0, 54);    // ModAssignment
            actionTable[66, 42] = new ParserAction(ParserActions.Reduce, 0, 54);    // LShift
            actionTable[66, 43] = new ParserAction(ParserActions.Reduce, 0, 54);    // RShift
            actionTable[66, 45] = new ParserAction(ParserActions.Reduce, 0, 54);    // LogicalAnd
            actionTable[66, 46] = new ParserAction(ParserActions.Reduce, 0, 54);    // LogicalOr
            actionTable[66, 47] = new ParserAction(ParserActions.Reduce, 0, 54);    // LogicalXor
            actionTable[66, 48] = new ParserAction(ParserActions.Reduce, 0, 54);    // LShiftAssignment
            actionTable[66, 49] = new ParserAction(ParserActions.Reduce, 0, 54);    // RShiftAssignment
            actionTable[66, 50] = new ParserAction(ParserActions.Reduce, 0, 54);    // AndAssignment
            actionTable[66, 51] = new ParserAction(ParserActions.Reduce, 0, 54);    // XorAssignment
            actionTable[66, 52] = new ParserAction(ParserActions.Reduce, 0, 54);    // OrAssignment
            actionTable[66, 53] = new ParserAction(ParserActions.Reduce, 0, 54);    // PlusPlus
            actionTable[66, 54] = new ParserAction(ParserActions.Reduce, 0, 54);    // MinusMinus

            // State 67
            actionTable[67, 0] = new ParserAction(ParserActions.Reduce, 0, 55);    // EOF
            actionTable[67, 13] = new ParserAction(ParserActions.Reduce, 0, 55);    // LParan
            actionTable[67, 14] = new ParserAction(ParserActions.Reduce, 0, 55);    // RParan
            actionTable[67, 15] = new ParserAction(ParserActions.Reduce, 0, 55);    // LSqr
            actionTable[67, 16] = new ParserAction(ParserActions.Reduce, 0, 55);    // RSqr
            actionTable[67, 17] = new ParserAction(ParserActions.Reduce, 0, 55);    // LCurly
            actionTable[67, 18] = new ParserAction(ParserActions.Reduce, 0, 55);    // RCurly
            actionTable[67, 19] = new ParserAction(ParserActions.Reduce, 0, 55);    // Comma
            actionTable[67, 20] = new ParserAction(ParserActions.Reduce, 0, 55);    // Dot
            actionTable[67, 21] = new ParserAction(ParserActions.Reduce, 0, 55);    // DotDot
            actionTable[67, 22] = new ParserAction(ParserActions.Reduce, 0, 55);    // Plus
            actionTable[67, 23] = new ParserAction(ParserActions.Reduce, 0, 55);    // Minus
            actionTable[67, 24] = new ParserAction(ParserActions.Reduce, 0, 55);    // Mult
            actionTable[67, 25] = new ParserAction(ParserActions.Reduce, 0, 55);    // Div
            actionTable[67, 26] = new ParserAction(ParserActions.Reduce, 0, 55);    // Mod
            actionTable[67, 27] = new ParserAction(ParserActions.Reduce, 0, 55);    // Equal
            actionTable[67, 28] = new ParserAction(ParserActions.Reduce, 0, 55);    // NotEqual
            actionTable[67, 29] = new ParserAction(ParserActions.Reduce, 0, 55);    // Lesser
            actionTable[67, 30] = new ParserAction(ParserActions.Reduce, 0, 55);    // Greater
            actionTable[67, 31] = new ParserAction(ParserActions.Reduce, 0, 55);    // LesserOrEqual
            actionTable[67, 32] = new ParserAction(ParserActions.Reduce, 0, 55);    // GreaterOrEqual
            actionTable[67, 34] = new ParserAction(ParserActions.Reduce, 0, 55);    // And
            actionTable[67, 35] = new ParserAction(ParserActions.Reduce, 0, 55);    // Or
            actionTable[67, 36] = new ParserAction(ParserActions.Reduce, 0, 55);    // Assignment
            actionTable[67, 37] = new ParserAction(ParserActions.Reduce, 0, 55);    // PlusAssignment
            actionTable[67, 38] = new ParserAction(ParserActions.Reduce, 0, 55);    // MinusAssignment
            actionTable[67, 39] = new ParserAction(ParserActions.Reduce, 0, 55);    // MultAssignment
            actionTable[67, 40] = new ParserAction(ParserActions.Reduce, 0, 55);    // DivAssignment
            actionTable[67, 41] = new ParserAction(ParserActions.Reduce, 0, 55);    // ModAssignment
            actionTable[67, 42] = new ParserAction(ParserActions.Reduce, 0, 55);    // LShift
            actionTable[67, 43] = new ParserAction(ParserActions.Reduce, 0, 55);    // RShift
            actionTable[67, 45] = new ParserAction(ParserActions.Reduce, 0, 55);    // LogicalAnd
            actionTable[67, 46] = new ParserAction(ParserActions.Reduce, 0, 55);    // LogicalOr
            actionTable[67, 47] = new ParserAction(ParserActions.Reduce, 0, 55);    // LogicalXor
            actionTable[67, 48] = new ParserAction(ParserActions.Reduce, 0, 55);    // LShiftAssignment
            actionTable[67, 49] = new ParserAction(ParserActions.Reduce, 0, 55);    // RShiftAssignment
            actionTable[67, 50] = new ParserAction(ParserActions.Reduce, 0, 55);    // AndAssignment
            actionTable[67, 51] = new ParserAction(ParserActions.Reduce, 0, 55);    // XorAssignment
            actionTable[67, 52] = new ParserAction(ParserActions.Reduce, 0, 55);    // OrAssignment
            actionTable[67, 53] = new ParserAction(ParserActions.Reduce, 0, 55);    // PlusPlus
            actionTable[67, 54] = new ParserAction(ParserActions.Reduce, 0, 55);    // MinusMinus

            // State 68
            actionTable[68, 0] = new ParserAction(ParserActions.Reduce, 0, 57);    // EOF
            actionTable[68, 13] = new ParserAction(ParserActions.Reduce, 0, 57);    // LParan
            actionTable[68, 14] = new ParserAction(ParserActions.Reduce, 0, 57);    // RParan
            actionTable[68, 15] = new ParserAction(ParserActions.Reduce, 0, 57);    // LSqr
            actionTable[68, 16] = new ParserAction(ParserActions.Reduce, 0, 57);    // RSqr
            actionTable[68, 17] = new ParserAction(ParserActions.Reduce, 0, 57);    // LCurly
            actionTable[68, 18] = new ParserAction(ParserActions.Reduce, 0, 57);    // RCurly
            actionTable[68, 19] = new ParserAction(ParserActions.Reduce, 0, 57);    // Comma
            actionTable[68, 20] = new ParserAction(ParserActions.Reduce, 0, 57);    // Dot
            actionTable[68, 21] = new ParserAction(ParserActions.Reduce, 0, 57);    // DotDot
            actionTable[68, 22] = new ParserAction(ParserActions.Reduce, 0, 57);    // Plus
            actionTable[68, 23] = new ParserAction(ParserActions.Reduce, 0, 57);    // Minus
            actionTable[68, 24] = new ParserAction(ParserActions.Reduce, 0, 57);    // Mult
            actionTable[68, 25] = new ParserAction(ParserActions.Reduce, 0, 57);    // Div
            actionTable[68, 26] = new ParserAction(ParserActions.Reduce, 0, 57);    // Mod
            actionTable[68, 27] = new ParserAction(ParserActions.Reduce, 0, 57);    // Equal
            actionTable[68, 28] = new ParserAction(ParserActions.Reduce, 0, 57);    // NotEqual
            actionTable[68, 29] = new ParserAction(ParserActions.Reduce, 0, 57);    // Lesser
            actionTable[68, 30] = new ParserAction(ParserActions.Reduce, 0, 57);    // Greater
            actionTable[68, 31] = new ParserAction(ParserActions.Reduce, 0, 57);    // LesserOrEqual
            actionTable[68, 32] = new ParserAction(ParserActions.Reduce, 0, 57);    // GreaterOrEqual
            actionTable[68, 34] = new ParserAction(ParserActions.Reduce, 0, 57);    // And
            actionTable[68, 35] = new ParserAction(ParserActions.Reduce, 0, 57);    // Or
            actionTable[68, 36] = new ParserAction(ParserActions.Reduce, 0, 57);    // Assignment
            actionTable[68, 37] = new ParserAction(ParserActions.Reduce, 0, 57);    // PlusAssignment
            actionTable[68, 38] = new ParserAction(ParserActions.Reduce, 0, 57);    // MinusAssignment
            actionTable[68, 39] = new ParserAction(ParserActions.Reduce, 0, 57);    // MultAssignment
            actionTable[68, 40] = new ParserAction(ParserActions.Reduce, 0, 57);    // DivAssignment
            actionTable[68, 41] = new ParserAction(ParserActions.Reduce, 0, 57);    // ModAssignment
            actionTable[68, 42] = new ParserAction(ParserActions.Reduce, 0, 57);    // LShift
            actionTable[68, 43] = new ParserAction(ParserActions.Reduce, 0, 57);    // RShift
            actionTable[68, 45] = new ParserAction(ParserActions.Reduce, 0, 57);    // LogicalAnd
            actionTable[68, 46] = new ParserAction(ParserActions.Reduce, 0, 57);    // LogicalOr
            actionTable[68, 47] = new ParserAction(ParserActions.Reduce, 0, 57);    // LogicalXor
            actionTable[68, 48] = new ParserAction(ParserActions.Reduce, 0, 57);    // LShiftAssignment
            actionTable[68, 49] = new ParserAction(ParserActions.Reduce, 0, 57);    // RShiftAssignment
            actionTable[68, 50] = new ParserAction(ParserActions.Reduce, 0, 57);    // AndAssignment
            actionTable[68, 51] = new ParserAction(ParserActions.Reduce, 0, 57);    // XorAssignment
            actionTable[68, 52] = new ParserAction(ParserActions.Reduce, 0, 57);    // OrAssignment
            actionTable[68, 53] = new ParserAction(ParserActions.Reduce, 0, 57);    // PlusPlus
            actionTable[68, 54] = new ParserAction(ParserActions.Reduce, 0, 57);    // MinusMinus

            // State 69
            actionTable[69, 13] = new ParserAction(ParserActions.Shift, 118, 0);    // LParan
            actionTable[69, 15] = new ParserAction(ParserActions.Shift, 119, 0);    // LSqr
            actionTable[69, 17] = new ParserAction(ParserActions.Shift, 120, 0);    // LCurly

            // State 70
            actionTable[70, 14] = new ParserAction(ParserActions.Shift, 121, 0);    // RParan

            // State 71
            actionTable[71, 14] = new ParserAction(ParserActions.Shift, 122, 0);    // RParan

            // State 72
            actionTable[72, 21] = new ParserAction(ParserActions.Shift, 123, 0);    // DotDot

            // State 73
            actionTable[73, 16] = new ParserAction(ParserActions.Shift, 124, 0);    // RSqr

            // State 74
            actionTable[74, 14] = new ParserAction(ParserActions.Reduce, 0, 81);    // RParan
            actionTable[74, 16] = new ParserAction(ParserActions.Reduce, 0, 81);    // RSqr
            actionTable[74, 18] = new ParserAction(ParserActions.Reduce, 0, 81);    // RCurly
            actionTable[74, 19] = new ParserAction(ParserActions.Reduce, 0, 81);    // Comma

            // State 75
            actionTable[75, 18] = new ParserAction(ParserActions.Shift, 125, 0);    // RCurly

            // State 76
            actionTable[76, 14] = new ParserAction(ParserActions.Reduce, 0, 72);    // RParan
            actionTable[76, 16] = new ParserAction(ParserActions.Reduce, 0, 72);    // RSqr
            actionTable[76, 18] = new ParserAction(ParserActions.Reduce, 0, 72);    // RCurly
            actionTable[76, 19] = new ParserAction(ParserActions.Shift, 126, 0);    // Comma

            // State 77
            actionTable[77, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[77, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[77, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[77, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[77, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[77, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[77, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[77, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[77, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[77, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[77, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[77, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[77, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[77, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[77, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[77, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[77, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[77, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 78
            actionTable[78, 0] = new ParserAction(ParserActions.Reduce, 0, 43);    // EOF
            actionTable[78, 14] = new ParserAction(ParserActions.Reduce, 0, 43);    // RParan
            actionTable[78, 16] = new ParserAction(ParserActions.Reduce, 0, 43);    // RSqr
            actionTable[78, 18] = new ParserAction(ParserActions.Reduce, 0, 43);    // RCurly
            actionTable[78, 19] = new ParserAction(ParserActions.Reduce, 0, 43);    // Comma
            actionTable[78, 21] = new ParserAction(ParserActions.Reduce, 0, 43);    // DotDot
            actionTable[78, 22] = new ParserAction(ParserActions.Reduce, 0, 43);    // Plus
            actionTable[78, 23] = new ParserAction(ParserActions.Reduce, 0, 43);    // Minus
            actionTable[78, 24] = new ParserAction(ParserActions.Reduce, 0, 43);    // Mult
            actionTable[78, 25] = new ParserAction(ParserActions.Reduce, 0, 43);    // Div
            actionTable[78, 26] = new ParserAction(ParserActions.Reduce, 0, 43);    // Mod
            actionTable[78, 27] = new ParserAction(ParserActions.Reduce, 0, 43);    // Equal
            actionTable[78, 28] = new ParserAction(ParserActions.Reduce, 0, 43);    // NotEqual
            actionTable[78, 29] = new ParserAction(ParserActions.Reduce, 0, 43);    // Lesser
            actionTable[78, 30] = new ParserAction(ParserActions.Reduce, 0, 43);    // Greater
            actionTable[78, 31] = new ParserAction(ParserActions.Reduce, 0, 43);    // LesserOrEqual
            actionTable[78, 32] = new ParserAction(ParserActions.Reduce, 0, 43);    // GreaterOrEqual
            actionTable[78, 34] = new ParserAction(ParserActions.Reduce, 0, 43);    // And
            actionTable[78, 35] = new ParserAction(ParserActions.Reduce, 0, 43);    // Or
            actionTable[78, 36] = new ParserAction(ParserActions.Reduce, 0, 43);    // Assignment
            actionTable[78, 37] = new ParserAction(ParserActions.Reduce, 0, 43);    // PlusAssignment
            actionTable[78, 38] = new ParserAction(ParserActions.Reduce, 0, 43);    // MinusAssignment
            actionTable[78, 39] = new ParserAction(ParserActions.Reduce, 0, 43);    // MultAssignment
            actionTable[78, 40] = new ParserAction(ParserActions.Reduce, 0, 43);    // DivAssignment
            actionTable[78, 41] = new ParserAction(ParserActions.Reduce, 0, 43);    // ModAssignment
            actionTable[78, 42] = new ParserAction(ParserActions.Reduce, 0, 43);    // LShift
            actionTable[78, 43] = new ParserAction(ParserActions.Reduce, 0, 43);    // RShift
            actionTable[78, 45] = new ParserAction(ParserActions.Reduce, 0, 43);    // LogicalAnd
            actionTable[78, 46] = new ParserAction(ParserActions.Reduce, 0, 43);    // LogicalOr
            actionTable[78, 47] = new ParserAction(ParserActions.Reduce, 0, 43);    // LogicalXor
            actionTable[78, 48] = new ParserAction(ParserActions.Reduce, 0, 43);    // LShiftAssignment
            actionTable[78, 49] = new ParserAction(ParserActions.Reduce, 0, 43);    // RShiftAssignment
            actionTable[78, 50] = new ParserAction(ParserActions.Reduce, 0, 43);    // AndAssignment
            actionTable[78, 51] = new ParserAction(ParserActions.Reduce, 0, 43);    // XorAssignment
            actionTable[78, 52] = new ParserAction(ParserActions.Reduce, 0, 43);    // OrAssignment

            // State 79
            actionTable[79, 0] = new ParserAction(ParserActions.Reduce, 0, 42);    // EOF
            actionTable[79, 14] = new ParserAction(ParserActions.Reduce, 0, 42);    // RParan
            actionTable[79, 16] = new ParserAction(ParserActions.Reduce, 0, 42);    // RSqr
            actionTable[79, 18] = new ParserAction(ParserActions.Reduce, 0, 42);    // RCurly
            actionTable[79, 19] = new ParserAction(ParserActions.Reduce, 0, 42);    // Comma
            actionTable[79, 21] = new ParserAction(ParserActions.Reduce, 0, 42);    // DotDot
            actionTable[79, 22] = new ParserAction(ParserActions.Reduce, 0, 42);    // Plus
            actionTable[79, 23] = new ParserAction(ParserActions.Reduce, 0, 42);    // Minus
            actionTable[79, 24] = new ParserAction(ParserActions.Reduce, 0, 42);    // Mult
            actionTable[79, 25] = new ParserAction(ParserActions.Reduce, 0, 42);    // Div
            actionTable[79, 26] = new ParserAction(ParserActions.Reduce, 0, 42);    // Mod
            actionTable[79, 27] = new ParserAction(ParserActions.Reduce, 0, 42);    // Equal
            actionTable[79, 28] = new ParserAction(ParserActions.Reduce, 0, 42);    // NotEqual
            actionTable[79, 29] = new ParserAction(ParserActions.Reduce, 0, 42);    // Lesser
            actionTable[79, 30] = new ParserAction(ParserActions.Reduce, 0, 42);    // Greater
            actionTable[79, 31] = new ParserAction(ParserActions.Reduce, 0, 42);    // LesserOrEqual
            actionTable[79, 32] = new ParserAction(ParserActions.Reduce, 0, 42);    // GreaterOrEqual
            actionTable[79, 34] = new ParserAction(ParserActions.Reduce, 0, 42);    // And
            actionTable[79, 35] = new ParserAction(ParserActions.Reduce, 0, 42);    // Or
            actionTable[79, 36] = new ParserAction(ParserActions.Reduce, 0, 42);    // Assignment
            actionTable[79, 37] = new ParserAction(ParserActions.Reduce, 0, 42);    // PlusAssignment
            actionTable[79, 38] = new ParserAction(ParserActions.Reduce, 0, 42);    // MinusAssignment
            actionTable[79, 39] = new ParserAction(ParserActions.Reduce, 0, 42);    // MultAssignment
            actionTable[79, 40] = new ParserAction(ParserActions.Reduce, 0, 42);    // DivAssignment
            actionTable[79, 41] = new ParserAction(ParserActions.Reduce, 0, 42);    // ModAssignment
            actionTable[79, 42] = new ParserAction(ParserActions.Reduce, 0, 42);    // LShift
            actionTable[79, 43] = new ParserAction(ParserActions.Reduce, 0, 42);    // RShift
            actionTable[79, 45] = new ParserAction(ParserActions.Reduce, 0, 42);    // LogicalAnd
            actionTable[79, 46] = new ParserAction(ParserActions.Reduce, 0, 42);    // LogicalOr
            actionTable[79, 47] = new ParserAction(ParserActions.Reduce, 0, 42);    // LogicalXor
            actionTable[79, 48] = new ParserAction(ParserActions.Reduce, 0, 42);    // LShiftAssignment
            actionTable[79, 49] = new ParserAction(ParserActions.Reduce, 0, 42);    // RShiftAssignment
            actionTable[79, 50] = new ParserAction(ParserActions.Reduce, 0, 42);    // AndAssignment
            actionTable[79, 51] = new ParserAction(ParserActions.Reduce, 0, 42);    // XorAssignment
            actionTable[79, 52] = new ParserAction(ParserActions.Reduce, 0, 42);    // OrAssignment

            // State 80
            actionTable[80, 0] = new ParserAction(ParserActions.Reduce, 0, 44);    // EOF
            actionTable[80, 14] = new ParserAction(ParserActions.Reduce, 0, 44);    // RParan
            actionTable[80, 16] = new ParserAction(ParserActions.Reduce, 0, 44);    // RSqr
            actionTable[80, 18] = new ParserAction(ParserActions.Reduce, 0, 44);    // RCurly
            actionTable[80, 19] = new ParserAction(ParserActions.Reduce, 0, 44);    // Comma
            actionTable[80, 21] = new ParserAction(ParserActions.Reduce, 0, 44);    // DotDot
            actionTable[80, 22] = new ParserAction(ParserActions.Reduce, 0, 44);    // Plus
            actionTable[80, 23] = new ParserAction(ParserActions.Reduce, 0, 44);    // Minus
            actionTable[80, 24] = new ParserAction(ParserActions.Reduce, 0, 44);    // Mult
            actionTable[80, 25] = new ParserAction(ParserActions.Reduce, 0, 44);    // Div
            actionTable[80, 26] = new ParserAction(ParserActions.Reduce, 0, 44);    // Mod
            actionTable[80, 27] = new ParserAction(ParserActions.Reduce, 0, 44);    // Equal
            actionTable[80, 28] = new ParserAction(ParserActions.Reduce, 0, 44);    // NotEqual
            actionTable[80, 29] = new ParserAction(ParserActions.Reduce, 0, 44);    // Lesser
            actionTable[80, 30] = new ParserAction(ParserActions.Reduce, 0, 44);    // Greater
            actionTable[80, 31] = new ParserAction(ParserActions.Reduce, 0, 44);    // LesserOrEqual
            actionTable[80, 32] = new ParserAction(ParserActions.Reduce, 0, 44);    // GreaterOrEqual
            actionTable[80, 34] = new ParserAction(ParserActions.Reduce, 0, 44);    // And
            actionTable[80, 35] = new ParserAction(ParserActions.Reduce, 0, 44);    // Or
            actionTable[80, 36] = new ParserAction(ParserActions.Reduce, 0, 44);    // Assignment
            actionTable[80, 37] = new ParserAction(ParserActions.Reduce, 0, 44);    // PlusAssignment
            actionTable[80, 38] = new ParserAction(ParserActions.Reduce, 0, 44);    // MinusAssignment
            actionTable[80, 39] = new ParserAction(ParserActions.Reduce, 0, 44);    // MultAssignment
            actionTable[80, 40] = new ParserAction(ParserActions.Reduce, 0, 44);    // DivAssignment
            actionTable[80, 41] = new ParserAction(ParserActions.Reduce, 0, 44);    // ModAssignment
            actionTable[80, 42] = new ParserAction(ParserActions.Reduce, 0, 44);    // LShift
            actionTable[80, 43] = new ParserAction(ParserActions.Reduce, 0, 44);    // RShift
            actionTable[80, 45] = new ParserAction(ParserActions.Reduce, 0, 44);    // LogicalAnd
            actionTable[80, 46] = new ParserAction(ParserActions.Reduce, 0, 44);    // LogicalOr
            actionTable[80, 47] = new ParserAction(ParserActions.Reduce, 0, 44);    // LogicalXor
            actionTable[80, 48] = new ParserAction(ParserActions.Reduce, 0, 44);    // LShiftAssignment
            actionTable[80, 49] = new ParserAction(ParserActions.Reduce, 0, 44);    // RShiftAssignment
            actionTable[80, 50] = new ParserAction(ParserActions.Reduce, 0, 44);    // AndAssignment
            actionTable[80, 51] = new ParserAction(ParserActions.Reduce, 0, 44);    // XorAssignment
            actionTable[80, 52] = new ParserAction(ParserActions.Reduce, 0, 44);    // OrAssignment

            // State 81
            actionTable[81, 0] = new ParserAction(ParserActions.Reduce, 0, 47);    // EOF
            actionTable[81, 14] = new ParserAction(ParserActions.Reduce, 0, 47);    // RParan
            actionTable[81, 16] = new ParserAction(ParserActions.Reduce, 0, 47);    // RSqr
            actionTable[81, 18] = new ParserAction(ParserActions.Reduce, 0, 47);    // RCurly
            actionTable[81, 19] = new ParserAction(ParserActions.Reduce, 0, 47);    // Comma
            actionTable[81, 21] = new ParserAction(ParserActions.Reduce, 0, 47);    // DotDot
            actionTable[81, 22] = new ParserAction(ParserActions.Reduce, 0, 47);    // Plus
            actionTable[81, 23] = new ParserAction(ParserActions.Reduce, 0, 47);    // Minus
            actionTable[81, 24] = new ParserAction(ParserActions.Reduce, 0, 47);    // Mult
            actionTable[81, 25] = new ParserAction(ParserActions.Reduce, 0, 47);    // Div
            actionTable[81, 26] = new ParserAction(ParserActions.Reduce, 0, 47);    // Mod
            actionTable[81, 27] = new ParserAction(ParserActions.Reduce, 0, 47);    // Equal
            actionTable[81, 28] = new ParserAction(ParserActions.Reduce, 0, 47);    // NotEqual
            actionTable[81, 29] = new ParserAction(ParserActions.Reduce, 0, 47);    // Lesser
            actionTable[81, 30] = new ParserAction(ParserActions.Reduce, 0, 47);    // Greater
            actionTable[81, 31] = new ParserAction(ParserActions.Reduce, 0, 47);    // LesserOrEqual
            actionTable[81, 32] = new ParserAction(ParserActions.Reduce, 0, 47);    // GreaterOrEqual
            actionTable[81, 34] = new ParserAction(ParserActions.Reduce, 0, 47);    // And
            actionTable[81, 35] = new ParserAction(ParserActions.Reduce, 0, 47);    // Or
            actionTable[81, 36] = new ParserAction(ParserActions.Reduce, 0, 47);    // Assignment
            actionTable[81, 37] = new ParserAction(ParserActions.Reduce, 0, 47);    // PlusAssignment
            actionTable[81, 38] = new ParserAction(ParserActions.Reduce, 0, 47);    // MinusAssignment
            actionTable[81, 39] = new ParserAction(ParserActions.Reduce, 0, 47);    // MultAssignment
            actionTable[81, 40] = new ParserAction(ParserActions.Reduce, 0, 47);    // DivAssignment
            actionTable[81, 41] = new ParserAction(ParserActions.Reduce, 0, 47);    // ModAssignment
            actionTable[81, 42] = new ParserAction(ParserActions.Reduce, 0, 47);    // LShift
            actionTable[81, 43] = new ParserAction(ParserActions.Reduce, 0, 47);    // RShift
            actionTable[81, 45] = new ParserAction(ParserActions.Reduce, 0, 47);    // LogicalAnd
            actionTable[81, 46] = new ParserAction(ParserActions.Reduce, 0, 47);    // LogicalOr
            actionTable[81, 47] = new ParserAction(ParserActions.Reduce, 0, 47);    // LogicalXor
            actionTable[81, 48] = new ParserAction(ParserActions.Reduce, 0, 47);    // LShiftAssignment
            actionTable[81, 49] = new ParserAction(ParserActions.Reduce, 0, 47);    // RShiftAssignment
            actionTable[81, 50] = new ParserAction(ParserActions.Reduce, 0, 47);    // AndAssignment
            actionTable[81, 51] = new ParserAction(ParserActions.Reduce, 0, 47);    // XorAssignment
            actionTable[81, 52] = new ParserAction(ParserActions.Reduce, 0, 47);    // OrAssignment

            // State 82
            actionTable[82, 0] = new ParserAction(ParserActions.Reduce, 0, 45);    // EOF
            actionTable[82, 14] = new ParserAction(ParserActions.Reduce, 0, 45);    // RParan
            actionTable[82, 16] = new ParserAction(ParserActions.Reduce, 0, 45);    // RSqr
            actionTable[82, 18] = new ParserAction(ParserActions.Reduce, 0, 45);    // RCurly
            actionTable[82, 19] = new ParserAction(ParserActions.Reduce, 0, 45);    // Comma
            actionTable[82, 21] = new ParserAction(ParserActions.Reduce, 0, 45);    // DotDot
            actionTable[82, 22] = new ParserAction(ParserActions.Reduce, 0, 45);    // Plus
            actionTable[82, 23] = new ParserAction(ParserActions.Reduce, 0, 45);    // Minus
            actionTable[82, 24] = new ParserAction(ParserActions.Reduce, 0, 45);    // Mult
            actionTable[82, 25] = new ParserAction(ParserActions.Reduce, 0, 45);    // Div
            actionTable[82, 26] = new ParserAction(ParserActions.Reduce, 0, 45);    // Mod
            actionTable[82, 27] = new ParserAction(ParserActions.Reduce, 0, 45);    // Equal
            actionTable[82, 28] = new ParserAction(ParserActions.Reduce, 0, 45);    // NotEqual
            actionTable[82, 29] = new ParserAction(ParserActions.Reduce, 0, 45);    // Lesser
            actionTable[82, 30] = new ParserAction(ParserActions.Reduce, 0, 45);    // Greater
            actionTable[82, 31] = new ParserAction(ParserActions.Reduce, 0, 45);    // LesserOrEqual
            actionTable[82, 32] = new ParserAction(ParserActions.Reduce, 0, 45);    // GreaterOrEqual
            actionTable[82, 34] = new ParserAction(ParserActions.Reduce, 0, 45);    // And
            actionTable[82, 35] = new ParserAction(ParserActions.Reduce, 0, 45);    // Or
            actionTable[82, 36] = new ParserAction(ParserActions.Reduce, 0, 45);    // Assignment
            actionTable[82, 37] = new ParserAction(ParserActions.Reduce, 0, 45);    // PlusAssignment
            actionTable[82, 38] = new ParserAction(ParserActions.Reduce, 0, 45);    // MinusAssignment
            actionTable[82, 39] = new ParserAction(ParserActions.Reduce, 0, 45);    // MultAssignment
            actionTable[82, 40] = new ParserAction(ParserActions.Reduce, 0, 45);    // DivAssignment
            actionTable[82, 41] = new ParserAction(ParserActions.Reduce, 0, 45);    // ModAssignment
            actionTable[82, 42] = new ParserAction(ParserActions.Reduce, 0, 45);    // LShift
            actionTable[82, 43] = new ParserAction(ParserActions.Reduce, 0, 45);    // RShift
            actionTable[82, 45] = new ParserAction(ParserActions.Reduce, 0, 45);    // LogicalAnd
            actionTable[82, 46] = new ParserAction(ParserActions.Reduce, 0, 45);    // LogicalOr
            actionTable[82, 47] = new ParserAction(ParserActions.Reduce, 0, 45);    // LogicalXor
            actionTable[82, 48] = new ParserAction(ParserActions.Reduce, 0, 45);    // LShiftAssignment
            actionTable[82, 49] = new ParserAction(ParserActions.Reduce, 0, 45);    // RShiftAssignment
            actionTable[82, 50] = new ParserAction(ParserActions.Reduce, 0, 45);    // AndAssignment
            actionTable[82, 51] = new ParserAction(ParserActions.Reduce, 0, 45);    // XorAssignment
            actionTable[82, 52] = new ParserAction(ParserActions.Reduce, 0, 45);    // OrAssignment

            // State 83
            actionTable[83, 0] = new ParserAction(ParserActions.Reduce, 0, 46);    // EOF
            actionTable[83, 14] = new ParserAction(ParserActions.Reduce, 0, 46);    // RParan
            actionTable[83, 16] = new ParserAction(ParserActions.Reduce, 0, 46);    // RSqr
            actionTable[83, 18] = new ParserAction(ParserActions.Reduce, 0, 46);    // RCurly
            actionTable[83, 19] = new ParserAction(ParserActions.Reduce, 0, 46);    // Comma
            actionTable[83, 21] = new ParserAction(ParserActions.Reduce, 0, 46);    // DotDot
            actionTable[83, 22] = new ParserAction(ParserActions.Reduce, 0, 46);    // Plus
            actionTable[83, 23] = new ParserAction(ParserActions.Reduce, 0, 46);    // Minus
            actionTable[83, 24] = new ParserAction(ParserActions.Reduce, 0, 46);    // Mult
            actionTable[83, 25] = new ParserAction(ParserActions.Reduce, 0, 46);    // Div
            actionTable[83, 26] = new ParserAction(ParserActions.Reduce, 0, 46);    // Mod
            actionTable[83, 27] = new ParserAction(ParserActions.Reduce, 0, 46);    // Equal
            actionTable[83, 28] = new ParserAction(ParserActions.Reduce, 0, 46);    // NotEqual
            actionTable[83, 29] = new ParserAction(ParserActions.Reduce, 0, 46);    // Lesser
            actionTable[83, 30] = new ParserAction(ParserActions.Reduce, 0, 46);    // Greater
            actionTable[83, 31] = new ParserAction(ParserActions.Reduce, 0, 46);    // LesserOrEqual
            actionTable[83, 32] = new ParserAction(ParserActions.Reduce, 0, 46);    // GreaterOrEqual
            actionTable[83, 34] = new ParserAction(ParserActions.Reduce, 0, 46);    // And
            actionTable[83, 35] = new ParserAction(ParserActions.Reduce, 0, 46);    // Or
            actionTable[83, 36] = new ParserAction(ParserActions.Reduce, 0, 46);    // Assignment
            actionTable[83, 37] = new ParserAction(ParserActions.Reduce, 0, 46);    // PlusAssignment
            actionTable[83, 38] = new ParserAction(ParserActions.Reduce, 0, 46);    // MinusAssignment
            actionTable[83, 39] = new ParserAction(ParserActions.Reduce, 0, 46);    // MultAssignment
            actionTable[83, 40] = new ParserAction(ParserActions.Reduce, 0, 46);    // DivAssignment
            actionTable[83, 41] = new ParserAction(ParserActions.Reduce, 0, 46);    // ModAssignment
            actionTable[83, 42] = new ParserAction(ParserActions.Reduce, 0, 46);    // LShift
            actionTable[83, 43] = new ParserAction(ParserActions.Reduce, 0, 46);    // RShift
            actionTable[83, 45] = new ParserAction(ParserActions.Reduce, 0, 46);    // LogicalAnd
            actionTable[83, 46] = new ParserAction(ParserActions.Reduce, 0, 46);    // LogicalOr
            actionTable[83, 47] = new ParserAction(ParserActions.Reduce, 0, 46);    // LogicalXor
            actionTable[83, 48] = new ParserAction(ParserActions.Reduce, 0, 46);    // LShiftAssignment
            actionTable[83, 49] = new ParserAction(ParserActions.Reduce, 0, 46);    // RShiftAssignment
            actionTable[83, 50] = new ParserAction(ParserActions.Reduce, 0, 46);    // AndAssignment
            actionTable[83, 51] = new ParserAction(ParserActions.Reduce, 0, 46);    // XorAssignment
            actionTable[83, 52] = new ParserAction(ParserActions.Reduce, 0, 46);    // OrAssignment

            // State 84
            actionTable[84, 0] = new ParserAction(ParserActions.Reduce, 0, 13);    // EOF
            actionTable[84, 14] = new ParserAction(ParserActions.Reduce, 0, 13);    // RParan
            actionTable[84, 16] = new ParserAction(ParserActions.Reduce, 0, 13);    // RSqr
            actionTable[84, 18] = new ParserAction(ParserActions.Reduce, 0, 13);    // RCurly
            actionTable[84, 19] = new ParserAction(ParserActions.Reduce, 0, 13);    // Comma
            actionTable[84, 21] = new ParserAction(ParserActions.Reduce, 0, 13);    // DotDot
            actionTable[84, 34] = new ParserAction(ParserActions.Shift, 45, 0);    // And
            actionTable[84, 35] = new ParserAction(ParserActions.Reduce, 0, 13);    // Or
            actionTable[84, 36] = new ParserAction(ParserActions.Reduce, 0, 13);    // Assignment
            actionTable[84, 37] = new ParserAction(ParserActions.Reduce, 0, 13);    // PlusAssignment
            actionTable[84, 38] = new ParserAction(ParserActions.Reduce, 0, 13);    // MinusAssignment
            actionTable[84, 39] = new ParserAction(ParserActions.Reduce, 0, 13);    // MultAssignment
            actionTable[84, 40] = new ParserAction(ParserActions.Reduce, 0, 13);    // DivAssignment
            actionTable[84, 41] = new ParserAction(ParserActions.Reduce, 0, 13);    // ModAssignment
            actionTable[84, 48] = new ParserAction(ParserActions.Reduce, 0, 13);    // LShiftAssignment
            actionTable[84, 49] = new ParserAction(ParserActions.Reduce, 0, 13);    // RShiftAssignment
            actionTable[84, 50] = new ParserAction(ParserActions.Reduce, 0, 13);    // AndAssignment
            actionTable[84, 51] = new ParserAction(ParserActions.Reduce, 0, 13);    // XorAssignment
            actionTable[84, 52] = new ParserAction(ParserActions.Reduce, 0, 13);    // OrAssignment

            // State 85
            actionTable[85, 0] = new ParserAction(ParserActions.Reduce, 0, 1);    // EOF
            actionTable[85, 14] = new ParserAction(ParserActions.Reduce, 0, 1);    // RParan
            actionTable[85, 16] = new ParserAction(ParserActions.Reduce, 0, 1);    // RSqr
            actionTable[85, 18] = new ParserAction(ParserActions.Reduce, 0, 1);    // RCurly
            actionTable[85, 19] = new ParserAction(ParserActions.Reduce, 0, 1);    // Comma
            actionTable[85, 21] = new ParserAction(ParserActions.Reduce, 0, 1);    // DotDot

            // State 86
            actionTable[86, 0] = new ParserAction(ParserActions.Reduce, 0, 2);    // EOF
            actionTable[86, 14] = new ParserAction(ParserActions.Reduce, 0, 2);    // RParan
            actionTable[86, 16] = new ParserAction(ParserActions.Reduce, 0, 2);    // RSqr
            actionTable[86, 18] = new ParserAction(ParserActions.Reduce, 0, 2);    // RCurly
            actionTable[86, 19] = new ParserAction(ParserActions.Reduce, 0, 2);    // Comma
            actionTable[86, 21] = new ParserAction(ParserActions.Reduce, 0, 2);    // DotDot

            // State 87
            actionTable[87, 0] = new ParserAction(ParserActions.Reduce, 0, 3);    // EOF
            actionTable[87, 14] = new ParserAction(ParserActions.Reduce, 0, 3);    // RParan
            actionTable[87, 16] = new ParserAction(ParserActions.Reduce, 0, 3);    // RSqr
            actionTable[87, 18] = new ParserAction(ParserActions.Reduce, 0, 3);    // RCurly
            actionTable[87, 19] = new ParserAction(ParserActions.Reduce, 0, 3);    // Comma
            actionTable[87, 21] = new ParserAction(ParserActions.Reduce, 0, 3);    // DotDot

            // State 88
            actionTable[88, 0] = new ParserAction(ParserActions.Reduce, 0, 4);    // EOF
            actionTable[88, 14] = new ParserAction(ParserActions.Reduce, 0, 4);    // RParan
            actionTable[88, 16] = new ParserAction(ParserActions.Reduce, 0, 4);    // RSqr
            actionTable[88, 18] = new ParserAction(ParserActions.Reduce, 0, 4);    // RCurly
            actionTable[88, 19] = new ParserAction(ParserActions.Reduce, 0, 4);    // Comma
            actionTable[88, 21] = new ParserAction(ParserActions.Reduce, 0, 4);    // DotDot

            // State 89
            actionTable[89, 0] = new ParserAction(ParserActions.Reduce, 0, 5);    // EOF
            actionTable[89, 14] = new ParserAction(ParserActions.Reduce, 0, 5);    // RParan
            actionTable[89, 16] = new ParserAction(ParserActions.Reduce, 0, 5);    // RSqr
            actionTable[89, 18] = new ParserAction(ParserActions.Reduce, 0, 5);    // RCurly
            actionTable[89, 19] = new ParserAction(ParserActions.Reduce, 0, 5);    // Comma
            actionTable[89, 21] = new ParserAction(ParserActions.Reduce, 0, 5);    // DotDot

            // State 90
            actionTable[90, 0] = new ParserAction(ParserActions.Reduce, 0, 6);    // EOF
            actionTable[90, 14] = new ParserAction(ParserActions.Reduce, 0, 6);    // RParan
            actionTable[90, 16] = new ParserAction(ParserActions.Reduce, 0, 6);    // RSqr
            actionTable[90, 18] = new ParserAction(ParserActions.Reduce, 0, 6);    // RCurly
            actionTable[90, 19] = new ParserAction(ParserActions.Reduce, 0, 6);    // Comma
            actionTable[90, 21] = new ParserAction(ParserActions.Reduce, 0, 6);    // DotDot

            // State 91
            actionTable[91, 0] = new ParserAction(ParserActions.Reduce, 0, 7);    // EOF
            actionTable[91, 14] = new ParserAction(ParserActions.Reduce, 0, 7);    // RParan
            actionTable[91, 16] = new ParserAction(ParserActions.Reduce, 0, 7);    // RSqr
            actionTable[91, 18] = new ParserAction(ParserActions.Reduce, 0, 7);    // RCurly
            actionTable[91, 19] = new ParserAction(ParserActions.Reduce, 0, 7);    // Comma
            actionTable[91, 21] = new ParserAction(ParserActions.Reduce, 0, 7);    // DotDot

            // State 92
            actionTable[92, 0] = new ParserAction(ParserActions.Reduce, 0, 8);    // EOF
            actionTable[92, 14] = new ParserAction(ParserActions.Reduce, 0, 8);    // RParan
            actionTable[92, 16] = new ParserAction(ParserActions.Reduce, 0, 8);    // RSqr
            actionTable[92, 18] = new ParserAction(ParserActions.Reduce, 0, 8);    // RCurly
            actionTable[92, 19] = new ParserAction(ParserActions.Reduce, 0, 8);    // Comma
            actionTable[92, 21] = new ParserAction(ParserActions.Reduce, 0, 8);    // DotDot

            // State 93
            actionTable[93, 0] = new ParserAction(ParserActions.Reduce, 0, 9);    // EOF
            actionTable[93, 14] = new ParserAction(ParserActions.Reduce, 0, 9);    // RParan
            actionTable[93, 16] = new ParserAction(ParserActions.Reduce, 0, 9);    // RSqr
            actionTable[93, 18] = new ParserAction(ParserActions.Reduce, 0, 9);    // RCurly
            actionTable[93, 19] = new ParserAction(ParserActions.Reduce, 0, 9);    // Comma
            actionTable[93, 21] = new ParserAction(ParserActions.Reduce, 0, 9);    // DotDot

            // State 94
            actionTable[94, 0] = new ParserAction(ParserActions.Reduce, 0, 10);    // EOF
            actionTable[94, 14] = new ParserAction(ParserActions.Reduce, 0, 10);    // RParan
            actionTable[94, 16] = new ParserAction(ParserActions.Reduce, 0, 10);    // RSqr
            actionTable[94, 18] = new ParserAction(ParserActions.Reduce, 0, 10);    // RCurly
            actionTable[94, 19] = new ParserAction(ParserActions.Reduce, 0, 10);    // Comma
            actionTable[94, 21] = new ParserAction(ParserActions.Reduce, 0, 10);    // DotDot

            // State 95
            actionTable[95, 0] = new ParserAction(ParserActions.Reduce, 0, 11);    // EOF
            actionTable[95, 14] = new ParserAction(ParserActions.Reduce, 0, 11);    // RParan
            actionTable[95, 16] = new ParserAction(ParserActions.Reduce, 0, 11);    // RSqr
            actionTable[95, 18] = new ParserAction(ParserActions.Reduce, 0, 11);    // RCurly
            actionTable[95, 19] = new ParserAction(ParserActions.Reduce, 0, 11);    // Comma
            actionTable[95, 21] = new ParserAction(ParserActions.Reduce, 0, 11);    // DotDot

            // State 96
            actionTable[96, 0] = new ParserAction(ParserActions.Reduce, 0, 15);    // EOF
            actionTable[96, 14] = new ParserAction(ParserActions.Reduce, 0, 15);    // RParan
            actionTable[96, 16] = new ParserAction(ParserActions.Reduce, 0, 15);    // RSqr
            actionTable[96, 18] = new ParserAction(ParserActions.Reduce, 0, 15);    // RCurly
            actionTable[96, 19] = new ParserAction(ParserActions.Reduce, 0, 15);    // Comma
            actionTable[96, 21] = new ParserAction(ParserActions.Reduce, 0, 15);    // DotDot
            actionTable[96, 34] = new ParserAction(ParserActions.Reduce, 0, 15);    // And
            actionTable[96, 35] = new ParserAction(ParserActions.Reduce, 0, 15);    // Or
            actionTable[96, 36] = new ParserAction(ParserActions.Reduce, 0, 15);    // Assignment
            actionTable[96, 37] = new ParserAction(ParserActions.Reduce, 0, 15);    // PlusAssignment
            actionTable[96, 38] = new ParserAction(ParserActions.Reduce, 0, 15);    // MinusAssignment
            actionTable[96, 39] = new ParserAction(ParserActions.Reduce, 0, 15);    // MultAssignment
            actionTable[96, 40] = new ParserAction(ParserActions.Reduce, 0, 15);    // DivAssignment
            actionTable[96, 41] = new ParserAction(ParserActions.Reduce, 0, 15);    // ModAssignment
            actionTable[96, 46] = new ParserAction(ParserActions.Shift, 46, 0);    // LogicalOr
            actionTable[96, 48] = new ParserAction(ParserActions.Reduce, 0, 15);    // LShiftAssignment
            actionTable[96, 49] = new ParserAction(ParserActions.Reduce, 0, 15);    // RShiftAssignment
            actionTable[96, 50] = new ParserAction(ParserActions.Reduce, 0, 15);    // AndAssignment
            actionTable[96, 51] = new ParserAction(ParserActions.Reduce, 0, 15);    // XorAssignment
            actionTable[96, 52] = new ParserAction(ParserActions.Reduce, 0, 15);    // OrAssignment

            // State 97
            actionTable[97, 0] = new ParserAction(ParserActions.Reduce, 0, 17);    // EOF
            actionTable[97, 14] = new ParserAction(ParserActions.Reduce, 0, 17);    // RParan
            actionTable[97, 16] = new ParserAction(ParserActions.Reduce, 0, 17);    // RSqr
            actionTable[97, 18] = new ParserAction(ParserActions.Reduce, 0, 17);    // RCurly
            actionTable[97, 19] = new ParserAction(ParserActions.Reduce, 0, 17);    // Comma
            actionTable[97, 21] = new ParserAction(ParserActions.Reduce, 0, 17);    // DotDot
            actionTable[97, 34] = new ParserAction(ParserActions.Reduce, 0, 17);    // And
            actionTable[97, 35] = new ParserAction(ParserActions.Reduce, 0, 17);    // Or
            actionTable[97, 36] = new ParserAction(ParserActions.Reduce, 0, 17);    // Assignment
            actionTable[97, 37] = new ParserAction(ParserActions.Reduce, 0, 17);    // PlusAssignment
            actionTable[97, 38] = new ParserAction(ParserActions.Reduce, 0, 17);    // MinusAssignment
            actionTable[97, 39] = new ParserAction(ParserActions.Reduce, 0, 17);    // MultAssignment
            actionTable[97, 40] = new ParserAction(ParserActions.Reduce, 0, 17);    // DivAssignment
            actionTable[97, 41] = new ParserAction(ParserActions.Reduce, 0, 17);    // ModAssignment
            actionTable[97, 46] = new ParserAction(ParserActions.Reduce, 0, 17);    // LogicalOr
            actionTable[97, 47] = new ParserAction(ParserActions.Shift, 47, 0);    // LogicalXor
            actionTable[97, 48] = new ParserAction(ParserActions.Reduce, 0, 17);    // LShiftAssignment
            actionTable[97, 49] = new ParserAction(ParserActions.Reduce, 0, 17);    // RShiftAssignment
            actionTable[97, 50] = new ParserAction(ParserActions.Reduce, 0, 17);    // AndAssignment
            actionTable[97, 51] = new ParserAction(ParserActions.Reduce, 0, 17);    // XorAssignment
            actionTable[97, 52] = new ParserAction(ParserActions.Reduce, 0, 17);    // OrAssignment

            // State 98
            actionTable[98, 0] = new ParserAction(ParserActions.Reduce, 0, 19);    // EOF
            actionTable[98, 14] = new ParserAction(ParserActions.Reduce, 0, 19);    // RParan
            actionTable[98, 16] = new ParserAction(ParserActions.Reduce, 0, 19);    // RSqr
            actionTable[98, 18] = new ParserAction(ParserActions.Reduce, 0, 19);    // RCurly
            actionTable[98, 19] = new ParserAction(ParserActions.Reduce, 0, 19);    // Comma
            actionTable[98, 21] = new ParserAction(ParserActions.Reduce, 0, 19);    // DotDot
            actionTable[98, 34] = new ParserAction(ParserActions.Reduce, 0, 19);    // And
            actionTable[98, 35] = new ParserAction(ParserActions.Reduce, 0, 19);    // Or
            actionTable[98, 36] = new ParserAction(ParserActions.Reduce, 0, 19);    // Assignment
            actionTable[98, 37] = new ParserAction(ParserActions.Reduce, 0, 19);    // PlusAssignment
            actionTable[98, 38] = new ParserAction(ParserActions.Reduce, 0, 19);    // MinusAssignment
            actionTable[98, 39] = new ParserAction(ParserActions.Reduce, 0, 19);    // MultAssignment
            actionTable[98, 40] = new ParserAction(ParserActions.Reduce, 0, 19);    // DivAssignment
            actionTable[98, 41] = new ParserAction(ParserActions.Reduce, 0, 19);    // ModAssignment
            actionTable[98, 45] = new ParserAction(ParserActions.Shift, 48, 0);    // LogicalAnd
            actionTable[98, 46] = new ParserAction(ParserActions.Reduce, 0, 19);    // LogicalOr
            actionTable[98, 47] = new ParserAction(ParserActions.Reduce, 0, 19);    // LogicalXor
            actionTable[98, 48] = new ParserAction(ParserActions.Reduce, 0, 19);    // LShiftAssignment
            actionTable[98, 49] = new ParserAction(ParserActions.Reduce, 0, 19);    // RShiftAssignment
            actionTable[98, 50] = new ParserAction(ParserActions.Reduce, 0, 19);    // AndAssignment
            actionTable[98, 51] = new ParserAction(ParserActions.Reduce, 0, 19);    // XorAssignment
            actionTable[98, 52] = new ParserAction(ParserActions.Reduce, 0, 19);    // OrAssignment

            // State 99
            actionTable[99, 0] = new ParserAction(ParserActions.Reduce, 0, 21);    // EOF
            actionTable[99, 14] = new ParserAction(ParserActions.Reduce, 0, 21);    // RParan
            actionTable[99, 16] = new ParserAction(ParserActions.Reduce, 0, 21);    // RSqr
            actionTable[99, 18] = new ParserAction(ParserActions.Reduce, 0, 21);    // RCurly
            actionTable[99, 19] = new ParserAction(ParserActions.Reduce, 0, 21);    // Comma
            actionTable[99, 21] = new ParserAction(ParserActions.Reduce, 0, 21);    // DotDot
            actionTable[99, 27] = new ParserAction(ParserActions.Shift, 49, 0);    // Equal
            actionTable[99, 28] = new ParserAction(ParserActions.Shift, 50, 0);    // NotEqual
            actionTable[99, 34] = new ParserAction(ParserActions.Reduce, 0, 21);    // And
            actionTable[99, 35] = new ParserAction(ParserActions.Reduce, 0, 21);    // Or
            actionTable[99, 36] = new ParserAction(ParserActions.Reduce, 0, 21);    // Assignment
            actionTable[99, 37] = new ParserAction(ParserActions.Reduce, 0, 21);    // PlusAssignment
            actionTable[99, 38] = new ParserAction(ParserActions.Reduce, 0, 21);    // MinusAssignment
            actionTable[99, 39] = new ParserAction(ParserActions.Reduce, 0, 21);    // MultAssignment
            actionTable[99, 40] = new ParserAction(ParserActions.Reduce, 0, 21);    // DivAssignment
            actionTable[99, 41] = new ParserAction(ParserActions.Reduce, 0, 21);    // ModAssignment
            actionTable[99, 45] = new ParserAction(ParserActions.Reduce, 0, 21);    // LogicalAnd
            actionTable[99, 46] = new ParserAction(ParserActions.Reduce, 0, 21);    // LogicalOr
            actionTable[99, 47] = new ParserAction(ParserActions.Reduce, 0, 21);    // LogicalXor
            actionTable[99, 48] = new ParserAction(ParserActions.Reduce, 0, 21);    // LShiftAssignment
            actionTable[99, 49] = new ParserAction(ParserActions.Reduce, 0, 21);    // RShiftAssignment
            actionTable[99, 50] = new ParserAction(ParserActions.Reduce, 0, 21);    // AndAssignment
            actionTable[99, 51] = new ParserAction(ParserActions.Reduce, 0, 21);    // XorAssignment
            actionTable[99, 52] = new ParserAction(ParserActions.Reduce, 0, 21);    // OrAssignment

            // State 100
            actionTable[100, 0] = new ParserAction(ParserActions.Reduce, 0, 23);    // EOF
            actionTable[100, 14] = new ParserAction(ParserActions.Reduce, 0, 23);    // RParan
            actionTable[100, 16] = new ParserAction(ParserActions.Reduce, 0, 23);    // RSqr
            actionTable[100, 18] = new ParserAction(ParserActions.Reduce, 0, 23);    // RCurly
            actionTable[100, 19] = new ParserAction(ParserActions.Reduce, 0, 23);    // Comma
            actionTable[100, 21] = new ParserAction(ParserActions.Reduce, 0, 23);    // DotDot
            actionTable[100, 27] = new ParserAction(ParserActions.Reduce, 0, 23);    // Equal
            actionTable[100, 28] = new ParserAction(ParserActions.Reduce, 0, 23);    // NotEqual
            actionTable[100, 29] = new ParserAction(ParserActions.Shift, 51, 0);    // Lesser
            actionTable[100, 30] = new ParserAction(ParserActions.Shift, 52, 0);    // Greater
            actionTable[100, 31] = new ParserAction(ParserActions.Shift, 53, 0);    // LesserOrEqual
            actionTable[100, 32] = new ParserAction(ParserActions.Shift, 54, 0);    // GreaterOrEqual
            actionTable[100, 34] = new ParserAction(ParserActions.Reduce, 0, 23);    // And
            actionTable[100, 35] = new ParserAction(ParserActions.Reduce, 0, 23);    // Or
            actionTable[100, 36] = new ParserAction(ParserActions.Reduce, 0, 23);    // Assignment
            actionTable[100, 37] = new ParserAction(ParserActions.Reduce, 0, 23);    // PlusAssignment
            actionTable[100, 38] = new ParserAction(ParserActions.Reduce, 0, 23);    // MinusAssignment
            actionTable[100, 39] = new ParserAction(ParserActions.Reduce, 0, 23);    // MultAssignment
            actionTable[100, 40] = new ParserAction(ParserActions.Reduce, 0, 23);    // DivAssignment
            actionTable[100, 41] = new ParserAction(ParserActions.Reduce, 0, 23);    // ModAssignment
            actionTable[100, 45] = new ParserAction(ParserActions.Reduce, 0, 23);    // LogicalAnd
            actionTable[100, 46] = new ParserAction(ParserActions.Reduce, 0, 23);    // LogicalOr
            actionTable[100, 47] = new ParserAction(ParserActions.Reduce, 0, 23);    // LogicalXor
            actionTable[100, 48] = new ParserAction(ParserActions.Reduce, 0, 23);    // LShiftAssignment
            actionTable[100, 49] = new ParserAction(ParserActions.Reduce, 0, 23);    // RShiftAssignment
            actionTable[100, 50] = new ParserAction(ParserActions.Reduce, 0, 23);    // AndAssignment
            actionTable[100, 51] = new ParserAction(ParserActions.Reduce, 0, 23);    // XorAssignment
            actionTable[100, 52] = new ParserAction(ParserActions.Reduce, 0, 23);    // OrAssignment

            // State 101
            actionTable[101, 0] = new ParserAction(ParserActions.Reduce, 0, 24);    // EOF
            actionTable[101, 14] = new ParserAction(ParserActions.Reduce, 0, 24);    // RParan
            actionTable[101, 16] = new ParserAction(ParserActions.Reduce, 0, 24);    // RSqr
            actionTable[101, 18] = new ParserAction(ParserActions.Reduce, 0, 24);    // RCurly
            actionTable[101, 19] = new ParserAction(ParserActions.Reduce, 0, 24);    // Comma
            actionTable[101, 21] = new ParserAction(ParserActions.Reduce, 0, 24);    // DotDot
            actionTable[101, 27] = new ParserAction(ParserActions.Reduce, 0, 24);    // Equal
            actionTable[101, 28] = new ParserAction(ParserActions.Reduce, 0, 24);    // NotEqual
            actionTable[101, 29] = new ParserAction(ParserActions.Shift, 51, 0);    // Lesser
            actionTable[101, 30] = new ParserAction(ParserActions.Shift, 52, 0);    // Greater
            actionTable[101, 31] = new ParserAction(ParserActions.Shift, 53, 0);    // LesserOrEqual
            actionTable[101, 32] = new ParserAction(ParserActions.Shift, 54, 0);    // GreaterOrEqual
            actionTable[101, 34] = new ParserAction(ParserActions.Reduce, 0, 24);    // And
            actionTable[101, 35] = new ParserAction(ParserActions.Reduce, 0, 24);    // Or
            actionTable[101, 36] = new ParserAction(ParserActions.Reduce, 0, 24);    // Assignment
            actionTable[101, 37] = new ParserAction(ParserActions.Reduce, 0, 24);    // PlusAssignment
            actionTable[101, 38] = new ParserAction(ParserActions.Reduce, 0, 24);    // MinusAssignment
            actionTable[101, 39] = new ParserAction(ParserActions.Reduce, 0, 24);    // MultAssignment
            actionTable[101, 40] = new ParserAction(ParserActions.Reduce, 0, 24);    // DivAssignment
            actionTable[101, 41] = new ParserAction(ParserActions.Reduce, 0, 24);    // ModAssignment
            actionTable[101, 45] = new ParserAction(ParserActions.Reduce, 0, 24);    // LogicalAnd
            actionTable[101, 46] = new ParserAction(ParserActions.Reduce, 0, 24);    // LogicalOr
            actionTable[101, 47] = new ParserAction(ParserActions.Reduce, 0, 24);    // LogicalXor
            actionTable[101, 48] = new ParserAction(ParserActions.Reduce, 0, 24);    // LShiftAssignment
            actionTable[101, 49] = new ParserAction(ParserActions.Reduce, 0, 24);    // RShiftAssignment
            actionTable[101, 50] = new ParserAction(ParserActions.Reduce, 0, 24);    // AndAssignment
            actionTable[101, 51] = new ParserAction(ParserActions.Reduce, 0, 24);    // XorAssignment
            actionTable[101, 52] = new ParserAction(ParserActions.Reduce, 0, 24);    // OrAssignment

            // State 102
            actionTable[102, 0] = new ParserAction(ParserActions.Reduce, 0, 26);    // EOF
            actionTable[102, 14] = new ParserAction(ParserActions.Reduce, 0, 26);    // RParan
            actionTable[102, 16] = new ParserAction(ParserActions.Reduce, 0, 26);    // RSqr
            actionTable[102, 18] = new ParserAction(ParserActions.Reduce, 0, 26);    // RCurly
            actionTable[102, 19] = new ParserAction(ParserActions.Reduce, 0, 26);    // Comma
            actionTable[102, 21] = new ParserAction(ParserActions.Reduce, 0, 26);    // DotDot
            actionTable[102, 27] = new ParserAction(ParserActions.Reduce, 0, 26);    // Equal
            actionTable[102, 28] = new ParserAction(ParserActions.Reduce, 0, 26);    // NotEqual
            actionTable[102, 29] = new ParserAction(ParserActions.Reduce, 0, 26);    // Lesser
            actionTable[102, 30] = new ParserAction(ParserActions.Reduce, 0, 26);    // Greater
            actionTable[102, 31] = new ParserAction(ParserActions.Reduce, 0, 26);    // LesserOrEqual
            actionTable[102, 32] = new ParserAction(ParserActions.Reduce, 0, 26);    // GreaterOrEqual
            actionTable[102, 34] = new ParserAction(ParserActions.Reduce, 0, 26);    // And
            actionTable[102, 35] = new ParserAction(ParserActions.Reduce, 0, 26);    // Or
            actionTable[102, 36] = new ParserAction(ParserActions.Reduce, 0, 26);    // Assignment
            actionTable[102, 37] = new ParserAction(ParserActions.Reduce, 0, 26);    // PlusAssignment
            actionTable[102, 38] = new ParserAction(ParserActions.Reduce, 0, 26);    // MinusAssignment
            actionTable[102, 39] = new ParserAction(ParserActions.Reduce, 0, 26);    // MultAssignment
            actionTable[102, 40] = new ParserAction(ParserActions.Reduce, 0, 26);    // DivAssignment
            actionTable[102, 41] = new ParserAction(ParserActions.Reduce, 0, 26);    // ModAssignment
            actionTable[102, 42] = new ParserAction(ParserActions.Shift, 55, 0);    // LShift
            actionTable[102, 43] = new ParserAction(ParserActions.Shift, 56, 0);    // RShift
            actionTable[102, 45] = new ParserAction(ParserActions.Reduce, 0, 26);    // LogicalAnd
            actionTable[102, 46] = new ParserAction(ParserActions.Reduce, 0, 26);    // LogicalOr
            actionTable[102, 47] = new ParserAction(ParserActions.Reduce, 0, 26);    // LogicalXor
            actionTable[102, 48] = new ParserAction(ParserActions.Reduce, 0, 26);    // LShiftAssignment
            actionTable[102, 49] = new ParserAction(ParserActions.Reduce, 0, 26);    // RShiftAssignment
            actionTable[102, 50] = new ParserAction(ParserActions.Reduce, 0, 26);    // AndAssignment
            actionTable[102, 51] = new ParserAction(ParserActions.Reduce, 0, 26);    // XorAssignment
            actionTable[102, 52] = new ParserAction(ParserActions.Reduce, 0, 26);    // OrAssignment

            // State 103
            actionTable[103, 0] = new ParserAction(ParserActions.Reduce, 0, 27);    // EOF
            actionTable[103, 14] = new ParserAction(ParserActions.Reduce, 0, 27);    // RParan
            actionTable[103, 16] = new ParserAction(ParserActions.Reduce, 0, 27);    // RSqr
            actionTable[103, 18] = new ParserAction(ParserActions.Reduce, 0, 27);    // RCurly
            actionTable[103, 19] = new ParserAction(ParserActions.Reduce, 0, 27);    // Comma
            actionTable[103, 21] = new ParserAction(ParserActions.Reduce, 0, 27);    // DotDot
            actionTable[103, 27] = new ParserAction(ParserActions.Reduce, 0, 27);    // Equal
            actionTable[103, 28] = new ParserAction(ParserActions.Reduce, 0, 27);    // NotEqual
            actionTable[103, 29] = new ParserAction(ParserActions.Reduce, 0, 27);    // Lesser
            actionTable[103, 30] = new ParserAction(ParserActions.Reduce, 0, 27);    // Greater
            actionTable[103, 31] = new ParserAction(ParserActions.Reduce, 0, 27);    // LesserOrEqual
            actionTable[103, 32] = new ParserAction(ParserActions.Reduce, 0, 27);    // GreaterOrEqual
            actionTable[103, 34] = new ParserAction(ParserActions.Reduce, 0, 27);    // And
            actionTable[103, 35] = new ParserAction(ParserActions.Reduce, 0, 27);    // Or
            actionTable[103, 36] = new ParserAction(ParserActions.Reduce, 0, 27);    // Assignment
            actionTable[103, 37] = new ParserAction(ParserActions.Reduce, 0, 27);    // PlusAssignment
            actionTable[103, 38] = new ParserAction(ParserActions.Reduce, 0, 27);    // MinusAssignment
            actionTable[103, 39] = new ParserAction(ParserActions.Reduce, 0, 27);    // MultAssignment
            actionTable[103, 40] = new ParserAction(ParserActions.Reduce, 0, 27);    // DivAssignment
            actionTable[103, 41] = new ParserAction(ParserActions.Reduce, 0, 27);    // ModAssignment
            actionTable[103, 42] = new ParserAction(ParserActions.Shift, 55, 0);    // LShift
            actionTable[103, 43] = new ParserAction(ParserActions.Shift, 56, 0);    // RShift
            actionTable[103, 45] = new ParserAction(ParserActions.Reduce, 0, 27);    // LogicalAnd
            actionTable[103, 46] = new ParserAction(ParserActions.Reduce, 0, 27);    // LogicalOr
            actionTable[103, 47] = new ParserAction(ParserActions.Reduce, 0, 27);    // LogicalXor
            actionTable[103, 48] = new ParserAction(ParserActions.Reduce, 0, 27);    // LShiftAssignment
            actionTable[103, 49] = new ParserAction(ParserActions.Reduce, 0, 27);    // RShiftAssignment
            actionTable[103, 50] = new ParserAction(ParserActions.Reduce, 0, 27);    // AndAssignment
            actionTable[103, 51] = new ParserAction(ParserActions.Reduce, 0, 27);    // XorAssignment
            actionTable[103, 52] = new ParserAction(ParserActions.Reduce, 0, 27);    // OrAssignment

            // State 104
            actionTable[104, 0] = new ParserAction(ParserActions.Reduce, 0, 28);    // EOF
            actionTable[104, 14] = new ParserAction(ParserActions.Reduce, 0, 28);    // RParan
            actionTable[104, 16] = new ParserAction(ParserActions.Reduce, 0, 28);    // RSqr
            actionTable[104, 18] = new ParserAction(ParserActions.Reduce, 0, 28);    // RCurly
            actionTable[104, 19] = new ParserAction(ParserActions.Reduce, 0, 28);    // Comma
            actionTable[104, 21] = new ParserAction(ParserActions.Reduce, 0, 28);    // DotDot
            actionTable[104, 27] = new ParserAction(ParserActions.Reduce, 0, 28);    // Equal
            actionTable[104, 28] = new ParserAction(ParserActions.Reduce, 0, 28);    // NotEqual
            actionTable[104, 29] = new ParserAction(ParserActions.Reduce, 0, 28);    // Lesser
            actionTable[104, 30] = new ParserAction(ParserActions.Reduce, 0, 28);    // Greater
            actionTable[104, 31] = new ParserAction(ParserActions.Reduce, 0, 28);    // LesserOrEqual
            actionTable[104, 32] = new ParserAction(ParserActions.Reduce, 0, 28);    // GreaterOrEqual
            actionTable[104, 34] = new ParserAction(ParserActions.Reduce, 0, 28);    // And
            actionTable[104, 35] = new ParserAction(ParserActions.Reduce, 0, 28);    // Or
            actionTable[104, 36] = new ParserAction(ParserActions.Reduce, 0, 28);    // Assignment
            actionTable[104, 37] = new ParserAction(ParserActions.Reduce, 0, 28);    // PlusAssignment
            actionTable[104, 38] = new ParserAction(ParserActions.Reduce, 0, 28);    // MinusAssignment
            actionTable[104, 39] = new ParserAction(ParserActions.Reduce, 0, 28);    // MultAssignment
            actionTable[104, 40] = new ParserAction(ParserActions.Reduce, 0, 28);    // DivAssignment
            actionTable[104, 41] = new ParserAction(ParserActions.Reduce, 0, 28);    // ModAssignment
            actionTable[104, 42] = new ParserAction(ParserActions.Shift, 55, 0);    // LShift
            actionTable[104, 43] = new ParserAction(ParserActions.Shift, 56, 0);    // RShift
            actionTable[104, 45] = new ParserAction(ParserActions.Reduce, 0, 28);    // LogicalAnd
            actionTable[104, 46] = new ParserAction(ParserActions.Reduce, 0, 28);    // LogicalOr
            actionTable[104, 47] = new ParserAction(ParserActions.Reduce, 0, 28);    // LogicalXor
            actionTable[104, 48] = new ParserAction(ParserActions.Reduce, 0, 28);    // LShiftAssignment
            actionTable[104, 49] = new ParserAction(ParserActions.Reduce, 0, 28);    // RShiftAssignment
            actionTable[104, 50] = new ParserAction(ParserActions.Reduce, 0, 28);    // AndAssignment
            actionTable[104, 51] = new ParserAction(ParserActions.Reduce, 0, 28);    // XorAssignment
            actionTable[104, 52] = new ParserAction(ParserActions.Reduce, 0, 28);    // OrAssignment

            // State 105
            actionTable[105, 0] = new ParserAction(ParserActions.Reduce, 0, 29);    // EOF
            actionTable[105, 14] = new ParserAction(ParserActions.Reduce, 0, 29);    // RParan
            actionTable[105, 16] = new ParserAction(ParserActions.Reduce, 0, 29);    // RSqr
            actionTable[105, 18] = new ParserAction(ParserActions.Reduce, 0, 29);    // RCurly
            actionTable[105, 19] = new ParserAction(ParserActions.Reduce, 0, 29);    // Comma
            actionTable[105, 21] = new ParserAction(ParserActions.Reduce, 0, 29);    // DotDot
            actionTable[105, 27] = new ParserAction(ParserActions.Reduce, 0, 29);    // Equal
            actionTable[105, 28] = new ParserAction(ParserActions.Reduce, 0, 29);    // NotEqual
            actionTable[105, 29] = new ParserAction(ParserActions.Reduce, 0, 29);    // Lesser
            actionTable[105, 30] = new ParserAction(ParserActions.Reduce, 0, 29);    // Greater
            actionTable[105, 31] = new ParserAction(ParserActions.Reduce, 0, 29);    // LesserOrEqual
            actionTable[105, 32] = new ParserAction(ParserActions.Reduce, 0, 29);    // GreaterOrEqual
            actionTable[105, 34] = new ParserAction(ParserActions.Reduce, 0, 29);    // And
            actionTable[105, 35] = new ParserAction(ParserActions.Reduce, 0, 29);    // Or
            actionTable[105, 36] = new ParserAction(ParserActions.Reduce, 0, 29);    // Assignment
            actionTable[105, 37] = new ParserAction(ParserActions.Reduce, 0, 29);    // PlusAssignment
            actionTable[105, 38] = new ParserAction(ParserActions.Reduce, 0, 29);    // MinusAssignment
            actionTable[105, 39] = new ParserAction(ParserActions.Reduce, 0, 29);    // MultAssignment
            actionTable[105, 40] = new ParserAction(ParserActions.Reduce, 0, 29);    // DivAssignment
            actionTable[105, 41] = new ParserAction(ParserActions.Reduce, 0, 29);    // ModAssignment
            actionTable[105, 42] = new ParserAction(ParserActions.Shift, 55, 0);    // LShift
            actionTable[105, 43] = new ParserAction(ParserActions.Shift, 56, 0);    // RShift
            actionTable[105, 45] = new ParserAction(ParserActions.Reduce, 0, 29);    // LogicalAnd
            actionTable[105, 46] = new ParserAction(ParserActions.Reduce, 0, 29);    // LogicalOr
            actionTable[105, 47] = new ParserAction(ParserActions.Reduce, 0, 29);    // LogicalXor
            actionTable[105, 48] = new ParserAction(ParserActions.Reduce, 0, 29);    // LShiftAssignment
            actionTable[105, 49] = new ParserAction(ParserActions.Reduce, 0, 29);    // RShiftAssignment
            actionTable[105, 50] = new ParserAction(ParserActions.Reduce, 0, 29);    // AndAssignment
            actionTable[105, 51] = new ParserAction(ParserActions.Reduce, 0, 29);    // XorAssignment
            actionTable[105, 52] = new ParserAction(ParserActions.Reduce, 0, 29);    // OrAssignment

            // State 106
            actionTable[106, 0] = new ParserAction(ParserActions.Reduce, 0, 31);    // EOF
            actionTable[106, 14] = new ParserAction(ParserActions.Reduce, 0, 31);    // RParan
            actionTable[106, 16] = new ParserAction(ParserActions.Reduce, 0, 31);    // RSqr
            actionTable[106, 18] = new ParserAction(ParserActions.Reduce, 0, 31);    // RCurly
            actionTable[106, 19] = new ParserAction(ParserActions.Reduce, 0, 31);    // Comma
            actionTable[106, 21] = new ParserAction(ParserActions.Reduce, 0, 31);    // DotDot
            actionTable[106, 22] = new ParserAction(ParserActions.Shift, 57, 0);    // Plus
            actionTable[106, 23] = new ParserAction(ParserActions.Shift, 58, 0);    // Minus
            actionTable[106, 27] = new ParserAction(ParserActions.Reduce, 0, 31);    // Equal
            actionTable[106, 28] = new ParserAction(ParserActions.Reduce, 0, 31);    // NotEqual
            actionTable[106, 29] = new ParserAction(ParserActions.Reduce, 0, 31);    // Lesser
            actionTable[106, 30] = new ParserAction(ParserActions.Reduce, 0, 31);    // Greater
            actionTable[106, 31] = new ParserAction(ParserActions.Reduce, 0, 31);    // LesserOrEqual
            actionTable[106, 32] = new ParserAction(ParserActions.Reduce, 0, 31);    // GreaterOrEqual
            actionTable[106, 34] = new ParserAction(ParserActions.Reduce, 0, 31);    // And
            actionTable[106, 35] = new ParserAction(ParserActions.Reduce, 0, 31);    // Or
            actionTable[106, 36] = new ParserAction(ParserActions.Reduce, 0, 31);    // Assignment
            actionTable[106, 37] = new ParserAction(ParserActions.Reduce, 0, 31);    // PlusAssignment
            actionTable[106, 38] = new ParserAction(ParserActions.Reduce, 0, 31);    // MinusAssignment
            actionTable[106, 39] = new ParserAction(ParserActions.Reduce, 0, 31);    // MultAssignment
            actionTable[106, 40] = new ParserAction(ParserActions.Reduce, 0, 31);    // DivAssignment
            actionTable[106, 41] = new ParserAction(ParserActions.Reduce, 0, 31);    // ModAssignment
            actionTable[106, 42] = new ParserAction(ParserActions.Reduce, 0, 31);    // LShift
            actionTable[106, 43] = new ParserAction(ParserActions.Reduce, 0, 31);    // RShift
            actionTable[106, 45] = new ParserAction(ParserActions.Reduce, 0, 31);    // LogicalAnd
            actionTable[106, 46] = new ParserAction(ParserActions.Reduce, 0, 31);    // LogicalOr
            actionTable[106, 47] = new ParserAction(ParserActions.Reduce, 0, 31);    // LogicalXor
            actionTable[106, 48] = new ParserAction(ParserActions.Reduce, 0, 31);    // LShiftAssignment
            actionTable[106, 49] = new ParserAction(ParserActions.Reduce, 0, 31);    // RShiftAssignment
            actionTable[106, 50] = new ParserAction(ParserActions.Reduce, 0, 31);    // AndAssignment
            actionTable[106, 51] = new ParserAction(ParserActions.Reduce, 0, 31);    // XorAssignment
            actionTable[106, 52] = new ParserAction(ParserActions.Reduce, 0, 31);    // OrAssignment

            // State 107
            actionTable[107, 0] = new ParserAction(ParserActions.Reduce, 0, 32);    // EOF
            actionTable[107, 14] = new ParserAction(ParserActions.Reduce, 0, 32);    // RParan
            actionTable[107, 16] = new ParserAction(ParserActions.Reduce, 0, 32);    // RSqr
            actionTable[107, 18] = new ParserAction(ParserActions.Reduce, 0, 32);    // RCurly
            actionTable[107, 19] = new ParserAction(ParserActions.Reduce, 0, 32);    // Comma
            actionTable[107, 21] = new ParserAction(ParserActions.Reduce, 0, 32);    // DotDot
            actionTable[107, 22] = new ParserAction(ParserActions.Shift, 57, 0);    // Plus
            actionTable[107, 23] = new ParserAction(ParserActions.Shift, 58, 0);    // Minus
            actionTable[107, 27] = new ParserAction(ParserActions.Reduce, 0, 32);    // Equal
            actionTable[107, 28] = new ParserAction(ParserActions.Reduce, 0, 32);    // NotEqual
            actionTable[107, 29] = new ParserAction(ParserActions.Reduce, 0, 32);    // Lesser
            actionTable[107, 30] = new ParserAction(ParserActions.Reduce, 0, 32);    // Greater
            actionTable[107, 31] = new ParserAction(ParserActions.Reduce, 0, 32);    // LesserOrEqual
            actionTable[107, 32] = new ParserAction(ParserActions.Reduce, 0, 32);    // GreaterOrEqual
            actionTable[107, 34] = new ParserAction(ParserActions.Reduce, 0, 32);    // And
            actionTable[107, 35] = new ParserAction(ParserActions.Reduce, 0, 32);    // Or
            actionTable[107, 36] = new ParserAction(ParserActions.Reduce, 0, 32);    // Assignment
            actionTable[107, 37] = new ParserAction(ParserActions.Reduce, 0, 32);    // PlusAssignment
            actionTable[107, 38] = new ParserAction(ParserActions.Reduce, 0, 32);    // MinusAssignment
            actionTable[107, 39] = new ParserAction(ParserActions.Reduce, 0, 32);    // MultAssignment
            actionTable[107, 40] = new ParserAction(ParserActions.Reduce, 0, 32);    // DivAssignment
            actionTable[107, 41] = new ParserAction(ParserActions.Reduce, 0, 32);    // ModAssignment
            actionTable[107, 42] = new ParserAction(ParserActions.Reduce, 0, 32);    // LShift
            actionTable[107, 43] = new ParserAction(ParserActions.Reduce, 0, 32);    // RShift
            actionTable[107, 45] = new ParserAction(ParserActions.Reduce, 0, 32);    // LogicalAnd
            actionTable[107, 46] = new ParserAction(ParserActions.Reduce, 0, 32);    // LogicalOr
            actionTable[107, 47] = new ParserAction(ParserActions.Reduce, 0, 32);    // LogicalXor
            actionTable[107, 48] = new ParserAction(ParserActions.Reduce, 0, 32);    // LShiftAssignment
            actionTable[107, 49] = new ParserAction(ParserActions.Reduce, 0, 32);    // RShiftAssignment
            actionTable[107, 50] = new ParserAction(ParserActions.Reduce, 0, 32);    // AndAssignment
            actionTable[107, 51] = new ParserAction(ParserActions.Reduce, 0, 32);    // XorAssignment
            actionTable[107, 52] = new ParserAction(ParserActions.Reduce, 0, 32);    // OrAssignment

            // State 108
            actionTable[108, 0] = new ParserAction(ParserActions.Reduce, 0, 34);    // EOF
            actionTable[108, 14] = new ParserAction(ParserActions.Reduce, 0, 34);    // RParan
            actionTable[108, 16] = new ParserAction(ParserActions.Reduce, 0, 34);    // RSqr
            actionTable[108, 18] = new ParserAction(ParserActions.Reduce, 0, 34);    // RCurly
            actionTable[108, 19] = new ParserAction(ParserActions.Reduce, 0, 34);    // Comma
            actionTable[108, 21] = new ParserAction(ParserActions.Reduce, 0, 34);    // DotDot
            actionTable[108, 22] = new ParserAction(ParserActions.Reduce, 0, 34);    // Plus
            actionTable[108, 23] = new ParserAction(ParserActions.Reduce, 0, 34);    // Minus
            actionTable[108, 24] = new ParserAction(ParserActions.Shift, 59, 0);    // Mult
            actionTable[108, 25] = new ParserAction(ParserActions.Shift, 60, 0);    // Div
            actionTable[108, 26] = new ParserAction(ParserActions.Shift, 61, 0);    // Mod
            actionTable[108, 27] = new ParserAction(ParserActions.Reduce, 0, 34);    // Equal
            actionTable[108, 28] = new ParserAction(ParserActions.Reduce, 0, 34);    // NotEqual
            actionTable[108, 29] = new ParserAction(ParserActions.Reduce, 0, 34);    // Lesser
            actionTable[108, 30] = new ParserAction(ParserActions.Reduce, 0, 34);    // Greater
            actionTable[108, 31] = new ParserAction(ParserActions.Reduce, 0, 34);    // LesserOrEqual
            actionTable[108, 32] = new ParserAction(ParserActions.Reduce, 0, 34);    // GreaterOrEqual
            actionTable[108, 34] = new ParserAction(ParserActions.Reduce, 0, 34);    // And
            actionTable[108, 35] = new ParserAction(ParserActions.Reduce, 0, 34);    // Or
            actionTable[108, 36] = new ParserAction(ParserActions.Reduce, 0, 34);    // Assignment
            actionTable[108, 37] = new ParserAction(ParserActions.Reduce, 0, 34);    // PlusAssignment
            actionTable[108, 38] = new ParserAction(ParserActions.Reduce, 0, 34);    // MinusAssignment
            actionTable[108, 39] = new ParserAction(ParserActions.Reduce, 0, 34);    // MultAssignment
            actionTable[108, 40] = new ParserAction(ParserActions.Reduce, 0, 34);    // DivAssignment
            actionTable[108, 41] = new ParserAction(ParserActions.Reduce, 0, 34);    // ModAssignment
            actionTable[108, 42] = new ParserAction(ParserActions.Reduce, 0, 34);    // LShift
            actionTable[108, 43] = new ParserAction(ParserActions.Reduce, 0, 34);    // RShift
            actionTable[108, 45] = new ParserAction(ParserActions.Reduce, 0, 34);    // LogicalAnd
            actionTable[108, 46] = new ParserAction(ParserActions.Reduce, 0, 34);    // LogicalOr
            actionTable[108, 47] = new ParserAction(ParserActions.Reduce, 0, 34);    // LogicalXor
            actionTable[108, 48] = new ParserAction(ParserActions.Reduce, 0, 34);    // LShiftAssignment
            actionTable[108, 49] = new ParserAction(ParserActions.Reduce, 0, 34);    // RShiftAssignment
            actionTable[108, 50] = new ParserAction(ParserActions.Reduce, 0, 34);    // AndAssignment
            actionTable[108, 51] = new ParserAction(ParserActions.Reduce, 0, 34);    // XorAssignment
            actionTable[108, 52] = new ParserAction(ParserActions.Reduce, 0, 34);    // OrAssignment

            // State 109
            actionTable[109, 0] = new ParserAction(ParserActions.Reduce, 0, 35);    // EOF
            actionTable[109, 14] = new ParserAction(ParserActions.Reduce, 0, 35);    // RParan
            actionTable[109, 16] = new ParserAction(ParserActions.Reduce, 0, 35);    // RSqr
            actionTable[109, 18] = new ParserAction(ParserActions.Reduce, 0, 35);    // RCurly
            actionTable[109, 19] = new ParserAction(ParserActions.Reduce, 0, 35);    // Comma
            actionTable[109, 21] = new ParserAction(ParserActions.Reduce, 0, 35);    // DotDot
            actionTable[109, 22] = new ParserAction(ParserActions.Reduce, 0, 35);    // Plus
            actionTable[109, 23] = new ParserAction(ParserActions.Reduce, 0, 35);    // Minus
            actionTable[109, 24] = new ParserAction(ParserActions.Shift, 59, 0);    // Mult
            actionTable[109, 25] = new ParserAction(ParserActions.Shift, 60, 0);    // Div
            actionTable[109, 26] = new ParserAction(ParserActions.Shift, 61, 0);    // Mod
            actionTable[109, 27] = new ParserAction(ParserActions.Reduce, 0, 35);    // Equal
            actionTable[109, 28] = new ParserAction(ParserActions.Reduce, 0, 35);    // NotEqual
            actionTable[109, 29] = new ParserAction(ParserActions.Reduce, 0, 35);    // Lesser
            actionTable[109, 30] = new ParserAction(ParserActions.Reduce, 0, 35);    // Greater
            actionTable[109, 31] = new ParserAction(ParserActions.Reduce, 0, 35);    // LesserOrEqual
            actionTable[109, 32] = new ParserAction(ParserActions.Reduce, 0, 35);    // GreaterOrEqual
            actionTable[109, 34] = new ParserAction(ParserActions.Reduce, 0, 35);    // And
            actionTable[109, 35] = new ParserAction(ParserActions.Reduce, 0, 35);    // Or
            actionTable[109, 36] = new ParserAction(ParserActions.Reduce, 0, 35);    // Assignment
            actionTable[109, 37] = new ParserAction(ParserActions.Reduce, 0, 35);    // PlusAssignment
            actionTable[109, 38] = new ParserAction(ParserActions.Reduce, 0, 35);    // MinusAssignment
            actionTable[109, 39] = new ParserAction(ParserActions.Reduce, 0, 35);    // MultAssignment
            actionTable[109, 40] = new ParserAction(ParserActions.Reduce, 0, 35);    // DivAssignment
            actionTable[109, 41] = new ParserAction(ParserActions.Reduce, 0, 35);    // ModAssignment
            actionTable[109, 42] = new ParserAction(ParserActions.Reduce, 0, 35);    // LShift
            actionTable[109, 43] = new ParserAction(ParserActions.Reduce, 0, 35);    // RShift
            actionTable[109, 45] = new ParserAction(ParserActions.Reduce, 0, 35);    // LogicalAnd
            actionTable[109, 46] = new ParserAction(ParserActions.Reduce, 0, 35);    // LogicalOr
            actionTable[109, 47] = new ParserAction(ParserActions.Reduce, 0, 35);    // LogicalXor
            actionTable[109, 48] = new ParserAction(ParserActions.Reduce, 0, 35);    // LShiftAssignment
            actionTable[109, 49] = new ParserAction(ParserActions.Reduce, 0, 35);    // RShiftAssignment
            actionTable[109, 50] = new ParserAction(ParserActions.Reduce, 0, 35);    // AndAssignment
            actionTable[109, 51] = new ParserAction(ParserActions.Reduce, 0, 35);    // XorAssignment
            actionTable[109, 52] = new ParserAction(ParserActions.Reduce, 0, 35);    // OrAssignment

            // State 110
            actionTable[110, 0] = new ParserAction(ParserActions.Reduce, 0, 37);    // EOF
            actionTable[110, 14] = new ParserAction(ParserActions.Reduce, 0, 37);    // RParan
            actionTable[110, 16] = new ParserAction(ParserActions.Reduce, 0, 37);    // RSqr
            actionTable[110, 18] = new ParserAction(ParserActions.Reduce, 0, 37);    // RCurly
            actionTable[110, 19] = new ParserAction(ParserActions.Reduce, 0, 37);    // Comma
            actionTable[110, 21] = new ParserAction(ParserActions.Reduce, 0, 37);    // DotDot
            actionTable[110, 22] = new ParserAction(ParserActions.Reduce, 0, 37);    // Plus
            actionTable[110, 23] = new ParserAction(ParserActions.Reduce, 0, 37);    // Minus
            actionTable[110, 24] = new ParserAction(ParserActions.Reduce, 0, 37);    // Mult
            actionTable[110, 25] = new ParserAction(ParserActions.Reduce, 0, 37);    // Div
            actionTable[110, 26] = new ParserAction(ParserActions.Reduce, 0, 37);    // Mod
            actionTable[110, 27] = new ParserAction(ParserActions.Reduce, 0, 37);    // Equal
            actionTable[110, 28] = new ParserAction(ParserActions.Reduce, 0, 37);    // NotEqual
            actionTable[110, 29] = new ParserAction(ParserActions.Reduce, 0, 37);    // Lesser
            actionTable[110, 30] = new ParserAction(ParserActions.Reduce, 0, 37);    // Greater
            actionTable[110, 31] = new ParserAction(ParserActions.Reduce, 0, 37);    // LesserOrEqual
            actionTable[110, 32] = new ParserAction(ParserActions.Reduce, 0, 37);    // GreaterOrEqual
            actionTable[110, 34] = new ParserAction(ParserActions.Reduce, 0, 37);    // And
            actionTable[110, 35] = new ParserAction(ParserActions.Reduce, 0, 37);    // Or
            actionTable[110, 36] = new ParserAction(ParserActions.Reduce, 0, 37);    // Assignment
            actionTable[110, 37] = new ParserAction(ParserActions.Reduce, 0, 37);    // PlusAssignment
            actionTable[110, 38] = new ParserAction(ParserActions.Reduce, 0, 37);    // MinusAssignment
            actionTable[110, 39] = new ParserAction(ParserActions.Reduce, 0, 37);    // MultAssignment
            actionTable[110, 40] = new ParserAction(ParserActions.Reduce, 0, 37);    // DivAssignment
            actionTable[110, 41] = new ParserAction(ParserActions.Reduce, 0, 37);    // ModAssignment
            actionTable[110, 42] = new ParserAction(ParserActions.Reduce, 0, 37);    // LShift
            actionTable[110, 43] = new ParserAction(ParserActions.Reduce, 0, 37);    // RShift
            actionTable[110, 45] = new ParserAction(ParserActions.Reduce, 0, 37);    // LogicalAnd
            actionTable[110, 46] = new ParserAction(ParserActions.Reduce, 0, 37);    // LogicalOr
            actionTable[110, 47] = new ParserAction(ParserActions.Reduce, 0, 37);    // LogicalXor
            actionTable[110, 48] = new ParserAction(ParserActions.Reduce, 0, 37);    // LShiftAssignment
            actionTable[110, 49] = new ParserAction(ParserActions.Reduce, 0, 37);    // RShiftAssignment
            actionTable[110, 50] = new ParserAction(ParserActions.Reduce, 0, 37);    // AndAssignment
            actionTable[110, 51] = new ParserAction(ParserActions.Reduce, 0, 37);    // XorAssignment
            actionTable[110, 52] = new ParserAction(ParserActions.Reduce, 0, 37);    // OrAssignment

            // State 111
            actionTable[111, 0] = new ParserAction(ParserActions.Reduce, 0, 38);    // EOF
            actionTable[111, 14] = new ParserAction(ParserActions.Reduce, 0, 38);    // RParan
            actionTable[111, 16] = new ParserAction(ParserActions.Reduce, 0, 38);    // RSqr
            actionTable[111, 18] = new ParserAction(ParserActions.Reduce, 0, 38);    // RCurly
            actionTable[111, 19] = new ParserAction(ParserActions.Reduce, 0, 38);    // Comma
            actionTable[111, 21] = new ParserAction(ParserActions.Reduce, 0, 38);    // DotDot
            actionTable[111, 22] = new ParserAction(ParserActions.Reduce, 0, 38);    // Plus
            actionTable[111, 23] = new ParserAction(ParserActions.Reduce, 0, 38);    // Minus
            actionTable[111, 24] = new ParserAction(ParserActions.Reduce, 0, 38);    // Mult
            actionTable[111, 25] = new ParserAction(ParserActions.Reduce, 0, 38);    // Div
            actionTable[111, 26] = new ParserAction(ParserActions.Reduce, 0, 38);    // Mod
            actionTable[111, 27] = new ParserAction(ParserActions.Reduce, 0, 38);    // Equal
            actionTable[111, 28] = new ParserAction(ParserActions.Reduce, 0, 38);    // NotEqual
            actionTable[111, 29] = new ParserAction(ParserActions.Reduce, 0, 38);    // Lesser
            actionTable[111, 30] = new ParserAction(ParserActions.Reduce, 0, 38);    // Greater
            actionTable[111, 31] = new ParserAction(ParserActions.Reduce, 0, 38);    // LesserOrEqual
            actionTable[111, 32] = new ParserAction(ParserActions.Reduce, 0, 38);    // GreaterOrEqual
            actionTable[111, 34] = new ParserAction(ParserActions.Reduce, 0, 38);    // And
            actionTable[111, 35] = new ParserAction(ParserActions.Reduce, 0, 38);    // Or
            actionTable[111, 36] = new ParserAction(ParserActions.Reduce, 0, 38);    // Assignment
            actionTable[111, 37] = new ParserAction(ParserActions.Reduce, 0, 38);    // PlusAssignment
            actionTable[111, 38] = new ParserAction(ParserActions.Reduce, 0, 38);    // MinusAssignment
            actionTable[111, 39] = new ParserAction(ParserActions.Reduce, 0, 38);    // MultAssignment
            actionTable[111, 40] = new ParserAction(ParserActions.Reduce, 0, 38);    // DivAssignment
            actionTable[111, 41] = new ParserAction(ParserActions.Reduce, 0, 38);    // ModAssignment
            actionTable[111, 42] = new ParserAction(ParserActions.Reduce, 0, 38);    // LShift
            actionTable[111, 43] = new ParserAction(ParserActions.Reduce, 0, 38);    // RShift
            actionTable[111, 45] = new ParserAction(ParserActions.Reduce, 0, 38);    // LogicalAnd
            actionTable[111, 46] = new ParserAction(ParserActions.Reduce, 0, 38);    // LogicalOr
            actionTable[111, 47] = new ParserAction(ParserActions.Reduce, 0, 38);    // LogicalXor
            actionTable[111, 48] = new ParserAction(ParserActions.Reduce, 0, 38);    // LShiftAssignment
            actionTable[111, 49] = new ParserAction(ParserActions.Reduce, 0, 38);    // RShiftAssignment
            actionTable[111, 50] = new ParserAction(ParserActions.Reduce, 0, 38);    // AndAssignment
            actionTable[111, 51] = new ParserAction(ParserActions.Reduce, 0, 38);    // XorAssignment
            actionTable[111, 52] = new ParserAction(ParserActions.Reduce, 0, 38);    // OrAssignment

            // State 112
            actionTable[112, 0] = new ParserAction(ParserActions.Reduce, 0, 39);    // EOF
            actionTable[112, 14] = new ParserAction(ParserActions.Reduce, 0, 39);    // RParan
            actionTable[112, 16] = new ParserAction(ParserActions.Reduce, 0, 39);    // RSqr
            actionTable[112, 18] = new ParserAction(ParserActions.Reduce, 0, 39);    // RCurly
            actionTable[112, 19] = new ParserAction(ParserActions.Reduce, 0, 39);    // Comma
            actionTable[112, 21] = new ParserAction(ParserActions.Reduce, 0, 39);    // DotDot
            actionTable[112, 22] = new ParserAction(ParserActions.Reduce, 0, 39);    // Plus
            actionTable[112, 23] = new ParserAction(ParserActions.Reduce, 0, 39);    // Minus
            actionTable[112, 24] = new ParserAction(ParserActions.Reduce, 0, 39);    // Mult
            actionTable[112, 25] = new ParserAction(ParserActions.Reduce, 0, 39);    // Div
            actionTable[112, 26] = new ParserAction(ParserActions.Reduce, 0, 39);    // Mod
            actionTable[112, 27] = new ParserAction(ParserActions.Reduce, 0, 39);    // Equal
            actionTable[112, 28] = new ParserAction(ParserActions.Reduce, 0, 39);    // NotEqual
            actionTable[112, 29] = new ParserAction(ParserActions.Reduce, 0, 39);    // Lesser
            actionTable[112, 30] = new ParserAction(ParserActions.Reduce, 0, 39);    // Greater
            actionTable[112, 31] = new ParserAction(ParserActions.Reduce, 0, 39);    // LesserOrEqual
            actionTable[112, 32] = new ParserAction(ParserActions.Reduce, 0, 39);    // GreaterOrEqual
            actionTable[112, 34] = new ParserAction(ParserActions.Reduce, 0, 39);    // And
            actionTable[112, 35] = new ParserAction(ParserActions.Reduce, 0, 39);    // Or
            actionTable[112, 36] = new ParserAction(ParserActions.Reduce, 0, 39);    // Assignment
            actionTable[112, 37] = new ParserAction(ParserActions.Reduce, 0, 39);    // PlusAssignment
            actionTable[112, 38] = new ParserAction(ParserActions.Reduce, 0, 39);    // MinusAssignment
            actionTable[112, 39] = new ParserAction(ParserActions.Reduce, 0, 39);    // MultAssignment
            actionTable[112, 40] = new ParserAction(ParserActions.Reduce, 0, 39);    // DivAssignment
            actionTable[112, 41] = new ParserAction(ParserActions.Reduce, 0, 39);    // ModAssignment
            actionTable[112, 42] = new ParserAction(ParserActions.Reduce, 0, 39);    // LShift
            actionTable[112, 43] = new ParserAction(ParserActions.Reduce, 0, 39);    // RShift
            actionTable[112, 45] = new ParserAction(ParserActions.Reduce, 0, 39);    // LogicalAnd
            actionTable[112, 46] = new ParserAction(ParserActions.Reduce, 0, 39);    // LogicalOr
            actionTable[112, 47] = new ParserAction(ParserActions.Reduce, 0, 39);    // LogicalXor
            actionTable[112, 48] = new ParserAction(ParserActions.Reduce, 0, 39);    // LShiftAssignment
            actionTable[112, 49] = new ParserAction(ParserActions.Reduce, 0, 39);    // RShiftAssignment
            actionTable[112, 50] = new ParserAction(ParserActions.Reduce, 0, 39);    // AndAssignment
            actionTable[112, 51] = new ParserAction(ParserActions.Reduce, 0, 39);    // XorAssignment
            actionTable[112, 52] = new ParserAction(ParserActions.Reduce, 0, 39);    // OrAssignment

            // State 113
            actionTable[113, 14] = new ParserAction(ParserActions.Shift, 128, 0);    // RParan

            // State 114
            actionTable[114, 16] = new ParserAction(ParserActions.Shift, 129, 0);    // RSqr

            // State 115
            actionTable[115, 18] = new ParserAction(ParserActions.Shift, 130, 0);    // RCurly
            actionTable[115, 19] = new ParserAction(ParserActions.Shift, 131, 0);    // Comma

            // State 116
            actionTable[116, 17] = new ParserAction(ParserActions.Shift, 132, 0);    // LCurly
            actionTable[116, 18] = new ParserAction(ParserActions.Reduce, 0, 73);    // RCurly
            actionTable[116, 19] = new ParserAction(ParserActions.Reduce, 0, 73);    // Comma
            actionTable[116, 55] = new ParserAction(ParserActions.Shift, 133, 0);    // ArrayDimensions

            // State 117
            actionTable[117, 0] = new ParserAction(ParserActions.Reduce, 0, 49);    // EOF
            actionTable[117, 13] = new ParserAction(ParserActions.Reduce, 0, 49);    // LParan
            actionTable[117, 14] = new ParserAction(ParserActions.Reduce, 0, 49);    // RParan
            actionTable[117, 15] = new ParserAction(ParserActions.Reduce, 0, 49);    // LSqr
            actionTable[117, 16] = new ParserAction(ParserActions.Reduce, 0, 49);    // RSqr
            actionTable[117, 17] = new ParserAction(ParserActions.Reduce, 0, 49);    // LCurly
            actionTable[117, 18] = new ParserAction(ParserActions.Reduce, 0, 49);    // RCurly
            actionTable[117, 19] = new ParserAction(ParserActions.Reduce, 0, 49);    // Comma
            actionTable[117, 20] = new ParserAction(ParserActions.Reduce, 0, 49);    // Dot
            actionTable[117, 21] = new ParserAction(ParserActions.Reduce, 0, 49);    // DotDot
            actionTable[117, 22] = new ParserAction(ParserActions.Reduce, 0, 49);    // Plus
            actionTable[117, 23] = new ParserAction(ParserActions.Reduce, 0, 49);    // Minus
            actionTable[117, 24] = new ParserAction(ParserActions.Reduce, 0, 49);    // Mult
            actionTable[117, 25] = new ParserAction(ParserActions.Reduce, 0, 49);    // Div
            actionTable[117, 26] = new ParserAction(ParserActions.Reduce, 0, 49);    // Mod
            actionTable[117, 27] = new ParserAction(ParserActions.Reduce, 0, 49);    // Equal
            actionTable[117, 28] = new ParserAction(ParserActions.Reduce, 0, 49);    // NotEqual
            actionTable[117, 29] = new ParserAction(ParserActions.Reduce, 0, 49);    // Lesser
            actionTable[117, 30] = new ParserAction(ParserActions.Reduce, 0, 49);    // Greater
            actionTable[117, 31] = new ParserAction(ParserActions.Reduce, 0, 49);    // LesserOrEqual
            actionTable[117, 32] = new ParserAction(ParserActions.Reduce, 0, 49);    // GreaterOrEqual
            actionTable[117, 34] = new ParserAction(ParserActions.Reduce, 0, 49);    // And
            actionTable[117, 35] = new ParserAction(ParserActions.Reduce, 0, 49);    // Or
            actionTable[117, 36] = new ParserAction(ParserActions.Reduce, 0, 49);    // Assignment
            actionTable[117, 37] = new ParserAction(ParserActions.Reduce, 0, 49);    // PlusAssignment
            actionTable[117, 38] = new ParserAction(ParserActions.Reduce, 0, 49);    // MinusAssignment
            actionTable[117, 39] = new ParserAction(ParserActions.Reduce, 0, 49);    // MultAssignment
            actionTable[117, 40] = new ParserAction(ParserActions.Reduce, 0, 49);    // DivAssignment
            actionTable[117, 41] = new ParserAction(ParserActions.Reduce, 0, 49);    // ModAssignment
            actionTable[117, 42] = new ParserAction(ParserActions.Reduce, 0, 49);    // LShift
            actionTable[117, 43] = new ParserAction(ParserActions.Reduce, 0, 49);    // RShift
            actionTable[117, 45] = new ParserAction(ParserActions.Reduce, 0, 49);    // LogicalAnd
            actionTable[117, 46] = new ParserAction(ParserActions.Reduce, 0, 49);    // LogicalOr
            actionTable[117, 47] = new ParserAction(ParserActions.Reduce, 0, 49);    // LogicalXor
            actionTable[117, 48] = new ParserAction(ParserActions.Reduce, 0, 49);    // LShiftAssignment
            actionTable[117, 49] = new ParserAction(ParserActions.Reduce, 0, 49);    // RShiftAssignment
            actionTable[117, 50] = new ParserAction(ParserActions.Reduce, 0, 49);    // AndAssignment
            actionTable[117, 51] = new ParserAction(ParserActions.Reduce, 0, 49);    // XorAssignment
            actionTable[117, 52] = new ParserAction(ParserActions.Reduce, 0, 49);    // OrAssignment
            actionTable[117, 53] = new ParserAction(ParserActions.Reduce, 0, 49);    // PlusPlus
            actionTable[117, 54] = new ParserAction(ParserActions.Reduce, 0, 49);    // MinusMinus

            // State 118
            actionTable[118, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[118, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[118, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[118, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[118, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[118, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[118, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[118, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[118, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[118, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[118, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[118, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[118, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[118, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[118, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[118, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[118, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[118, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[118, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[118, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[118, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[118, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 119
            actionTable[119, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[119, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[119, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[119, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[119, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[119, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[119, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[119, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[119, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[119, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[119, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[119, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[119, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[119, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[119, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[119, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[119, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[119, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[119, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[119, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[119, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[119, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 120
            actionTable[120, 12] = new ParserAction(ParserActions.Shift, 116, 0);    // Identifier

            // State 121
            actionTable[121, 0] = new ParserAction(ParserActions.Reduce, 0, 56);    // EOF
            actionTable[121, 13] = new ParserAction(ParserActions.Reduce, 0, 56);    // LParan
            actionTable[121, 14] = new ParserAction(ParserActions.Reduce, 0, 56);    // RParan
            actionTable[121, 15] = new ParserAction(ParserActions.Reduce, 0, 56);    // LSqr
            actionTable[121, 16] = new ParserAction(ParserActions.Reduce, 0, 56);    // RSqr
            actionTable[121, 17] = new ParserAction(ParserActions.Reduce, 0, 56);    // LCurly
            actionTable[121, 18] = new ParserAction(ParserActions.Reduce, 0, 56);    // RCurly
            actionTable[121, 19] = new ParserAction(ParserActions.Reduce, 0, 56);    // Comma
            actionTable[121, 20] = new ParserAction(ParserActions.Reduce, 0, 56);    // Dot
            actionTable[121, 21] = new ParserAction(ParserActions.Reduce, 0, 56);    // DotDot
            actionTable[121, 22] = new ParserAction(ParserActions.Reduce, 0, 56);    // Plus
            actionTable[121, 23] = new ParserAction(ParserActions.Reduce, 0, 56);    // Minus
            actionTable[121, 24] = new ParserAction(ParserActions.Reduce, 0, 56);    // Mult
            actionTable[121, 25] = new ParserAction(ParserActions.Reduce, 0, 56);    // Div
            actionTable[121, 26] = new ParserAction(ParserActions.Reduce, 0, 56);    // Mod
            actionTable[121, 27] = new ParserAction(ParserActions.Reduce, 0, 56);    // Equal
            actionTable[121, 28] = new ParserAction(ParserActions.Reduce, 0, 56);    // NotEqual
            actionTable[121, 29] = new ParserAction(ParserActions.Reduce, 0, 56);    // Lesser
            actionTable[121, 30] = new ParserAction(ParserActions.Reduce, 0, 56);    // Greater
            actionTable[121, 31] = new ParserAction(ParserActions.Reduce, 0, 56);    // LesserOrEqual
            actionTable[121, 32] = new ParserAction(ParserActions.Reduce, 0, 56);    // GreaterOrEqual
            actionTable[121, 34] = new ParserAction(ParserActions.Reduce, 0, 56);    // And
            actionTable[121, 35] = new ParserAction(ParserActions.Reduce, 0, 56);    // Or
            actionTable[121, 36] = new ParserAction(ParserActions.Reduce, 0, 56);    // Assignment
            actionTable[121, 37] = new ParserAction(ParserActions.Reduce, 0, 56);    // PlusAssignment
            actionTable[121, 38] = new ParserAction(ParserActions.Reduce, 0, 56);    // MinusAssignment
            actionTable[121, 39] = new ParserAction(ParserActions.Reduce, 0, 56);    // MultAssignment
            actionTable[121, 40] = new ParserAction(ParserActions.Reduce, 0, 56);    // DivAssignment
            actionTable[121, 41] = new ParserAction(ParserActions.Reduce, 0, 56);    // ModAssignment
            actionTable[121, 42] = new ParserAction(ParserActions.Reduce, 0, 56);    // LShift
            actionTable[121, 43] = new ParserAction(ParserActions.Reduce, 0, 56);    // RShift
            actionTable[121, 45] = new ParserAction(ParserActions.Reduce, 0, 56);    // LogicalAnd
            actionTable[121, 46] = new ParserAction(ParserActions.Reduce, 0, 56);    // LogicalOr
            actionTable[121, 47] = new ParserAction(ParserActions.Reduce, 0, 56);    // LogicalXor
            actionTable[121, 48] = new ParserAction(ParserActions.Reduce, 0, 56);    // LShiftAssignment
            actionTable[121, 49] = new ParserAction(ParserActions.Reduce, 0, 56);    // RShiftAssignment
            actionTable[121, 50] = new ParserAction(ParserActions.Reduce, 0, 56);    // AndAssignment
            actionTable[121, 51] = new ParserAction(ParserActions.Reduce, 0, 56);    // XorAssignment
            actionTable[121, 52] = new ParserAction(ParserActions.Reduce, 0, 56);    // OrAssignment
            actionTable[121, 53] = new ParserAction(ParserActions.Reduce, 0, 56);    // PlusPlus
            actionTable[121, 54] = new ParserAction(ParserActions.Reduce, 0, 56);    // MinusMinus

            // State 122
            actionTable[122, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[122, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[122, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[122, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[122, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[122, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[122, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[122, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[122, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[122, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[122, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[122, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[122, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[122, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[122, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[122, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[122, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[122, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 123
            actionTable[123, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[123, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[123, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[123, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[123, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[123, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[123, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[123, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[123, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[123, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[123, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[123, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[123, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[123, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[123, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[123, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[123, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[123, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 124
            actionTable[124, 56] = new ParserAction(ParserActions.Shift, 139, 0);    // ColonColon

            // State 125
            actionTable[125, 0] = new ParserAction(ParserActions.Reduce, 0, 66);    // EOF
            actionTable[125, 13] = new ParserAction(ParserActions.Reduce, 0, 66);    // LParan
            actionTable[125, 14] = new ParserAction(ParserActions.Reduce, 0, 66);    // RParan
            actionTable[125, 15] = new ParserAction(ParserActions.Reduce, 0, 66);    // LSqr
            actionTable[125, 16] = new ParserAction(ParserActions.Reduce, 0, 66);    // RSqr
            actionTable[125, 17] = new ParserAction(ParserActions.Reduce, 0, 66);    // LCurly
            actionTable[125, 18] = new ParserAction(ParserActions.Reduce, 0, 66);    // RCurly
            actionTable[125, 19] = new ParserAction(ParserActions.Reduce, 0, 66);    // Comma
            actionTable[125, 20] = new ParserAction(ParserActions.Reduce, 0, 66);    // Dot
            actionTable[125, 21] = new ParserAction(ParserActions.Reduce, 0, 66);    // DotDot
            actionTable[125, 22] = new ParserAction(ParserActions.Reduce, 0, 66);    // Plus
            actionTable[125, 23] = new ParserAction(ParserActions.Reduce, 0, 66);    // Minus
            actionTable[125, 24] = new ParserAction(ParserActions.Reduce, 0, 66);    // Mult
            actionTable[125, 25] = new ParserAction(ParserActions.Reduce, 0, 66);    // Div
            actionTable[125, 26] = new ParserAction(ParserActions.Reduce, 0, 66);    // Mod
            actionTable[125, 27] = new ParserAction(ParserActions.Reduce, 0, 66);    // Equal
            actionTable[125, 28] = new ParserAction(ParserActions.Reduce, 0, 66);    // NotEqual
            actionTable[125, 29] = new ParserAction(ParserActions.Reduce, 0, 66);    // Lesser
            actionTable[125, 30] = new ParserAction(ParserActions.Reduce, 0, 66);    // Greater
            actionTable[125, 31] = new ParserAction(ParserActions.Reduce, 0, 66);    // LesserOrEqual
            actionTable[125, 32] = new ParserAction(ParserActions.Reduce, 0, 66);    // GreaterOrEqual
            actionTable[125, 34] = new ParserAction(ParserActions.Reduce, 0, 66);    // And
            actionTable[125, 35] = new ParserAction(ParserActions.Reduce, 0, 66);    // Or
            actionTable[125, 36] = new ParserAction(ParserActions.Reduce, 0, 66);    // Assignment
            actionTable[125, 37] = new ParserAction(ParserActions.Reduce, 0, 66);    // PlusAssignment
            actionTable[125, 38] = new ParserAction(ParserActions.Reduce, 0, 66);    // MinusAssignment
            actionTable[125, 39] = new ParserAction(ParserActions.Reduce, 0, 66);    // MultAssignment
            actionTable[125, 40] = new ParserAction(ParserActions.Reduce, 0, 66);    // DivAssignment
            actionTable[125, 41] = new ParserAction(ParserActions.Reduce, 0, 66);    // ModAssignment
            actionTable[125, 42] = new ParserAction(ParserActions.Reduce, 0, 66);    // LShift
            actionTable[125, 43] = new ParserAction(ParserActions.Reduce, 0, 66);    // RShift
            actionTable[125, 45] = new ParserAction(ParserActions.Reduce, 0, 66);    // LogicalAnd
            actionTable[125, 46] = new ParserAction(ParserActions.Reduce, 0, 66);    // LogicalOr
            actionTable[125, 47] = new ParserAction(ParserActions.Reduce, 0, 66);    // LogicalXor
            actionTable[125, 48] = new ParserAction(ParserActions.Reduce, 0, 66);    // LShiftAssignment
            actionTable[125, 49] = new ParserAction(ParserActions.Reduce, 0, 66);    // RShiftAssignment
            actionTable[125, 50] = new ParserAction(ParserActions.Reduce, 0, 66);    // AndAssignment
            actionTable[125, 51] = new ParserAction(ParserActions.Reduce, 0, 66);    // XorAssignment
            actionTable[125, 52] = new ParserAction(ParserActions.Reduce, 0, 66);    // OrAssignment
            actionTable[125, 53] = new ParserAction(ParserActions.Reduce, 0, 66);    // PlusPlus
            actionTable[125, 54] = new ParserAction(ParserActions.Reduce, 0, 66);    // MinusMinus

            // State 126
            actionTable[126, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[126, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[126, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[126, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[126, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[126, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[126, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[126, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[126, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[126, 11] = new ParserAction(ParserActions.Shift, 141, 0);    // Ref
            actionTable[126, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[126, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[126, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[126, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[126, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[126, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[126, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[126, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[126, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 127
            actionTable[127, 14] = new ParserAction(ParserActions.Reduce, 0, 83);    // RParan
            actionTable[127, 16] = new ParserAction(ParserActions.Reduce, 0, 83);    // RSqr
            actionTable[127, 18] = new ParserAction(ParserActions.Reduce, 0, 83);    // RCurly
            actionTable[127, 19] = new ParserAction(ParserActions.Reduce, 0, 83);    // Comma

            // State 128
            actionTable[128, 0] = new ParserAction(ParserActions.Reduce, 0, 50);    // EOF
            actionTable[128, 13] = new ParserAction(ParserActions.Reduce, 0, 50);    // LParan
            actionTable[128, 14] = new ParserAction(ParserActions.Reduce, 0, 50);    // RParan
            actionTable[128, 15] = new ParserAction(ParserActions.Reduce, 0, 50);    // LSqr
            actionTable[128, 16] = new ParserAction(ParserActions.Reduce, 0, 50);    // RSqr
            actionTable[128, 17] = new ParserAction(ParserActions.Reduce, 0, 50);    // LCurly
            actionTable[128, 18] = new ParserAction(ParserActions.Reduce, 0, 50);    // RCurly
            actionTable[128, 19] = new ParserAction(ParserActions.Reduce, 0, 50);    // Comma
            actionTable[128, 20] = new ParserAction(ParserActions.Reduce, 0, 50);    // Dot
            actionTable[128, 21] = new ParserAction(ParserActions.Reduce, 0, 50);    // DotDot
            actionTable[128, 22] = new ParserAction(ParserActions.Reduce, 0, 50);    // Plus
            actionTable[128, 23] = new ParserAction(ParserActions.Reduce, 0, 50);    // Minus
            actionTable[128, 24] = new ParserAction(ParserActions.Reduce, 0, 50);    // Mult
            actionTable[128, 25] = new ParserAction(ParserActions.Reduce, 0, 50);    // Div
            actionTable[128, 26] = new ParserAction(ParserActions.Reduce, 0, 50);    // Mod
            actionTable[128, 27] = new ParserAction(ParserActions.Reduce, 0, 50);    // Equal
            actionTable[128, 28] = new ParserAction(ParserActions.Reduce, 0, 50);    // NotEqual
            actionTable[128, 29] = new ParserAction(ParserActions.Reduce, 0, 50);    // Lesser
            actionTable[128, 30] = new ParserAction(ParserActions.Reduce, 0, 50);    // Greater
            actionTable[128, 31] = new ParserAction(ParserActions.Reduce, 0, 50);    // LesserOrEqual
            actionTable[128, 32] = new ParserAction(ParserActions.Reduce, 0, 50);    // GreaterOrEqual
            actionTable[128, 34] = new ParserAction(ParserActions.Reduce, 0, 50);    // And
            actionTable[128, 35] = new ParserAction(ParserActions.Reduce, 0, 50);    // Or
            actionTable[128, 36] = new ParserAction(ParserActions.Reduce, 0, 50);    // Assignment
            actionTable[128, 37] = new ParserAction(ParserActions.Reduce, 0, 50);    // PlusAssignment
            actionTable[128, 38] = new ParserAction(ParserActions.Reduce, 0, 50);    // MinusAssignment
            actionTable[128, 39] = new ParserAction(ParserActions.Reduce, 0, 50);    // MultAssignment
            actionTable[128, 40] = new ParserAction(ParserActions.Reduce, 0, 50);    // DivAssignment
            actionTable[128, 41] = new ParserAction(ParserActions.Reduce, 0, 50);    // ModAssignment
            actionTable[128, 42] = new ParserAction(ParserActions.Reduce, 0, 50);    // LShift
            actionTable[128, 43] = new ParserAction(ParserActions.Reduce, 0, 50);    // RShift
            actionTable[128, 45] = new ParserAction(ParserActions.Reduce, 0, 50);    // LogicalAnd
            actionTable[128, 46] = new ParserAction(ParserActions.Reduce, 0, 50);    // LogicalOr
            actionTable[128, 47] = new ParserAction(ParserActions.Reduce, 0, 50);    // LogicalXor
            actionTable[128, 48] = new ParserAction(ParserActions.Reduce, 0, 50);    // LShiftAssignment
            actionTable[128, 49] = new ParserAction(ParserActions.Reduce, 0, 50);    // RShiftAssignment
            actionTable[128, 50] = new ParserAction(ParserActions.Reduce, 0, 50);    // AndAssignment
            actionTable[128, 51] = new ParserAction(ParserActions.Reduce, 0, 50);    // XorAssignment
            actionTable[128, 52] = new ParserAction(ParserActions.Reduce, 0, 50);    // OrAssignment
            actionTable[128, 53] = new ParserAction(ParserActions.Reduce, 0, 50);    // PlusPlus
            actionTable[128, 54] = new ParserAction(ParserActions.Reduce, 0, 50);    // MinusMinus

            // State 129
            actionTable[129, 0] = new ParserAction(ParserActions.Reduce, 0, 52);    // EOF
            actionTable[129, 13] = new ParserAction(ParserActions.Reduce, 0, 52);    // LParan
            actionTable[129, 14] = new ParserAction(ParserActions.Reduce, 0, 52);    // RParan
            actionTable[129, 15] = new ParserAction(ParserActions.Reduce, 0, 52);    // LSqr
            actionTable[129, 16] = new ParserAction(ParserActions.Reduce, 0, 52);    // RSqr
            actionTable[129, 17] = new ParserAction(ParserActions.Reduce, 0, 52);    // LCurly
            actionTable[129, 18] = new ParserAction(ParserActions.Reduce, 0, 52);    // RCurly
            actionTable[129, 19] = new ParserAction(ParserActions.Reduce, 0, 52);    // Comma
            actionTable[129, 20] = new ParserAction(ParserActions.Reduce, 0, 52);    // Dot
            actionTable[129, 21] = new ParserAction(ParserActions.Reduce, 0, 52);    // DotDot
            actionTable[129, 22] = new ParserAction(ParserActions.Reduce, 0, 52);    // Plus
            actionTable[129, 23] = new ParserAction(ParserActions.Reduce, 0, 52);    // Minus
            actionTable[129, 24] = new ParserAction(ParserActions.Reduce, 0, 52);    // Mult
            actionTable[129, 25] = new ParserAction(ParserActions.Reduce, 0, 52);    // Div
            actionTable[129, 26] = new ParserAction(ParserActions.Reduce, 0, 52);    // Mod
            actionTable[129, 27] = new ParserAction(ParserActions.Reduce, 0, 52);    // Equal
            actionTable[129, 28] = new ParserAction(ParserActions.Reduce, 0, 52);    // NotEqual
            actionTable[129, 29] = new ParserAction(ParserActions.Reduce, 0, 52);    // Lesser
            actionTable[129, 30] = new ParserAction(ParserActions.Reduce, 0, 52);    // Greater
            actionTable[129, 31] = new ParserAction(ParserActions.Reduce, 0, 52);    // LesserOrEqual
            actionTable[129, 32] = new ParserAction(ParserActions.Reduce, 0, 52);    // GreaterOrEqual
            actionTable[129, 34] = new ParserAction(ParserActions.Reduce, 0, 52);    // And
            actionTable[129, 35] = new ParserAction(ParserActions.Reduce, 0, 52);    // Or
            actionTable[129, 36] = new ParserAction(ParserActions.Reduce, 0, 52);    // Assignment
            actionTable[129, 37] = new ParserAction(ParserActions.Reduce, 0, 52);    // PlusAssignment
            actionTable[129, 38] = new ParserAction(ParserActions.Reduce, 0, 52);    // MinusAssignment
            actionTable[129, 39] = new ParserAction(ParserActions.Reduce, 0, 52);    // MultAssignment
            actionTable[129, 40] = new ParserAction(ParserActions.Reduce, 0, 52);    // DivAssignment
            actionTable[129, 41] = new ParserAction(ParserActions.Reduce, 0, 52);    // ModAssignment
            actionTable[129, 42] = new ParserAction(ParserActions.Reduce, 0, 52);    // LShift
            actionTable[129, 43] = new ParserAction(ParserActions.Reduce, 0, 52);    // RShift
            actionTable[129, 45] = new ParserAction(ParserActions.Reduce, 0, 52);    // LogicalAnd
            actionTable[129, 46] = new ParserAction(ParserActions.Reduce, 0, 52);    // LogicalOr
            actionTable[129, 47] = new ParserAction(ParserActions.Reduce, 0, 52);    // LogicalXor
            actionTable[129, 48] = new ParserAction(ParserActions.Reduce, 0, 52);    // LShiftAssignment
            actionTable[129, 49] = new ParserAction(ParserActions.Reduce, 0, 52);    // RShiftAssignment
            actionTable[129, 50] = new ParserAction(ParserActions.Reduce, 0, 52);    // AndAssignment
            actionTable[129, 51] = new ParserAction(ParserActions.Reduce, 0, 52);    // XorAssignment
            actionTable[129, 52] = new ParserAction(ParserActions.Reduce, 0, 52);    // OrAssignment
            actionTable[129, 53] = new ParserAction(ParserActions.Reduce, 0, 52);    // PlusPlus
            actionTable[129, 54] = new ParserAction(ParserActions.Reduce, 0, 52);    // MinusMinus

            // State 130
            actionTable[130, 13] = new ParserAction(ParserActions.Shift, 142, 0);    // LParan

            // State 131
            actionTable[131, 12] = new ParserAction(ParserActions.Shift, 143, 0);    // Identifier

            // State 132
            actionTable[132, 12] = new ParserAction(ParserActions.Shift, 116, 0);    // Identifier

            // State 133
            actionTable[133, 18] = new ParserAction(ParserActions.Reduce, 0, 75);    // RCurly
            actionTable[133, 19] = new ParserAction(ParserActions.Reduce, 0, 75);    // Comma

            // State 134
            actionTable[134, 14] = new ParserAction(ParserActions.Shift, 145, 0);    // RParan

            // State 135
            actionTable[135, 16] = new ParserAction(ParserActions.Shift, 146, 0);    // RSqr

            // State 136
            actionTable[136, 18] = new ParserAction(ParserActions.Shift, 147, 0);    // RCurly
            actionTable[136, 19] = new ParserAction(ParserActions.Shift, 131, 0);    // Comma

            // State 137
            actionTable[137, 0] = new ParserAction(ParserActions.Reduce, 0, 41);    // EOF
            actionTable[137, 14] = new ParserAction(ParserActions.Reduce, 0, 41);    // RParan
            actionTable[137, 16] = new ParserAction(ParserActions.Reduce, 0, 41);    // RSqr
            actionTable[137, 18] = new ParserAction(ParserActions.Reduce, 0, 41);    // RCurly
            actionTable[137, 19] = new ParserAction(ParserActions.Reduce, 0, 41);    // Comma
            actionTable[137, 21] = new ParserAction(ParserActions.Reduce, 0, 41);    // DotDot
            actionTable[137, 22] = new ParserAction(ParserActions.Reduce, 0, 41);    // Plus
            actionTable[137, 23] = new ParserAction(ParserActions.Reduce, 0, 41);    // Minus
            actionTable[137, 24] = new ParserAction(ParserActions.Reduce, 0, 41);    // Mult
            actionTable[137, 25] = new ParserAction(ParserActions.Reduce, 0, 41);    // Div
            actionTable[137, 26] = new ParserAction(ParserActions.Reduce, 0, 41);    // Mod
            actionTable[137, 27] = new ParserAction(ParserActions.Reduce, 0, 41);    // Equal
            actionTable[137, 28] = new ParserAction(ParserActions.Reduce, 0, 41);    // NotEqual
            actionTable[137, 29] = new ParserAction(ParserActions.Reduce, 0, 41);    // Lesser
            actionTable[137, 30] = new ParserAction(ParserActions.Reduce, 0, 41);    // Greater
            actionTable[137, 31] = new ParserAction(ParserActions.Reduce, 0, 41);    // LesserOrEqual
            actionTable[137, 32] = new ParserAction(ParserActions.Reduce, 0, 41);    // GreaterOrEqual
            actionTable[137, 34] = new ParserAction(ParserActions.Reduce, 0, 41);    // And
            actionTable[137, 35] = new ParserAction(ParserActions.Reduce, 0, 41);    // Or
            actionTable[137, 36] = new ParserAction(ParserActions.Reduce, 0, 41);    // Assignment
            actionTable[137, 37] = new ParserAction(ParserActions.Reduce, 0, 41);    // PlusAssignment
            actionTable[137, 38] = new ParserAction(ParserActions.Reduce, 0, 41);    // MinusAssignment
            actionTable[137, 39] = new ParserAction(ParserActions.Reduce, 0, 41);    // MultAssignment
            actionTable[137, 40] = new ParserAction(ParserActions.Reduce, 0, 41);    // DivAssignment
            actionTable[137, 41] = new ParserAction(ParserActions.Reduce, 0, 41);    // ModAssignment
            actionTable[137, 42] = new ParserAction(ParserActions.Reduce, 0, 41);    // LShift
            actionTable[137, 43] = new ParserAction(ParserActions.Reduce, 0, 41);    // RShift
            actionTable[137, 45] = new ParserAction(ParserActions.Reduce, 0, 41);    // LogicalAnd
            actionTable[137, 46] = new ParserAction(ParserActions.Reduce, 0, 41);    // LogicalOr
            actionTable[137, 47] = new ParserAction(ParserActions.Reduce, 0, 41);    // LogicalXor
            actionTable[137, 48] = new ParserAction(ParserActions.Reduce, 0, 41);    // LShiftAssignment
            actionTable[137, 49] = new ParserAction(ParserActions.Reduce, 0, 41);    // RShiftAssignment
            actionTable[137, 50] = new ParserAction(ParserActions.Reduce, 0, 41);    // AndAssignment
            actionTable[137, 51] = new ParserAction(ParserActions.Reduce, 0, 41);    // XorAssignment
            actionTable[137, 52] = new ParserAction(ParserActions.Reduce, 0, 41);    // OrAssignment

            // State 138
            actionTable[138, 16] = new ParserAction(ParserActions.Shift, 148, 0);    // RSqr

            // State 139
            actionTable[139, 12] = new ParserAction(ParserActions.Shift, 149, 0);    // Identifier

            // State 140
            actionTable[140, 14] = new ParserAction(ParserActions.Reduce, 0, 82);    // RParan
            actionTable[140, 16] = new ParserAction(ParserActions.Reduce, 0, 82);    // RSqr
            actionTable[140, 18] = new ParserAction(ParserActions.Reduce, 0, 82);    // RCurly
            actionTable[140, 19] = new ParserAction(ParserActions.Reduce, 0, 82);    // Comma

            // State 141
            actionTable[141, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[141, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[141, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[141, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[141, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[141, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[141, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[141, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[141, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[141, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[141, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[141, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[141, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[141, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[141, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[141, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[141, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[141, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 142
            actionTable[142, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[142, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[142, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[142, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[142, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[142, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[142, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[142, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[142, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[142, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[142, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[142, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[142, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[142, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[142, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[142, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[142, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[142, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[142, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[142, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[142, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[142, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 143
            actionTable[143, 17] = new ParserAction(ParserActions.Shift, 152, 0);    // LCurly
            actionTable[143, 18] = new ParserAction(ParserActions.Reduce, 0, 77);    // RCurly
            actionTable[143, 19] = new ParserAction(ParserActions.Reduce, 0, 77);    // Comma
            actionTable[143, 55] = new ParserAction(ParserActions.Shift, 153, 0);    // ArrayDimensions

            // State 144
            actionTable[144, 18] = new ParserAction(ParserActions.Shift, 154, 0);    // RCurly
            actionTable[144, 19] = new ParserAction(ParserActions.Shift, 131, 0);    // Comma

            // State 145
            actionTable[145, 0] = new ParserAction(ParserActions.Reduce, 0, 67);    // EOF
            actionTable[145, 13] = new ParserAction(ParserActions.Reduce, 0, 67);    // LParan
            actionTable[145, 14] = new ParserAction(ParserActions.Reduce, 0, 67);    // RParan
            actionTable[145, 15] = new ParserAction(ParserActions.Reduce, 0, 67);    // LSqr
            actionTable[145, 16] = new ParserAction(ParserActions.Reduce, 0, 67);    // RSqr
            actionTable[145, 17] = new ParserAction(ParserActions.Reduce, 0, 67);    // LCurly
            actionTable[145, 18] = new ParserAction(ParserActions.Reduce, 0, 67);    // RCurly
            actionTable[145, 19] = new ParserAction(ParserActions.Reduce, 0, 67);    // Comma
            actionTable[145, 20] = new ParserAction(ParserActions.Reduce, 0, 67);    // Dot
            actionTable[145, 21] = new ParserAction(ParserActions.Reduce, 0, 67);    // DotDot
            actionTable[145, 22] = new ParserAction(ParserActions.Reduce, 0, 67);    // Plus
            actionTable[145, 23] = new ParserAction(ParserActions.Reduce, 0, 67);    // Minus
            actionTable[145, 24] = new ParserAction(ParserActions.Reduce, 0, 67);    // Mult
            actionTable[145, 25] = new ParserAction(ParserActions.Reduce, 0, 67);    // Div
            actionTable[145, 26] = new ParserAction(ParserActions.Reduce, 0, 67);    // Mod
            actionTable[145, 27] = new ParserAction(ParserActions.Reduce, 0, 67);    // Equal
            actionTable[145, 28] = new ParserAction(ParserActions.Reduce, 0, 67);    // NotEqual
            actionTable[145, 29] = new ParserAction(ParserActions.Reduce, 0, 67);    // Lesser
            actionTable[145, 30] = new ParserAction(ParserActions.Reduce, 0, 67);    // Greater
            actionTable[145, 31] = new ParserAction(ParserActions.Reduce, 0, 67);    // LesserOrEqual
            actionTable[145, 32] = new ParserAction(ParserActions.Reduce, 0, 67);    // GreaterOrEqual
            actionTable[145, 34] = new ParserAction(ParserActions.Reduce, 0, 67);    // And
            actionTable[145, 35] = new ParserAction(ParserActions.Reduce, 0, 67);    // Or
            actionTable[145, 36] = new ParserAction(ParserActions.Reduce, 0, 67);    // Assignment
            actionTable[145, 37] = new ParserAction(ParserActions.Reduce, 0, 67);    // PlusAssignment
            actionTable[145, 38] = new ParserAction(ParserActions.Reduce, 0, 67);    // MinusAssignment
            actionTable[145, 39] = new ParserAction(ParserActions.Reduce, 0, 67);    // MultAssignment
            actionTable[145, 40] = new ParserAction(ParserActions.Reduce, 0, 67);    // DivAssignment
            actionTable[145, 41] = new ParserAction(ParserActions.Reduce, 0, 67);    // ModAssignment
            actionTable[145, 42] = new ParserAction(ParserActions.Reduce, 0, 67);    // LShift
            actionTable[145, 43] = new ParserAction(ParserActions.Reduce, 0, 67);    // RShift
            actionTable[145, 45] = new ParserAction(ParserActions.Reduce, 0, 67);    // LogicalAnd
            actionTable[145, 46] = new ParserAction(ParserActions.Reduce, 0, 67);    // LogicalOr
            actionTable[145, 47] = new ParserAction(ParserActions.Reduce, 0, 67);    // LogicalXor
            actionTable[145, 48] = new ParserAction(ParserActions.Reduce, 0, 67);    // LShiftAssignment
            actionTable[145, 49] = new ParserAction(ParserActions.Reduce, 0, 67);    // RShiftAssignment
            actionTable[145, 50] = new ParserAction(ParserActions.Reduce, 0, 67);    // AndAssignment
            actionTable[145, 51] = new ParserAction(ParserActions.Reduce, 0, 67);    // XorAssignment
            actionTable[145, 52] = new ParserAction(ParserActions.Reduce, 0, 67);    // OrAssignment
            actionTable[145, 53] = new ParserAction(ParserActions.Reduce, 0, 67);    // PlusPlus
            actionTable[145, 54] = new ParserAction(ParserActions.Reduce, 0, 67);    // MinusMinus

            // State 146
            actionTable[146, 0] = new ParserAction(ParserActions.Reduce, 0, 69);    // EOF
            actionTable[146, 13] = new ParserAction(ParserActions.Reduce, 0, 69);    // LParan
            actionTable[146, 14] = new ParserAction(ParserActions.Reduce, 0, 69);    // RParan
            actionTable[146, 15] = new ParserAction(ParserActions.Reduce, 0, 69);    // LSqr
            actionTable[146, 16] = new ParserAction(ParserActions.Reduce, 0, 69);    // RSqr
            actionTable[146, 17] = new ParserAction(ParserActions.Reduce, 0, 69);    // LCurly
            actionTable[146, 18] = new ParserAction(ParserActions.Reduce, 0, 69);    // RCurly
            actionTable[146, 19] = new ParserAction(ParserActions.Reduce, 0, 69);    // Comma
            actionTable[146, 20] = new ParserAction(ParserActions.Reduce, 0, 69);    // Dot
            actionTable[146, 21] = new ParserAction(ParserActions.Reduce, 0, 69);    // DotDot
            actionTable[146, 22] = new ParserAction(ParserActions.Reduce, 0, 69);    // Plus
            actionTable[146, 23] = new ParserAction(ParserActions.Reduce, 0, 69);    // Minus
            actionTable[146, 24] = new ParserAction(ParserActions.Reduce, 0, 69);    // Mult
            actionTable[146, 25] = new ParserAction(ParserActions.Reduce, 0, 69);    // Div
            actionTable[146, 26] = new ParserAction(ParserActions.Reduce, 0, 69);    // Mod
            actionTable[146, 27] = new ParserAction(ParserActions.Reduce, 0, 69);    // Equal
            actionTable[146, 28] = new ParserAction(ParserActions.Reduce, 0, 69);    // NotEqual
            actionTable[146, 29] = new ParserAction(ParserActions.Reduce, 0, 69);    // Lesser
            actionTable[146, 30] = new ParserAction(ParserActions.Reduce, 0, 69);    // Greater
            actionTable[146, 31] = new ParserAction(ParserActions.Reduce, 0, 69);    // LesserOrEqual
            actionTable[146, 32] = new ParserAction(ParserActions.Reduce, 0, 69);    // GreaterOrEqual
            actionTable[146, 34] = new ParserAction(ParserActions.Reduce, 0, 69);    // And
            actionTable[146, 35] = new ParserAction(ParserActions.Reduce, 0, 69);    // Or
            actionTable[146, 36] = new ParserAction(ParserActions.Reduce, 0, 69);    // Assignment
            actionTable[146, 37] = new ParserAction(ParserActions.Reduce, 0, 69);    // PlusAssignment
            actionTable[146, 38] = new ParserAction(ParserActions.Reduce, 0, 69);    // MinusAssignment
            actionTable[146, 39] = new ParserAction(ParserActions.Reduce, 0, 69);    // MultAssignment
            actionTable[146, 40] = new ParserAction(ParserActions.Reduce, 0, 69);    // DivAssignment
            actionTable[146, 41] = new ParserAction(ParserActions.Reduce, 0, 69);    // ModAssignment
            actionTable[146, 42] = new ParserAction(ParserActions.Reduce, 0, 69);    // LShift
            actionTable[146, 43] = new ParserAction(ParserActions.Reduce, 0, 69);    // RShift
            actionTable[146, 45] = new ParserAction(ParserActions.Reduce, 0, 69);    // LogicalAnd
            actionTable[146, 46] = new ParserAction(ParserActions.Reduce, 0, 69);    // LogicalOr
            actionTable[146, 47] = new ParserAction(ParserActions.Reduce, 0, 69);    // LogicalXor
            actionTable[146, 48] = new ParserAction(ParserActions.Reduce, 0, 69);    // LShiftAssignment
            actionTable[146, 49] = new ParserAction(ParserActions.Reduce, 0, 69);    // RShiftAssignment
            actionTable[146, 50] = new ParserAction(ParserActions.Reduce, 0, 69);    // AndAssignment
            actionTable[146, 51] = new ParserAction(ParserActions.Reduce, 0, 69);    // XorAssignment
            actionTable[146, 52] = new ParserAction(ParserActions.Reduce, 0, 69);    // OrAssignment
            actionTable[146, 53] = new ParserAction(ParserActions.Reduce, 0, 69);    // PlusPlus
            actionTable[146, 54] = new ParserAction(ParserActions.Reduce, 0, 69);    // MinusMinus

            // State 147
            actionTable[147, 13] = new ParserAction(ParserActions.Shift, 155, 0);    // LParan
            actionTable[147, 15] = new ParserAction(ParserActions.Shift, 156, 0);    // LSqr

            // State 148
            actionTable[148, 0] = new ParserAction(ParserActions.Reduce, 0, 65);    // EOF
            actionTable[148, 13] = new ParserAction(ParserActions.Reduce, 0, 65);    // LParan
            actionTable[148, 14] = new ParserAction(ParserActions.Reduce, 0, 65);    // RParan
            actionTable[148, 15] = new ParserAction(ParserActions.Reduce, 0, 65);    // LSqr
            actionTable[148, 16] = new ParserAction(ParserActions.Reduce, 0, 65);    // RSqr
            actionTable[148, 17] = new ParserAction(ParserActions.Reduce, 0, 65);    // LCurly
            actionTable[148, 18] = new ParserAction(ParserActions.Reduce, 0, 65);    // RCurly
            actionTable[148, 19] = new ParserAction(ParserActions.Reduce, 0, 65);    // Comma
            actionTable[148, 20] = new ParserAction(ParserActions.Reduce, 0, 65);    // Dot
            actionTable[148, 21] = new ParserAction(ParserActions.Reduce, 0, 65);    // DotDot
            actionTable[148, 22] = new ParserAction(ParserActions.Reduce, 0, 65);    // Plus
            actionTable[148, 23] = new ParserAction(ParserActions.Reduce, 0, 65);    // Minus
            actionTable[148, 24] = new ParserAction(ParserActions.Reduce, 0, 65);    // Mult
            actionTable[148, 25] = new ParserAction(ParserActions.Reduce, 0, 65);    // Div
            actionTable[148, 26] = new ParserAction(ParserActions.Reduce, 0, 65);    // Mod
            actionTable[148, 27] = new ParserAction(ParserActions.Reduce, 0, 65);    // Equal
            actionTable[148, 28] = new ParserAction(ParserActions.Reduce, 0, 65);    // NotEqual
            actionTable[148, 29] = new ParserAction(ParserActions.Reduce, 0, 65);    // Lesser
            actionTable[148, 30] = new ParserAction(ParserActions.Reduce, 0, 65);    // Greater
            actionTable[148, 31] = new ParserAction(ParserActions.Reduce, 0, 65);    // LesserOrEqual
            actionTable[148, 32] = new ParserAction(ParserActions.Reduce, 0, 65);    // GreaterOrEqual
            actionTable[148, 34] = new ParserAction(ParserActions.Reduce, 0, 65);    // And
            actionTable[148, 35] = new ParserAction(ParserActions.Reduce, 0, 65);    // Or
            actionTable[148, 36] = new ParserAction(ParserActions.Reduce, 0, 65);    // Assignment
            actionTable[148, 37] = new ParserAction(ParserActions.Reduce, 0, 65);    // PlusAssignment
            actionTable[148, 38] = new ParserAction(ParserActions.Reduce, 0, 65);    // MinusAssignment
            actionTable[148, 39] = new ParserAction(ParserActions.Reduce, 0, 65);    // MultAssignment
            actionTable[148, 40] = new ParserAction(ParserActions.Reduce, 0, 65);    // DivAssignment
            actionTable[148, 41] = new ParserAction(ParserActions.Reduce, 0, 65);    // ModAssignment
            actionTable[148, 42] = new ParserAction(ParserActions.Reduce, 0, 65);    // LShift
            actionTable[148, 43] = new ParserAction(ParserActions.Reduce, 0, 65);    // RShift
            actionTable[148, 45] = new ParserAction(ParserActions.Reduce, 0, 65);    // LogicalAnd
            actionTable[148, 46] = new ParserAction(ParserActions.Reduce, 0, 65);    // LogicalOr
            actionTable[148, 47] = new ParserAction(ParserActions.Reduce, 0, 65);    // LogicalXor
            actionTable[148, 48] = new ParserAction(ParserActions.Reduce, 0, 65);    // LShiftAssignment
            actionTable[148, 49] = new ParserAction(ParserActions.Reduce, 0, 65);    // RShiftAssignment
            actionTable[148, 50] = new ParserAction(ParserActions.Reduce, 0, 65);    // AndAssignment
            actionTable[148, 51] = new ParserAction(ParserActions.Reduce, 0, 65);    // XorAssignment
            actionTable[148, 52] = new ParserAction(ParserActions.Reduce, 0, 65);    // OrAssignment
            actionTable[148, 53] = new ParserAction(ParserActions.Reduce, 0, 65);    // PlusPlus
            actionTable[148, 54] = new ParserAction(ParserActions.Reduce, 0, 65);    // MinusMinus

            // State 149
            actionTable[149, 0] = new ParserAction(ParserActions.Reduce, 0, 53);    // EOF
            actionTable[149, 13] = new ParserAction(ParserActions.Reduce, 0, 53);    // LParan
            actionTable[149, 14] = new ParserAction(ParserActions.Reduce, 0, 53);    // RParan
            actionTable[149, 15] = new ParserAction(ParserActions.Reduce, 0, 53);    // LSqr
            actionTable[149, 16] = new ParserAction(ParserActions.Reduce, 0, 53);    // RSqr
            actionTable[149, 17] = new ParserAction(ParserActions.Reduce, 0, 53);    // LCurly
            actionTable[149, 18] = new ParserAction(ParserActions.Reduce, 0, 53);    // RCurly
            actionTable[149, 19] = new ParserAction(ParserActions.Reduce, 0, 53);    // Comma
            actionTable[149, 20] = new ParserAction(ParserActions.Reduce, 0, 53);    // Dot
            actionTable[149, 21] = new ParserAction(ParserActions.Reduce, 0, 53);    // DotDot
            actionTable[149, 22] = new ParserAction(ParserActions.Reduce, 0, 53);    // Plus
            actionTable[149, 23] = new ParserAction(ParserActions.Reduce, 0, 53);    // Minus
            actionTable[149, 24] = new ParserAction(ParserActions.Reduce, 0, 53);    // Mult
            actionTable[149, 25] = new ParserAction(ParserActions.Reduce, 0, 53);    // Div
            actionTable[149, 26] = new ParserAction(ParserActions.Reduce, 0, 53);    // Mod
            actionTable[149, 27] = new ParserAction(ParserActions.Reduce, 0, 53);    // Equal
            actionTable[149, 28] = new ParserAction(ParserActions.Reduce, 0, 53);    // NotEqual
            actionTable[149, 29] = new ParserAction(ParserActions.Reduce, 0, 53);    // Lesser
            actionTable[149, 30] = new ParserAction(ParserActions.Reduce, 0, 53);    // Greater
            actionTable[149, 31] = new ParserAction(ParserActions.Reduce, 0, 53);    // LesserOrEqual
            actionTable[149, 32] = new ParserAction(ParserActions.Reduce, 0, 53);    // GreaterOrEqual
            actionTable[149, 34] = new ParserAction(ParserActions.Reduce, 0, 53);    // And
            actionTable[149, 35] = new ParserAction(ParserActions.Reduce, 0, 53);    // Or
            actionTable[149, 36] = new ParserAction(ParserActions.Reduce, 0, 53);    // Assignment
            actionTable[149, 37] = new ParserAction(ParserActions.Reduce, 0, 53);    // PlusAssignment
            actionTable[149, 38] = new ParserAction(ParserActions.Reduce, 0, 53);    // MinusAssignment
            actionTable[149, 39] = new ParserAction(ParserActions.Reduce, 0, 53);    // MultAssignment
            actionTable[149, 40] = new ParserAction(ParserActions.Reduce, 0, 53);    // DivAssignment
            actionTable[149, 41] = new ParserAction(ParserActions.Reduce, 0, 53);    // ModAssignment
            actionTable[149, 42] = new ParserAction(ParserActions.Reduce, 0, 53);    // LShift
            actionTable[149, 43] = new ParserAction(ParserActions.Reduce, 0, 53);    // RShift
            actionTable[149, 45] = new ParserAction(ParserActions.Reduce, 0, 53);    // LogicalAnd
            actionTable[149, 46] = new ParserAction(ParserActions.Reduce, 0, 53);    // LogicalOr
            actionTable[149, 47] = new ParserAction(ParserActions.Reduce, 0, 53);    // LogicalXor
            actionTable[149, 48] = new ParserAction(ParserActions.Reduce, 0, 53);    // LShiftAssignment
            actionTable[149, 49] = new ParserAction(ParserActions.Reduce, 0, 53);    // RShiftAssignment
            actionTable[149, 50] = new ParserAction(ParserActions.Reduce, 0, 53);    // AndAssignment
            actionTable[149, 51] = new ParserAction(ParserActions.Reduce, 0, 53);    // XorAssignment
            actionTable[149, 52] = new ParserAction(ParserActions.Reduce, 0, 53);    // OrAssignment
            actionTable[149, 53] = new ParserAction(ParserActions.Reduce, 0, 53);    // PlusPlus
            actionTable[149, 54] = new ParserAction(ParserActions.Reduce, 0, 53);    // MinusMinus

            // State 150
            actionTable[150, 14] = new ParserAction(ParserActions.Reduce, 0, 84);    // RParan
            actionTable[150, 16] = new ParserAction(ParserActions.Reduce, 0, 84);    // RSqr
            actionTable[150, 18] = new ParserAction(ParserActions.Reduce, 0, 84);    // RCurly
            actionTable[150, 19] = new ParserAction(ParserActions.Reduce, 0, 84);    // Comma

            // State 151
            actionTable[151, 14] = new ParserAction(ParserActions.Shift, 157, 0);    // RParan

            // State 152
            actionTable[152, 12] = new ParserAction(ParserActions.Shift, 116, 0);    // Identifier

            // State 153
            actionTable[153, 18] = new ParserAction(ParserActions.Reduce, 0, 79);    // RCurly
            actionTable[153, 19] = new ParserAction(ParserActions.Reduce, 0, 79);    // Comma

            // State 154
            actionTable[154, 18] = new ParserAction(ParserActions.Reduce, 0, 74);    // RCurly
            actionTable[154, 19] = new ParserAction(ParserActions.Reduce, 0, 74);    // Comma
            actionTable[154, 55] = new ParserAction(ParserActions.Shift, 159, 0);    // ArrayDimensions

            // State 155
            actionTable[155, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[155, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[155, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[155, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[155, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[155, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[155, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[155, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[155, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[155, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[155, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[155, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[155, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[155, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[155, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[155, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[155, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[155, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[155, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[155, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[155, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[155, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 156
            actionTable[156, 2] = new ParserAction(ParserActions.Shift, 15, 0);    // Dollar
            actionTable[156, 3] = new ParserAction(ParserActions.Shift, 16, 0);    // Null
            actionTable[156, 4] = new ParserAction(ParserActions.Shift, 17, 0);    // Character
            actionTable[156, 5] = new ParserAction(ParserActions.Shift, 18, 0);    // String
            actionTable[156, 6] = new ParserAction(ParserActions.Shift, 19, 0);    // Boolean
            actionTable[156, 7] = new ParserAction(ParserActions.Shift, 20, 0);    // Integer
            actionTable[156, 8] = new ParserAction(ParserActions.Shift, 21, 0);    // Hexadecimal
            actionTable[156, 9] = new ParserAction(ParserActions.Shift, 22, 0);    // Float
            actionTable[156, 10] = new ParserAction(ParserActions.Shift, 23, 0);    // New
            actionTable[156, 11] = new ParserAction(ParserActions.Shift, 77, 0);    // Ref
            actionTable[156, 13] = new ParserAction(ParserActions.Shift, 24, 0);    // LParan
            actionTable[156, 14] = new ParserAction(ParserActions.Reduce, 0, 71);    // RParan
            actionTable[156, 15] = new ParserAction(ParserActions.Shift, 25, 0);    // LSqr
            actionTable[156, 16] = new ParserAction(ParserActions.Reduce, 0, 71);    // RSqr
            actionTable[156, 17] = new ParserAction(ParserActions.Shift, 26, 0);    // LCurly
            actionTable[156, 18] = new ParserAction(ParserActions.Reduce, 0, 71);    // RCurly
            actionTable[156, 22] = new ParserAction(ParserActions.Shift, 27, 0);    // Plus
            actionTable[156, 23] = new ParserAction(ParserActions.Shift, 28, 0);    // Minus
            actionTable[156, 33] = new ParserAction(ParserActions.Shift, 29, 0);    // Not
            actionTable[156, 44] = new ParserAction(ParserActions.Shift, 30, 0);    // LogicalNot
            actionTable[156, 53] = new ParserAction(ParserActions.Shift, 31, 0);    // PlusPlus
            actionTable[156, 54] = new ParserAction(ParserActions.Shift, 32, 0);    // MinusMinus

            // State 157
            actionTable[157, 0] = new ParserAction(ParserActions.Reduce, 0, 51);    // EOF
            actionTable[157, 13] = new ParserAction(ParserActions.Reduce, 0, 51);    // LParan
            actionTable[157, 14] = new ParserAction(ParserActions.Reduce, 0, 51);    // RParan
            actionTable[157, 15] = new ParserAction(ParserActions.Reduce, 0, 51);    // LSqr
            actionTable[157, 16] = new ParserAction(ParserActions.Reduce, 0, 51);    // RSqr
            actionTable[157, 17] = new ParserAction(ParserActions.Reduce, 0, 51);    // LCurly
            actionTable[157, 18] = new ParserAction(ParserActions.Reduce, 0, 51);    // RCurly
            actionTable[157, 19] = new ParserAction(ParserActions.Reduce, 0, 51);    // Comma
            actionTable[157, 20] = new ParserAction(ParserActions.Reduce, 0, 51);    // Dot
            actionTable[157, 21] = new ParserAction(ParserActions.Reduce, 0, 51);    // DotDot
            actionTable[157, 22] = new ParserAction(ParserActions.Reduce, 0, 51);    // Plus
            actionTable[157, 23] = new ParserAction(ParserActions.Reduce, 0, 51);    // Minus
            actionTable[157, 24] = new ParserAction(ParserActions.Reduce, 0, 51);    // Mult
            actionTable[157, 25] = new ParserAction(ParserActions.Reduce, 0, 51);    // Div
            actionTable[157, 26] = new ParserAction(ParserActions.Reduce, 0, 51);    // Mod
            actionTable[157, 27] = new ParserAction(ParserActions.Reduce, 0, 51);    // Equal
            actionTable[157, 28] = new ParserAction(ParserActions.Reduce, 0, 51);    // NotEqual
            actionTable[157, 29] = new ParserAction(ParserActions.Reduce, 0, 51);    // Lesser
            actionTable[157, 30] = new ParserAction(ParserActions.Reduce, 0, 51);    // Greater
            actionTable[157, 31] = new ParserAction(ParserActions.Reduce, 0, 51);    // LesserOrEqual
            actionTable[157, 32] = new ParserAction(ParserActions.Reduce, 0, 51);    // GreaterOrEqual
            actionTable[157, 34] = new ParserAction(ParserActions.Reduce, 0, 51);    // And
            actionTable[157, 35] = new ParserAction(ParserActions.Reduce, 0, 51);    // Or
            actionTable[157, 36] = new ParserAction(ParserActions.Reduce, 0, 51);    // Assignment
            actionTable[157, 37] = new ParserAction(ParserActions.Reduce, 0, 51);    // PlusAssignment
            actionTable[157, 38] = new ParserAction(ParserActions.Reduce, 0, 51);    // MinusAssignment
            actionTable[157, 39] = new ParserAction(ParserActions.Reduce, 0, 51);    // MultAssignment
            actionTable[157, 40] = new ParserAction(ParserActions.Reduce, 0, 51);    // DivAssignment
            actionTable[157, 41] = new ParserAction(ParserActions.Reduce, 0, 51);    // ModAssignment
            actionTable[157, 42] = new ParserAction(ParserActions.Reduce, 0, 51);    // LShift
            actionTable[157, 43] = new ParserAction(ParserActions.Reduce, 0, 51);    // RShift
            actionTable[157, 45] = new ParserAction(ParserActions.Reduce, 0, 51);    // LogicalAnd
            actionTable[157, 46] = new ParserAction(ParserActions.Reduce, 0, 51);    // LogicalOr
            actionTable[157, 47] = new ParserAction(ParserActions.Reduce, 0, 51);    // LogicalXor
            actionTable[157, 48] = new ParserAction(ParserActions.Reduce, 0, 51);    // LShiftAssignment
            actionTable[157, 49] = new ParserAction(ParserActions.Reduce, 0, 51);    // RShiftAssignment
            actionTable[157, 50] = new ParserAction(ParserActions.Reduce, 0, 51);    // AndAssignment
            actionTable[157, 51] = new ParserAction(ParserActions.Reduce, 0, 51);    // XorAssignment
            actionTable[157, 52] = new ParserAction(ParserActions.Reduce, 0, 51);    // OrAssignment
            actionTable[157, 53] = new ParserAction(ParserActions.Reduce, 0, 51);    // PlusPlus
            actionTable[157, 54] = new ParserAction(ParserActions.Reduce, 0, 51);    // MinusMinus

            // State 158
            actionTable[158, 18] = new ParserAction(ParserActions.Shift, 162, 0);    // RCurly
            actionTable[158, 19] = new ParserAction(ParserActions.Shift, 131, 0);    // Comma

            // State 159
            actionTable[159, 18] = new ParserAction(ParserActions.Reduce, 0, 76);    // RCurly
            actionTable[159, 19] = new ParserAction(ParserActions.Reduce, 0, 76);    // Comma

            // State 160
            actionTable[160, 14] = new ParserAction(ParserActions.Shift, 163, 0);    // RParan

            // State 161
            actionTable[161, 16] = new ParserAction(ParserActions.Shift, 164, 0);    // RSqr

            // State 162
            actionTable[162, 18] = new ParserAction(ParserActions.Reduce, 0, 78);    // RCurly
            actionTable[162, 19] = new ParserAction(ParserActions.Reduce, 0, 78);    // Comma
            actionTable[162, 55] = new ParserAction(ParserActions.Shift, 165, 0);    // ArrayDimensions

            // State 163
            actionTable[163, 0] = new ParserAction(ParserActions.Reduce, 0, 68);    // EOF
            actionTable[163, 13] = new ParserAction(ParserActions.Reduce, 0, 68);    // LParan
            actionTable[163, 14] = new ParserAction(ParserActions.Reduce, 0, 68);    // RParan
            actionTable[163, 15] = new ParserAction(ParserActions.Reduce, 0, 68);    // LSqr
            actionTable[163, 16] = new ParserAction(ParserActions.Reduce, 0, 68);    // RSqr
            actionTable[163, 17] = new ParserAction(ParserActions.Reduce, 0, 68);    // LCurly
            actionTable[163, 18] = new ParserAction(ParserActions.Reduce, 0, 68);    // RCurly
            actionTable[163, 19] = new ParserAction(ParserActions.Reduce, 0, 68);    // Comma
            actionTable[163, 20] = new ParserAction(ParserActions.Reduce, 0, 68);    // Dot
            actionTable[163, 21] = new ParserAction(ParserActions.Reduce, 0, 68);    // DotDot
            actionTable[163, 22] = new ParserAction(ParserActions.Reduce, 0, 68);    // Plus
            actionTable[163, 23] = new ParserAction(ParserActions.Reduce, 0, 68);    // Minus
            actionTable[163, 24] = new ParserAction(ParserActions.Reduce, 0, 68);    // Mult
            actionTable[163, 25] = new ParserAction(ParserActions.Reduce, 0, 68);    // Div
            actionTable[163, 26] = new ParserAction(ParserActions.Reduce, 0, 68);    // Mod
            actionTable[163, 27] = new ParserAction(ParserActions.Reduce, 0, 68);    // Equal
            actionTable[163, 28] = new ParserAction(ParserActions.Reduce, 0, 68);    // NotEqual
            actionTable[163, 29] = new ParserAction(ParserActions.Reduce, 0, 68);    // Lesser
            actionTable[163, 30] = new ParserAction(ParserActions.Reduce, 0, 68);    // Greater
            actionTable[163, 31] = new ParserAction(ParserActions.Reduce, 0, 68);    // LesserOrEqual
            actionTable[163, 32] = new ParserAction(ParserActions.Reduce, 0, 68);    // GreaterOrEqual
            actionTable[163, 34] = new ParserAction(ParserActions.Reduce, 0, 68);    // And
            actionTable[163, 35] = new ParserAction(ParserActions.Reduce, 0, 68);    // Or
            actionTable[163, 36] = new ParserAction(ParserActions.Reduce, 0, 68);    // Assignment
            actionTable[163, 37] = new ParserAction(ParserActions.Reduce, 0, 68);    // PlusAssignment
            actionTable[163, 38] = new ParserAction(ParserActions.Reduce, 0, 68);    // MinusAssignment
            actionTable[163, 39] = new ParserAction(ParserActions.Reduce, 0, 68);    // MultAssignment
            actionTable[163, 40] = new ParserAction(ParserActions.Reduce, 0, 68);    // DivAssignment
            actionTable[163, 41] = new ParserAction(ParserActions.Reduce, 0, 68);    // ModAssignment
            actionTable[163, 42] = new ParserAction(ParserActions.Reduce, 0, 68);    // LShift
            actionTable[163, 43] = new ParserAction(ParserActions.Reduce, 0, 68);    // RShift
            actionTable[163, 45] = new ParserAction(ParserActions.Reduce, 0, 68);    // LogicalAnd
            actionTable[163, 46] = new ParserAction(ParserActions.Reduce, 0, 68);    // LogicalOr
            actionTable[163, 47] = new ParserAction(ParserActions.Reduce, 0, 68);    // LogicalXor
            actionTable[163, 48] = new ParserAction(ParserActions.Reduce, 0, 68);    // LShiftAssignment
            actionTable[163, 49] = new ParserAction(ParserActions.Reduce, 0, 68);    // RShiftAssignment
            actionTable[163, 50] = new ParserAction(ParserActions.Reduce, 0, 68);    // AndAssignment
            actionTable[163, 51] = new ParserAction(ParserActions.Reduce, 0, 68);    // XorAssignment
            actionTable[163, 52] = new ParserAction(ParserActions.Reduce, 0, 68);    // OrAssignment
            actionTable[163, 53] = new ParserAction(ParserActions.Reduce, 0, 68);    // PlusPlus
            actionTable[163, 54] = new ParserAction(ParserActions.Reduce, 0, 68);    // MinusMinus

            // State 164
            actionTable[164, 0] = new ParserAction(ParserActions.Reduce, 0, 70);    // EOF
            actionTable[164, 13] = new ParserAction(ParserActions.Reduce, 0, 70);    // LParan
            actionTable[164, 14] = new ParserAction(ParserActions.Reduce, 0, 70);    // RParan
            actionTable[164, 15] = new ParserAction(ParserActions.Reduce, 0, 70);    // LSqr
            actionTable[164, 16] = new ParserAction(ParserActions.Reduce, 0, 70);    // RSqr
            actionTable[164, 17] = new ParserAction(ParserActions.Reduce, 0, 70);    // LCurly
            actionTable[164, 18] = new ParserAction(ParserActions.Reduce, 0, 70);    // RCurly
            actionTable[164, 19] = new ParserAction(ParserActions.Reduce, 0, 70);    // Comma
            actionTable[164, 20] = new ParserAction(ParserActions.Reduce, 0, 70);    // Dot
            actionTable[164, 21] = new ParserAction(ParserActions.Reduce, 0, 70);    // DotDot
            actionTable[164, 22] = new ParserAction(ParserActions.Reduce, 0, 70);    // Plus
            actionTable[164, 23] = new ParserAction(ParserActions.Reduce, 0, 70);    // Minus
            actionTable[164, 24] = new ParserAction(ParserActions.Reduce, 0, 70);    // Mult
            actionTable[164, 25] = new ParserAction(ParserActions.Reduce, 0, 70);    // Div
            actionTable[164, 26] = new ParserAction(ParserActions.Reduce, 0, 70);    // Mod
            actionTable[164, 27] = new ParserAction(ParserActions.Reduce, 0, 70);    // Equal
            actionTable[164, 28] = new ParserAction(ParserActions.Reduce, 0, 70);    // NotEqual
            actionTable[164, 29] = new ParserAction(ParserActions.Reduce, 0, 70);    // Lesser
            actionTable[164, 30] = new ParserAction(ParserActions.Reduce, 0, 70);    // Greater
            actionTable[164, 31] = new ParserAction(ParserActions.Reduce, 0, 70);    // LesserOrEqual
            actionTable[164, 32] = new ParserAction(ParserActions.Reduce, 0, 70);    // GreaterOrEqual
            actionTable[164, 34] = new ParserAction(ParserActions.Reduce, 0, 70);    // And
            actionTable[164, 35] = new ParserAction(ParserActions.Reduce, 0, 70);    // Or
            actionTable[164, 36] = new ParserAction(ParserActions.Reduce, 0, 70);    // Assignment
            actionTable[164, 37] = new ParserAction(ParserActions.Reduce, 0, 70);    // PlusAssignment
            actionTable[164, 38] = new ParserAction(ParserActions.Reduce, 0, 70);    // MinusAssignment
            actionTable[164, 39] = new ParserAction(ParserActions.Reduce, 0, 70);    // MultAssignment
            actionTable[164, 40] = new ParserAction(ParserActions.Reduce, 0, 70);    // DivAssignment
            actionTable[164, 41] = new ParserAction(ParserActions.Reduce, 0, 70);    // ModAssignment
            actionTable[164, 42] = new ParserAction(ParserActions.Reduce, 0, 70);    // LShift
            actionTable[164, 43] = new ParserAction(ParserActions.Reduce, 0, 70);    // RShift
            actionTable[164, 45] = new ParserAction(ParserActions.Reduce, 0, 70);    // LogicalAnd
            actionTable[164, 46] = new ParserAction(ParserActions.Reduce, 0, 70);    // LogicalOr
            actionTable[164, 47] = new ParserAction(ParserActions.Reduce, 0, 70);    // LogicalXor
            actionTable[164, 48] = new ParserAction(ParserActions.Reduce, 0, 70);    // LShiftAssignment
            actionTable[164, 49] = new ParserAction(ParserActions.Reduce, 0, 70);    // RShiftAssignment
            actionTable[164, 50] = new ParserAction(ParserActions.Reduce, 0, 70);    // AndAssignment
            actionTable[164, 51] = new ParserAction(ParserActions.Reduce, 0, 70);    // XorAssignment
            actionTable[164, 52] = new ParserAction(ParserActions.Reduce, 0, 70);    // OrAssignment
            actionTable[164, 53] = new ParserAction(ParserActions.Reduce, 0, 70);    // PlusPlus
            actionTable[164, 54] = new ParserAction(ParserActions.Reduce, 0, 70);    // MinusMinus

            // State 165
            actionTable[165, 18] = new ParserAction(ParserActions.Reduce, 0, 80);    // RCurly
            actionTable[165, 19] = new ParserAction(ParserActions.Reduce, 0, 80);    // Comma

            gotoTable = new int[NumStates, NumNonTerminals];
            for (int i = 0; i < NumStates; i++)
            {
                for (int j = 0; j < NumNonTerminals; j++)
                {
                    gotoTable[i, j] = -1;
                }
            }

            gotoTable[0, 0] = 1;
            gotoTable[0, 1] = 2;
            gotoTable[0, 2] = 3;
            gotoTable[0, 3] = 4;
            gotoTable[0, 4] = 5;
            gotoTable[0, 5] = 6;
            gotoTable[0, 6] = 7;
            gotoTable[0, 7] = 8;
            gotoTable[0, 8] = 9;
            gotoTable[0, 9] = 10;
            gotoTable[0, 10] = 11;
            gotoTable[0, 11] = 12;
            gotoTable[0, 12] = 13;
            gotoTable[0, 13] = 14;
            gotoTable[24, 0] = 70;
            gotoTable[24, 1] = 2;
            gotoTable[24, 2] = 3;
            gotoTable[24, 3] = 4;
            gotoTable[24, 4] = 5;
            gotoTable[24, 5] = 6;
            gotoTable[24, 6] = 7;
            gotoTable[24, 7] = 8;
            gotoTable[24, 8] = 9;
            gotoTable[24, 9] = 10;
            gotoTable[24, 10] = 11;
            gotoTable[24, 11] = 12;
            gotoTable[24, 12] = 13;
            gotoTable[24, 13] = 14;
            gotoTable[25, 0] = 72;
            gotoTable[25, 1] = 2;
            gotoTable[25, 2] = 3;
            gotoTable[25, 3] = 4;
            gotoTable[25, 4] = 5;
            gotoTable[25, 5] = 6;
            gotoTable[25, 6] = 7;
            gotoTable[25, 7] = 8;
            gotoTable[25, 8] = 9;
            gotoTable[25, 9] = 10;
            gotoTable[25, 10] = 11;
            gotoTable[25, 11] = 12;
            gotoTable[25, 12] = 13;
            gotoTable[25, 13] = 14;
            gotoTable[26, 0] = 74;
            gotoTable[26, 1] = 2;
            gotoTable[26, 2] = 3;
            gotoTable[26, 3] = 4;
            gotoTable[26, 4] = 5;
            gotoTable[26, 5] = 6;
            gotoTable[26, 6] = 7;
            gotoTable[26, 7] = 8;
            gotoTable[26, 8] = 9;
            gotoTable[26, 9] = 10;
            gotoTable[26, 10] = 11;
            gotoTable[26, 11] = 12;
            gotoTable[26, 12] = 13;
            gotoTable[26, 13] = 14;
            gotoTable[26, 14] = 75;
            gotoTable[26, 16] = 76;
            gotoTable[27, 11] = 78;
            gotoTable[27, 12] = 13;
            gotoTable[27, 13] = 14;
            gotoTable[28, 11] = 79;
            gotoTable[28, 12] = 13;
            gotoTable[28, 13] = 14;
            gotoTable[29, 11] = 80;
            gotoTable[29, 12] = 13;
            gotoTable[29, 13] = 14;
            gotoTable[30, 11] = 81;
            gotoTable[30, 12] = 13;
            gotoTable[30, 13] = 14;
            gotoTable[31, 11] = 82;
            gotoTable[31, 12] = 13;
            gotoTable[31, 13] = 14;
            gotoTable[32, 11] = 83;
            gotoTable[32, 12] = 13;
            gotoTable[32, 13] = 14;
            gotoTable[33, 2] = 84;
            gotoTable[33, 3] = 4;
            gotoTable[33, 4] = 5;
            gotoTable[33, 5] = 6;
            gotoTable[33, 6] = 7;
            gotoTable[33, 7] = 8;
            gotoTable[33, 8] = 9;
            gotoTable[33, 9] = 10;
            gotoTable[33, 10] = 11;
            gotoTable[33, 11] = 12;
            gotoTable[33, 12] = 13;
            gotoTable[33, 13] = 14;
            gotoTable[34, 0] = 85;
            gotoTable[34, 1] = 2;
            gotoTable[34, 2] = 3;
            gotoTable[34, 3] = 4;
            gotoTable[34, 4] = 5;
            gotoTable[34, 5] = 6;
            gotoTable[34, 6] = 7;
            gotoTable[34, 7] = 8;
            gotoTable[34, 8] = 9;
            gotoTable[34, 9] = 10;
            gotoTable[34, 10] = 11;
            gotoTable[34, 11] = 12;
            gotoTable[34, 12] = 13;
            gotoTable[34, 13] = 14;
            gotoTable[35, 0] = 86;
            gotoTable[35, 1] = 2;
            gotoTable[35, 2] = 3;
            gotoTable[35, 3] = 4;
            gotoTable[35, 4] = 5;
            gotoTable[35, 5] = 6;
            gotoTable[35, 6] = 7;
            gotoTable[35, 7] = 8;
            gotoTable[35, 8] = 9;
            gotoTable[35, 9] = 10;
            gotoTable[35, 10] = 11;
            gotoTable[35, 11] = 12;
            gotoTable[35, 12] = 13;
            gotoTable[35, 13] = 14;
            gotoTable[36, 0] = 87;
            gotoTable[36, 1] = 2;
            gotoTable[36, 2] = 3;
            gotoTable[36, 3] = 4;
            gotoTable[36, 4] = 5;
            gotoTable[36, 5] = 6;
            gotoTable[36, 6] = 7;
            gotoTable[36, 7] = 8;
            gotoTable[36, 8] = 9;
            gotoTable[36, 9] = 10;
            gotoTable[36, 10] = 11;
            gotoTable[36, 11] = 12;
            gotoTable[36, 12] = 13;
            gotoTable[36, 13] = 14;
            gotoTable[37, 0] = 88;
            gotoTable[37, 1] = 2;
            gotoTable[37, 2] = 3;
            gotoTable[37, 3] = 4;
            gotoTable[37, 4] = 5;
            gotoTable[37, 5] = 6;
            gotoTable[37, 6] = 7;
            gotoTable[37, 7] = 8;
            gotoTable[37, 8] = 9;
            gotoTable[37, 9] = 10;
            gotoTable[37, 10] = 11;
            gotoTable[37, 11] = 12;
            gotoTable[37, 12] = 13;
            gotoTable[37, 13] = 14;
            gotoTable[38, 0] = 89;
            gotoTable[38, 1] = 2;
            gotoTable[38, 2] = 3;
            gotoTable[38, 3] = 4;
            gotoTable[38, 4] = 5;
            gotoTable[38, 5] = 6;
            gotoTable[38, 6] = 7;
            gotoTable[38, 7] = 8;
            gotoTable[38, 8] = 9;
            gotoTable[38, 9] = 10;
            gotoTable[38, 10] = 11;
            gotoTable[38, 11] = 12;
            gotoTable[38, 12] = 13;
            gotoTable[38, 13] = 14;
            gotoTable[39, 0] = 90;
            gotoTable[39, 1] = 2;
            gotoTable[39, 2] = 3;
            gotoTable[39, 3] = 4;
            gotoTable[39, 4] = 5;
            gotoTable[39, 5] = 6;
            gotoTable[39, 6] = 7;
            gotoTable[39, 7] = 8;
            gotoTable[39, 8] = 9;
            gotoTable[39, 9] = 10;
            gotoTable[39, 10] = 11;
            gotoTable[39, 11] = 12;
            gotoTable[39, 12] = 13;
            gotoTable[39, 13] = 14;
            gotoTable[40, 0] = 91;
            gotoTable[40, 1] = 2;
            gotoTable[40, 2] = 3;
            gotoTable[40, 3] = 4;
            gotoTable[40, 4] = 5;
            gotoTable[40, 5] = 6;
            gotoTable[40, 6] = 7;
            gotoTable[40, 7] = 8;
            gotoTable[40, 8] = 9;
            gotoTable[40, 9] = 10;
            gotoTable[40, 10] = 11;
            gotoTable[40, 11] = 12;
            gotoTable[40, 12] = 13;
            gotoTable[40, 13] = 14;
            gotoTable[41, 0] = 92;
            gotoTable[41, 1] = 2;
            gotoTable[41, 2] = 3;
            gotoTable[41, 3] = 4;
            gotoTable[41, 4] = 5;
            gotoTable[41, 5] = 6;
            gotoTable[41, 6] = 7;
            gotoTable[41, 7] = 8;
            gotoTable[41, 8] = 9;
            gotoTable[41, 9] = 10;
            gotoTable[41, 10] = 11;
            gotoTable[41, 11] = 12;
            gotoTable[41, 12] = 13;
            gotoTable[41, 13] = 14;
            gotoTable[42, 0] = 93;
            gotoTable[42, 1] = 2;
            gotoTable[42, 2] = 3;
            gotoTable[42, 3] = 4;
            gotoTable[42, 4] = 5;
            gotoTable[42, 5] = 6;
            gotoTable[42, 6] = 7;
            gotoTable[42, 7] = 8;
            gotoTable[42, 8] = 9;
            gotoTable[42, 9] = 10;
            gotoTable[42, 10] = 11;
            gotoTable[42, 11] = 12;
            gotoTable[42, 12] = 13;
            gotoTable[42, 13] = 14;
            gotoTable[43, 0] = 94;
            gotoTable[43, 1] = 2;
            gotoTable[43, 2] = 3;
            gotoTable[43, 3] = 4;
            gotoTable[43, 4] = 5;
            gotoTable[43, 5] = 6;
            gotoTable[43, 6] = 7;
            gotoTable[43, 7] = 8;
            gotoTable[43, 8] = 9;
            gotoTable[43, 9] = 10;
            gotoTable[43, 10] = 11;
            gotoTable[43, 11] = 12;
            gotoTable[43, 12] = 13;
            gotoTable[43, 13] = 14;
            gotoTable[44, 0] = 95;
            gotoTable[44, 1] = 2;
            gotoTable[44, 2] = 3;
            gotoTable[44, 3] = 4;
            gotoTable[44, 4] = 5;
            gotoTable[44, 5] = 6;
            gotoTable[44, 6] = 7;
            gotoTable[44, 7] = 8;
            gotoTable[44, 8] = 9;
            gotoTable[44, 9] = 10;
            gotoTable[44, 10] = 11;
            gotoTable[44, 11] = 12;
            gotoTable[44, 12] = 13;
            gotoTable[44, 13] = 14;
            gotoTable[45, 3] = 96;
            gotoTable[45, 4] = 5;
            gotoTable[45, 5] = 6;
            gotoTable[45, 6] = 7;
            gotoTable[45, 7] = 8;
            gotoTable[45, 8] = 9;
            gotoTable[45, 9] = 10;
            gotoTable[45, 10] = 11;
            gotoTable[45, 11] = 12;
            gotoTable[45, 12] = 13;
            gotoTable[45, 13] = 14;
            gotoTable[46, 4] = 97;
            gotoTable[46, 5] = 6;
            gotoTable[46, 6] = 7;
            gotoTable[46, 7] = 8;
            gotoTable[46, 8] = 9;
            gotoTable[46, 9] = 10;
            gotoTable[46, 10] = 11;
            gotoTable[46, 11] = 12;
            gotoTable[46, 12] = 13;
            gotoTable[46, 13] = 14;
            gotoTable[47, 5] = 98;
            gotoTable[47, 6] = 7;
            gotoTable[47, 7] = 8;
            gotoTable[47, 8] = 9;
            gotoTable[47, 9] = 10;
            gotoTable[47, 10] = 11;
            gotoTable[47, 11] = 12;
            gotoTable[47, 12] = 13;
            gotoTable[47, 13] = 14;
            gotoTable[48, 6] = 99;
            gotoTable[48, 7] = 8;
            gotoTable[48, 8] = 9;
            gotoTable[48, 9] = 10;
            gotoTable[48, 10] = 11;
            gotoTable[48, 11] = 12;
            gotoTable[48, 12] = 13;
            gotoTable[48, 13] = 14;
            gotoTable[49, 7] = 100;
            gotoTable[49, 8] = 9;
            gotoTable[49, 9] = 10;
            gotoTable[49, 10] = 11;
            gotoTable[49, 11] = 12;
            gotoTable[49, 12] = 13;
            gotoTable[49, 13] = 14;
            gotoTable[50, 7] = 101;
            gotoTable[50, 8] = 9;
            gotoTable[50, 9] = 10;
            gotoTable[50, 10] = 11;
            gotoTable[50, 11] = 12;
            gotoTable[50, 12] = 13;
            gotoTable[50, 13] = 14;
            gotoTable[51, 8] = 102;
            gotoTable[51, 9] = 10;
            gotoTable[51, 10] = 11;
            gotoTable[51, 11] = 12;
            gotoTable[51, 12] = 13;
            gotoTable[51, 13] = 14;
            gotoTable[52, 8] = 103;
            gotoTable[52, 9] = 10;
            gotoTable[52, 10] = 11;
            gotoTable[52, 11] = 12;
            gotoTable[52, 12] = 13;
            gotoTable[52, 13] = 14;
            gotoTable[53, 8] = 104;
            gotoTable[53, 9] = 10;
            gotoTable[53, 10] = 11;
            gotoTable[53, 11] = 12;
            gotoTable[53, 12] = 13;
            gotoTable[53, 13] = 14;
            gotoTable[54, 8] = 105;
            gotoTable[54, 9] = 10;
            gotoTable[54, 10] = 11;
            gotoTable[54, 11] = 12;
            gotoTable[54, 12] = 13;
            gotoTable[54, 13] = 14;
            gotoTable[55, 9] = 106;
            gotoTable[55, 10] = 11;
            gotoTable[55, 11] = 12;
            gotoTable[55, 12] = 13;
            gotoTable[55, 13] = 14;
            gotoTable[56, 9] = 107;
            gotoTable[56, 10] = 11;
            gotoTable[56, 11] = 12;
            gotoTable[56, 12] = 13;
            gotoTable[56, 13] = 14;
            gotoTable[57, 10] = 108;
            gotoTable[57, 11] = 12;
            gotoTable[57, 12] = 13;
            gotoTable[57, 13] = 14;
            gotoTable[58, 10] = 109;
            gotoTable[58, 11] = 12;
            gotoTable[58, 12] = 13;
            gotoTable[58, 13] = 14;
            gotoTable[59, 11] = 110;
            gotoTable[59, 12] = 13;
            gotoTable[59, 13] = 14;
            gotoTable[60, 11] = 111;
            gotoTable[60, 12] = 13;
            gotoTable[60, 13] = 14;
            gotoTable[61, 11] = 112;
            gotoTable[61, 12] = 13;
            gotoTable[61, 13] = 14;
            gotoTable[62, 0] = 74;
            gotoTable[62, 1] = 2;
            gotoTable[62, 2] = 3;
            gotoTable[62, 3] = 4;
            gotoTable[62, 4] = 5;
            gotoTable[62, 5] = 6;
            gotoTable[62, 6] = 7;
            gotoTable[62, 7] = 8;
            gotoTable[62, 8] = 9;
            gotoTable[62, 9] = 10;
            gotoTable[62, 10] = 11;
            gotoTable[62, 11] = 12;
            gotoTable[62, 12] = 13;
            gotoTable[62, 13] = 14;
            gotoTable[62, 14] = 113;
            gotoTable[62, 16] = 76;
            gotoTable[63, 0] = 74;
            gotoTable[63, 1] = 2;
            gotoTable[63, 2] = 3;
            gotoTable[63, 3] = 4;
            gotoTable[63, 4] = 5;
            gotoTable[63, 5] = 6;
            gotoTable[63, 6] = 7;
            gotoTable[63, 7] = 8;
            gotoTable[63, 8] = 9;
            gotoTable[63, 9] = 10;
            gotoTable[63, 10] = 11;
            gotoTable[63, 11] = 12;
            gotoTable[63, 12] = 13;
            gotoTable[63, 13] = 14;
            gotoTable[63, 14] = 114;
            gotoTable[63, 16] = 76;
            gotoTable[64, 15] = 115;
            gotoTable[77, 0] = 127;
            gotoTable[77, 1] = 2;
            gotoTable[77, 2] = 3;
            gotoTable[77, 3] = 4;
            gotoTable[77, 4] = 5;
            gotoTable[77, 5] = 6;
            gotoTable[77, 6] = 7;
            gotoTable[77, 7] = 8;
            gotoTable[77, 8] = 9;
            gotoTable[77, 9] = 10;
            gotoTable[77, 10] = 11;
            gotoTable[77, 11] = 12;
            gotoTable[77, 12] = 13;
            gotoTable[77, 13] = 14;
            gotoTable[118, 0] = 74;
            gotoTable[118, 1] = 2;
            gotoTable[118, 2] = 3;
            gotoTable[118, 3] = 4;
            gotoTable[118, 4] = 5;
            gotoTable[118, 5] = 6;
            gotoTable[118, 6] = 7;
            gotoTable[118, 7] = 8;
            gotoTable[118, 8] = 9;
            gotoTable[118, 9] = 10;
            gotoTable[118, 10] = 11;
            gotoTable[118, 11] = 12;
            gotoTable[118, 12] = 13;
            gotoTable[118, 13] = 14;
            gotoTable[118, 14] = 134;
            gotoTable[118, 16] = 76;
            gotoTable[119, 0] = 74;
            gotoTable[119, 1] = 2;
            gotoTable[119, 2] = 3;
            gotoTable[119, 3] = 4;
            gotoTable[119, 4] = 5;
            gotoTable[119, 5] = 6;
            gotoTable[119, 6] = 7;
            gotoTable[119, 7] = 8;
            gotoTable[119, 8] = 9;
            gotoTable[119, 9] = 10;
            gotoTable[119, 10] = 11;
            gotoTable[119, 11] = 12;
            gotoTable[119, 12] = 13;
            gotoTable[119, 13] = 14;
            gotoTable[119, 14] = 135;
            gotoTable[119, 16] = 76;
            gotoTable[120, 15] = 136;
            gotoTable[122, 11] = 137;
            gotoTable[122, 12] = 13;
            gotoTable[122, 13] = 14;
            gotoTable[123, 0] = 138;
            gotoTable[123, 1] = 2;
            gotoTable[123, 2] = 3;
            gotoTable[123, 3] = 4;
            gotoTable[123, 4] = 5;
            gotoTable[123, 5] = 6;
            gotoTable[123, 6] = 7;
            gotoTable[123, 7] = 8;
            gotoTable[123, 8] = 9;
            gotoTable[123, 9] = 10;
            gotoTable[123, 10] = 11;
            gotoTable[123, 11] = 12;
            gotoTable[123, 12] = 13;
            gotoTable[123, 13] = 14;
            gotoTable[126, 0] = 140;
            gotoTable[126, 1] = 2;
            gotoTable[126, 2] = 3;
            gotoTable[126, 3] = 4;
            gotoTable[126, 4] = 5;
            gotoTable[126, 5] = 6;
            gotoTable[126, 6] = 7;
            gotoTable[126, 7] = 8;
            gotoTable[126, 8] = 9;
            gotoTable[126, 9] = 10;
            gotoTable[126, 10] = 11;
            gotoTable[126, 11] = 12;
            gotoTable[126, 12] = 13;
            gotoTable[126, 13] = 14;
            gotoTable[132, 15] = 144;
            gotoTable[141, 0] = 150;
            gotoTable[141, 1] = 2;
            gotoTable[141, 2] = 3;
            gotoTable[141, 3] = 4;
            gotoTable[141, 4] = 5;
            gotoTable[141, 5] = 6;
            gotoTable[141, 6] = 7;
            gotoTable[141, 7] = 8;
            gotoTable[141, 8] = 9;
            gotoTable[141, 9] = 10;
            gotoTable[141, 10] = 11;
            gotoTable[141, 11] = 12;
            gotoTable[141, 12] = 13;
            gotoTable[141, 13] = 14;
            gotoTable[142, 0] = 74;
            gotoTable[142, 1] = 2;
            gotoTable[142, 2] = 3;
            gotoTable[142, 3] = 4;
            gotoTable[142, 4] = 5;
            gotoTable[142, 5] = 6;
            gotoTable[142, 6] = 7;
            gotoTable[142, 7] = 8;
            gotoTable[142, 8] = 9;
            gotoTable[142, 9] = 10;
            gotoTable[142, 10] = 11;
            gotoTable[142, 11] = 12;
            gotoTable[142, 12] = 13;
            gotoTable[142, 13] = 14;
            gotoTable[142, 14] = 151;
            gotoTable[142, 16] = 76;
            gotoTable[152, 15] = 158;
            gotoTable[155, 0] = 74;
            gotoTable[155, 1] = 2;
            gotoTable[155, 2] = 3;
            gotoTable[155, 3] = 4;
            gotoTable[155, 4] = 5;
            gotoTable[155, 5] = 6;
            gotoTable[155, 6] = 7;
            gotoTable[155, 7] = 8;
            gotoTable[155, 8] = 9;
            gotoTable[155, 9] = 10;
            gotoTable[155, 10] = 11;
            gotoTable[155, 11] = 12;
            gotoTable[155, 12] = 13;
            gotoTable[155, 13] = 14;
            gotoTable[155, 14] = 160;
            gotoTable[155, 16] = 76;
            gotoTable[156, 0] = 74;
            gotoTable[156, 1] = 2;
            gotoTable[156, 2] = 3;
            gotoTable[156, 3] = 4;
            gotoTable[156, 4] = 5;
            gotoTable[156, 5] = 6;
            gotoTable[156, 6] = 7;
            gotoTable[156, 7] = 8;
            gotoTable[156, 8] = 9;
            gotoTable[156, 9] = 10;
            gotoTable[156, 10] = 11;
            gotoTable[156, 11] = 12;
            gotoTable[156, 12] = 13;
            gotoTable[156, 13] = 14;
            gotoTable[156, 14] = 161;
            gotoTable[156, 16] = 76;

        }

        /// <summary>
        /// Gets the initial state to start the parser in.
        /// </summary>
        public int InitialState
        {
            get { return 0; }
        }

        /// <summary>
        /// Gets the next action for the parser to perform
        /// </summary>
        /// <param name="input_token">Current input token</param>
        /// <param name="current_state">Current state on top of the stack</param>
        /// <returns>Action to perform</returns>
        public ParserAction GetAction(int current_state, Tokens input_token)
        {
            return actionTable[current_state, (int)input_token];
        }

        /// <summary>
        /// Gets a reduction rule specified by number
        /// </summary>
        /// <param name="reduction_rule">Reduction rule to retrieve</param>
        /// <returns>Reduction rule</returns>
        public ReductionRule<NonTerminals, Reductions> GetReductionRule(int reduction_rule)
        {
            return reductionRules[reduction_rule];
        }

        /// <summary>
        /// Get which state to goto next following a reduction
        /// </summary>
        /// <param name="non_terminal">The non-terminal produced by the reduction</param>
        /// <param name="state">State currently on the top of the stack (following reduction)</param>
        /// <returns>New state to push on the stack, -1 in case of error</returns>
        public int GetGoto(int state, NonTerminals non_terminal)
        {
            return gotoTable[state, (int)non_terminal];
        }
    }

    /// <summary>
    /// Symbol class.
    /// </summary>
    public class Symbol : SymbolBase<Tokens, NonTerminals, Reductions, Symbol>
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DbAccess.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public static class DbAccess
    {
        private static string _connectionString;
        private static string _server;
        private static string _database;
        private static bool _initialized = false;

        public static string ConnectString
        {
            get { return _connectionString; }
        }

        public static bool IsInitialized
        {
            get { return _initialized; }
        }

        public static void Init(string server, string database)
        {
            if (String.IsNullOrEmpty(server))
                throw new ArgumentException("Invalid server string. The string must not be null or zero-length.");
            if (String.IsNullOrEmpty(database))
                throw new ArgumentException("Invalid database string. The string must not be null or zero-length.");

            _server = server;
            _database = database;
            _connectionString = String.Format("server={0};database={1};Integrated Security=SSPI;MultipleActiveResultSets=True", server, database);

            // Test the connection
            try
            {
                using (SqlConnection conn = new SqlConnection(_connectionString))
                {
                    conn.Open();
                    _initialized = true;
                }
            }
            catch (Exception ex)
            {
                throw new DBConnectException(server, database, ex);
            }
        }

        public static List<BuildInfo> GetBuilds()
        {
            List<BuildInfo> builds = new List<BuildInfo>();

            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandText = "p_build_get_builds";
                    cmd.CommandType = CommandType.StoredProcedure;

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            BuildInfo build = new BuildInfo();
                            build.Id = reader.GetInt64(0);
                            build.BuildName = reader.GetString(1);
                            build.BuildSourcePath = reader.GetString(2);
                            builds.Add(build);
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_build_get_builds", _server, _database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return builds;
        }

        public static List<EnvironmentInfo> GetEnvironments()
        {
            List<EnvironmentInfo> envs = new List<EnvironmentInfo>();

            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandText = "p_env_get_environments";
                    cmd.CommandType = CommandType.StoredProcedure;

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            int i = 0;
                            EnvironmentInfo env = new EnvironmentInfo();
                            env.Id = reader.GetInt64(i++);
                            env.Name = reader.GetString(i++);
                            env.StagerName = reader.GetString(i++);
                            env.BuildShare = reader.GetString(i++);
                            env.TitlesShare = reader.GetString(i++);
                            env.UserName = reader.GetString(i++);
                            env.Locked = reader.GetBoolean(i++);
                            env.Virtual = reader.GetBoolean(i++);
                            env.DNSFlipped = reader.GetBoolean(i++);
                            env.Active = reader.GetBoolean(i++);
                            if (!reader.IsDBNull(i))
                                env.HostList = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.ServerPrefix = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.ClientPoolIpBegin = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.ClientPoolIpEnd = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.SGAdminIp = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.INHInternetIp = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.SGInternetIp = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.XDSInternetIp = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.ClientPoolNetmask = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.ClientPoolGateway = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.InternetNetmask = reader.GetString(i++);
                            if (!reader.IsDBNull(i))
                                env.InternetGateway = reader.GetString(i++);

                            if (!env.DNSFlipped)
                            {
                                // Pull the passwords for this environment
                                env.Passwords = GetEnvironmentPasswords(env.Id);

                                // Pull the servers for this environment
                                env.Servers = GetEnvironmentServers(env.Id);
                            }

                            envs.Add(env);
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_env_get_environments", _server, _database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return envs;
        }

        public static List<EnvironmentPassword> GetEnvironmentPasswords(long envId)
        {
            List<EnvironmentPassword> pwds = new List<EnvironmentPassword>(2);
            pwds.Add(null);
            pwds.Add(null);

            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandText = "p_env_get_passwords";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@envId", envId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            EnvironmentPassword pwd = new EnvironmentPassword();
                            pwd.Password = reader.GetString(1);
                            pwd.ContextServer = reader.GetString(2);
                            pwd.Type = (PasswordType)reader.GetByte(3);
                            pwd.IsEncrypted = reader.GetBoolean(4);
                            pwds[((int)pwd.Type) - 1] = pwd;
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_env_get_passwords", _server, _database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return pwds;
        }

        public static Dictionary<string, List<EnvironmentServer>> GetEnvironmentServers(long envId)
        {
            Dictionary<string, List<EnvironmentServer>> serverList = new Dictionary<string, List<EnvironmentServer>>();

            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandText = "p_env_get_server_list";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@envId", envId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            string role = reader.GetString(1);
                            if (!serverList.ContainsKey(role))
                            {
                                serverList.Add(role, new List<EnvironmentServer>());
                            }
                            EnvironmentServer server = new EnvironmentServer();
                            server.Id = reader.GetInt64(0);
                            server.Role = role;
                            server.Name = reader.GetString(2);
                            // Skip the b_snapshot_ignore column
                            server.Ip = reader.GetString(4);
                            serverList[role].Add(server);
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_env_get_server_list", _server, _database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return serverList;
        }

        public static List<string> GetEnvironmentIPList(long envId)
        {
            List<string> ipList = new List<string>();

            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandText = "p_env_get_ip_list";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@envId", envId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_env_get_ip_list", _server, _database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return ipList;
        }

        #region Job Methods

        //
        //  This section contains all data access methods that are job-specific.
        //

        public static void ScheduleJob(long jobId)
        {
            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_schedule_job";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_schedule_job", _server, _database, ex);
                    }
                }
            }
        }

        public static string GetLatestSuccessfulVersion(string jobName, string environmentName, string buildName)
        {
            string latestVersion = "";

            using (SqlConnection conn = new SqlConnection(_connectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(_server, _database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_latest_version";
                    cmd.Parameters.AddWithValue("@jobName", jobName);
                    cmd.Parameters.AddWithValue("@environmentName", environmentName);
                    cmd.Parameters.AddWithValue("@buildName", buildName);
                    cmd.Parameters.Add("@latestVersion", SqlDbType.NVarChar);
                    cmd.Parameters[3].Size = 32;
                    cmd.Parameters[3].Direction = ParameterDirection.Output;

                    try
                    {
                        cmd.ExecuteNonQuery();
                        if (cmd.Parameters["@latestVersion"].Value != null)
                            latestVersion = cmd.Parameters["@latestVersion"].Value as string;
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_get_latest_version", _server, _database, ex);
                    }
                }
            }

            return latestVersion;
        }

        #endregion
    }

    public class DBConnectException : Exception
    {
        public DBConnectException(string server, string database, Exception e)
            : base(String.Format("Unable to connect to database. "
                                 + "Server={0}; Db={1}", server, database),
                   e)
        {
        }
    }

    public class DBAccessException : Exception
    {
        public DBAccessException(string proc, string server, string database, Exception e)
            : base(String.Format("Request ({0}) to the database failed. "
                                 + "Server={1}; Db={2}", proc, server, database),
                   e)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\BDServiceLogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public enum LoggingLevel
    {
        None = 0,
        Error = EventLogEntryType.Error,
        Warning = EventLogEntryType.Warning,
        Information = EventLogEntryType.Information,
        Debug = 5
    }
    
    public static class BDServiceLogger
	{
        public static string EventSource { get; set; }
        public static LoggingLevel TargetLogLevel { get; set; }

        public static void LogEvent(LoggingLevel level, string msg, params object[] args)
        {
            if (TargetLogLevel == LoggingLevel.None)
                return;

            EventLogEntryType entryType;

            if (LoggingLevel.None == level || LoggingLevel.Debug == level)
                entryType = EventLogEntryType.Information;
            else
                entryType = (EventLogEntryType)(int)level;

            // Only write the entry if the appropriate logging level is set
            if (TargetLogLevel >= level)
            {
                // Embed this call in a try...catch just so we don't crash while writing to the event log
                try
                {
                    EventLog.WriteEntry(EventSource, String.Format(msg, args), entryType, (int)level);
                }
                catch (Exception) { }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\BuildInfo.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class BuildInfo
    {
        public long Id { get; set; }
        public string BuildName { get; set; }
        public string BuildSourcePath { get; set; }
        public string BuildType { get; set; }

        public BuildInfo()
        {
            Id = 0;
            BuildName = "";
            BuildSourcePath = "";
            BuildType = "retail";
        }

        public string GetBuildTokenValue(string token)
        {
            string tokenValue = null;
            switch (token)
            {
                case ParameterTokens.ParamTokenBuildName:
                    tokenValue = BuildName;
                    break;
                case ParameterTokens.ParamTokenBuildPath:
                    tokenValue = BuildSourcePath;
                    break;
                case ParameterTokens.ParamTokenBuildType:
                    tokenValue = BuildType;
                    break;
            }
            return tokenValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DBSettings.cs ===
﻿using System;
using System.Collections.Generic;
using System.Threading;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public static class EnvironmentSettings
    {
        private static Dictionary<String, EnvironmentInfo> _envInfo = new Dictionary<string, EnvironmentInfo>();

        public static EnvironmentInfo GetEnvInfo(string envName)
        {
            EnvironmentInfo info = null;
            lock (_envInfo)
            {
                if (_envInfo.ContainsKey(envName.ToLower()))
                {
                    info = _envInfo[envName.ToLower()];

                    // If this is a DNSFlipped environment, we need to get the inactive sub-environment
                    if (info.DNSFlipped)
                    {
                        long envId = info.Id;
                        info = null;    // For DNS Flipped environments, we never return the parent

                        string subEnvName = envName.ToLower() + "_a";
                        if (_envInfo.ContainsKey(subEnvName) && !_envInfo[subEnvName].Active)
                        {
                            info = _envInfo[subEnvName];
                        }
                        else
                        {
                            subEnvName = envName.ToLower() + "_b";
                            if (_envInfo.ContainsKey(subEnvName) && !_envInfo[subEnvName].Active)
                            {
                                info = _envInfo[subEnvName];
                            }
                        }

                        // We never want to use the sub-environment name or id
                        // So after getting the environment info, set the name and id to those of the parent environment
                        if (null != info)
                        {
                            info.Name = envName;
                            info.Id = envId;
                        }
                    }
                }
            }
            return info;
        }

        public static void Add(string envName, EnvironmentInfo info)
        {
            if (String.IsNullOrEmpty(envName))
                throw new ArgumentException("Invalid environment name.");
            Monitor.Enter(_envInfo);
            if (!_envInfo.ContainsKey(envName.ToLower()))
            {
                _envInfo.Add(envName.ToLower(), info);
            }
            else
            {
                _envInfo[envName.ToLower()] = null;
                _envInfo[envName.ToLower()] = info;
            }
            Monitor.Exit(_envInfo);
        }

        public static void ReloadSettings()
        {
            List<EnvironmentInfo> envs = DbAccess.GetEnvironments();
            Monitor.Enter(_envInfo);
            _envInfo.Clear();
            foreach (EnvironmentInfo env in envs)
            {
                _envInfo.Add(env.Name.ToLower(), env);
            }
            Monitor.Exit(_envInfo);
        }
    }

    public static class BuildSettings
    {
        private static Dictionary<String, BuildInfo> _buildInfo = new Dictionary<string, BuildInfo>();

        public static BuildInfo GetBuildInfo(string buildName)
        {
            BuildInfo info = null;

            Monitor.Enter(_buildInfo);
            if (_buildInfo.ContainsKey(buildName.ToLower()))
                info = _buildInfo[buildName.ToLower()];
            Monitor.Exit(_buildInfo);

            return info;
        }

        public static void Add(string buildName, BuildInfo info)
        {
            if (String.IsNullOrEmpty(buildName))
                throw new ArgumentException("Invalid build name.");
            Monitor.Enter(_buildInfo);
            if (!_buildInfo.ContainsKey(buildName.ToLower()))
            {
                _buildInfo.Add(buildName.ToLower(), info);
            }
            else
            {
                _buildInfo[buildName.ToLower()] = null;
                _buildInfo[buildName.ToLower()] = info;
            }
            Monitor.Exit(_buildInfo);
        }

        public static void ReloadSettings()
        {
            List<BuildInfo> builds = DbAccess.GetBuilds();

            Monitor.Enter(_buildInfo);
            _buildInfo.Clear();
            foreach (BuildInfo build in builds)
            {
                _buildInfo.Add(build.BuildName.ToLower(), build);
            }
            Monitor.Exit(_buildInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\BDServiceSettings.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    internal class BDServiceSettings
	{
        public string SettingsFile { get; private set; }
        public string DataSourceServer { get; private set; }
        public string DataSourceDB { get; private set; }
        public List<DeploymentJob> Jobs { get; private set; }
        public bool NeedsReload { get; set; }

        public BDServiceSettings() { }
        public BDServiceSettings(BDServiceSettings obj)
        {
            SettingsFile = obj.SettingsFile;
            DataSourceServer = obj.DataSourceServer;
            DataSourceDB = obj.DataSourceDB;
            Jobs = new List<DeploymentJob>(obj.Jobs);
            NeedsReload = obj.NeedsReload;
        }

        public static BDServiceSettings Parse(string settingsFile)
        {
            BDServiceSettings settings = new BDServiceSettings();
            XPathDocument settingsDoc;
            XPathNavigator docNav;

            settings.SettingsFile = settingsFile;
            settingsDoc = LoadXmlFile(settingsFile);
            docNav = settingsDoc.CreateNavigator();
            docNav.MoveToChild(XPathNodeType.Element);

            // Load the data source element
            XPathNavigator node = docNav.SelectSingleNode("DataSource");
            settings.DataSourceServer = node.GetAttribute("Server", node.NamespaceURI);
            settings.DataSourceDB = node.GetAttribute("Database", node.NamespaceURI);

            // Load the Job elements
            settings.Jobs = new List<DeploymentJob>();
            XPathNodeIterator itor = docNav.Select("Jobs/Job");
            while (itor.MoveNext())
            {
                DeploymentJob job = DeploymentJob.Parse(itor.Current);
                settings.Jobs.Add(job);
            }

            settings.NeedsReload = false;
            return settings;
        }

        public void Clear()
        {
            SettingsFile = "";
            DataSourceServer = "";
            DataSourceDB = "";
            if (Jobs != null)
                Jobs.Clear();
        }

        private static XPathDocument LoadXmlFile(string xmlFile)
        {
            XPathDocument xmlDocument = null;

            using (StreamReader sr = new StreamReader(xmlFile))
            {
                string xsdFile = Path.Combine(Path.GetDirectoryName(xmlFile), Path.GetFileNameWithoutExtension(xmlFile) + ".xsd");
                XmlReaderSettings xrs = new XmlReaderSettings();
                xrs.ValidationType = ValidationType.Schema;
                xrs.Schemas.Add(null, xsdFile);
                using (XmlReader xr = XmlReader.Create(sr, xrs))
                {
                    xmlDocument = new XPathDocument(xr);
                }
            }

            return xmlDocument;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\BDService.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.ServiceProcess;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using Microsoft.Win32;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    /// <summary>
    /// The BuildDetector service watches a specified location for a new build to drop.
    /// Once it detects a new build, it executes a plugin that has been defined for that branch.
    /// </summary>
    public class BDService : ServiceBase
    {
        private ManualResetEvent _pause = new ManualResetEvent(true);   // Initially set to make sure the service isn't initially paused
        private AutoResetEvent _quit = new AutoResetEvent(false);
        private bool _paused = false;
        private Thread _deploymentThread = null;

        private DeploymentJob _currentJob = null;
        private string _settingsFile = null;
        private FileSystemWatcher _settingFileWatcher = null;
        internal BDServiceSettings _settings = null;
        private ParameterTokens.TokenValue[] _tokenReplacers = null;

        public BDService()
        {
            CanStop = true;
            CanShutdown = true;
            CanPauseAndContinue = true;
            ServiceName = "BDService";
            AutoLog = false;

            BDServiceLogger.EventSource = ServiceName;
#if DEBUG
            BDServiceLogger.TargetLogLevel = LoggingLevel.Debug;
#else
            BDServiceLogger.TargetLogLevel = LoggingLevel.Information;
#endif
        }

        public void OnSettingsFileChanged(object sender, FileSystemEventArgs args)
        {
            BDServiceLogger.LogEvent(LoggingLevel.Debug, "{0} file changed - a reload will occur during the next processing window.", args.FullPath);
            _settings.NeedsReload = true;
        }

        private bool ReloadSettings()
        {
            try
            {
                BDServiceSettings newSettings = BDServiceSettings.Parse(_settingsFile);
                if (null != _settings)
                    _settings.Clear();
                _settings = new BDServiceSettings(newSettings);
            }
            catch (Exception ex)
            {
                BDServiceLogger.LogEvent(LoggingLevel.Error, "Unable to load the settings file:\r\n\r\n{0}", ex);
                return false;
            }

            return true;
        }

        private Int32 CalculateWaitTime()
        {
            // Wake up at 00, 15, 30, and 45 minutes past every hour
            DateTime next = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, DateTime.Now.Hour, DateTime.Now.Minute, 0, 0);
            if (next.Minute >= 45)
                next = next.AddMinutes(60 - next.Minute);
            else if (next.Minute >= 30)
                next = next.AddMinutes(45 - next.Minute);
            else if (next.Minute >= 15)
                next = next.AddMinutes(30 - next.Minute);
            else
                next = next.AddMinutes(15 - next.Minute);

            return (Int32)((next.Ticks - DateTime.Now.Ticks) / TimeSpan.TicksPerMillisecond);
        }

        private bool CanScheduleJob(DeploymentJobSchedule schedule, DateTime lastRun)
        {
            bool runJob = false;
            DateTime current = DateTime.Now;
            TimeSpan delta = current.Subtract(lastRun);
            TimeSpan startTime = schedule.StartTime.TimeOfDay;
            TimeSpan endTime = schedule.EndTime.TimeOfDay;
            TimeSpan time = current.TimeOfDay;

            // We need these to be able to correctly calculate the delta days between
            // successful schedule attempts. By removing the Time portion, the resulting
            // delta will refer to days as calendar days rather than 24-hour periods.
            DateTime lastRunNoTime = new DateTime(lastRun.Year, lastRun.Month, lastRun.Day);
            DateTime currentNoTime = new DateTime(current.Year, current.Month, current.Day);
            TimeSpan deltaNoTime = currentNoTime.Subtract(lastRunNoTime);
            bool scheduledToday = deltaNoTime.Days == 0;

            switch (schedule.RunRate)
            {
                case Rate.QuarterHourly:
                    // Quarter-Hourly schedule
                    // This schedule runs the specified task every quarter hour during the run window.
                    // The startTime indicates when the task should start being processed.
                    // The endTime indicates when the task should stop begin processed.
                    // The Frequency value is used to determine how many times the task should be run
                    // during this window: 0 = Run every time; 1 = Run only once.
                    runJob = (
                        /* Check the weekdays - if None, it runs every day */
                        (Weekday.None == schedule.Weekdays || (((Weekday)(1 << (int)current.DayOfWeek) & schedule.Weekdays) != 0)) &&
                        /* Check to make sure the current time is within the provided run window */
                        ((current.Hour >= startTime.Hours && (current.Hour <= endTime.Hours || endTime.Hours == 0)) ||
                        ((current.Hour >= startTime.Hours && (current.Hour <= endTime.Hours || endTime.Hours == 0)) &&
                        (current.Minute >= startTime.Minutes && current.Minute <= endTime.Minutes))) &&
                        /* Check to see if this job should be scheduled only once and if it's already been scheduled */
                        ((schedule.Frequency > 0) && (!scheduledToday) || (schedule.Frequency == 0))
                        );
                    break;
                case Rate.Hourly:
                    // Hourly schedule
                    // An hourly schedule can be set to run at 00, 15, 30, or 45 minutes after the hour.
                    // The Frequency determines how many hours to wait for the next run.
                    // Specifying Weekdays limits the run to those days.
                    runJob = (
                        /* Check the weekdays - if None, it runs every day */
                        (Weekday.None == schedule.Weekdays || (((Weekday)(1 << (int)current.DayOfWeek) & schedule.Weekdays) != 0)) &&
                        /* Check the delta against the Frequency */
                        (delta.TotalHours >= schedule.Frequency) &&
                        /* Check the Start time */
                        (schedule.StartTime.Minute == current.Minute)
                        );
                    break;
                case Rate.Daily:
                    // Daily schedule
                    // A Daily schedule can be set to run every n days at a certain time of day.
                    runJob = (
                        /* Check to see if the job has already been scheduled today */
                        (!scheduledToday) &&
                        /* Check the delta days against the target Frequency */
                        (deltaNoTime.Days >= (int)schedule.Frequency) &&
                        /* Check the Start time */
                        (time.Hours == startTime.Hours && time.Minutes == startTime.Minutes)
                        );
                    break;
                case Rate.Weekly:
                    // Weekly schedule
                    // A Weekly schedule can be set to run every n weeks on certain days at a certain time.

                    // We need to recalculate the deltaNoTime to be defined as the number of days since the
                    // first day of the week in which the job was last successfully scheduled.
                    // However, if the job has never been run before, skip this step.
                    if (lastRunNoTime > DateTime.MinValue)
                        deltaNoTime = currentNoTime.Subtract(lastRunNoTime.AddDays(-(int)lastRunNoTime.DayOfWeek));
                    runJob = (
                        /* Check the weekdays to see if the job should be run today */
                        (((Weekday)(1 << (int)current.DayOfWeek) & schedule.Weekdays) != 0) &&
                        /* Check to see if the job has already been scheduled today */
                        (!scheduledToday) &&
                        /* Check the delta to see if the job should be scheduled this week */
                        ((deltaNoTime.TotalDays > 0 && deltaNoTime.TotalDays < 7) || (deltaNoTime.TotalDays >= (schedule.Frequency * 7))) &&
                        /* Check the Start time */
                        (time.Hours == startTime.Hours && time.Minutes == startTime.Minutes)
                        );
                    break;
                case Rate.Monthly:
                    // Monthly schedule
                    // A Monthly schedule can be set to run in two ways:
                    //  Every n months on a specific day at a certain time
                    //  Every mth weekday of every n months at a certain time
                    DateTime targetDate = lastRun.AddMonths(schedule.Frequency);
                    if (schedule.Weekdays > 0)
                    {
                        // Every mth weekday of every n months
                        runJob = (current.Month >= targetDate.Month &&
                                    (((Weekday)(1 << (int)current.DayOfWeek) & schedule.Weekdays) != 0) &&
                                    ((current.Day - schedule.WeekdayFrequency * 7) >= 1 &&
                                    (current.Day - schedule.WeekdayFrequency * 7) <= 7) &&
                                    (time.Hours == startTime.Hours && time.Minutes == startTime.Minutes));
                    }
                    else
                    {
                        // Every n months on a specific day
                        runJob = (current.Month >= targetDate.Month &&
                                    current.Day == schedule.WeekdayFrequency &&
                                    time.Hours == startTime.Hours && time.Minutes == startTime.Minutes);
                    }
                    break;
            }

            return runJob;
        }

        private string GetNewBuildVersion(TriggerPrecondition trigger)
        {
            // The trigger file path may be tokenized with environment- and build-specific tokens
            string triggerPath = ParameterTokens.ReplaceTokens(trigger.FileSpec, _tokenReplacers);
            string buildVersion = "";

            if (trigger.IsRemote)
            {
                // Connect to the remote resource
                EnvironmentInfo currentEnv = EnvironmentSettings.GetEnvInfo(_currentJob.EnvName);
                string password = null;
                if (currentEnv.Passwords[0] != null)
                {
                    if (currentEnv.Passwords[0].IsEncrypted)
                        password = DataProtector.DecryptFromHexString(currentEnv.Passwords[0].Password);
                    else
                        password = currentEnv.Passwords[0].Password;
                }

                try
                {
                    NetworkDrive.MapNetworkDrive(Path.GetPathRoot(triggerPath), null, currentEnv.UserName, password);
                }
                catch (Exception ex)
                {
                    BDServiceLogger.LogEvent(LoggingLevel.Warning, "GetNewBuildVersion: Mapping the network drive '{0}' threw an exception, but it may not prevent the new build version from being determined.\r\n\r\n{1}",
                        Path.GetPathRoot(triggerPath), ex);
                }
            }

            // Find the trigger file in the build drop directory
            string[] triggerFiles = Directory.GetFiles(Path.GetDirectoryName(triggerPath), Path.GetFileName(triggerPath));
            if (triggerFiles.Length > 0)
            {
                // Determine how we are to treat this trigger file:
                // If the Usage property is set to NameOnly, the name of the file is used as the version trigger
                // If the Usage property is set to ContentOnly, the file is opened and the first line is used as the version trigger
                // If the Usage property is set to Either, the file is opened and the first line is used. If the file is empty,
                //    the file name is used.
                if (trigger.Usage == TriggerUse.ContentOnly || trigger.Usage == TriggerUse.Either)
                {
                    using (StreamReader sr = new StreamReader(triggerFiles[0]))
                    {
                        buildVersion = sr.ReadLine();
                    }
                }

                if ((String.IsNullOrEmpty(buildVersion) && trigger.Usage == TriggerUse.Either) || trigger.Usage == TriggerUse.NameOnly)
                {
                    buildVersion = Path.GetFileName(triggerFiles[0]);
                }
            }
            else
            {
                BDServiceLogger.LogEvent(LoggingLevel.Warning, "Unable to locate the trigger file {0}", triggerPath);
            }

            if (trigger.IsRemote)
            {
                try
                {
                    NetworkDrive.UnMapNetworkDrive(Path.GetPathRoot(triggerPath), true);
                }
                catch (Exception ex)
                {
                    BDServiceLogger.LogEvent(LoggingLevel.Warning, "GetNewBuildVersion: Unmapping '{0}' failed with the following exception:\r\n{1}",
                        Path.GetPathRoot(triggerPath), ex);
                }
            }

            return buildVersion;
        }

        private bool IsUpdateRequired(string currentVersion, string newVersion)
        {
            // An empty newVersion string is an invalid version
            if (String.IsNullOrEmpty(newVersion))
                return false;

            // An empty currentVersion string indicates this job has never run successfully
            if (String.IsNullOrEmpty(currentVersion))
                return true;

            bool updateRequired = false;
            string[] versionParts = newVersion.Split('.');
            string[] currentParts = currentVersion.Split('.');
            if (versionParts.Length == currentParts.Length)
            {
                // Compare the versions and make the determination if an update is required
                for (int i = 0; (i < versionParts.Length) && (updateRequired == false); i++)
                {
                    int curPart, newPart;
                    if (!Int32.TryParse(currentParts[i], out curPart))
                    {
                        BDServiceLogger.LogEvent(LoggingLevel.Error, "Invalid current build part '{0}' in {1}", currentParts[i], currentVersion);
                        break;
                    }

                    if (!Int32.TryParse(versionParts[i], out newPart))
                    {
                        BDServiceLogger.LogEvent(LoggingLevel.Error, "Invalid new build part '{0}' in {1}", versionParts[i], newVersion);
                        break;
                    }

                    updateRequired = (newPart > curPart);
                }
            }
            else
            {
                BDServiceLogger.LogEvent(LoggingLevel.Error, "Unmatched version formats: '{0}' vs '{1}'", newVersion, currentVersion);
            }

            return updateRequired;
        }

        public void DeploymentThreadMethod()
        {
            BDServiceLogger.LogEvent(LoggingLevel.Debug, "Scheduler thread is alive!");
#if DEBUG
            Thread.Sleep(30000);    // In Debug mode, sleep for 30 seconds to allow time to attach a debugger
#endif
            try
            {
                // Perform the initial load of the BDService.xml file
                if (!ReloadSettings())
                {
                    if (null == _settings)
                    {
                        BDServiceLogger.LogEvent(LoggingLevel.Error, "Unable to load the BDService.xml file. The scheduler thread will now exit.");
                        return;
                    }
                }

                // Initialize the data source
                try
                {
                    DbAccess.Init(_settings.DataSourceServer, _settings.DataSourceDB);
                }
                catch (DBAccessException dbEx)
                {
                    BDServiceLogger.LogEvent(LoggingLevel.Error, "Unable to connect to the deployment database '{0}':\r\n{1}",
                        _settings.DataSourceServer, dbEx);
                }

                // Load the Build data from the database
                try
                {
                    BuildSettings.ReloadSettings();
                }
                catch (Exception ex)
                {
                    BDServiceLogger.LogEvent(LoggingLevel.Error, "Unable to perform the initial load of Build settings from the database:\r\n{0}", ex);
                }

                while (true)
                {
                    // If paused, the _pause event will not be set, causing WaitOne to block the thread
                    _pause.WaitOne();

                    if (!_quit.WaitOne(CalculateWaitTime(), false))
                    {
                        // If we've been paused during the WaitOne call, we don't want to do any processing
                        if (!_paused)
                        {
                            // First check to see if we need to reload the settings
                            if (null == _settings || _settings.NeedsReload)
                            {
                                BDServiceLogger.LogEvent(LoggingLevel.Debug, "Reloading BDService configuration file...");
                                if (!ReloadSettings())
                                {
                                    if (null == _settings)
                                        continue;
                                }
                            }

                            // Reload the Environment settings from the database
                            // This is done in the loop because DNS flipped environments
                            // need their settings updated after they flip.
                            try
                            {
                                EnvironmentSettings.ReloadSettings();
                            }
                            catch (Exception ex)
                            {
                                BDServiceLogger.LogEvent(LoggingLevel.Error, "Unable to load the Environment settings from the database:\r\n{0}", ex);
                                continue;
                            }

                            // Process the jobs
                            for (int i = 0; i < _settings.Jobs.Count; i++)
                            {
                                _pause.WaitOne();

                                _currentJob = _settings.Jobs[i];
                                if (!_currentJob.Enabled)
                                    continue;

                                bool scheduleJob = false;
                                try
                                {
                                    scheduleJob = CanScheduleJob(_currentJob.Schedule, _currentJob.GetLastRunDate());
                                }
                                catch (Exception ex)
                                {
                                    BDServiceLogger.LogEvent(LoggingLevel.Error, "An error occurred processing the schedule for the '{0}' job:\r\n{1}",
                                        _currentJob.Name, ex);
                                }

                                // Check the job's schedule to see if it should try to be scheduled
                                if (scheduleJob)
                                {
                                    // Set up the token replacement delegates for this job
                                    _tokenReplacers = new ParameterTokens.TokenValue[3];
                                    _tokenReplacers[0] = _currentJob.GetJobTokenValue;
                                    _tokenReplacers[1] = EnvironmentSettings.GetEnvInfo(_currentJob.EnvName).GetEnvTokenValue;
                                    _tokenReplacers[2] = BuildSettings.GetBuildInfo(_currentJob.Build).GetBuildTokenValue;

                                    try
                                    {
                                        // Pull the latest successful job version from the database
                                        string latestVersion = DbAccess.GetLatestSuccessfulVersion(_currentJob.Name, _currentJob.EnvName, _currentJob.Build);

                                        // Check to see if any other preconditions have been defined for this job
                                        if (_currentJob.Schedule.Trigger != null)
                                        {
                                            // Get the new version from the trigger location
                                            string newVersion = GetNewBuildVersion(_currentJob.Schedule.Trigger);

                                            // HACK: A new version trigger file format is being used for QFE builds:
                                            //       nn.nn.nnnn.nn.QFE
                                            //       Check for the existence of the .QFE and remove it.
                                            if (newVersion.EndsWith(".QFE"))
                                                newVersion = newVersion.Substring(0, newVersion.Length - 4);

                                            // If an update is required, set the version value on the Job object
                                            scheduleJob = IsUpdateRequired(latestVersion, newVersion);
                                            if (scheduleJob)
                                                _currentJob.Version = newVersion;
                                        }
                                        else if (_currentJob.Schedule.CustomPrecondition != null)
                                        {
                                            /* Call the custom precondition method */
                                        }
                                        else
                                        {
                                            // No Pre-Condition is defined, so set the job version to be one greater than the latest successful run
                                            long version = 0;
                                            if (!Int64.TryParse(latestVersion, out version))
                                                version = 0;
                                            _currentJob.Version = (++version).ToString();
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        BDServiceLogger.LogEvent(LoggingLevel.Error, "Precondition checking failed for the '{0}' job, so it will not be scheduled:\r\n{1}",
                                            _currentJob.Name, ex);
                                        scheduleJob = false;
                                    }
                                }

                                if (scheduleJob)
                                {
                                    try
                                    {
                                        // Schedule the job
                                        if (_currentJob.Create(_tokenReplacers) > 0)
                                        {
                                            DbAccess.ScheduleJob(_currentJob.Id);
                                            _currentJob.SetLastRunDate();
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        BDServiceLogger.LogEvent(LoggingLevel.Error, "Scheduling the '{0}' job in {1} failed.\r\n\r\n{2}",
                                            _currentJob.Name, _currentJob.EnvName, ex);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // We're quitting
                        BDServiceLogger.LogEvent(LoggingLevel.Debug, "Deployment thread received quit notification at {0}", DateTime.Now);
                        break;
                    }
                }
            }
            catch (ThreadAbortException)
            {
                BDServiceLogger.LogEvent(LoggingLevel.Debug, "Deployment thread abort signalled.");
            }
            catch (Exception ex)
            {
                BDServiceLogger.LogEvent(LoggingLevel.Error, "Unhandled exception occurred in the Deployment thread. The thread is terminating.\r\n\r\n{0}", ex);
            }

            BDServiceLogger.LogEvent(LoggingLevel.Debug, "Deployment thread exiting.");
        }

        #region Service Event Handlers
        protected override void OnStart(string[] args)
        {
            // The settings file must be in the same directory as the service executable
            _settingsFile = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, ServiceName + ".xml");
            _settings = new BDServiceSettings();
            _settings.NeedsReload = true;

            // Set up a FileSystemWatcher to detect changes to the settings file
            _settingFileWatcher = new FileSystemWatcher(AppDomain.CurrentDomain.BaseDirectory, Path.GetFileName(_settingsFile));
            _settingFileWatcher.Created += new FileSystemEventHandler(OnSettingsFileChanged);
            _settingFileWatcher.Changed += new FileSystemEventHandler(OnSettingsFileChanged);
            _settingFileWatcher.EnableRaisingEvents = true;

            // Create and start the build staging/deployment worker thread
            if ((null == _deploymentThread) ||
                ((_deploymentThread.ThreadState &
                (System.Threading.ThreadState.Unstarted | System.Threading.ThreadState.Stopped)) != 0))
            {
                _deploymentThread = new Thread(new ThreadStart(DeploymentThreadMethod));
                _deploymentThread.Name = "Scheduler Thread";
                _deploymentThread.Start();
            }

            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
            BDServiceLogger.LogEvent(LoggingLevel.Information, "BDService version {0} started at {1}", fvi.ProductVersion, DateTime.Now);
        }

        protected override void OnStop()
        {
            // Signal the worker thread to exit
            _quit.Set();
            _pause.Set();
            if (!_deploymentThread.Join(5000))
                _deploymentThread.Abort();

            this.ExitCode = 0;
            BDServiceLogger.LogEvent(LoggingLevel.Information, "BDService stopped at {0}", DateTime.Now);
        }

        protected override void OnPause()
        {
            if ((_deploymentThread != null) &&
                (_deploymentThread.IsAlive) &&
                ((_deploymentThread.ThreadState &
                (System.Threading.ThreadState.Suspended | System.Threading.ThreadState.SuspendRequested)) == 0))
            {
                // Reset the event, which will cause the worker thread to block on the WaitOne call
                _paused = true;
                _pause.Reset();
            }
        }

        protected override void OnContinue()
        {
            if ((_deploymentThread != null) &&
                (_deploymentThread.IsAlive) &&
                ((_deploymentThread.ThreadState &
                (System.Threading.ThreadState.Suspended | System.Threading.ThreadState.SuspendRequested)) == 0))
            {
                // Set the event, which will cause the worker thread to cruise through the WaitOne call
                _pause.Set();
                _paused = false;
            }
        }
        #endregion

        #region Main entry point
        static void Main(string[] args)
        {
            ServiceBase[] ServicesToRun;
            ServicesToRun = new ServiceBase[] 
			{ 
				new BDService() 
			};
            ServiceBase.Run(ServicesToRun);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentParameter.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class DeploymentParameter
    {
        public string Name { get; set; }
        public string Value { get; set; }
        public RunCondition Condition { get; set; }

        public DeploymentParameter() { }
        public DeploymentParameter(string name, string value)
        {
            Name = name;
            Value = value;
            Condition = RunCondition.Always;
        }
        public DeploymentParameter(string name, string value, RunCondition condition)
        {
            Name = name;
            Value = value;
            Condition = condition;
        }
        public DeploymentParameter(DeploymentParameter obj)
        {
            if (null == obj)
                throw new ArgumentNullException();
            Name = obj.Name;
            Value = obj.Value;
            Condition = obj.Condition;
        }

        public static DeploymentParameter Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            DeploymentParameter param = new DeploymentParameter();
            if (node.Name == "Parameter")
            {
                param.Name = node.GetAttribute("Name", node.NamespaceURI);
                param.Value = node.GetAttribute("Value", node.NamespaceURI);
            }
            else if (node.Name == "Parameters")
            {
                param.Name = Parameter.ParameterBlock;
                param.Value = node.OuterXml;
            }

            string conditionAttr = node.GetAttribute("Condition", node.NamespaceURI);
            if (!String.IsNullOrEmpty(conditionAttr))
            {
                param.Condition = (RunCondition)Enum.Parse(typeof(RunCondition), conditionAttr);
                if (RunCondition.Inherit == param.Condition)
                {
                    throw new ApplicationException(String.Format(
                        "The '{0}' parameter has an invalid Condition of 'Inherit'. This will be set to 'Always'.", param.Name));
                }
            }
            else
            {
                param.Condition = RunCondition.Always;
            }

            return param;
        }

        public void Create(Int64 taskId, ParameterTokens.TokenValue[] tokenReplacers)
        {
            if (taskId < 1)
                throw new ArgumentException("Invalid task Id provided to the DeploymentParameter::Create method.");

            using (SqlConnection conn = new SqlConnection(DbAccess.ConnectString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_task_add_parameter";
                    cmd.Parameters.AddWithValue("@taskId", taskId);
                    cmd.Parameters.AddWithValue("@parameterName", Name);
                    cmd.Parameters.AddWithValue("@parameterValue", ParameterTokens.ReplaceTokens(Value, tokenReplacers));
                    cmd.Parameters.AddWithValue("@condition", (byte)Condition);
                    cmd.ExecuteNonQuery();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentJobReport.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class DeploymentJobReport
    {
        public string ToList { get; set; }
        public string CcList { get; set; }
        public string BccList { get; set; }
        public string XsltName { get; set; }
        public RunCondition Condition { get; set; }
        public byte HistoryMaxDays { get; set; }
        public byte HistoryMaxJobs { get; set; }

        public DeploymentJobReport() { }
        public DeploymentJobReport(DeploymentJobReport obj)
        {
            if (null == obj)
                throw new ArgumentNullException();
            ToList = obj.ToList;
            CcList = obj.CcList;
            BccList = obj.BccList;
            XsltName = obj.XsltName;
            Condition = obj.Condition;
            HistoryMaxDays = obj.HistoryMaxDays;
            HistoryMaxJobs = obj.HistoryMaxJobs;
        }

        public static DeploymentJobReport Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            DeploymentJobReport djr = new DeploymentJobReport();
            string attr;

            djr.ToList = node.GetAttribute("ToList", node.NamespaceURI);
            djr.CcList = node.GetAttribute("CCList", node.NamespaceURI);
            djr.BccList = node.GetAttribute("BCCList", node.NamespaceURI);
            djr.XsltName = node.GetAttribute("XsltName", node.NamespaceURI);
            attr = node.GetAttribute("Condition", node.NamespaceURI);
            if (attr.Length > 0)
                djr.Condition = (RunCondition)Enum.Parse(typeof(RunCondition), attr);
            else
                djr.Condition = RunCondition.Always;

            if (RunCondition.Inherit == djr.Condition)
            {
                throw new ApplicationException("'Inherit' is not a valid value for the Condition attribut of the Report element.");
            }

            if (node.HasChildren)
            {
                XPathNavigator historyNode = node.SelectSingleNode("JobHistory");
                djr.HistoryMaxDays = byte.Parse(historyNode.GetAttribute("MaxDays", historyNode.NamespaceURI));
                djr.HistoryMaxJobs = byte.Parse(historyNode.GetAttribute("MaxJobs", historyNode.NamespaceURI));
            }

            return djr;
        }

        public void Create(Int64 jobId)
        {
            if (jobId < 1)
                throw new ArgumentException("Invalid job Id provided to the DeploymentJobReport::Create method.");

            using (SqlConnection conn = new SqlConnection(DbAccess.ConnectString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_create_report";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.Parameters.AddWithValue("@toList", ToList);
                    if (CcList.Length > 0)
                        cmd.Parameters.AddWithValue("@ccList", CcList);
                    if (BccList.Length > 0)
                        cmd.Parameters.AddWithValue("@bccList", BccList);
                    if (XsltName.Length > 0)
                        cmd.Parameters.AddWithValue("@xsltName", XsltName);
                    cmd.Parameters.AddWithValue("@condition", (byte)Condition);
                    if (HistoryMaxDays > 0)
                        cmd.Parameters.AddWithValue("@historyMaxDays", HistoryMaxDays);
                    if (HistoryMaxJobs > 0)
                        cmd.Parameters.AddWithValue("@historyMaxJobs", HistoryMaxJobs);
                    cmd.Parameters.Add("@reportId", SqlDbType.BigInt).Direction = ParameterDirection.Output;
                    cmd.ExecuteNonQuery();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentJobSchedule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace xonline.test.deployment.automation.bdservice
{
    public enum Rate : short
    {
        QuarterHourly = 0,
        Hourly,
        Daily,
        Weekly,
        Monthly
    }

    public enum TriggerUse : short
    {
        Either = 0,
        NameOnly,
        ContentOnly
    }

    [Flags]
    public enum Weekday : short
    {
        None = 0x00,
        Sunday = 0x01,
        Monday = 0x02,
        Tuesday = 0x04,
        Wednesday = 0x08,
        Thursday = 0x10,
        Friday = 0x20,
        Saturday = 0x40,
        Weekdays = (Sunday | Monday | Tuesday | Wednesday | Thursday | Friday)
    }

    public class DeploymentJobSchedule
    {
        public Rate RunRate { get; set; }
        public short Frequency { get; set; }
        public Weekday Weekdays { get; set; }
        public short WeekdayFrequency { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public TriggerPrecondition Trigger { get; set; }
        public CustomPrecondition CustomPrecondition { get; set; }

        public DeploymentJobSchedule()
        {
            Trigger = null;
            CustomPrecondition = null;
        }
        public DeploymentJobSchedule(DeploymentJobSchedule obj)
        {
            RunRate = obj.RunRate;
            Frequency = obj.Frequency;
            Weekdays = obj.Weekdays;
            WeekdayFrequency = obj.WeekdayFrequency;
            StartTime = obj.StartTime;
            EndTime = obj.EndTime;
            if (obj.Trigger != null)
                Trigger = new TriggerPrecondition(obj.Trigger);
            if (obj.CustomPrecondition != null)
                CustomPrecondition = new CustomPrecondition(obj.CustomPrecondition);
        }

        public static DeploymentJobSchedule parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            DeploymentJobSchedule schedule = new DeploymentJobSchedule();

            string attr = node.GetAttribute("Rate", node.NamespaceURI);
            schedule.RunRate = (Rate)Enum.Parse(typeof(Rate), attr, true);
            attr = node.GetAttribute("Frequency", node.NamespaceURI);
            if (!String.IsNullOrEmpty(attr))
                schedule.Frequency = Int16.Parse(attr);
            schedule.Weekdays = Weekday.None;
            attr = node.GetAttribute("Weekdays", node.NamespaceURI);
            if (!String.IsNullOrEmpty(attr))
            {
                // Parse the list of weekdays into their corresponding enum values
                string[] weekdays = attr.Split(',');
                for (int i = 0; i < weekdays.Length; i++)
                {
                    Weekday val = (Weekday)Enum.Parse(typeof(Weekday), weekdays[i], true);
                    schedule.Weekdays |= val;
                }
            }
            attr = node.GetAttribute("WeekdayFrequency", node.NamespaceURI);
            if (!String.IsNullOrEmpty(attr))
                schedule.WeekdayFrequency = Int16.Parse(attr);
            schedule.StartTime = DateTime.Parse(node.GetAttribute("StartTime", node.NamespaceURI));
            attr = node.GetAttribute("EndTime", node.NamespaceURI);
            if (!String.IsNullOrEmpty(attr))
                schedule.EndTime = DateTime.Parse(attr);

            // The Schedule element may have either a Trigger child element or a Custom child element
            // This child element defines any other precondition steps that must be taken before the
            // job is scheduled. The Trigger precondition is supported natively and compares the
            // specified trigger file to the version of the latest successful run of this job.
            // The Custom precondition indicates that a dll has been supplied that provides a method
            // used to determine whether or not the job should be scheduled.
            node = node.SelectSingleNode("*");
            if (node != null)
            {
                if (node.Name == "Trigger")
                {
                    schedule.Trigger = TriggerPrecondition.Parse(node);
                    schedule.CustomPrecondition = null;
                }
                else if (node.Name == "Custom")
                {
                    schedule.CustomPrecondition = CustomPrecondition.Parse(node);
                    schedule.Trigger = null;
                }
            }

            return schedule;
        }
    }

    public class TriggerPrecondition
    {
        public string FileSpec { get; set; }
        public TriggerUse Usage { get; set; }
        public bool IsRemote { get; set; }

        public TriggerPrecondition() { }
        public TriggerPrecondition(TriggerPrecondition obj)
        {
            if (null == obj)
                throw new ArgumentNullException();
            FileSpec = obj.FileSpec;
            IsRemote = obj.IsRemote;
            Usage = obj.Usage;
        }

        public static TriggerPrecondition Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            TriggerPrecondition tp = new TriggerPrecondition();

            tp.FileSpec = node.GetAttribute("FileSpec", node.NamespaceURI);
            tp.IsRemote = Boolean.Parse(node.GetAttribute("IsRemote", node.NamespaceURI));
            tp.Usage = (TriggerUse)Enum.Parse(typeof(TriggerUse), node.GetAttribute("TriggerUse", node.NamespaceURI), true);

            return tp;
        }
    }

    public class CustomPrecondition
    {
        public string Module { get; set; }
        public string Parameter { get; set; }

        public CustomPrecondition() { }
        public CustomPrecondition(CustomPrecondition obj)
        {
            Module = obj.Module;
            Parameter = obj.Parameter;
        }

        public static CustomPrecondition Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            CustomPrecondition cp = new CustomPrecondition();

            cp.Module = node.GetAttribute("Module", node.NamespaceURI);
            cp.Parameter = node.GetAttribute("Parameter", node.NamespaceURI);

            return cp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentTask.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class DeploymentTask
    {
        public string Name { get; set; }
        public string Module { get; set; }
        public TaskType Type { get; set; }
        public RunCondition Condition { get; set; }
        public List<DeploymentParameter> Parameters { get; set; }
        public string LogTarget { get; set; }

        #region c'tor

        public DeploymentTask()
        {
            Parameters = new List<DeploymentParameter>();
        }
        public DeploymentTask(DeploymentTask obj)
        {
            if (null == obj)
                throw new ArgumentNullException();
            Name = obj.Name;
            Module = obj.Module;
            Type = obj.Type;
            Condition = obj.Condition;
            Parameters = new List<DeploymentParameter>(obj.Parameters);
            LogTarget = obj.LogTarget;
        }

        #endregion

        public static DeploymentTask Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            string attrib;
            DeploymentTask task = new DeploymentTask();
            if (node.Name == "Wait")
            {
                int waitSeconds;
                task.Name = "Wait";
                task.Module = "";
                task.Type = TaskType.Local;
                task.Condition = RunCondition.Always;
                attrib = node.GetAttribute("WaitSeconds", node.NamespaceURI);
                if (Int32.TryParse(attrib, out waitSeconds))
                    task.Parameters.Add(new DeploymentParameter("WaitSeconds", attrib));
                else
                    throw new ApplicationException("Invalid Wait element.");
            }
            else if (node.Name == "Task")
            {
                task.Name = node.GetAttribute("Name", node.NamespaceURI);
                task.Module = node.GetAttribute("Module", node.NamespaceURI);
                task.Type = (TaskType)Enum.Parse(typeof(TaskType), node.GetAttribute("Type", node.NamespaceURI), true);
                task.LogTarget = node.GetAttribute("LocalLogTarget", node.NamespaceURI);
                attrib = node.GetAttribute("Condition", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attrib))
                    task.Condition = (RunCondition)Enum.Parse(typeof(RunCondition), attrib);
                else
                    task.Condition = RunCondition.Inherit;

                // Look for a 'Parameters' block first
                XPathNodeIterator itor = node.Select("Parameters");
                if (itor.Count > 0)
                {
                    if (itor.MoveNext())
                    {
                        task.Parameters.Add(DeploymentParameter.Parse(itor.Current));
                    }
                }
                else
                {
                    itor = node.Select("Parameter");
                    while (itor.MoveNext())
                    {
                        DeploymentParameter param = DeploymentParameter.Parse(itor.Current);
                        task.Parameters.Add(param);
                    }
                }
            }
            else
                task = null;

            return task;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is DeploymentTask)
                return ((obj as DeploymentTask).Name == Name);
            else if (obj is string)
                return ((obj as string) == Name);

            return false;
        }

        public void Create(Int64 jobId, Int64 groupId, ParameterTokens.TokenValue[] tokenReplacers)
        {
            if (jobId < 1)
                throw new ArgumentException("Invalid job Id provided to the DeploymentTask::Create method.");

            Int64 taskId = 0;

            using (SqlConnection conn = new SqlConnection(DbAccess.ConnectString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_add_task";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.Parameters.AddWithValue("@groupId", groupId);
                    cmd.Parameters.AddWithValue("@taskName", Name);
                    cmd.Parameters.AddWithValue("@module", Module);
                    cmd.Parameters.AddWithValue("@taskType", Type);
                    cmd.Parameters.AddWithValue("@condition", Condition);
                    cmd.Parameters.AddWithValue("@localLogTarget", ParameterTokens.ReplaceTokens(LogTarget, tokenReplacers));
                    cmd.Parameters.Add("@taskid", SqlDbType.BigInt).Direction = ParameterDirection.Output;
                    cmd.ExecuteNonQuery();
                    taskId = (Int64)cmd.Parameters["@taskid"].Value;
                    if (0 == taskId)
                        throw new ApplicationException("Task creation returned an invalid task Id.");

                    // Add all parameters defined for this task
                    foreach (DeploymentParameter param in Parameters)
                    {
                        param.Create(taskId, tokenReplacers);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentJob.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using Microsoft.Win32;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class DeploymentJob
    {
        private const string REGISTRY_PATH = "SYSTEM\\CurrentControlSet\\Services\\BDService\\Jobs";

        public long Id { get; set; }  // This is not specified in the XML, but set when the job is created.
        public string Owner { get; set; }
        public string Name { get; set; }
        public string EnvName { get; set; }
        public string Build { get; set; }
        public string Version { get; set; }
        public string LogBase { get; set; }
        public JobType Type { get; set; }
        public JobPriority Priority { get; set; }
        public bool Enabled { get; set; }
        public DeploymentJobSchedule Schedule { get; set; }
        public DeploymentJobReport Report { get; set; }
        public List<object> Tasks { get; set; }

        public DeploymentJob() { }
        public DeploymentJob(DeploymentJob obj)
        {
            if (null == obj)
                throw new ArgumentNullException();
            Id = obj.Id;
            Owner = obj.Owner;
            Name = obj.Name;
            EnvName = obj.EnvName;
            Build = obj.Build;
            Version = obj.Version;
            LogBase = obj.LogBase;
            Type = obj.Type;
            Priority = obj.Priority;
            Enabled = obj.Enabled;
            Report = obj.Report;
            Tasks = new List<object>(obj.Tasks);
        }

        public static DeploymentJob Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            DeploymentJob job = new DeploymentJob();

            job.Name = node.GetAttribute("Name", node.NamespaceURI);
            job.EnvName = node.GetAttribute("Environment", node.NamespaceURI);
            job.LogBase = node.GetAttribute("LogBase", node.NamespaceURI);
            job.Priority = (JobPriority)Enum.Parse(typeof(JobPriority), node.GetAttribute("Priority", node.NamespaceURI), true);
            job.Type = (JobType)Enum.Parse(typeof(JobType), node.GetAttribute("Type", node.NamespaceURI), true);
            job.Build = node.GetAttribute("Build", node.NamespaceURI);
            job.Enabled = Boolean.Parse(node.GetAttribute("Enabled", node.NamespaceURI));
            job.Owner = node.GetAttribute("Owner", node.NamespaceURI);
            if (String.IsNullOrEmpty(job.Owner))
                job.Owner = Environment.UserName;

            // Process the Schedule element
            XPathNavigator schedNode = node.SelectSingleNode("Schedule");
            job.Schedule = DeploymentJobSchedule.parse(schedNode);

            // Process the Report element
            XPathNavigator reportNode = node.SelectSingleNode("Report");
            if (reportNode != null)
            {
                job.Report = DeploymentJobReport.Parse(reportNode);
            }
            else
            {
                job.Report = null;
            }

            // Process the tasks and task groups.
            // All tasks must belong to a group. If a group is not explicitely defined,
            // the tasks are put into a default group
            job.Tasks = new List<object>();
            XPathNodeIterator itor = node.SelectChildren(XPathNodeType.Element);
            while (itor.MoveNext())
            {
                if (String.Compare("TaskGroup", itor.Current.Name, true) == 0)
                {
                    DeploymentTaskGroup group = DeploymentTaskGroup.Parse(itor.Current);
                    job.Tasks.Add(group);
                }
                else
                {
                    DeploymentTask task = DeploymentTask.Parse(itor.Current);
                    if (null != task)
                        job.Tasks.Add(task);
                }
            }

            return job;
        }

        public DateTime GetLastRunDate()
        {
            DateTime lastRun = DateTime.MinValue;
            string jobKeyName = String.Format("{0}\\[{1}][{2}]{3}", REGISTRY_PATH, EnvName, Build, Name);

            RegistryKey rk = Registry.LocalMachine.OpenSubKey(jobKeyName);
            if (rk != null)
            {
                string val = rk.GetValue("LastRunDate") as string;
                DateTime.TryParse(val, out lastRun);
            }

            return lastRun;
        }

        public void SetLastRunDate()
        {
            string jobKeyName = String.Format("{0}\\[{1}][{2}]{3}", REGISTRY_PATH, EnvName, Build, Name);
            RegistryKey rk = Registry.LocalMachine.CreateSubKey(jobKeyName, RegistryKeyPermissionCheck.ReadWriteSubTree);
            if (rk != null)
            {
                // We don't care about the seconds or milliseconds
                rk.SetValue("LastRunDate", DateTime.Now.ToString("MM/dd/yyyy HH:mm"));
            }
        }

        public Int64 Create() { return CreateInternal(false, null); }
        public Int64 Create(ParameterTokens.TokenValue[] tokenReplacers) { return CreateInternal(false, tokenReplacers); }

        public Int64 CreatePrivate() { return CreateInternal(true, null); }
        public Int64 CreatePrivate(ParameterTokens.TokenValue[] tokenReplacers) { return CreateInternal(true, tokenReplacers); }
        
        private Int64 CreateInternal(bool privateJob, ParameterTokens.TokenValue[] tokenReplacers)
        {
            using (SqlConnection conn = new SqlConnection(DbAccess.ConnectString))
            {
                conn.Open();

                // Create the job in the database
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    if (privateJob)
                    {
                        cmd.CommandText = "p_job_create_private_job";
                    }
                    else
                    {
                        cmd.CommandText = "p_job_create_job_2";
                        cmd.Parameters.AddWithValue("@version", Version);
                    }
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@jobName", Name);
                    cmd.Parameters.AddWithValue("@envName", EnvName);
                    cmd.Parameters.AddWithValue("@buildName", Build);
                    cmd.Parameters.AddWithValue("@userName", Owner);
                    cmd.Parameters.AddWithValue("@jobType", (byte)Type);
                    cmd.Parameters.AddWithValue("@priority", (byte)Priority);
                    if (!String.IsNullOrEmpty(LogBase))
                        cmd.Parameters.AddWithValue("@logBase", LogBase);
                    cmd.Parameters.Add("@jobId", SqlDbType.BigInt);
                    cmd.Parameters["@jobId"].Direction = ParameterDirection.Output;
                    cmd.ExecuteNonQuery();
                    Id = (long)cmd.Parameters["@jobId"].Value;
                }

                if (Id > 0)
                {
                    // If there is a Report definition, add that to the database
                    if (Report != null)
                    {
                        Report.Create(Id);
                    }

                    // Add the task groups and tasks
                    foreach (object obj in Tasks)
                    {
                        if (obj is DeploymentTaskGroup)
                        {
                            (obj as DeploymentTaskGroup).Create(Id, tokenReplacers);
                        }
                        else if (obj is DeploymentTask)
                        {
                            (obj as DeploymentTask).Create(Id, 0, tokenReplacers);
                        }
                    }
                }
            }

            return Id;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is DeploymentJob)
                return ((obj as DeploymentJob).Name == Name);
            else if (obj is string)
                return ((obj as string) == Name);

            return false;
        }

        public string GetJobTokenValue(string token)
        {
            string tokenValue = null;
            switch (token)
            {
                case ParameterTokens.ParamTokenBuildName:
                    tokenValue = Build;
                    break;
                case ParameterTokens.ParamTokenBuildVersion:
                    tokenValue = Version;
                    break;
                case ParameterTokens.ParamTokenEnvironment:
                    tokenValue = EnvName;
                    break;
                case ParameterTokens.ParamTokenJobId:
                    tokenValue = Id.ToString();
                    break;
                case ParameterTokens.ParamTokenJobType:
                    tokenValue = Type.ToString();
                    break;
                case ParameterTokens.ParamTokenJobOwner:
                    tokenValue = Owner;
                    break;
                case ParameterTokens.ParamTokenJobName:
                    tokenValue = Name;
                    break;
                case ParameterTokens.ParamTokenJobLogBase:
                    tokenValue = LogBase;
                    break;
            }
            return tokenValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentInfo.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace xonline.test.deployment.automation.bdservice
{
    internal class DeploymentInfo
    {
        private DeploymentJobCollection _jobs;

        public DeploymentInfo()
        {
            _jobs = new DeploymentJobCollection();
        }
        public DeploymentInfo(DeploymentInfo obj) : this()
        {
            if (null == obj)
                throw new ArgumentNullException();
            obj._jobs.Clone(_jobs);
        }

        public DeploymentJobCollection Jobs
        {
            get { return _jobs; }
        }

        public void Parse(XPathNavigator deploymentNode)
        {
            if (null == deploymentNode)
                throw new ArgumentNullException();
            if (deploymentNode.Name != "Deployment")
                throw new BuildInfoException("Invalid Deployment element - the element name is incorrect.");

            // Process the deployment tasks
            XPathNavigator node = deploymentNode.SelectSingleNode("child::Jobs");
            if (null == node)
            {
                throw new BuildInfoException("Invalid Deployment element - no Jobs are defined.");
            }
            _jobs.Parse(node);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\DeploymentTaskGroup.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class DeploymentTaskGroup
    {
        public string Name { get; set; }
        public bool Rollup { get; set; }
        public RunCondition Condition { get; set; }
        public List<DeploymentTask> Tasks { get; set; }

        #region c'tor

        public DeploymentTaskGroup()
        {
            Tasks = new List<DeploymentTask>();
        }

        public DeploymentTaskGroup(DeploymentTaskGroup obj)
        {
            if (null == obj)
                throw new ArgumentNullException();
            Name = obj.Name;
            Rollup = obj.Rollup;
            Condition = obj.Condition;
            Tasks = new List<DeploymentTask>(obj.Tasks);
        }

        #endregion

        public static DeploymentTaskGroup Parse(XPathNavigator node)
        {
            if (null == node)
                throw new ArgumentNullException();

            string attrib;
            DeploymentTaskGroup group = new DeploymentTaskGroup();
            group.Name = node.GetAttribute("Name", node.NamespaceURI);
            attrib = node.GetAttribute("Rollup", node.NamespaceURI);
            if (!String.IsNullOrEmpty(attrib))
                group.Rollup = Convert.ToBoolean(attrib);
            else
                group.Rollup = false;
            attrib = node.GetAttribute("Condition", node.NamespaceURI);
            if (!String.IsNullOrEmpty(attrib))
                group.Condition = (RunCondition)Enum.Parse(typeof(RunCondition), attrib, true);
            else
                group.Condition = RunCondition.Inherit;

            XPathNodeIterator itor = node.SelectChildren(XPathNodeType.Element);
            while (itor.MoveNext())
            {
                DeploymentTask task = DeploymentTask.Parse(itor.Current);
                group.Tasks.Add(task);
            }

            return group;
        }

        public void Create(Int64 jobId, ParameterTokens.TokenValue[] tokenReplacers)
        {
            if (jobId < 1)
                throw new ArgumentException("Invalid job Id provided to the DeploymentTaskGroup::Create method.");

            Int64 groupId = 0;

            using (SqlConnection conn = new SqlConnection(DbAccess.ConnectString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_add_task_group";
                    cmd.Parameters.AddWithValue("@jobId", jobId);
                    cmd.Parameters.AddWithValue("@groupName", Name);
                    cmd.Parameters.AddWithValue("@rollup", Rollup);
                    cmd.Parameters.AddWithValue("@condition", (byte)Condition);
                    cmd.Parameters.Add("@groupId", SqlDbType.BigInt).Direction = ParameterDirection.Output;
                    cmd.ExecuteNonQuery();
                    groupId = (Int64)cmd.Parameters["@groupId"].Value;
                    if (0 == groupId)
                        throw new ApplicationException("Task Group creation returned an invalid group Id.");
                }
            }

            // Add the tasks
            foreach (DeploymentTask task in Tasks)
            {
                task.Create(jobId, groupId, tokenReplacers);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\ITaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// Required interface implemented by all task modules, in addition to any required attributes
    /// </summary>
    public interface ITaskModule
    {
        /// <summary>
        /// Gets information describing the task module, including task name and parameters
        /// </summary>
        TaskModuleInfo Info
        {
            get;
        }

        /// <summary>
        /// Adds a parameter to the task for consideration for execution. The
        /// parameter name might be one of the ones listed in the Info property, but 
        /// this is not required.
        /// 
        /// Resubmitting the same parameter name multiple times yields undefined behavior.
        /// Many tasks will use the last value associated with a given parameter, but this is
        /// not required.
        /// </summary>
        /// <param name="parameterName"></param>
        /// <param name="value"></param>
        void AddParameter(string parameterName, string value);

        /// <summary>
        /// Adds parameters to the task module as a well-formed XML block. The paramter block
        /// must be surrounded by the Parameters element:
        /// 
        ///     <Paramters>
        ///         <Task Module defined parameter block>
        ///     </Paramters>
        ///
        /// </summary>
        /// <param name="xmlParameterBlock"></param>
        void AddParameters(string xmlParameterBlock);
        
        /// <summary>
        /// Removes all the parameters from a given task object. Task modules that don't implement
        /// this should throw an InvalidOperationException.
        /// </summary>
        void RemoveAllParameters();

        /// <summary>
        /// Causes the task to execute with the parameters previously set by AddParameter.
        /// </summary>
        /// <returns>The status resulting from executing the task, plus any logs.</returns>
        TaskResult Perform();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\FileUtils.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace xonline.test.deployment.automation.common
{
	public static class FileUtils
	{
        public static void CreatePath(string path)
        {
            if (String.IsNullOrEmpty(path))
                throw new ArgumentException("Invalid path - cannot be null or empty.");

            string[] parts = path.Split(Path.DirectorySeparatorChar);
            bool isUNC = path.StartsWith("\\\\");
            int i = 0;
            StringBuilder tmpPath = new StringBuilder();

            if (isUNC)
            {
                tmpPath.Append(@"\\" + parts[2]);
                i = 3;
            }
            else
            {
                tmpPath.Append(parts[0]);
                i = 1;
            }

            try
            {
                for (; i < parts.Length; i++)
                {
                    tmpPath.Append(@"\" + parts[i]);
                    if (!Directory.Exists(tmpPath.ToString()))
                    {
                        Directory.CreateDirectory(tmpPath.ToString());
                    }
                }
            }
            catch (Exception ex)
            {
                throw new ApplicationException(String.Format("Unable to create part of the destination path '{0}'", tmpPath), ex);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\DeploymentTaskModuleAttribute.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// Required attribute for Task Modules
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface , AllowMultiple=false, Inherited=false)]
    public class DeploymentTaskModuleAttribute : Attribute
    {

        /// <summary>
        /// The name of the task module. This must be unique.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Denotes a task module
        /// </summary>
        /// <param name="name">The name of the task module. This must be unique.</param>
        public DeploymentTaskModuleAttribute(string name)
        {
            Name = name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\EnvironmentInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.bdservice
{
    public class EnvironmentInfo
    {
        public long Id { get; set; }
        public string Name { get; set; }
        public string StagerName { get; set; }
        public string BuildShare { get; set; }
        public string TitlesShare { get; set; }
        public string UserName { get; set; }
        public bool Locked { get; set; }
        public bool Virtual { get; set; }
        public bool DNSFlipped { get; set; }
        public bool Active { get; set; }
        public string HostList { get; set; }
        public string ServerPrefix { get; set; }
        public string ClientPoolIpBegin { get; set; }
        public string ClientPoolIpEnd { get; set; }
        public string SGAdminIp { get; set; }
        public string INHInternetIp { get; set; }
        public string SGInternetIp { get; set; }
        public string XDSInternetIp { get; set; }
        public string ClientPoolNetmask { get; set; }
        public string ClientPoolGateway { get; set; }
        public string InternetNetmask { get; set; }
        public string InternetGateway { get; set; }
        public string[] SubEnvironments { get; set; }
        public Dictionary<string, List<EnvironmentServer>> Servers { get; set; }
        public List<EnvironmentPassword> Passwords { get; set; }

        public static EnvironmentInfo Load(string envName)
        {
            EnvironmentInfo env = null;

            using (SqlConnection conn = new SqlConnection(DbAccess.ConnectString))
            {
                conn.Open();
                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "p_env_get_environment";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@envName", envName);
                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            env = new EnvironmentInfo();
                            env.Id = (Int64)reader["i_env_id"];
                            env.Name = reader["vc_environment_name"] as string;
                            env.StagerName = reader["vc_stager_name"] as string;
                            env.BuildShare = reader["vc_build_share"] as string;
                            env.TitlesShare = reader["vc_titles_share"] as string;
                            env.UserName = reader["vc_user_name"] as string;
                            env.Locked = (Boolean)reader["b_locked"];
                            env.Virtual = (Boolean)reader["b_is_virtual"];
                            env.DNSFlipped = (Boolean)reader["b_is_dns_flipped"];
                            env.HostList = reader["vc_hostList"] as string;
                            env.ServerPrefix = reader["vc_machine_prefix"] as string;
                            env.ClientPoolIpBegin = reader["vc_clientpool_ip_begin"] as string;
                            env.ClientPoolIpEnd = reader["vc_clientpool_ip_end"] as string;
                            env.ClientPoolNetmask = reader["vc_clientpool_netmask"] as string;
                            env.ClientPoolGateway = reader["vc_clientpool_gateway"] as string;
                            env.INHInternetIp = reader["vc_inh_internet_ip"] as string;
                            env.SGAdminIp = reader["vc_sg_admin_ip"] as string;
                            env.SGInternetIp = reader["vc_sg_internet_ip"] as string;
                            env.XDSInternetIp = reader["vc_xds_internet_ip"] as string;
                            env.InternetNetmask = reader["vc_internet_netmask"] as string;
                            env.InternetGateway = reader["vc_internet_gateway"] as string;
                        }
                    }

                    // Get the passwords
                    env.Passwords = new List<EnvironmentPassword>();
                    cmd.CommandText = "p_env_get_passwords";
                    cmd.Parameters.Clear();
                    cmd.Parameters.AddWithValue("@envId", env.Id);
                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            EnvironmentPassword pwd = new EnvironmentPassword();
                            pwd.Password = reader["vc_password"] as string;
                            pwd.ContextServer = reader["vc_context_server"] as string;
                            pwd.IsEncrypted = (Boolean)reader["b_encrypted"];
                            pwd.Type = (PasswordType)reader["ti_type"];
                            env.Passwords.Add(pwd);
                        }
                    }

                    // Get the server list
                    env.Servers = new Dictionary<string, List<EnvironmentServer>>();
                    cmd.CommandText = "p_env_get_server_list";
                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            EnvironmentServer svr = new EnvironmentServer();
                            svr.Id = (Int64)reader["i_server_id"];
                            svr.Role = reader["vc_server_role"] as string;
                            svr.Name = reader["vc_server_name"] as string;
                            svr.Ip = reader["vc_ip"] as string;
                            if (!env.Servers.ContainsKey(svr.Role))
                                env.Servers.Add(svr.Role, new List<EnvironmentServer>());
                            env.Servers[svr.Role].Add(svr);
                        }
                    }
                }
            }

            return env;
        }

        public string GetEnvTokenValue(string token)
        {
            string tokenValue = null;
            switch (token)
            {
                case ParameterTokens.ParamTokenEnvironment:
                    tokenValue = Name;
                    break;
                case ParameterTokens.ParamTokenStagerName:
                    tokenValue = StagerName;
                    break;
                case ParameterTokens.ParamTokenStagerBuildShare:
                    tokenValue = BuildShare;
                    break;
                case ParameterTokens.ParamTokenStagerTitleShare:
                    tokenValue = TitlesShare;
                    break;
                case ParameterTokens.ParamTokenEnvUserName:
                    tokenValue = UserName;
                    break;
                case ParameterTokens.ParamTokenLocalPassword:
                case ParameterTokens.ParamTokenLocalPasswordEncrypted:
                    foreach (EnvironmentPassword pwd in Passwords)
                    {
                        if (pwd.Type == PasswordType.Local)
                        {
                            if (token == ParameterTokens.ParamTokenLocalPassword)
                                tokenValue = pwd.Password;
                            else
                                tokenValue = pwd.IsEncrypted.ToString().ToLower();
                        }
                    }
                    break;
                case ParameterTokens.ParamTokenRemotePassword:
                case ParameterTokens.ParamTokenRemotePasswordEncrypted:
                    foreach (EnvironmentPassword pwd in Passwords)
                    {
                        if (pwd.Type == PasswordType.Remote)
                        {
                            if (token == ParameterTokens.ParamTokenRemotePassword)
                                tokenValue = pwd.Password;
                            else
                                tokenValue = pwd.IsEncrypted.ToString().ToLower();
                        }
                    }
                    break;
                case ParameterTokens.ParamTokenEnvHostList:
                    tokenValue = HostList;
                    break;
                case ParameterTokens.ParamTokenEnvAllSQL1:
                case ParameterTokens.ParamTokenEnvAllSQL2:
                case ParameterTokens.ParamTokenEnvMstrSQL:
                case ParameterTokens.ParamTokenEnvCatrSQL:
                case ParameterTokens.ParamTokenEnvInfrTLS:
                case ParameterTokens.ParamTokenEnvPoolIIS:
                case ParameterTokens.ParamTokenEnvPoolINH:
                case ParameterTokens.ParamTokenEnvSecuINH:
                    {
                        // We need to strip off the token delimiters as well as the 'Env' token prefix to get to the server role
                        string role = token.Substring(5, token.Length - 7);
                        if (Servers.ContainsKey(role) && Servers[role].Count > 0)
                        {
                            tokenValue = Servers[role][0].Name;
                        }
                    }
                    break;
                case ParameterTokens.ParamTokenEnvAllSQL1Ip:
                case ParameterTokens.ParamTokenEnvAllSQL2Ip:
                case ParameterTokens.ParamTokenEnvMstrSQLIp:
                case ParameterTokens.ParamTokenEnvCatrSQLIp:
                case ParameterTokens.ParamTokenEnvInfrTLSIp:
                case ParameterTokens.ParamTokenEnvPoolIISIp:
                case ParameterTokens.ParamTokenEnvPoolINHIp:
                case ParameterTokens.ParamTokenEnvSecuINHIp:
                    {
                        // We need to strip off the token delimiters as well as the 'Env' token prefix to get to the server role
                        string role = token.Substring(5, token.Length - 9);
                        if (Servers.ContainsKey(role) && Servers[role].Count > 0)
                        {
                            tokenValue = Servers[role][0].Ip;
                        }
                    }
                    break;
                case ParameterTokens.ParamTokenEnvAllServersList:
                    {
                        StringBuilder serverList = new StringBuilder();
                        foreach (KeyValuePair<string, List<EnvironmentServer>> kvp in Servers)
                        {
                            foreach (EnvironmentServer server in kvp.Value)
                                serverList.AppendFormat("{0},", server.Name);
                        }
                        if (serverList.Length > 0)
                            serverList.Length--;

                        tokenValue = serverList.ToString();
                    }
                    break;
                case ParameterTokens.ParamTokenEnvClientList:
                    if (Servers.ContainsKey("Client"))
                    {
                        StringBuilder clientList = new StringBuilder();
                        foreach (EnvironmentServer client in Servers["Client"])
                        {
                            clientList.Append(client.Name);
                            clientList.Append(",");
                        }
                        if (clientList.Length > 0)
                            clientList.Length--;

                        tokenValue = clientList.ToString();
                    }
                    break;
                case ParameterTokens.ParamTokenEnvClientPoolIpBegin:
                    tokenValue = ClientPoolIpBegin;
                    break;
                case ParameterTokens.ParamTokenEnvClientPoolIpEnd:
                    tokenValue = ClientPoolIpEnd;
                    break;
                case ParameterTokens.ParamTokenEnvClientPoolNetmask:
                    tokenValue = ClientPoolNetmask;
                    break;
                case ParameterTokens.ParamTokenEnvClientPoolGateway:
                    tokenValue = ClientPoolGateway;
                    break;
                case ParameterTokens.ParamTokenEnvServerPrefix:
                    tokenValue = ServerPrefix;
                    break;
                case ParameterTokens.ParamTokenEnvSGAdminIp:
                    tokenValue = SGAdminIp;
                    break;
                case ParameterTokens.ParamTokenEnvSGInternetIp:
                    tokenValue = SGInternetIp;
                    break;
                case ParameterTokens.ParamTokenEnvXDSInternetIp:
                    tokenValue = XDSInternetIp;
                    break;
                case ParameterTokens.ParamTokenEnvINHInternetIp:
                case ParameterTokens.ParamTokenEnvCatalogIp:
                    tokenValue = INHInternetIp;
                    break;
            }
            return tokenValue;
        }
    }

    public class EnvironmentPassword
    {
        public string Password { get; set; }
        public string ContextServer { get; set; }
        public PasswordType Type { get; set; }
        public bool IsEncrypted { get; set; }
    }

    public class EnvironmentServer
    {
        public long Id { get; set; }
        public string Name { get; set; }
        public string Role { get; set; }
        public string Ip { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\BDService\ParameterTokens.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.automation.bdservice
{
	public class ParameterTokens
	{
        // This is the list of replaceable parameter tokens understood by BDService
        public const string ParamTokenBuildName = "##BuildName##";
        public const string ParamTokenBuildPath = "##BuildPath##";
        public const string ParamTokenBuildType = "##BuildType##";
        public const string ParamTokenBuildVersion = "##BuildVersion##";
        public const string ParamTokenEnvironment = "##Environment##";
        public const string ParamTokenJobId = "##JobId##";
        public const string ParamTokenJobType = "##JobType##";
        public const string ParamTokenJobOwner = "##JobOwner##";
        public const string ParamTokenJobName = "##JobName##";
        public const string ParamTokenJobLogBase = "##LogBase##";
        public const string ParamTokenStagerName = "##StagerName##";
        public const string ParamTokenStagerBuildShare = "##StagerBuildShare##";
        public const string ParamTokenStagerTitleShare = "##StagerTitleShare##";
        public const string ParamTokenEnvUserName = "##EnvUserName##";
        public const string ParamTokenLocalPassword = "##LocalPassword##";
        public const string ParamTokenLocalPasswordEncrypted = "##LocalPasswordEncrypted##";
        public const string ParamTokenRemotePassword = "##RemotePassword##";
        public const string ParamTokenRemotePasswordEncrypted = "##RemotePasswordEncrypted##";
        public const string ParamTokenEnvHostList = "##EnvHostList##";
        public const string ParamTokenEnvClientList = "##EnvClientList##";
        public const string ParamTokenEnvServerPrefix = "##EnvServerPrefix##";
        public const string ParamTokenEnvAllSQL1 = "##EnvAllSQL1##";
        public const string ParamTokenEnvAllSQL1Ip = "##EnvAllSQL1Ip##";
        public const string ParamTokenEnvAllSQL2 = "##EnvAllSQL2##";
        public const string ParamTokenEnvAllSQL2Ip = "##EnvAllSQL2Ip##";
        public const string ParamTokenEnvCatrSQL = "##EnvCatrSQL##";
        public const string ParamTokenEnvCatrSQLIp = "##EnvCatrSQLIp##";
        public const string ParamTokenEnvMstrSQL = "##EnvMstrSQL##";
        public const string ParamTokenEnvMstrSQLIp = "##EnvMstrSQLIp##";
        public const string ParamTokenEnvPoolIIS = "##EnvPoolIIS##";
        public const string ParamTokenEnvPoolIISIp = "##EnvPoolIISIp##";
        public const string ParamTokenEnvPoolINH = "##EnvPoolINH##";
        public const string ParamTokenEnvPoolINHIp = "##EnvPoolINHIp##";
        public const string ParamTokenEnvSecuINH = "##EnvSecuINH##";
        public const string ParamTokenEnvSecuINHIp = "##EnvSecuINHIp##";
        public const string ParamTokenEnvSGAdminIp = "##EnvSGAdminIp##";
        public const string ParamTokenEnvInfrTLS = "##EnvInfrTLS##";
        public const string ParamTokenEnvInfrTLSIp = "##EnvInfrTLSIp##";
        public const string ParamTokenEnvAllServersList = "##EnvAllServersList##";
        public const string ParamTokenEnvClientPoolIpBegin = "##EnvClientPoolIpBegin##";
        public const string ParamTokenEnvClientPoolIpEnd = "##EnvClientPoolIpEnd##";
        public const string ParamTokenEnvINHInternetIp = "##EnvINHInternetIp##";
        public const string ParamTokenEnvSGInternetIp = "##EnvSGInternetIp##";
        public const string ParamTokenEnvXDSInternetIp = "##EnvXDSInternetIp##";
        public const string ParamTokenEnvClientPoolNetmask = "##EnvClientPoolNetmask##";
        public const string ParamTokenEnvClientPoolGateway = "##EnvClientPoolGateway##";
        public const string ParamTokenEnvInternetNetmask = "##EnvInternetNetmask##";
        public const string ParamTokenEnvInternetGateway = "##EnvInternetGateway##";
        public const string ParamTokenEnvCatalogIp = "##EnvCatalogIp##";

        public delegate string TokenValue(string tokenString);
        public static string ReplaceTokens(string tokenizedString, TokenValue[] tokenValueDelegates)
        {
            if (String.IsNullOrEmpty(tokenizedString) || null == tokenValueDelegates ||
                (null != tokenValueDelegates && 0 == tokenValueDelegates.Length))
                return tokenizedString;

            int tokenStart = 0;
            int tokenEnd = -1;
            int readIndex = 0;
            StringBuilder errors = new StringBuilder();
            StringBuilder finalString = new StringBuilder(tokenizedString.Length);

            tokenStart = tokenizedString.IndexOf("##", tokenEnd + 1);
            while (tokenStart < tokenizedString.Length && tokenStart > tokenEnd)
            {
                // Write the string up to the token
                finalString.Append(tokenizedString.Substring(readIndex, tokenStart - readIndex));

                // Find the end of the token
                tokenEnd = tokenizedString.IndexOf("##", tokenStart + 2);
                if (-1 == tokenEnd)
                {
                    // This token doesn't have a closing delimiter
                    // Note the error and move on
                    errors.AppendFormat("char pos {0}: No closing token delimiter found.\r\n", tokenStart + 1);
                    tokenEnd = tokenStart + 2;
                    readIndex = tokenStart;
                }
                else
                {
                    // Get the token and lookup its value (include the token delimiters)
                    string token = tokenizedString.Substring(tokenStart, tokenEnd - tokenStart + 2);
                    string tokenValue = null;
                    try
                    {
                        foreach (TokenValue tv in tokenValueDelegates)
                        {
                            tokenValue = tv(token);
                            if (tokenValue != null)
                                break;
                        }
                    }
                    catch (Exception ex)
                    {
                        errors.AppendFormat("char pos {0}: Token expansion failure for token '{1}': {2}\r\n", tokenStart + 1, token, ex.Message);
                    }

                    if (null == tokenValue)
                    {
                        // Unknown token - just write it to the output string
                        errors.AppendFormat("char pos {0}: Unknown token: {1}\r\n", tokenStart + 1, token);
                        tokenValue = token;
                    }

                    // Write the token's value to the output string and update the input indices
                    finalString.Append(tokenValue);
                    tokenEnd += 2;
                    readIndex = tokenEnd;
                }

                // Get the next token delimiter
                if (tokenEnd < tokenizedString.Length)
                    tokenStart = tokenizedString.IndexOf("##", tokenEnd);
                else
                    tokenStart = -1;
            }

            // Write out the remainder of the source string
            finalString.Append(tokenizedString.Substring(readIndex));
            return finalString.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\Common.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Pipes;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    public enum Result : byte
    {
        NotRun = 0,
        Succeeded,
        Failed,
        Cancelled,
        NonFatalFailure,
        Blocked,
        Skipped
    }

    public enum JobState : byte
    {
        NotReady = 0,
        Ready,
        Running,
        Paused,
        Complete,
        MaxJobState = Complete
    };

    public enum JobPriority : byte
    {
        Low = 0,
        Medium,
        High
    }

    public enum TaskState : byte
    {
        None = 0,
        Ready,
        Running,
        Complete
    }

    public enum JobType : byte
    {
        Other = 0,
        Deployment,
        LKGTesting,
        TestRun
    }

    public enum TaskType : byte
    {
        Local,
        Remote
    }

    public enum LoggingLevel
    {
        None = 0,
        Error = EventLogEntryType.Error,
        Warning = EventLogEntryType.Warning,
        Information = EventLogEntryType.Information,
        Debug = 5
    }

    public enum RunCondition : byte
    {
        Inherit = 0,
        Always,
        IfPassing,
        IfFailing
    }

    public enum PasswordType : byte
    {
        Local = 1,
        Remote
    }

    public static class DACommon
    {
        public const string AgentPipeName = @"\\.\Pipe\AgentPipe";
        public const string AgentHandShake = "The cake is a lie.";
        public const string AgentRemoteTask = "RemoteTask";
        public const string AgentRemoteCommand = "RemoteCommand";

        public static LoggingLevel LogLevel { get; set; }

        static DACommon()
        {
#if Debug
            LogLevel = LoggingLeve.Debug;
#else
            LogLevel = LoggingLevel.Information;
#endif
        }

        public static void LogEvent(LoggingLevel level, string msg, params object[] args)
        {
            LogEvent("Deployment Automation", level, msg, args);
        }

        public static void LogEvent(string eventSource, LoggingLevel level, string msg, params object[] args)
        {
            if (LogLevel == LoggingLevel.None)
                return;

            EventLogEntryType entryType;

            if (LoggingLevel.None == level || LoggingLevel.Debug == level)
                entryType = EventLogEntryType.Information;
            else
                entryType = (EventLogEntryType)(int)level;

            // Only write the entry if the appropriate logging level is set
            if ((int)LogLevel >= (int)level)
            {
                // Embed this call in a try...catch just so we don't crash while writing to the event log
                try
                {
                    EventLog.WriteEntry(eventSource, String.Format(msg, args), entryType, (int)level);
                }
                catch (Exception) { }
            }
        }

        public static RemoteCommandResponse RunRemoteCommand(string server, RemoteCommandArgs rca)
        {
            RemoteCommandResponse rcr = null;

            using (NamedPipeClientStream npStream = new NamedPipeClientStream(server, DACommon.AgentPipeName, PipeDirection.InOut,
                PipeOptions.WriteThrough, System.Security.Principal.TokenImpersonationLevel.Anonymous))
            {
                byte[] rwBuffer = new Byte[64];

                // The Connect timeout is expressed in milliseconds
                npStream.Connect((int)rca.TimeoutSeconds * 1000);
                if (npStream.IsConnected)
                {
                    // Send the target server as the client ID
                    try
                    {
                        rwBuffer = UnicodeEncoding.Unicode.GetBytes(server);
                        npStream.Write(rwBuffer, 0, rwBuffer.Length);
                        npStream.WaitForPipeDrain();
                    }
                    catch (Exception ex)
                    {
                        LogEvent(LoggingLevel.Error, "Error sending client identification:\r\n\r\n{0}", ex);
                        throw ex;
                    }

                    try
                    {
                        // First send the command type to the server
                        rwBuffer = UnicodeEncoding.Unicode.GetBytes(DACommon.AgentRemoteCommand);
                        npStream.Write(rwBuffer, 0, rwBuffer.Length);
                        npStream.WaitForPipeDrain();

                        // Send the command information to the server
                        IFormatter formatter = new BinaryFormatter();
                        formatter.Serialize(npStream, rca);

                        // Wait for the resulting TaskResult object
                        rcr = formatter.Deserialize(npStream) as RemoteCommandResponse;
                    }
                    catch (Exception ex)
                    {
                        LogEvent(LoggingLevel.Error, "Error communicating with the remote server:\r\n\r\n{0}", ex);
                        throw ex;
                    }
                }
                else
                {
                    throw new Exception(String.Format("Unable to run the remote task on '{0}'. The timeout expired waiting to connect to the remote server.",
                        server));
                }
            }

            return rcr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\DataProtector.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

namespace xonline.test.deployment.automation.common
{
	public static class DataProtector
	{
        public static byte[] Encrypt(string data)
        {
            if (null == data)
                throw new ArgumentNullException();

            byte[] toEncrypt = UnicodeEncoding.ASCII.GetBytes(data);
            return ProtectedData.Protect(toEncrypt, null, DataProtectionScope.LocalMachine);
        }

        public static string Decrypt(byte[] data)
        {
            if (null == data)
                throw new ArgumentNullException();

            byte[] toDecrypt = ProtectedData.Unprotect(data, null, DataProtectionScope.LocalMachine);
            return UnicodeEncoding.ASCII.GetString(toDecrypt);
        }

        public static string EncryptToHexString(string data)
        {
            byte[] encrypted = DataProtector.Encrypt(data);
            return BitConverter.ToString(encrypted).Replace("-", "");
        }

        public static string DecryptFromHexString(string data)
        {
            data = data.Trim();
            if ((data.Length % 2) != 0)
                throw new ArgumentException("Invalid hex data string.");
            byte[] hexData = new byte[data.Length / 2];
            for (int i = 0; i < hexData.Length; i++)
            {
                // Every two characters is a hex value
                hexData[i] = byte.Parse(data.Substring(i * 2, 2), System.Globalization.NumberStyles.HexNumber);
            }
            return Decrypt(hexData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\Parameter.cs ===
using System;
using System.Collections.Generic;

namespace xonline.test.deployment.automation.common
{
    [Serializable]
    public class Parameter
    {
        public static string ParameterBlock = "PARAM_BLOCK";

        public Parameter(){ }
        public Parameter(string name, string value)
        {
            Name = name;
            Value = value;
            Condition = RunCondition.Always;
        }
        public Parameter(string parameterBlockXml)
        {
            Name = ParameterBlock;
            Value = parameterBlockXml;
            Condition = RunCondition.Always;
        }

        public string Name { get; set; }
        public string Value { get; set; }
        public RunCondition Condition { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\Job.cs ===
using System;
using System.Collections.Generic;

namespace xonline.test.deployment.automation.common
{
    public class Job
    {
        public Job() { }
        public Job(Job jobObj)
        {
            if (null == jobObj)
                throw new ArgumentNullException();

            Id = jobObj.Id;
            Priority = jobObj.Priority;
            State = jobObj.State;
            StartDate = jobObj.StartDate;
            EndDate = jobObj.EndDate;
            Result = jobObj.Result;
            Name = jobObj.Name;
            Environment = jobObj.Environment;
            Creator = jobObj.Creator;
            Build = jobObj.Build;
            BuildVersion = jobObj.BuildVersion;
            CreateDate = jobObj.CreateDate;
            LogBase = jobObj.LogBase;
        }

        public long Id { get; set; }
        public string Name { get; set; }
        public JobType Type { get; set; }
        public string Creator { get; set; }
        public DateTime CreateDate { get; set; }
        public JobPriority Priority { get; set; }
        public string Environment { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
        public Result Result { get; set; }
        public JobState State { get; set; }
        public string Build { get; set; }
        public string BuildVersion { get; set; }
        public string LogBase { get; set; }
        public string LogsLocation
        {
            get
            {
                if (!String.IsNullOrEmpty(LogBase))
                    return System.IO.Path.Combine(LogBase, String.Format("{0}\\{1}\\{2}", Environment, Build, BuildVersion));
                else
                    return String.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\JobReport.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.automation.common
{
	public class JobReport
	{
        public long ReportId { get; set; }
        public long JobId { get; set; }
        public string ToList { get; set; }
        public string CcList { get; set; }
        public string BccList { get; set; }
        public string XsltName { get; set; }
        public RunCondition Condition { get; set; }
        public byte HistoryMaxDays { get; set; }
        public byte HistoryMaxJobs { get; set; }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\RemoteCommand.cs ===
﻿using System;

namespace xonline.test.deployment.automation.common
{
    [Serializable]
	public class RemoteCommandArgs
	{
        public RemoteCommandArgs(string exeName, string args, UInt16 timeoutSeconds)
        {
            ExeName = exeName;
            Arguments = args;
            TimeoutSeconds = timeoutSeconds;
        }

        public string ExeName { get; set; }
        public string Arguments { get; set; }
        public UInt16 TimeoutSeconds { get; set; }
	}

    [Serializable]
    public class RemoteCommandResponse
    {
        public RemoteCommandResponse()
        {
            ExitCode = 0;
            Exception = null;
            Output = null;
            Completed = false;
            TimedOut = false;
            RunTimeTicks = 0;
        }

        public int ExitCode { get; set; }
        public Exception Exception { get; set; }
        public string Output { get; set; }
        public bool Completed { get; set; }
        public bool TimedOut { get; set; }
        public long RunTimeTicks { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\NetworkDrive.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    public static class NetworkDrive
    {
		#region API Definitions

        [DllImport("mpr.dll")]
        private static extern int WNetAddConnection2A(ref NetResource lpNetResource, String lpPassword, String lpUsername, UInt32 dwFlags);
        [DllImport("mpr.dll")]
        private static extern int WNetCancelConnection2A(String lpName, UInt32 dwFlags, Int32 fForce);

        [StructLayout(LayoutKind.Sequential)]
        internal struct NetResource
        {
            public UInt32 dwScope;
            public UInt32 dwType;
            public UInt32 dwDisplayType;
            public UInt32 dwUsage;
            public String lpLocalName;
            public String lpRemoteName;
            public String lpComment;
            public String lpProvider;
        }

        private const UInt32 RESOURE_CONNECTED = 0x00000001;
        private const UInt32 RESOURE_GLOBALNET = 0x00000002;
        private const UInt32 RESOURE_REMEMBERED = 0x00000003;

        private const UInt32 RESOURCETYPE_ANY = 0x00000000;
        private const UInt32 RESOURCETYPE_DISK = 0x00000001;
        private const UInt32 RESOURCETYPE_PRINTER = 0x00000002;
        private const UInt32 RESOURCEDISPLAYTYPE_GENERIC = 0x00000000;

        private const UInt32 RESOURCEUSAGE_CONNECTABLE = 0x00000001;
        private const UInt32 RESOURCEUSAGE_CONTAINER = 0x00000002;

        private const UInt32 CONNECT_UPDATE_PROFILE = 0x00000001;
        private const UInt32 CONNECT_INTERACTIVE = 0x00000008;
        private const UInt32 CONNECT_PROMPT = 0x00000010;
        private const UInt32 CONNECT_REDIRECT = 0x00000080;
        private const UInt32 CONNECT_COMMANDLINE = 0x00000800;
        private const UInt32 CONNECT_CMD_SAVECRED = 0x00001000;
		
		#endregion

        public static void MapNetworkDrive(string networkLocation)
        {
            MapNetworkDrive(networkLocation, null, null, null);
        }

        public static void MapNetworkDrive(string networkLocation, string localName)
        {
            MapNetworkDrive(networkLocation, localName, null, null);
        }

        public static void MapNetworkDrive(string networkLocation, string localName, string userName, string password)
        {
            if (null == networkLocation)
                throw new ArgumentNullException("networkLocation");
            if (networkLocation.Length < 1)
                throw new ArgumentException("Zero-length network drive names are not allowed.");

            int retCode;
            NetResource res = new NetResource();
            res.dwType = RESOURCETYPE_ANY;
            res.lpLocalName = null;
            res.lpRemoteName = networkLocation;
            res.lpProvider = null;
            retCode = WNetAddConnection2A(ref res, password, userName, 0);
            if (retCode != 0)
                throw new System.ComponentModel.Win32Exception(retCode);
        }

        public static void UnMapNetworkDrive(string name, bool force)
        {
            int retCode = WNetCancelConnection2A(name, 0, Convert.ToInt32(force));
            if (retCode != 0)
                throw new System.ComponentModel.Win32Exception(retCode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\ParameterDescriptor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// Describes a parameter that a task module will accept.
    /// </summary>
    public class ParameterDescriptor
    {
        public string ParameterName { get; set; }
        public string Description { get; set; }

        public ParameterDescriptor() { }
        public ParameterDescriptor(string parameterName, string description)
        {
            Description = description;
            ParameterName = parameterName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\Log.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// Wrapper for log files. The log file represented by this file may be located purely in memory
    /// or may have an on disk representation.
    /// </summary>
    [Serializable]
    public class Log
    {
        /// <summary>
        /// The filename of the log file, including any extension
        /// </summary>
        public String FileName { get; set; }
        
        /// <summary>
        /// The complete path to the directory that the file is in.
        /// This is null if the log is stored in memory.
        /// </summary>
        public String Path { get; set; }

        /// <summary>
        /// The contents of the log, if this log is stored in memory.
        /// If the log is stored on disk, null.
        /// </summary>
        public String Text { get; set; }

        /// <summary>
        /// Creates a new log file wrapper.
        /// </summary>
        public Log() { }

        /// <summary>
        /// Creates a new log file wrapper.
        /// </summary>
        /// <param name="text">The text to add to the log. This can be a format string.</param>
        public Log(string text)
        {
            if (text != null)
                Text = text;
        }

        /// <summary>
        /// Creates a new log file wrapper.
        /// </summary>
        /// <param name="text">The text to add to the log. This can be a format string.</param>
        /// <param name="args">The replacement arguments for the format string.</param>
        public Log(string text, params object[] args)
        {
            if (text != null)
                Text = String.Format(text, args);
        }

        /// <summary>
        /// Creates a new log file wrapper.
        /// </summary>
        /// <param name="text">The text to add to the log. This can be a format string.</param>
        /// <param name="args">The replacement arguments for the format string.</param>
        public Log(string text, object args)
        {
            if (text != null)
                Text = String.Format(text, new object[] {args} );
        }

        public override string ToString()
        {
            StringBuilder ret = new StringBuilder();

            // Output the contents based on what is defined:
            //  If a file path and name are defined, put them together and output the result
            //  If the Text is defined, output that
            //  If both are defined, put them together with the file first followed by the text
            if (!String.IsNullOrEmpty(FileName) || !String.IsNullOrEmpty(Path))
            {
                if (!String.IsNullOrEmpty(Text))
                    ret.Append("File: ");

                if (!String.IsNullOrEmpty(Path))
                {
                    if (!String.IsNullOrEmpty(FileName))
                        ret.Append(System.IO.Path.Combine(Path, FileName));
                    else
                        ret.Append(Path);
                }
                else
                {
                    ret.Append(FileName);
                }
            }

            if (!String.IsNullOrEmpty(Text))
            {
                if (ret.Length > 0)
                    ret.Append(" ");

                if (!String.IsNullOrEmpty(FileName))
                    ret.Append("LogText: ");
                ret.Append(Text);
            }

            return ret.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\TaskGroup.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
	public class TaskGroup
	{
        public long Id { get; set; }
        public long JobId { get; set; }
        public string Name { get; set; }
        public RunCondition Condition { get; set; }
        public bool Rollup { get; set; }

        public TaskGroup() { }
        public TaskGroup(TaskGroup obj)
        {
            if (null == obj)
                throw new ArgumentNullException();

            Id = obj.Id;
            JobId = obj.JobId;
            Name = obj.Name;
            Condition = obj.Condition;
            Rollup = obj.Rollup;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\task.cs ===
using System;
using System.Collections.Generic;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// This class represents the Task information as stored in the database
    /// </summary>
    [Serializable]
    public class Task
    {
        #region c'tor

        public Task()
        {
            Parameters = new List<Parameter>();
        }

        public Task(Task taskobj)
        {
            if (null == taskobj)
                throw new ArgumentNullException();

            Id = taskobj.Id;
            JobId = taskobj.JobId;
            Group = taskobj.Group;
            RunOrder = taskobj.RunOrder;
            Condition = taskobj.Condition;
            Name = taskobj.Name;
            Module = taskobj.Module;
            State = taskobj.State;
            StartDate = taskobj.StartDate;
            EndDate = taskobj.EndDate;
            Result = taskobj.Result;
            Type = taskobj.Type;
            LocalLogTarget = taskobj.LocalLogTarget;
            Parameters = new List<Parameter>(taskobj.Parameters);
        }

        #endregion

        #region properties

        public long Id { get; set; }
        public long JobId { get; set; }
        public long Group { get; set; }
        public int RunOrder { get; set; }
        public string Name { get; set; }
        public string Module { get; set; }
        public TaskState State { get; set; }
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
        public Result Result { get; set; }
        public TaskType Type { get; set; }
        public RunCondition Condition { get; set; }
        public string LocalLogTarget { get; set; }
        public List<Parameter> Parameters { get; private set; }

        #endregion

        public void AddParameterList(List<Parameter> parameters)
        {
            if (parameters != null)
            {
                Parameters = new List<Parameter>(parameters);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\RemoteTask.cs ===
﻿using System;
using System.Collections.Generic;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// This class is used to communicate the essential task information
    /// to the remote server for execution.
    /// </summary>
    [Serializable]
    public class RemoteTask
	{
        public Task Task { get; private set; }
        public RunCondition CurrentCondition { get; private set; }
        public Result JobResult { get; private set; }

        private RemoteTask() { }
        public RemoteTask(Task task, RunCondition currentCondition, Result jobResult)
        {
            Task = task;
            CurrentCondition = currentCondition;
            JobResult = jobResult;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\TaskModuleInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// Describes a particular type of task module
    /// </summary>
    public class TaskModuleInfo
    {
        /// <summary>
        /// Unique name of the task
        /// </summary>
        public string Name { get; set; }
        
        /// <summary>
        /// Description of the task module
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Description of the parameters that a task module accepts.
        /// </summary>
        public ParameterDescriptor[] ParameterDescriptions { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\TaskLog.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// This class represents the t_task_log table in the Deployment DB.
    /// It associates a Log with a Task.
    /// </summary>
    public class TaskLog
    {
        private long _taskid;
        private Log _log;

        public TaskLog()
        {
            _log = new Log();
        }
        public TaskLog(TaskLog obj)
        {
            _taskid = obj._taskid;
            _log = new Log(obj._log.FileName, obj._log.Path, obj._log.Text);
        }

        #region Properties

        public long TaskId
        {
            get { return _taskid; }
            set { _taskid = value; }
        }

        public string LogFile
        {
            get { return _log.FileName; }
            set { _log.FileName = value; }
        }

        public string LogPath
        {
            get { return _log.Path; }
            set { _log.Path = value; }
        }

        public string LogText
        {
            get { return _log.Text; }
            set { _log.Text = value; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\TaskModuleLoader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    internal class ModuleInfo
    {
        public Type Type { get; set; }
        public ITaskModule Instance { get; set; }
    }

    public class TaskModuleManager
    {
        private Dictionary<string, ModuleInfo> _taskModules;

        public void LoadTaskDLLs(string taskDllPath)
        {
            _taskModules = new Dictionary<string, ModuleInfo>();

            if (!Directory.Exists(taskDllPath))
            {
                DACommon.LogEvent(LoggingLevel.Warning,
                    "The task dll directory '{0}' doesn't exist", taskDllPath);
                return;
            }

            string[] files = Directory.GetFiles(taskDllPath, "*.dll");
            if (0 == files.Length)
            {
                DACommon.LogEvent(LoggingLevel.Warning,
                    "There are no dlls in the task dll directory '{0}'", taskDllPath);
                return;
            }

            for (int i = 0; i < files.Length; i++)
            {
                Assembly taskAssm = null;
                FileVersionInfo dllVersion = FileVersionInfo.GetVersionInfo(files[i]);
                try
                {
                    taskAssm = Assembly.LoadFile(files[i]);
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(LoggingLevel.Warning,
                        "Unable to load '{0}'.\r\n\r\n{1}", files[i], ex);
                    continue;
                }

                Type[] exTypes = taskAssm.GetExportedTypes();
                StringBuilder msg = new StringBuilder();
                foreach (Type exType in exTypes)
                {
                    if (!exType.IsClass)
                        continue;

                    // Check for the DeploymentTaskModule attribute
                    if (exType.GetCustomAttributes(typeof(DeploymentTaskModuleAttribute), false).Length > 0)
                    {
                        // Store the task module object for later use
                        string normalizedModuleName = exType.Name.ToLower();
                        if (!_taskModules.ContainsKey(normalizedModuleName))
                        {
                            ModuleInfo mi = new ModuleInfo();
                            mi.Type = exType;
                            mi.Instance = (Activator.CreateInstance(exType) as ITaskModule);
                            _taskModules.Add(normalizedModuleName, mi);
                            msg.AppendLine(exType.Name);
                        }
                    }
                }
                DACommon.LogEvent(LoggingLevel.Information,
                    "Loaded task module '{0}' version {1} containing the following task modules:\r\n{2}",
                    files[i], dllVersion.ProductVersion, msg);
            }
        }

        public ITaskModule GetModule(string moduleName)
        {
            ITaskModule itm = null;

            if (_taskModules.ContainsKey(moduleName.ToLower()))
            {
                itm = (Activator.CreateInstance(_taskModules[moduleName.ToLower()].Type) as ITaskModule);
            }
            else
            {
                throw new ApplicationException("Unable to find the '" + moduleName + "' task module.");
            }

            return itm;
        }

        public void ExecuteRemoveAllParameters(string moduleName)
        {
            if (_taskModules.ContainsKey(moduleName.ToLower()))
            {
                _taskModules[moduleName.ToLower()].Instance.RemoveAllParameters();
            }
            else
            {
                throw new ApplicationException("Unable to find the '" + moduleName + "' task module.");
            }
        }

        public void ExecuteAddParameter(string moduleName, string paramName, string paramValue)
        {
            if (_taskModules.ContainsKey(moduleName.ToLower()))
            {
                _taskModules[moduleName.ToLower()].Instance.AddParameter(paramName, paramValue);
            }
            else
            {
                throw new ApplicationException("Unable to find the '" + moduleName + "' task module.");
            }
        }

        public void ExecuteAddParameter(string moduleName, List<Parameter> paramList)
        {
            if (paramList != null)
            {
                for (int i = 0; i < paramList.Count; i++)
                {
                    ExecuteAddParameter(moduleName, paramList[i].Name, paramList[i].Value);
                }
            }
        }

        public void ExecuteAddParameters(string moduleName, string xmlParameterBlock)
        {
            if (_taskModules.ContainsKey(moduleName.ToLower()))
            {
                _taskModules[moduleName.ToLower()].Instance.AddParameters(xmlParameterBlock);
            }
            else
            {
                throw new ApplicationException("Unable to find the '" + moduleName + "' task module.");
            }
        }

        public TaskResult ExecutePerform(string moduleName)
        {
            TaskResult result;

            if (_taskModules.ContainsKey(moduleName.ToLower()))
            {
                result = _taskModules[moduleName.ToLower()].Instance.Perform();
            }
            else
            {
                throw new ApplicationException("Unable to find the '" + moduleName + "' task module.");
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\TaskResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    /// <summary>
    /// Describes the result of executing a TaskModule.
    /// </summary>
    [Serializable]
    public class TaskResult
    {
        private List<Log> _logs;

        public bool ExecutedSuccessfully { set; get; }
        /// <summary>
        /// A list of logs, both in memory and on disk.
        /// </summary>
        public Log[] Logs {
            set { _logs = new List<Log>(value); }
            get { return _logs.ToArray(); }
        }

        public TaskResult()
        {
            _logs = new List<Log>();
        }

        public TaskResult(IEnumerable<Log> logs)
        {
            _logs = new List<Log>(logs);
        }

        public TaskResult(IEnumerable<Log> logs, bool executedSuccessfully)
        {
            _logs = new List<Log>(logs);
            ExecutedSuccessfully = executedSuccessfully;
        }

        public void AddLog(Log log) {
            _logs.Add(log);
        }

        public void AddLogs(IEnumerable<Log> logs)
        {
            _logs.AddRange(logs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\DAService\Agent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.daservice
{
    internal class AgentPipeInfo
    {
        public NamedPipeServerStream Pipe = null;
        public IAsyncResult PipeInfo = null;
    }

	public class Agent
	{
        private const int MAX_PIPES = 10;

        private bool _shuttingDown = false;
        private ManualResetEvent _stopEvent;
        private Thread _agentThread = null;
        private TaskModuleManager _tmm;

        public Agent()
        {
            _stopEvent = new ManualResetEvent(false);
        }

        public void Start()
        {
            // Don't do anything if the thread is already running
            if (null != _agentThread)
                return;

            // Can't start if we're shutting down
            if (_shuttingDown)
                return;

            // Create and start the Agent thread
            _agentThread = new Thread(new ThreadStart(AgentThreadProc));
            _agentThread.Name = "Agent Thread";
            _agentThread.Start();
        }

        public void Stop(int waitMilliseconds)
        {
            if (_agentThread != null && _agentThread.IsAlive)
            {
                _stopEvent.Set();
                _shuttingDown = true;
                if (!_agentThread.Join(waitMilliseconds))
                {
                    _agentThread.Abort();
                }
            }
        }

        private void AgentThreadProc()
        {
#if DEBUG
            DACommon.LogLevel = LoggingLevel.Debug;
            Thread.Sleep(30000);    // Allow time to attach a debugger
#endif
            // Load the task modules
            _tmm = new TaskModuleManager();
            try
            {
                _tmm.LoadTaskDLLs(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "TaskModules"));
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "Error loading the task modules:\r\n\r\n{0}", ex);
                return;
            }

            // Create the named pipes
            List<AgentPipeInfo> serverPipes = new List<AgentPipeInfo>(MAX_PIPES);
            for (int i = 0; i < MAX_PIPES; i++)
            {
                AgentPipeInfo pipeInfo = new AgentPipeInfo();
                pipeInfo.Pipe = new NamedPipeServerStream(DACommon.AgentPipeName, PipeDirection.InOut, MAX_PIPES, PipeTransmissionMode.Byte, PipeOptions.Asynchronous, 4096, 4096);
                serverPipes.Add(pipeInfo);
            }

            // This loop makes sure that the pipes stay active. As clients disconnect from the pipes, they get reconnected here.
            while (!_stopEvent.WaitOne(0, false))
            {
                for (int i = 0; i < serverPipes.Count; i++)
                {
                    if ((null == serverPipes[i].PipeInfo) ||
                        (serverPipes[i].PipeInfo.IsCompleted && !serverPipes[i].Pipe.IsConnected))
                    {
                        // The pipe needs to be re-connected
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Debug, "Beginning to wait for connections on pipe '{0}' number {1}.",
                            DACommon.AgentPipeName, i + 1);
                        serverPipes[i].PipeInfo = serverPipes[i].Pipe.BeginWaitForConnection(new AsyncCallback(ProcessClientRequest), serverPipes[i].Pipe);
                    }
                }
                Thread.Sleep(10000);
            }

            // Destroy the pipes
            for (int i = 0; i < serverPipes.Count; i++)
            {
                serverPipes[i].Pipe.Dispose();
            }
        }

        private void ProcessClientRequest(IAsyncResult res)
        {
            NamedPipeServerStream serverPipe = null;
            Byte[] cmdBuffer = null;
            IAsyncResult readRes = null;
            BinaryFormatter formatter = null;
            TaskResult result = null;
            int readSignal = 0;
            bool stop = false;
            string clientId = "";
            string requestType = "";

            // Call the EndWaitForConnection method
            try
            {
                serverPipe = res.AsyncState as NamedPipeServerStream;
                serverPipe.EndWaitForConnection(res);
                if (!serverPipe.IsConnected) return;
            }
            catch (ObjectDisposedException)
            {
                DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Warning, "The Agent thread exited before the connection could be completed.");
                return;
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "Unable to complete the client connection:\r\n{0}", ex);
                return;
            }

            // Wait for the client to send identification
            try
            {
                DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Debug, "Waiting for client to send it's identification string.");
                cmdBuffer = new Byte[64];
                readRes = serverPipe.BeginRead(cmdBuffer, 0, cmdBuffer.Length, null, null);
                readSignal = WaitHandle.WaitAny(new WaitHandle[] { _stopEvent, readRes.AsyncWaitHandle }, 30000, false);
                if (1 == readSignal)
                {
                    // Buffer read complete
                    serverPipe.EndRead(readRes);
                    clientId = UnicodeEncoding.Unicode.GetString(cmdBuffer).TrimEnd('\0');
                }
                else if (0 == readSignal)
                {
                    // Stop event signalled
                    DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Information, "The Stop event was signalled while waiting for the client to send its identification string.");
                    stop = true;
                }
                else if (WaitHandle.WaitTimeout == readSignal)
                {
                    // No data received within the timeout period
                    throw new Exception("The client did not send an identification string within the timeout period. Closing connection.");
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "Unable to read the client identification:\r\n{0}", ex);
            }

            // Wait for the client to send the request type
            if (!stop)
            {
                try
                {
                    DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Debug, "[{0}]Waiting for the client to send the request type.", clientId);
                    cmdBuffer = new Byte[64];
                    readRes = serverPipe.BeginRead(cmdBuffer, 0, cmdBuffer.Length, null, null);
                    readSignal = WaitHandle.WaitAny(new WaitHandle[] { _stopEvent, readRes.AsyncWaitHandle }, 30000, false);
                    if (1 == readSignal)
                    {
                        // Buffer read complete
                        serverPipe.EndRead(readRes);
                        requestType = UnicodeEncoding.Unicode.GetString(cmdBuffer).TrimEnd('\0');
                    }
                    else if (0 == readSignal)
                    {
                        // Stop event signalled
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Information,
                            "[{0}]The Stop event was signalled while waiting for the client to send the request type.", clientId);
                        stop = true;
                    }
                    else if (WaitHandle.WaitTimeout == readSignal)
                    {
                        // No data received within the timeout period
                        throw new Exception(String.Format("[{0}]The client did not send a command string within the timeout period. Closing connection.", clientId));
                    }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]Error reading the request type from the client:\r\n\r\n{1}", clientId, ex);
                    stop = true;
                }
            }

            // Process the Client Request
            if (!stop)
            {
                formatter = new BinaryFormatter();

                if (String.Compare(requestType, "RemoteTask", true) == 0)
                {
                    DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Debug, "[{0}]Receiving a Remote Task from the client.", clientId);

                    // Wait for the task data from the client
                    RemoteTask remoteTask = null;
                    try
                    {
                        remoteTask = formatter.Deserialize(serverPipe) as RemoteTask;
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]Error receiving the task information:\r\n\r\n{1}", clientId, ex);
                    }

                    if (remoteTask != null)
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Information, "[{0}]Remote Task received:\r\nName: {1}\r\nModule: {2}",
                            clientId, remoteTask.Task.Name, remoteTask.Task.Module);
                        try
                        {
                            // Get a new instance of the requested module (this will throw if the module isn't loaded)
                            ITaskModule itm = _tmm.GetModule(remoteTask.Task.Module);

                            // Run the task
                            foreach (Parameter param in remoteTask.Task.Parameters)
                            {
                                if (RunCondition.Always == param.Condition ||
                                    (RunCondition.IfPassing == param.Condition && Result.Succeeded == remoteTask.JobResult) ||
                                    (RunCondition.IfFailing == param.Condition && Result.Failed == remoteTask.JobResult))
                                {
                                    if (Parameter.ParameterBlock == param.Name)
                                    {
                                        itm.AddParameters(param.Value);
                                    }
                                    else
                                    {
                                        itm.AddParameter(param.Name, param.Value);
                                    }
                                }
                            }
                            result = itm.Perform();
                        }
                        catch (Exception ex)
                        {
                            DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]An exception occurred while running the task:\r\n{1}", clientId, ex);
                            result = new TaskResult();
                            result.ExecutedSuccessfully = false;
                            result.AddLog(new Log(ex.ToString()));
                        }
                    }
                    else
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]An invalid TaskInfo object was received from the client.", clientId);
                        result = new TaskResult();
                        result.ExecutedSuccessfully = false;
                        result.AddLog(new Log("Agent Error : Invalid TaskInfo object received from the '{0}' client.", clientId));
                    }

                    try
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Debug, "[{0}]Sending the results back to the client.", clientId);

                        // Return the results over the pipe
                        formatter.Serialize(serverPipe, result);
                        serverPipe.WaitForPipeDrain();
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]Error sending the results back over the pipe:\r\n\r\n{1}",
                            clientId, ex);
                    }
                }
                else if (String.Compare(requestType, "RemoteCommand", true) == 0)
                {
                    DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Debug, "[{0}]Receiving a Remote Command from the client.", clientId);

                    // Wait for the client to send the data
                    RemoteCommandArgs rca = null;
                    try
                    {
                        rca = formatter.Deserialize(serverPipe) as RemoteCommandArgs;
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]Error receiving the remote command information:\r\n\r\n{1}",
                            clientId, ex);
                    }

                    if (rca != null)
                    {
                        RemoteCommand rc = new RemoteCommand();
                        RemoteCommandResponse rcr = rc.Run(clientId, rca);

                        // Report the results back to the client
                        try
                        {
                            formatter.Serialize(serverPipe, rcr);
                            serverPipe.WaitForPipeDrain();
                        }
                        catch (Exception ex)
                        {
                            DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error,
                                "[{0}]Error sending the remote command response to the client:\r\n\r\n{1}", clientId, ex);
                        }
                    }
                    else
                    {
                        DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error,
                            "[{0}]An invalid RemoteCommandArgs object was received from the client.", clientId);
                    }
                }
            }

            serverPipe.Disconnect();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\WMITaskModuleBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Management;
using System.Text;

namespace xonline.test.deployment.automation.common
{
    public static class WMIReturnCode
    {
        public const UInt32 Completed = 0;
        public const UInt32 Started = 4096;
        public const UInt32 Failed = 32768;
        public const UInt32 AccessDenied = 32769;
        public const UInt32 NotSupported = 32770;
        public const UInt32 Unknown = 32771;
        public const UInt32 Timeout = 32772;
        public const UInt32 InvalidParameter = 32773;
        public const UInt32 SystemInUser = 32774;
        public const UInt32 InvalidState = 32775;
        public const UInt32 IncorrectDataType = 32776;
        public const UInt32 SystemNotAvailable = 32777;
        public const UInt32 OutofMemory = 32778;
    }

    public static class WMIJobState
    {
        public const UInt16 New = 2;
        public const UInt16 Starting = 3;
        public const UInt16 Running = 4;
        public const UInt16 Suspened = 5;
        public const UInt16 ShuttingDown = 6;
        public const UInt16 Completed = 7;
        public const UInt16 Terminated = 8;
        public const UInt16 Killed = 9;
        public const UInt16 Exception = 10;
        public const UInt16 Service = 11;
    }

    public class MethodParam
    {
        public string Key { get; private set; }
        public string Value { get; private set; }
        public MethodParam(string key, string value)
        {
            Key = key;
            Value = value;
        }
    }

    public class WMITimeoutException : Exception
    {
        public WMITimeoutException() : base() { }
        public WMITimeoutException(string message) : base(message) { }
        public WMITimeoutException(string message, Exception innerException) : base(message, innerException) { }
    }

    public class WMIConnectException : Exception
    {
        public WMIConnectException() : base() { }
        public WMIConnectException(string message) : base(message) { }
        public WMIConnectException(string message, Exception innerException) : base(message, innerException) { }
    }

    public class WMIExecuteException : Exception
    {
        public UInt32 ErrorCode { get; private set; }
        public string ErrorDescription { get; private set; }

        public WMIExecuteException() : base() { }
        public WMIExecuteException(string message) : base(message) { }
        public WMIExecuteException(string message, Exception innerException) : base(message, innerException) { }
        public WMIExecuteException(string message, UInt32 errorCode, string errorDesc)
            : base(message)
        {
            ErrorCode = errorCode;
            ErrorDescription = errorDesc;
        }
        public WMIExecuteException(string message, UInt32 errorCode, string errorDesc, Exception innerException)
            : base(message, innerException)
        {
            ErrorCode = errorCode;
            ErrorDescription = errorDesc;
        }
    }

	public static class WMI
	{
        public static ManagementScope ConnectToHost(string hostName, string path, string userName, string password)
        {
            ManagementScope scope = null;
            ConnectionOptions options = null;

            try
            {
                // If the username is supplied, connect using the supplied credentials
                if (!String.IsNullOrEmpty(userName))
                {
                    options = new ConnectionOptions();
                    options.Username = userName;
                    options.Password = password;
                    options.Authentication = AuthenticationLevel.PacketPrivacy;
                }

                scope = new ManagementScope(String.Format(@"\\{0}\root\{1}", hostName, path), options);
                ConnectScope(scope);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Warning, "ConnectToHost: Failed to connect to the host server:\r\n{0}", ex);
                // Only package the exception in a WMIConnectException if it is not already one
                if (ex is WMIConnectException)
                    throw ex;
                else
                    throw new WMIConnectException(String.Format("Failed to connect to {0}", hostName), ex);
            }

            return scope;
        }

        public static ManagementScope ConnectToHost(ManagementScope connection, string newClassName)
        {
            string newPath = String.Format(@"\\{0}\root\{1}", connection.Path.Server, newClassName);
            ManagementScope newScope = null;
            try
            {
                newScope = new ManagementScope(newPath, connection.Options);
                ConnectScope(newScope);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Warning, "Unable to connect to '{0}' on host machine {1}:\r\n{2}",
                    newClassName, connection.Path.Server, ex);
                newScope = null;
            }

            return newScope;
        }

        public static ManagementObject GetServiceObject(ManagementScope scope, string serviceName)
        {
            if (!scope.IsConnected)
                scope.Connect();
            ManagementPath wmiPath = new ManagementPath(serviceName);
            ManagementClass serviceClass = new ManagementClass(scope, wmiPath, null);
            ManagementObjectCollection services = serviceClass.GetInstances();

            ManagementObject serviceObject = null;

            foreach (ManagementObject service in services)
            {
                serviceObject = service;
            }

            return serviceObject;
        }

        public static ManagementObjectCollection QueryObjects(ManagementScope scope, string query)
        {
            ManagementObjectCollection obList = null;

            if (scope != null)
            {
                if (!scope.IsConnected)
                    scope.Connect();
                ManagementObjectSearcher searcher = new ManagementObjectSearcher(scope, new WqlObjectQuery(query));
                obList = searcher.Get();
            }

            return obList;
        }

        public static ManagementObject QuerySingleObject(ManagementScope scope, string query)
        {
            ManagementObject ret = null;
            ManagementObjectCollection obList = QueryObjects(scope, query);
            if (obList != null)
            {
                foreach (ManagementObject obj in obList)
                {
                    ret = obj;
                    break;
                }
            }

            return ret;
        }

        public static bool InvokeMethod(ManagementObject obj, string methodName, int timeout, params MethodParam[] parameters)
        {
            bool success = true;
            ManagementBaseObject inParams = obj.GetMethodParameters(methodName);
            foreach (MethodParam param in parameters)
            {
                inParams[param.Key] = param.Value;
            }

            ManagementBaseObject outParams = obj.InvokeMethod(methodName, inParams, null);
            if (null != outParams)
            {
                ManagementObject job = null;
                UInt32 retValue = WMIReturnCode.Completed;
                foreach (PropertyData retData in outParams.Properties)
                {
                    if (String.Compare("ReturnValue", retData.Name, true) == 0)
                        retValue = (UInt32)retData.Value;
                }
                string errorDescription = "";

                switch (retValue)
                {
                    case WMIReturnCode.Completed:
                        break;
                    case WMIReturnCode.Started:
                        {
                            // Asynchronous job - wait for completion
                            int waitTime = 0;
                            job = new ManagementObject(obj.Scope, new ManagementPath(outParams["Job"] as string), null);
                            while ((UInt16)job["JobState"] == WMIJobState.Starting
                                || (UInt16)job["JobState"] == WMIJobState.Running)
                            {
                                if (waitTime > timeout)
                                {
                                    throw new WMITimeoutException(
                                        String.Format("The timeout of {0} seconds elapsed waiting for the {1} method to finish.", timeout, methodName));
                                }
                                System.Threading.Thread.Sleep(1000);
                                waitTime++;
                                job = new ManagementObject(job.Scope, job.Path, null);  // Refresh the job object
                            }
                            if ((UInt16)job["JobState"] != WMIJobState.Completed)
                            {
                                retValue = (UInt32)(UInt16)job["ErrorCode"];
                                errorDescription = job["ErrorDescription"] as string;
                                success = false;
                            }
                        }
                        break;
                    default:
                        success = false;
                        errorDescription = "None available.";
                        break;
                }

                if (!success)
                    throw new WMIExecuteException(String.Format("{0} failed.", methodName), retValue, errorDescription);
            }

            return success;
        }

        public static DateTime ParseCIMDateTime(string cimDateTime, bool convertToLocal)
        {
            // The format of a CIM_DateTime is:
            //  yyyymmddHHMMSS.mmmmmmsUUU
            // Most of these are pretty self-explanatory.
            // The sUUU portion is an offset from GMT, expressed in minutes.
            if (String.IsNullOrEmpty(cimDateTime))
                throw new ArgumentException("Invalid CIM_DateTime - the string is null or empty");
            if (cimDateTime.Length != 25)
                throw new ArgumentException("Invalid CIM_DateTime - unexpected string length.");

            // Parse the Date and Time
            DateTime dt = DateTime.ParseExact(cimDateTime.Substring(0, 14), "yyyyMMddHHmmss", null);

            // Get the offset from GMT
            char sign = cimDateTime[21];
            if (sign != '+' && sign != '-')
                throw new ArgumentException("Invalid CIM_DateTime - unexpected offset sign.");
            int offset;
            if (!Int32.TryParse(cimDateTime.Substring(22), out offset))
                throw new ArgumentException("Invalid CIM_DateTime - unable to convert the offset to a number.");

            // Apply the offset to the DateTime
            if (offset > 0)
            {
                if (sign == '-')
                    offset = -offset;
                dt = dt.AddMinutes((double)offset);
            }

            // Optionally convert the DateTime to local time
            return (convertToLocal ? dt.ToLocalTime() : dt);
        }

        private static void ConnectScope(ManagementScope scope)
        {
            bool connected = false;
            int connectRetries = 0;

            while (!connected)
            {
                try
                {
                    scope.Connect();
                    connected = true;
                }
                catch (Exception ex)
                {
                    if (ex.Message.ToLower().Contains("the rpc server is unavailable"))
                    {
                        if (connectRetries < 2)
                        {
                            System.Threading.Thread.Sleep(30000);   // Wait 30 seconds before retrying
                            connectRetries++;
                            connected = false;
                        }
                        else
                        {
                            throw new WMIConnectException(
                                String.Format("Unable to connect to the host machine '{0}' after 3 tries.", scope.Path.Server), ex);
                        }
                    }
                    else
                    {
                        throw new WMIConnectException(
                            String.Format("Unable to connect to the host machine '{0}'.", scope.Path.Server), ex);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\DAService\DAService.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.ServiceProcess;
using System.Text;
using System.Threading;
using System.Xml.XPath;
using Microsoft.Win32;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.daservice
{
    public partial class DAService : ServiceBase
    {
        internal const string EVENT_SOURCE = "DAService";

        private Agent _agent;

        public DAService()
        {
            CanStop = true;
            CanShutdown = true;
            CanPauseAndContinue = false;
            ServiceName = EVENT_SOURCE;
            AutoLog = false;
        }

        protected override void OnStart(string[] args)
        {
            _agent = new Agent();
            _agent.Start();

            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
            DACommon.LogEvent(EVENT_SOURCE, LoggingLevel.Information, "{0} version {1} started successfully.", ServiceName, fvi.ProductVersion);
        }

        protected override void OnStop()
        {
            DACommon.LogEvent(EVENT_SOURCE, LoggingLevel.Information, "{0} stopping.", ServiceName);
            _agent.Stop(30000);
        }

        #region Main entry point
        static void Main(string[] args)
        {
            ServiceBase[] ServicesToRun;
            ServicesToRun = new ServiceBase[] 
			{ 
				new DAService() 
			};
            ServiceBase.Run(ServicesToRun);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\Common\XLFServiceBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.ServiceProcess;
using System.Text;
using System.Threading;

namespace xonline.test.deployment.automation.common
{
    public class XLFServiceBase : ServiceBase
    {
        private Thread _commandThread = null;
        private ManualResetEvent _stopEvent = null;
        private Dictionary<string, CommandHandler> _commands = null;

        public delegate string CommandHandler(string parameters);

        protected XLFServiceBase()
        {
            // Create the event used to signal service stoppage
            _stopEvent = new ManualResetEvent(false);

            // Add a command handler for the GetVersion and GetCommands commands
            AddCommandHandler("GetVersion", GetVersionString);
            AddCommandHandler("GetCommands", GetCommandList);

            // Create the command thread
            _commandThread = new Thread(new ThreadStart(CommandThreadProc));
            _commandThread.Name = "Command Thread";
        }

        protected void AddCommandHandler(string command, CommandHandler handler)
        {
            string cmd = command.ToLower();
            if (null == _commands)
                _commands = new Dictionary<string, CommandHandler>();
            if (!_commands.ContainsKey(cmd))
                _commands.Add(cmd, null);
            _commands[cmd] = handler;
        }

        protected void RemoveCommandHandler(string command)
        {
            string cmd = command.ToLower();
            if (null != _commands)
            {
                if (_commands.ContainsKey(cmd))
                    _commands.Remove(cmd);
            }
        }

        protected override void OnStart(string[] args)
        {
            try
            {
                if (null != _commandThread)
                    _commandThread.Start();
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "An exception occurred during the OnStart handler:\r\n{0}", ex);
            }
        }

        protected override void OnStop()
        {
            Stop(30000);
        }

        protected override void OnShutdown()
        {
            Stop(30000);
        }

        protected void LogEvent(LoggingLevel loggingLevel, string msg, params object[] args)
        {
            string eventText = String.Format(msg, args);

            // Write the event to the event log
            DACommon.LogEvent(ServiceName, loggingLevel, eventText);
        }

        private void Stop(int waitMilliseconds)
        {
            if (_stopEvent != null)
                _stopEvent.Set();

            if (_commandThread != null)
            {
                if (!_commandThread.Join(waitMilliseconds))
                {
                    _commandThread.Abort();
                }
            }
        }

        private void CommandThreadProc()
        {
            string pipeName = String.Format(@"\\.\Pipe\{0}_Command", ServiceName);
            NamedPipeServerStream commandPipe = new NamedPipeServerStream(pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Message, PipeOptions.Asynchronous, 4096, 4096);
            IAsyncResult connectResult;
            Byte[] cmdBuffer = null;
            int bufferSize = 4096;
            string commandString = "";

            while (true)
            {
                // Wait for a client connection
                try
                {
                    connectResult = commandPipe.BeginWaitForConnection(null, null);
                    int waitIndex = WaitHandle.WaitAny(new WaitHandle[] { connectResult.AsyncWaitHandle, _stopEvent });
                    if (0 == waitIndex)
                        commandPipe.EndWaitForConnection(connectResult);
                    else
                        break;
                }
                catch (ObjectDisposedException)
                {
                    LogEvent(LoggingLevel.Warning, "Cmd: The Communication thread exited before the connection could be completed.");
                    return;
                }
                catch (Exception ex)
                {
                    LogEvent(LoggingLevel.Error, "Cmd: Unable to complete the client connection:\r\n{0}", ex);
                    continue;
                }

                if (commandPipe.IsConnected)
                {
                    // Wait for a command from the client (indefinately)
                    try
                    {
                        cmdBuffer = new Byte[bufferSize];
                        int bytesRead = commandPipe.Read(cmdBuffer, 0, bufferSize);
                        commandString = UnicodeEncoding.Unicode.GetString(cmdBuffer, 0, bytesRead);
                    }
                    catch (Exception ex)
                    {
                        LogEvent(LoggingLevel.Warning, "Cmd: Unable to read the command from the client:\r\n{0}", ex);
                    }

                    if (!String.IsNullOrEmpty(commandString))
                    {
                        string ret = "";
                        try
                        {
                            ret = CommandProcessor(commandString);
                        }
                        catch (Exception ex)
                        {
                            ret = String.Format("Cmd: {0}'s command processor threw an exception:\r\n{1}", ServiceName, ex);
                            LogEvent(LoggingLevel.Error, ret);
                        }

                        // Send the result string back to the client
                        if (!String.IsNullOrEmpty(ret))
                        {
                            try
                            {
                                int byteCount = UnicodeEncoding.Unicode.GetByteCount(ret);
                                byte[] returnBuffer = UnicodeEncoding.Unicode.GetBytes(ret);
                                commandPipe.Write(returnBuffer, 0, byteCount);
                                commandPipe.WaitForPipeDrain();
                            }
                            catch (Exception ex)
                            {
                                LogEvent(LoggingLevel.Warning, "Cmd: Unable to send the command results to the client:\r\n{0}", ex);
                            }
                        }
                    }

                    // disconnect the pipe
                    commandPipe.Disconnect();
                }
            }
        }

        protected virtual string CommandProcessor(string commandString)
        {
            string ret = "";

            // The format of the command string is "command[ paramName=paramValue[ ...]]"
            string command;
            string parameters;
            int space = commandString.IndexOf(' ');
            if (space > 0)
            {
                command = commandString.Substring(0, space).ToLower();
                parameters = commandString.Substring(space + 1);
            }
            else
            {
                command = commandString.ToLower();
                parameters = null;
            }
            DACommon.LogEvent(ServiceName, LoggingLevel.Debug, "Command: '{0}'\r\nParameters: '{1}'", command, parameters);

            if (null != _commands)
            {
                if (_commands.ContainsKey(command))
                {
                    ret = _commands[command](parameters);
                }
                else
                {
                    ret = String.Format("This service does not have a handler for the '{0}' command.", command);
                }
            }
            else
                ret = "This service does not support commands.";

            return ret;
        }

        protected virtual string GetVersionString(string parameters)
        {
            FileVersionInfo info = FileVersionInfo.GetVersionInfo(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, ServiceName + ".exe"));
            return String.Format("{0} version {1}", ServiceName, info.ProductVersion);
        }

        protected virtual string GetCommandList(string parameters)
        {
            StringBuilder sb = new StringBuilder();
            foreach (KeyValuePair<string, CommandHandler> kvp in _commands)
            {
                sb.AppendLine(kvp.Key);
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\EnvironmentData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.jsservice
{
    public class EnvironmentData
    {
        public long Id { get; set; }
        public string Environment { get; set; }
        public string AgentServer { get; set; }
        public string AgentServerIP { get; set; }
        public string UserName { get; set; }
        public EnvironmentPassword LocalPassword { get; set; }
        public EnvironmentPassword RemotePassword { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\DAService\DASInstaller.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.ServiceProcess;
using Microsoft.Win32;

namespace xonline.test.deployment.automation.daservice
{
    [RunInstaller(true)]
    public class DASInstaller : Installer
    {
        private ServiceProcessInstaller _processInstaller;
        private ServiceInstaller _daServiceInstaller;

        public DASInstaller()
        {
            _processInstaller = new ServiceProcessInstaller();
            _processInstaller.Account = ServiceAccount.User;

            _daServiceInstaller = new ServiceInstaller();
            _daServiceInstaller.ServiceName = "DAService";
            _daServiceInstaller.DisplayName = "Deployment Agent";
            _daServiceInstaller.Description = "Accepts tasks from the Job Scheduler service and runs them locally.";
            _daServiceInstaller.StartType = ServiceStartMode.Automatic;

            Installers.Add(_daServiceInstaller);
            Installers.Add(_processInstaller);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\EnvironmentPassword.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.jsservice
{
	public class EnvironmentPassword
	{
        public string Password { get; set; }
        public bool IsEncrypted { get; set; }
        public string ContextServer { get; set; }
        public PasswordType Type { get; set; }

        public override string ToString()
        {
            if (IsEncrypted)
                return DataProtector.DecryptFromHexString(Password);
            else
                return Password;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\DAService\RemoteCommand.cs ===
﻿using System;
using System.Diagnostics;
using System.IO;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.daservice
{
	public class RemoteCommand
	{
        private StringBuilder _processOutput;

        public RemoteCommand()
        {
            _processOutput = new StringBuilder();
        }

        public RemoteCommandResponse Run(string clientId, RemoteCommandArgs rca)
        {
            RemoteCommandResponse rcr = new RemoteCommandResponse();
            long startTicks = 0;

            // Run the remote command
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo();
                psi.FileName = rca.ExeName;
                psi.WorkingDirectory = Path.GetDirectoryName(rca.ExeName);
                psi.Arguments = rca.Arguments;
                psi.RedirectStandardError = true;
                psi.RedirectStandardOutput = true;
                psi.CreateNoWindow = true;
                psi.UseShellExecute = false;

                Process cmdProcess = new Process();
                cmdProcess.StartInfo = psi;
                cmdProcess.OutputDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
                cmdProcess.ErrorDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
                startTicks = DateTime.Now.Ticks;
                cmdProcess.Start();
                cmdProcess.BeginOutputReadLine();
                cmdProcess.BeginErrorReadLine();
                if (cmdProcess.WaitForExit(rca.TimeoutSeconds * 1000))
                {
                    // Even though the Process finished, we need to wait for all asynchronous event handling to complete
                    cmdProcess.WaitForExit();
                    rcr.RunTimeTicks = DateTime.Now.Ticks - startTicks;
                    rcr.Completed = true;
                    rcr.ExitCode = cmdProcess.ExitCode;
                    rcr.Output = _processOutput.ToString();
                }
                else
                {
                    // The process took too long to execute - kill it
                    cmdProcess.Kill();
                    rcr.TimedOut = true;
                    rcr.Completed = false;
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(DAService.EVENT_SOURCE, LoggingLevel.Error, "[{0}]Exception while running {1}:\r\n\r\n{2}",
                    clientId, rca.ExeName, ex);
                rcr.Exception = ex;
                rcr.Completed = false;
            }

            return rcr;
        }

        private void OutputDataReceivedHandler(object sender, DataReceivedEventArgs e)
        {
            _processOutput.AppendLine(e.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\JobScheduler.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;
using System.Xml;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.jsservice
{
    public class JobScheduler
    {
        // Parameter tokens. This is the list of replaceable parameter tokens understood by JSService
        internal const string ParamTokenJobStartTime = "##JobStartTime##";
        internal const string ParamTokenJobStartTimeGMT = "##JobStartTimeGMT##";
        internal const string ParamTokenCurrentTime = "##CurrentTime##";
        internal const string ParamTokenCurrentTimeGMT = "##CurrentTimeGMT##";
        internal const string ParamTokenJobResult = "##JobResult##";

        private const int PAUSE_EVENT = 0;
        private const int CANCEL_EVENT = 1;
        private const int SHUTDOWN_EVENT = 2;
        private const int RemoteConnectionTimeout = 300000; // 5 minutes
        private const int QueueSleepLength = 300000;        // 5 minutes
        private const int LockNotifyThreshold = 3;

        private Thread _schedulerThread = null;
        private ManualResetEvent[] _controlEvents = new ManualResetEvent[3];
        private EnvironmentData _envData = null;
        private bool _shuttingDown = false;
        private Dictionary<string, string> _tokenData;

        public JobScheduler(string envName)
        {
            // Create the control events
            _controlEvents[PAUSE_EVENT] = new ManualResetEvent(false);
            _controlEvents[CANCEL_EVENT] = new ManualResetEvent(false);
            _controlEvents[SHUTDOWN_EVENT] = new ManualResetEvent(false);

            // Create the scheduler thread
            _schedulerThread = new Thread(new ThreadStart(ThreadProc));
            _schedulerThread.Name = envName;
        }

        #region Public Methods

        public void Start()
        {
            // Don't do anything if the thread is already running
            if (_schedulerThread.ThreadState != System.Threading.ThreadState.Unstarted)
                return;

            // Can't start if we're shutting down
            if (_shuttingDown)
                return;

            // Create the TokenData dictionary for run-time token replacements
            _tokenData = new Dictionary<string, string>();
            _tokenData.Add(ParamTokenCurrentTime, "");
            _tokenData.Add(ParamTokenCurrentTimeGMT, "");
            _tokenData.Add(ParamTokenJobResult, "");
            _tokenData.Add(ParamTokenJobStartTime, "");
            _tokenData.Add(ParamTokenJobStartTimeGMT, "");

            // Start processing jobs for this environment
            JSService.LogEvent(LoggingLevel.Information, "Starting job scheduler for " + _schedulerThread.Name);
            try
            {
                _schedulerThread.Start();
            }
            catch (Exception ex)
            {
                JSService.LogEvent(LoggingLevel.Error, "Unable to start the job scheduler thread for the '{0}' environment.\r\n\r\n{1}",
                    _schedulerThread.Name, ex);
            }
        }

        public void Pause()
        {
            if (!_shuttingDown && !_controlEvents[PAUSE_EVENT].WaitOne(0, false))
            {
                // Signal the pause event
                _controlEvents[PAUSE_EVENT].Set();
            }
        }

        public void Resume()
        {
            if (!_shuttingDown && _controlEvents[PAUSE_EVENT].WaitOne(0, false))
            {
                // Reset the pause event
                _controlEvents[PAUSE_EVENT].Reset();
            }
        }

        public void Shutdown(int waitMilliseconds)
        {
            if (_schedulerThread.IsAlive)
            {
                _controlEvents[SHUTDOWN_EVENT].Set();
                _shuttingDown = true;
                if (!_schedulerThread.Join(waitMilliseconds))
                {
                    // The scheduler thread is still executing - time to kill it
                    _schedulerThread.Abort();
                }
            }
        }

        #endregion

        #region Private Methods

        private void ThreadProc()
        {
            JSService.LogEvent(LoggingLevel.Debug, "Starting scheduler thread. Name={0}", Thread.CurrentThread.Name);
#if DEBUG
            Thread.Sleep(30000);    // Allow time to attach a debugger
#endif
            Job job = null;
            Result jobResult = Result.Succeeded;
            TaskGroup currentGroup = null;
            Queue<Task> groupTasks = null;
            Task nextTask = null;
            int waitTime = 0;
            int eventId = WaitHandle.WaitTimeout;
            bool paused = false;
            int lockNotifyCounter = 0;

            try
            {
                while (true)
                {
                    // Check the control events
                    eventId = WaitHandle.WaitAny(_controlEvents, waitTime, false);
                    waitTime = 0;
                    if (PAUSE_EVENT == eventId)
                    {
                        paused = true;
                        continue;
                    }
                    else if (CANCEL_EVENT == eventId)
                    {
                        // Ignore
                        continue;
                    }
                    else if (SHUTDOWN_EVENT == eventId)
                    {
                        if (job != null)
                        {
                            DbAccess.CancelJob(job.Id);
                        }
                        break;
                    }
                    else if (paused)
                    {
                        paused = false;
                    }

                    if (null == _envData)
                    {
                        // Pull the environment data out of the database
                        try
                        {
                            _envData = DbAccess.LoadEnvironmentData(Thread.CurrentThread.Name);
                        }
                        catch (Exception ex)
                        {
                            JSService.LogEvent(LoggingLevel.Error,
                                "Unable to read the environment settings for {0}:\r\n{1}", Thread.CurrentThread.Name, ex);
                            waitTime = QueueSleepLength;
                            continue;
                        }

                        // Convert the DNS name of the agent server to it's IP Address. This is done to avoid problems
                        // when mapping network drives later on.
                        IPAddress[] ipAddresses = Dns.GetHostAddresses(_envData.AgentServer);
                        if (ipAddresses.Length > 0)
                            _envData.AgentServerIP = ipAddresses[0].ToString();
                    }

                    // Determine if a job is running
                    if (job != null)
                    {
                        JobState state = DbAccess.GetJobState(job.Id);

                        // If the job has been paused, sleep and check again later
                        if (JobState.Paused == state)
                        {
                            waitTime = 60000;   // Wait 60 seconds before checking again
                            continue;
                        }

                        // The job should never be marked Complete at this stage
                        // unless the job has been cancelled from an external source
                        if (JobState.Complete == state)
                        {
                            Result result = DbAccess.GetJobResult(job.Id);
                            JSService.LogEvent(LoggingLevel.Warning, "Job {0} has been marked Complete with a result of {1}",
                                job.Id, result);

                            // Reset the job information and continue
                            if (null != groupTasks)
                                groupTasks.Clear();
                            currentGroup = null;
                            job = null;
                            jobResult = Result.Succeeded;
                            waitTime = 0;
                            continue;
                        }

                        if (groupTasks != null && groupTasks.Count > 0)
                        {
                            // Continue to run synchronous tasks from the current task group
                            nextTask = groupTasks.Dequeue();
                        }
                        else
                        {
                            // Pull the next task from the database
                            nextTask = DbAccess.GetNextTask(job.Id);
                            if (nextTask != null)
                            {
                                // If this task is part of a task group,
                                // pull the list of tasks for that group.
                                if (nextTask.Group > 0)
                                {
                                    currentGroup = DbAccess.GetTaskGroupInfo(nextTask.Group);
                                    if (RunCondition.Inherit == currentGroup.Condition)
                                        currentGroup.Condition = RunCondition.Always;

                                    // Should we be running this group?
                                    if (RunCondition.Always == currentGroup.Condition ||
                                        (RunCondition.IfPassing == currentGroup.Condition && Result.Succeeded == jobResult) ||
                                        (RunCondition.IfFailing == currentGroup.Condition && Result.Failed == jobResult))
                                    {
                                        // This group will run - pull the tasks that belong to it
                                        groupTasks = new Queue<Task>(DbAccess.GetGroupTasks(currentGroup.Id));

                                        // Pull the first task from the group
                                        nextTask = groupTasks.Dequeue();
                                    }
                                    else
                                    {
                                        // This group will not run - mark all tasks as skipped
                                        DbAccess.SkipAllTasks(currentGroup.Id);
                                        groupTasks.Clear();
                                        currentGroup = null;
                                        waitTime = 0;
                                        continue;
                                    }
                                }
                            }
                            else
                            {
                                // There are no more tasks for this job - finish the job and report the results
                                JSService.LogEvent(LoggingLevel.Debug, "{0} : Ending job - result = {1}.", Thread.CurrentThread.Name, jobResult);
                                try
                                {
                                    // Mark the job complete in the database
                                    DbAccess.EndJob(job.Id, jobResult);
                                }
                                catch(Exception ex)
                                {
                                    JSService.LogEvent(LoggingLevel.Error, "Marking job {0} complete in the database failed:\r\n{1}", job.Id, ex);
                                }

                                // Send the job report
                                SendJobReport(job, jobResult);

                                if (null != groupTasks)
                                    groupTasks.Clear();
                                currentGroup = null;
                                job = null;
                                jobResult = Result.Succeeded;
                                waitTime = 0;
                                continue;
                            }
                        }

                        // Check to make sure the state of the task is set to 'Ready'. If not, leave it alone.
                        // Adding this check enables an admin to restart a job at a given task and only
                        // run those tasks that have been reset.
                        if (TaskState.Ready != nextTask.State)
                            continue;

                        // Determine the proper run condition for this task
                        RunCondition taskCondition = nextTask.Condition;
                        if (RunCondition.Inherit == taskCondition)
                        {
                            if (currentGroup != null)
                                taskCondition = currentGroup.Condition;
                            else
                                taskCondition = RunCondition.Always;
                        }

                        // Now that we have the condition under which this task will run,
                        // determine if it should actually be run.
                        if (RunCondition.Always == taskCondition ||
                            (RunCondition.IfPassing == taskCondition && Result.Succeeded == jobResult) ||
                            (RunCondition.IfFailing == taskCondition && Result.Failed == jobResult))
                        {
                            // Update the token data
                            DateTime current = DateTime.Now;
                            _tokenData[ParamTokenCurrentTime] = current.ToString("MM/dd/yyyy HH:mm:ss");
                            _tokenData[ParamTokenCurrentTimeGMT] = current.ToUniversalTime().ToString("MM/dd/yyyy HH:mm:ss");
                            _tokenData[ParamTokenJobResult] = jobResult.ToString();
                            
                            // Run the task
                            Result taskResult = RunTask(nextTask, taskCondition, jobResult);
                            if (Result.Succeeded == jobResult)
                                jobResult = taskResult;
                        }
                        else
                        {
                            // Mark the task as skipped
                            DbAccess.SkipTask(nextTask.Id);
                        }
                    }
                    else
                    {
                        long jobId = 0;
                        jobResult = Result.Succeeded;

                        // pull the next job for this environment from the database
                        try
                        {
                            jobId = DbAccess.GetNextAvailableJobId(_envData.Environment);
                        }
                        catch (Exception ex)
                        {
                            JSService.LogEvent(LoggingLevel.Error, "{0} : Unable to retrieve the next job from the database.\r\n\r\n{1}",
                                Thread.CurrentThread.Name, ex);
                            job = null;
                        }

                        if (-1 == jobId)
                        {
                            // The environment has been locked to running jobs
                            if (lockNotifyCounter > LockNotifyThreshold)
                            {
                                JSService.LogEvent(LoggingLevel.Warning, "{0} : The environment has been locked and no jobs can run until it is unlocked.");
                                lockNotifyCounter = 0;
                            }
                            else
                            {
                                lockNotifyCounter++;
                            }
                        }
                        else if (jobId != 0)
                        {
                            JSService.LogEvent(LoggingLevel.Debug, "{0} : Starting job id {1}.", Thread.CurrentThread.Name, jobId);

                            try
                            {
                                // Start the job
                                job = DbAccess.GetJob(jobId);
                                DbAccess.StartJob(jobId);

                                // Update the token data
                                DateTime jobStart = DateTime.Now;
                                _tokenData[ParamTokenJobStartTime] = jobStart.ToString("MM/dd/yyyy HH:mm:ss");
                                _tokenData[ParamTokenJobStartTimeGMT] = jobStart.ToUniversalTime().ToString("MM/dd/yyyy HH:mm:ss");
                            }
                            catch (Exception ex)
                            {
                                JSService.LogEvent(LoggingLevel.Error, "{0} : Unable to start job {1}:\r\n\r\n{2}",
                                    Thread.CurrentThread.Name, job.Id, ex);
                                job = null;
                                continue;
                            }

                            // Set the wait to 0 to immediately start working on tasks
                            waitTime = 0;
                        }

                        if (null == job)
                        {
                            // Put the scheduler to sleep if there are no more jobs in the queue
                            waitTime = QueueSleepLength;
                        }
                    }
                }
            }
            catch (ThreadAbortException)
            {
                // We're being killed - try to cancel the job in the database
                if (job != null)
                {
                    DbAccess.CancelJob(job.Id);
                }
                return;
            }
        }

        private Result RunTask(Task task, RunCondition currentCondition, Result jobResult)
        {
            Result result = Result.Succeeded;
            TaskResult taskResult = new TaskResult();
            taskResult.ExecutedSuccessfully = true;

            JSService.LogEvent(LoggingLevel.Debug, "{0} : Starting task '{1}'.",
                Thread.CurrentThread.Name, task.Name);

            try
            {
                DbAccess.StartTask(task.Id);
            }
            catch (Exception ex)
            {
                JSService.LogEvent(LoggingLevel.Error, "{0} : Unable to start task {1}:\r\n\r\n{2}",
                    Thread.CurrentThread.Name, task.Name, ex);
                taskResult.ExecutedSuccessfully = false;
                taskResult.AddLog(new Log("Unable to start the task:\r\n{0}", ex));
            }

            if (taskResult.ExecutedSuccessfully)
            {
                // Run the task and report the result
                try
                {
                    if (TaskType.Local == task.Type)
                    {
                        // Special case the Wait task since there is no task module for it
                        if (String.Compare(task.Name, "Wait", true) == 0)
                        {
                            try
                            {
                                Thread.Sleep(Int32.Parse(task.Parameters[0].Value) * 1000);
                            }
                            catch (Exception ex)
                            {
                                JSService.LogEvent(LoggingLevel.Error, "{0} : Error sleeping:\r\n\r\n{1}", Thread.CurrentThread.Name, ex);
                            }

                            // This task always succeeds (even if it fails)
                            taskResult.ExecutedSuccessfully = true;
                       } 
                        else
                        {
                            ITaskModule itm = null;

                            try
                            {
                                itm = JSService.TMM.GetModule(task.Module);
                            }
                            catch (Exception ex)
                            {
                                JSService.LogEvent(LoggingLevel.Error, ex.ToString());
                            }

                            if (itm != null)
                            {
                                foreach (Parameter param in task.Parameters)
                                {
                                    if (RunCondition.Always == param.Condition ||
                                        (RunCondition.IfPassing == param.Condition && Result.Succeeded == jobResult) ||
                                        (RunCondition.IfFailing == param.Condition && Result.Failed == jobResult))
                                    {
                                        // Perform token replacements on this parameter
                                        param.Value = ReplaceTokens(param.Value, _tokenData);

                                        if (Parameter.ParameterBlock == param.Name)
                                        {
                                            itm.AddParameters(param.Value);
                                        }
                                        else
                                        {
                                            itm.AddParameter(param.Name, param.Value);
                                        }
                                    }
                                }
                                taskResult = itm.Perform();
                                itm.RemoveAllParameters();
                            }
                        }
                    }
                    else
                    {
                        // Perform token replacements on all parameters before passing them to the remote server
                        foreach (Parameter param in task.Parameters)
                        {
                            param.Value = ReplaceTokens(param.Value, _tokenData);
                        }
                        taskResult = RunRemoteTask(task, currentCondition, jobResult);
                    }
                }
                catch (Exception ex)
                {
                    taskResult.ExecutedSuccessfully = false;
                    taskResult.AddLog(new Log("Unhandled exception while running the task:\r\n{0}", ex));
                }

                // If the task has a LocalLogTarget defined, the remote portion of the path
                // needs to be replaced by the local path
                if (!String.IsNullOrEmpty(task.LocalLogTarget))
                {
                    // Find logs that have a path and filename defined
                    foreach (Log log in taskResult.Logs)
                    {
                        if (!String.IsNullOrEmpty(log.Path))
                        {
                            // Replace the root with the local path
                            string localTarget = log.Path.Replace(Path.GetPathRoot(log.Path), Path.GetPathRoot(task.LocalLogTarget));
                            TaskResult copyResult = null;

                            // Copy the remote log to the local location
                            StringBuilder xmlBlock = new StringBuilder();
                            xmlBlock.AppendLine("<Parameters>");
                            xmlBlock.AppendLine("<FileCommand Action=\"Copy\" FileSpec=\"*.*\" Recurse=\"true\" Force=\"true\" />");
                            xmlBlock.AppendFormat("<SourceLocation Path=\"{0}\" UserName=\"{1}\" Password=\"{2}\" PasswordEncrypted=\"{3}\" />\r\n",
                                log.Path, _envData.UserName, _envData.LocalPassword.Password, _envData.LocalPassword.IsEncrypted);
                            xmlBlock.AppendFormat("<DestLocation Path=\"{0}\" />\r\n", localTarget);
                            xmlBlock.AppendLine("</Parameters>");

                            try
                            {
                                ITaskModule ftm = JSService.TMM.GetModule("FileTaskModule");
                                ftm.AddParameters(xmlBlock.ToString());
                                copyResult = ftm.Perform();
                            }
                            catch (Exception ex)
                            {
                                JSService.LogEvent(LoggingLevel.Error,
                                    "Unable to copy the remote log files from {0} to {1}:\r\n{2}",
                                    log.Path, localTarget, ex);
                                continue;
                            }

                            if (copyResult.ExecutedSuccessfully)
                            {
                                // Replace the path stored in the log with the local path
                                log.Path = localTarget;
                            }
                            else
                            {
                                StringBuilder msg = new StringBuilder();
                                msg.AppendFormat("Unable to copy the remote log files from {0} to {1}.\r\n",
                                    log.Path, localTarget);
                                foreach (Log copyLog in copyResult.Logs)
                                    msg.AppendLine(copyLog.ToString());

                                JSService.LogEvent(LoggingLevel.Error, msg.ToString());
                            }
                        }
                    }
                }

                JSService.LogEvent(LoggingLevel.Debug, "{0} : Ending task '{1}'. Result = {2}",
                    Thread.CurrentThread.Name, task.Name, taskResult.ExecutedSuccessfully ? Result.Succeeded : Result.Failed);
                try
                {
                    DbAccess.EndTask(task.Id, taskResult.ExecutedSuccessfully ? Result.Succeeded : Result.Failed, taskResult.Logs);
                }
                catch (Exception ex)
                {
                    JSService.LogEvent(LoggingLevel.Error, "{0} : Unable to end task {1}:\r\n\r\n{2}",
                        Thread.CurrentThread.Name, task.Name, ex);
                }

                // Update the result
                if (!taskResult.ExecutedSuccessfully)
                {
                    result = Result.Failed;
                }
            }

            return result;
        }

        private TaskResult RunRemoteTask(Task task, RunCondition currentCondition, Result jobResult)
        {
            TaskResult result = null;

            // We need to create a network connection to the remote server prior to creating the named pipe.
            // This is because the remote server resides on a different domain and we need to send credentials.
            try
            {
                NetworkDrive.MapNetworkDrive(@"\\" + _envData.AgentServerIP + @"\c$", null, _envData.UserName, _envData.LocalPassword.ToString());
            }
            catch (Exception ex)
            {
                JSService.LogEvent(LoggingLevel.Warning, "RunRemoteTask: Creating a drive mapping to '{0}' failed - the connection to the named pipe may fail, too.\r\n\r\n{1}",
                    _envData.AgentServer, ex);
            }

            using (NamedPipeClientStream npStream = new NamedPipeClientStream(_envData.AgentServerIP, DACommon.AgentPipeName, PipeDirection.InOut,
                PipeOptions.WriteThrough, System.Security.Principal.TokenImpersonationLevel.Anonymous))
            {
                byte[] rwBuffer = new Byte[64];

                npStream.Connect(RemoteConnectionTimeout);
                if (npStream.IsConnected)
                {
                    // Send the environment name as the client ID
                    try
                    {
                        rwBuffer = UnicodeEncoding.Unicode.GetBytes(_envData.Environment);
                        npStream.Write(rwBuffer, 0, rwBuffer.Length);
                        npStream.WaitForPipeDrain();
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(JSService.EVENT_SOURCE, LoggingLevel.Error, "[{0}] Error sending client identification:\r\n\r\n{1}", Thread.CurrentThread.Name, ex);
                    }

                    try
                    {
                        // First send the command type to the server
                        rwBuffer = UnicodeEncoding.Unicode.GetBytes(DACommon.AgentRemoteTask);
                        npStream.Write(rwBuffer, 0, rwBuffer.Length);
                        npStream.WaitForPipeDrain();

                        // Send the task information to the server
                        IFormatter formatter = new BinaryFormatter();
                        formatter.Serialize(npStream, new RemoteTask(task, currentCondition, jobResult));

                        // Wait for the resulting TaskResult object
                        result = formatter.Deserialize(npStream) as TaskResult;
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(JSService.EVENT_SOURCE, LoggingLevel.Error, "[{0}] Error communicating with the remote server:\r\n\r\n{1}", Thread.CurrentThread.Name, ex);
                        result = new TaskResult();
                        result.ExecutedSuccessfully = false;
                        result.AddLog(new Log("[{0}] Error communicating with the remote server:\r\n{1}", Thread.CurrentThread.Name, ex));
                    }
                }
                else
                {
                    result = new TaskResult();
                    result.ExecutedSuccessfully = false;
                    result.AddLog(new Log("[{0}] Unable to run the remote task '{1}' on '{2}'. The timeout expired waiting to connect to the remote server.",
                        Thread.CurrentThread.Name, task.Name, _envData.AgentServer));
                }
            }

            try
            {
                NetworkDrive.UnMapNetworkDrive(@"\\" + _envData.AgentServerIP + @"\c$", true);
            }
            catch (Exception ex)
            {
                JSService.LogEvent(LoggingLevel.Warning, "RunRemoteTask: Unmapping the drive from '{0}' failed:\r\n{1}",
                    _envData.AgentServer, ex);
            }

            return result;
        }

        private void SendJobReport(Job job, Result jobResult)
        {
            // Pull the job report settings from the database
            JobReport report = null;
            try
            {
                report = DbAccess.GetJobReport(job.Id);
            }
            catch (Exception ex)
            {
                JSService.LogEvent(LoggingLevel.Error, "Unable to retrieve the report definition for Job {0}:\r\n{1}",
                    job.Id, ex);
            }

            if (report != null)
            {
                // Check the run condition for the report
                if (RunCondition.Always == report.Condition ||
                    (RunCondition.IfPassing == report.Condition && Result.Succeeded == jobResult) ||
                    (RunCondition.IfFailing == report.Condition && Result.Failed == jobResult))
                {
                    string html = null;
                    string text = null;
                    try
                    {
                        // We need to pass the job Id so that the latest information about the
                        // job is pulled from the database before generating the report.
                        XmlDocument xmlReportFile = XMLResultWriter.GenerateReport(job.Id, report.HistoryMaxDays, report.HistoryMaxJobs);
                        string reportDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Reports");
                        try
                        {
                            if (!Directory.Exists(reportDir))
                                Directory.CreateDirectory(reportDir);
                            xmlReportFile.Save(Path.Combine(reportDir, String.Format("{0}_{1}_{2}.xml", job.Environment, job.Build, job.BuildVersion)));
                        }
                        catch (Exception ex)
                        {
                            JSService.LogEvent(LoggingLevel.Warning, "Unable to save the results file for build {0} in {1}:\r\n{2}",
                                job.Build, job.Environment, ex);
                        }

                        if (String.IsNullOrEmpty(report.XsltName))
                        {
                            text = xmlReportFile.OuterXml;
                        }
                        else
                        {
                            html = XMLResultWriter.Transform(xmlReportFile, report.XsltName);
                        }
                    }
                    catch (Exception ex)
                    {
                        JSService.LogEvent(LoggingLevel.Error, "Unable to generate a results report for job {0}:\r\n{1}",
                            job.Id, ex);
                    }

                    // Get the list of attachments for this status mail
                    // We'll attach everything located in the Logs\<Environment>\PostMortem\<JobID> folder
                    string folder = String.Format(@"G:\Logs\{0}\PostMortem\{1}", job.Environment, job.Id);
                    string[] attachmentFiles = null;
                    if (Directory.Exists(folder))
                    {
                        attachmentFiles = Directory.GetFiles(folder);
                    }

                    try
                    {
                        ResultsMailer.SendResultsMail(
                            report.ToList,
                            report.CcList,
                            report.BccList,
                            String.Format("{0} : {1} [{2}]", jobResult, job.Name, job.BuildVersion),
                            text,
                            html,
                            attachmentFiles,
                            (Result.Failed == jobResult ? System.Net.Mail.MailPriority.High : System.Net.Mail.MailPriority.Normal));
                    }
                    catch (Exception ex)
                    {
                        JSService.LogEvent(LoggingLevel.Error, "Unable to send the results report for job {0}:\r\n{1}", job.Id, ex);
                    }
                }
                else
                {
                    JSService.LogEvent(LoggingLevel.Warning,
                        "The report for job {0} is marked '{1}' and the job result is '{2}', so the report was not generated.",
                        job.Id, report.Condition, jobResult);
                }
            }
        }

        private string ReplaceTokens(string tokenizedString, Dictionary<string, string> tokenData)
        {
            string ret = tokenizedString;

            if (tokenizedString.Contains("##"))
            {
                foreach (KeyValuePair<string, string> kvp in tokenData)
                {
                    if (ret.Contains(kvp.Key))
                        ret = ret.Replace(kvp.Key, kvp.Value);
                }
            }

            return ret;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\DBAccess.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.jsservice
{
    public static class DbAccess
    {
        private static string ConnectionString { get; set; }
        public static string Server { get; private set; }
        public static string Database { get; private set; }

        public static void Init(string server, string database)
        {
            if (String.IsNullOrEmpty(server))
                throw new ArgumentException("Invalid server string. The string must not be null or zero-length.");
            if (String.IsNullOrEmpty(database))
                throw new ArgumentException("Invalid database string. The string must not be null or zero-length.");

            Server = server;
            Database = database;
            ConnectionString = String.Format("server={0};database={1};Integrated Security=SSPI;MultipleActiveResultSets=True", server, database);
        }

        public static EnvironmentData LoadEnvironmentData(string envName)
        {
            EnvironmentData env = null;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_env_get_environment";
                    cmd.Parameters.AddWithValue("@envName", envName);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        if (reader.Read())
                        {
                            env = new EnvironmentData();
                            env.Id = reader.GetInt64(0);
                            env.Environment = reader.GetString(1);
                            env.AgentServer = reader.GetString(2);
                            env.UserName = reader.GetString(5);
                            GetPasswords(env);
                        }
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return env;
        }

        private static void GetPasswords(EnvironmentData envData)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_env_get_passwords";
                    cmd.Parameters.AddWithValue("@envId", envData.Id);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            PasswordType type = (PasswordType)reader.GetByte(3);
                            if (PasswordType.Local == type)
                            {
                                envData.LocalPassword = new EnvironmentPassword();
                                envData.LocalPassword.Password = reader.GetString(1);
                                envData.LocalPassword.ContextServer = reader.GetString(2);
                                envData.LocalPassword.Type = PasswordType.Local;
                                envData.LocalPassword.IsEncrypted = reader.GetBoolean(4);
                            }
                            else
                            {
                                envData.RemotePassword = new EnvironmentPassword();
                                envData.RemotePassword.Password = reader.GetString(1);
                                envData.RemotePassword.ContextServer = reader.GetString(2);
                                envData.RemotePassword.Type = PasswordType.Remote;
                                envData.RemotePassword.IsEncrypted = reader.GetBoolean(4);
                            }
                        }
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }
        }

        //
        //  This section contains all data access methods that are job-specific.
        //

        #region Job Methods

        public static Job GetJob(long jobId)
        {
            Job job = null;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        if (reader.Read())
                        {
                            job = new Job();
                            job.Id = jobId;
                            job.Name = reader["vc_job_name"] as string;
                            job.Environment = reader["vc_environment_name"] as string;
                            job.Build = reader["vc_build_name"] as string;
                            job.BuildVersion = reader["vc_version"] as string;
                            job.Type = (JobType)reader["ti_job_type"];
                            job.Creator = reader["vc_requestor_username"] as string;
                            job.CreateDate = (DateTime)reader["dt_create_date"];
                            job.Priority = (JobPriority)reader["ti_priority"];
                            job.State = (JobState)reader["ti_job_state"];
                            job.Result = (Result)reader["ti_job_result"];
                            job.LogBase = reader["vc_log_base"] as string;
                            if (!(reader["dt_job_start_date"] is DBNull))
                                job.StartDate = (DateTime)reader["dt_job_start_date"];
                            if (!(reader["dt_job_end_date"] is DBNull))
                                job.EndDate = (DateTime)reader["dt_job_end_date"];
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_get_job", Server, Database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return job;
        }

        public static JobState GetJobState(long jobId)
        {
            JobState state = JobState.NotReady;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_state";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    cmd.Parameters.Add("@state", SqlDbType.TinyInt).Direction = ParameterDirection.Output;

                    try
                    {
                        cmd.ExecuteNonQuery();
                        if (cmd.Parameters[1].Value != null)
                        {
                            state = (JobState)Convert.ToByte(cmd.Parameters[1].Value);
                        }
                    }
                    catch (Exception ex)
                    {
                        throw new DBAccessException("p_job_get_state", Server, Database, ex);
                    }
                }
            }

            return state;
        }

        public static Result GetJobResult(long jobId)
        {
            Result result = Result.NotRun;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_result";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    cmd.Parameters.Add("@result", SqlDbType.TinyInt).Direction = ParameterDirection.Output;

                    try
                    {
                        cmd.ExecuteNonQuery();
                        if (cmd.Parameters[1].Value != null)
                        {
                            result = (Result)Convert.ToByte(cmd.Parameters[1].Value);
                        }
                    }
                    catch (Exception ex)
                    {
                        throw new DBAccessException("p_job_get_result", Server, Database, ex);
                    }
                }
            }

            return result;
        }

        public static long GetNextAvailableJobId(string envName)
        {
            long jobId = 0;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_next_available_job_id";
                    cmd.Parameters.AddWithValue("@environment", envName);
                    cmd.Parameters.Add("@jobid", SqlDbType.BigInt).Direction = ParameterDirection.Output;

                    try
                    {
                        cmd.ExecuteNonQuery();
                        if (cmd.Parameters[1].Value != null)
                        {
                            jobId = (Int64)cmd.Parameters[1].Value;
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_get_next_available_job_id", Server, Database, ex);
                    }
                }
            }

            return jobId;
        }

        public static void StartJob(long jobId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_start_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_start_job", Server, Database, ex);
                    }
                }
            }
        }

        public static void EndJob(long jobId, Result result)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_end_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    cmd.Parameters.AddWithValue("@jobresult", (byte)result);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_end_job", Server, Database, ex);
                    }
                }
            }
        }

        public static void CancelJob(long jobId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_cancel_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_cancel_job", Server, Database, ex);
                    }
                }
            }
        }

        public static void PauseJob(long jobId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_pause_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_pause_job", Server, Database, ex);
                    }
                }
            }
        }

        public static void ResumeJob(long jobId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_resume_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_resume_job", Server, Database, ex);
                    }
                }
            }
        }

        public static void DeleteJob(long jobId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_delete_job";
                    cmd.Parameters.AddWithValue("@jobid", jobId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_delete_job", Server, Database, ex);
                    }
                }
            }
        }

        public static bool IsJobPaused(long jobId)
        {
            bool paused = false;

            // We do NOT want this method to throw an exception (as much as possible).
            // If an exception does occur, just return FALSE.
            try
            {
                using (SqlConnection conn = new SqlConnection(ConnectionString))
                {
                    try
                    {
                        conn.Open();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBConnectException(Server, Database, ex);
                    }

                    using (SqlCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = "p_job_get_state";
                        cmd.Parameters.AddWithValue("@jobId", jobId);
                        cmd.Parameters.Add("@state", SqlDbType.TinyInt).Direction = ParameterDirection.Output;

                        cmd.ExecuteNonQuery();
                        if (cmd.Parameters[1].Value != null)
                            paused = ((byte)cmd.Parameters[1].Value == (byte)JobState.Paused);
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "Error getting the state for job id {0}:\r\n{1}", jobId, ex);
            }

            return paused;
        }

        public static Task GetNextTask(long jobId)
        {
            Task task = null;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_next_task";
                    cmd.Parameters.AddWithValue("@jobId", jobId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        if (reader.Read())
                        {
                            task = new Task();
                            task.Id = reader.GetInt64(0);
                            task.Group = reader.GetInt64(1);
                            task.RunOrder = reader.GetInt32(2);
                            task.Name = reader.GetString(3);
                            task.Module = reader.GetString(4);
                            if (!reader.IsDBNull(5))
                                task.StartDate = reader.GetDateTime(5);
                            if (!reader.IsDBNull(6))
                                task.EndDate = reader.GetDateTime(6);
                            task.State = (TaskState)reader.GetByte(7);
                            task.Result = (Result)reader.GetByte(8);
                            task.Type = (TaskType)reader.GetByte(9);
                            task.Condition = (RunCondition)reader.GetByte(10);
                            if (!reader.IsDBNull(11))
                                task.LocalLogTarget = reader.GetString(11);

                            // Get the parameters for this task
                            task.AddParameterList(GetTaskParameters(task.Id));
                        }
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_job_get_next_task", Server, Database, sqlEx);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return task;
        }

        public static List<TaskGroup> GetJobTaskGroups(long jobId)
        {
            List<TaskGroup> taskGroups = new List<TaskGroup>();

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_group_list";
                    cmd.Parameters.AddWithValue("@jobId", jobId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            TaskGroup tg = new TaskGroup();
                            tg.Id = reader.GetInt64(0);
                            tg.JobId = jobId;
                            tg.Name = reader.GetString(1);
                            tg.Condition = (RunCondition)reader.GetByte(2);
                            tg.Rollup = reader.GetBoolean(3);
                            taskGroups.Add(tg);
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_get_group_list", Server, Database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return taskGroups;
        }

        public static List<Task> GetJobTasks(long jobId)
        {
            List<Task> tasks = new List<Task>();

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_task_list";
                    cmd.Parameters.AddWithValue("@jobId", jobId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            Task task = new Task();
                            task.Id = reader.GetInt64(0);
                            task.Group = reader.GetInt64(1);
                            task.RunOrder = reader.GetInt32(2);
                            task.Name = reader.GetString(3);
                            task.Module = reader.GetString(4);
                            if (!reader.IsDBNull(5))
                                task.StartDate = reader.GetDateTime(5);
                            if (!reader.IsDBNull(6))
                                task.EndDate = reader.GetDateTime(6);
                            task.State = (TaskState)reader.GetByte(7);
                            task.Result = (Result)reader.GetByte(8);
                            task.Type = (TaskType)reader.GetByte(9);
                            task.Condition = (RunCondition)reader.GetByte(10);
                            if (!reader.IsDBNull(11))
                                task.LocalLogTarget = reader.GetString(11);
                            tasks.Add(task);
                        }
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_job_get_task_list", Server, Database, sqlEx);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return tasks;
        }

        public static List<TaskLog> GetJobLogs(long jobId)
        {
            List<TaskLog> taskLogs = new List<TaskLog>();

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_job_logs";
                    cmd.Parameters.AddWithValue("@jobId", jobId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            TaskLog tl = new TaskLog();
                            tl.TaskId = reader.GetInt64(0);
                            if (!reader.IsDBNull(1))
                                tl.LogFile = reader.GetString(1);
                            if (!reader.IsDBNull(2))
                                tl.LogPath = reader.GetString(2);
                            if (!reader.IsDBNull(3))
                                tl.LogText = reader.GetString(3);
                            taskLogs.Add(tl);
                        }
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_job_get_job_logs", Server, Database, sqlEx);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return taskLogs;
        }

        public static JobReport GetJobReport(long jobId)
        {
            JobReport report = null;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_report";
                    cmd.Parameters.AddWithValue("@jobId", jobId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        if (reader.Read())
                        {
                            report = new JobReport();
                            report.ReportId = reader.GetInt64(0);
                            report.JobId = jobId;
                            report.ToList = reader.GetString(2);
                            if (!reader.IsDBNull(3))
                                report.CcList = reader.GetString(3);
                            if (!reader.IsDBNull(4))
                                report.BccList = reader.GetString(4);
                            if (!reader.IsDBNull(5))
                                report.XsltName = reader.GetString(5);
                            report.Condition = (RunCondition)reader.GetByte(6);
                            if (!reader.IsDBNull(7))
                                report.HistoryMaxDays = reader.GetByte(7);
                            if (!reader.IsDBNull(8))
                                report.HistoryMaxJobs = reader.GetByte(8);
                        }
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_job_get_report", Server, Database, sqlEx);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return report;
        }

        public static List<Job> GetJobHistory(string env, string build, JobType type, byte maxDays, byte maxJobs)
        {
            List<Job> jobHistory = new List<Job>();

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_job_get_result_history";
                    cmd.Parameters.AddWithValue("@environment", env);
                    cmd.Parameters.AddWithValue("@build", build);
                    cmd.Parameters.AddWithValue("@jobType", (byte)type);
                    cmd.Parameters.AddWithValue("@maxDays", maxDays);
                    cmd.Parameters.AddWithValue("@maxJobs", maxJobs);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            Job job = new Job();
                            job.Id = reader.GetInt64(0);
                            job.Environment = reader.GetString(1);
                            job.Build = reader.GetString(2);
                            job.Name = reader.GetString(3);
                            job.Type = (JobType)reader.GetByte(4);
                            job.Creator = reader.GetString(5);
                            job.CreateDate = reader.GetDateTime(6);
                            job.Priority = (JobPriority)reader.GetByte(7);
                            if (!reader.IsDBNull(8))
                                job.StartDate = reader.GetDateTime(8);
                            if (!reader.IsDBNull(9))
                                job.EndDate = reader.GetDateTime(9);
                            job.State = (JobState)reader.GetByte(10);
                            job.Result = (Result)reader.GetByte(11);
                            job.BuildVersion = reader.GetString(12);
                            jobHistory.Add(job);
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_job_get_result_history", Server, Database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return jobHistory;
        }

        #endregion

        //
        //  This section contains all data access methods that are task-specific.
        //

        #region Task Methods

        public static TaskGroup GetTaskGroupInfo(long groupId)
        {
            TaskGroup group = null;

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_group_get_group";
                    cmd.Parameters.AddWithValue("@groupId", groupId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        if (reader.Read())
                        {
                            group = new TaskGroup();
                            group.Id = groupId;
                            group.JobId = reader.GetInt64(0);
                            group.Name = reader.GetString(1);
                            group.Condition = (RunCondition)reader.GetByte(2);
                            group.Rollup = reader.GetBoolean(3);
                        }
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_group_get_group", Server, Database, sqlEx);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return group;
        }

        public static List<Task> GetGroupTasks(long groupId)
        {
            List<Task> tasks = new List<Task>();

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_group_get_tasks";
                    cmd.Parameters.AddWithValue("@groupId", groupId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            Task task = new Task();
                            task.Id = reader.GetInt64(0);
                            task.Group = reader.GetInt64(1);
                            task.RunOrder = reader.GetInt32(2);
                            task.Name = reader.GetString(3);
                            task.Module = reader.GetString(4);
                            if (!reader.IsDBNull(5))
                                task.StartDate = reader.GetDateTime(5);
                            if (!reader.IsDBNull(6))
                                task.EndDate = reader.GetDateTime(6);
                            task.State = (TaskState)reader.GetByte(7);
                            task.Result = (Result)reader.GetByte(8);
                            task.Type = (TaskType)reader.GetByte(9);
                            task.Condition = (RunCondition)reader.GetByte(10);
                            if (!reader.IsDBNull(11))
                                task.LocalLogTarget = reader.GetString(11);

                            // Get the parameters for this task
                            task.AddParameterList(GetTaskParameters(task.Id));

                            tasks.Add(task);
                        }
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_group_get_tasks", Server, Database, sqlEx);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return tasks;
        }

        public static void SkipTask(long taskId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_task_skip_task";
                    cmd.Parameters.AddWithValue("@taskId", taskId);

                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_task_skip_task", Server, Database, sqlEx);
                    }
                }
            }
        }

        public static void SkipAllTasks(long groupId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_group_skip_tasks";
                    cmd.Parameters.AddWithValue("@groupId", groupId);

                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException sqlEx)
                    {
                        throw new DBAccessException("p_group_skip_tasks", Server, Database, sqlEx);
                    }
                }
            }
        }

        public static void StartTask(long taskId)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_task_start_task";
                    cmd.Parameters.AddWithValue("@taskid", taskId);
                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_task_start_task", Server, Database, ex);
                    }
                }
            }
        }

        public static void EndTask(long taskId, Result result, Log[] logs)
        {
            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                // Use a transaction to update the task and its associated logs
                using (SqlTransaction tran = conn.BeginTransaction(IsolationLevel.ReadCommitted))
                {
                    using (SqlCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = "p_task_end_task";
                        cmd.Transaction = tran;
                        cmd.Parameters.AddWithValue("@taskid", taskId);
                        cmd.Parameters.AddWithValue("@taskresult", result);
                        try
                        {
                            cmd.ExecuteNonQuery();
                        }
                        catch (SqlException ex)
                        {
                            tran.Rollback();
                            tran.Dispose();
                            throw new DBAccessException("p_task_end_task", Server, Database, ex);
                        }
                    }

                    if (logs != null)
                    {
                        using (SqlCommand cmd = conn.CreateCommand())
                        {
                            cmd.CommandType = CommandType.StoredProcedure;
                            cmd.CommandText = "p_task_add_task_log";
                            cmd.Transaction = tran;
                            cmd.Parameters.AddWithValue("@taskid", taskId);
                            cmd.Parameters.Add("@logfilename", SqlDbType.NVarChar);
                            cmd.Parameters.Add("@logfilepath", SqlDbType.NVarChar);
                            cmd.Parameters.Add("@logfiledata", SqlDbType.Text);

                            try
                            {
                                for (int i = 0; i < logs.Length; i++)
                                {
                                    if (String.IsNullOrEmpty(logs[i].FileName))
                                        cmd.Parameters[1].Value = DBNull.Value;
                                    else
                                        cmd.Parameters[1].Value = logs[i].FileName;
                                    if (String.IsNullOrEmpty(logs[i].Path))
                                        cmd.Parameters[2].Value = DBNull.Value;
                                    else
                                        cmd.Parameters[2].Value = logs[i].Path;
                                    if (String.IsNullOrEmpty(logs[i].Text))
                                        cmd.Parameters[3].Value = DBNull.Value;
                                    else
                                        cmd.Parameters[3].Value = logs[i].Text;

                                    cmd.ExecuteNonQuery();
                                }
                            }
                            catch (Exception ex)
                            {
                                tran.Rollback();
                                throw new DBAccessException("p_task_add_task_log", Server, Database, ex);
                            }
                        }
                    }

                    // Commit the transaction
                    tran.Commit();
                }
            }
        }

        public static List<Parameter> GetTaskParameters(long taskId)
        {
            List<Parameter> parameters = new List<Parameter>();

            using (SqlConnection conn = new SqlConnection(ConnectionString))
            {
                try
                {
                    conn.Open();
                }
                catch (SqlException ex)
                {
                    throw new DBConnectException(Server, Database, ex);
                }

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    SqlDataReader reader = null;

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandText = "p_task_get_task_parameters";
                    cmd.Parameters.AddWithValue("@taskid", taskId);

                    try
                    {
                        reader = cmd.ExecuteReader();
                        while (reader.Read())
                        {
                            Parameter param = new Parameter();
                            param.Name = reader.GetString(0);
                            param.Value = reader.GetString(1);
                            param.Condition = (RunCondition)reader.GetByte(2);
                            parameters.Add(param);
                        }
                    }
                    catch (SqlException ex)
                    {
                        throw new DBAccessException("p_task_get_task_parameters", Server, Database, ex);
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                    }
                }
            }

            return parameters;
        }

        #endregion
    }

    public class DBConnectException : Exception
    {
        public DBConnectException(string server, string database, Exception ex)
            : base(String.Format("Unable to connect to database.\r\nServer={0}; Database={1}",
           server, database), ex) { }
    }

    public class DBAccessException : Exception
    {
        public DBAccessException(string sproc, string server, string database, Exception ex)
            : base(String.Format("Request ({0}) to the database failed.\r\nServer={1}; Database={2}",
           sproc, server, database), ex) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\JSSInstaller.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.ServiceProcess;
using Microsoft.Win32;

namespace xonline.test.deployment.automation.jsservice
{
    [RunInstaller(true)]
    public class JSSInstaller : Installer
    {
        private ServiceProcessInstaller _processInstaller;
        private ServiceInstaller _jsServiceInstaller;

        public JSSInstaller()
        {
            _processInstaller = new ServiceProcessInstaller();
            _processInstaller.Account = ServiceAccount.User;

            _jsServiceInstaller = new ServiceInstaller();
            _jsServiceInstaller.ServiceName = "JSService";
            _jsServiceInstaller.DisplayName = "Deployment Automation Job Scheduler";
            _jsServiceInstaller.Description = "Runs deployment automation jobs in all supported environments.";
            _jsServiceInstaller.StartType = ServiceStartMode.Automatic;

            Installers.Add(_jsServiceInstaller);
            Installers.Add(_processInstaller);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\ResultsMailer.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Mail;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.jsservice
{
	public class ResultsMailer
	{
        private const string SMTP_HOST_NAME = "smtphost.redmond.corp.microsoft.com";
        private const string EMAIL_DOMAIN_NAME = "@microsoft.com";
        private const int MAX_RETRIES = 2;

        public static void SendResultsMail(string to, string subject, string body)
        {
            SendResultsMail(to, null, null, subject, body, null, null, MailPriority.Normal);
        }

        public static void SendResultsMail(string to, string cc, string bcc, string subject, string textBody, string htmlBody, string[] attachmentList, MailPriority priority)
        {
            AlternateView av;
            bool hasTextBody = !String.IsNullOrEmpty(textBody);
            bool hasHTMLBody = !String.IsNullOrEmpty(htmlBody);

            if (!(hasHTMLBody || hasTextBody))
            {
                throw new ApplicationException("There is not a valid message body specified.");
            }

            MailMessage msg = new MailMessage();
            msg.From = new MailAddress(Environment.UserName + EMAIL_DOMAIN_NAME);
            msg.To.Add(NormalizeEmailAddressList(to));
            if (!String.IsNullOrEmpty(cc))
                msg.CC.Add(NormalizeEmailAddressList(cc));
            if (!String.IsNullOrEmpty(bcc))
                msg.Bcc.Add(NormalizeEmailAddressList(bcc));
            msg.Subject = subject;
            msg.Body = hasTextBody ? textBody : htmlBody;
            msg.IsBodyHtml = !hasTextBody;
            msg.BodyEncoding = new ASCIIEncoding();
            msg.Priority = priority;

            // Create an alternate view only if both a text body and an HTML body have been specified
            if (hasHTMLBody && !msg.IsBodyHtml)
            {
                av = AlternateView.CreateAlternateViewFromString(htmlBody);
                av.ContentType.MediaType = System.Net.Mime.MediaTypeNames.Text.Html;
                av.TransferEncoding = System.Net.Mime.TransferEncoding.QuotedPrintable;
                msg.AlternateViews.Add(av);
            }

            // Add any Attachment files to the message
            if (null != attachmentList)
            {
                foreach (string file in attachmentList)
                {
                    if (String.IsNullOrEmpty(file))
                        continue;
                    string fullPath = Path.GetFullPath(file);

                    if (File.Exists(fullPath))
                    {
                        string mediaType;
                        switch(Path.GetExtension(fullPath).ToLower())
                        {
                            case ".zip":
                                mediaType = System.Net.Mime.MediaTypeNames.Application.Zip;
                                break;
                            case ".rtf":
                                mediaType = System.Net.Mime.MediaTypeNames.Application.Rtf;
                                break;
                            case ".pdf":
                                mediaType = System.Net.Mime.MediaTypeNames.Application.Pdf;
                                break;
                            default:
                                mediaType = System.Net.Mime.MediaTypeNames.Application.Octet;
                                break;
                        }

                        Attachment attachment = new Attachment(fullPath, mediaType);
                        attachment.ContentDisposition.CreationDate = File.GetCreationTime(fullPath);
                        attachment.ContentDisposition.ModificationDate = File.GetLastWriteTime(fullPath);
                        attachment.ContentDisposition.ReadDate = File.GetLastAccessTime(fullPath);
                        msg.Attachments.Add(attachment);
                    }
                    else
                    {
                        DACommon.LogEvent(LoggingLevel.Warning, "Attachment file '{0}' does not exist.", fullPath);
                    }
                }
            }

            SmtpClient client = new SmtpClient(SMTP_HOST_NAME);
            client.UseDefaultCredentials = true;

            int retries = 0;
            while (true)
            {
                try
                {
                    client.Send(msg);
                    break;
                }
                catch (SmtpException ex)
                {
                    if (retries < MAX_RETRIES)
                    {
                        DACommon.LogEvent(LoggingLevel.Warning,
                            "Attempt {0} to send email to '{1}' failed.\r\n\r\n{2}",
                            ++retries, to, ex);
                        System.Threading.Thread.Sleep(500);
                    }
                    else
                    {
                        throw ex;
                    }
                }
            }
        }

        private static string NormalizeEmailAddressList(string addrList)
        {
            string[] addrs = addrList.Split(new char[] { ',', ';' });
            StringBuilder sb = new StringBuilder();

            // Make sure every address has a domain name
            foreach (string addr in addrs)
            {
                if (addr.Contains("@"))
                    sb.Append(addr);
                else
                    sb.AppendFormat("{0}{1}", addr, EMAIL_DOMAIN_NAME);
                sb.Append(',');
            }

            // Remove the trailing comma
            if (sb.Length > 1)
                sb.Length--;

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\JSService.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.ServiceProcess;
using System.Text;
using System.Threading;
using System.Xml.XPath;
using Microsoft.Win32;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.jsservice
{
    public partial class JSService : XLFServiceBase
    {
        internal const string EVENT_SOURCE = "JSService";

        private string _server;
        private string _database;
        private Dictionary<string, JobScheduler> _schedulers;

        public JSService() : base()
        {
            CanStop = true;
            CanShutdown = true;
            CanPauseAndContinue = true;
            ServiceName = EVENT_SOURCE;
            AutoLog = false;

            // Add command handlers
            AddCommandHandler("ListSchedulers", OnListSchedulers);
            AddCommandHandler("RestartScheduler", OnRestartScheduler);
        }

        internal static TaskModuleManager TMM { get; private set; }
        new internal static void LogEvent(LoggingLevel level, string msg, params object[] args)
        {
            DACommon.LogEvent(EVENT_SOURCE, level, msg, args);
        }

        protected override void OnStart(string[] args)
        {
            // Calling the base starts the communication thread
            base.OnStart(args);

            _schedulers = new Dictionary<string, JobScheduler>();
            try
            {
                // Load the settings
                LoadSettings();
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Error, "Unable to load service settings:\r\n\r\n{0}", ex);
                this.Stop();
            }

            try
            {
                // Initialize the data source
                DbAccess.Init(_server, _database);
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Warning, "Unable to initialize the data source:\r\n\r\n{0}", ex);
                this.Stop();
            }

            // Load the task modules
            try
            {
                TMM = new TaskModuleManager();
                TMM.LoadTaskDLLs(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "TaskModules"));
            }
            catch (Exception ex)
            {
                LogEvent(LoggingLevel.Error, "Error loading the task modules:\r\n\r\n{0}", ex);
                this.Stop();
            }

            // Start the job schedulers
            foreach (KeyValuePair<string, JobScheduler> kvp in _schedulers)
            {
                if (kvp.Key.Length > 0)
                {
                    try
                    {
                        kvp.Value.Start();
                    }
                    catch (Exception ex)
                    {
                        LogEvent(LoggingLevel.Error, "Unable to start the scheduler for {0}:\r\n{1}", kvp.Key, ex);
                    }
                }
                else
                {
                    LogEvent(LoggingLevel.Warning, "Unable to start a job scheduler for a zero-length environment name.");
                }
            }

            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
            LogEvent(LoggingLevel.Information, "{0} version {1} started successfully.", ServiceName, fvi.ProductVersion);
        }

        protected override void OnPause()
        {
            if (_schedulers != null)
            {
                foreach (KeyValuePair<string, JobScheduler> kvp in _schedulers)
                {
                    kvp.Value.Pause();
                }
            }
        }

        protected override void OnContinue()
        {
            if (_schedulers != null)
            {
                foreach (KeyValuePair<string, JobScheduler> kvp in _schedulers)
                {
                    kvp.Value.Resume();
                }
            }
        }

        protected override void OnStop()
        {
            LogEvent(LoggingLevel.Information, "{0} stopping.", ServiceName);
            if (_schedulers != null)
            {
                foreach (KeyValuePair<string, JobScheduler> kvp in _schedulers)
                {
                    // wait up to 30-seconds per thread for shutdown
                    kvp.Value.Shutdown(30000);
                }
            }

            // Stop the communication thread
            base.OnStop();
        }

        private void LoadSettings()
        {
            string settingsPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, ServiceName + ".xml");
            if (!File.Exists(settingsPath))
            {
                LogEvent(LoggingLevel.Error, "Unable to locate {0}.xml in {1}", ServiceName, AppDomain.CurrentDomain.BaseDirectory);
                return;
            }

            XPathDocument doc = new XPathDocument(settingsPath);
            XPathNavigator docNav = doc.CreateNavigator();
            docNav.MoveToChild(XPathNodeType.Element);
            if (docNav.Name != ServiceName)
            {
                LogEvent(LoggingLevel.Error, "Invalid settings file - The root element name is not '{0}'", ServiceName);
                return;
            }

            XPathNavigator node = docNav.SelectSingleNode("child::DataSource");
            if (node != null)
            {
                _server = node.GetAttribute("Server", node.NamespaceURI) as string;
                _database = node.GetAttribute("Database", node.NamespaceURI) as string;
            }
            else
            {
                LogEvent(LoggingLevel.Error, "Invalid settings file - The DataSource element is missing");
                return;
            }

            XPathNodeIterator itor = docNav.Select("Environments/Environment");
            if (itor.Count == 0)
                LogEvent(LoggingLevel.Warning, "There are no supported environments defined in the settings file.");

            while (itor.MoveNext())
            {
                try
                {
                    string envName = itor.Current.GetAttribute("Name", docNav.NamespaceURI);
                    if (!_schedulers.ContainsKey(envName))
                    {
                        _schedulers.Add(envName, new JobScheduler(envName));
                    }
                }
                catch (Exception ex)
                {
                    LogEvent(LoggingLevel.Error, "Error loading the JSService settings file - processing the Environments failed:\r\n{0}", ex);
                }
            }
        }

        #region Command Handlers

        /* Expected parameter: SchedulerName */
        private string OnRestartScheduler(string parameters)
        {
            string ret = "";

            if (null != _schedulers)
            {
                // In order to be case-insensitive, walk the keys collection looking for a match
                ret = String.Format("Unable to locate the scheduler '{0}'\r\n", parameters);
                foreach (string key in _schedulers.Keys)
                {
                    if (String.Compare(key, parameters, true) == 0)
                    {
                        // Found the scheduler - restart it
                        try
                        {
                            _schedulers[key].Shutdown(0);
                            _schedulers[key] = new JobScheduler(key);
                            _schedulers[key].Start();
                            ret = String.Format("Successfully restarted the '{0}' job scheduler.\r\n", key);
                        }
                        catch (Exception ex)
                        {
                            ret = String.Format("Unable to restart the '{0}' job scheduler: {1}\r\n", key, ex);
                        }
                        break;
                    }
                }
            }
            else
            {
                ret = "There are no schedulers running\r\n";
            }

            return ret;
        }

        /* Expected parameter: None */
        private string OnListSchedulers(string parameters)
        {
            StringBuilder ret = new StringBuilder();
            if (_schedulers != null)
            {
                foreach(KeyValuePair<string, JobScheduler> kvp in _schedulers)
                {
                    ret.AppendFormat("{0}\r\n", kvp.Key);
                }
            }
            else
            {
                ret.AppendLine("There are no schedulers running.");
            }

            return ret.ToString();
        }

        #endregion

        #region Main entry point
        static void Main(string[] args)
        {
            ServiceBase[] ServicesToRun;
            ServicesToRun = new ServiceBase[] 
			{ 
				new JSService() 
			};
            ServiceBase.Run(ServicesToRun);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\JSService\XMLResultWriter.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Xsl;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.jsservice
{
	public class XMLResultWriter
	{
        private const string DATE_FORMAT = "MM/dd/yyyy HH:mm:ss.fff";

        public static XmlDocument GenerateReport(long jobId, byte historyMaxDays, byte historyMaxJobs)
        {
            Job job = null;
            XmlDocument report = null;

            try
            {
                job = DbAccess.GetJob(jobId);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "Unable to pull the Job data for job Id {0}:\r\n{1}", jobId, ex);
            }

            if (null != job)
            {
                report = GenerateReport(job, historyMaxDays, historyMaxJobs);
            }
            else
            {
                DACommon.LogEvent(LoggingLevel.Error, "Unable to find a job with an Id of {0}.", jobId);
            }

            return report;
        }
        public static XmlDocument GenerateReport(Job job, byte historyMaxDays, byte historyMaxJobs)
        {
            if (null == job)
                throw new ArgumentNullException();
            
            XmlDocument doc = null;

            if (JobState.Complete == job.State)
            {
                long currentGroup = 0;

                // Pull the list of task groups associated with this job
                List<TaskGroup> taskGroups = DbAccess.GetJobTaskGroups(job.Id);

                // Pull the list of tasks belonging to this job
                List<Task> tasks = DbAccess.GetJobTasks(job.Id);

                // Pull the list of result logs for this job
                List<TaskLog> taskLogs = DbAccess.GetJobLogs(job.Id);

                List<Job> history = null;
                if (historyMaxDays > 0 || historyMaxJobs > 0)
                {
                    // Pull the job history from the database
                    history = DbAccess.GetJobHistory(job.Environment, job.Build, job.Type, historyMaxDays, historyMaxJobs);
                }

                // Create the base document
                doc = new XmlDocument();
                doc.AppendChild(doc.CreateXmlDeclaration("1.0", "utf-8", null));
                XmlNode root = doc.CreateNode(XmlNodeType.Element, "JobResults", doc.NamespaceURI);
                XmlNode jobNode = null;
                XmlNode groupNode = null;
                XmlNode taskNode = null;
                Result rollupResult = Result.Succeeded;
                
                // Add the date the report was generated to the root element
                XmlAttribute attrib = doc.CreateAttribute("ReportDate");
                attrib.Value = DateTime.Now.ToString("M/d/yyyy");
                root.Attributes.Append(attrib);

                // Add any job result history
                if (null != history)
                {
                    XmlNode historyNode = SerializeJobHistory(doc, history, historyMaxDays, historyMaxJobs);
                    if (historyNode != null)
                        root.AppendChild(historyNode);
                }

                // Serialize the Job object
                jobNode = SerializeJob(doc, job);
                if (jobNode != null)
                {
                    foreach (Task task in tasks)
                    {
                        // Check for a group change
                        if (task.Group != currentGroup)
                        {
                            if (currentGroup > 0)
                            {
                                if (groupNode != null)
                                    jobNode.AppendChild(groupNode);
                                currentGroup = 0;
                                groupNode = null;
                            }

                            // If this task belongs to a group, open the new TaskGroup
                            if (task.Group > 0)
                            {
                                foreach (TaskGroup tg in taskGroups)
                                {
                                    if (tg.Id == task.Group)
                                    {
                                        groupNode = SerializeTaskGroup(doc, tg);
                                        currentGroup = tg.Id;
                                        rollupResult = Result.Succeeded;
                                        break;
                                    }
                                }
                            }
                        }

                        // Rollup the result
                        switch (task.Result)
                        {
                            case Result.Succeeded:
                                break;
                            case Result.NotRun:
                                if (Result.Succeeded == rollupResult)
                                    rollupResult = Result.NotRun;
                                break;
                            case Result.Skipped:
                                if (Result.Succeeded == rollupResult ||
                                    Result.NotRun == rollupResult)
                                    rollupResult = Result.Skipped;
                                break;
                            case Result.NonFatalFailure:
                                if (Result.Succeeded == rollupResult ||
                                    Result.NotRun == rollupResult ||
                                    Result.Skipped == rollupResult)
                                    rollupResult = Result.NonFatalFailure;
                                break;
                            case Result.Cancelled:
                                if (Result.Failed != rollupResult &&
                                    Result.Blocked != rollupResult)
                                    rollupResult = Result.Cancelled;
                                break;
                            case Result.Blocked:
                                if (Result.Failed != rollupResult)
                                    rollupResult = Result.Blocked;
                                break;
                            case Result.Failed:
                                rollupResult = Result.Failed;
                                break;
                        }

                        // Serialize the task
                        taskNode = SerializeTask(doc, task);
                        foreach (TaskLog tl in taskLogs)
                        {
                            if (tl.TaskId == task.Id)
                            {
                                XmlNode logNode = SerializeTaskLog(doc, tl);
                                if (logNode != null && taskNode != null)
                                    taskNode.AppendChild(logNode);
                            }
                        }

                        // Add the task to either the job or a task group
                        if (task != null)
                        {
                            if (groupNode != null)
                            {
                                // If the current group specifies a rollup, add the 'Result' attribute
                                if (String.Compare(groupNode.Attributes["Rollup"].Value, "true", true) == 0)
                                {
                                    attrib = doc.CreateAttribute("Result");
                                    attrib.Value = rollupResult.ToString();
                                    groupNode.Attributes.Append(attrib);
                                }
                                groupNode.AppendChild(taskNode);
                            }
                            else
                                jobNode.AppendChild(taskNode);
                        }
                    }

                    // If a group is still active, add it to the job
                    if (groupNode != null)
                        jobNode.AppendChild(groupNode);

                    // Add the Job node to the root element
                    root.AppendChild(jobNode);

                    // Add the root element to the document
                    doc.AppendChild(root);
                }
            }
            else
            {
                throw new ApplicationException(String.Format("Job {0} is not complete. It's current state is {1}.", job.Id, job.State));
            }

            // Save the results xml document to the Logs folder
            string logFolder = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
            if (Directory.Exists(logFolder))
            {
                doc.Save(Path.Combine(logFolder, String.Format("Job_{0}_Results_{1}.xml", job.Id, DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"))));
            }

            return doc;
        }

        public static string Transform(string inputXmlFile, string xsltFileName)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(inputXmlFile);
            return Transform(xmlDoc, xsltFileName);
        }

        public static string Transform(XmlDocument xmlDoc, string xsltFileName)
        {
            string outputHtml = "";

            if (null == xmlDoc)
                throw new ArgumentNullException();

            XslCompiledTransform xslt = new XslCompiledTransform();
            using (StringWriter output = new StringWriter())
            {
                try
                {
                    // The XSLT file can either be in the EXE directory or the Transforms subdirectory
                    string[] xsltFiles = null;
                    if (Directory.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Transforms")))
                        xsltFiles = Directory.GetFiles(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Transforms"), xsltFileName);
                    if (xsltFiles == null || xsltFiles.Length == 0)
                        xsltFiles = Directory.GetFiles(AppDomain.CurrentDomain.BaseDirectory, xsltFileName);

                    if (xsltFiles.Length > 0)
                    {
                        // Perform the transformation
                        xslt.Load(xsltFiles[0]);
                        xslt.Transform(xmlDoc, null, output);
                        outputHtml = output.ToString();
                    }
                    else
                    {
                        DACommon.LogEvent(LoggingLevel.Error,
                            "Unable to locate the transform template '{0}'. The XML results cannot be transformed.",
                            xsltFileName);
                    }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(LoggingLevel.Error, "Unable to transform the XML result file '{0}':\r\n{1}",
                        xsltFileName, ex);
                }
            }

            return outputHtml;
        }

        private static XmlNode SerializeJobHistory(XmlDocument doc, List<Job> history, byte maxDays, byte maxJobs)
        {
            XmlNode historyNode = null;
            try
            {
                XmlNode resultNode = null;
                XmlNode weekNode = null;
                XmlNode dayNode = null;
                XmlAttribute attrib = null;
                DateTime todayDate = DateTime.Today;
                DateTime firstDay = todayDate.Subtract(new TimeSpan(28 + (int)(todayDate.DayOfWeek), 0, 0, 0));
                DateTime currentDay = firstDay;
                int jobIndex = 0;

                historyNode = doc.CreateNode(XmlNodeType.Element, "JobHistory", doc.NamespaceURI);

                // Add all the jobs that started earlier than 5 weeks from the current week
                while (jobIndex < history.Count && history[jobIndex].StartDate < firstDay)
                {
                    if (null == weekNode)
                        weekNode = doc.CreateNode(XmlNodeType.Element, "Older", doc.NamespaceURI);
                    resultNode = SerializeJobResult(doc, history[jobIndex]);
                    weekNode.AppendChild(resultNode);
                    jobIndex++;
                }
                if (weekNode != null)
                    historyNode.AppendChild(weekNode);

                // Create the week/day hierarchy of the results history
                for (int week = 1; week < 6; week++)
                {
                    weekNode = doc.CreateNode(XmlNodeType.Element, "Week", doc.NamespaceURI);
                    attrib = doc.CreateAttribute("Id");
                    attrib.Value = week.ToString();
                    weekNode.Attributes.Append(attrib);
                    historyNode.AppendChild(weekNode);

                    for (int day = 1; day < 8; day++)
                    {
                        dayNode = doc.CreateNode(XmlNodeType.Element, "Day", doc.NamespaceURI);
                        attrib = doc.CreateAttribute("Date");
                        attrib.Value = currentDay.ToString("M/d/yyyy");
                        dayNode.Attributes.Append(attrib);
                        while (jobIndex < history.Count && history[jobIndex].StartDate.DayOfYear == currentDay.DayOfYear)
                        {
                            resultNode = SerializeJobResult(doc, history[jobIndex]);
                            dayNode.AppendChild(resultNode);
                            jobIndex++;
                        }
                        currentDay = currentDay.AddDays(1);
                        weekNode.AppendChild(dayNode);
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "SerializeJobHistory : Error serializing job history:\r\n{0}", ex);
            }

            return historyNode;
        }

        private static XmlNode SerializeJobResult(XmlDocument doc, Job job)
        {
            XmlNode resultNode = doc.CreateNode(XmlNodeType.Element, "JobResult", doc.NamespaceURI);
            XmlAttribute attrib;

            attrib = doc.CreateAttribute("Id");
            attrib.Value = job.Id.ToString();
            resultNode.Attributes.Append(attrib);

            attrib = doc.CreateAttribute("Version");
            attrib.Value = job.BuildVersion;
            resultNode.Attributes.Append(attrib);

            attrib = doc.CreateAttribute("Result");
            attrib.Value = job.Result.ToString();
            resultNode.Attributes.Append(attrib);

            return resultNode;
        }

        private static XmlNode SerializeJob(XmlDocument doc, Job job)
        {
            XmlNode jobNode = null;
            try
            {
                TimeSpan eTime = job.EndDate.Subtract(job.StartDate);
                jobNode = doc.CreateNode(XmlNodeType.Element, "Job", doc.NamespaceURI);
                XmlAttribute attrib = doc.CreateAttribute("Id");
                attrib.Value = job.Id.ToString();
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Name");
                attrib.Value = job.Name;
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Type");
                attrib.Value = job.Type.ToString();
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Build");
                attrib.Value = job.Build;
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Version");
                attrib.Value = job.BuildVersion;
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Environment");
                attrib.Value = job.Environment;
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Priority");
                attrib.Value = job.Priority.ToString();
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("CreatedBy");
                attrib.Value = job.Creator;
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("CreateDate");
                attrib.Value = job.CreateDate.ToString(DATE_FORMAT);
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Started");
                attrib.Value = job.StartDate.ToString(DATE_FORMAT);
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Finished");
                attrib.Value = job.EndDate.ToString(DATE_FORMAT);
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("ElapsedTime");
                eTime = job.EndDate.Subtract(job.StartDate);
                attrib.Value = eTime.ToString();
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Result");
                attrib.Value = job.Result.ToString();
                jobNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("LogsLocation");
                attrib.Value = job.LogsLocation;
                if (attrib.Value.Length > 0)
                    jobNode.Attributes.Append(attrib);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "SerializeJob : Error serializing job {0}:\r\n{1}", job.Id, ex);
            }

            return jobNode;
        }

        private static XmlNode SerializeTaskGroup(XmlDocument doc, TaskGroup taskGroup)
        {
            XmlNode groupNode = null;
            try
            {
                groupNode = doc.CreateNode(XmlNodeType.Element, "TaskGroup", doc.NamespaceURI);
                XmlAttribute attrib = doc.CreateAttribute("Id");
                attrib.Value = taskGroup.Id.ToString();
                groupNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Name");
                attrib.Value = taskGroup.Name;
                groupNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Rollup");
                attrib.Value = taskGroup.Rollup.ToString();
                groupNode.Attributes.Append(attrib);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "SerializeTaskGroup : Error serializing task group {0}:\r\n{1}", taskGroup.Id, ex);
            }

            return groupNode;
        }

        private static XmlNode SerializeTask(XmlDocument doc, Task task)
        {
            XmlNode taskNode = null;
            try
            {
                TimeSpan eTime = task.EndDate.Subtract(task.StartDate);
                taskNode = doc.CreateNode(XmlNodeType.Element, "Task", doc.NamespaceURI);
                XmlAttribute attrib = doc.CreateAttribute("Id");
                attrib.Value = task.Id.ToString();
                taskNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Name");
                attrib.Value = task.Name;
                taskNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Module");
                attrib.Value = task.Module;
                taskNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Result");
                attrib.Value = task.Result.ToString();
                taskNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Started");
                attrib.Value = task.StartDate.ToString(DATE_FORMAT);
                taskNode.Attributes.Append(attrib);

                attrib = doc.CreateAttribute("Finished");
                attrib.Value = task.EndDate.ToString(DATE_FORMAT);
                taskNode.Attributes.Append(attrib);

                eTime = task.EndDate.Subtract(task.StartDate);
                attrib = doc.CreateAttribute("ElapsedTime");
                attrib.Value = eTime.ToString();
                taskNode.Attributes.Append(attrib);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "SerializeTask : Error serializing task {0}:\r\n{1}", task.Id, ex);
            }

            return taskNode;
        }

        private static XmlNode SerializeTaskLog(XmlDocument doc, TaskLog taskLog)
        {
            XmlNode logNode = null;
            XmlAttribute attrib = null;

            try
            {
                if (!String.IsNullOrEmpty(taskLog.LogFile) || !String.IsNullOrEmpty(taskLog.LogPath))
                {
                    logNode = doc.CreateNode(XmlNodeType.Element, "LogFile", doc.NamespaceURI);
                    attrib = doc.CreateAttribute("Path");
                    if (!String.IsNullOrEmpty(taskLog.LogPath))
                    {
                        if (!String.IsNullOrEmpty(taskLog.LogFile))
                            attrib.Value = Path.Combine(taskLog.LogPath, taskLog.LogFile);
                        else
                            attrib.Value = taskLog.LogPath;
                    }
                    else
                    {
                        attrib.Value = taskLog.LogFile;
                    }
                    logNode.Attributes.Append(attrib);
                }
                else if (taskLog.LogText != null)
                {
                    // if the log text is XML, just add it as a sub-element of the LogText element
                    // if the log text is plain text, add it as a CDATA element
                    if (taskLog.LogText.StartsWith("<"))
                    {
                        logNode = doc.CreateNode(XmlNodeType.Element, "LogXML", doc.NamespaceURI);
                        logNode.InnerXml = taskLog.LogText;
                    }
                    else
                    {
                        logNode = doc.CreateNode(XmlNodeType.Element, "LogText", doc.NamespaceURI);
                        XmlCDataSection logData = doc.CreateCDataSection(taskLog.LogText);
                        logNode.AppendChild(logData);
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "SerializeTaskLog : Error serializing the log for task {0}:\r\n{1}", taskLog.TaskId, ex);
            }

            return logNode;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\CommandLineTaskModule\CommandLineTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.commandlinetaskmodule
{
    [DeploymentTaskModule("CommandLineTaskModule")]
	public class CommandLineTaskModule : ITaskModule
    {
        #region Command class - Object representation of the Command Element
        protected class Command
        {
            public string Executable { get; private set; }
            public string WorkingDirectory { get; private set; }
            public string Arguments { get; private set; }
            public int ExpectedExitCode { get; private set; }
            public int TimeoutSeconds { get; private set; }
            public bool CaptureOutput { get; private set; }
            public bool ErrorsAreFatal { get; private set; }

            public static Command Parse(XPathNavigator node)
            {
                Command cmd = new Command();

                cmd.Executable = "";
                cmd.WorkingDirectory = "";
                cmd.Arguments = "";
                cmd.ExpectedExitCode = 0;
                cmd.TimeoutSeconds = 3600;
                cmd.CaptureOutput = true;
                cmd.ErrorsAreFatal = true;

                cmd.Executable = node.GetAttribute("Executable", node.NamespaceURI);
                cmd.WorkingDirectory = node.GetAttribute("WorkingDirectory", node.NamespaceURI);
                if (cmd.WorkingDirectory.Length == 0 && cmd.Executable.Length > 0)
                    cmd.WorkingDirectory = Path.GetDirectoryName(cmd.Executable);
                cmd.Arguments = node.GetAttribute("Arguments", node.NamespaceURI);
                int intTmp;
                bool boolTmp;
                if (Int32.TryParse(node.GetAttribute("ExpectedExitCode", node.NamespaceURI), out intTmp))
                    cmd.ExpectedExitCode = intTmp;
                if (Int32.TryParse(node.GetAttribute("TimeoutSeconds", node.NamespaceURI), out intTmp))
                    cmd.TimeoutSeconds = intTmp;
                if (Boolean.TryParse(node.GetAttribute("CaptureOutput", node.NamespaceURI), out boolTmp))
                    cmd.CaptureOutput = boolTmp;
                if (Boolean.TryParse(node.GetAttribute("ErrorsAreFatal", node.NamespaceURI), out boolTmp))
                    cmd.ErrorsAreFatal = boolTmp;

                return cmd;
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendFormat("Execuatble: {0}\r\n", Executable);
                sb.AppendFormat("Working Directory: {0}\r\n", WorkingDirectory);
                sb.AppendFormat("Arguments: {0}\r\n", Arguments);
                sb.AppendFormat("Expected Exit Code: {0}\r\n", ExpectedExitCode);
                sb.AppendFormat("Timeout Seconds: {0}\r\n", TimeoutSeconds);
                sb.AppendFormat("Capture Output: {0}\r\n", CaptureOutput);
                sb.AppendFormat("Errors Are Fatal: {0}\r\n", ErrorsAreFatal);
                return sb.ToString();
            }
        }
        #endregion

        TaskModuleInfo _info;
        TaskResult _result;
        StringBuilder _cmdOutput;
        Command _command;
        string _remoteServer;
        string _userName;
        string _password;

        public CommandLineTaskModule()
        {
            StringBuilder desc = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "CommanLineTaskModule";
            _info.Description = "Provides support for executing command from the command line.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <Command Executable=\"executablePathAndName\" [WorkingDirectory=\"workingDirectory\"] [Arguments=\"argumentList\"] [ExpectedExitCode=\"expectedExitCode\"] [TimeoutSeconds=\"timeoutSeconds\"] [CaptureOutput=\"true|false\"] [ErrorsAreFatal=\"true|false\"] />");
            desc.AppendLine("  <RunAt Server=\"serverName\" [Username=\"userName\"] [Password=\"password\"] [PasswordEncrypted=\"true|false\"] />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("If the WorkingDirectory attribute is not specified, the executable directory will be used.");
            desc.AppendLine("The RunAt element is optional and specifies a remote server on which the command should be run. The remote server must be in the same domain and must be running the DAService.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _cmdOutput = new StringBuilder();
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void AddParameter(string parameterName, string value) { }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "command":
                            _command = Command.Parse(itor.Current);
                            break;
                        case "runat":
                            _remoteServer = itor.Current.GetAttribute("Server", itor.Current.NamespaceURI);
                            _userName = itor.Current.GetAttribute("Username", itor.Current.NamespaceURI);
                            if (_userName.Length > 0)
                            {
                                bool passwordEncrypted = false;
                                bool.TryParse(itor.Current.GetAttribute("PasswordEncrypted", itor.Current.NamespaceURI), out passwordEncrypted);
                                if (passwordEncrypted)
                                    _password = DataProtector.DecryptFromHexString(itor.Current.GetAttribute("Password", itor.Current.NamespaceURI));
                                else
                                    _password = itor.Current.GetAttribute("Password", itor.Current.NamespaceURI);
                            }
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public void RemoveAllParameters()
        {
            _command = null;
            _remoteServer = null;
        }

        public TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (null == _command)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Command element is required, but was not specified."));
                return _result;
            }
            if (String.IsNullOrEmpty(_command.Executable))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Executable attribute is required, but was not specified."));
            }

            if (_result.ExecutedSuccessfully)
            {
                if (String.IsNullOrEmpty(_remoteServer))
                {
                    _result.ExecutedSuccessfully = ExecuteCommand(_command.Executable, _command.WorkingDirectory,
                        _command.Arguments, _command.ExpectedExitCode, _command.TimeoutSeconds, _command.CaptureOutput);
                }
                else
                {
                    RemoteCommandResponse rcr = null;
                    bool networkDriveConnected = false;
                    try
                    {
                        // If a username and password are specified, try connecting using those credentials
                        if (!String.IsNullOrEmpty(_userName))
                        {
                            NetworkDrive.MapNetworkDrive(String.Format(@"\\{0}\C$", _remoteServer), null, _userName, _password);
                            networkDriveConnected = true;
                        }
                        RemoteCommandArgs rca = new RemoteCommandArgs(_command.Executable, _command.Arguments, (ushort)_command.TimeoutSeconds);
                        rcr = DACommon.RunRemoteCommand(_remoteServer, rca);
                    }
                    catch (Exception ex)
                    {
                        _result.ExecutedSuccessfully = false;
                        _result.AddLog(new Log("Unable to run the command on the server '{0}': {1}", _remoteServer, ex.Message));
                        DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to run the following command on the server '{0}':\r\n{1}\r\n\r\nException:\r\n{2}",
                            _remoteServer, _command.ToString(), ex);
                    }
                    finally
                    {
                        if (networkDriveConnected)
                            NetworkDrive.UnMapNetworkDrive(String.Format(@"\\{0}\c$", _remoteServer), true);
                    }

                    if (rcr != null)
                    {
                        if (rcr.Completed)
                        {
                            if (rcr.ExitCode != _command.ExpectedExitCode)
                            {
                                _result.ExecutedSuccessfully = false;
                                _result.AddLog(new Log("The command '{0}' returned exit code {1}, but the exit code {2} was expected.",
                                    _command.Executable, rcr.ExitCode, _command.ExpectedExitCode));
                            }

                            if (_command.CaptureOutput)
                            {
                                _result.AddLog(new Log("Command Output:\r\n{0}", rcr.Output));
                            }
                        }
                        else if (rcr.TimedOut)
                        {
                            _result.ExecutedSuccessfully = false;
                            _result.AddLog(new Log("The command '{0}' timed out after {1} seconds.", _command.Executable, _command.TimeoutSeconds));
                        }
                        else if (rcr.Exception != null)
                        {
                            _result.ExecutedSuccessfully = false;
                            _result.AddLog(new Log("An exception was caught while running the command '{0}' on the server {1}: {2}",
                                _command.Executable, _remoteServer, rcr.Exception.Message));
                        }
                    }
                }
            }

            if (!_command.ErrorsAreFatal)
                _result.ExecutedSuccessfully = true;

            return _result;
        }

        #endregion

        public bool ExecuteCommand(string command, string workingDirectory, string argumentList, int expectedExitCode, int timeoutSeconds, bool captureOutput)
        {
            bool success = true;

            // If the working directory is not specified, set it to the directory of the command
            if (workingDirectory.Length == 0)
                workingDirectory = Path.GetDirectoryName(command);

            ProcessStartInfo psi = new ProcessStartInfo();
            psi.WorkingDirectory = workingDirectory;
            psi.FileName = command;
            psi.Arguments = argumentList.ToString();
            psi.RedirectStandardError = captureOutput;
            psi.RedirectStandardOutput = captureOutput;
            psi.UseShellExecute = false;

            try
            {
                Process cmdProcess = new Process();
                cmdProcess.StartInfo = psi;
                cmdProcess.OutputDataReceived += new DataReceivedEventHandler(OutputDataHandler);
                cmdProcess.ErrorDataReceived += new DataReceivedEventHandler(OutputDataHandler);
                cmdProcess.Start();
                cmdProcess.BeginOutputReadLine();
                cmdProcess.BeginErrorReadLine();
                if (timeoutSeconds > 0)
                {
                    if (!cmdProcess.WaitForExit(timeoutSeconds * 1000))
                    {
                        cmdProcess.Kill();
                        throw new Exception(String.Format("The {0} second timeout expired while waiting for the command to complete.", timeoutSeconds));
                    }
                }
                else
                {
                    cmdProcess.WaitForExit();
                }

                if (captureOutput)
                {
                    // Add the command output to the results
                    _result.AddLog(new Log(_cmdOutput.ToString()));
                }

                success = (cmdProcess.ExitCode == expectedExitCode);
            }
            catch (Exception ex)
            {
                success = false;
                _result.AddLog(new Log("An exception occurred while trying to run the command '{0}':\r\n{1}", command, ex.Message));
            }

            return success;
        }

        private void OutputDataHandler(object sender, DataReceivedEventArgs e)
        {
            _cmdOutput.AppendLine(e.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\ConsoleTestTaskModule\ConsoleComandUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Diagnostics;

namespace xonline.test.deployment.automation.taskmodules.consoletesttaskmodule
{
    internal class ConsoleCommandUtil
    {
        public const string ConsoleLocationRoot = "xE:\\";
        public const string ConsoleLocation = "xE:\\XLSAT\\";
        public string ConsoleName { set; get; }
        public string PathToXDKBinDir { set; get; }
        public string PathToLogLocation { set; get; }

        private StringBuilder _outputStringBuilder;
        private int _exitCode = 0;

        public int ExitCode
        {
            get { return _exitCode; }
        }

        public string Output
        {
            get
            {
                return _outputStringBuilder.ToString();
            }
        }

        public ConsoleCommandUtil()
        {
            _outputStringBuilder = new StringBuilder();
            this.ConsoleName = "";
            this.PathToXDKBinDir = "";

        }

        public int RunXLSAT()
        {
            // xbreboot.exe /X:<Console> /C xE:\XLSAT\XLSAT.xex autorun writefilelog
            return Reboot("xE:\\XLSAT\\XLSAT.xex autorun writefilelog", false, true);
        }

        public int Reboot(string cmdline)
        {
            // xbreboot.exe /X:<Console> /C xE:\XLSAT\XLSAT.xex autorun writefilelog
            return Reboot(cmdline, false, true);
        }

        public int Reboot(string cmdline, bool waitfordebug, bool coldreboot)
        {
            int retVal = 0;
            _outputStringBuilder = new StringBuilder();
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.AppendFormat("/X:{0} ", ConsoleName);
            if (waitfordebug)
                argumentListBuilder.Append("/W ");
            if (coldreboot)
                argumentListBuilder.Append("/C ");

            argumentListBuilder.AppendFormat("{0} ", cmdline);

            ProcessStartInfo processStartInfo = new ProcessStartInfo(Path.Combine(PathToXDKBinDir, "xbreboot.exe"), argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = PathToXDKBinDir;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.RedirectStandardError = true;

            Process copycmd = Process.Start(processStartInfo);
            copycmd.OutputDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            copycmd.ErrorDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            copycmd.BeginOutputReadLine();
            copycmd.BeginErrorReadLine();
            copycmd.WaitForExit();
            _exitCode = copycmd.ExitCode;
            retVal = _exitCode;

            return retVal;
        }

        public int CopyToConsoleRoot(string source)
        {
            // Console location should be xE:\
            return Copy(source, ConsoleLocationRoot);
        }

        public int CopyToConsoleXLSAT(string source)
        {
            // Console location should be xE:\XLSAT\
            return Copy(source, ConsoleLocation);
        }

        public int CopyFromConsole(string filespec)
        {
            // Console location should be xE:\XLSAT\
            string source = Path.Combine(ConsoleLocation, filespec);
            return Copy(source, PathToLogLocation);
        }

        public int CopyFromConsole(string filespec, string destfile)
        {
            // Console location should be xE:\XLSAT\
            string source = Path.Combine(ConsoleLocation, filespec);
            return Copy(source, Path.Combine(PathToLogLocation, destfile));
        }

        public int Copy(string source, string dest)
        {
            return Copy(source, dest, false, true, true, false, true);
        }

        public int Copy(string source, string dest, bool recursive, bool copyhidden, bool overwrite, bool createdest, bool force)
        {
            int retVal = 0;
            _outputStringBuilder = new StringBuilder();
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.AppendFormat("/X:{0} ", ConsoleName);
            if (recursive)
                argumentListBuilder.Append("/R ");
            if (copyhidden)
                argumentListBuilder.Append("/H ");
            if (overwrite)
                argumentListBuilder.Append("/Y ");
            if (createdest)
                argumentListBuilder.Append("/T ");
            if (force)
                argumentListBuilder.Append("/F ");

            argumentListBuilder.AppendFormat("{0} ", source);
            argumentListBuilder.AppendFormat("{0} ", dest);

            ProcessStartInfo processStartInfo = new ProcessStartInfo(Path.Combine(PathToXDKBinDir, "xbcp.exe"), argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = PathToXDKBinDir;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.RedirectStandardError = true;

            Process copycmd = Process.Start(processStartInfo);
            copycmd.OutputDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            copycmd.ErrorDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            copycmd.BeginOutputReadLine();
            copycmd.BeginErrorReadLine();
            copycmd.WaitForExit();
            _exitCode = copycmd.ExitCode;
            retVal = _exitCode;
            return retVal;
        }

        public int DeleteFromConsole(string filespec)
        {
            string filePath = Path.Combine(ConsoleLocation, filespec);
            return Delete(filePath, false, true, true);
        }

        public int Delete(string filespec)
        {
            return Delete(filespec, false, true, true);
        }

        public int Delete(string filespec, bool recursive, bool delhidden, bool force)
        {
            int retVal = 0;
            _outputStringBuilder = new StringBuilder();
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.AppendFormat("/X:{0} ", ConsoleName);
            if (recursive)
                argumentListBuilder.Append("/R ");
            if (delhidden)
                argumentListBuilder.Append("/H ");
            if (force)
                argumentListBuilder.Append("/F ");

            argumentListBuilder.AppendFormat("{0} ", filespec);

            ProcessStartInfo processStartInfo = new ProcessStartInfo(Path.Combine(PathToXDKBinDir, "xbdel.exe"), argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = PathToXDKBinDir;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.RedirectStandardError = true;

            Process copycmd = Process.Start(processStartInfo);
            copycmd.OutputDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            copycmd.ErrorDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            copycmd.BeginOutputReadLine();
            copycmd.BeginErrorReadLine();
            copycmd.WaitForExit();
            _exitCode = copycmd.ExitCode;
            retVal = _exitCode;
            return retVal;
        }

        public int DeleteOldAccounts()
        {
            int retVal = 0;

            // BackUp xZ:\Content\0000000000000000
            retVal = Copy(@"xZ:\Content\0000000000000000", @"xZ:\0000000000000000", true, true, true, false, true);
            if (retVal == 0)
            {
                // Delete all accounts from xZ:\Content\
                retVal = Delete(@"xZ:\Content\*", true, true, true);
                if (retVal == 0)
                {
                    // Copy back xZ:\Content\0000000000000000
                    retVal = Copy(@"xZ:\0000000000000000", @"xZ:\Content\0000000000000000", true, true, true, false, true);
                    if (retVal == 0)
                    {
                        // Delete the back up at xZ:\0000000000000000
                        retVal = Delete(@"xZ:\0000000000000000", true, true, true);
                    }
                }
            }

            return retVal;
        }

        public int Capture(string filespec)
        {
            int retVal = 0;
            _outputStringBuilder = new StringBuilder();
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.AppendFormat("/X:{0} ", ConsoleName);

            argumentListBuilder.AppendFormat("{0} ", filespec);

            ProcessStartInfo processStartInfo = new ProcessStartInfo(Path.Combine(PathToXDKBinDir, "xbcapture.exe"), argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = PathToXDKBinDir;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.RedirectStandardError = true;

            Process captureCmd = Process.Start(processStartInfo);
            captureCmd.OutputDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            captureCmd.ErrorDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            captureCmd.BeginOutputReadLine();
            captureCmd.BeginErrorReadLine();
            captureCmd.WaitForExit();
            _exitCode = captureCmd.ExitCode;
            retVal = _exitCode;
            return retVal;
        }

        void OutputDataReceivedHandler(object sender, DataReceivedEventArgs e)
        {
            _outputStringBuilder.AppendLine(e.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\ActiveDirectoryTaskModule\ActiveDirectoryModuleBase.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.DirectoryServices;
using System.DirectoryServices.ActiveDirectory;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.activedirectorytaskmodule
{
    /// <summary>
    /// Task module used for interacting with the HyperNet Active Directory
    /// </summary>
    [DeploymentTaskModule("ActiveDirectoryTaskModule")]
    public class ActiveDirectoryTaskModule : ITaskModule
    {
        /// <summary>
        /// List of supported commands for this task module
        /// </summary>
        protected enum ActiveDirectoryAction
        {
            /// <summary>
            /// Adds an account (user or security group) to an existing security group
            /// </summary>
            Add = 0,

            /// <summary>
            /// Creates a new object in the Active Directory
            /// </summary>
            Create,

            /// <summary>
            /// Deletes an existing object in the Active Directory
            /// </summary>
            Delete,

            /// <summary>
            /// Enumerates objects
            /// </summary>
            Enumerate,

            /// <summary>
            /// Removes an account (user or security group) from an existing security group
            /// </summary>
            Remove
        }

        /// <summary>
        /// List of items found in Active Directory
        /// </summary>
        protected enum ObjectClass
        {
            /// <summary>
            /// An object representing a security group within the domain
            /// </summary>
            Group,

            /// <summary>
            /// An object represeting an organizational unit container
            /// </summary>
            OrganizationalUnit,

            /// <summary>
            /// An object representing a user account within the domain
            /// </summary>
            User
        }

        #region ActiveDirectoryItem class - Object representing an object in the Active Directory

        /// <summary>
        /// A generic object found in the Active Directory
        /// </summary>
        protected class ActiveDirectoryItem
        {
            /// <summary>
            /// Gets or sets the account name of the object
            /// </summary>
            /// <remarks>
            /// For User object, this represents the alias
            /// </remarks>
            public string AccountName { get; set; }

            /// <summary>
            /// Gets or sets the pre-defined action in the domain
            /// </summary>
            public ActiveDirectoryAction Action { get; set; }

            /// <summary>
            /// Gets or sets the class type for this object
            /// </summary>
            public ObjectClass Class { get; set; }

            /// <summary>
            /// Gets or sets the description of the user
            /// </summary>
            public string Description { get; set; }

            /// <summary>
            /// Gets or sets the filter format string that helps locate this object
            /// </summary>
            public string Filter { get; set; }

            /// <summary>
            /// Gets or sets the value indicating whether the caller has overridden the default filter
            /// </summary>
            public bool FilterBypass { get; private set; }

            /// <summary>
            /// Gets or sets the first name of user account
            /// </summary>
            public string FirstName { get; set; }

            /// <summary>
            /// Gets or sets the last name of user account
            /// </summary>
            public string LastName { get; set; }

            /// <summary>
            /// Gets or sets the friendly name of the object
            /// </summary>
            public string MemberOf { get; set; }

            /// <summary>
            /// Gets or sets the OU where <c>item</c> resides
            /// <remarks>Expected format: Foo\Bar\Foobar</remarks>
            /// <remarks>Should exclude DC=xxx,DC=yyy</remarks>
            /// </summary>
            public string Path { get; set; }

            /// <summary>
            /// Parses the XML block for information specific to the user
            /// </summary>
            /// <param name="node">
            /// XML block to parse for data
            /// </param>
            /// <returns>
            /// Initialized <c>ActiveDirectoryItem</c> object for the task to consume
            /// </returns>
            public static ActiveDirectoryItem Parse(XPathNavigator node)
            {
                // required: must be an OU, SecurityGroup or User
                if (!node.Name.Equals("OrganizationalUnit", StringComparison.InvariantCultureIgnoreCase) &&
                    !node.Name.Equals("SecurityGroup", StringComparison.InvariantCultureIgnoreCase) &&
                    !node.Name.Equals("User", StringComparison.InvariantCultureIgnoreCase))
                {
                    string message = String.Format(
                        "Invalid element '{0}' The element name is not 'OrganizationalUnit', 'SecurityGroup' or 'User'.",
                        node.Name);
                    throw new ApplicationException(message);
                }

                ActiveDirectoryItem item = new ActiveDirectoryItem()
                {
                    FilterBypass = false
                };

                // required: must have an action associated with item
                string attr = node.GetAttribute("Action", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                {
                    throw new ApplicationException("Missing attribute 'Action'. The element must have an action associated with it.");
                }

                // required: must be a valid action
                try
                {
                    item.Action = (ActiveDirectoryAction)Enum.Parse(typeof(ActiveDirectoryAction), attr, true);
                }
                catch (Exception)
                {
                    string message = String.Format("Unexpected 'Action'. Invalid attribute: '{0}'", attr);
                    throw new ApplicationException(message);
                }

                // set class and default filter by comparing name of node
                switch (node.Name.ToLowerInvariant())
                {
                    case "organizationalunit":
                        item.AccountName = node.GetAttribute("Name", node.NamespaceURI);
                        item.Class = ObjectClass.OrganizationalUnit;
                        item.Description = "Xbox Live testing";
                        item.Filter = "(objectClass=organizationalUnit)";
                        break;
                    case "securitygroup":
                        item.AccountName = node.GetAttribute("Name", node.NamespaceURI);
                        item.Class = ObjectClass.Group;
                        item.Filter = String.Format(
                            "(&(objectClass=group)(sAMAccountName={0}))",
                            item.AccountName);
                        break;
                    case "user":
                        item.AccountName = node.GetAttribute("Alias", node.NamespaceURI);
                        item.Class = ObjectClass.User;
                        item.Filter = String.Format(
                            "(&(objectCategory=user)(objectClass=person)(sAMAccountName={0}))",
                            item.AccountName);
                        break;
                }

                if (!String.IsNullOrEmpty(node.GetAttribute("Description", node.NamespaceURI)))
                {
                    // overwrite with caller value
                    item.Description = node.GetAttribute("Description", node.NamespaceURI);
                }

                if (!String.IsNullOrEmpty(node.GetAttribute("Filter", node.NamespaceURI)))
                {
                    // overwrite with caller value
                    item.Filter = node.GetAttribute("Filter", node.NamespaceURI);
                    item.FilterBypass = true;
                }

                item.FirstName = node.GetAttribute("FirstName", node.NamespaceURI);
                item.LastName = node.GetAttribute("LastName", node.NamespaceURI);
                item.MemberOf = node.GetAttribute("MemberOf", node.NamespaceURI);

                // need to generate LDAP path from user friendly path
                if (!String.IsNullOrEmpty(node.GetAttribute("Path", node.NamespaceURI)))
                {
                    string path = node.GetAttribute("Path", node.NamespaceURI).Replace("\\", ",OU=");
                    item.Path = path.Insert(0, "OU=");
                }

                return item;
            }
        }

        #endregion

        #region Options class - Object representation of the Options element

        /// <summary>
        /// Additional options for task module to consume
        /// </summary>
        protected class Options
        {
            /// <summary>
            /// Gets or sets the USERDNSDOMAIN value for this task environment
            /// </summary>
            public string Domain { get; set; }

            /// <summary>
            /// Gets or sets the value indicating whether a failure terminates task
            /// </summary>
            public bool ErrorsAreFatal { get; set; }

            /// <summary>
            /// Gets or sets the path for saving the logging information to a file
            /// </summary>
            public string OutputPath { get; set; }

            /// <summary>
            /// Parses the XML block for information to assist the task
            /// </summary>
            /// <param name="node">
            /// XML block to parse for data
            /// </param>
            /// <returns>
            /// Initialized <c>Options</c> object for the task to consume
            /// </returns>
            public static Options Parse(XPathNavigator node)
            {
                if (!node.Name.Equals("Options", StringComparison.InvariantCultureIgnoreCase))
                {
                    string message = String.Format(
                        "Invalid element '{0}' The element name is not 'Options'.",
                        node.Name);
                    throw new ApplicationException(message);
                }

                Options command = new Options();
                command.Domain = node.GetAttribute("Domain", node.NamespaceURI);
                bool tmp;
                command.ErrorsAreFatal = true;
                if (Boolean.TryParse(node.GetAttribute("ErrorsAreFatal", node.NamespaceURI), out tmp))
                {
                    command.ErrorsAreFatal = tmp;
                }

                command.OutputPath = node.GetAttribute("OutputPath", node.NamespaceURI);
                return command;
            }
        }

        #endregion

        protected TaskModuleInfo _info;
        protected Dictionary<string, string> _parameters = null;
        protected TaskResult _result;
        protected List<ActiveDirectoryItem> _items;
        protected Options _options;

        public ActiveDirectoryTaskModule()
        {
            this._info = new TaskModuleInfo();
            this._info.Name = "ActiveDirectoryTaskModule";
            this._info.Description = "Performs tasks within the Active Directory.";
            this._info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <Options Domain=\"[string]\" ErrorsAreFatal=\"true|false\" OutputPath=\"[logfilepath]\" />");
            desc.AppendLine("  <User Action=\"[ADAction]\" Alias=\"[username]\" Description=\"[string]\" FirstName=\"[string]\" LastName=\"[string]\" MemberOf=\"[groupname]\" Path=\"[OUPath]\" />");
            desc.AppendLine("  <SecurityGroup Action=\"[ADAction]\" Name=\"[username]\" Description=\"[string]\" MemberOf=\"[groupname]\" Path=\"[OUPath]\" />");
            desc.AppendLine("  <OrganizationaUnit Action=\"[ADAction]\" Name=\"[containername]\" Path=\"[parentOUpath]\" Description=\"[string]\" />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("ADAction - Add, Create, Delete, Enumerate, Remove");
            desc.AppendLine("OUPath - Locaton in Active directory; e.g. Foo\\Bar\\Foobar (exclude domain path)");
            this._info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
            this._items = new List<ActiveDirectoryItem>();
            this._result = new TaskResult();
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return this._info; }
        }

        public virtual void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();
            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (!docNav.Name.Equals("Parameters", StringComparison.InvariantCultureIgnoreCase))
                {
                    string message = String.Format(
                        "Invalid block '{0}'; parent element must be named 'Parameters'.",
                        docNav.Name);
                    throw new ApplicationException(message);
                }

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "organizationalunit":
                        case "securitygroup":
                        case "user":
                            this._items.Add(ActiveDirectoryItem.Parse(itor.Current));
                            break;
                        case "options":
                            this._options = Options.Parse(itor.Current);
                            break;
                        default:
                            DACommon.LogEvent(
                                LoggingLevel.Warning,
                                "{0}: Unknown parameter block element: {1}",
                                _info.Name,
                                itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(
                    LoggingLevel.Error,
                    "{0}: Unable to parse the parameter block: {1}",
                    this._info.Name,
                    ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public virtual void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
            {
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");
            }

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
            {
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");
            }

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public virtual TaskResult Perform()
        {
            this._result = new TaskResult()
            {
                ExecutedSuccessfully = true
            };

            try
            {
                foreach (ActiveDirectoryItem item in this._items)
                {
                    switch (item.Action)
                    {
                        case ActiveDirectoryAction.Add:
                        case ActiveDirectoryAction.Remove:
                            if (String.IsNullOrEmpty(item.AccountName))
                            {
                                this._result.ExecutedSuccessfully = false;
                                this._result.AddLog(new Log("Missing required parameter 'AccountName'/'Alias' for {0}", item.Action));
                                continue;
                            }

                            if (String.IsNullOrEmpty(item.MemberOf))
                            {
                                this._result.ExecutedSuccessfully = false;
                                this._result.AddLog(new Log("Missing required parameter 'MemberOf' for {0}", item.Action));
                                continue;
                            }

                            if (item.AccountName.Equals(item.MemberOf, StringComparison.InvariantCultureIgnoreCase))
                            {
                                this._result.ExecutedSuccessfully = false;
                                this._result.AddLog(new Log("'AccountName'/'Alias' and 'MemberOf' cannot be the same value: {0}", item.AccountName));
                                continue;
                            }

                            this.PerformAddOrRemove(item);
                            break;
                        case ActiveDirectoryAction.Create:
                            if (String.IsNullOrEmpty(item.AccountName))
                            {
                                this._result.ExecutedSuccessfully = false;
                                this._result.AddLog(new Log("Missing required parameter 'Alias'/'Name' for {0}", item.Action));
                                continue;
                            }

                            if (String.IsNullOrEmpty(item.Path))
                            {
                                this._result.ExecutedSuccessfully = false;
                                this._result.AddLog(new Log("Missing required parameter 'Path' for {0}", item.Action));
                                continue;
                            }
                            this.PerformCreate(item);
                            break;
                        case ActiveDirectoryAction.Delete:
                            this.PerformDelete(item);
                            break;
                        case ActiveDirectoryAction.Enumerate:
                            this.PerformEnumerate(item);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                this._result.ExecutedSuccessfully = false;
                this._result.AddLog(new Log("An error occurred while executing the task.\r\n{0}", ex.Message));
            }

            return this._result;
        }

        public virtual void RemoveAllParameters()
        {
            this._options = null;
            if (this._items != null)
            {
                this._items.Clear();
            }
        }

        #endregion

        /// <summary>
        /// Adds or Removes object to/from Group
        /// </summary>
        /// <param name="user">
        /// <c>ActiveDirectoryItem</c> object to add/remove to/from Group
        /// </param>
        private void PerformAddOrRemove(ActiveDirectoryItem item)
        {
            // find the item based on it's unique filter
            string[] properties = new string[0];
            SearchResultCollection collection = this.SearchFor(item.Filter, properties);
            string itemDN = String.Empty;
            if (collection.Count > 0)
            {
                // need to removing the LDAP portion of the path
                itemDN = collection[0].Path.Remove(0, 7);
            }
            else
            {
                this._result.AddLog(new Log("Did not find {0}", item.Filter));
                return;
            }

            // find the target group
            string groupFilter = "(&(objectClass=group)(sAMAccountName=" + item.MemberOf + "))";
            properties = new string[] { "member" };
            collection = this.SearchFor(groupFilter, properties);
            string targetDN = collection[0].Path;
            try
            {
                using (DirectoryEntry dirEntry = new DirectoryEntry(targetDN))
                {
                    if (item.Action == ActiveDirectoryAction.Add)
                    {
                        // is user already a member?
                        if (dirEntry.Properties["member"].Contains(itemDN))
                        {
                            this._result.ExecutedSuccessfully = true;
                            this._result.AddLog(new Log("{0} is already a member of {1}", itemDN, targetDN));
                        }
                        else
                        {
                            dirEntry.Properties["member"].Add(itemDN);
                            dirEntry.CommitChanges();
                            this._result.AddLog(new Log("SUCCESS: {0} {1} to {2}", item.Action, itemDN, targetDN));
                        }
                    }
                    else
                    {
                        // is user not a member of the group?
                        if (dirEntry.Properties["member"].Contains(itemDN))
                        {
                            dirEntry.Properties["member"].Remove(itemDN);
                            dirEntry.CommitChanges();
                            this._result.AddLog(new Log("SUCCESS: {0} {1} to {2}", item.Action, itemDN, targetDN));
                        }
                        else
                        {
                            this._result.ExecutedSuccessfully = true;
                            this._result.AddLog(new Log("{0} is not a member of {1}", itemDN, targetDN));
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                this._result.ExecutedSuccessfully = false;
                this._result.AddLog(new Log("An error occurred while {0} '{1}':\r\n{2}", item.Action, itemDN, ex.Message));
            }
            finally
            {
                // SearchResultCollection cannot release all of its resources when it is garbage collected
                if (collection != null)
                {
                    collection.Dispose();
                }
            }
        }

        /// <summary>
        /// Creates an object in the Active Directory
        /// </summary>
        /// <param name="item">
        /// <c>ActiveDirectoryItem</c> to create
        /// </param>
        private void PerformCreate(ActiveDirectoryItem item)
        {
            DirectorySearcher searcher = new DirectorySearcher();
            string root = this.UserDNSDomainToLdapDomain(Environment.GetEnvironmentVariable("USERDNSDOMAIN"));
            string targetContainer = String.Format(
                "LDAP://{0},{1}",
                item.Path,
                root);
            string target = String.Empty;
            using (DirectoryEntry directoryTarget = new DirectoryEntry(targetContainer))
            {
                string name = String.Empty;
                switch (item.Class)
                {
                    case ObjectClass.OrganizationalUnit:
                        name = "OU=" + item.AccountName;
                        break;
                    case ObjectClass.User:
                        name = "CN=" + String.Format("{0} {1}", item.FirstName, item.LastName);
                        break;
                    default:
                        name = "CN=" + item.AccountName;
                        break;
                }

                // create the new entry so we have something to work with
                DirectoryEntry targetEntry = directoryTarget.Children.Add(name, item.Class.ToString());
                targetEntry.CommitChanges();

                // set individual properites based on class of this item
                switch (item.Class)
                {
                    case ObjectClass.Group:
                        targetEntry.Properties["description"].Add(item.Description);
                        targetEntry.Properties["samAccountName"].Value = item.AccountName;
                        break;
                    case ObjectClass.OrganizationalUnit:
                        targetEntry.Properties["description"].Add(item.Description);
                        break;
                    case ObjectClass.User:
                        targetEntry.Properties["samAccountName"].Value = item.AccountName;
                        targetEntry.Properties["description"].Add(item.Description);
                        if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("USERDNSDOMAIN")))
                        {
                            targetEntry.Properties["UserPrincipalName"].Value = String.Format(
                                "{0}@{1}",
                                item.AccountName,
                                this._options.Domain);
                        }
                        else
                        {
                            targetEntry.Properties["UserPrincipalName"].Value = String.Format(
                                "{0}@{1}",
                                item.AccountName,
                                Environment.GetEnvironmentVariable("USERDNSDOMAIN"));
                        }

                        targetEntry.Properties["givenName"].Value = item.FirstName;
                        targetEntry.Properties["displayName"].Value = String.Format("{0} {1}", item.FirstName, item.LastName);
                        targetEntry.Properties["sn"].Value = item.LastName;
                        targetEntry.CommitChanges();

                        // enable the user account
                        if (targetEntry.Properties["userAccountControl"].Value != null)
                        {
                            int val = (int)targetEntry.Properties["userAccountControl"].Value;
                            targetEntry.Properties["userAccountControl"].Value = val & ~0x2;
                        }
                        else
                        {
                            targetEntry.Properties["userAccountControl"].Value = 0x2;
                        }

                        // set password to default
                        targetEntry.Invoke("SetPassword", new Object[] { "Pa$$word!" });

                        // force user to change password at next logon
                        targetEntry.Properties["pwdLastSet"].Value = 0;
                        break;
                }

                targetEntry.CommitChanges();
                this._result.AddLog(new Log("SUCCESS: {0} {1}", item.Action, item.AccountName));
            }

            if (!String.IsNullOrEmpty(item.MemberOf))
            {
                string[] groups = null;
                if (item.MemberOf.Contains(","))
                {
                    // more than one item?
                    groups = item.MemberOf.Split(
                        new char[] { ',' },
                        StringSplitOptions.RemoveEmptyEntries);
                }
                else
                {
                    groups = new string[] { item.MemberOf };
                }

                foreach (string group in groups)
                {
                    ActiveDirectoryItem temp = new ActiveDirectoryItem()
                    {
                        AccountName = item.AccountName,
                        Action = ActiveDirectoryAction.Add,
                        Class = item.Class,
                        Description = item.Description,
                        Filter = item.Filter,
                        FirstName = item.FirstName,
                        LastName = item.LastName,
                        MemberOf = group,
                        Path = item.Path
                    };

                    // reuse existing framework for adding group members
                    this.PerformAddOrRemove(temp);
                }
            }
        }

        /// <summary>
        /// Deletes an object from the Active Directory
        /// </summary>
        /// <param name="item">
        /// <c>ActiveDirectoryItem</c> to delete
        /// </param>
        private void PerformDelete(ActiveDirectoryItem item)
        {
            DirectorySearcher searcher = new DirectorySearcher();
            string root = this.UserDNSDomainToLdapDomain(Environment.GetEnvironmentVariable("USERDNSDOMAIN"));
            string targetContainer = String.Format(
                "LDAP://{0},{1}",
                item.Path,
                root);
            using (DirectoryEntry directoryTarget = new DirectoryEntry(targetContainer))
            {
                string[] properties = new string[] { "distinguishedName" };
                SearchResultCollection collection = this.SearchFor(item.Filter, properties);
                string itemDN = collection[0].Properties["distinguishedName"].ToString();
                using (DirectoryEntry targetEntry = new DirectoryEntry(itemDN))
                {
                    directoryTarget.Children.Remove(targetEntry);
                    directoryTarget.CommitChanges();
                }
            }
        }

        /// <summary>
        /// Enumerates through objects in the Active Directory
        /// </summary>
        /// <param name="item">
        /// <c>ActiveDirectoryItem</c> to enumerate through
        /// </param>
        private void PerformEnumerate(ActiveDirectoryItem item)
        {
            // hard-code search path for now
            string filter = item.Filter;
            if (!item.FilterBypass)
            {
                // user didn't specify a custom filter, so use the default
                filter = this.GenerateFilter(item);
            }

            string[] properties = null;
            switch (item.Class)
            {
                case ObjectClass.OrganizationalUnit:
                    properties = new string[] { "name", "distinguishedname", "objectguid" };
                    break;
                case ObjectClass.Group:
                    properties = new string[] { "name", "member", "distinguishedname", "objectguid", "memberof" };
                    break;
                case ObjectClass.User:
                    properties = new string[] { "name", "samaccountname", "givenname", "sn", "distinguishedname", "objectguid", "memberof" };
                    break;
            }

            SearchResultCollection collection = this.SearchFor(filter, properties);
            StringBuilder enumeratedData = new StringBuilder();
            try
            {
                if (item.Class == ObjectClass.Group &&
                    (!String.IsNullOrEmpty(item.AccountName) && !item.AccountName.Contains("*")))
                {
                    // return the members of the group
                    string property = "member";
                    foreach (object result in collection[0].Properties[property])
                    {
                        // result is the full DN of this object
                        enumeratedData.AppendLine(String.Format("DATA:{0}={1}", property, result.ToString()));
                    }
                }
                else
                {
                    // return all items that match items filter
                    foreach (SearchResult result in collection)
                    {
                        foreach (string property in properties)
                        {
                            if (result.GetDirectoryEntry().Properties[property].Value == null)
                            {
                                continue;
                            }

                            string value = result.GetDirectoryEntry().Properties[property].Value.ToString();
                            if (result.GetDirectoryEntry().Properties[property].Value is Byte[])
                            {
                                value = new Guid((byte[])result.GetDirectoryEntry().Properties[property][0]).ToString();
                            }

                            if (result.GetDirectoryEntry().Properties[property].Value is Object[])
                            {
                                value = String.Empty;
                                for (int index = 0; index < result.GetDirectoryEntry().Properties[property].Count; index++)
                                {
                                    value += result.GetDirectoryEntry().Properties[property][index].ToString() + "|";
                                }
                            }

                            enumeratedData.AppendLine(
                                String.Format("{0}={1};",
                                result.GetDirectoryEntry().Properties[property].PropertyName,
                                value));
                        }
                    }
                }

                if (!String.IsNullOrEmpty(this._options.OutputPath) && Directory.Exists(this._options.OutputPath))
                {
                    // put all data into log file specified by user
                    Log output = new Log(enumeratedData.ToString());
                    string fileName = String.Format(
                        "{0}-{1}-{2}.txt",
                        item.Class,
                        item.Action,
                        DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"));
                    output.Path = this._options.OutputPath;
                    this._result.AddLog(output);
                }
                else
                {
                    // just put all the enumerated data into the default log stream
                    this._result.AddLog(new Log("DATA:" + enumeratedData.ToString()));
                }
            }
            catch (Exception ex)
            {
                this._result.ExecutedSuccessfully = false;
                this._result.AddLog(new Log("An error occurred while enumerating:\r\n{0}", ex.Message));
            }
            finally
            {
                if (collection != null)
                {
                    // SearchResultCollection cannot release all of its resources when it is garbage collected
                    collection.Dispose();
                }
            }
        }

        /// <summary>
        /// Creates a filter specific to the object class this instance is consuming
        /// </summary>
        /// <param name="item">
        /// Current item being processed by task
        /// </param>
        /// <returns>
        /// LDAP query string to send to Active Directory
        /// </returns>
        private string GenerateFilter(ActiveDirectoryItem item)
        {
            StringBuilder filter = new StringBuilder();

            // we're only going to support some query fields for now
            filter.AppendFormat("(&(objectCategory={0})", item.Class.ToString().ToLower());
            if (item.Class == ObjectClass.User)
            {
                filter.Append("(objectClass=person)");
            }

            if (!String.IsNullOrEmpty(item.AccountName))
            {
                filter.AppendFormat("(sAMAccountName={0})", item.AccountName);
            }

            if (!String.IsNullOrEmpty(item.FirstName))
            {
                filter.AppendFormat("(givenName={0})", item.FirstName);
            }

            if (!String.IsNullOrEmpty(item.LastName))
            {
                filter.AppendFormat("(sn={0})", item.LastName);
            }

            filter.Append(")");
            return filter.ToString();
        }

        /// <summary>
        /// Queries the Active Directory and returns a collection of objects found
        /// </summary>
        /// <param name="filter">
        /// Filter string to limit query results. E.g. (&(objectCategory=user)(objectClass=person))
        /// </param>
        /// <param name="properties">
        /// Array of object properties to include in search results
        /// </param>
        /// <returns>
        /// Collection of entries found
        /// </returns>
        private SearchResultCollection SearchFor(string filter, string[] properties)
        {
            SearchResultCollection collection = null;
            DirectorySearcher searcher = new DirectorySearcher();
            try
            {
                using (DirectoryEntry directoryEntry = new DirectoryEntry(searcher.SearchRoot.Path))
                {
                    searcher = new DirectorySearcher(directoryEntry);
                    searcher.Filter = filter;
                    foreach (string property in properties)
                    {
                        searcher.PropertiesToLoad.Add(property);
                    }

                    collection = searcher.FindAll();
                }
            }
            catch (Exception ex)
            {
                this._result.ExecutedSuccessfully = false;
                this._result.AddLog(new Log("Searching for item failed. Exception: {0}", ex.Message));
            }

            return collection;
        }

        /// <summary>
        /// Converts UserDNSDomain into LDAP query string
        /// </summary>
        /// <param name="userDNSDomainName">
        /// Existing UserDNSDomain value; e.g. hyper.live
        /// </param>
        /// <returns>
        /// LDAP equivalent of <c>userDNSDomainName</c>; e.g. DC=hyper,DC=live
        /// </returns>
        private string UserDNSDomainToLdapDomain(string userDNSDomainName)
        {
            if (String.IsNullOrEmpty(userDNSDomainName))
            {
                // try value passed with parameter block
                userDNSDomainName = this._options.Domain;
            }

            string ldapPath = String.Format(
                "DC={0}",
                userDNSDomainName.Replace(".", ",DC="));
            return ldapPath;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\ConsoleTestTaskModule\ConsoleTestTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.filetaskmodule;

namespace xonline.test.deployment.automation.taskmodules.consoletesttaskmodule
{
    [DeploymentTaskModule("ConsoleTaskModule")]
    public class ConsoleTaskModule : FileModuleBase
    {
        protected enum ConsoleAction
        {
            None = 0,
            Reboot,
            Copy,
            Delete,
            Capture
        }

        #region ConsoleCommand class - Object representation of the ConsoleCommand element
        protected class ConsoleCommand
        {
            public ConsoleAction Action { get; set; }
            public bool Wait { get; set; }
            public bool Cold { get; set; }
            public bool Recurse { get; set; }
            public bool Subdirectories { get; set; }
            public bool Hidden { get; set; }
            public bool Overwrite { get; set; }
            public bool CreateDest { get; set; }
            public bool Force { get; set; }
            public static ConsoleCommand Parse(XPathNavigator node)
            {
                //<ConsoleCommand Action=\"Reboot|Copy|Delete|Dir|Capture\" Wait=\"true|false\" Cold=\"true|false\" Recurse=\"true|false\" Subdirectories=\"true|false\" Hidden=\"true|false\" Overwrite=\"true|false\" CreateDest=\"true|false\" Force=\"true|false\" />");
                if (String.Compare(node.Name, "ConsoleCommand", true) != 0)
                    throw new ApplicationException("Invalid ConsoleCommand element - The element name is not 'ConsoleCommand'.");

                ConsoleCommand cc = new ConsoleCommand();
                string attr = node.GetAttribute("Action", node.NamespaceURI);
                try
                {
                    cc.Action = (ConsoleAction)Enum.Parse(typeof(ConsoleAction), attr, true);
                }
                catch (Exception)
                {
                    throw new ApplicationException(String.Format("Invalid ConsoleCommand element - bad Action: '{0}'", attr));
                }

                bool tmp;
                cc.Wait = false;
                if (Boolean.TryParse(node.GetAttribute("Wait", node.NamespaceURI), out tmp))
                    cc.Wait = tmp;

                cc.Cold = false;
                if (Boolean.TryParse(node.GetAttribute("Cold", node.NamespaceURI), out tmp))
                    cc.Cold = tmp;

                cc.Recurse = false;
                if (Boolean.TryParse(node.GetAttribute("Recurse", node.NamespaceURI), out tmp))
                    cc.Recurse = tmp;

                cc.Subdirectories = false;
                if (Boolean.TryParse(node.GetAttribute("Subdirectories", node.NamespaceURI), out tmp))
                    cc.Subdirectories = tmp;

                cc.Hidden = false;
                if (Boolean.TryParse(node.GetAttribute("Hidden", node.NamespaceURI), out tmp))
                    cc.Hidden = tmp;

                cc.Overwrite = false;
                if (Boolean.TryParse(node.GetAttribute("Overwrite", node.NamespaceURI), out tmp))
                    cc.Overwrite = tmp;

                cc.CreateDest = false;
                if (Boolean.TryParse(node.GetAttribute("CreateDest", node.NamespaceURI), out tmp))
                    cc.CreateDest = tmp;

                cc.Force = false;
                if (Boolean.TryParse(node.GetAttribute("Force", node.NamespaceURI), out tmp))
                    cc.Force = tmp;

                return cc;
            }
        }
        #endregion

        #region ConsoleParam class - Object representation of the Console element
        protected class ConsoleParam
        {
            public string Name { get; set; }
            public string XDKPath { get; set; }
            public static ConsoleParam Parse(XPathNavigator node)
            {
                //<Console Name=\"Name or IP\" XDKPath=\"Path to the XDK console bin commands\" />");
                if (String.Compare(node.Name, "Console", true) != 0)
                    throw new ApplicationException("Invalid Console element - The element name is not 'Console'.");

                ConsoleParam cp = new ConsoleParam();
                cp.Name = "";
                cp.XDKPath = "";

                string attr = node.GetAttribute("Name", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ArgumentException("Invalid Console element - The Name attribute is required");
                cp.Name = attr;

                attr = node.GetAttribute("XDKPath", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                    cp.XDKPath = attr;

                return cp;
            }
        }
        #endregion

        private ConsoleCommandUtil _consoleUtil = null;
        private Location _srcLocation;
        private Location _dstLocation;
        private ConsoleCommand _consoleCommand;

        public ConsoleTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "ConsoleTaskModule";
            _info.Description = "Provides support for managing commands to an Xbox console.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <Console Name=\"Name or IP\" XDKPath=\"Path to the XDK console bin commands\" />");
            desc.AppendLine("  <SourceLocation Path=\"SourcePath\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\"/>");
            desc.AppendLine("  <DestLocation Path=\"DestPath\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\" />");
            desc.AppendLine("  <ConsoleCommand Action=\"Reboot|Copy|Delete|Dir|Capture\" Wait=\"true|false\" Cold=\"true|false\" Recurse=\"true|false\" Subdirectories=\"true|false\" Hidden=\"true|false\" Overwrite=\"true|false\" CreateDest=\"true|false\" Force=\"true|false\" />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("The Console and ConsoleCommand Parameters are required.\r\n");
            desc.AppendLine("For all commands except Capture the SourceLocation is required which uses the DestLocation.\r\n");
            desc.AppendLine("The UserName and Password parameters are optional and should only be used for remote shares\r\n");
            desc.AppendLine("For console paths, the absolute path should be uses (i.e. xE:\\xonline.ini\r\n");
            desc.AppendLine("For the Console commands all of the options default to false if not provided.\r\n");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _result = null;
            _consoleUtil = null;
            _srcLocation = null;
            _dstLocation = null;
            _consoleCommand = null;
        }

        #region ITaskModule Members

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "sourcelocation":
                            _srcLocation = Location.Parse(itor.Current);
                            break;
                        case "destlocation":
                            _dstLocation = Location.Parse(itor.Current);
                            break;
                        case "consolecommand":
                            _consoleCommand = ConsoleCommand.Parse(itor.Current);
                            break;
                        case "console":
                            ConsoleParam consoleParam = ConsoleParam.Parse(itor.Current);
                            _consoleUtil = new ConsoleCommandUtil();
                            _consoleUtil.ConsoleName = consoleParam.Name;
                            _consoleUtil.PathToXDKBinDir = consoleParam.XDKPath;
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override void RemoveAllParameters()
        {
            _result = null;
            _consoleUtil = null;
            _srcLocation = null;
            _dstLocation = null;
            _consoleCommand = null;
        }

        public override TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            if (_consoleUtil == null)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Console is required but not specified."));
            }
            if (_consoleCommand == null)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Console Command is required but not specified."));
                return _result; // Can't go further than this if the File Command is NULL
            }
            if (null == _srcLocation &&
                (_consoleCommand.Action == ConsoleAction.Copy
                || _consoleCommand.Action == ConsoleAction.Delete))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Source Location is required but not specified."));
            }
            if (null == _dstLocation && _consoleCommand.Action == ConsoleAction.Copy)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Destination Location is required but not specified."));
            }

            if (_result.ExecutedSuccessfully)
            {
                // Connect to the remote resources
                if (_srcLocation != null && _srcLocation.IsRemote() && _srcLocation.UserName != null)
                {
                    _srcLocation.Connect();
                }
                if (_dstLocation != null && _dstLocation.IsRemote() && _dstLocation.UserName != null)
                {
                    _dstLocation.Connect();
                }

                Log resultLog = null;
                try
                {
                    int retVal = 0;
                    switch (_consoleCommand.Action)
                    {
                        case ConsoleAction.Reboot:
                            retVal = _consoleUtil.Reboot((_srcLocation == null) ? "" : _srcLocation.Path, _consoleCommand.Wait, _consoleCommand.Cold);
                            resultLog = new Log("Console Reboot returned: {0}", retVal);
                            _result.ExecutedSuccessfully = (retVal == 0);
                            break;
                        case ConsoleAction.Copy:
                            retVal = _consoleUtil.Copy(_srcLocation.Path, _dstLocation.Path, _consoleCommand.Recurse, _consoleCommand.Hidden, _consoleCommand.Overwrite, _consoleCommand.CreateDest, _consoleCommand.Force);
                            resultLog = new Log("Console Copy returned: {0}", retVal);
                            _result.ExecutedSuccessfully = (retVal == 0);
                            break;
                        case ConsoleAction.Delete:
                            retVal = _consoleUtil.Delete(_srcLocation.Path, _consoleCommand.Recurse, _consoleCommand.Hidden, _consoleCommand.Force);
                            resultLog = new Log("Console Delete returned: {0}", retVal);
                            _result.ExecutedSuccessfully = (retVal == 0);
                            break;
                        case ConsoleAction.Capture:
                            retVal = _consoleUtil.Capture(_srcLocation.Path);
                            resultLog = new Log("Console Capture returned: {0}", retVal);
                            _result.ExecutedSuccessfully = (retVal == 0);
                            break;
                        default:
                            _result.ExecutedSuccessfully = false;
                            resultLog = new Log("Unsupported 'Action' value : '{0}'", _consoleCommand.Action);
                            break;
                    }

                    if (null != resultLog)
                        _result.AddLog(resultLog);
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("An error occurred while processing the '{0}' command:\r\n{1}", _consoleCommand.Action, ex));
                }
            }

            return _result;
        }
        #endregion

    }

    [DeploymentTaskModule("XLSATTaskModule")]
    public class XLSATTaskModule : ITaskModule
    {
        public const string DevKitParameter = "devkit";
        public const string XDKPathParameter = "xdkpath";
        public const string TestsListParameter = "testlist";
        public const string LogFolderParameter = "logfolder";
        public const string NumRetriesParameter = "numretries";
        public const string PollRetryParameter = "pollretry";
        public const string PollIntervalParameter = "pollinterval";

        private const string XDKPathDefault = @"C:\Program Files\Microsoft Xbox 360 SDK\bin\win32";
        private const string XLSATResultLogFilenameDefault = "XLSAT_LOG.log";
        private const string XLSATResultLogFilenameDefaultNoExt = "XLSAT_LOG";
        private const string XLSATResultXmlFilenameDefault = "XLSAT_RESULTS.xml";
        private const string XLSATResultXmlFilenameDefaultNoExt = "XLSAT_RESULTS";
        private const string XLSATDoneFilenameDefault = "done.txt";
        private const UInt16 NumTestRetriesDefault = 1;
        private const UInt16 XLSAT_Poll_Retry_Count = 20;     // 20 minutes; 20 x Command_Poll_Interval of 60 seconds
        private const UInt16 XLSAT_Poll_Interval = 60000;     // 60 seconds;

        private ConsoleCommandUtil _consoleUtil;
        private XLSATTest _xlsatTest;
        private string _devkitMachine;
        private string _xboxXDKPath;
        private List<string> _testRunList;
        private string _logFolder;
        private UInt16 _numretries;
        private UInt16 _pollRetryCount;
        private UInt16 _pollInterval;
        private string _testIniFilePath;
        private TaskModuleInfo _info;

        public XLSATTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "XLSATTaskModule";
            _info.Description = "Provides access to run XLSAT tests on a console in order to verify service deployments.";
            _info.ParameterDescriptions = new ParameterDescriptor[] { 
                new ParameterDescriptor(DevKitParameter, "The name or IP address of the devkit where the XLSATs are installed."),
                new ParameterDescriptor(XDKPathParameter, "[Optional] Full path to the Xbox XDK console binaries (i.e. \\bin\\win32\\ folder)"),
                new ParameterDescriptor(TestsListParameter, "Comma-delimited List of tests to run for the XLSAT suite"),
                new ParameterDescriptor(LogFolderParameter, "UNC Temporary folder path to store the XLSAT results before it is parsed."),
                new ParameterDescriptor(NumRetriesParameter, "[Optional] Number of times to run XLSAT suite to retry failures. Default: 1"),
                new ParameterDescriptor(PollRetryParameter, "[Optional] Number of times to poll the console waiting for XLSAT to complete running. Default: 20"),
                new ParameterDescriptor(PollIntervalParameter, "[Optional] Interval (in milliseconds) to wait between polls for the console to complete running XLSATs. Default: 60000")
            };

            _consoleUtil = null;
            _xlsatTest = null;
            _devkitMachine = "";
            _xboxXDKPath = XDKPathDefault;
            _testRunList = new List<string>();
            _logFolder = "";
            _numretries = NumTestRetriesDefault;
            _pollRetryCount = XLSAT_Poll_Retry_Count;
            _pollInterval = XLSAT_Poll_Interval;
            _testIniFilePath = "";
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void RemoveAllParameters()
        {
            _consoleUtil = null;
            _xlsatTest = null;
            _devkitMachine = "";
            _xboxXDKPath = XDKPathDefault;
            _testRunList = new List<string>();
            _logFolder = "";
            _numretries = NumTestRetriesDefault;
            _pollRetryCount = XLSAT_Poll_Retry_Count;
            _pollInterval = XLSAT_Poll_Interval;
            _testIniFilePath = "";
        }

        public void AddParameters(string xmlParameterBlock) { }

        public void AddParameter(string parameterName, string value)
        {
            try
            {
                if (parameterName == null)
                    throw new ArgumentNullException("parameterName");
                if (value == null)
                    throw new ArgumentNullException("value");

                if (_consoleUtil == null)
                {
                    _consoleUtil = new ConsoleCommandUtil();
                }
                if(_xlsatTest == null)
                {
                    _xlsatTest = new XLSATTest();
                }

                string normalizedParameterName = parameterName.ToLower().Trim();

                if (normalizedParameterName == DevKitParameter.ToLower())
                    _devkitMachine = value;
                else if (normalizedParameterName == XDKPathParameter.ToLower())
                    _xboxXDKPath = value;
                else if (normalizedParameterName == TestsListParameter.ToLower())
                    _testRunList = ParseCommaDelimitedList(value);
                else if (normalizedParameterName == LogFolderParameter.ToLower())
                    _logFolder = value;
                else if (normalizedParameterName == NumRetriesParameter.ToLower())
                    _numretries = UInt16.Parse(value);
                else if (normalizedParameterName == PollRetryParameter.ToLower())
                    _pollRetryCount = UInt16.Parse(value);
                else if (normalizedParameterName == PollIntervalParameter.ToLower())
                    _pollInterval = UInt16.Parse(value);

                else
                    throw new ArgumentException("The specified parameter name is invalid", "parameterName");
            }
            catch (FormatException ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter name: {1}", parameterName, ex);
                throw new ArgumentException(String.Format("Caught Exception parsing the Parameter {0}. ex: {1}"), parameterName, ex);
            }

        }

        public TaskResult Perform()
        {
            TaskResult result = new TaskResult();
            // Since there is only one possible succcessful way out, I'm defaulting this to failed.
            result.ExecutedSuccessfully = false;
            int cmdRetVal = 0;

            // Perform basic validation of the parameters
            if (String.IsNullOrEmpty(_devkitMachine))
            {
                result.AddLog(new Log("The 'DevKit' parameter is required, but was not specified."));
                return result;
            }
            if (String.IsNullOrEmpty(_xboxXDKPath))
            {
                result.AddLog(new Log("The 'XDK Path' parameter is required, but was not specified."));
                return result;
            }
            if ((_testRunList == null) || (_testRunList.Count == 0))
            {
                result.AddLog(new Log("The 'Test List' parameter is required, but was not specified."));
                return result;
            }
            if (String.IsNullOrEmpty(_logFolder))
            {
                result.AddLog(new Log("The 'Log Folder' parameter is required, but was not specified."));
                return result;
            }

            //Dynamically create the output folder so we can verify a new file and not an old one
            StringBuilder logFolderName = new StringBuilder("");
            logFolderName.AppendFormat("{0}-{1}-{2}_{3}-{4}-{5}",
                        System.DateTime.Now.Year.ToString("D4"), System.DateTime.Now.Month.ToString("D2"), System.DateTime.Now.Day.ToString("D2"),
                        System.DateTime.Now.Hour.ToString("D2"), System.DateTime.Now.Minute.ToString("D2"), System.DateTime.Now.Second.ToString("D2"));
            string xlsatLogFolderPath = Path.Combine(_logFolder, logFolderName.ToString());
            _testIniFilePath = Path.Combine(xlsatLogFolderPath, "tests.ini");

            try
            {
                //Create the results folder
                FileUtils.CreatePath(xlsatLogFolderPath);
                _consoleCmd.ConsoleName = _devkitMachine;
                _consoleCmd.PathToXDKBinDir = _xboxXDKPath;
                _consoleCmd.PathToLogLocation = xlsatLogFolderPath;

                // Initialize the Test List
                _xlsatTest.InitializeList(_testRunList);
                _xlsatTest.GenerateTestsIniFile(_testIniFilePath, _testRunList);
                if(File.Exists(_testIniFilePath) == false)
                    throw new FileNotFoundException("Tests.ini file not found after being generated", _testIniFilePath);

                UInt16 attemptCount = 0;
                while (attemptCount < _numretries)
                {
                    attemptCount++;
                    //Clean up old accounts
                    cmdRetVal = _consoleUtil.DeleteOldAccounts();
                    if (cmdRetVal != 0)
                    {
                        DACommon.LogEvent(LoggingLevel.Error, "XLSAT: Unable to delete the old Live accounts: {1}", _consoleUtil.Output);
                        result.AddLog(new Log("Unable to delete the old Live accounts.\r\n{0}", _consoleUtil.Output));
                        throw new Exception("Unable to delete the old Live accounts. Console not responding.");
                    }

                    //Run the XLSAT suite - This will throw if it fails since we can't recover if we can't reboot and run the console
                    RunXLSATSuite(xlsatLogFolderPath, result);

                    //Copy the results files
                    string xmlFilename = String.Format("{0}{1}.xml", XLSATResultXmlFilenameDefaultNoExt, attemptCount);
                    cmdRetVal = _consoleUtil.CopyFromConsole(XLSATResultXmlFilenameDefault, xmlFilename);
                    if (cmdRetVal != 0)
                        result.AddLog(new Log("XLSAT_RESULTS.xml file copy failed.\r\n{0}", _consoleUtil.Output));
                    else
                    {
                        // Add a Log entry specifying where the results are.
                        Log xlsatResultsFileLog = new Log();
                        xlsatResultsFileLog.FileName = xmlFilename;
                        xlsatResultsFileLog.Path = xlsatLogFolderPath;
                        result.AddLog(xlsatResultsFileLog);
                    }

                    string logFilename = String.Format("{0}{1}.log", XLSATResultLogFilenameDefaultNoExt, attemptCount);
                    cmdRetVal = _consoleUtil.CopyFromConsole(XLSATResultLogFilenameDefault, XLSATResultLogFilenameDefault);
                    if (cmdRetVal != 0)
                        result.AddLog(new Log("XLSAT_LOG.log file copy failed.\r\n{0}", _consoleUtil.Output));
                    else
                    {
                        Log xlsatResultsFileLog = new Log();
                        xlsatResultsFileLog.FileName = logFilename;
                        xlsatResultsFileLog.Path = xlsatLogFolderPath;
                        result.AddLog(xlsatResultsFileLog);
                        _xlsatTest.FixConsoleTestLog(Path.Combine(xlsatLogFolderPath, XLSATResultLogFilenameDefault), Path.Combine(xlsatLogFolderPath, logFilename));
                    }

                    string xlsatResultXmlPath = Path.Combine(xlsatLogFolderPath, xmlFilename);
                    if (File.Exists(xlsatResultXmlPath) == true)
                    {
                        // Verify results
                        try
                        {
                            _xlsatTest.GetConsoleTestFailure(xlsatResultXmlPath);
                            if (_xlsatTest.AnyTestsFailed == false)
                            {
                                // All tests passed!
                                result.ExecutedSuccessfully = true;
                                break;
                            }
                        }
                        catch (Exception ex)
                        {
                            // If the file copied but didn't parse, retry (can be caused by someone manually retrying or XLSAT crashing)
                            result.AddLog(new Log("{0}", ex.ToString()));
                        }
                    }
                    else
                    {
                        result.AddLog(new Log("XLSAT results file not found: {0}", xlsatLogFolderPath));
                        // Console probably dead, leave
                        // Not sure we need this break anymore now that the Run will throw and break us out if we can't connect to the console.
                        break;
                    }
                }

                LogResults(result);
            }
            catch (Exception ex)
            {
                result.AddLog(new Log("Caught an Global Exception in the XLSAT module:\r\n{0}", ex.ToString()));
            }

            return result;
        }

        public void RunXLSATSuite(string resultsFilePath, TaskResult result)
        {
            try
            {
                int cmdRetVal = 0;
                //Copy the tests.ini file over
                cmdRetVal = _consoleUtil.CopyToConsoleXLSAT(_testIniFilePath);
                if (cmdRetVal != 0)
                {
                    DACommon.LogEvent(LoggingLevel.Error, "XLSAT: Unable to copy Tests.ini file to console: {1}", _consoleUtil.Output);
                    result.AddLog(new Log("Tests.Ini file copy failed.\r\n{0}", _consoleUtil.Output));
                    throw new Exception("Could not copy to console. Failing out.");
                }

                // Delete any previous "Done" files
                string doneFile = Path.Combine(resultsFilePath, XLSATDoneFilenameDefault);
                _consoleUtil.DeleteFromConsole(XLSATDoneFilenameDefault);
                if (File.Exists(doneFile) == true)
                    File.Delete(doneFile);

                //Run the XLSATs
                cmdRetVal = _consoleUtil.RunXLSAT();
                if (cmdRetVal != 0)
                {
                    DACommon.LogEvent(LoggingLevel.Error, "XLSAT: Unable to reboot and run XLSATs: {1}", _consoleUtil.Output);
                    result.AddLog(new Log("Reboot and Run XLSATs failed.\r\n{0}", _consoleUtil.Output));
                    throw new Exception("Could not reboot console. Failing out.");
                }

                //Wait for "Done"
                int loopCounter = 0;
                while (File.Exists(doneFile) == false)
                {
                    System.Threading.Thread.Sleep(_pollInterval);
                    // Add try catch to ignore failure after initial reboot?
                    cmdRetVal = _consoleUtil.CopyFromConsole(XLSATDoneFilenameDefault);
                    loopCounter++;
                    if (loopCounter >= _pollRetryCount)
                    {
                        result.AddLog(new Log("done.txt file not found after timeout period expired.\r\n{0}", _consoleUtil.Output));
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                result.AddLog(new Log("Caught an Exception Running XLSATs:\r\n{0}", ex.ToString()));
                throw ex;
            }
        }

        public void LogResults(TaskResult result)
        {
            string[] failedCases = _xlsatTest.FailedCases;
            foreach(string failedCase in failedCases)
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("XLSAT {0}: Failed", failedCase));
            }
        }

        /// <summary>
        /// Parses a comma delmited list and Trim()s the resulting strings into a List of strings
        /// </summary>
        /// <param name="list">string to be parsed</param>
        /// <returns>List of strings parsed from a comma delimited string</returns>
        protected static List<string> ParseCommaDelimitedList(string list)
        {
            //We're doing the trim post Split rather than as a split char in case someone puts a space after the comma
            string[] parsedList = list.Split(new char[] { ',' });
            List<string> trimmedList = new List<string>();
            foreach (string listItem in parsedList)
            {
                trimmedList.Add(listItem.Trim());
            }

            return trimmedList;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\ConsoleTestTaskModule\Test\ConsoleTestTaskModuleTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Security.Principal;
using System.ComponentModel;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.consoletesttaskmodule;

namespace xonline.test.deployment.automation.taskmodules.consoletesttaskmodule.test
{
    public class ConsoleTestTaskModuleTest
    {
        static void Main()
        {
            string devkit = "trevorm360-1";
            string xdkbinpath = @"E:\Program Files\Microsoft Xbox 360 SDK\bin\win32";
            string logFolderParameter;
            string environment = "default";
            string testcaselist;
            UInt16 numtestretries = 3;
            switch (environment)
            {
                case "CoreNet":
                    testcaselist = "AccountCreationSigninBVT,BillingBVT,EpixValuesBVT,LiveSignupVersionBVT,PresenceBVT,SessionStatsBVT,TitleContentBVT";
                    logFolderParameter = @"\\craigwh-hvs01\Logs\CoreNet\XLSATLogs";
                    break;
                case "TestNet":
                    testcaselist = "AccountCreationSigninBVT,BillingBVT,EpixValuesBVT,LiveSignupVersionBVT,PresenceBVT,SessionStatsBVT,TitleContentBVT";
                    logFolderParameter = @"\\craigwh-hvs01\Logs\TeestNet\XLSATLogs";
                    break;
                default:
                    testcaselist = "AccountCreationSigninBVT,BillingBVT,EpixValuesBVT,LiveSignupVersionBVT,PresenceBVT,SessionStatsBVT,TitleContentBVT,TOUBVT";
                    logFolderParameter = @"\\trevormxdev2\Logs\XLSAT";
                    break;
            }

            XLSATTaskModule consoletestVerifier = new XLSATTaskModule();
            consoletestVerifier.AddParameter(XLSATTaskModule.DevKitParameter, devkit);
            consoletestVerifier.AddParameter(XLSATTaskModule.XDKPathParameter, xdkbinpath);
            consoletestVerifier.AddParameter(XLSATTaskModule.LogFolderParameter, logFolderParameter);
            consoletestVerifier.AddParameter(XLSATTaskModule.TestsListParameter, testcaselist);
            consoletestVerifier.AddParameter(XLSATTaskModule.NumRetriesParameter, numtestretries.ToString());
            TaskResult consoletestResults = consoletestVerifier.Perform();

            Console.WriteLine("XLSATS succeeded = {0}", consoletestResults.ExecutedSuccessfully);
            foreach (Log log in consoletestResults.Logs)
            {
                Console.WriteLine("Log:");
                if(log.Path != null)
                    Console.WriteLine("\tPath: {0}", log.Path);
                if (log.FileName != null)
                    Console.WriteLine("\tFile: {0}", log.FileName);
                if (log.Text != null)
                    Console.WriteLine("\tText: {0}", log.Text);
            }

            Console.WriteLine();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\ConsoleTestTaskModule\XLSATTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;

namespace xonline.test.deployment.automation.taskmodules.consoletesttaskmodule
{
    public enum XLSATResultState
    {
        Pass, Fail, Skipped, NotRun
    }

    public struct XLSATTestCase
    {
        public bool Enabled;
        public XLSATResultState Result;
        public string ErrorString;
    }

    public class XLSATTest
    {
        private Dictionary<string, XLSATTestCase> _xlsatTestCases;

        public bool AnyTestsFailed
        {
            get
            {
                bool testfailurefound = false;
                foreach (XLSATTestCase testcase in _xlsatTestCases.Values)
                {
                    if (testcase.Result == XLSATResultState.Fail)
                    {
                        testfailurefound = true;
                        break;
                    }
                }

                return testfailurefound;
            }
        }

        public string[] FailedCases
        {
            get
            {
                string[] failedcases;
                List<string> failedcasesTemp = new List<string>();
                uint failedcasesCount = 0;

                foreach (KeyValuePair<string, XLSATTestCase> testcase in _xlsatTestCases)
                {
                    if (testcase.Value.Result == XLSATResultState.Fail)
                    {
                        failedcasesTemp.Add(testcase.Key);
                        failedcasesCount++;
                    }
                }
                failedcases = failedcasesTemp.ToArray();

                return failedcases;
            }
        }

        public XLSATTest()
        {
            _xlsatTestCases = new Dictionary<string, XLSATTestCase>();
        }

        public void InitializeList(List<string> testCaseList)
        {
            foreach (string testName in testCaseList)
            {
                XLSATTestCase testCase = new XLSATTestCase();
                testCase.Enabled = true;
                testCase.Result = XLSATResultState.NotRun;
                _xlsatTestCases.Add(testName, testCase);
            }
        }

        public void GenerateTestsIniFile(string filePath, List<string> testCaseList)
        {
            try
            {
                // Load file
                if (File.Exists(filePath) == true)
                {
                    File.Delete(filePath);
                }

                using (StreamWriter sw = new StreamWriter(filePath))
                {
                    string fileLine;

                    for (int testIter = 0; testIter < testCaseList.Count; testIter++ )
                    {
                        fileLine = string.Format("{0} 1", testCaseList[testIter]);
                        // WARNING: The last line CANNOT end with a \r\n or it breaks the XLSAT suite
                        if (testIter != testCaseList.Count - 1)
                            sw.WriteLine(fileLine);
                        else
                            sw.Write(fileLine);
                    }
                    sw.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Caught an Generating the Tests.ini file:\r\n", ex);
            }
        }

        public void GetConsoleTestFailure(string xlsatResultXmlPath)
        {
            // We don't want to let any exeption escape from this method.
            // If this fails, then there's nothing lost.
            try
            {
                // Load the result doc in an XMLDocument
                XmlDocument xlsatXml = new XmlDocument();
                xlsatXml.Load(xlsatResultXmlPath);

                //Iterate through each test result. 1 = Passed, 2 = skipped, 0 = failed
                XmlNodeList testChildNodes = xlsatXml.GetElementsByTagName("test");

                // For each checkResult node, 
                //
                foreach (XmlNode testResult in testChildNodes)
                {
                    string testname = testResult.Attributes["name"].InnerXml;
                    string testresult = testResult.Attributes["result"].InnerXml;
                    XLSATResultState testresultstate;
                    switch (testresult)
                    {
                        case "0":
                            //Test Failed
                            testresultstate = XLSATResultState.Fail;
                            break;
                        case "1":
                            //Test Passed
                            testresultstate = XLSATResultState.Pass;
                            break;
                        case "2":
                            //Test Skipped
                            testresultstate = XLSATResultState.Skipped;
                            break;
                        default:
                            //Unknown result
                            testresultstate = XLSATResultState.NotRun;
                            break;
                    }
                    UpdateResult(testname, testresultstate);
                }

            }
            catch (Exception ex)
            {
                throw new Exception("Caught an Exception Parsing XLSAT xml results:\r\n", ex);
            }
        }

        public void FixConsoleTestLog(string xlsatResultLogPath, string xlsatNewResultLogPath)
        {
            // The default XLSAT_LOG.log file uses \n only instead of \r\n.
            // We can also remove spaces and / and hope to get lucky and find the actual error.
            try
            {
                // Load file
                if (File.Exists(xlsatResultLogPath) != true)
                {
                    throw new FileNotFoundException("Can't find the XLSAT_LOG.log file", xlsatResultLogPath);
                }

                using (StreamReader sr = new StreamReader(xlsatResultLogPath))
                {
                    using (StreamWriter sw = new StreamWriter(xlsatNewResultLogPath))
                    {
                        string fileline;

                        while (sr.Peek() >= 0)
                        {
                            fileline = sr.ReadLine(); // ReadLine removes the \n or a \r\n in case they ever fix XLSAT this becomes a noop.
                            // using a string intermediary in case we want to parse the line later for finding errors
                            sw.WriteLine(fileline); // WriteLine appends our \r\n for us
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Caught an Exception Parsing XLSAT log results:\r\n", ex);
            }
        }

        public void UpdateResult(string testname, XLSATResultState testresult)
        {
            if (_xlsatTestCases.ContainsKey(testname) == true)
            {
                // If the previous result is not already passed
                if (_xlsatTestCases[testname].Result != XLSATResultState.Pass)
                {
                    // if the previous result failed and the new result is skipped don't update
                    if ((_xlsatTestCases[testname].Result == XLSATResultState.Fail)
                        && (testresult == XLSATResultState.Skipped))
                    {
                        //Don't update
                    }
                    else
                    {
                        XLSATTestCase newResult = new XLSATTestCase();
                        newResult.Enabled = _xlsatTestCases[testname].Enabled;
                        newResult.Result = testresult;
                        _xlsatTestCases[testname] = newResult;
                    }
                }
            }
            else
            {
                //Not sure what to do here...
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\DNSTaskModule\DNSResourceRecord.cs ===
﻿using System;
using System.Collections.Generic;
using System.Management;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.dnstaskmodule
{
	public class DNSResourceRecord
	{
        public string DnsServerName { get; set; }
        public string ContainerName { get; set; }
        public string OwnerName { get; set; }
        public string TTL { get; set; }
        public string RecordData { get; set; }
        public string ClassType { get; protected set; }
        public string Class
        {
            get { return String.Format("MicrosoftDNS_{0}Type", ClassType); }
        }
        public string TextRepresentation
        {
            get { return TextRep(); }
        }

        protected DNSResourceRecord() { }

        public bool GetEntry(ManagementScope dnsServer, string zone, string ownerName)
        {
            if (null == dnsServer)
                throw new ArgumentNullException();

            ManagementObject entry = WMI.QuerySingleObject(dnsServer,
                String.Format("Select * From {0} Where OwnerName='{1}.{2}'", Class, ownerName, zone));
            if (entry != null)
            {
                // Fill in the fields from the returned object
                DnsServerName = entry["DnsServerName"] as string;
                ContainerName = entry["ContainerName"] as string;
                OwnerName = entry["OwnerName"] as string;
                TTL = ((UInt32)entry["TTL"]).ToString();
                RecordData = entry["RecordData"] as string;
            }

            return (entry != null);
        }

        public bool Modify(ManagementScope dnsServer)
        {
            if (null == dnsServer)
                throw new ArgumentNullException();

            bool ret = false;
            ManagementObject entry = WMI.QuerySingleObject(dnsServer,
                String.Format("Select * From {0} Where OwnerName='{1}'", Class, OwnerName));
            if (entry != null)
            {
                ret = ModifyInternal(entry);
            }

            return ret;
        }

        public bool Create(ManagementScope dnsServer)
        {
            if (null == dnsServer)
                throw new ArgumentNullException();

            return CreateInternal(dnsServer);
        }

        protected virtual string TextRep()
        {
            return "";
        }
        protected virtual bool CreateInternal(ManagementScope scope)
        {
            return false;
        }
        protected virtual bool ModifyInternal(ManagementObject entry)
        {
            return false;
        }
	}

    public class ATypeRecord : DNSResourceRecord
    {
        public ATypeRecord()
        {
            ClassType = "A";
        }

        protected override string TextRep()
        {
            return String.Format("{0}.{1} IN A {3}", OwnerName, ContainerName, RecordData);
        }

        protected override bool ModifyInternal(ManagementObject entry)
        {
            // only modify settings that are changing
            bool ret = true;
            List<MethodParam> paramList = new List<MethodParam>();
            string setting = entry["IPAddress"] as string;
            if (setting != RecordData)
                paramList.Add(new MethodParam("IPAddress", RecordData));
            setting = ((UInt32)entry["TTL"]).ToString();
            if (setting != TTL)
                paramList.Add(new MethodParam("TTL", TTL));

            if (paramList.Count > 0)
                ret = WMI.InvokeMethod(entry, "Modify", 60, paramList.ToArray());

            return ret;
        }

        protected override bool CreateInternal(ManagementScope scope)
        {
            bool ret = false;
            ManagementClass mc = new ManagementClass(scope, new ManagementPath(Class), null);
            if (mc != null)
            {
                ret = WMI.InvokeMethod(mc, "CreateInstanceFromPropertyData", 60,
                    new MethodParam("DnsServerName", DnsServerName),
                    new MethodParam("ContainerName", ContainerName),
                    new MethodParam("OwnerName", String.Format("{0}.{1}", OwnerName, ContainerName)),
                    new MethodParam("TTL", TTL),
                    new MethodParam("IPAddress", RecordData));
            }

            return ret;
        }
    }

    public class CNAMETypeRecord : DNSResourceRecord
    {
        public CNAMETypeRecord()
        {
            ClassType = "CNAME";
        }

        protected override string TextRep()
        {
            return String.Format("{0}.{1} IN CNAME {2}", OwnerName, ContainerName, RecordData);
        }

        protected override bool ModifyInternal(ManagementObject entry)
        {
            // only modify settings that are changing
            bool ret = true;
            List<MethodParam> paramList = new List<MethodParam>();
            string setting = entry["PrimaryName"] as string;
            if (setting != RecordData)
                paramList.Add(new MethodParam("PrimaryName", RecordData));
            setting = ((UInt32)entry["TTL"]).ToString();
            if (setting != TTL)
                paramList.Add(new MethodParam("TTL", TTL));

            if (paramList.Count > 0)
                ret = WMI.InvokeMethod(entry, "Modify", 60, paramList.ToArray());

            return ret;
        }

        protected override bool CreateInternal(ManagementScope scope)
        {
            bool ret = false;
            ManagementClass mc = new ManagementClass(scope, new ManagementPath(Class), null);
            if (mc != null)
            {
                ret = WMI.InvokeMethod(mc, "CreateInstanceFromPropertyData", 60,
                    new MethodParam("DnsServerName", DnsServerName),
                    new MethodParam("ContainerName", ContainerName),
                    new MethodParam("OwnerName", String.Format("{0}.{1}", OwnerName, ContainerName)),
                    new MethodParam("TTL", TTL),
                    new MethodParam("PrimaryName", RecordData));
            }

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\DNSTaskModule\DNSTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Management;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.dnstaskmodule
{
    /// <summary>
    /// DNSEntryType
    /// Indicates the type of DNS entry to modify. Add entries as DNS types are supported.
    /// </summary>
    public enum DNSEntryType : byte
    {
        A = 1,
        AAAA,
        CNAME
    }

    [DeploymentTaskModule("DNSTaskModule")]
    public class DNSTaskModule : ITaskModule
    {
        #region DNSEntry class - Defines a single DNS entry
        public class DNSEntry
        {
            public string Name { get; private set; }
            public string Value { get; private set; }
            public DNSEntryType Type { get; private set; }

            public static DNSEntry Parse(XPathNavigator node)
            {
                DNSEntry entry = new DNSEntry();

                entry.Type = (DNSEntryType)Enum.Parse(typeof(DNSEntryType), node.GetAttribute("Type", node.NamespaceURI), true);
                entry.Name = node.GetAttribute("Name", node.NamespaceURI);
                entry.Value = node.GetAttribute("Value", node.NamespaceURI);

                return entry;
            }
        }
        #endregion

        #region DNSEntries class - Defines the DNS entries to modify
        public class DNSEntries
        {
            public string DNSServer { get; private set; }
            public string Zone { get; private set; }
            public int TTL { get; private set; }
            public List<DNSEntry> Entries { get; private set; }

            public static DNSEntries Parse(XPathNavigator node)
            {
                DNSEntries dnsEntries = new DNSEntries();

                dnsEntries.Entries = new List<DNSEntry>();
                dnsEntries.DNSServer = node.GetAttribute("DNSServer", node.NamespaceURI);
                dnsEntries.Zone = node.GetAttribute("Zone", node.NamespaceURI);
                int itmp = 0;
                if (!Int32.TryParse(node.GetAttribute("TTLSeconds", node.NamespaceURI), out itmp))
                    itmp = 120;
                dnsEntries.TTL = itmp;

                XPathNodeIterator childNodes = node.SelectChildren(XPathNodeType.Element);
                while (childNodes.MoveNext())
                {
                    switch (childNodes.Current.Name.ToLower())
                    {
                        case "dnsentry":
                            {
                                dnsEntries.Entries.Add(DNSEntry.Parse(childNodes.Current));
                            }
                            break;
                        default:
                            break;
                    }
                }

                return dnsEntries;
            }
        }
        #endregion

        protected static int DEFAULT_TIMEOUT = 60;  // 60 second timeout
        protected DNSEntries _entries;
        protected TaskResult _result;
        protected TaskModuleInfo _info;

        public DNSTaskModule()
        {
            StringBuilder desc = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "DNSTaskModule";
            _info.Description = "Provides support for adding or editing DNS entries.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <DNSEntries DNSServer=\"DNSServerName\" Zone=\"ZoneName\" [TTLSeconds=\"TimeToLive\"]>");
            desc.AppendLine("    <DNSEntry Type=\"EntryType\" Name=\"DNSName\" Value=\"Value\" />");
            desc.AppendLine("  </DNSEntries>\r\n");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("There may be multiple DNSEntry elements within the DNSEntries parent element.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void RemoveAllParameters()
        {
            if (_entries != null)
            {
                if (_entries.Entries != null)
                    _entries.Entries.Clear();
                _entries = null;
            }
        }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "dnsentries":
                            _entries = DNSEntries.Parse(itor.Current);
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public void AddParameter(string parameterName, string value)
        {
            throw new ApplicationException("This module does not support Name/Value pair paramters. Please use an XML parameter block instead.");
        }

        public TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Perform basic validation of the parameters
            if (_entries == null)
            {
                _result.AddLog(new Log("The DNSEntries element is required, but was not specified."));
                _result.ExecutedSuccessfully = false;
            }

            if (_result.ExecutedSuccessfully)
            {
                try
                {
                    // Connect to the DNS Server
                    ManagementScope scope = WMI.ConnectToHost(_entries.DNSServer, "MicrosoftDNS", null, null);
                    if (scope != null)
                    {
                        foreach (DNSEntry entry in _entries.Entries)
                        {
                            DNSResourceRecord rr = null;
                            switch (entry.Type)
                            {
                                case DNSEntryType.A:
                                    rr = new ATypeRecord();
                                    break;
                                case DNSEntryType.AAAA:
                                    // Not supported yet.
                                    break;
                                case DNSEntryType.CNAME:
                                    rr = new CNAMETypeRecord();
                                    break;
                            }

                            if (rr != null)
                            {
                                try
                                {
                                    if (rr.GetEntry(scope, _entries.Zone, entry.Name))
                                    {
                                        // The entry exists, simply modify it
                                        rr.RecordData = entry.Value;
                                        rr.TTL = _entries.TTL.ToString();
                                        rr.Modify(scope);
                                    }
                                    else
                                    {
                                        // The record does not exist - create it
                                        rr.DnsServerName = _entries.DNSServer;
                                        rr.RecordData = entry.Value;
                                        rr.ContainerName = _entries.Zone;
                                        rr.OwnerName = entry.Name;
                                        rr.TTL = _entries.TTL.ToString();
                                        rr.Create(scope);
                                    }
                                }
                                catch (Exception ex)
                                {
                                    _result.AddLog(new Log("An exception occurred modifying the DNS entry {0}: {1}", entry.Name, ex.Message));
                                    _result.ExecutedSuccessfully = false;
                                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "An exception occurred modifying the DNS entry {0}: {1}", entry.Name, ex);
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Exception occurred while processing DNS entries:\r\n{0}", ex);
                    _result.AddLog(new Log("Caught an Exception:\r\n{0}", ex.ToString()));
                    _result.ExecutedSuccessfully = false;
                }
            }

            return _result;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\HealthCheckTaskModule\HealthCheckException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.healthchecktaskmodule
{
    public enum ExceptionListOperator : int
    {
        None = 0,
        Equals = 1,
        Contains,
        NotEqual,
        NotContains
    }

    public class HealthCheckException
    {
        public string Component { get; private set; }
        public string Port { get; private set; }
        public string ResponseCode { get; private set; }
        public string HealthStatus { get; private set; }
        public HealthBlockExceptionCollection HealthBlockExceptions { get; private set; }

        private HealthCheckException() { }

        public static HealthCheckException Parse(XmlNode node)
        {
            if (null == node)
                throw new ArgumentNullException("node");

            HealthCheckException hce = new HealthCheckException();
            hce.Component = node.Attributes["Component"].Value;
            hce.Port = node.Attributes["Port"].Value;
            hce.ResponseCode = node.Attributes["ResponseCode"].Value;
            hce.HealthStatus = node.Attributes["HealthStatus"].Value;
            hce.HealthBlockExceptions = new HealthBlockExceptionCollection();

            foreach (XmlNode hbeNode in node.ChildNodes)
            {
                hce.HealthBlockExceptions.Add(HealthBlockException.Parse(hbeNode));
            }

            return hce;
        }
    }

    public class HealthBlockException
    {
        public string Name { get; private set; }
        public string HealthStatus { get; private set; }
        public HealthBlockErrorDetails Error { get; private set; }

        private HealthBlockException() { }
        public static HealthBlockException Parse(XmlNode node)
        {
            if (null == node)
                throw new ArgumentNullException("node");

            HealthBlockException hbe = new HealthBlockException();
            hbe.Name = node.Attributes["Name"].Value;
            hbe.HealthStatus = node.Attributes["HealthStatus"].Value;
            hbe.Error = null;

            foreach (XmlNode childNode in node.ChildNodes)
            {
                if (childNode.NodeType != XmlNodeType.Element &&
                    String.Compare(childNode.Name, "ErrorDetails", true) != 0)
                    continue;
                hbe.Error = HealthBlockErrorDetails.Parse(childNode);
            }

            return hbe;
        }

        public bool Contains(XmlNode healthBlockNode)
        {
            bool contains = false;

            if ((null != healthBlockNode) &&
                ((Name == "*") || (String.Compare(healthBlockNode.Attributes["Name"].Value, Name, true) == 0)) &&
                (String.Compare(healthBlockNode.Attributes["HealthStatus"].Value, HealthStatus, true) == 0))
            {
                // If there is an error detail defined, check that, too
                if (Error != null)
                {
                    XmlNodeList errorDetails = healthBlockNode.SelectNodes("ErrorDetails");
                    foreach (XmlNode edNode in errorDetails)
                    {
                        switch (Error.Op)
                        {
                            case ExceptionListOperator.Equals:
                                contains = (String.Compare(edNode.InnerText, Error.Value, true) == 0);
                                break;
                            case ExceptionListOperator.Contains:
                                contains = edNode.InnerText.ToLower().Contains(Error.Value.ToLower());
                                break;
                            case ExceptionListOperator.NotEqual:
                                contains = (String.Compare(edNode.InnerText, Error.Value, true) != 0);
                                break;
                            case ExceptionListOperator.NotContains:
                                contains = !(edNode.InnerText.ToLower().Contains(Error.Value.ToLower()));
                                break;
                        }
                        if (contains) break;
                    }
                }
                else
                    contains = true;
            }

            return contains;
        }
    }

    public class HealthBlockErrorDetails
    {
        public ExceptionListOperator Op { get; private set; }
        public string Value { get; private set; }

        private HealthBlockErrorDetails() { }
        public static HealthBlockErrorDetails Parse(XmlNode node)
        {
            if (null == node)
                throw new ArgumentNullException();

            HealthBlockErrorDetails ed = new HealthBlockErrorDetails();
            ed.Op = (ExceptionListOperator)Enum.Parse(typeof(ExceptionListOperator),
                node.Attributes["Op"].Value, true);
            ed.Value = node.InnerText;

            return ed;
        }
    }

    public class HealthCheckExceptionCollection : Collection<HealthCheckException>
    {
        public HealthCheckException GetException(HealthCheck hc)
        {
            if (null == hc)
                return null;

            foreach (HealthCheckException hce in Items)
            {
                if ((String.Compare(hc.Component, hce.Component, true) == 0) &&
                    ((hce.Port == "*") || (String.Compare(hc.Port, hce.Port, true) == 0)))
                {
                    return hce;
                }
            }
            return null;
        }
    }

    public class HealthBlockExceptionCollection : Collection<HealthBlockException>
    {
        public bool Contains(XmlNode healthBlockNode)
        {
            foreach (HealthBlockException hbe in Items)
            {
                if (hbe.Contains(healthBlockNode))
                    return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\FileTaskModule\FileTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.filetaskmodule
{
    public class FileModuleBase : ITaskModule
    {
        #region Location Class - Defines a file location with user credentials
        protected class Location
        {
            public string Path { get; set; }
            public string FileSpec { get; set; }
            public string UserName { get; set; }
            public string Password { get; set; }
            private bool networkDriveMapped = false;

            public static Location Parse(XPathNavigator node)
            {
                Location loc = new Location();
                string attr;
                bool tmp = false;

                loc.Path = "";
                loc.UserName = null;
                loc.Password = null;

                attr = node.GetAttribute("Path", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid element: The Path attribute is missing or empty.");
                loc.Path = attr;

                // The FileSpec attribute is optional and may not appear for all uses of the Location class
                attr = node.GetAttribute("FileSpec", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    loc.FileSpec = System.IO.Path.GetFileName(loc.Path);
                else
                    loc.FileSpec = attr;

                attr = node.GetAttribute("UserName", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    loc.UserName = attr;
                    attr = node.GetAttribute("PasswordEncrypted", node.NamespaceURI);
                    if (!String.IsNullOrEmpty(attr))
                        Boolean.TryParse(attr, out tmp);
                    attr = node.GetAttribute("Password", node.NamespaceURI);
                    if (!String.IsNullOrEmpty(attr))
                    {
                        if (tmp)
                            loc.Password = DataProtector.DecryptFromHexString(attr);
                        else
                            loc.Password = attr;
                    }
                }

                return loc;
            }

            public bool IsRemote()
            {
                return Path.StartsWith(@"\\");
            }

            public void Connect()
            {
                try
                {
                    // Connect to the remote resource
                    NetworkDrive.MapNetworkDrive(System.IO.Path.GetPathRoot(this.Path), null, UserName, Password);
                    networkDriveMapped = true;
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(LoggingLevel.Warning, "Unable to connect to '{0}':\r\n\r\n{1}", System.IO.Path.GetPathRoot(this.Path), ex);
                }
            }

            public void Disconnect()
            {
                if (networkDriveMapped)
                {
                    try
                    {
                        NetworkDrive.UnMapNetworkDrive(System.IO.Path.GetPathRoot(this.Path), true);
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(LoggingLevel.Warning, "An error occurred disconnecting from '{0}':\r\n\r\n{1}", System.IO.Path.GetPathRoot(this.Path), ex);
                    }
                }
            }
        }
        #endregion

        protected TaskModuleInfo _info = null;
        protected Dictionary<string, string> _parameters = null;
        protected TaskResult _result = null;

        protected FileModuleBase()
        {
            _parameters = new Dictionary<string, string>();
            _result = new TaskResult();
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public virtual void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public virtual void AddParameters(string xmlParameterBlock) { }

        public virtual TaskResult Perform()
        {
            throw new NotImplementedException();
        }

        public virtual void RemoveAllParameters()
        {
            throw new NotImplementedException();
        }

        #endregion
    }

    [DeploymentTaskModule("FileTaskModule")]
	public class FileTaskModule : FileModuleBase
    {
        protected enum FileAction
        {
            None = 0,
            Create,
            Copy,
            Move,
            Delete,
            Rename,
            EditAttributes
        }

        #region FileCommand class - Object representation of the FileCommand element
        protected class FileCommand
        {
            public FileAction Action { get; set; }
            public string FileSpec { get; set; }
            public string NewFileName { get; set; }
            public bool Recurse { get; set; }
            public bool Force { get; set; }
            public bool ErrorsAreFatal { get; set; }
            public object CommandData { get; set; }

            public static FileCommand Parse(XPathNavigator node)
            {
                if (String.Compare(node.Name, "FileCommand", true) != 0)
                    throw new ApplicationException("Invalid FileCommand element - The element name is not 'FileCommand'.");

                FileCommand fc = new FileCommand();
                string attr = node.GetAttribute("Action", node.NamespaceURI);
                try
                {
                    fc.Action = (FileAction)Enum.Parse(typeof(FileAction), attr, true);
                }
                catch (Exception)
                {
                    throw new ApplicationException(String.Format("Invalid FileCommand element - bad Action: '{0}'", attr));
                }

                fc.FileSpec = node.GetAttribute("FileSpec", node.NamespaceURI);
                fc.NewFileName = node.GetAttribute("NewFileName", node.NamespaceURI);
                fc.CommandData = null;

                bool tmp;
                fc.Recurse = false;
                if (Boolean.TryParse(node.GetAttribute("Recurse", node.NamespaceURI), out tmp))
                    fc.Recurse = tmp;

                fc.Force= false;
                if (Boolean.TryParse(node.GetAttribute("Force", node.NamespaceURI), out tmp))
                    fc.Force = tmp;

                fc.ErrorsAreFatal = true;
                if (Boolean.TryParse(node.GetAttribute("ErrorsAreFatal", node.NamespaceURI), out tmp))
                    fc.ErrorsAreFatal = tmp;

                // Parse any command-specific data
                XPathNodeIterator children = node.SelectChildren(XPathNodeType.Element);
                switch (fc.Action)
                {
                    case FileAction.Create:
                        if (children.MoveNext())
                        {
                            if (String.Compare(children.Current.Name, "FileContents", true) == 0)
                            {
                                fc.CommandData = children.Current.Value;
                            }
                        }
                        break;
                    case FileAction.EditAttributes:
                        if (children.Count > 0)
                        {
                            AttribData data = new AttribData();
                            fc.CommandData = data;
                            while (children.MoveNext())
                            {
                                switch (children.Current.Name.ToLower())
                                {
                                    case "attribute":
                                        {
                                            string[] attribs = children.Current.GetAttribute("Name", node.NamespaceURI).Split(',');
                                            bool set;
                                            if (Boolean.TryParse(children.Current.GetAttribute("Set", node.NamespaceURI), out set))
                                                data.SetAttributes = set;
                                            for (int i = 0; i < attribs.Length; i++)
                                            {
                                                FileAttributes attrib;
                                                attrib = (FileAttributes)Enum.Parse(typeof(FileAttributes), attribs[i], true);
                                                data.Attributes |= (UInt32)attrib;
                                            }
                                        }
                                        break;
                                    case "filetime":
                                        {
                                            string type = children.Current.GetAttribute("Type", node.NamespaceURI);
                                            switch (type.ToLower())
                                            {
                                                case "creation":
                                                    data.CreateTime = DateTime.Parse(children.Current.Value);
                                                    break;
                                                case "lastaccess":
                                                    data.AccessTime = DateTime.Parse(children.Current.Value);
                                                    break;
                                                case "lastwrite":
                                                    data.WriteTime = DateTime.Parse(children.Current.Value);
                                                    break;
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                        break;
                }

                return fc;
            }
        }

        protected class AttribData
        {
            public UInt32 Attributes { get; set; }
            public bool SetAttributes { get; set; }
            public DateTime CreateTime { get; set; }
            public DateTime WriteTime { get; set; }
            public DateTime AccessTime { get; set; }
            public AttribData()
            {
                Attributes = 0;     // Technically an invalid FileAttributes enum value.
                SetAttributes = true;
                CreateTime = DateTime.MaxValue;
                WriteTime = DateTime.MaxValue;
                AccessTime = DateTime.MaxValue;
            }
        }
        #endregion

        private const int DirectoryCopyTimeout = 60;

        private Location _srcLocation;
        private Location _dstLocation;
        private FileCommand _fileCmd;

        public FileTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "FileTaskModule";
            _info.Description = "Provides tasks for managing files.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <SourceLocation Path=\"BuildSourceBasePath\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\"/>");
            desc.AppendLine("  <DestLocation Path=\"BuildDestBasePath\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\" />");
            desc.AppendLine("  <FileCommand Action=\"Create|Copy|Move|Delete|EditAttributes\" FileSpec=\"fileSpec\" NewFileName=\"fileName\" Recurse=\"true|false\" Force=\"true|false\" ErrorsAreFatal=\"true|false\">");
            desc.AppendLine("    Command-specific parameters (See below)");
            desc.AppendLine("  </FileCommand>");
            desc.AppendLine("</Parameters>");
            desc.AppendLine();
            desc.AppendLine("Command-Specific Parameters");
            desc.AppendLine("Create:");
            desc.AppendLine("    <FileContents>Text to add new newly-created files</FileContents>");
            desc.AppendLine("EditAttributes:");
            desc.AppendLine("    <Attribute Name=\"Read-only|Hidden|System|Archive\" Set=\"true|false\" />");
            desc.AppendLine("    <FileTime Type=\"Creation|LastAccess|LastWrite\">New Date/Time</FileTime>");
            desc.AppendLine();
            desc.AppendLine("The NewFileName attribute is optional and only used with the Copy action to copy a file to a new name. If the FileSpec parameter contains wildcards, this value is ignored.");
            desc.AppendLine("The UserName attribute on the SourceLocation and DestLocation elements is optional. If omitted, the current credentials will be used to connect.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
        }

        #region ITaskModule Members

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "sourcelocation":
                            _srcLocation = Location.Parse(itor.Current);
                            break;
                        case "destlocation":
                            _dstLocation = Location.Parse(itor.Current);
                            break;
                        case "filecommand":
                            _fileCmd = FileCommand.Parse(itor.Current);
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Perform basic validation of the parameters
            if (_fileCmd == null)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The File Command is required but not specified."));
                return _result; // Can't go further than this if the File Command is NULL
            }

            if (_result.ExecutedSuccessfully)
            {
                // Connect to the remote resources
                if (_srcLocation != null && _srcLocation.IsRemote() && _srcLocation.UserName != null)
                {
                    _srcLocation.Connect();
                }
                if (_dstLocation != null && _dstLocation.IsRemote() && _dstLocation.UserName != null)
                {
                    _dstLocation.Connect();
                }

                try
                {
                    switch (_fileCmd.Action)
                    {
                        case FileAction.Create:
                            _result.ExecutedSuccessfully = PerformCreate(_dstLocation.Path, _fileCmd);
                            break;
                        case FileAction.Copy:
                            _result.ExecutedSuccessfully = PerformCopy(_srcLocation.Path, _dstLocation.Path, _fileCmd, false);
                            break;
                        case FileAction.Move:
                            _result.ExecutedSuccessfully = PerformCopy(_srcLocation.Path, _dstLocation.Path, _fileCmd, true);
                            break;
                        case FileAction.Rename:
                            PerformRename();
                            break;
                        case FileAction.Delete:
                            PerformDelete(_srcLocation.Path, _fileCmd);
                            break;
                        case FileAction.EditAttributes:
                            PerformAttributeEdit(_srcLocation.Path, _fileCmd);
                            break;
                        default:
                            _result.ExecutedSuccessfully = false;
                            _result.AddLog(new Log("Unsupported 'Action' value : '{0}'", _fileCmd.Action));
                            break;
                    }
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("An error occurred while processing the '{0}' command:\r\n{1}", _fileCmd.Action, ex));
                }
            }

            // If the ErrorsAreFatal flag is false, report success
            if (!_fileCmd.ErrorsAreFatal) _result.ExecutedSuccessfully = true;

            return _result;
        }

        public override void RemoveAllParameters()
        {
            _srcLocation = null;
            _dstLocation = null;
            _fileCmd = null;
        }

        #endregion

        private bool PerformCreate(string dir, FileCommand fileCmd)
        {
            bool ret = true;

            // If a file already exists, don't try to create it unless Force has been specified
            string createFile = Path.Combine(dir, fileCmd.FileSpec);
            if (File.Exists(createFile))
            {
                if (fileCmd.Force)
                {
                    try
                    {
                        File.SetAttributes(createFile, FileAttributes.Normal);
                        File.Delete(createFile);
                    }
                    catch (Exception ex)
                    {
                        _result.AddLog(new Log("The file '{0}' already exists but could not be deleted: {1}", createFile, ex.Message));
                        DACommon.LogEvent(LoggingLevel.Error, "The file '{0}' already exists but could not be deleted: {1}",
                            createFile, ex.Message);
                        ret = false;
                    }
                }
                else
                {
                    _result.AddLog(new Log("The file '{0}' already exists. Force was not specified, so the file will be left alone.", createFile));
                    DACommon.LogEvent(LoggingLevel.Information, "The file '{0}' already exists. Force was not specified, so the file will be left alone.",
                        createFile);
                    return true;    // return here to avoid re-creating the file
                }
            }

            if (ret)
            {
                // Create the file
                try
                {
                    // Make sure the directory exists
                    FileUtils.CreatePath(dir);

                    using (StreamWriter sw = new StreamWriter(createFile))
                    {
                        // If content has been specified, write it to the file
                        string fileContents = fileCmd.CommandData as string;
                        if (!String.IsNullOrEmpty(fileContents))
                            sw.Write(fileContents);
                    }
                    ret = true;
                }
                catch (Exception ex)
                {
                    _result.AddLog(new Log("The file '{0}' could not be created:\r\n{1}", createFile, ex));
                    ret = false;
                }
            }

            return ret;
        }

        private bool PerformCopy(string src, string dst, FileCommand fileCmd, bool move)
        {
            bool ret = true;

            // Create the base destination directory structure, then copy the files
            try
            {
                FileUtils.CreatePath(dst);
            }
            catch (Exception ex)
            {
                _result.AddLog(new Log(ex.ToString()));
                ret = false;
            }

            if (ret)
            {
                try
                {
                    CopyDirectory(src, dst, fileCmd.FileSpec, fileCmd.NewFileName, move, fileCmd.Recurse, fileCmd.Force, false);
                    ret = true;
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error,
                        "Unable to copy '{0}' from '{1}' to '{2}' : {3}",
                        fileCmd.FileSpec, src, dst, ex);
                    _result.AddLog(new Log("Unable to copy '{0}' from '{1}' to '{2}' : {3}",
                        fileCmd.FileSpec, src, dst, ex.Message));
                    ret = false;
                }
            }

            return ret;
        }

        private void PerformRename()
        {
        }

        private void PerformDelete(string deleteDir, FileCommand fileCmd)
        {
            // If there is no specified filespec, then delete the directory
            if (String.IsNullOrEmpty(fileCmd.FileSpec))
            {
                if (Directory.Exists(deleteDir))
                {
                    // A directory was specified for deletion
                    // This means that all subdirectories must also be deleted
                    try
                    {
                        Directory.Delete(deleteDir, fileCmd.Recurse);
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(LoggingLevel.Warning,
                            "Not all files and directories could be deleted from {0}:\r\n{1}",
                            deleteDir, ex);
                        _result.AddLog(new Log("Warning: Not all files and directories could be deleted from {0}: {1}",
                            deleteDir, ex.Message));
                    }
                }
            }
            else
            {
                if (fileCmd.Recurse)
                {
                    // Recursively delete the files, leaving the directories intact
                    string[] dirs = Directory.GetDirectories(deleteDir);
                    foreach (string dir in dirs)
                    {
                        PerformDelete(dir, fileCmd);
                    }
                }

                // Delete the specified file(s)
                string[] files = Directory.GetFiles(deleteDir, fileCmd.FileSpec);
                foreach (string file in files)
                {
                    if (fileCmd.Force)
                    {
                        try { File.SetAttributes(file, FileAttributes.Normal); }
                        catch (Exception) { }
                    }
                    File.Delete(file);
                }
            }
        }

        private void PerformAttributeEdit(string dir, FileCommand fileCmd)
        {
            if (Directory.Exists(dir))
            {
                string[] files = Directory.GetFiles(dir, fileCmd.FileSpec);
                AttribData data = fileCmd.CommandData as AttribData;
                if (data != null)
                {
                    for (int i = 0; i < files.Length; i++)
                    {
                        try
                        {
                            // Check to see if file attributes need to be changed
                            if (data.Attributes > 0)
                            {
                                if (data.SetAttributes)
                                    File.SetAttributes(files[i], (FileAttributes)data.Attributes);
                                else
                                {
                                    // To clear attributes, we need to get the current
                                    // set of attributes on the file, then remove the
                                    // ones we're supposed to clear, if they're set.
                                    UInt32 currentAttribs = (UInt32)File.GetAttributes(files[i]);
                                    File.SetAttributes(files[i], (FileAttributes)(currentAttribs & (~data.Attributes)));
                                }
                            }

                            // Change the Creation time
                            if (data.CreateTime <= DateTime.Now)
                            {
                                File.SetCreationTime(files[i], data.CreateTime);
                            }

                            // Change the Last Write time
                            if (data.WriteTime <= DateTime.Now)
                            {
                                File.SetLastWriteTime(files[i], data.WriteTime);
                            }

                            // Change the Last Accessed time
                            if (data.AccessTime <= DateTime.Now)
                            {
                                File.SetLastAccessTime(files[i], data.AccessTime);
                            }
                        }
                        catch (Exception ex)
                        {
                            DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to edit the attributes of '{0}':\r\n{1}", files[i], ex);
                        }
                    }
                }
            }
        }

        public void CopyDirectory(string srcDir, string destDir, string fileSpec, string newFileName, bool moveFiles, bool copySubDirectories, bool force, bool removeExtraFiles)
        {
            int timeout = 0;

            // If the target directory doesn't exist, create it
            if (!Directory.Exists(destDir))
            {
                Directory.CreateDirectory(destDir);
            }

            if (copySubDirectories)
            {
                while (timeout <= DirectoryCopyTimeout)
                {
                    try
                    {
                        string[] dirs = Directory.GetDirectories(srcDir);
                        foreach (string dir in dirs)
                        {
                            string dirName = dir.Substring(dir.LastIndexOf('\\') + 1);

                            // Recurse into the function
                            CopyDirectory(dir, Path.Combine(destDir, dirName), fileSpec, newFileName, moveFiles, copySubDirectories, force, removeExtraFiles);
                        }
                        break;
                    }
                    catch (UnauthorizedAccessException)
                    {
                        System.Threading.Thread.Sleep(1000);
                        timeout++;
                    }
                }
            }

            // Copy the files into the destination directory
            List<string> srcFiles = new List<string>(Directory.GetFiles(srcDir, fileSpec));
            List<string> dstFiles = new List<string>(Directory.GetFiles(destDir, fileSpec));
            foreach (string fileName in srcFiles)
            {
                string destFileName;

                // If only one file is being copied and a new filename has been specified,
                // copy the file to the destination directory with the new filename,
                // otherwise, just copy it with the same name as the source file.
                if (srcFiles.Count > 1 || String.IsNullOrEmpty(newFileName))
                    destFileName = Path.Combine(destDir, Path.GetFileName(fileName));
                else
                    destFileName = Path.Combine(destDir, newFileName);

                try
                {
                    if (File.Exists(destFileName))
                    {
                        // if the force flag is false, we compare the Last Modified Time of
                        // both files and only copy them if they've changed
                        if (!force)
                        {
                            if (DateTime.Compare(File.GetLastWriteTime(fileName), File.GetLastWriteTime(destFileName)) > 0)
                            {
                                DACommon.LogEvent(_info.Name, LoggingLevel.Information,
                                    "Overwriting {0} ({1}) with {2} ({3})", destFileName, File.GetLastWriteTime(destFileName),
                                    fileName, File.GetLastWriteTime(fileName));
                                dstFiles.Remove(destFileName);
                            }
                            else
                                continue;
                        }
                    }

                    // Copy the file
                    File.Copy(fileName, destFileName, true);
                    if (moveFiles)
                    {
                        // Delete the source file
                        File.Delete(fileName);
                    }

                    // Remove the filename from the destination file list
                    dstFiles.Remove(destFileName);

                    // Make sure the destination file is nt marked read-only
                    try { File.SetAttributes(destFileName, FileAttributes.Normal); }
                    catch (Exception) { }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error,
                        "Unable to {0} '{1}' to '{2}':\r\n{3}",
                        moveFiles ? "move" : "copy", fileName, destFileName, ex);
                }
            }

            // if the removeExtraFiles flag is set, remove any files from the destination directory that were not in the source directory
            if (removeExtraFiles && dstFiles.Count > 0)
            {
                StringBuilder msg = new StringBuilder();
                msg.AppendLine("Removing extra files from the destination directory:");
                foreach (string fileName in dstFiles)
                {
                    try
                    {
                        File.Delete(fileName);
                        msg.AppendFormat("{0} - Ok\r\n", fileName);
                    }
                    catch (Exception ex)
                    {
                        msg.AppendFormat("{0} - Error: {1}\r\n", fileName, ex.Message);
                    }
                }
                DACommon.LogEvent(_info.Name, LoggingLevel.Information, msg.ToString());
            }
        }
    }

    [DeploymentTaskModule("StageFilesTaskModule")]
    public class StageFilesTaskModule : FileModuleBase
    {
        #region StageDir Class - Object representation of the StageDir element.
        protected class StageDir
        {
            public string Path { get; set; }
            public string TargetPath { get; set; }
            public bool Recurse { get; set; }
            public bool Force { get; set; }
            public bool RemoveExtraFiles { get; set; }
            public static StageDir Parse(XPathNavigator node)
            {
                StageDir dir = new StageDir();
                string attr;
                bool tmp;

                dir.Path = "";
                dir.Recurse = false;
                dir.Force = false;
                dir.RemoveExtraFiles = false;

                attr = node.GetAttribute("Path", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid StageDir element: The Path attribute is missing.");
                dir.Path = attr;

                // TargetPath is optional - it allows files to be staged to different relative locations
                dir.TargetPath = node.GetAttribute("TargetPath", node.NamespaceURI);
                if (dir.TargetPath.Length == 0)
                    dir.TargetPath = dir.Path;
                
                attr = node.GetAttribute("Recurse", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Boolean.TryParse(attr, out tmp))
                        dir.Recurse = tmp;
                }

                attr = node.GetAttribute("Force", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Boolean.TryParse(attr, out tmp))
                        dir.Force = tmp;
                }

                attr = node.GetAttribute("RemoveExtraFiles", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Boolean.TryParse(attr, out tmp))
                        dir.RemoveExtraFiles = tmp;
                }

                return dir;
            }
        }
        #endregion

        #region StageFile Class - Object representation of the StageFile element.
        protected class StageFile
        {
            public string Path { get; set; }
            public string FileSpec { get; set; }
            public string NewFileName { get; set; }
            public bool CreateDstPath { get; set; }
            public bool Force { get; set; }
            public static StageFile Parse(XPathNavigator node)
            {
                StageFile file = new StageFile();
                string attr;
                bool tmp;

                file.Path = "";
                file.FileSpec = "";
                file.CreateDstPath = false;
                file.Force = false;

                attr = node.GetAttribute("Path", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid StageFile element: The Path attribute is missing.");
                file.Path = attr;

                attr = node.GetAttribute("FileSpec", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid StageFile element: The FileSpec attribute is missing.");
                file.FileSpec = attr;

                file.NewFileName = node.GetAttribute("NewFileName", node.NamespaceURI);

                attr = node.GetAttribute("CreateDestPath", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Boolean.TryParse(attr, out tmp))
                        file.CreateDstPath = tmp;
                }

                attr = node.GetAttribute("Force", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Boolean.TryParse(attr, out tmp))
                        file.Force = tmp;
                }

                return file;
            }
        }
        #endregion

        protected Location _srcLocation;
        protected Location _dstLocation;
        protected List<StageDir> _stageDirs;
        protected List<StageFile> _stageFiles;
        protected string _oldVersion = "";
        protected string _newVersion = "";

        public StageFilesTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "StageFilesTaskModule";
            _info.Description = "Provides support for staging files from the build server to the stager.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <SourceLocation Path=\"BuildSourceBasePath\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\"/>");
            desc.AppendLine("  <DestLocation Path=\"BuildDestBasePath\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\" />");
            desc.AppendLine("  <Version OldVersion=\"ExistingVersionFileSpec\" NewVersion=\"NewVersion\" />");
            desc.AppendLine("  <StageDir Path=\"RelativeDir\" TargetPath=\"RelativeDir\" Recurse=\"true|false\" Force=\"true|false\" RemoveExtraFiles=\"true|false\" />");
            desc.AppendLine("  <StageFile Path=\"RelativeDir\" FileSpec=\"File(s)ToCopy\" NewFileName=\"newFileName\" CreateDestPath=\"true|false\" Force=\"true|false\" />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("There may be multiple StageDir and StageFile elements, but only the first Location and Version elements will be used.");
            desc.AppendLine("The NewFileName attribute is optional and is used to copy a file to a new name. If the FileSpec parameter contains wildcards, this value is ignored.");
            desc.AppendLine("Setting the 'RemoveExtraFiles' attribute to true will cause any files in the destination directory that are not in the source directory to be deleted.");
            desc.AppendLine("The UserName attribute on the SourceLocation and DestLocation elements is optional. If omitted, the current credentials will be used to connect.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _stageDirs = new List<StageDir>();
            _stageFiles = new List<StageFile>();
        }

        #region ITaskModule Members

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "sourcelocation":
                            _srcLocation = Location.Parse(itor.Current);
                            break;
                        case "destlocation":
                            _dstLocation = Location.Parse(itor.Current);
                            break;
                        case "version":
                            if (_oldVersion.Length == 0 && _newVersion.Length == 0)
                            {
                                _oldVersion = itor.Current.GetAttribute("OldVersion", itor.Current.NamespaceURI);
                                _newVersion = itor.Current.GetAttribute("NewVersion", itor.Current.NamespaceURI);
                            }
                            break;
                        case "stagedir":
                            {
                                StageDir dir = StageDir.Parse(itor.Current);
                                _stageDirs.Add(dir);
                            }
                            break;
                        case "stagefile":
                            {
                                StageFile file = StageFile.Parse(itor.Current);
                                _stageFiles.Add(file);
                            }
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override TaskResult Perform()
        {
            FileTaskModule ftm = new FileTaskModule();
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (null == _srcLocation)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Source Location is required, but was not specified."));
            }
            if (null == _dstLocation)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Destination Location is required, but was not specified."));
            }

            // Connect to the remote resources
            if (_srcLocation.IsRemote() && _srcLocation.UserName != null)
            {
                _srcLocation.Connect();
            }
            if (_dstLocation.IsRemote() && _dstLocation.UserName != null)
            {
                _dstLocation.Connect();
            }

            // Compare the old version file with the new version number.
            // If they are equal, we won't stage the build.
            string[] versionFiles = null;
            if (Directory.Exists(_dstLocation.Path))
            {
                versionFiles = Directory.GetFiles(_dstLocation.Path, _oldVersion);
                foreach (string oldVer in versionFiles)
                {
                    if (Path.GetFileName(oldVer) == _newVersion)
                    {
                        _result.AddLog(new Log("The '{0}' version already exists in '{1}' and will not be staged.",
                            _newVersion, _dstLocation.Path));
                        _srcLocation.Disconnect();
                        _dstLocation.Disconnect();
                        return _result;
                    }
                }
            }

            // Process the StageDirs first
            string src = "";
            string dst = "";
            foreach (StageDir dir in _stageDirs)
            {
                try
                {
                    src = Path.Combine(_srcLocation.Path, dir.Path);
                    dst = Path.Combine(_dstLocation.Path, dir.TargetPath);
                    ftm.CopyDirectory(src, dst, "*.*", null, false, dir.Recurse, dir.Force, dir.RemoveExtraFiles);
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("Error copying files from '{0}' to '{1}': {2}",
                        src, dst, ex.Message));
                }
            }

            // Process the StageFiles
            foreach (StageFile file in _stageFiles)
            {
                try
                {
                    src = Path.Combine(_srcLocation.Path, file.Path);
                    if (file.CreateDstPath)
                    {
                        // The specified file(s) should be copied into the same folder structure as the source
                        dst = Path.Combine(_dstLocation.Path, file.Path);
                    }
                    else
                    {
                        // The specified file(s) should be copied to the destination location
                        dst = _dstLocation.Path;
                    }
                    ftm.CopyDirectory(src, dst, file.FileSpec, file.NewFileName, false, false, file.Force, false);
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("Error copying '{0}' from '{1}' to '{2}': {3}",
                        file.FileSpec, src, dst, ex.Message));
                }
            }

            // Delete all the old version files and create the new one
            if (_result.ExecutedSuccessfully)
            {
                try
                {
                    if (versionFiles != null)
                    {
                        foreach (string verFile in versionFiles)
                        {
                            File.Delete(verFile);
                        }
                    }
                    if (!String.IsNullOrEmpty(_newVersion))
                        File.Create(Path.Combine(_dstLocation.Path, _newVersion));
                }
                catch (Exception ex)
                {
                    _result.AddLog(new Log("Unable to remove the old version files and create the new one: {0}", ex.Message));
                }
            }

            _srcLocation.Disconnect();
            _dstLocation.Disconnect();

            return _result;
        }

        public override void RemoveAllParameters()
        {
            _srcLocation = null;
            _dstLocation = null;
            _oldVersion = "";
            _newVersion = "";
            _stageDirs.Clear();
            _stageFiles.Clear();
        }

        #endregion
    }

    [DeploymentTaskModule("FileStringReplaceModule")]
    public class FileStringReplaceModule : FileModuleBase
    {
        #region FindReplace Class - Object representation of the Replace element
        protected class FindReplace
        {
            public string FindString { get; set; }
            public string ReplaceString { get; set; }
            public bool IgnoreCase { get; set; }

            public static FindReplace Parse(XPathNavigator node)
            {
                FindReplace fr = new FindReplace();
                string attr = null;
                bool tmp;

                fr.FindString = "";
                fr.ReplaceString = "";
                fr.IgnoreCase = false;

                attr = node.GetAttribute("FindString", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid element : The 'FindString' attribute is missing or empty.");
                fr.FindString = attr;

                fr.ReplaceString = node.GetAttribute("ReplaceString", node.NamespaceURI);

                attr = node.GetAttribute("IgnoreCase", node.NamespaceURI);
                if (Boolean.TryParse(attr, out tmp))
                    fr.IgnoreCase = tmp;

                return fr;
            }
        }
        #endregion

        protected Location _fileLocation;
        protected List<FindReplace> _replaceList;
        protected bool _recurse;

        public FileStringReplaceModule()
        {
            StringBuilder desc = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "FileStringReplaceModule";
            _info.Description = "Provides basic string find/replace for text files.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <FileLocation Path=\"basePath\" FileSpec=\"fileSpec\" UserName=\"UserName\" Password=\"Password\" PasswordEncrypted=\"true|false\"/>");
            desc.AppendLine("  <Replace FindString=\"StringToFind\" ReplaceString=\"ReplacementString\" IgnoreCase=\"true|false\" />");
            desc.AppendLine("  <Recurse />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("Including the Recurse parameter will cause the module to walk through all subdirectories and perform replacements in all files that match the FileSpec.");
            desc.AppendLine("There may be multiple 'Replace' elements to perform multiple find/replace operations on a single file.");
            desc.AppendLine("The replacements are performed in the order given.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _replaceList = new List<FindReplace>();
            _recurse = false;
        }

        #region ITaskModule Members

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "filelocation":
                            _fileLocation = Location.Parse(itor.Current);
                            break;
                        case "replace":
                            _replaceList.Add(FindReplace.Parse(itor.Current));
                            break;
                        case "recurse":
                            _recurse = true;
                            break;
                        default:
                            DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unknown parameter block element: {0}", itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override void RemoveAllParameters()
        {
            _fileLocation = null;
            if (null != _replaceList)
                _replaceList.Clear();
            _recurse = false;
        }

        public override TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (null == _fileLocation)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The File Location is required, but was not specified."));
            }

            try
            {
                // Connect to the remote resources
                if (_fileLocation.IsRemote() && _fileLocation.UserName != null)
                {
                    _fileLocation.Connect();
                }

                // Perform the string replacements in all matching files
                PerformReplacement(_fileLocation.Path, _fileLocation.FileSpec);

                // Disconnect
                _fileLocation.Disconnect();
            }
            catch (Exception ex)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("An unhandled exception occurred performing a string replacement in {0}:\r\n{1}",
                    _fileLocation.Path, ex.Message));
                DACommon.LogEvent(LoggingLevel.Error, "An unhandled exception occurred performing a string replacement in '{0}':\r\n{1}",
                    _fileLocation.Path, ex);
            }

            return _result;
        }

        #endregion

        private void PerformReplacement(string path, string fileSpec)
        {
            if (!Directory.Exists(path))
            {
                _result.AddLog(new Log("The path '{0}' doesn't exist.", path));
                return;
            }

            // If we're doing this recursively, get a list of subdirectories and process them first
            if (_recurse)
            {
                string[] subDirectories = null;
                try
                {
                    subDirectories = Directory.GetDirectories(path);
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to get the subdirectory list for '{0}':\r\n{1}", path, ex);
                    _result.AddLog(new Log("Unable to get the subdirectory list for '{0}'. Replacements in these subdirectories will be skipped.", path));
                }

                if (null != subDirectories && subDirectories.Length > 0)
                {
                    foreach (string subDir in subDirectories)
                    {
                        PerformReplacement(subDir, fileSpec);
                    }
                }
            }

            // Perform the string replacement in all matching files in the current directory
            string[] files = Directory.GetFiles(path, fileSpec);
            foreach (string fileName in files)
            {
                try
                {
                    // To process the find/replace, we will read the original file,
                    // perform the string replacements in-memory, then write the
                    // new data back to the file.
                    string fileData;
                    Encoding fileEnc;
                    using (StreamReader sr = new StreamReader(fileName, true))
                    {
                        fileData = sr.ReadToEnd();
                        fileEnc = sr.CurrentEncoding;
                    }

                    foreach (FindReplace fr in _replaceList)
                    {
                        if (fr.IgnoreCase)
                        {
                            // The Replace method doesn't offer a case-insensitive version
                            // so we need to do this ourselves.
                            StringBuilder replaceData = new StringBuilder(fileData.Length);
                            int blockStart = 0;
                            int blockEnd = 0;
                            while ((blockEnd = fileData.IndexOf(fr.FindString, blockStart, StringComparison.OrdinalIgnoreCase)) >= 0)
                            {
                                // Copy the current block to replaceData
                                replaceData.Append(fileData.Substring(blockStart, blockEnd - blockStart));
                                // Add the replacement value
                                replaceData.Append(fr.ReplaceString);
                                // Reset the blockStart value
                                blockStart = blockEnd + fr.FindString.Length;
                            }

                            if (replaceData.Length > 0)
                            {
                                // Copy the remainder of the string into replaceData
                                replaceData.Append(fileData.Substring(blockStart));
                                fileData = replaceData.ToString();
                            }
                        }
                        else
                            fileData = fileData.Replace(fr.FindString, fr.ReplaceString);
                    }

                    using (StreamWriter sw = new StreamWriter(fileName, false, fileEnc))
                    {
                        sw.Write(fileData);
                    }
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to perform a string replacement in '{0}':\r\n{1}",
                        fileName, ex);
                    _result.AddLog(new Log("Unable to perform a string replacement in '{0}': {1}", fileName, ex.Message));
                    _result.ExecutedSuccessfully = false;
                }
            }
        }
    }

    [DeploymentTaskModule("XMLFileModule")]
    public class XMLFileModule : FileModuleBase
    {
        protected enum XMLCommand : short
        {
            None=0,
            Replace,
            AddElement,
            AddAttribute,
            RemoveElement,
            RemoveAttribute
        }

        protected class XMLCommandData
        {
            public XMLCommand Command { get; private set; }
            public string XPath { get; private set; }
            public string Attribute { get; private set; }
            public string Value { get; private set; }

            public static XMLCommandData Parse(XPathNavigator node)
            {
                XMLCommandData cmd = new XMLCommandData();

                cmd.Command = XMLCommand.None;
                cmd.XPath = "";
                cmd.Attribute = "";
                cmd.Value = "";

                cmd.Command = (XMLCommand)Enum.Parse(typeof(XMLCommand), node.Name, true);
                cmd.XPath = node.GetAttribute("XPath", node.NamespaceURI);
                if (String.IsNullOrEmpty(cmd.XPath))
                    throw new ApplicationException("Invalid element : The 'XPath' attribute is missing or empty.");

                // The other properties depend on the command
                switch (cmd.Command)
                {
                    case XMLCommand.Replace:
                        cmd.Attribute = node.GetAttribute("Attribute", node.NamespaceURI);
                        cmd.Value = node.GetAttribute("NewValue", node.NamespaceURI);
                        break;
                    case XMLCommand.AddElement:
                        cmd.Value = node.InnerXml;
                        break;
                    case XMLCommand.AddAttribute:
                        cmd.Attribute = node.GetAttribute("AttributeName", node.NamespaceURI);
                        cmd.Value = node.GetAttribute("AttributeValue", node.NamespaceURI);
                        break;
                    case XMLCommand.RemoveAttribute:
                        cmd.Attribute = node.GetAttribute("AttributeName", node.NamespaceURI); 
                        break;
                }
                return cmd;
            }
        }

        protected Location _fileLocation;
        protected List<XMLCommandData> _commandList;

        public XMLFileModule()
        {
            StringBuilder desc = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "XMLFileModule";
            _info.Description = "Provides Element and Attribute manipulation for XML files.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <FileLocation Path=\"FilePathAndName\" UserName=\"UserName\" Password=\"Password\" PasswordEncrypted=\"true|false\"/>");
            desc.AppendLine("  <Replace XPath=\"XPathExpression\" [Attribute=\"AttrName\"] NewValue=\"Value\" />");
            desc.AppendLine("  <AddElement XPath=\"XPathExpression\">XML element block to add</AddElement> ");
            desc.AppendLine("  <RemoveElement XPath=\"XPathExpression\" />");
            desc.AppendLine("  <AddAttribute XPath=\"XPathExpression\" AttributeName=\"Name\" AttributeValue=\"Value\" />");
            desc.AppendLine("  <RemoveAttribute XPath=\"XPathExpression\" [AttributeName=\"Name\"] />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("For the Replace command, specifying an Attribute replaces the value of that Attribute, otherwise the value of the element is replaced.");
            desc.AppendLine("The AddElement command allows an entire XML block to be added as a child element of the matched parent element(s).");
            desc.AppendLine("To remove all attributes from an element, leave the AttributeName attribute off the RemoveAttribute element.");
            desc.AppendLine("All commands will be performed against all elements that match the given XPath expression.");
            desc.AppendLine("There may be multiple XML command elements defined. They will be run in the order given.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _commandList = new List<XMLCommandData>();
        }

        #region ITaskModule Members

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "filelocation":
                            _fileLocation = Location.Parse(itor.Current);
                            break;
                        case "replace":
                        case "addelement":
                        case "addattribute":
                        case "removeelement":
                        case "removeattribute":
                            _commandList.Add(XMLCommandData.Parse(itor.Current));
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override void RemoveAllParameters()
        {
            _fileLocation = null;
            if (null != _commandList)
                _commandList.Clear();
        }

        public override TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (null == _fileLocation)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The File Location is required, but was not specified."));
            }

            try
            {
                // Connect to the remote resources
                if (_fileLocation.IsRemote() && _fileLocation.UserName != null)
                {
                    _fileLocation.Connect();
                }

                string[] files = Directory.GetFiles(Path.GetDirectoryName(_fileLocation.Path), Path.GetFileName(_fileLocation.Path));
                foreach (string fileName in files)
                {
                    XmlDocument doc = new XmlDocument();
                    doc.Load(fileName);

                    foreach (XMLCommandData cmd in _commandList)
                    {
                        XmlNodeList nodes = doc.SelectNodes(cmd.XPath);
                        foreach (XmlNode node in nodes)
                        {
                            try
                            {
                                switch (cmd.Command)
                                {
                                    case XMLCommand.Replace:
                                        // Are we changing an attribute or the value?
                                        if (String.IsNullOrEmpty(cmd.Attribute))
                                        {
                                            node.InnerText = cmd.Value;
                                        }
                                        else
                                        {
                                            XmlNode attr = node.Attributes.GetNamedItem(cmd.Attribute);
                                            if (attr != null)
                                                attr.Value = cmd.Value;
                                            else
                                                _result.AddLog(new Log("The '{0}' element does not contain an attribute with the name '{1}'", node.Name, cmd.Attribute));
                                        }
                                        break;
                                    case XMLCommand.AddElement:
                                        // Don't add anything if the provided text in not valid XML
                                        try
                                        {
                                            XmlDocumentFragment frag = doc.CreateDocumentFragment();
                                            frag.InnerXml = cmd.Value;
                                            node.AppendChild(frag);
                                        }
                                        catch (Exception ex)
                                        {
                                            DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to add the element to the existing XML document:\r\n{0}", ex);
                                            _result.AddLog(new Log("Unable to add the element to the existing XML document:\r\n{0}", ex));
                                            _result.ExecutedSuccessfully = false;
                                        }
                                        break;
                                    case XMLCommand.AddAttribute:
                                        {
                                            if (!String.IsNullOrEmpty(cmd.Attribute))
                                            {
                                                if (!String.IsNullOrEmpty(cmd.Value))
                                                {
                                                    XmlAttribute newAttr = doc.CreateAttribute(cmd.Attribute);
                                                    newAttr.Value = cmd.Value;
                                                    node.Attributes.Append(newAttr);
                                                }
                                                else
                                                {
                                                    DACommon.LogEvent(_info.Name, LoggingLevel.Information,
                                                        "The new attribute value is empty, so the {0} attribute will not be added to the {1} element.",
                                                        cmd.Attribute, node.Name);
                                                    _result.AddLog(new Log("The new attribute value is empty, so the {0} attribute will not be added to the {1} element.",
                                                        cmd.Attribute, node.Name));
                                                }
                                            }
                                            else
                                            {
                                                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to add an attribute with no name to the {0} element.", node.Name);
                                                _result.AddLog(new Log("Unable to add an attribute with no name to the {0} element.", node.Name));
                                                _result.ExecutedSuccessfully = false;
                                            }
                                        }
                                        break;
                                    case XMLCommand.RemoveElement:
                                        if (node.ParentNode != null)
                                        {
                                            node.ParentNode.RemoveChild(node);
                                        }
                                        else
                                        {
                                            doc.RemoveChild(node);
                                        }
                                        break;
                                    case XMLCommand.RemoveAttribute:
                                        node.Attributes.RemoveNamedItem(cmd.Attribute);
                                        break;
                                }
                            }
                            catch (Exception ex)
                            {
                                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "An error occurred processing the {0} command on the {1} element:\r\n{2}",
                                    cmd.Command.ToString(), node.Name, ex);
                                _result.AddLog(new Log("An error occurred processing the {0} command on the {1} element: {2}",
                                    cmd.Command.ToString(), node.Name, ex.Message));
                                _result.ExecutedSuccessfully = false;
                            }
                        }
                    }

                    // Save the changes
                    doc.Save(fileName);
                }

                // Disconnect
                _fileLocation.Disconnect();
            }
            catch (Exception ex)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("An unhandled exception occurred while trying to modify '{0}':\r\n{1}",
                    _fileLocation.Path, ex.Message));
                DACommon.LogEvent(LoggingLevel.Error, "An unhandled exception occurred while trying to modify '{0}':\r\n{1}",
                    _fileLocation.Path, ex);
            }

            return _result;
        }

        #endregion
    }

    [DeploymentTaskModule("CompressionFileModule")]
    public class CompressionFileModule : FileModuleBase
    {
        protected Location _zipLocation = null;
        protected Location _filesLocation = null;
        protected string _action = "";
        protected string _fileSpec = "";
        protected bool _useDirNames = false;

        public CompressionFileModule()
        {
            StringBuilder desc = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "CompressionFileModule";
            _info.Description = "Provides file compression and decompression support.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <FilesLocation Path=\"Path\" UserName=\"UserName\" Password=\"Password\" PasswordEncrypted=\"true|false\" />");
            desc.AppendLine("  <ZipLocation Path=\"ZipFilePathAndName\" UserName=\"UserName\" Password=\"Password\" PasswordEncrypted=\"true|false\" />");
            desc.AppendLine("  <Command Action=\"compress|decompress\" FileSpec=\"FilesToUse\" UseDirectoryNames=\"true|false\" />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("");
            desc.AppendLine("");
            desc.AppendLine("");
            desc.AppendLine("");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
        }

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "ziplocation":
                            _zipLocation = Location.Parse(itor.Current);
                            break;
                        case "fileslocation":
                            _filesLocation = Location.Parse(itor.Current);
                            break;
                        case "command":
                            {
                                _action = itor.Current.GetAttribute("Action", itor.Current.NamespaceURI);
                                _fileSpec = itor.Current.GetAttribute("FileSpec", itor.Current.NamespaceURI);
                                bool tmp;
                                _useDirNames = false;
                                if (Boolean.TryParse(itor.Current.GetAttribute("UseDirectoryNames", itor.Current.NamespaceURI), out tmp))
                                    _useDirNames = tmp;
                            }
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override void RemoveAllParameters()
        {
            _zipLocation = null;
            _filesLocation = null;
            _action = "";
            _useDirNames = false;
        }

        public override TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            if (null == _zipLocation)
            {
                _result.AddLog(new Log("The 'ZipLocation' parameter is required, but was not supplied."));
                _result.ExecutedSuccessfully = false;
            }
            if (null == _filesLocation)
            {
                _result.AddLog(new Log("The 'FilesLocation' parameter is required, but was not supplied."));
                _result.ExecutedSuccessfully = false;
            }
            if (String.IsNullOrEmpty(_action))
            {
                _result.AddLog(new Log("The 'Action' parameter is required, but was not supplied."));
                _result.ExecutedSuccessfully = false;
            }

            if (_result.ExecutedSuccessfully)
            {
                // Connect to the file locations
                if (_zipLocation.IsRemote() && !String.IsNullOrEmpty(_zipLocation.UserName))
                    _zipLocation.Connect();
                if (_filesLocation.IsRemote() && !String.IsNullOrEmpty(_filesLocation.UserName))
                    _filesLocation.Connect();

                try
                {
                    switch (_action.ToLower())
                    {
                        case "compress":
                            PerformCompress(_filesLocation.Path, _fileSpec, _zipLocation.Path);
                            break;
                        case "decompress":
                            PerformDecompress(_zipLocation.Path, _fileSpec, _filesLocation.Path, _useDirNames);
                            break;
                        default:
                            throw new ApplicationException(String.Format("Invalid Action specified: '{0}'", _action));
                    }
                }
                catch (Exception ex)
                {
                    _result.AddLog(new Log("An exception was thrown while processing the '{0}' command: {1}", _action, ex.Message));
                    _result.ExecutedSuccessfully = false;
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Exception caught while trying to perform the '{0}' action:\r\n{1}",
                        _action, ex);
                }
            }

            return _result;
        }

        private void PerformCompress(string srcPath, string fileSpec, string zipPath)
        {
            // Make sure the destination location exists
            try
            {
                FileUtils.CreatePath(Path.GetDirectoryName(zipPath));

                // If a zip file already exists at this location, delete it before trying to create the new one
                if (File.Exists(zipPath))
                {
                    try { File.Delete(zipPath); }
                    catch (Exception) { }
                }

                using (Ionic.Zip.ZipFile zipFile = new Ionic.Zip.ZipFile())
                {
                    zipFile.AddSelectedFiles(fileSpec, srcPath, "", true);
                    zipFile.Save(zipPath);
                }
            }
            catch (Exception ex)
            {
                _result.AddLog(new Log("Unable to create the Zip file '{0}':{1}", zipPath, ex.Message));
                _result.ExecutedSuccessfully = false;
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to create the zip file '{0}':\r\n{1}", zipPath, ex);
            }
        }

        private void PerformDecompress(string zipPath, string fileSpec, string dstPath, bool useDirNames)
        {
            if (!File.Exists(zipPath))
            {
                _result.AddLog(new Log("'{0}' does not exist.", zipPath));
                return;
            }

            using (Ionic.Zip.ZipFile zipFile = new Ionic.Zip.ZipFile(zipPath))
            {
                bool getAll = String.IsNullOrEmpty(fileSpec);

                zipFile.FlattenFoldersOnExtract = !useDirNames;
                zipFile.ExtractExistingFile = Ionic.Zip.ExtractExistingFileAction.OverwriteSilently;

                System.Collections.ObjectModel.ReadOnlyCollection<Ionic.Zip.ZipEntry> entries = null;
                if (getAll)
                    entries = zipFile.Entries;
                else
                    entries = new System.Collections.ObjectModel.ReadOnlyCollection<Ionic.Zip.ZipEntry>(
                        new List<Ionic.Zip.ZipEntry>(zipFile.SelectEntries(fileSpec)));

                if (entries.Count > 0)
                {
                    foreach (Ionic.Zip.ZipEntry entry in entries)
                    {
                        entry.Extract(dstPath);
                    }
                }
                else
                {
                    if (getAll)
                        _result.AddLog(new Log("There are no entries in the zip file '{0}'.", zipPath));
                    else
                        _result.AddLog(new Log("No entries in the zip file '{0}' match the given filespec '{1}'", zipPath, fileSpec));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\EmailTaskModule\EmailTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Mail;
using System.Text;
using System.Web;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.emailtaskmodule
{
    public enum MessageTextPosition
    {
        Top = 0,
        Bottom
    }
    public enum MessageTextStyle
    {
        Normal = 0,
        Callout,
        Error
    }
    public enum MessageContentType
    {
        Text = 0,
        HTML,
        XML
    }

    [DeploymentTaskModule("EmailTaskModule")]
    public class EmailTaskModule : ITaskModule
    {
        #region MessageHeader class - Defines the email message
        private class MessageHeader
        {
            public string ToList { get; private set; }
            public string CcList { get; private set; }
            public string BccList { get; private set; }
            public MailPriority Priority { get; private set; }
            public Int32 MaxRetries { get; private set; }

            private MessageHeader()
            {
                ToList = "";
                CcList = "";
                BccList = "";
                Priority = MailPriority.Normal;
                MaxRetries = 2;
            }

            public static MessageHeader Parse(XmlNode node)
            {
                MessageHeader msgHeader = new MessageHeader();

                // Get the attributes of the email message
                foreach (XmlAttribute attr in node.Attributes)
                {
                    switch (attr.Name.ToLower())
                    {
                        case "tolist":
                            msgHeader.ToList = NormalizeEmailAddressList(attr.Value);
                            break;
                        case "cclist":
                            msgHeader.CcList = NormalizeEmailAddressList(attr.Value);
                            break;
                        case "bcclist":
                            msgHeader.BccList = NormalizeEmailAddressList(attr.Value);
                            break;
                        case "priority":
                            try
                            {
                                msgHeader.Priority = (MailPriority)Enum.Parse(typeof(MailPriority), attr.Value, true);
                            }
                            catch (ArgumentException) { /* Invalid enumeration value - default to Normal */ }
                            break;
                        case "maxretries":
                            {
                                Int32 retries;
                                if (Int32.TryParse(attr.Value, out retries))
                                    msgHeader.MaxRetries = retries;
                            }
                            break;
                    }
                }

                return msgHeader;
            }

            private static string NormalizeEmailAddressList(string addrList)
            {
                string[] addrs = addrList.Split(new char[] { ',', ';' });
                StringBuilder sb = new StringBuilder();

                // Make sure every address has a domain name
                foreach (string addr in addrs)
                {
                    if (addr.Contains("@"))
                        sb.Append(addr);
                    else
                        sb.AppendFormat("{0}{1}", addr, c_emailDomainName);
                    sb.Append(',');
                }

                // Remove the trailing comma
                if (sb.Length > 1)
                    sb.Length--;

                return sb.ToString();
            }
        }
        #endregion

        #region MessageBody class
        private class MessageBody
        {
            private const string c_htmlContentTopTag = "<div id=\"contentTop\" style=\"margin-bottom:10px;\">";
            private const string c_htmlContentMainTag = "<div id=\"contentMain\" style=\"margin-top:20px; margin-bottom:20px;\">";
            private const string c_htmlContentBottomTag = "<div id=\"contentBottom\" style=\"margin-top:10px;\">";
            private const string c_htmlContentEndTag = "</div>";
            private const string c_htmlErrorStyleTag = "<p style=\"color:Red; font-family:Arial; font-weight:bold; font-size:1em; margin-top:10px;\">";
            private const string c_htmlCalloutStyleTag = "<p style=\"background-color:#FFFFCC; color:#000000; font-family:Arial; font-size:.8em; font-weight:normal; margin-right:10px; margin-top:10px; padding:8px; border: 1px solid #000000;\">";
            private const string c_htmlNormalStyleTag = "<p style=\"color:Black; font-family:Arial; font-weight:Normal; font-size:.8em; margin-top:10px;\">";
            private const string c_htmlStyleEndTag = "</p>";

            public MessageContentType ContentType { get; private set; }
            public String ContentSource { get; private set; }
            public String ContentTransform { get; private set; }

            private List<MessageText> _mtTop = null;
            private List<MessageText> _mtBottom = null;
            private string _styleList = null;

            private MessageBody()
            {
                ContentType = MessageContentType.Text;
                ContentSource = "";
                ContentTransform = "";
            }

            public static MessageBody Parse(XmlNode node)
            {
                MessageBody body = new MessageBody();

                // Get the type
                try
                {
                    foreach (XmlAttribute attr in node.Attributes)
                    {
                        if (String.Compare(attr.Name, "Type", true) == 0)
                        {
                            body.ContentType = (MessageContentType)Enum.Parse(typeof(MessageContentType), attr.Value, true);
                            break;
                        }
                    }
                }
                catch (ArgumentException) { }

                // Look for all MessageText blocks
                XmlNodeList mtNodes = node.SelectNodes("MessageText");
                foreach (XmlNode mtNode in mtNodes)
                {
                    MessageText mt = MessageText.Parse(mtNode);
                    body.AddMessageText(mt);
                }

                // Get the Content Source and Transform
                XmlNode contentSrc = node.SelectSingleNode("ContentSource");
                if (contentSrc != null)
                {
                    foreach (XmlAttribute attr in contentSrc.Attributes)
                    {
                        if (String.Compare(attr.Name, "Filename", true) == 0)
                        {
                            body.ContentSource = attr.Value;
                        }
                        else if (String.Compare(attr.Name, "Transform", true) == 0)
                        {
                            body.ContentTransform = attr.Value;
                        }
                    }
                }

                return body;
            }

            private void AddMessageText(MessageText mt)
            {
                if (MessageTextPosition.Top == mt.Position)
                {
                    if (null == _mtTop)
                        _mtTop = new List<MessageText>();
                    _mtTop.Add(mt);
                }
                else
                {
                    if (null == _mtBottom)
                        _mtBottom = new List<MessageText>();
                    _mtBottom.Add(mt);
                }
            }

            private string GetMessageText(MessageTextPosition position)
            {
                StringBuilder msg = new StringBuilder();

                if (MessageTextPosition.Top == position)
                {
                    if (_mtTop != null)
                    {
                        if (ContentType != MessageContentType.Text)
                            msg.AppendLine(c_htmlContentTopTag);

                        foreach (MessageText mt in _mtTop)
                        {
                            switch (mt.Style)
                            {
                                case MessageTextStyle.Error:
                                    if (MessageContentType.Text == ContentType)
                                    {
                                        msg.AppendFormat("{0}\r\n", mt.Text);
                                    }
                                    else
                                    {
                                        msg.AppendFormat("{0}{1}{2}\r\n", c_htmlErrorStyleTag, mt.Text, c_htmlStyleEndTag);
                                    }
                                    break;
                                case MessageTextStyle.Callout:
                                    if (MessageContentType.Text == ContentType)
                                    {
                                        msg.AppendFormat("{0}\r\n{1}\r\n{2}\r\n", new String('=', 80), mt.Text, new String('=', 80));
                                    }
                                    else
                                    {
                                        msg.AppendFormat("{0}{1}{2}\r\n", c_htmlCalloutStyleTag, mt.Text, c_htmlStyleEndTag);
                                    }
                                    break;
                                case MessageTextStyle.Normal:
                                    if (MessageContentType.Text == ContentType)
                                    {
                                        msg.AppendFormat("{0}\r\n", mt.Text);
                                    }
                                    else
                                    {
                                        msg.AppendFormat("{0}{1}{2}\r\n", c_htmlNormalStyleTag, mt.Text, c_htmlStyleEndTag);
                                    }
                                    break;
                            }
                        }
                        if (ContentType == MessageContentType.Text)
                            msg.AppendLine("\r\n");
                        else
                            msg.AppendLine(c_htmlContentEndTag);
                    }
                }
                else
                {
                    if (_mtBottom != null)
                    {
                        if (ContentType == MessageContentType.Text)
                            msg.AppendLine("\r\n");
                        else
                            msg.AppendLine(c_htmlContentBottomTag);

                        foreach (MessageText mt in _mtBottom)
                        {
                            switch (mt.Style)
                            {
                                case MessageTextStyle.Error:
                                    if (MessageContentType.Text == ContentType)
                                    {
                                        msg.AppendFormat("{0}\r\n", mt.Text);
                                    }
                                    else
                                    {
                                        msg.AppendFormat("{0}{1}{2}\r\n", c_htmlErrorStyleTag, mt.Text, c_htmlStyleEndTag);
                                    }
                                    break;
                                case MessageTextStyle.Callout:
                                    if (MessageContentType.Text == ContentType)
                                    {
                                        msg.AppendFormat("{0}\r\n{1}\r\n{2}\r\n", new String('=', 80), mt.Text, new String('=', 80));
                                    }
                                    else
                                    {
                                        msg.AppendFormat("{0}{1}{2}\r\n", c_htmlCalloutStyleTag, mt.Text, c_htmlStyleEndTag);
                                    }
                                    break;
                                case MessageTextStyle.Normal:
                                    if (MessageContentType.Text == ContentType)
                                    {
                                        msg.AppendFormat("{0}\r\n", mt.Text);
                                    }
                                    else
                                    {
                                        msg.AppendFormat("{0}{1}{2}\r\n", c_htmlNormalStyleTag, mt.Text, c_htmlStyleEndTag);
                                    }
                                    break;
                            }
                        }
                        if (ContentType != MessageContentType.Text)
                            msg.AppendLine(c_htmlContentEndTag);
                    }
                }

                return msg.ToString();
            }

            private string GetContent()
            {
                // If there is no content specified, just return an empty string
                if (String.IsNullOrEmpty(ContentSource))
                    return String.Empty;

                StringBuilder content = new StringBuilder();
                string htmlContent = null;

                if (MessageContentType.XML == ContentType &&
                    !String.IsNullOrEmpty(ContentTransform))
                {
                    // If a transform is specified, load it and transform the XML
                    XslCompiledTransform xslt = new XslCompiledTransform();
                    using (StringWriter transformedXml = new StringWriter())
                    {
                        XsltSettings settings = new XsltSettings();
                        settings.EnableDocumentFunction = true;
                        xslt.Load(ContentTransform, settings, null);
                        xslt.Transform(ContentSource, null, transformedXml);
                        htmlContent = transformedXml.ToString();
                    }
                }
                else
                {
                    // Load the content from the specified file
                    using (StreamReader sr = new StreamReader(ContentSource))
                    {
                        if (MessageContentType.Text == ContentType)
                            content.AppendLine(HttpUtility.HtmlEncode(sr.ReadToEnd()));
                        else
                            htmlContent = sr.ReadToEnd();
                    }
                }

                if (ContentType != MessageContentType.Text)
                {
                    // For HTML content (including transformed XML), we need to extract the list of styles from the <head> tag
                    // and then extract everything from the <body> tag. This is because this is all going into a new HTML
                    // document with its own <head> and <body> tags
                    _styleList = ExtractStyles(htmlContent);
                    htmlContent = ExtractBody(htmlContent);

                    content.AppendLine(c_htmlContentMainTag);
                    content.AppendLine(htmlContent);
                    content.AppendLine(c_htmlContentEndTag);
                }

                return content.ToString();
            }

            private string ExtractStyles(string html)
            {
                string styles = null;
                if (html != null)
                {
                    int stylesStart, stylesEnd;
                    stylesStart = html.IndexOf("<style");
                    if (stylesStart >= 0)
                    {
                        stylesEnd = html.IndexOf("</style>", stylesStart + 8);
                        if (stylesEnd > stylesStart)
                        {
                            stylesEnd += 9;
                            styles = html.Substring(stylesStart, stylesEnd - stylesStart).Replace("\r\n", "");
                        }
                    }
                }
                return styles;
            }

            private string ExtractBody(string html)
            {
                string body = null;
                if (html != null)
                {
                    int bodyStart, bodyEnd;
                    bodyStart = html.IndexOf("<body");
                    if (bodyStart >= 0)
                    {
                        // Find the end of the opening body tag
                        bodyEnd = html.IndexOf('>', bodyStart);
                        if (bodyEnd > bodyStart)
                        {
                            bodyStart = bodyEnd + 1;
                            // Now find the closing tag
                            bodyEnd = html.IndexOf("</body>", bodyStart);
                            if (bodyEnd > bodyStart)
                            {
                                body = html.Substring(bodyStart, bodyEnd - bodyStart);
                            }
                        }
                    }
                }
                return body;
            }

            public override string ToString()
            {
                StringBuilder body = new StringBuilder();
                if (ContentType != MessageContentType.Text)
                {
                    string htmlContent = GetContent();

                    body.AppendLine("<html xmlns=\"http://www.w3.org/1999/xhtml\" >");
                    if (!String.IsNullOrEmpty(_styleList))
                    {
                        body.AppendLine("<head>");
                        body.AppendLine(_styleList);
                        body.AppendLine("</head>");
                    }
                    body.AppendLine("<body>");
                    body.Append(GetMessageText(MessageTextPosition.Top));
                    body.Append(htmlContent);
                    body.Append(GetMessageText(MessageTextPosition.Bottom));
                    body.AppendLine("</body>");
                    body.AppendLine("</html>");
                }
                else
                {
                    body.Append(GetMessageText(MessageTextPosition.Top));
                    body.Append(GetContent());
                    body.Append(GetMessageText(MessageTextPosition.Bottom));
                }
                return body.ToString();
            }
        }
        #endregion

        #region MessageText class
        private class MessageText
        {
            public MessageTextPosition Position { get; private set; }
            public MessageTextStyle Style { get; private set; }
            public String Text { get; private set; }

            private MessageText()
            {
                Position = MessageTextPosition.Top;
                Style = MessageTextStyle.Normal;
                Text = "";
            }

            public static MessageText Parse(XmlNode node)
            {
                MessageText mt = new MessageText();

                foreach (XmlAttribute attr in node.Attributes)
                {
                    try
                    {
                        switch (attr.Name.ToLower())
                        {
                            case "position":
                                mt.Position = (MessageTextPosition)Enum.Parse(typeof(MessageTextPosition), attr.Value, true);
                                break;
                            case "style":
                                mt.Style = (MessageTextStyle)Enum.Parse(typeof(MessageTextStyle), attr.Value, true);
                                break;
                        }
                    }
                    catch (ArgumentException) { }
                }

                mt.Text = HttpUtility.HtmlDecode(node.InnerText);

                return mt;
            }
        }
        #endregion

        private const string c_smtpHostName = "smtphost.redmond.corp.microsoft.com";
        private const string c_emailDomainName = "@microsoft.com";

        private TaskModuleInfo _info = null;
        private MessageHeader _header;
        private MessageBody _body;
        private string _subject;

        public EmailTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "EmailTaskModule";
            _info.Description = "Provides support for sending email messages via SMTP";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <MessageHeader ToList=\"Alias list\" [CcList=\"Alias list\"] [BccList=\"Alias list\"] [Priority=\"Low|Normal|High\"] [MaxRetries=\"Max number of times to retry sending\"] />");
            desc.AppendLine("  <Subject>Subject line text</Subject>");
            desc.AppendLine("  <MessageBody Type=\"Text|HTML|XML\">");
            desc.AppendLine("    [<MessageText [Placement=\"Top|Bottom\"] [Style=\"Normal|Callout|Error\"]>Additional text to display in the message</MessageText>]");
            desc.AppendLine("    [<ContentSource Filename=\"Path and name of the content file\" [Transform=\"Path and name of an XSLT file\"] />");
            desc.AppendLine("  </MessageBody>");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("* This module never reports a failed execution although failures will still be reported.");
            desc.AppendLine("* The default value for the MaxRetries parameter is 2.");
            desc.AppendLine("* There may be multiple MessageText elements defined. They will appear in the order specified. They may contain HTML.");
            desc.AppendLine("* There may be only one ContentSource element. Multiple ContentSource elements after the first one will be ignored.");
            desc.AppendLine("* The Transform attribute on the ContentSource element is only used when the Type=XML.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void AddParameter(string parameterName, string value)
        {
            throw new NotImplementedException();
        }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XmlNode paramNode = paramDoc.SelectSingleNode("Parameters");
                if (String.Compare(paramNode.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                // Walk the list of child nodes
                foreach (XmlNode node in paramNode)
                {
                    switch (node.Name.ToLower())
                    {
                        case "messageheader":
                            if (null == _header)
                                _header = MessageHeader.Parse(node);
                            break;
                        case "subject":
                            if (null == _subject)
                                _subject = node.InnerText;
                            break;
                        case "messagebody":
                            if (null == _body)
                                _body = MessageBody.Parse(node);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public void RemoveAllParameters()
        {
            _header = null;
            _subject = null;
            _body = null;
        }

        public TaskResult Perform()
        {
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            // Basic parameter validation
            if (null == _header)
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The MessageHeader parameter is required, but was not specified."));
            }
            else
            {
                // The ToList parameter is required
                if (String.IsNullOrEmpty(_header.ToList))
                {
                    result.ExecutedSuccessfully = false;
                    result.AddLog(new Log("The ToList parameter is required, but was not specified."));
                }
            }
            if (null == _subject)
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The Subject parameter is required, but was not specified."));
            }
            if (null == _body)
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The MessageBody parameter is required, but was not specified."));
            }

            if (result.ExecutedSuccessfully)
            {
                try
                {
                    MailMessage mailMsg = new MailMessage();
                    mailMsg.From = new MailAddress(Environment.UserName + c_emailDomainName);
                    mailMsg.To.Add(_header.ToList);
                    if (!String.IsNullOrEmpty(_header.CcList))
                        mailMsg.CC.Add(_header.CcList);
                    if (!String.IsNullOrEmpty(_header.BccList))
                        mailMsg.Bcc.Add(_header.BccList);
                    mailMsg.Subject = _subject;
                    mailMsg.Priority = _header.Priority;
                    mailMsg.IsBodyHtml = (_body.ContentType != MessageContentType.Text);
                    mailMsg.BodyEncoding = new ASCIIEncoding();
                    mailMsg.Body = _body.ToString();

                    SmtpClient smtpClient = new SmtpClient(c_smtpHostName);
                    smtpClient.UseDefaultCredentials = true;

                    int retries = 0;
                    while (true)
                    {
                        try
                        {
                            smtpClient.Send(mailMsg);
                            break;
                        }
                        catch (SmtpException ex)
                        {
                            if (retries < _header.MaxRetries)
                            {
                                DACommon.LogEvent(_info.Name, LoggingLevel.Warning,
                                    "Attempt {0} to send email to '{1}' failed.\r\n\r\n{2}",
                                    ++retries, _header.ToList, ex);
                                System.Threading.Thread.Sleep(500);
                            }
                            else
                            {
                                result.AddLog(new Log("Unable to send the message after {0} tries:\r\n{1}",
                                    retries, ex));
                                break;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    result.AddLog(new Log("An error occurred while preparing the message to be sent:\r\n{0}", ex));
                    DACommon.LogEvent(_info.Name, LoggingLevel.Error, "An error occurred while preparing the message to be sent:\r\n{0}", ex);
                }
            }

            // Never return a fail code
            result.ExecutedSuccessfully = true;
            return result;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\GeneralTaskModule\GeneralTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Management;
using System.Reflection;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.generaltaskmodule
{
    [DeploymentTaskModule("ServicesTaskModule")]
	public class ServicesTaskModule : ITaskModule
	{
        private class ServiceInfo
        {
            public string Name { get; set; }
            public string DisplayName { get; set; }
            public string State { get; set; }
            public string Description { get; set; }
            public ManagementObject ServiceObject { get; set; }
        }

        static readonly string[] ReturnCodeStrings =
        {"Success","Not Supported","Access Denied","Dependent Services Running","Invalid Service Control",
         "Service Cannot Accept Control","Service Not Active","Service Request Timeout","Unknown Failure",
         "Path Not Found","Service Already Running","Service Database Locked","Service Dependency Deleted",
         "Service Dependency Failure","Service Disabled","Service Logon Failure","Service Marked For Deletion",
         "Service No Thread","Status Circular Dependency","Status Duplicate Name","Status Invalid Name",
         "Status Invalid Parameter","Status Invalid Service Account","Status Service Exists","Service Already Paused"};

        private const string ActionParameter = "action";
        private const string MachineParameter = "machine";
        private const string ServicesParameter = "services";
        private const string UserNameParameter = "username";
        private const string PasswordParameter = "password";
        private const string PasswordEncryptedParameter = "passwordencrypted";
        private const string ErrorsAreFatalParameter = "errorsarefatal";

        private Dictionary<string, string> _parameters;
        private TaskModuleInfo _info;
        private StringBuilder _cmdOutput;

        public ServicesTaskModule()
        {
            _cmdOutput = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "Service Management";
            _info.Description = "Provides methods for administering services on remote servers.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Action", "The service management action to take. Specify START, STOP, RESTART, PAUSE, or RESUME"),
                new ParameterDescriptor("Machine", "The name of the server where the service resides."),
                new ParameterDescriptor("Services", "A comma-separated list of services to upon which the action is applied."),
                new ParameterDescriptor("UserName", "[Optional] Username to use to connect to the remote server. If not specified, the current credentials are used."),
                new ParameterDescriptor("Password", "[Optional] Password to use to conenct to the remote server. If not specified, the current credentials are used."),
                new ParameterDescriptor("PasswordEncrypted", "[Optional] Flag indicating whether the password is encrypted or plain text. Default is FALSE."),
                new ParameterDescriptor("ErrorsAreFatal", "[Optional] Flag indicating whether errors are treated as fatal. Default is TRUE.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(ActionParameter, "");
            _parameters.Add(MachineParameter, "");
            _parameters.Add(ServicesParameter, "");
            _parameters.Add(UserNameParameter, "");
            _parameters.Add(PasswordParameter, "");
            _parameters.Add(PasswordEncryptedParameter, "False");
            _parameters.Add(ErrorsAreFatalParameter, "True");
        }

        #region ITaskModule Members

        public void AddParameters(string xmlParameterBlock) { }

        public void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public TaskResult Perform()
        {
            bool passwordEncrypted = false;
            bool errorsAreFatal = true;
            bool taskResult = false;
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            Boolean.TryParse(_parameters[PasswordEncryptedParameter], out passwordEncrypted);
            Boolean.TryParse(_parameters[ErrorsAreFatalParameter], out errorsAreFatal);

            // Perform basic validation of the required parameters
            if (String.IsNullOrEmpty(_parameters[MachineParameter]))
            {
                result.ExecutedSuccessfully = !errorsAreFatal;
                result.AddLog(new Log("The 'Machine' parameter is required, but was not specified."));
            }
            else if (String.IsNullOrEmpty(_parameters[ServicesParameter]))
            {
                result.ExecutedSuccessfully = !errorsAreFatal;
                result.AddLog(new Log("The 'Services' parameter is required, but was not specified."));
            }

            // Parse the services list
            string[] servicesList = _parameters[ServicesParameter].Split(',');

            try
            {
                // if the action parameter is "RESTART", then send a Stop, followed by a Start
                if (String.Compare(_parameters[ActionParameter], "RESTART", true) == 0)
                {
                    taskResult = false;
                    if (PerformAction(servicesList, "STOP", result))
                    {
                        taskResult = PerformAction(servicesList, "START", result);
                    }
                }
                else
                {
                    taskResult = PerformAction(servicesList, _parameters[ActionParameter].ToLower(), result);
                }
            }
            catch (Exception ex)
            {
                taskResult = false;
                result.AddLog(new Log("An error occurred while processing the '{0}' command on '{1}':\r\n{2}",
                    _parameters[ActionParameter], _parameters[MachineParameter], ex));
            }

            if (errorsAreFatal)
                result.ExecutedSuccessfully = taskResult;

            return result;
        }

        public void RemoveAllParameters()
        {
            _parameters[ActionParameter] = "";
            _parameters[MachineParameter] = "";
            _parameters[ServicesParameter] = "";
            _parameters[UserNameParameter] = "";
            _parameters[PasswordParameter] = "";
            _parameters[PasswordEncryptedParameter] = "False";
            _parameters[ErrorsAreFatalParameter] = "True";
        }

        #endregion

        private bool PerformAction(string[] servicesList, string action, TaskResult taskResult)
        {
            UInt32 retCode = 0;
            string userName = null;
            string password = null;
            string targetState = "None";
            bool success = true;

            // Figure out the target state based on the action
            if (String.Compare(action, "Start", true) == 0 ||
                String.Compare(action, "Resume", true) == 0)
                targetState = "Running";
            else if (String.Compare(action, "Stop", true) == 0)
                targetState = "Stopped";
            else if (String.Compare(action, "Pause", true) == 0)
                targetState = "Paused";

            if (!String.IsNullOrEmpty(_parameters[UserNameParameter]))
            {
                if (!String.IsNullOrEmpty(_parameters[PasswordParameter]))
                {
                    bool passwordEncrypted = false;
                    Boolean.TryParse(_parameters[PasswordEncryptedParameter], out passwordEncrypted);
                    if (passwordEncrypted)
                        password = DataProtector.DecryptFromHexString(_parameters[PasswordParameter]);
                    else
                        password = _parameters[PasswordParameter];
                    userName = _parameters[UserNameParameter];
                }
            }

            foreach (string service in servicesList)
            {
                retCode = ChangeServiceState(_parameters[MachineParameter], service, userName, password, targetState, 60);
                if (retCode != 0)
                {
                    success = false;
                    taskResult.AddLog(new Log("Failed to change state for service '{0}' to {1}: {2}({3})",
                        service, targetState, ReturnCodeStrings[retCode], retCode));
                }
            }

            return success;
        }

        private ServiceInfo GetServiceInfo(string machine, string service, string userName, string password)
        {
            ServiceInfo serviceInfo = null;
            ConnectionOptions options = new ConnectionOptions();
            options.Username = userName;
            options.Password = password;

            ManagementScope scope = new ManagementScope(String.Format(@"\\{0}\root\cimv2", machine), options);
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(scope,
                new WqlObjectQuery(String.Format("SELECT * FROM Win32_Service WHERE Name LIKE '{0}'", service)));
            ManagementObjectCollection obList = searcher.Get();
            foreach (ManagementObject mo in obList)
            {
                serviceInfo = new ServiceInfo();
                serviceInfo.Name = mo["Name"] as string;
                serviceInfo.DisplayName = mo["DisplayName"] as string;
                serviceInfo.Description = mo["Description"] as string;
                serviceInfo.State = mo["State"] as string;
                serviceInfo.ServiceObject = mo;
                break;
            }

            return serviceInfo;
        }

        private UInt32 ChangeServiceState(string machine, string service, string userName, string password, string targetState, UInt16 timeoutSeconds)
        {
            UInt32 retCode = 0;
            UInt16 elapsedSeconds = 0;
            ServiceInfo si = null;

            // Only 3 valid target states : Running, Stopped, and Paused
            if (String.Compare("Running", targetState, true) != 0 &&
                String.Compare("Stopped", targetState, true) != 0 &&
                String.Compare("Paused", targetState, true) != 0)
            {
                return 1;
            }

            while (elapsedSeconds <= timeoutSeconds)
            {
                int statusCode = -1;

                si = GetServiceInfo(machine, service, userName, password);
                if (si != null)
                {
                    // If we've reached the target state, exit.
                    if (String.Compare(targetState, si.State, true) == 0)
                    {
                        retCode = 0;
                        elapsedSeconds = 0; // Make sure a timeout return code isn't triggered
                        break;
                    }

                    // Determine the correct course of action based on where we are
                    switch (si.State.ToLower())
                    {
                        case "stopped":
                            statusCode = (int)(UInt32)si.ServiceObject.InvokeMethod("StartService", null);
                            break;
                        case "running":
                            if (String.Compare(targetState, "Stopped", true) == 0)
                            {
                                statusCode = (int)(UInt32)si.ServiceObject.InvokeMethod("StopService", null);
                            }
                            else if (String.Compare(targetState, "Paused", true) == 0)
                            {
                                statusCode = (int)(UInt32)si.ServiceObject.InvokeMethod("PauseService", null);
                            }
                            break;
                        case "paused":
                            if (String.Compare(targetState, "Stopped", true) == 0)
                            {
                                statusCode = (int)(UInt32)si.ServiceObject.InvokeMethod("StopService", null);
                            }
                            else if (String.Compare(targetState, "Running", true) == 0)
                            {
                                statusCode = (int)(UInt32)si.ServiceObject.InvokeMethod("ResumeService", null);
                            }
                            break;
                        case "start pending":
                        case "stop pending":
                        case "continue pending":
                        case "pause pending":
                            // Wait until the service gets into a stable state
                            statusCode = -1;
                            break;
                        case "unknown":
                            // Tell the service to update the SCM
                            statusCode = (int)(UInt32)si.ServiceObject.InvokeMethod("InterrogateService", null);
                            break;
                    }

                    if (statusCode > 0)
                    {
                        retCode = (UInt32)statusCode;
                        break;
                    }
                }
                else
                {
                    retCode = 8;
                    break;
                }

                System.Threading.Thread.Sleep(1000);
                elapsedSeconds++;
            }

            if (elapsedSeconds > timeoutSeconds)
                retCode = 7;

            return retCode;
        }
    }

    static internal class AppPoolStates
    {
        public static readonly UInt32 Starting = 0;
        public static readonly UInt32 Started = 1;
        public static readonly UInt32 Stopping = 2;
        public static readonly UInt32 Stopped = 3;
        public static readonly UInt32 Unknown = 4;
    }

    [DeploymentTaskModule("IISAppPoolModule")]
    public class IISTaskModule : ITaskModule
    {
        private const string ActionParameter = "action";
        private const string MachineParameter = "machine";
        private const string AppPoolsParameter = "apppools";
        private const string UserNameParameter = "username";
        private const string PasswordParameter = "password";
        private const string PasswordEncryptedParameter = "passwordencrypted";
        private const string ErrorsAreFatalParameter = "errorsarefatal";
        private const string StartStoppedPoolsParameter = "startstoppedpools";

        private Dictionary<string, string> _parameters;
        private TaskModuleInfo _info;
        private StringBuilder _cmdOutput;

        public IISTaskModule()
        {
            _cmdOutput = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "IIS App Pool Management";
            _info.Description = "Provides methods for administering IIS Application Pools on remote servers.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            {
                new ParameterDescriptor("Action", "The IIS management action to take: RECYCLE."),
                new ParameterDescriptor("Machine", "The name of the IIS server."),
                new ParameterDescriptor("AppPools", "A comma-separated list of App Pools to upon which the action is applied. Use ALL to recycle all running App Pools."),
                new ParameterDescriptor("UserName", "[Optional] Username to use to connect to the remote server. If not specified, the current credentials are used."),
                new ParameterDescriptor("Password", "[Optional] Password to use to conenct to the remote server. If not specified, the current credentials are used."),
                new ParameterDescriptor("PasswordEncrypted", "[Optional] Flag indicating whether the password is encrypted or plain text. Default is FALSE."),
                new ParameterDescriptor("StartStoppedPools", "[Optional] Flag indicating whether or not the recycle starts stopped app pools. Default is FALSE."),
                new ParameterDescriptor("ErrorsAreFatal", "[Optional] Flag indicating whether errors are treated as fatal. Default is TRUE.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(ActionParameter, "");
            _parameters.Add(MachineParameter, "");
            _parameters.Add(AppPoolsParameter, "");
            _parameters.Add(UserNameParameter, "");
            _parameters.Add(PasswordParameter, "");
            _parameters.Add(PasswordEncryptedParameter, "False");
            _parameters.Add(ErrorsAreFatalParameter, "True");
            _parameters.Add(StartStoppedPoolsParameter, "False");
        }

        #region ITaskModule Members

        public void AddParameters(string xmlParameterBlock) { }

        public void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public TaskResult Perform()
        {
            bool passwordEncrypted = false;
            bool errorsAreFatal = true;
            bool startStoppedPools = false;
            bool taskResult = false;
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            Boolean.TryParse(_parameters[PasswordEncryptedParameter], out passwordEncrypted);
            Boolean.TryParse(_parameters[ErrorsAreFatalParameter], out errorsAreFatal);
            Boolean.TryParse(_parameters[StartStoppedPoolsParameter], out startStoppedPools);

            // Perform basic validation of the required parameters
            if (String.IsNullOrEmpty(_parameters[MachineParameter]))
            {
                result.ExecutedSuccessfully = !errorsAreFatal;
                result.AddLog(new Log("The 'Machine' parameter is required, but was not specified."));
            }
            else if (String.IsNullOrEmpty(_parameters[AppPoolsParameter]))
            {
                result.ExecutedSuccessfully = !errorsAreFatal;
                result.AddLog(new Log("The 'AppPools' parameter is required, but was not specified."));
            }

            // Parse the App Pool list
            List<string> appPoolList = new List<string>(_parameters[AppPoolsParameter].Split(','));
            try
            {
                taskResult = PerformAction(appPoolList, _parameters[ActionParameter].ToLower(), startStoppedPools, result);
            }
            catch (Exception ex)
            {
                taskResult = false;
                result.AddLog(new Log("An error occurred while processing the '{0}' command on '{1}':\r\n{2}",
                    _parameters[ActionParameter], _parameters[MachineParameter], ex));
            }

            if (errorsAreFatal)
                result.ExecutedSuccessfully = taskResult;

            return result;
        }

        public void RemoveAllParameters()
        {
            _parameters[ActionParameter] = "";
            _parameters[MachineParameter] = "";
            _parameters[AppPoolsParameter] = "";
            _parameters[UserNameParameter] = "";
            _parameters[PasswordParameter] = "";
            _parameters[PasswordEncryptedParameter] = "False";
            _parameters[ErrorsAreFatalParameter] = "True";
            _parameters[StartStoppedPoolsParameter] = "False";
        }

        #endregion

        private bool PerformAction(List<string> appPoolList, string action, bool startStoppedPools, TaskResult result)
        {
            string userName = null;
            string password = null;
            bool success = true;

            if (!String.IsNullOrEmpty(_parameters[UserNameParameter]))
            {
                if (!String.IsNullOrEmpty(_parameters[PasswordParameter]))
                {
                    bool passwordEncrypted = false;
                    Boolean.TryParse(_parameters[PasswordEncryptedParameter], out passwordEncrypted);
                    if (passwordEncrypted)
                        password = DataProtector.DecryptFromHexString(_parameters[PasswordParameter]);
                    else
                        password = _parameters[PasswordParameter];
                    userName = _parameters[UserNameParameter];
                }
            }

            // If the list contains only "ALL", then enumerate all running app pools and recycle them
            if (1 == appPoolList.Count && (String.Compare(appPoolList[0], "ALL", true) == 0))
            {
                appPoolList = EnumAppPools(_parameters[MachineParameter], userName, password);
            }

            foreach (string appPool in appPoolList)
            {
                try
                {
                    UInt32 state = RecycleAppPool(_parameters[MachineParameter], appPool, userName, password, startStoppedPools);
                    if (AppPoolStates.Started != state)
                    {
                        result.AddLog(new Log("The app pool '{0}' was recycled, but it's reported state is {1}", appPool, state));
                        success = false;
                    }
                }
                catch (Exception ex)
                {
                    result.AddLog(new Log("Unable to recycle the '{0}' app pool: {1}", appPool, ex.Message));
                    success = false;
                }
            }

            return success;
        }

        private List<string> EnumAppPools(string machine, string userName, string password)
        {
            List<string> appPools = new List<string>();

            ConnectionOptions options = new ConnectionOptions();
            options.Username = userName;
            options.Password = password;
            options.Authentication = AuthenticationLevel.PacketPrivacy;

            ManagementScope scope = new ManagementScope(String.Format(@"\\{0}\root\WebAdministration", machine), options);
            scope.Connect();
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(scope,
                new WqlObjectQuery(String.Format("SELECT * FROM ApplicationPool")));
            ManagementObjectCollection obList = searcher.Get();
            foreach (ManagementObject mo in obList)
            {
                appPools.Add(mo["Name"].ToString());
            }

            return appPools;
        }

        private UInt32 RecycleAppPool(string machine, string appPool, string userName, string password, bool startStoppedPools)
        {
            UInt32 state = AppPoolStates.Unknown;
            ConnectionOptions options = new ConnectionOptions();
            options.Username = userName;
            options.Password = password;
            options.Authentication = AuthenticationLevel.PacketPrivacy;

            ManagementScope scope = new ManagementScope(String.Format(@"\\{0}\root\WebAdministration", machine), options);
            scope.Connect();
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(scope,
                new WqlObjectQuery(String.Format("SELECT * FROM ApplicationPool WHERE Name LIKE '{0}'", appPool)));
            ManagementObjectCollection obList = searcher.Get();
            foreach (ManagementObject mo in obList)
            {
                state = (UInt32)mo.InvokeMethod("GetState", null);
                if (AppPoolStates.Stopped == state && startStoppedPools)
                {
                    mo.InvokeMethod("Start", null);
                }
                else if (AppPoolStates.Started == state)
                {
                    mo.InvokeMethod("Recycle", null);
                }
                state = (UInt32)mo.InvokeMethod("GetState", null);
            }

            return state;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\HealthCheckTaskModule\HealthCheck.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Xml;

namespace xonline.test.deployment.automation.taskmodules.healthchecktaskmodule
{
    /// <summary>
    /// This class defines an Xbox LIVE health check, including the URL, the
    /// server, the component name, and the port.
    /// </summary>
    public class HealthCheck
    {
        private Uri _healthUrl = null;
        private string _component = null;

        public HealthCheck(Uri url, String component)
        {
            _healthUrl = url;
            _component = component;
        }

        public string HealthUrl { get { return _healthUrl.ToString(); } }
        public string Server { get { return _healthUrl.Host; } }
        public string Port { get { return _healthUrl.Port.ToString(); } }
        public string Component { get { return _component; } }

        public override string ToString()
        {
            return _healthUrl.ToString();
        }
    }

    /// <summary>
    /// This class encapsulates an individual health request. Prior to initiating
    /// a web request, call the BeginRequest method to create a new request object
    /// and increment the number of attempts. At the end of the request, call the
    /// EndRequest method to store the timestamp of the finished request.
    /// </summary>
    public class HealthCheckRequest
    {
        public HealthCheck HealthCheck { get; private set; }
        public HttpWebRequest Request { get; private set; }
        public DateTime RequestTimestamp { get; private set; }
        public int Attempts { get; private set; }
        public bool HasException { get; set; }

        public HealthCheckRequest(HealthCheck hc)
        {
            HealthCheck = hc;
            Request = null;
            Attempts = 0;
            RequestTimestamp = DateTime.MinValue;
        }

        public void BeginRequest(int timeout)
        {
            Request = (HttpWebRequest)HttpWebRequest.Create(HealthCheck.HealthUrl);
            Request.CachePolicy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.BypassCache);
            Request.Timeout = timeout;
            Attempts++;
        }

        public void EndRequest()
        {
            RequestTimestamp = DateTime.Now;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\EventLogTaskModule\EventLogTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Management;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.eventlogtaskmodule
{
    [DeploymentTaskModule("EventLogTaskModule")]
    public class EventLogTaskModule : ITaskModule
    {
        #region Connection and Filter classes - Object representations of the Connection and Filter elements
        protected class Connection
        {
            public string Server { get; private set; }
            public string UserName { get; private set; }
            public string Password { get; private set; }
            public static Connection Parse(XPathNavigator node)
            {
                if (null == node)
                    throw new ArgumentNullException();
                if (String.Compare(node.Name, "Connection", true) != 0)
                    throw new ApplicationException("Invalid Connection element - the element name must be 'Connection'.");

                Connection connect = new Connection();
                connect.Server = node.GetAttribute("Server", node.NamespaceURI);
                if (connect.Server.Length == 0)
                    connect.Server = ".";

                // If this is a local connection, ignore the UserName and Password attributes
                if (connect.Server != ".")
                {
                    connect.UserName = node.GetAttribute("UserName", node.NamespaceURI);
                    if (connect.UserName.Length > 0)
                    {
                        bool tmp = false;
                        string attr = node.GetAttribute("PasswordEncrypted", node.NamespaceURI);
                        if (attr.Length > 0)
                            Boolean.TryParse(attr, out tmp);
                        if (tmp)
                            connect.Password = DataProtector.DecryptFromHexString(node.GetAttribute("Password", node.NamespaceURI));
                        else
                            connect.Password = node.GetAttribute("Password", node.NamespaceURI);
                    }
                }
                else
                {
                    connect.Server = Environment.MachineName;
                    connect.UserName = null;
                    connect.Password = null;
                }

                return connect;
            }
        }

        protected enum FilterOp
        {
            None = 0,
            Equals,
            NotEquals,
            GreaterThan,
            LessThan,
            GreaterThanOrEquals,
            LessThanOrEquals
        }

        protected class Filter
        {
            public string Field { get; private set; }
            public FilterOp Operator { get; private set; }
            public string Value { get; private set; }
            public static Filter Parse(XPathNavigator node)
            {
                if (null == node)
                    throw new ArgumentNullException();
                if (String.Compare(node.Name, "Filter", true) != 0)
                    throw new ApplicationException("Invalid Filter element - the element name must be 'Filter'.");

                Filter filter = new Filter();
                string op;
                string field = node.GetAttribute("Field", node.NamespaceURI);
                switch (field.ToLower())
                {
                    case "eventid":
                        filter.Field = "EventCode";
                        break;
                    case "source":
                        filter.Field = "SourceName";
                        break;
                    case "datetime":
                        filter.Field = "TimeWritten";
                        break;
                    case "type":
                        filter.Field = "EventType";
                        break;
                    default:
                        filter.Field = field;
                        break;
                }
                op = node.GetAttribute("Op", node.NamespaceURI);
                try
                {
                    filter.Operator = (FilterOp)Enum.Parse(typeof(FilterOp), op, true);
                }
                catch (Exception ex)
                {
                    throw new ApplicationException(String.Format("Invalid operator: '{0}'", op), ex);
                }
                filter.Value = node.GetAttribute("Value", node.NamespaceURI);

                return filter;
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendFormat("({0}", Field);
                switch (Operator)
                {
                    case FilterOp.Equals:
                        sb.Append(" = ");
                        break;
                    case FilterOp.NotEquals:
                        sb.Append(" <> ");
                        break;
                    case FilterOp.GreaterThan:
                        sb.Append(" > ");
                        break;
                    case FilterOp.LessThan:
                        sb.Append(" < ");
                        break;
                    case FilterOp.GreaterThanOrEquals:
                        sb.Append(" >= ");
                        break;
                    case FilterOp.LessThanOrEquals:
                        sb.Append(" <= ");
                        break;
                }
                sb.AppendFormat("'{0}')", Value);
                return sb.ToString();
            }
        }
        #endregion

        protected string[] Types = { "Unknown", "Error", "Warning", "Information", "Security Audit Success", "Security Audit Failure" };

        protected TaskModuleInfo _info;
        protected Connection _connection;
        protected List<Filter> _filters;
        protected string _eventLog;
        protected string _outPath;
        protected TaskResult _result;

        public EventLogTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "EventLogTaskModule";
            _info.Description = "Provides access to NT Event Logs.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <Connection Server=\"ServerName\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\"/>");
            desc.AppendLine("  <EventLog Name=\"Name of the event log (Application, System, etc)\" />");
            desc.AppendLine("  <Filter Field=\"FieldName\" Op=\"Operator\" Value=\"Value\" />");
            desc.AppendLine("  <Output Path=\"Path where the output file will get created.\" />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("To connect to the local server, use a period (.) as the Server attribute and leave off the rest of the attributes.");
            desc.AppendLine("There may be multiple Filter clauses defined. Each Filter element will be joined with an 'AND' logical operator.");
            desc.AppendLine("Valid filter fields are: EventId, Source, DateTime, Type.");
            desc.AppendLine("Valid Operators are: Equals, NotEquals, GreaterThan, LessThan, GreaterThanOrEquals, LessThanOrEquals");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _filters = new List<Filter>();
        }

        public TaskResult Result { get { return _result; } }

        #region ITaskModule Members

        public void AddParameter(string parameterName, string value) { }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "connection":
                            _connection = Connection.Parse(itor.Current);
                            break;
                        case "eventlog":
                            _eventLog = itor.Current.GetAttribute("Name", itor.Current.NamespaceURI);
                            break;
                        case "filter":
                            _filters.Add(Filter.Parse(itor.Current));
                            break;
                        case "output":
                            _outPath = itor.Current.GetAttribute("Path", itor.Current.NamespaceURI);
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public TaskResult Perform()
        {
            StringBuilder whereClause = null;
            StringBuilder query = null;
            ManagementScope scope = null;
            ManagementObjectCollection logs = null;
            int logCount = 0;

            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Basic validation of parameters
            if (null == _connection)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Connection parameter is required, but was not specified."));
            }
            if (String.IsNullOrEmpty(_eventLog))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The EventLog parameter is required, but was not specified."));
            }
            if (String.IsNullOrEmpty(_outPath))
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The Output parameter is required, but was not specified."));
            }

            if (_result.ExecutedSuccessfully)
            {
                // Build the query
                query = new StringBuilder();
                try
                {
                    query.AppendFormat("Select * From Win32_NTLogEvent Where (LogFile='{0}')", _eventLog);
                    if (_filters.Count > 0)
                    {
                        whereClause = new StringBuilder();
                        for (int i = 0; i < _filters.Count; i++)
                        {
                            whereClause.AppendFormat(" AND {0}", _filters[i].ToString());
                        }
                        query.Append(whereClause.ToString());
                    }
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("An error occurred while creating the WQL query:\r\n{0}", ex));
                }
            }

            if (_result.ExecutedSuccessfully)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Information, "Executing the following WQL query:\r\n{0}", query.ToString());
                _result.AddLog(new Log("Executing the following query to retrieve the Event logs from {0}:\r\n{1}", _connection.Server, query.ToString()));

                // Connect to the server and run the query
                try
                {
                    scope = WMI.ConnectToHost(_connection.Server, "cimv2", _connection.UserName, _connection.Password);
                    logs = WMI.QueryObjects(scope, query.ToString());
                    logCount = logs.Count;
                }
                catch (Exception ex)
                {
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("An error occurred running the query:\r\n{0}", ex));
                }
            }

            if (_result.ExecutedSuccessfully)
            {
                // Save the transform as NTEventLog.xslt, if one doesn't already exist
                string xsltName = Path.Combine(_outPath, "NTEventLog.xslt");
                lock (xsltName)
                {
                    if (!File.Exists(xsltName))
                    {
                        DACommon.LogEvent(_info.Name, LoggingLevel.Information, "Creating the XML transform as '{0}'", xsltName);
                        try
                        {
                            FileUtils.CreatePath(_outPath);
                            using (FileStream xsltOutStream = new FileStream(xsltName, FileMode.Create, FileAccess.Write, FileShare.Read))
                            {
                                using (Stream xsltInStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("NTEventLog.xslt"))
                                {
                                    Byte[] block = new Byte[8192];
                                    int bytesRead;

                                    while ((bytesRead = xsltInStream.Read(block, 0, 8192)) != 0)
                                    {
                                        xsltOutStream.Write(block, 0, bytesRead);
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to write the NTEventLog.xslt file:\r\n{0}", ex);
                        }
                    }
                }

                if (logCount > 0)
                {
                    XmlDocument doc = new XmlDocument();
                    doc.AppendChild(doc.CreateXmlDeclaration("1.0", "utf-8", null));
                    doc.AppendChild(doc.CreateProcessingInstruction("xml-stylesheet", "type='text/xsl' href='NTEventLog.xslt'"));
                    XmlNode root = doc.CreateNode(XmlNodeType.Element, "NTEventLog", doc.NamespaceURI);

                    XmlAttribute attr = doc.CreateAttribute("Server", doc.NamespaceURI);
                    attr.Value = _connection.Server;
                    root.Attributes.Append(attr);

                    attr = doc.CreateAttribute("EventLog", doc.NamespaceURI);
                    attr.Value = _eventLog;
                    root.Attributes.Append(attr);

                    attr = doc.CreateAttribute("TimeStamp", doc.NamespaceURI);
                    attr.Value = DateTime.Now.ToString();
                    root.Attributes.Append(attr);

                    // Serialize the current filter
                    XmlNode filterNode = doc.CreateNode(XmlNodeType.Element, "Filter", doc.NamespaceURI);
                    if (_filters.Count > 0)
                    {
                        XmlCDataSection filterCDATA = doc.CreateCDataSection(whereClause.ToString());
                        filterNode.AppendChild(filterCDATA);
                    }
                    else
                    {
                        filterNode.InnerText = "None";
                    }
                    root.AppendChild(filterNode);

                    // Serialize each event
                    foreach (ManagementObject log in logs)
                    {
                        XmlNode node = doc.CreateNode(XmlNodeType.Element, "NTEvent", doc.NamespaceURI);
                        attr = doc.CreateAttribute("EventIdentifier", doc.NamespaceURI);
                        attr.Value = log["EventIdentifier"].ToString();
                        node.Attributes.Append(attr);

                        attr = doc.CreateAttribute("Source", doc.NamespaceURI);
                        attr.Value = log["SourceName"].ToString();
                        node.Attributes.Append(attr);

                        attr = doc.CreateAttribute("EventCode", doc.NamespaceURI);
                        attr.Value = log["EventCode"].ToString();
                        node.Attributes.Append(attr);

                        attr = doc.CreateAttribute("EventType", doc.NamespaceURI);
                        Byte type = (Byte)log["EventType"];
                        if (type >= 0 && type < Types.Length)
                            attr.Value = Types[type];
                        else
                            attr.Value = type.ToString();
                        node.Attributes.Append(attr);

                        attr = doc.CreateAttribute("TimeStamp", doc.NamespaceURI);
                        DateTime timeStamp = WMI.ParseCIMDateTime(log["TimeWritten"].ToString(), true);
                        attr.Value = timeStamp.ToString();
                        node.Attributes.Append(attr);

                        if (log["User"] != null)
                        {
                            attr = doc.CreateAttribute("User", doc.NamespaceURI);
                            attr.Value = log["User"].ToString();
                            node.Attributes.Append(attr);
                        }

                        // Output the message as a child element
                        XmlNode msgNode = doc.CreateNode(XmlNodeType.Element, "Message", doc.NamespaceURI);
                        if (log["Message"] != null)
                            msgNode.InnerText = log["Message"].ToString();
                        node.AppendChild(msgNode);

                        try
                        {
                            // Output any data as a series of 2-character hexadecimal bytes
                            if (log["Data"] != null)
                            {
                                XmlNode dataNode = doc.CreateNode(XmlNodeType.Element, "BinaryData", doc.NamespaceURI);
                                dataNode.InnerText = BitConverter.ToString(((Byte[])log["Data"])).Replace("-", "");
                                node.AppendChild(dataNode);
                            }
                        }
                        catch (Exception ex)
                        {
                            _result.AddLog(new Log("The Data section for Event {0} could not be serialized.\r\n{1}", log["EventIdentifier"].ToString(), ex));
                        }

                        root.AppendChild(node);
                    }
                    doc.AppendChild(root);

                    // Save the xml document to the specified location
                    try
                    {
                        string fileName = String.Format("{0}-{1}-{2}.xml", _connection.Server, _eventLog, DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"));
                        FileUtils.CreatePath(_outPath);
                        doc.Save(Path.Combine(_outPath, fileName));
                        Log fileLog = new Log();
                        fileLog.Path = _outPath;
                        fileLog.FileName = fileName;
                        _result.AddLog(fileLog);
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(Info.Name, LoggingLevel.Error, "Unable to save the xml output file.\r\n{0}", ex);
                        _result.AddLog(new Log("Unable to save the output file: {0}", ex.Message));
                        _result.ExecutedSuccessfully = false;
                    }
                }
                else
                {
                    _result.AddLog(new Log("The query returned no results."));
                }
            }

            return _result;
        }

        public void RemoveAllParameters()
        {
            _filters.Clear();
            _connection = null;
        }

        #endregion
    }

    [DeploymentTaskModule("AsyncEventLogTaskModule")]
    public class AsyncEventLogTaskModule : ITaskModule
    {
        private class ThreadData
        {
            public EventLogTaskModule Module { get; set; }
            public ManualResetEvent CompleteEvent { get; set; }
        }

        TaskModuleInfo _info = null;
        TaskResult _result = null;
        Dictionary<string, EventLogTaskModule> _modules = null;

        public AsyncEventLogTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "EventLogTaskModule";
            _info.Description = "Provides asynchronous access to NT Event Logs.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <Connection ServerList=\"Comma-delimited list of servers\" UserName=\"UserName\" PasswordEncrypted=\"true|false\" Password=\"Password\"/>");
            desc.AppendLine("  <EventLog Name=\"Name of the event log (Application, System, etc)\" />");
            desc.AppendLine("  <Filter Field=\"FieldName\" Op=\"Operator\" Value=\"Value\" />");
            desc.AppendLine("  <Output Path=\"Path where the output file(s) will get created.\" />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("To connect to the local server, use a period (.) as the Server attribute and leave off the rest of the attributes.");
            desc.AppendLine("When connecting to multiple servers, the same credentials will be supplied to each one.");
            desc.AppendLine("There may be multiple Filter clauses defined. Each Filter element will be joined with an 'AND' logical operator.");
            desc.AppendLine("Valid filter fields are: EventId, Source, DateTime, Type.");
            desc.AppendLine("Valid Operators are: Equals, NotEquals, GreaterThan, LessThan, GreaterThanOrEquals, LessThanOrEquals");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _modules = new Dictionary<string, EventLogTaskModule>();
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void AddParameter(string parameterName, string value) { }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XmlNode connectNode = paramDoc.SelectSingleNode("/Parameters/Connection");
                if (connectNode != null)
                {
                    // Get the list of servers
                    string[] serverList = connectNode.Attributes["ServerList"].Value.Split(',');
                    if (serverList.Length > 0)
                    {
                        // Remove the ServerList attribute from the Connection element
                        // And replace it with the 'Server' attribute
                        connectNode.Attributes.RemoveNamedItem("ServerList");
                        XmlAttribute attrib = paramDoc.CreateAttribute("Server");
                        attrib.Value = "";
                        connectNode.Attributes.Append(attrib);

                        foreach (string server in serverList)
                        {
                            if (!_modules.ContainsKey(server))
                            {
                                EventLogTaskModule eltm = new EventLogTaskModule();
                                connectNode.Attributes["Server"].Value = server;
                                eltm.AddParameters(paramDoc.OuterXml);
                                _modules.Add(server, eltm);
                            }
                            else
                            {
                                DACommon.LogEvent(_info.Name, LoggingLevel.Warning,
                                    "The server '{0}' has already been specified - ignoring additional entries.");
                            }
                        }
                    }
                    else
                    {
                        throw new ApplicationException("Invalid parameter block: The ServerList is either missing or is empty.");
                    }
                }
                else
                {
                    throw new ApplicationException("Invalid parameter block: The Connection element does not exist.");
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public void RemoveAllParameters()
        {
            _modules.Clear();
        }

        public TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            if (null == _modules || _modules.Count == 0)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("There are no valid parameters set for this task module."));
            }

            if (_result.ExecutedSuccessfully)
            {
                ManualResetEvent[] completeEvents = new ManualResetEvent[_modules.Count];
                int index = 0;
                foreach (KeyValuePair<string, EventLogTaskModule> kvp in _modules)
                {
                    completeEvents[index] = new ManualResetEvent(false);

                    ThreadData data = new ThreadData();
                    data.Module = kvp.Value;
                    data.CompleteEvent = completeEvents[index];

                    ThreadPool.QueueUserWorkItem(new WaitCallback(PerformThreadProc), data);
                    index++;
                }

                // Wait for all the complete events to get signalled
                if (!WaitHandle.WaitAll(completeEvents, 1200000, true))
                {
                    _result.AddLog(new Log("The timeout of 20 minutes elapsed while waiting for all the worker threads to exit."));
                }
            }

            return _result;
        }

        #endregion

        private void PerformThreadProc(object state)
        {
            ThreadData data = state as ThreadData;

            TaskResult result = null;
            try
            {
                result = data.Module.Perform();
            }
            catch (Exception ex)
            {
                result = new TaskResult();
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log(ex.ToString()));
            }

            // update the results
            lock (_result)
            {
                if (_result.ExecutedSuccessfully)
                    _result.ExecutedSuccessfully = result.ExecutedSuccessfully;
                _result.AddLogs(result.Logs);
            }

            // We're done - signal the event
            data.CompleteEvent.Set();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\OctopusTaskModule\OctopusProcess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace xonline.test.deployment.automation.taskmodules.octopustaskmodule
{
    internal enum OctopusPendingRebootOperation
    {
        Ignore, Error, Reboot
    }

    internal enum OctopusInstallationType
    {
        Install, Uninstall, PrerequisiteCheck
    }

    internal class OctopusProcess
    {
        public bool UseFakeAgent { set; get; }
        public bool UseVerboseMsiLogging { set; get; }
        public string Password { set; get; }
        public string PathToLogLocationFile { set; get; }
        public string PathToConfigurationFile { set; get; }
        public List<string> PropertyOverrides
        {
            get { return _propertyOverrides; }
        }

        public OctopusPendingRebootOperation PendingRebootOperation { set; get; }
        public OctopusInstallationType InstallationType { set; get; }

        private List<string> _propertyOverrides;
        private StringBuilder _outputStringBuilder;
        private int _exitCode = 0;

        public int ExitCode
        {
            get { return _exitCode; }
        }

        public string Output
        {
            get
            {
                return _outputStringBuilder.ToString();
            }
        }

        public OctopusProcess()
        {
            _propertyOverrides = new List<string>();
            _outputStringBuilder = new StringBuilder();

            // if these defaults change, make sure to update the OctopusTaskModule parameter descriptions in
            // OctopusTaskModule.cs or preserve back-compat.
            PendingRebootOperation = OctopusPendingRebootOperation.Reboot;
            InstallationType = OctopusInstallationType.Install;
            UseFakeAgent = false;
            UseVerboseMsiLogging = false;
        }

        public void Run()
        {
            StringBuilder argumentListBuilder = new StringBuilder();

            argumentListBuilder.Append("-");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusInstallationType), InstallationType));
            argumentListBuilder.Append(" ");
            argumentListBuilder.Append("-onpendingrebootoperation ");
            argumentListBuilder.Append(Enum.GetName(typeof(OctopusPendingRebootOperation), PendingRebootOperation));
            argumentListBuilder.Append(" ");
            if (UseFakeAgent)
                argumentListBuilder.Append("-fakeAgent");
            else
                argumentListBuilder.Append("-adminpassword " + Password);
            argumentListBuilder.Append(" ");

            if (PathToConfigurationFile != null)
                argumentListBuilder.Append(String.Format("-config \"{0}\"", PathToConfigurationFile));
            argumentListBuilder.Append(" ");

            if (PathToLogLocationFile != null)
                argumentListBuilder.Append(String.Format("-recordlogfolderin \"{0}\"", PathToLogLocationFile));
            argumentListBuilder.Append(" ");

            if (UseVerboseMsiLogging)
                argumentListBuilder.Append("-verbosemsilogging");
            argumentListBuilder.Append(" ");

            // Add the property value overrides
            foreach (string property in _propertyOverrides)
            {
                argumentListBuilder.AppendFormat(" -property {0}", property);
            }

            ProcessStartInfo processStartInfo = new ProcessStartInfo("octopuscli.exe", argumentListBuilder.ToString());
            processStartInfo.UseShellExecute = false;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.RedirectStandardError = true;

            Process octopus = Process.Start(processStartInfo);
            octopus.OutputDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            octopus.ErrorDataReceived += new DataReceivedEventHandler(OutputDataReceivedHandler);
            octopus.BeginOutputReadLine();
            octopus.BeginErrorReadLine();
            octopus.WaitForExit();
            _exitCode = octopus.ExitCode;
        }

        void OutputDataReceivedHandler(object sender, DataReceivedEventArgs e)
        {
            _outputStringBuilder.AppendLine(e.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\HealthCheckTaskModule\HealthCheckTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Schema;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.healthchecktaskmodule
{
    [DeploymentTaskModule("HealthCheckTaskModule")]
    public class HealthCheckTaskModule : ITaskModule
    {
        // Parameter variables
        private string _npdbServer = null;
        private string _npdbName = null;
        private int _requestTimeout = 0;
        private int _retryDelta = 0;
        private int _maxAttempts = 0;
        private int _batchSize = 0;
        private string _logLocation = null;
        private Dictionary<string, string> _excludeList = null;
        private HealthCheckExceptionCollection _exceptions = null;
        private NetworkCredential _credentials = null;

        // Other internal variables
        private TaskModuleInfo _info = null;
        private Queue<HealthCheckRequest> _healthQueue = null;
        private Queue<HealthCheckRequest> _retryQueue = null;
        private readonly object _queueLock = new object();
        private Timer _retryTimer = null;
        private int _timerSet = 0;
        private int _remainingHealthchecks = 0;
        private ManualResetEvent _done = null;
        private string _summaryFileName = null;
        private StringBuilder _failSummary = null;
        private StringBuilder _exceptionSummary = null;
        private StringBuilder _excludedSummary = null;

        public HealthCheckTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "HealthCheckTaskModule";
            _info.Description = "Tests health checks to determine service health.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("    <HealthCheckList NPDBServer=\"NPDB server name\" [NPDBName=\"NPDB database name\"]>");
            desc.AppendLine("        [<ExcludeComponent Name=\"ComponentName\" [Port=\"Port number or *\"] />]");
            desc.AppendLine("    </HealthCheckList>");
            desc.AppendLine("    <Credentials UserName=\"User name\" Password=\"Password\" [Encrypted=\"true|false\"] />");
            desc.AppendLine("    [<Options [RequestTimeout=\"Timeout in seconds\"] [MaxAttempts=\"Number of times to try the healthcheck\"] [RetryDelta=\"Time to wait between retries\"] [BatchSize=\"Number of healthchecks to process at once\"] />]");
            desc.AppendLine("    <LogsLocation>Full path where the health and summary XML files will be written.</LogsLocation>");
            desc.AppendLine("    [<HealthCheckExceptions>");
            desc.AppendLine("        <HealthCheckException Component=\"Component name\" HealthStatus=\"Expected healthstatus\" [Port=\"Port number or *\"] [ResponseCode=\"Expected web response code\"]>");
            desc.AppendLine("            [<HealthBlockException Name=\"Health block name\" HealthStatus=\"Expected healthstatus\">]");
            desc.AppendLine("                [<ErrorDetails Op=\"Equals|Contains|NotEquals|NotContains\">Error details text</ErrorDetails>]");
            desc.AppendLine("            [</HealthBlockException>]");
            desc.AppendLine("        </HealthCheckException>");
            desc.AppendLine("    <HealthCheckExceptions>]");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("* The elements must appear in this order.");
            desc.AppendLine("* Excluding a component won't even try to call it's healthcheck.");
            desc.AppendLine("* There may be multiple HealthCheckException elements defined, each with multiple HealthBlockException elements.");
            desc.AppendLine("* There may be only one ErrorDetails element for each HealthBlockException.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
        }

        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public XmlSchema Schema
        {
            get { return GetSchema(); }
        }

        public void RemoveAllParameters()
        {
            _npdbServer = null;
            _npdbName = null;
            _requestTimeout = 0;
            _maxAttempts = 0;
            _retryDelta = 0;
            _batchSize = 0;
            _logLocation = null;
            _excludeList = null;
        }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.IgnoreComments = true;
            readerSettings.IgnoreProcessingInstructions = true;
            readerSettings.IgnoreWhitespace = true;
            XmlSchema schema = GetSchema();
            if (schema != null)
            {
                // Validate the xmlParameterBlock against the schema
                readerSettings.Schemas.Add(schema);
                readerSettings.ValidationType = ValidationType.Schema;
                readerSettings.ValidationFlags = XmlSchemaValidationFlags.None;
            }

            XmlReader reader = null;
            XmlDocument doc = null;
            try
            {
                reader = XmlReader.Create(new MemoryStream(Encoding.ASCII.GetBytes(xmlParameterBlock)), readerSettings);
                doc = new XmlDocument();
                doc.Load(reader);
            }
            finally
            {
                if (reader != null)
                    reader.Close();
            }

            // Parse the parameter block
            foreach (XmlNode node in doc.ChildNodes[0].ChildNodes)
            {
                if (node.NodeType != XmlNodeType.Element)
                    continue;

                string nodeName = node.Name.ToLower();
                switch (nodeName)
                {
                    case "healthchecklist":
                        _npdbServer = node.Attributes["NPDBServer"].Value;
                        _npdbName = node.Attributes["NPDBName"].Value;
                        if (node.HasChildNodes)
                        {
                            _excludeList = new Dictionary<string, string>();
                            foreach (XmlNode hclNode in node.ChildNodes)
                            {
                                _excludeList.Add(hclNode.Attributes["Name"].Value, hclNode.Attributes["Port"].Value);
                            }
                        }
                        break;
                    case "credentials":
                        {
                            string password;
                            if (Boolean.Parse(node.Attributes["Encrypted"].Value))
                                password = DataProtector.DecryptFromHexString(node.Attributes["Password"].Value);
                            else
                                password = node.Attributes["Password"].Value;
                            _credentials = new NetworkCredential(node.Attributes["UserName"].Value, password);
                        }
                        break;
                    case "options":
                        _requestTimeout = Int32.Parse(node.Attributes["RequestTimeout"].Value);
                        _retryDelta = Int32.Parse(node.Attributes["RetryDelta"].Value);
                        _maxAttempts = Int32.Parse(node.Attributes["MaxAttempts"].Value);
                        _batchSize = Int32.Parse(node.Attributes["BatchSize"].Value);
                        break;
                    case "logslocation":
                        _logLocation = node.InnerText;
                        break;
                    case "healthcheckexceptions":
                        _exceptions = new HealthCheckExceptionCollection();
                        foreach (XmlNode exceptionNode in node.ChildNodes)
                            _exceptions.Add(HealthCheckException.Parse(exceptionNode));
                        break;
                }
            }
        }

        public void AddParameter(string parameterName, string value)
        {
            throw new NotImplementedException();
        }

        public TaskResult Perform()
        {
            _done = new ManualResetEvent(false);
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            _failSummary = new StringBuilder();
            _exceptionSummary = new StringBuilder();
            _excludedSummary = new StringBuilder();

            // Check the parameters
            if (_batchSize <= 0)
                _batchSize = 3;
            if (_maxAttempts <= 0)
                _maxAttempts = 3;
            if (_requestTimeout <= 0 || _requestTimeout > 1000000)
                _requestTimeout = 30;
            if (_retryDelta <= 0 || _retryDelta > 3600)
                _retryDelta = 30;

            // Get the list of healthchecks from NPDB
            Debug.WriteLine(String.Format("Querying {0}::{1} for the list of healthchecks...", _npdbServer, _npdbName));

            SqlConnectionStringBuilder connStr = new SqlConnectionStringBuilder();
            connStr.DataSource = _npdbServer;
            connStr.InitialCatalog = _npdbName;
            connStr.IntegratedSecurity = true;
            connStr.AsynchronousProcessing = true;
            SqlConnection conn = new SqlConnection(connStr.ToString());
            try
            {
                conn.Open();
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to connect to {0}::{1} to get the health check list:\r\n{2}",
                    _npdbServer, _npdbName, ex);
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("Unable to connect to {0}::{1} to get the health check list:\r\n{2}",
                    _npdbServer, _npdbName, ex));
                conn.Dispose();
                return result;
            }

            using (SqlCommand cmd = conn.CreateCommand())
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_config_get_server_healthchecks";
                cmd.BeginExecuteReader(readerResult =>
                {
                    SqlDataReader reader = null;
                    try
                    {
                        reader = (readerResult.AsyncState as SqlCommand).EndExecuteReader(readerResult);
                        _healthQueue = new Queue<HealthCheckRequest>();
                        while (reader.Read())
                        {
                            string component = (reader["vc_component"] as string).ToLower();
                            Uri url = new Uri(reader["vc_healthcheck_url"] as string);

                            // Ignore any healthchecks that are in the exclude list
                            if (null != _excludeList &&
                                _excludeList.ContainsKey(component))
                            {
                                if ((_excludeList[component] == "*") ||
                                    (url.Port.ToString() == _excludeList[component]))
                                {
                                    // Either the port number matches or all ports ("*") was specified - ignore this healthcheck
                                    Debug.WriteLine(String.Format("Excluding {0}::{1} from the list of healthcheck urls", component, _excludeList[component]));
                                    _excludedSummary.AppendLine(url.ToString());
                                    continue;
                                }
                            }
                            HealthCheck hc = new HealthCheck(url, component);
                            _healthQueue.Enqueue(new HealthCheckRequest(hc));
                            _remainingHealthchecks++;
                        }
                        Debug.WriteLine(String.Format("Added {0} healthcheck urls to the processing queue.", _remainingHealthchecks));
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to get the list of healthchecks from {0}::{1}:\r\n{2}",
                            _npdbServer, _npdbName, ex);
                        result.ExecutedSuccessfully = false;
                        result.AddLog(new Log("Unable to retrieve the health check list from {0}::{1}:\r\n{2}", _npdbServer, _npdbName, ex));
                    }
                    finally
                    {
                        if (reader != null)
                            reader.Close();
                        if (conn != null)
                            conn.Close();
                    }

                    if (result.ExecutedSuccessfully)
                    {
                        FileUtils.CreatePath(_logLocation);
                        CreateSummaryFile();

                        // Create the retry queue
                        _retryQueue = new Queue<HealthCheckRequest>();

                        // This allows all SSL connections (https) to go through
                        ServicePointManager.ServerCertificateValidationCallback +=
                            delegate(
                            Object sender,
                            System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                            System.Security.Cryptography.X509Certificates.X509Chain chain,
                            System.Net.Security.SslPolicyErrors sslPolicyErrors)
                            {
                                return true;
                            };

                        // Begin sending URLs
                        for (int i = 0; i < _batchSize && i < _healthQueue.Count; i++)
                        {
                            HealthCheckRequest hcr = null;
                            Monitor.Enter(_queueLock);
                            if (_healthQueue.Count > 0)
                                hcr = _healthQueue.Dequeue();
                            Monitor.Exit(_queueLock);
                            if (hcr != null)
                                TestHealthCheck(hcr);
                        }

                        // Create the retry timer. This won't go off until it gets modified
                        // if and when the first failed healthcheck is found.
                        _retryTimer = new Timer(new TimerCallback(RetryTimerElapsed), null, Timeout.Infinite, Timeout.Infinite);
                    }
                },
                cmd);
            }

            // Wait for all the healthchecks to be complete before returning
            Debug.WriteLine("Waiting for all healthchecks to be processed.");

            _done.WaitOne();
            _done.Close();

            // Kill the retry timer
            if (_retryTimer != null)
                _retryTimer.Dispose();

            // Close the summary file and add its location to the logs
            CloseSummaryFile();
            if (!String.IsNullOrEmpty(_summaryFileName))
            {
                Log fileLog = new Log();
                fileLog.Path = Path.GetDirectoryName(_summaryFileName);
                fileLog.FileName = Path.GetFileName(_summaryFileName);
                result.AddLog(fileLog);
            }

            // Add the excluded summary, the exception summary and the failure summary to the result log
            if (_excludedSummary.Length > 0)
            {
                result.AddLog(new Log("Health URLs that will not be checked:\r\n{0}", _excludedSummary.ToString()));
            }
            if (_exceptionSummary.Length > 0)
            {
                result.AddLog(new Log("Healthchecks that passed with an exception:\r\n{0}", _exceptionSummary.ToString()));
            }
            if (_failSummary.Length > 0)
            {
                result.AddLog(new Log("Healthchecks that failed:\r\n{0}", _failSummary.ToString()));
                result.ExecutedSuccessfully = false;
            }

            return result;
        }

        #endregion

        /// <summary>
        /// This is the workhorse method of this task module. This method asynchronously
        /// calls a health URL and processes the response. If the URL fails and does not
        /// have an exception defined for it, the URL is placed in the retry queue.
        /// </summary>
        /// <param name="hcRequest">A HealthCheckRequest object that defines the current request.</param>
        private void TestHealthCheck(HealthCheckRequest hcRequest)
        {
            hcRequest.BeginRequest(_requestTimeout * 1000);
            hcRequest.Request.Credentials = _credentials;
            Debug.WriteLine(String.Format("{0}: Beginning request #{1}", hcRequest.HealthCheck.HealthUrl, hcRequest.Attempts));
            try
            {
                hcRequest.Request.BeginGetResponse(requestResult =>
                {
                    HealthCheckRequest hcr = (requestResult.AsyncState as HealthCheckRequest);
                    Debug.WriteLine(String.Format("{0}: Ending request #{1}", hcRequest.HealthCheck.HealthUrl, hcRequest.Attempts));
                    HttpWebResponse response = null;
                    try
                    {
                        hcr.EndRequest();
                        response = hcr.Request.EndGetResponse(requestResult) as HttpWebResponse;
                    }
                    catch (WebException webEx)
                    {
                        // Not neccessarily a fatal error, this.
                        // Put the healthcheck into the retry queue.
                        Debug.WriteLine(String.Format("Attempt {0}: {1}({2})", hcr.Attempts, webEx.Message, webEx.Status), hcr.HealthCheck.HealthUrl);
                        DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "{0}: Attempt {1}:\r\n{2}",
                            hcr.HealthCheck.HealthUrl, hcr.Attempts, webEx);

                        response = webEx.Response as HttpWebResponse;
                        if (null == response)
                        {
                            if (hcr.Attempts < _maxAttempts)
                            {
                                Monitor.Enter(_queueLock);
                                _retryQueue.Enqueue(hcr);
                                Interlocked.Increment(ref _remainingHealthchecks);
                                Monitor.Exit(_queueLock);
                            }
                            else
                            {
                                SaveSummary(hcr, webEx.Status.ToString());
                                Monitor.Enter(_failSummary);
                                _failSummary.AppendFormat("{0}: No response was received: {1}\r\n", hcr.HealthCheck.HealthUrl, webEx.Message);
                                Monitor.Exit(_failSummary);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        
                        Debug.WriteLine(String.Format("Attempt {0}: {1}", hcr.Attempts, ex.Message), hcr.HealthCheck.HealthUrl);
                        DACommon.LogEvent(_info.Name, LoggingLevel.Error, "{0}: Attempt {1}: A non-Web exception was thrown:\r\n{2}",
                            hcr.HealthCheck.HealthUrl, hcr.Attempts, ex);

                        if (hcr.Attempts < _maxAttempts)
                        {
                            Monitor.Enter(_queueLock);
                            _retryQueue.Enqueue(hcr);
                            Interlocked.Increment(ref _remainingHealthchecks);
                            Monitor.Exit(_queueLock);
                        }
                        else
                        {
                            SaveSummary(hcr, ex.Message);
                            Monitor.Enter(_failSummary);
                            _failSummary.AppendFormat("{0}: Exception occurred waiting for a response: {1}\r\n", hcr.HealthCheck.HealthUrl, ex.Message);
                            Monitor.Exit(_failSummary);
                            response = null;
                        }
                    }

                    // Kick off another health request
                    HealthCheckRequest newHcr = null;
                    Monitor.Enter(_queueLock);
                    if (_healthQueue.Count > 0)
                    {
                        newHcr = _healthQueue.Dequeue();
                    }
                    Monitor.Exit(_queueLock);
                    if (newHcr != null)
                    {
                        TestHealthCheck(newHcr);
                    }
                    else
                    {
                        // No more health urls - start the retry timer
                        if (Interlocked.Increment(ref _timerSet) == 1)
                        {
                            Debug.WriteLine("Starting the retry timer", hcr.HealthCheck.HealthUrl);
                            _retryTimer.Change(_retryDelta * 1000, Timeout.Infinite);
                        }
                    }

                    if (response != null)
                    {
                        StreamReader responseStream = new StreamReader(response.GetResponseStream(), true);
                        string responseText = null;
                        try
                        {
                            responseText = responseStream.ReadToEnd();
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine(String.Format("Attempt {0}: {1}", hcr.Attempts, ex.Message), hcr.HealthCheck.HealthUrl);
                            DACommon.LogEvent(_info.Name, LoggingLevel.Error, "{0}: Attempt {1}: Unable to read the response stream:\r\n{2}",
                                hcr.HealthCheck.HealthUrl, hcr.Attempts, ex);
                        }
                        finally
                        {
                            responseStream.Close();
                        }

                        // Now that the response stream has been successfully read, it needs to be validated

                        // First save the result file
                        string detailFile = null;
                        try
                        {
                            Debug.WriteLine("Creating the detail file.", hcr.HealthCheck.HealthUrl);
                            detailFile = SaveDetail(hcr.HealthCheck, response.ContentType, responseText);
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine("Unable to create the detail file", hcr.HealthCheck.HealthUrl);
                            Debug.WriteLine(ex);
                            DACommon.LogEvent(_info.Name, LoggingLevel.Error, "{0}: Attempt {1}: Unable to save the response detail file:\r\n{2}",
                                hcr.HealthCheck.HealthUrl, hcr.Attempts, ex);
                        }

                        if (response.ContentType.Contains("text/xml") &&
                            !String.IsNullOrEmpty(responseText))
                        {
                            Debug.WriteLine("Processing the response as XML", hcr.HealthCheck.HealthUrl);
                            XmlDocument doc = new XmlDocument();
                            StringBuilder healthBlockReport = new StringBuilder();
                            try
                            {
                                doc.LoadXml(responseText);
                                XmlNode healthCheckNode = doc.SelectSingleNode("Healthcheck");
                                string healthStatus = healthCheckNode.Attributes["HealthStatus"].Value;
                                if (String.Compare(healthStatus, "Green", true) != 0)
                                {
                                    XmlNodeList failedNodes = doc.SelectNodes("Healthcheck/Reports/HealthReport[@HealthStatus != \"Green\"]");
                                    HealthCheckException hce = null;
                                    if (_exceptions != null && _exceptions.Count > 0)
                                        hce = _exceptions.GetException(hcr.HealthCheck);
                                    hcr.HasException = (hce != null);

                                    for (int i = 0; i < failedNodes.Count; i++)
                                    {
                                        // Determine if there is an exception for this failing health block
                                        XmlNode node = failedNodes[i];
                                        bool hasException = false;
                                        if (null != hce)
                                        {
                                            hasException = hce.HealthBlockExceptions.Contains(node);
                                        }
                                        if (hcr.HasException)
                                            hcr.HasException = hasException;

                                        healthBlockReport.AppendFormat("{0}: {1}[{2}]", i + 1, node.Attributes["Name"].Value, node.Attributes["HealthStatus"].Value);
                                        if (hasException)
                                            healthBlockReport.Append(" (Exception)");
                                        healthBlockReport.Append("\r\n");
                                    }
                                    if (healthBlockReport.Length > 0)
                                        healthBlockReport.Length -= 2;

                                    if (!hcr.HasException && hcr.Attempts < _maxAttempts)
                                    {
                                        Monitor.Enter(_queueLock);
                                        _retryQueue.Enqueue(hcr);
                                        Interlocked.Increment(ref _remainingHealthchecks);
                                        Monitor.Exit(_queueLock);
                                    }
                                    else
                                    {
                                        SaveSummary(hcr, response.StatusCode, healthStatus, detailFile);
                                        string reportText = String.Format("{0}: HealthStatus:{1}; Failed healthblocks:\r\n{2}\r\n",
                                            hcr.HealthCheck.HealthUrl, healthStatus, healthBlockReport.ToString());
                                        DACommon.LogEvent(_info.Name, LoggingLevel.Warning, reportText);
                                        if (hcr.HasException)
                                        {
                                            Monitor.Enter(_exceptionSummary);
                                            _exceptionSummary.Append(reportText);
                                            Monitor.Exit(_exceptionSummary);
                                        }
                                        else
                                        {
                                            Monitor.Enter(_failSummary);
                                            _failSummary.Append(reportText);
                                            Monitor.Exit(_failSummary);
                                        }
                                    }
                                }
                                else
                                    SaveSummary(hcr, response.StatusCode, healthStatus, detailFile);
                            }
                            catch (Exception ex)
                            {
                                Debug.WriteLine("Unable to correctly process the XML returned by the healthcheck:", hcr.HealthCheck.HealthUrl);
                                Debug.WriteLine(ex);
                                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "{0}: Attempt {1}: Unable to process the XML stream returned from the healthcheck:\r\n{2}",
                                    hcr.HealthCheck.HealthUrl, hcr.Attempts, ex);
                            }
                        }
                        else
                        {
                            Debug.WriteLine("Processing response as text/HTML", hcr.HealthCheck.HealthUrl);
                            // We're not looking for a non-xml response - try again
                            if (hcr.Attempts < _maxAttempts)
                            {
                                Monitor.Enter(_queueLock);
                                _retryQueue.Enqueue(hcr);
                                Interlocked.Increment(ref _remainingHealthchecks);
                                Monitor.Exit(_queueLock);
                            }
                            else
                            {
                                // Invalid healthcheck response - save the text and report the failure
                                SaveSummary(hcr, response.StatusCode, null, detailFile);
                                Monitor.Enter(_failSummary);
                                _failSummary.AppendFormat("{0}: Http Response:{1}\r\n", hcr.HealthCheck.HealthUrl, response.StatusDescription);
                                Monitor.Exit(_failSummary);
                            }
                        }
                    }

                    // Decrement the number of outstanding healthchecks
                    if (Interlocked.Decrement(ref _remainingHealthchecks) <= 0)
                    {
                        Debug.WriteLine("All healthchecks have been processed - setting the finish event.");
                        _done.Set();
                    }
                },
                hcRequest);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("Unable to start the asynchronous request:");
                Debug.WriteLine(ex);
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "{0}: Attempt {1}: Unable to start the asyncronous web request:\r\n{2}",
                    hcRequest.HealthCheck.HealthUrl, hcRequest.Attempts, ex);
            }
        }

        /// <summary>
        /// Handler for when the retry timer goes off. The retry queue becomes the
        /// main queue, both the retry queue and the timer are rest, then the URLs
        /// in the queue are processed again.
        /// </summary>
        /// <param name="state">Unused</param>
        private void RetryTimerElapsed(object state)
        {
            Debug.WriteLine("Retry timer expired.");

            // Reset the timer
            _retryTimer.Change(Timeout.Infinite, Timeout.Infinite);
            Interlocked.Exchange(ref _timerSet, 0);

            // When the timer goes off, make the retry queue the main queue,
            // create a new retry queue, and start processing health urls
            if (_retryQueue.Count > 0)
            {
                Debug.WriteLine(String.Format("Moving {0} entries back into the main url queue.", _retryQueue.Count));
                Monitor.Enter(_queueLock);
                _healthQueue = _retryQueue;
                _retryQueue = new Queue<HealthCheckRequest>();
                Monitor.Exit(_queueLock);

                // Send the URLs back through
                Debug.WriteLine("Beginning to reprocess failed health urls.");
                for (int i = 0; i < _batchSize && i < _healthQueue.Count; i++)
                {
                    HealthCheckRequest hcr = null;
                    Monitor.Enter(_queueLock);
                    if (_healthQueue.Count > 0)
                        hcr = _healthQueue.Dequeue();
                    Monitor.Exit(_queueLock);
                    if (hcr != null)
                        TestHealthCheck(hcr);
                }
            }
        }

        /// <summary>
        /// Creates the healthcheck summary file and adds the opening tags.
        /// </summary>
        private void CreateSummaryFile()
        {
            StreamWriter sw = null;
            try
            {
                FileUtils.CreatePath(_logLocation);
                CreateXSLT(this._logLocation, "HealthSummary.xslt");
                CreateXSLT(_logLocation, "health.xslt");
                _summaryFileName = Path.Combine(_logLocation, "HealthCheckSummary.xml");
                sw = new StreamWriter(_summaryFileName);
                sw.WriteLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
                sw.WriteLine("<?xml-stylesheet href='HealthSummary.xslt' type='text/xsl'?>");
                sw.WriteLine("<HealthCheckSummary>");
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to create the HealthCheck summary file at '{0}':\r\n\r\n{1}",
                    _summaryFileName, ex);
                _summaryFileName = null;
            }
            finally
            {
                if (sw != null)
                    sw.Close();
            }
        }

        /// <summary>
        /// Adds the closing tag to the healthcheck summary file.
        /// </summary>
        private void CloseSummaryFile()
        {
            if (_summaryFileName != null)
            {
                StreamWriter sw = null;
                try
                {
                    sw = new StreamWriter(_summaryFileName, true);
                    sw.WriteLine("</HealthCheckSummary>");
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Error closing the HealthCheck summary file:\r\n\r\n{0}", ex);
                }
                finally
                {
                    if (sw != null)
                        sw.Close();
                }
            }
        }

        /// <summary>
        /// Writes the summary line for a healthcheck in the health check summary XML file.
        /// </summary>
        /// <param name="hcr">A HealthCheckRequest object that defines the specific healthcheck request to write</param>
        /// <param name="statusCode">[Optional] A web response status code. May be 0.</param>
        /// <param name="statusDescription">[Optional] A brief description of the status code or the response in general. May be null.</param>
        /// <param name="healthStatus">[Optional] The health status of the health check (Green, Yellow, Red). May be null.</param>
        /// <param name="detailFile">[Optional] The name of the corresponding detail file for this healthcheck. May be null.</param>
        private void SaveSummary(HealthCheckRequest hcr, string responseDescription) { SaveSummary(hcr, 0, responseDescription, null, null); }
        private void SaveSummary(HealthCheckRequest hcr, HttpStatusCode responseCode, string healthStatus, string detailFile) { SaveSummary(hcr, (int)responseCode, responseCode.ToString(), healthStatus, detailFile); }
        private void SaveSummary(HealthCheckRequest hcr, int statusCode, string statusDescription, string healthStatus, string detailFile)
        {
            if (null == _summaryFileName)
                return;

            StringBuilder summaryLine = new StringBuilder();
            summaryLine.AppendFormat("<HealthCheck Name=\"{0}\" Server=\"{1}\" Url=\"{2}\" Attempts=\"{3}\" TimeStamp=\"{4}\" ",
                hcr.HealthCheck.Component, hcr.HealthCheck.Server, hcr.HealthCheck.HealthUrl, hcr.Attempts, hcr.RequestTimestamp.ToString("MM/dd/yyyy HH:mm:ss"));

            if (statusCode > 0)
                summaryLine.AppendFormat("StatusCode=\"{0}\" ", statusCode);
            if (!String.IsNullOrEmpty(statusDescription))
                summaryLine.AppendFormat("StatusDescription=\"{0}\" ", statusDescription);
            if (!String.IsNullOrEmpty(healthStatus))
                summaryLine.AppendFormat("HealthStatus=\"{0}\" ", healthStatus);
            if (!String.IsNullOrEmpty(detailFile))
                summaryLine.AppendFormat("DetailFile=\"{0}\" ", Path.GetFileName(detailFile));
            summaryLine.AppendLine("/>");

            Monitor.Enter(_summaryFileName);
            using (StreamWriter sw = new StreamWriter(_summaryFileName, true))
            {
                sw.WriteLine(summaryLine.ToString());
                sw.Flush();
            }
            Monitor.Exit(_summaryFileName);
        }

        /// <summary>
        /// Saves the detailed response text sent back from the healthcheck request. The file gets saved in the location
        /// specified by the LogsLocation parameter element. For XML responses, the stylesheet processing directive will
        /// get the stylesheet href replaced with the name of the embedded stylesheet.
        /// </summary>
        /// <param name="content">
        /// A HealthCheck object that represents the healthcheck. If the ResponseText element is null or empty,
        /// the file will not be saved.
        /// </param>
        /// <returns>The fully-qualified name of the new file if the file was saved successfully. Null otherwise.</returns>
        private string SaveDetail(HealthCheck hc, string responseType, string responseText)
        {
            if (null == hc)
                throw new ArgumentNullException("hc");

            // If there is no content, don't save anything
            if (String.IsNullOrEmpty(responseText))
                return null;

            // Determine the appropriate extention based on the content type
            string ext = "txt";
            if (null != responseType && responseType.Contains("text/xml"))
            {
                // Fix up the stylesheet element
                responseText = responseText.Replace("'health.ashx?xsl=Default'", "'health.xslt'");
                ext = "xml";
            }
            else if (null != responseType && responseType.Contains("text/html"))
                ext = "html";

            string fileName = Path.Combine(_logLocation, String.Format("{0}({1}).{2}", hc.Component, hc.Port, ext));
            StreamWriter sw = null;
            try
            {
                sw = new StreamWriter(fileName, false);
                sw.Write(responseText);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to save the health response for '{0}' to '{1}':\r\n\r\n{2}",
                    hc.HealthUrl, fileName, ex);
                fileName = null;
            }
            finally
            {
                if (sw != null)
                    sw.Close();
            }

            return fileName;
        }

        /// <summary>
        /// Saves the embedded XML stylesheet to the specified location.
        /// </summary>
        /// <param name="targetPath">The location to create the xslt file.</param>
        /// <param name="xsltName">The name of the stylesheet. This name is used as both the embedded resource name as well as the target xslt file name.</param>
        private void CreateXSLT(string targetPath, string xsltName)
        {
            string xsltFileName = Path.Combine(targetPath, xsltName);
            if (!xsltFileName.EndsWith(".xslt"))
                xsltFileName += ".xslt";

            FileStream xsltOutStream = null;
            Stream xsltInStream = null;

            try
            {
                xsltOutStream = new FileStream(xsltFileName, FileMode.Create, FileAccess.Write, FileShare.Read);
                xsltInStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(xsltName);
                Byte[] block = new Byte[8192];
                int bytesRead;

                while ((bytesRead = xsltInStream.Read(block, 0, 8192)) != 0)
                {
                    xsltOutStream.Write(block, 0, bytesRead);
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Warning, "Unable to save the stylesheet '{0}' to {1}:\r\n{2}",
                    xsltName, targetPath, ex);
            }
            finally
            {
                if (xsltInStream != null)
                    xsltInStream.Close();
                if (xsltOutStream != null)
                    xsltOutStream.Close();
            }
        }

        /// <summary>
        /// Returns the schema that defines a valid XML Parameter block for this module.
        /// </summary>
        /// <returns>An XmlSchema object that represents the schema for the parameter block.</returns>
        private XmlSchema GetSchema()
        {
            Stream schemaStream = null;
            XmlSchema schema = null;

            try
            {
                schemaStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(_info.Name);
                schema = XmlSchema.Read(schemaStream, null);
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(_info.Name, LoggingLevel.Error, "Unable to get the schema:\r\n{0}", ex);
            }
            finally
            {
                if (schemaStream != null)
                    schemaStream.Close();
            }

            return schema;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\ModuleTest\ModuleTest.cs ===
﻿using System;
using System.Text;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.consoletesttaskmodule;
using xonline.test.deployment.automation.taskmodules.eventlogtaskmodule;
using xonline.test.deployment.automation.taskmodules.filetaskmodule;
using xonline.test.deployment.automation.taskmodules.generaltaskmodule;
using xonline.test.deployment.automation.taskmodules.healthchecktaskmodule;
using xonline.test.deployment.automation.taskmodules.stftaskmodule;
using xonline.test.deployment.automation.taskmodules.titleproptaskmodule;
using xonline.test.deployment.automation.taskmodules.vmtaskmodule;
using xonline.test.deployment.automation.taskmodules.vmcleanuptaskmodule;

namespace ModuleTest
{
    class ModuleTest
    {
        static void Main(string[] args)
        {
            // Make sure all diagnostic messages are sent to the event log
            DACommon.LogLevel = LoggingLevel.Debug;

            TaskResult result;

            // Update the task module under test here
            VMCleanupSnapshotModule tm = new VMCleanupSnapshotModule();

            TaskModuleInfo info = tm.Info;
            Console.WriteLine("Task module: {0}", info.Name);
            Console.WriteLine("Description: {0}", info.Description);
            Console.WriteLine("Parameters:");
            foreach (ParameterDescriptor param in info.ParameterDescriptions)
            {
                Console.WriteLine("{0} : {1}", param.ParameterName, param.Description);
            }
            Console.WriteLine();

            Console.WriteLine("Adding parameters to the module...");
            Console.WriteLine();

            #region XML Parameter Block
            // Specify an XML parameter block here
            StringBuilder paramBlock = new StringBuilder();
            paramBlock.AppendLine("<Parameters>");
            paramBlock.AppendLine("</Parameters>");
            try
            {
                tm.AddParameters(paramBlock.ToString());
            }
            catch (Exception ex)
            {
                Console.WriteLine("An exception occurred while adding an XML parameter block to the '{0}' module:\r\n{1}", info.Name, ex);
            }
            #endregion

            #region Individual Name/Value Parameters
            //try
            //{
            //    tm.AddParameter("Name", "Value");
            //}
            //catch (Exception ex)
            //{
            //    Console.WriteLine("An exception occurred while adding the parameters to the module:\r\n{0}", ex);
            //}
            #endregion

            Console.WriteLine();

            Console.WriteLine("Executing the module...");
            Console.WriteLine();
            try
            {
                result = tm.Perform();
                if (result.ExecutedSuccessfully)
                    Console.WriteLine("The module executed successfully.");
                else
                    Console.WriteLine("The module did not execute successfully.");

                Console.WriteLine("Task Logs:");

                for (int i = 0; i < result.Logs.Length; i++)
                {
                    Console.WriteLine("{0}: Type={1} Value=[{2}]", i + 1, result.Logs[i].Path != null ? "File Path" : "Log Text",
                        result.Logs[i].ToString());
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("An unhandled exception occurred while executing the module:\r\n{0}", ex);
            }
            Console.WriteLine();

            Console.WriteLine("Removing all parameters from the module...");
            Console.WriteLine();
            try
            {
                tm.RemoveAllParameters();
                Console.WriteLine("Success");
            }
            catch (Exception ex)
            {
                Console.WriteLine("An exception occurred while removing the parameters:\r\n{0}", ex);
            }

            Console.ReadLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\STFTaskModule\CutoffTimer.cs ===
﻿using System;
using System.Timers;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.stftaskmodule
{
    public delegate bool Condition();

	public class CutoffTimer
	{
        private Timer _timer;

        public CutoffTimer() : this(new TimeSpan(TimeSpan.TicksPerSecond)) { }
        public CutoffTimer(TimeSpan delta)
        {
            _timer = new Timer(delta.TotalMilliseconds);
        }

        public Condition Condition { get; set; }
        public bool TimerStarted
        {
            get { return _timer.Enabled; }
        }

        public event Action OnCondition;

        public void StartTimer()
        {
            _timer.AutoReset = true;
            _timer.Elapsed += new ElapsedEventHandler(_timer_Elapsed);
            _timer.Start();
        }

        public void StopTimer()
        {
            _timer.Stop();
        }

        void _timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            if (Condition())
            {
                if (OnCondition != null)
                {
                    OnCondition();
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\OctopusTaskModule\OctopusTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Security.Principal;
using System.ComponentModel;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.octopustaskmodule
{
    [DeploymentTaskModule("OctopusTaskModule")]
    public class OctopusTaskModule : ITaskModule
    {
        public const string InstallationTypeKey = "installationtype";
        public const string ConfigurationFilePathKey = "configurationfilepath";
        public const string RebootAutomaticallyKey = "rebootautomatically";
        public const string UseVerboseLoggingKey = "useverboselogging";
        public const string PasswordKey = "password";
        public const string PasswordEncryptedKey = "passwordencrypted";
        public const string UseFakeAgentKey = "usefakeagent";
        public const string PropertyKey = "property";

        private Dictionary<string, string> _parameters;
        private TaskModuleInfo _info;

        public OctopusTaskModule()
        {
            _info = new TaskModuleInfo();
            _info.Name = "OctopusTaskModule";
            _info.Description = "Provides access to Octopus in order to perform service deployments.";
            _info.ParameterDescriptions = new ParameterDescriptor[]
            { 
                    new ParameterDescriptor("InstallationType", "The type of installation Octopus should do. Specify INSTALL, UNINSTALL, or PREREQUISITECHECK"),
                    new ParameterDescriptor("ConfigurationFilePath", "Absolute path of the octopus configuration file to be used"),
                    new ParameterDescriptor("Password", "The Password for the user account under which Octopus will run."),
                    new ParameterDescriptor("PasswordEncrypted", "[Optional]Flag indicating whether the password is encrypted. Specify TRUE or FALSE. Default is FALSE"),
                    new ParameterDescriptor("RebootAutomatically", "[Optional]Whether or not Octopus should reboot servers automatically. Specify TRUE or FALSE. Default is TRUE"),
                    new ParameterDescriptor("UseVerboseLogging", "[Optional]Whether or not Windows Installer should generate verbose logs. Specify TRUE or FALSE. Default is FALSE"),
                    new ParameterDescriptor("UseFakeAgent", "[Optional]Whether or not Octopus should use the fake agent. Specify TRUE or FALSE. Default is FALSE"),
                    new ParameterDescriptor("Property", "[Optional]Overrides a property value. Must be in the form <Server> <Component> <Property> <Value>. May be specified multiple times.")
            };

            _parameters = new Dictionary<string, string>();
            _parameters.Add(InstallationTypeKey, "");
            _parameters.Add(ConfigurationFilePathKey, "");
            _parameters.Add(PasswordKey, "");
            _parameters.Add(PasswordEncryptedKey, "false");
            _parameters.Add(UseVerboseLoggingKey, "false");
            _parameters.Add(RebootAutomaticallyKey, "true");
            _parameters.Add(UseFakeAgentKey, "false");
            _parameters.Add(PropertyKey, "");
        }

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public void RemoveAllParameters()
        {
            _parameters[InstallationTypeKey] = "";
            _parameters[ConfigurationFilePathKey] = "";
            _parameters[PasswordKey] = "";
            _parameters[PasswordEncryptedKey] = "false";
            _parameters[UseVerboseLoggingKey] = "false";
            _parameters[RebootAutomaticallyKey] = "true";
            _parameters[UseFakeAgentKey] = "false";
            _parameters[PropertyKey] = "";
        }

        public void AddParameters(string xmlParameterBlock) { }

        public void AddParameter(string parameterName, string value)
        {
            if (String.IsNullOrEmpty(parameterName))
                throw new ArgumentException("Invalid parameter name: '" + parameterName + "'");

            string normalizedParamName = parameterName.ToLower().Trim();
            if (!_parameters.ContainsKey(normalizedParamName))
                throw new ArgumentException("Unknown parameter: '" + parameterName + "'");

            if (String.IsNullOrEmpty(value))
            {
                _parameters[normalizedParamName] = "";
            }
            else
            {
                _parameters[normalizedParamName] = value.Trim();
            }
        }

        public TaskResult Perform()
        {
            bool useFakeAgent = false;
            bool useVerboseLogging = false;
            bool reboot = true;
            bool passwordEncrypted = false;

            OctopusProcess octopusProcess = null;
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            // Validate the required parameters
            if (String.IsNullOrEmpty(_parameters[InstallationTypeKey]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'Installation Type' parameter is required, but was not supplied."));
            }
            if (String.IsNullOrEmpty(_parameters[ConfigurationFilePathKey]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'Configuration File Path' parameter is required, but was not supplied."));
            }
            if (String.IsNullOrEmpty(_parameters[PasswordKey]))
            {
                result.ExecutedSuccessfully = false;
                result.AddLog(new Log("The 'Password' parameter is required, but was not supplied."));
            }

            // Parse the boolean parameters
            if (!bool.TryParse(_parameters[UseFakeAgentKey], out useFakeAgent))
            {
                result.AddLog(new Log("The 'Use Fake Agent' parameter has an invalid value. The default of FALSE will be used."));
                useFakeAgent = false;
            }
            if (!bool.TryParse(_parameters[UseVerboseLoggingKey], out useVerboseLogging))
            {
                result.AddLog(new Log("The 'Use Verbose Logging' parameter has an invalid value. The default of FALSE will be used."));
                useVerboseLogging = false;
            }
            if (!bool.TryParse(_parameters[RebootAutomaticallyKey], out reboot))
            {
                result.AddLog(new Log("The 'Reboot Automatically' parameter has an invalid value. The default of TRUE will be used."));
                reboot = true;
            }
            if (!bool.TryParse(_parameters[PasswordEncryptedKey], out passwordEncrypted))
            {
                result.AddLog(new Log("The 'Password Encrypted' parameter has an invalid value. The default of FALSE will be used."));
                passwordEncrypted = false;
            }

            if (result.ExecutedSuccessfully)
            {
                string password;
                int retries = 1;
                bool retry = false;

                if (passwordEncrypted)
                    password = DataProtector.DecryptFromHexString(_parameters[PasswordKey]);
                else
                    password = _parameters[PasswordKey];

                octopusProcess = new OctopusProcess();
                switch (_parameters[InstallationTypeKey].ToLower())
                {
                    case "install":
                        octopusProcess.InstallationType = OctopusInstallationType.Install;
                        break;
                    case "uninstall":
                        octopusProcess.InstallationType = OctopusInstallationType.Uninstall;
                        break;
                    case "prerequisitecheck":
                        octopusProcess.InstallationType = OctopusInstallationType.PrerequisiteCheck;
                        break;
                    default:
                        result.ExecutedSuccessfully = false;
                        result.AddLog(new Log("Invalid installation type: '{0}'. Expected one of: Install, Uninstall, or PreRequisiteCheck",
                            _parameters[InstallationTypeKey].ToLower()));
                        break;
                }

                if (result.ExecutedSuccessfully)
                {
                    octopusProcess.PathToLogLocationFile = Path.GetTempFileName();
                    octopusProcess.PathToConfigurationFile = _parameters[ConfigurationFilePathKey];
                    octopusProcess.Password = password;
                    octopusProcess.UseFakeAgent = useFakeAgent;
                    octopusProcess.UseVerboseMsiLogging = useVerboseLogging;
                    octopusProcess.PendingRebootOperation = reboot ? OctopusPendingRebootOperation.Reboot : OctopusPendingRebootOperation.Ignore;
                    if (!String.IsNullOrEmpty(_parameters[PropertyKey]))
                    {
                        octopusProcess.PropertyOverrides.AddRange(_parameters[PropertyKey].Split(','));
                    }

                    do
                    {
                        try
                        {
                            octopusProcess.Run();
                            result.ExecutedSuccessfully = (octopusProcess.ExitCode == 0);
                        }
                        catch (Exception ex)
                        {
                            result.ExecutedSuccessfully = false;
                            result.AddLog(new Log("Running the Octopus process threw an exception:\r\n{0}", ex.ToString()));
                        }

                        using (StreamReader s = new StreamReader(octopusProcess.PathToLogLocationFile))
                        {
                            string logDirectoryPath = s.ReadLine();
                            if (!String.IsNullOrEmpty(logDirectoryPath))
                            {
                                // Write the location of the deploymentSession.xml file
                                Log log = new Log();
                                log.Path = logDirectoryPath;
                                log.FileName = "deploymentSession.xml";
                                result.AddLog(log);

                                // If the deployment failed, parse the deploymentSession.xml file for the relevant error
                                // and add that to the log, too
                                if (!result.ExecutedSuccessfully)
                                {
                                    retry = GetOctopusFailure(Path.Combine(logDirectoryPath, "deploymentSession.xml"), result);
                                }
                            }
                            else
                            {
                                // If Octopus never wrote to the temp file, chances are there was a problem
                                // with the command line - save the command output and immediately exit
                                result.AddLog(new Log(octopusProcess.Output));
                            }
                        }

                        // Check to see if we've failed and can retry the deployment
                        if (!result.ExecutedSuccessfully && retry)
                        {
                            if (retries < 3)
                            {
                                retries++;
                                System.Threading.Thread.Sleep(30000);
                                DACommon.LogEvent(LoggingLevel.Warning, "Octopus failed and will be retried. Attempt #{0}", retries + 1);
                            }
                            else
                            {
                                result.AddLog(new Log("Unable to successfully run Octopus after 3 tries, so it's time to give up."));
                                retry = false;
                            }
                        }
                    } while (!result.ExecutedSuccessfully && retry);
                }
            }

            return result;
        }

        // This method will return True if the detected error will support a retry; False otherwise
        public bool GetOctopusFailure(string xmlPath, TaskResult result)
        {
            // We don't want to let any exeption escape from this method.
            // If this fails, then there's nothing lost.
            bool canRetry = false;
            try
            {
                XPathDocument doc = new XPathDocument(xmlPath);
                XPathNavigator nav = doc.CreateNavigator();
                nav.MoveToChild(XPathNodeType.Element);

                // Look for the 'messageError' element
                XPathNavigator msgError = nav.SelectSingleNode("messageError");
                if (msgError != null)
                {
                    // Look for other elements that have an eventLevel = Error
                    XPathNodeIterator errNodes = nav.Select("*[@eventLevel='Error']");
                    if (errNodes.Count > 1)
                    {
                        while (errNodes.MoveNext())
                        {
                            // Ignore the messageError element since it usually doesn't contain useful error information
                            if (String.Compare("messageError", errNodes.Current.Name, true) == 0)
                                continue;

                            // Build the log entry based on the command information
                            StringBuilder logLine = new StringBuilder();
                            logLine.AppendLine("Error Message:");
                            logLine.AppendLine(errNodes.Current.Value);
                            if (String.Compare("commandFinished", errNodes.Current.Name, true) == 0)
                            {
                                logLine.AppendLine("Error Details:");
                                logLine.AppendLine("Server = " + errNodes.Current.GetAttribute("serverName", errNodes.Current.NamespaceURI));
                                logLine.AppendLine("TimeStamp = " + errNodes.Current.GetAttribute("timeStamp", errNodes.Current.NamespaceURI));
                                logLine.AppendLine("Command = " + errNodes.Current.GetAttribute("cmd", errNodes.Current.NamespaceURI));
                            }
                            else if (String.Compare("msiError", errNodes.Current.Name, true) == 0)
                            {
                                logLine.AppendLine("Error Details:");
                                logLine.AppendLine("Server = " + errNodes.Current.GetAttribute("serverName", errNodes.Current.NamespaceURI));
                                logLine.AppendLine("TimeStamp = " + errNodes.Current.GetAttribute("timeStamp", errNodes.Current.NamespaceURI));
                            }

                            result.AddLog(new Log(logLine.ToString()));
                        }
                        canRetry = false;
                    }
                    else
                    {
                        // The messageError node contains the actual error
                        // If the error is an Octopus Agent error, then we should retry the operation
                        canRetry = msgError.Value.ToLower().Contains("setting up the octopus agent failed:");
                        result.AddLog(new Log("Error Message:\r\n" + msgError.Value));
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "OctopusTaskModule : GetOctopusFailure threw and exception while trying to parse the log:\r\n{0}", ex);
            }

            return canRetry;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\SQLTaskModule\CSVTable.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;

namespace xonline.test.deployment.automation.taskmodules.sqltaskmodule
{
    /// <summary>
    /// Static Class containing CSV related methods.
    /// </summary>
    public static class CSVTable
    {

        /// <summary>
        /// Creates a CSV File from an array of strings. Each position in the array corresponds to a position
        /// in the final CSV. A null value at an index indicates an empty cell.
        /// 
        /// Values coming into this method are considered to be unescaped. Any legal string is valid, including
        /// ones that contain carriage returns, commas, line feeds, and quotation marks.
        /// 
        /// This variant of CSV considers whitespace to be important. All whitespace is preserved.
        /// 
        /// This implementation always quotes empty cells.
        /// </summary>
        /// <param name="data">An array representing the CSV file. The first dimension is the Y axis and the second is
        /// the X axis.</param>
        /// <returns>The data in the array, converted to the CSV format</returns>
        public static string ToCSV(string[,] data)
        {
            StringBuilder csvBuilder = new StringBuilder();

            for (int i = 0; i < data.GetLength(0); i++)
            {
                List<string> line = new List<string>();
                for (int j = 0; j < data.GetLength(1); j++)
                {
                    line.Add(EscapeData(data[i, j]));
                }
                csvBuilder.AppendLine(String.Join(",", line.ToArray()));
            }

            return csvBuilder.ToString();
        }

        /// <summary>
        /// Convert a string to its equivalent CSV value. See the ToCSV method for details about escaping.
        /// </summary>
        /// <param name="data">The data to convert to CSV format. This would typically be found in a cell.</param>
        /// <returns>The data in CSV format.</returns>
        static string EscapeData(string data)
        {
            bool requiresQuoting = false;
            string returnedData = ((data == null) ? "" : data);
            
            if (returnedData.Contains("\n")
                || returnedData.Contains("\r")
                || returnedData.Trim() != returnedData
                || returnedData.Contains(",")
                || returnedData == string.Empty)
            {
                requiresQuoting = true;
            }

            if (returnedData.Contains("\""))
            {
                requiresQuoting = true;
                returnedData = data.Replace("\"", "\"\"");
            }

            if (requiresQuoting)
                returnedData = String.Format("\"{0}\"", returnedData);

            return returnedData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\SQLTaskModule\SQLTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.sqltaskmodule
{
    [DeploymentTaskModule("SQLTaskModule")]
    public class SQLTaskModule : ITaskModule
    {
        #region DBConnection Class - Defines a connection to a SQL database
        public class DBConnection
        {
            public string Server { get; private set; }
            public string Database { get; private set; }
            public string Username { get; private set; }
            public string Password { get; private set; }

            public static DBConnection Parse(XPathNavigator node)
            {
                DBConnection conn = new DBConnection();

                conn.Server = node.GetAttribute("Server", node.NamespaceURI);
                conn.Database = node.GetAttribute("Database", node.NamespaceURI);

                string attr = node.GetAttribute("UserName", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    bool encrypted = true;
                    conn.Username = attr;
                    attr = node.GetAttribute("PasswordEncrypted", node.NamespaceURI);
                    if (!Boolean.TryParse(attr, out encrypted))
                        encrypted = true;
                    if (encrypted)
                        conn.Password = DataProtector.DecryptFromHexString(node.GetAttribute("Password", node.NamespaceURI));
                    else
                        conn.Password = node.GetAttribute("Password", node.NamespaceURI);
                }
                return conn;
            }

            public override string ToString()
            {
                SqlConnectionStringBuilder csb = new SqlConnectionStringBuilder();
                csb.ApplicationName = this.GetType().Name;
                csb.DataSource = Server;
                csb.InitialCatalog = Database;
                if (!String.IsNullOrEmpty(Username))
                {
                    csb.UserID = Username;
                    csb.Password = Password;
                }
                else
                {
                    csb.IntegratedSecurity = true;
                }

                return csb.ConnectionString;
            }
        }
        #endregion

        #region Location Class - Defines a file location with user credentials
        protected class Location
        {
            public string Path { get; private set; }
            public string FileName { get; private set; }
            public string UserName { get; private set; }
            public string Password { get; private set; }

            private bool networkDriveMapped = false;

            public static Location Parse(XPathNavigator node)
            {
                Location loc = new Location();
                string attr;
                bool tmp = false;

                loc.Path = "";
                loc.UserName = null;
                loc.Password = null;

                attr = node.GetAttribute("Path", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid element: The Path attribute is missing or empty.");
                loc.Path = attr;

                // The FileName attribute is optional. If not specified, the filename is assumerd to be part of the path
                attr = node.GetAttribute("FileName", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    loc.FileName = System.IO.Path.GetFileName(loc.Path);
                else
                    loc.FileName = attr;

                attr = node.GetAttribute("UserName", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    loc.UserName = attr;
                    attr = node.GetAttribute("PasswordEncrypted", node.NamespaceURI);
                    if (!String.IsNullOrEmpty(attr))
                        Boolean.TryParse(attr, out tmp);
                    attr = node.GetAttribute("Password", node.NamespaceURI);
                    if (!String.IsNullOrEmpty(attr))
                    {
                        if (tmp)
                            loc.Password = DataProtector.DecryptFromHexString(attr);
                        else
                            loc.Password = attr;
                    }
                }

                return loc;
            }

            public bool IsRemote()
            {
                return Path.StartsWith(@"\\");
            }

            public void Connect()
            {
                try
                {
                    // Connect to the remote resource
                    NetworkDrive.MapNetworkDrive(System.IO.Path.GetPathRoot(this.Path), null, UserName, Password);
                    networkDriveMapped = true;
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(LoggingLevel.Warning, "Unable to connect to '{0}':\r\n\r\n{1}", System.IO.Path.GetPathRoot(this.Path), ex);
                }
            }

            public void Disconnect()
            {
                if (networkDriveMapped)
                {
                    try
                    {
                        NetworkDrive.UnMapNetworkDrive(System.IO.Path.GetPathRoot(this.Path), true);
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent(LoggingLevel.Warning, "An error occurred disconnecting from '{0}':\r\n\r\n{1}", System.IO.Path.GetPathRoot(this.Path), ex);
                    }
                }
            }
        }
        #endregion

        protected TaskModuleInfo _info;
        protected TaskResult _result;
        protected DBConnection _connection;
        protected string _query;
        protected bool _errorsAreFatal;
        protected Location _resultsPath;

        public SQLTaskModule()
        {
            StringBuilder desc = new StringBuilder();
            _info = new TaskModuleInfo();
            _info.Name = "Execute SQL Statement";
            _info.Description = "Executes an arbitrary SQL statement on a server.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <Connection Server=\"serverName\" Database=\"databaseName\" [UserName=\"userName\"] [Password=\"password\"] [PasswordEncrypted=\"true|false\"] />");
            desc.AppendLine("  <Query [ErrorsAreFatal=\"true|false\">queryText</Query>");
            desc.AppendLine("  <ResultsFile Path=\"pathToResultsFile\" FileName=\"resultsFileName.csv\" [UserName=\"userName\"] [Password=\"password\"] [PasswordEncrypted=\"true|false\"] />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("The Results element is optional and will only be used when a query returns a rowset.");
            desc.AppendLine("The ErrorsAreFatal attribute on the Query element is optional and defaults to 'true' if not specified.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());
        }
        #region ITaskModule Members

        public void AddParameter(string parameterName, string value)
        {
            throw new ApplicationException("This module does not support Name/Value pair paramters. Please use an XML parameter block instead.");
        }

        public void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "connection":
                            _connection = DBConnection.Parse(itor.Current);
                            break;
                        case "query":
                            {
                                bool tmp;
                                if (!Boolean.TryParse(itor.Current.GetAttribute("ErrorsAreFatal", itor.Current.NamespaceURI), out tmp))
                                    tmp = true;
                                _errorsAreFatal = tmp;
                                _query = itor.Current.Value;
                            }
                            break;
                        case "results":
                            _resultsPath = Location.Parse(itor.Current);
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public TaskModuleInfo Info
        {
            get { return _info; }
        }

        public TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;
            
            if (null == _connection)
            {
                _result.AddLog(new Log("The Connection element is required, but was not specified."));
                _result.ExecutedSuccessfully = false;
            }
            if (null == _query)
            {
                _result.AddLog(new Log("The Query element is required, but was not specified."));
                _result.ExecutedSuccessfully = false;
            }

            if (!_result.ExecutedSuccessfully)
                return _result;

            // Gather the results from the SQL query
            try
            {
                using (SqlConnection connection = new SqlConnection(_connection.ToString()))
                {
                    connection.Open();
                    using (SqlCommand command = new SqlCommand(_query, connection))
                    {
                        if (null == _resultsPath)
                        {
                            // No results required - just run the query
                            int rowsAffected = command.ExecuteNonQuery();
                            _result.AddLog(new Log("Rows affected: {0}", rowsAffected));
                        }
                        else
                        {
                            List<List<string>> outputCollector = new List<List<string>>();

                            using (SqlDataReader reader = command.ExecuteReader())
                            {
                                do
                                {
                                    bool shouldReadHeaders = true;
                                    while (reader.Read())
                                    {
                                        // Input the results into our CSV array
                                        if (shouldReadHeaders)
                                        {
                                            List<string> headerLine = new List<string>();
                                            for (int fieldNumber = 0; fieldNumber < reader.FieldCount; fieldNumber++)
                                            {
                                                headerLine.Add(reader.GetName(fieldNumber));
                                            }

                                            // add an extra line of spacing if this isn't the first result set
                                            if (outputCollector.Count != 0)
                                            {
                                                outputCollector.Add(null);
                                            }
                                            outputCollector.Add(headerLine);
                                            shouldReadHeaders = false;
                                        }

                                        List<string> line = new List<string>();
                                        for (int fieldNumber = 0; fieldNumber < reader.FieldCount; fieldNumber++)
                                        {
                                            line.Add(reader.GetValue(fieldNumber).ToString());
                                        }
                                        outputCollector.Add(line);
                                    }
                                } while (reader.NextResult());
                            }

                            // Save the results
                            // If this is a remote location, we need to connect to it before creating the output file
                            if (_resultsPath.IsRemote() && !String.IsNullOrEmpty(_resultsPath.UserName))
                                _resultsPath.Connect();

                            // Create the output path (if needed)
                            FileUtils.CreatePath(_resultsPath.Path);

                            if (outputCollector.Count > 0)
                            {
                                // determine the maximum width of the csv file, skipping blank lines
                                int maxFieldCount = outputCollector.Where((x) => x != null).Max((x) => x.Count);

                                // move everything into a two dimensional array.
                                // blank fields are left unintialized intentionally.
                                string[,] tableOutput = new string[outputCollector.Count, maxFieldCount];
                                for (int lineNumber = 0; lineNumber < outputCollector.Count; lineNumber++)
                                {
                                    for (int columnNumber = 0;
                                            outputCollector[lineNumber] != null && columnNumber < outputCollector[lineNumber].Count;
                                            columnNumber++)
                                    {
                                        tableOutput[lineNumber, columnNumber] = outputCollector[lineNumber][columnNumber];
                                    }
                                }
                                File.WriteAllText(Path.Combine(_resultsPath.Path, _resultsPath.FileName), CSVTable.ToCSV(tableOutput));
                            }
                            else
                            {
                                File.WriteAllText(Path.Combine(_resultsPath.Path, _resultsPath.FileName), "No results returned.");
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                _result.AddLog(new Log(e.ToString()));
                
                if (_errorsAreFatal)
                    _result.ExecutedSuccessfully = false;
            }

            return _result;
        }

        public void RemoveAllParameters()
        {
            _connection = null;
            _query = null;
            _resultsPath = null;
            _errorsAreFatal = true;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\DACommonLogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    class DACommonLogger : ILogger
    {
        public void LogEvent(string eventSource, LoggingLevel level, string format, params object[] args)
        {
            DACommon.LogEvent(eventSource, level, format, args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\ILogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    public interface ILogger
    {
        void LogEvent(string eventSource, LoggingLevel level, string format, params object[] args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\IProcessLauncher.cs ===
﻿using System;

namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    public interface IProcessLauncher
    {
        /// <summary>
        //  Launch a program in a separate process and wait for completion
        /// </summary>
        /// <param name="program">the program to run</param>
        /// <param name="args">command line args</param>
        /// <returns>the exit code</returns>
        int RunProccess(string program, string args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\ISTFLogFinder.cs ===
namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    public interface ISTFLogFinder
    {
        string[] FindLogFiles(string path);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\STFLogFinder.cs ===
using System;
using System.IO;
using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    public class STFLogFinder : ISTFLogFinder
    {
        private ILogger _logger;
        public STFLogFinder(ILogger logger)
        {
            _logger = logger;
        }

        public string[] FindLogFiles(string path)
        {
            try
            {
                return Directory.GetFiles(path, "*.xml");
            }
            catch (Exception e)
            {
                _logger.LogEvent("TfsPublishSTFResultsTaskModule.STFLogFinder", LoggingLevel.Error, e.Message);
                return new string[0];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\STFTaskModule\SuiteTiming.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.stftaskmodule
{
	public class SuiteTiming
	{
        private class TimingData
        {
            public long Total { get; private set; }
            public long DataPoints { get; private set; }
            public long Average
            {
                get
                {
                    if (DataPoints > 0)
                        return (long)Math.Round((double)Total / (double)DataPoints, 0);
                    return Total;
                }
            }
            public TimingData()
            {
                Total = 0;
                DataPoints = 0;
            }
            public TimingData(long data)
            {
                Total = data;
                DataPoints = 1;
            }

            public void Add(long data)
            {
                Total += data;
                DataPoints++;
            }
        }
        
        private string _timingFileLocation = null;
        private Dictionary<string, TimingData> _suiteTimings;

        public bool Init(string timingFileBasePath)
        {
            bool ret = true;

            if (String.IsNullOrEmpty(timingFileBasePath))
                return false;

            _suiteTimings = new Dictionary<string, TimingData>();
            _timingFileLocation = Path.Combine(timingFileBasePath, "SuiteTiming.xml");
            if (!File.Exists(_timingFileLocation))
            {
                try
                {
                    FileUtils.CreatePath(Path.GetDirectoryName(_timingFileLocation));
                    XmlDocument doc = new XmlDocument();
                    doc.AppendChild(doc.CreateXmlDeclaration("1.0", "utf-8", null));
                    XmlNode root = doc.CreateNode(XmlNodeType.Element, "Suites", doc.NamespaceURI);
                    doc.AppendChild(root);
                    doc.Save(_timingFileLocation);
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent("SuiteTiming", LoggingLevel.Error, "Unable to initialize the timings file:\r\n{0}", ex);
                    ret = false;
                }
            }
            return ret;
        }

        public void LoadSuiteTimingData(string frequency)
        {
            try
            {
                XPathDocument doc = new XPathDocument(_timingFileLocation);
                XPathNavigator nav = doc.CreateNavigator();
                nav = nav.SelectSingleNode("Suites/" + frequency);

                if (null != nav)
                {
                    XPathNodeIterator suites = nav.SelectChildren(XPathNodeType.Element);
                    while (suites.MoveNext())
                    {
                        long data;
                        if (long.TryParse(suites.Current.Value, out data))
                        {
                            if (!_suiteTimings.ContainsKey(suites.Current.Name.ToLower()))
                                _suiteTimings.Add(suites.Current.Name.ToLower(), new TimingData(data));
                            else
                                _suiteTimings[suites.Current.Name.ToLower()].Add(data);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent("SuiteTiming", LoggingLevel.Error, "Unable to load suite timing data:\r\n{0}", ex);
                _suiteTimings.Clear();
            }
        }

        public long GetTiming(string suiteName)
        {
            if (_suiteTimings.ContainsKey(suiteName.ToLower()))
                return _suiteTimings[suiteName.ToLower()].Average;
            return long.MaxValue;
        }

        public void SetTiming(string suiteName, string frequency, long runTimeTicks)
        {
            WriteTimingToDataStore(suiteName, frequency, runTimeTicks);
        }

        private void WriteTimingToDataStore(string suiteName, string frequency, long runTimeTicks)
        {
            if (runTimeTicks <= 0)
                return;

            if (File.Exists(_timingFileLocation))
            {
                lock (_timingFileLocation)
                {
                    try
                    {
                        XmlDocument doc = new XmlDocument();
                        doc.Load(_timingFileLocation);
                        XmlNode root = doc.SelectSingleNode("Suites/" + frequency);
                        if (null == root)
                        {
                            XmlNode suites = doc.SelectSingleNode("Suites");
                            if (null == suites)
                                throw new ApplicationException("Invalid suite timing file - there is no Suites node.");
                            root = doc.CreateNode(XmlNodeType.Element, frequency, doc.NamespaceURI);
                            suites.AppendChild(root);
                        }
                        XmlNode suite = doc.CreateNode(XmlNodeType.Element, suiteName, doc.NamespaceURI);
                        suite.InnerText = runTimeTicks.ToString();
                        root.AppendChild(suite);
                        doc.Save(_timingFileLocation);
                    }
                    catch (Exception ex)
                    {
                        DACommon.LogEvent("SuiteTiming", LoggingLevel.Error, "Unable to write timing for suite {0}:\r\n{1}", suiteName, ex);
                    }
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\ProcessLauncher.cs ===
using System;
using System.Diagnostics;
using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    public class ProcessLauncher : IProcessLauncher
    {
        private ILogger _logger;
        public ProcessLauncher(ILogger logger)
        {
            _logger = logger;
        }

        public int RunProccess(string program, string args)
        {
            Process p = new Process();
            p.StartInfo.FileName = program;
            p.StartInfo.Arguments = args;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.ErrorDataReceived += new DataReceivedEventHandler(ErrorDataHandler);
            p.OutputDataReceived += new DataReceivedEventHandler(OutputDataHandler);
            p.Start();
            p.BeginOutputReadLine();
            p.BeginErrorReadLine();
            p.WaitForExit();
            return p.ExitCode;
        }

        private void OutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)
        {
            // Collect the net view command output.
            if (!String.IsNullOrEmpty(outLine.Data))
            {
                // Add the text to the collected output.
                _logger.LogEvent("TfsPublishSTFResultsTaskModule.ProcessLauncher", 
                    LoggingLevel.Information,
                    outLine.Data);
            }
        }

        private void ErrorDataHandler(object sendingProcess, DataReceivedEventArgs outLine)
        {
            // Collect the net view command output.
            if (!String.IsNullOrEmpty(outLine.Data))
            {
                // Add the text to the collected output.
                _logger.LogEvent("TfsPublishSTFResultsTaskModule.ProcessLauncher",
                    LoggingLevel.Error,
                    outLine.Data);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\STFTaskModule\TestPassSummary.cs ===
﻿using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.test.deployment.automation.common;

namespace xonline.test.deployment.automation.taskmodules.stftaskmodule
{
	public class TestPassSummary
	{
        public string FullPath { get; private set; }
        public XmlDocument _doc = null;
        public XmlNode _root = null;

        public TestPassSummary(string fullPath, string environment, string build, string version, string type, string dateTime)
        {
            FullPath = Path.Combine(fullPath, "TestPassSummary.xml");
            _doc = new XmlDocument();
            _doc.AppendChild(_doc.CreateXmlDeclaration("1.0", "utf-8", string.Empty));
            _doc.AppendChild(_doc.CreateProcessingInstruction("xml-stylesheet", "type='text/xsl' href='TestPassSummary.xslt'"));
            _root = _doc.CreateNode(XmlNodeType.Element, "TestPassSummary", _doc.NamespaceURI);
            _doc.AppendChild(_root);
            XmlAttribute attr = _doc.CreateAttribute("Environment");
            attr.Value = environment;
            _root.Attributes.Append(attr);

            attr = _doc.CreateAttribute("Build");
            attr.Value = build;
            _root.Attributes.Append(attr);

            attr = _doc.CreateAttribute("Version");
            attr.Value = version;
            _root.Attributes.Append(attr);

            attr = _doc.CreateAttribute("Type");
            attr.Value = type;
            _root.Attributes.Append(attr);

            attr = _doc.CreateAttribute("DateTime");
            attr.Value = dateTime;
            _root.Attributes.Append(attr);

            _doc.Save(FullPath);
        }

        public void AddSummary(string suite, string date, string time, string runTime, string total, string failures, string notRun, string totalCases, string filtered, string filteredEnv, string filteredSuite, string resultXmlFile, string owners)
        {
            XmlNode summary = _doc.CreateNode(XmlNodeType.Element, "Summary", _doc.NamespaceURI);
            XmlAttribute attr;

            attr = _doc.CreateAttribute("suite");
            attr.Value = suite;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("date");
            attr.Value = date;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("time");
            attr.Value = time;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("runTime");
            attr.Value = runTime;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("total");
            attr.Value = total;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("failures");
            attr.Value = failures;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("not-run");
            attr.Value = notRun;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("totalcases");
            attr.Value = totalCases;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("filtered");
            attr.Value = filtered;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("filteredEnv");
            attr.Value = filteredEnv;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("filteredSuite");
            attr.Value = filteredSuite;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("resultFile");
            attr.Value = resultXmlFile;
            summary.Attributes.Append(attr);

            attr = _doc.CreateAttribute("owners");
            attr.Value = owners;
            summary.Attributes.Append(attr);

            _root.AppendChild(summary);
            _doc.Save(FullPath);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GenericCommandLineTaskModule")]
[assembly: AssemblyDescription("")]

[assembly: InternalsVisibleTo("GenericCommandLineTaskModuleTests")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\TfsPublishSTFResultsModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using xonline.test.deployment.automation.common;
using System.Threading;

namespace xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule
{
    [DeploymentTaskModule("TfsPublishSTFResultsTaskModule")]
    public class TfsPublishSTFResultsTaskModule : ITaskModule
    {
        public TfsPublishSTFResultsTaskModule()
        {
            Logger = new DACommonLogger();
            TheProcessLauncher = new ProcessLauncher(Logger);
            TheLogFinder = new STFLogFinder(Logger);

            Info = new TaskModuleInfo();
            Info.Name = "TfsPublishSTFResultsTaskModule";
            Info.Description = "Publishes STF logs to TFS";
            Info.ParameterDescriptions =
                new ParameterDescriptor[] 
                { 
                    new ParameterDescriptor("buildname", "The name of the build (eg xonline_r2)"),
                    new ParameterDescriptor("buildnumber", "The build number (eg 09.02.0150.00)"),
                    new ParameterDescriptor("stflogfolder", "The path to the folder with the STF logs to publish"),
                    new ParameterDescriptor("environment", "The environment in which this case was run"),
                    new ParameterDescriptor("logpath", "The path to the logs") 
                };
        }

        internal ILogger Logger
        {
            get;
            set;
        }
        /// <summary>
        /// The build name (eg XOnline_R2)
        /// </summary>
        internal string BuildName 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// The build number (eg 09.02.0126.00)
        /// </summary>
        internal string BuildNumber 
        { 
            get; 
            set; 
        }

        internal string Environment
        {
            get;
            set;
        }

        /// <summary>
        /// The folder where the STF logs are.
        /// </summary>
        internal string STFLogFolder 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// 
        /// </summary>
        internal IProcessLauncher TheProcessLauncher
        {
            get;
            set;
        }

        internal string Frequency
        {
            get;
            set;
        }

        /// <summary>
        /// The log finder
        /// </summary>
        internal ISTFLogFinder TheLogFinder
        {
            get;
            set;
        }
        
        #region ITaskModule Members

        public TaskModuleInfo Info
        {
            get;
            private set;
        }

        /// <summary>
        /// Don't use this, it will only log an error and not add your parameters to anything
        /// </summary>
        /// <param name="parameterName"></param>
        /// <param name="value"></param>
        public void AddParameter(string parameterName, string value)
        {
            Logger.LogEvent(
                Info.Name, 
                LoggingLevel.Error,
                "Failed to add ({0}, {1}). Don't use AddParameter, use AddParameters instead", 
                parameterName, 
                value);
        }

        public void AddParameters(string xmlParameterBlock)
        {

            //Parse XML block
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);

                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                //BUGBUG: This is okay for now, but can get pretty heinous as the number of parameters to this
                //dll grows. Make sure you watch how this grows.
                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    var node = itor.Current;

                    switch (node.Name.ToLower())
                    {
                        case "buildname":
                            BuildName = node.InnerXml.ToLower();
                            break;
                        case "buildnumber":
                            BuildNumber = node.InnerXml;
                            break;
                        case "stflogfolder":
                            STFLogFolder = node.InnerXml;
                            break;
                        case "frequency":
                            Frequency = node.InnerXml;
                            break;
                        case "environment":
                            Environment = node.InnerXml;
                            break;
                        default:
                            Logger.LogEvent(Info.Name,  LoggingLevel.Warning, "Unrecognised parameter: {0}", itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogEvent(Info.Name, LoggingLevel.Error, "Unable to parse the parameter block: {0}", ex);
                throw;
            }
        }

        public void RemoveAllParameters()
        {
            BuildName = string.Empty;
            BuildNumber = string.Empty;
            STFLogFolder = string.Empty;
            
        }

        public TaskResult Perform()
        {
            TaskResult result = new TaskResult();
            result.ExecutedSuccessfully = true;

            // validate the necesarry parameters have been set
            if (string.IsNullOrEmpty(BuildName) || 
                string.IsNullOrEmpty(BuildNumber) || 
                string.IsNullOrEmpty(STFLogFolder))
            {
                result.ExecutedSuccessfully = false;
                return result;
            }

            // get a list of the STF log files to publish to TFS
            string[] logfiles = TheLogFinder.FindLogFiles(STFLogFolder);
            object syncLock = new object();
            int logsPublished = 0;

            foreach ( string log in logfiles)
            {
                while (!ThreadPool.QueueUserWorkItem(
                    delegate(object o)
                    {
                        int exitCode = TheProcessLauncher.RunProccess("TfsPublishResults.exe",
                        "/buildDefinition:" + BuildName +
                        " /buildNumber:" + BuildNumber +
                        " /flavor:retail /platform:x86 /nunit:" + log +
                        " /frequency:" + Frequency +
                        " /logPath:" + STFLogFolder +
                        " /env:" + Environment);

                        if (0 != exitCode)
                        {
                            Logger.LogEvent(
                                Info.Name,
                                LoggingLevel.Error,
                                "Failed to publish " + log);
                            result.ExecutedSuccessfully = false;
                        }

                        lock (syncLock)
                        {
                            logsPublished++;
                        }
                    }))
                {
                }
            }

            int tempPublished;

            lock (syncLock)
            {
                tempPublished = logsPublished;
            }

            while (tempPublished < logfiles.Length)
            {
                Thread.Sleep(TimeSpan.FromSeconds(1));

                lock (syncLock)
                {
                    tempPublished = logsPublished;
                }
            }

            return result;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\TfsPublishSTFResultsModuleTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GenericCommandLineTaskModuleTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("GenericCommandLineTaskModuleTests")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("39ef6baf-f22e-4191-90f1-c709547f9467")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\VMCleanUpTaskModule\VMCleanUpTaskModule.cs ===
﻿using System;
using System.Collections.Generic;
using System.Management;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using System.Text.RegularExpressions;

using xonline.test.deployment.automation.common;
using xonline.test.deployment.automation.taskmodules.vmtaskmodule;

namespace xonline.test.deployment.automation.taskmodules.vmcleanuptaskmodule
{
    [DeploymentTaskModule("VMCleanupSnapshotModule")]
    public class VMCleanupSnapshotModule : VMTaskModuleBase
    {
        #region HostList Class - Object representation of the HostList element.
        protected class HostList
        {
            public List<string> ServerList { get; set; }
            public string UserName { get; set; }
            public string Password { get; set; }
            public static HostList Parse(XPathNavigator node)
            {
                HostList tempHostList = new HostList();
                string attr;
                bool pwdEncrypted = false;

                tempHostList.ServerList = new List<string>();
                tempHostList.UserName = null;
                tempHostList.Password = null;

                attr = node.GetAttribute("Hosts", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ApplicationException("Invalid HostList element: The Hosts attribute is missing.");
                tempHostList.ServerList = ParseCommaDelimitedList(attr);

                attr = node.GetAttribute("UserName", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    tempHostList.UserName = attr;

                    attr = node.GetAttribute("Password", node.NamespaceURI);
                    if (!String.IsNullOrEmpty(attr))
                    {
                        tempHostList.Password = attr;

                        attr = node.GetAttribute("PasswordEncrypted", node.NamespaceURI);
                        if (!String.IsNullOrEmpty(attr))
                        {
                            if (Boolean.TryParse(attr, out pwdEncrypted))
                            {
                                if(pwdEncrypted == true)
                                    tempHostList.Password = DataProtector.DecryptFromHexString(tempHostList.Password);
                            }
                            else
                            {
                                DACommon.LogEvent(LoggingLevel.Warning, "Invalid HostList element: The PasswordEncrypted attribute is invalid. The default of false will be used.");
                            }
                        }
                    }
                }


                return tempHostList;
            }
        }
        #endregion

        #region VMList Class - Object representation of the VMList element.
        protected class VMList
        {
            public string VMSpec { get; set; }
            public List<string> IgnoreVMList { get; set; }
            public bool DelChildren { get; set; }
            public static VMList Parse(XPathNavigator node)
            {
                VMList tempVMList = new VMList();
                string attr;
                bool delChildren;

                tempVMList.VMSpec = "";
                tempVMList.IgnoreVMList = new List<string>();
                tempVMList.DelChildren = false;

                attr = node.GetAttribute("VMSpec", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ArgumentException("Invalid VMList element: The VMSpec attribute is missing.");
                tempVMList.VMSpec = attr;

                attr = node.GetAttribute("IgnoreVMList", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                    tempVMList.IgnoreVMList = ParseCommaDelimitedList(attr);

                attr = node.GetAttribute("DelChildren", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Boolean.TryParse(attr, out delChildren))
                        tempVMList.DelChildren = delChildren;
                }

                return tempVMList;
            }
        }
        #endregion

        #region SnapKeyword Class - Object representation of the SnapKeyword element.
        protected class SnapKeyword
        {
            public Regex RegExString { get; set; }
            public int KeepCount { get; set; }
            public static SnapKeyword Parse(XPathNavigator node)
            {
                SnapKeyword tempSnapKeyword = new SnapKeyword();
                string attr;
                int keepCount;

                tempSnapKeyword.RegExString = null;
                tempSnapKeyword.KeepCount = -1;

                attr = node.GetAttribute("String", node.NamespaceURI);
                if (String.IsNullOrEmpty(attr))
                    throw new ArgumentException("Invalid SnapKeyword element: The Regular Expression String attribute is missing.");
                try
                {
                    tempSnapKeyword.RegExString = new Regex(attr);
                }
                catch(Exception ex)
                {
                    string errorString = String.Format("Unable to parse the Regular Expression attribute of the SnapKeyword element: {0}", attr);
                    throw new ArgumentException(errorString, ex);
                }

                attr = node.GetAttribute("KeepCount", node.NamespaceURI);
                if (!String.IsNullOrEmpty(attr))
                {
                    if (Int32.TryParse(attr, out keepCount) == false)
                        throw new ArgumentException("Invalid SnapKeyword element: The KeepCount attribute is invalid.");
                    tempSnapKeyword.KeepCount = keepCount;
                }

                return tempSnapKeyword;
            }
        }
        #endregion

        protected HostList _hostList;
        protected VMList _vmList;
        protected List<SnapKeyword> _snapKeywordList;
        protected bool _debug;

        /// <summary>
        /// Module to clean up a set of snapshots from one or multiple servers by keeping a recent list of "Versions" and deleting snapshots older than that list
        /// </summary>
        public VMCleanupSnapshotModule()
            : base()
        {
            _info = new TaskModuleInfo();
            _info.Name = "VMCleanupSnapshotModule";
            _info.Description = "Deletes virtual machine snapshots using Hyper-V based on a regular expression string.";
            _info.ParameterDescriptions = new ParameterDescriptor[1];
            StringBuilder desc = new StringBuilder();
            desc.AppendLine("The following is the expected format for the XML Parameter block:\r\n");
            desc.AppendLine("<Parameters>");
            desc.AppendLine("  <HostList Hosts=\"Comma-Delimetted Host List\" Username=\"UserName\" Password=\"Password\" PasswordEncrypted=\"true|false\" />");
            desc.AppendLine("  <VMList VMSpec=\"WQL-compliant string\" IgnoreVMList=\"Comma-Delimetted Ignore List\" DelChildren=\"true|false\" />");
            desc.AppendLine("  <SnapKeyword String=\"RegularExpressionString\" KeepCount=\"[0-x]\" />");
            desc.AppendLine("  <ListOnly />");
            desc.AppendLine("</Parameters>\r\n");
            desc.AppendLine("Multiple SnapKeyword parameters may be passed. Only the first HostList and VMList elements will be used.");
            desc.AppendLine("The UserName and Password attributes on the VMList element is optional. If omitted, the current credentials will be used to connect.");
            desc.AppendLine("The KeepCount attribute on the SnapKeyword element is optional. If omitted, all snapshots matching the regular expression string will be kept.");
            desc.AppendLine("The ListOnly element is optional. If provided the task will simply list all the snapshots that would be deleted for debugging purposes.");
            _info.ParameterDescriptions[0] = new ParameterDescriptor("XML Parameter Block", desc.ToString());

            _hostList = null;
            _vmList = null;
            _snapKeywordList = new List<SnapKeyword>();
            _debug = false;
        }

        public override void AddParameters(string xmlParameterBlock)
        {
            XmlDocument paramDoc = new XmlDocument();

            try
            {
                paramDoc.LoadXml(xmlParameterBlock);
                XPathNavigator docNav = paramDoc.CreateNavigator();
                docNav.MoveToFirstChild();
                if (String.Compare(docNav.Name, "Parameters", true) != 0)
                    throw new ApplicationException("Invalid parameter block. The parent element must have the name 'Parameters'.");

                XPathNodeIterator itor = docNav.SelectChildren(XPathNodeType.Element);
                while (itor.MoveNext())
                {
                    switch (itor.Current.Name.ToLower())
                    {
                        case "hostlist":
                            _hostList = HostList.Parse(itor.Current);
                            break;
                        case "vmlist":
                            _vmList = VMList.Parse(itor.Current);
                            break;
                        case "snapkeyword":
                            _snapKeywordList.Add(SnapKeyword.Parse(itor.Current));
                            break;
                        case "listonly":
                            _debug = true;
                            break;
                        default:
                            DACommon.LogEvent(LoggingLevel.Warning, "{0}: Unknown parameter block element: {1}", _info.Name, itor.Current.Name);
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                DACommon.LogEvent(LoggingLevel.Error, "{0}: Unable to parse the parameter block: {1}", _info.Name, ex);
                throw new ApplicationException("Unable to parse the parameter block.", ex);
            }
        }

        public override void RemoveAllParameters()
        {
            _hostList = null;
            _vmList = null;
            _snapKeywordList = new List<SnapKeyword>();
            _debug = false;
        }

        /// <summary>
        /// Performs the basic action of this module. Queries a list of snapshots based on the HostList/VMName,
        /// parses the list, and deletes snapshots that don't match the "keep" criteria or don't have a version
        /// </summary>
        /// <returns>A TaskResult list that is a list of logs from the module</returns>
        public override TaskResult Perform()
        {
            _result = new TaskResult();
            _result.ExecutedSuccessfully = true;

            // Validate the parameters
            if (null == _hostList)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'HostList' parameter is invalid."));
            }
            if (null == _vmList)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'VMName' parameter is invalid."));
            }
            if (0 == _snapKeywordList.Count)
            {
                _result.ExecutedSuccessfully = false;
                _result.AddLog(new Log("The 'SnapshotKeyword' parameter is missing."));
            }
            if (_debug == true)
            {
                _result.AddLog(new Log("Running Cleanup module in 'listonly' mode. No Snapshots will be deleted"));
            }

            // If the parameters are all valid, perform the task
            if (_result.ExecutedSuccessfully)
            {
                try
                {
                    //Get the single VM or vmspec
                    List<ManagementObject> vmList = FindVMs(_hostList.ServerList, _vmList.VMSpec, 
                            _vmList.IgnoreVMList, _hostList.UserName, _hostList.Password);

                    //Check if we found our VM(s)
                    if (vmList == null || vmList.Count == 0)
                    {
                        DACommon.LogEvent(LoggingLevel.Warning, "VMCleanUpTaskModule - Could not find the VM(s) on host(s) \"{0}\".", _hostList.ServerList.ToString());
                        _result.AddLog(new Log("Could not find the VM(s) on host(s) \"{0}\".", _hostList.ServerList.ToString()));
                    }

                    Dictionary<ManagementObject, List<string>> vmCleanupList = new Dictionary<ManagementObject, List<string>>();
                    //Foreach VM
                    foreach (ManagementObject vm in vmList)
                    {
                        //Get all snapshots for VM
                        List<ManagementObject> vmSnapshots = GetVMSnapshots(vm);
                        if (vmSnapshots.Count != 0)
                        {
                            //Parse through snapshots
                            List<string> toBeDeletedList = GetToBeDeletedSnapshots(vmSnapshots, _snapKeywordList);
                            if (toBeDeletedList.Count != 0)
                            {
                                vmCleanupList.Add(vm, toBeDeletedList);
                            }
                            else
                            {
                                DACommon.LogEvent(LoggingLevel.Information, "{0}: VMCleanUpTaskModule - No snapshots being deleted from vm", vm["ElementName"]);
                                _result.AddLog(new Log("{0}: No snapshots being deleted from vm", vm["ElementName"]));
                            }
                        }
                        else
                        {
                            DACommon.LogEvent(LoggingLevel.Information, "{0}: VMCleanUpTaskModule - No snapshots found on vm", vm["ElementName"]);
                            _result.AddLog(new Log("{0}: No snapshots found on vm", vm["ElementName"]));
                        }
                    }
                    //Delete Snapshots
                    DeleteSnapshotListAsync(vmCleanupList, true, _debug, _vmList.DelChildren);
                }
                catch (Exception ex)
                {
                    DACommon.LogEvent(LoggingLevel.Error, "A global error was caught by the VMCleanUpTaskModule while cleaning up the snapshots. {0}", ex.ToString());
                    _result.ExecutedSuccessfully = false;
                    _result.AddLog(new Log("A global error occurred cleaning up the snapshots. {0}", ex.ToString()));
                }
            }

            return _result;
        }

        /// <summary>
        /// Creates a List of snapshotnames to be deleted. The incoming list is from a specific VM and will be called for each VM.
        /// </summary>
        /// <remarks>
        /// This function will parse through the full list of snapshots provided matching against each regular expressions string.
        /// For each regular expression snapshotKeyword if the snapshot matches the regular expression for that keyword it will add
        /// it to a Dictionary indexed on the snapshot CreationDate which can be sorted to find the "most recent" to keep. When calculating
        /// how many to keep, if -1 is provided as the KeepCount all will be kept. The parsing is paranoid in that if any SnapshotKeyword
        /// determines to keep a snapshot it will be cleaned from the delete list at the end in case another Keyword added it the toBeDeletedList.
        /// </remarks>
        /// <param name="snapshots">List of ManagementObjects for a single vm with each object a unique snapshot</param>
        /// <param name="snapshotKeywordList">List of SnapshotKeyword elements to match against snapshot names</param>
        /// <returns>List of strings that are the full snapshot names to be deleted based on the other parameters</returns>
        private List<string> GetToBeDeletedSnapshots(List<ManagementObject> snapshots, List<SnapKeyword> snapshotKeywordList)
        {
            //Create an empty list we can return by default, anything else will be added
            List<string> toBeDeletedList = new List<string>(); 
            
            // This is the running list of "paranoid" snapshots to keep. Anything added to this list will be kept regardless of other SnapshotKeywords
            List<string> keepSnapshotNameList = new List<string>(); 

            //Iterate through each keyword and find the list of snapshots that match the RegEx and add the non-keep ones to the toBeDeletedList
            foreach (SnapKeyword snapshotKeyword in snapshotKeywordList)
            {
                //Create an empty list to populate that we can sort by snapshot date
                Dictionary<DateTime, string> snapshotDictionary = new Dictionary<DateTime, string>();
                List<DateTime> allSnapDateList;

                //Iterate through all snapshots and add them to the Dictionary if they match the RegEx string. Index the Dictionary on the "CreationTime"
                foreach (ManagementObject snapshot in snapshots)
                {
                    string snapshotName = "";
                    try
                    {
                        snapshotName = snapshot["ElementName"].ToString();
                        if (snapshotKeyword.RegExString.IsMatch(snapshotName))
                        {
                            DateTime snapshotDate = ManagementDateTimeConverter.ToDateTime(snapshot["CreationTime"].ToString());
                            //Adding the ContainsKey check since the same snapshotName/Date are showing up in the snapshots List multiple times
                            //They have the same name and time but different "paths". 
                            //I've verified visually that only 1 snapshot with that name exists on the host
                            if(snapshotDictionary.ContainsKey(snapshotDate) == false)
                                snapshotDictionary.Add(snapshotDate, snapshotName);
                        }
                    }
                    catch (Exception ex)
                    {
                        //Can't parse this snapshot so we'll continue and ignore and not delete it
                        //  If we decide we want to know which snapshots are skipped we can uncomment this
                        //result.AddLog(new Log("Caught Exception parsing snapshot {0}: {1}", newsnapshotinfo.snapshotname, ex.ToString()));
                        DACommon.LogEvent(LoggingLevel.Information, "VMCleanUpTaskModule - Caught Exception parsing snapshot {0}: {1}", snapshotName, ex.ToString());
                    }
                }

                //Create a most recent version list of count = snapshotKeyword.KeepCount
                allSnapDateList = new List<DateTime>(snapshotDictionary.Keys);
                //Create a unique list of all creation dates we can sort and grab just the keepBuildCount latest
                if ((allSnapDateList.Count > snapshotKeyword.KeepCount) && (snapshotKeyword.KeepCount >= 0))
                {
                    //The sort puts the most recent builds at the end of the list so we need to grab n-1 to n-1-keepbuildcount
                    allSnapDateList.Sort();
                    for (int snapCount = 0; snapCount < snapshotKeyword.KeepCount; snapCount++)
                    {
                        string keepSnapshotName = snapshotDictionary[allSnapDateList[allSnapDateList.Count - 1 - snapCount]];
                        if(keepSnapshotNameList.Contains(keepSnapshotName) == false)
                            keepSnapshotNameList.Add(keepSnapshotName);
                    }
                }
                else
                {
                    //If there are less builds available than we're told to keep, keep all of them.
                    //If -1 is passed as the keepcount we want to keep all as well.
                    foreach (DateTime snapshotDate in allSnapDateList)
                    {
                        keepSnapshotNameList.Add(snapshotDictionary[snapshotDate]);
                    }
                }

                //Iterate through each version, each kvp is a Key (CreationDate) and Value (SnapshotName)
                foreach (KeyValuePair<DateTime, string> currentDateTimeSnapshot in snapshotDictionary)
                {
                    //If the snapshot datetime is not in keeplist add tobedeleted
                    if ((keepSnapshotNameList.Contains(currentDateTimeSnapshot.Value) == false) &&
                        (toBeDeletedList.Contains(currentDateTimeSnapshot.Value) == false))
                    {
                        toBeDeletedList.Add(currentDateTimeSnapshot.Value);
                    }
                }
            }

            //We want to be extra careful with the multiple passes here. If any snapKeywords say to keep something we want to keep it.
            foreach (String keepSnapShotName in keepSnapshotNameList)
            {
                //If the keep snapshot is in the delete list, remove it from tobedeleted
                if (toBeDeletedList.Contains(keepSnapShotName) == true)
                {
                    toBeDeletedList.Remove(keepSnapShotName);
                }
            }

            return toBeDeletedList;
        }

        /// <summary>
        /// Parses a comma delmited list and Trim()s the resulting strings into a List of strings
        /// </summary>
        /// <param name="list">string to be parsed</param>
        /// <returns>List of strings parsed from a comma delimited string</returns>
        protected static List<string> ParseCommaDelimitedList(string list)
        {
            //We're doing the trim post Split rather than as a split char in case the keyword is a space like "TestNet Current"
            string[] parsedList = list.Split(new char[] {','});
            List<string> trimmedList = new List<string>();
            foreach (string listItem in parsedList)
            {
                trimmedList.Add(listItem.Trim());
            }

            return trimmedList;
        }

        /// <summary>
        /// Deletes a list of snapshots Asynchronously from a list of VMs. For each VM, a thread is spawned to delete the list
        /// of snapshots for that specific VM and has no dependency on the state of any of the other VMs.
        /// </summary>
        /// <param name="vmDeleteList">Dictionary object where the Keys are VM ManagementObjects and the Values are Lists of snapshotnames to be deleted</param>
        /// <param name="force">whether to force the delete (passed to the DeleteSnapshot API)</param>
        /// <param name="debug">used when debugging to test and log each snapshot that would be deleted without actually deleting the snapshot</param>
        /// <param name="delChildren">if true, will delete all child snapshots using the RemoveVirtualSystemSnapshotTree method</param>
        private void DeleteSnapshotListAsync(Dictionary<ManagementObject, List<string>> vmDeleteList, bool force, bool debug, bool delChildren)
        {
            //foreach Key (VM) Queue the list of snapshots for that VM.
            foreach (KeyValuePair<ManagementObject, List<string>> kvpVM in vmDeleteList)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(DeleteSnapshotList), new ThreadData(kvpVM.Key, kvpVM.Value, force, debug, delChildren));
            }

            // wait for all the thread pool threads to exit
            int maxThreads, availThreads = 0;
            int maxIOPorts, availIOPorts = 0;
            ThreadPool.GetMaxThreads(out maxThreads, out maxIOPorts);
            while (maxThreads != availThreads)
            {
                Thread.Sleep(1000);
                ThreadPool.GetAvailableThreads(out availThreads, out availIOPorts);
            }
        }

        /// <summary>
        /// Deletes a list of snapshots for a specific VM. Iterates through the list, deleting and logging each snapshot as it's deleted
        /// Also writes to the event log when each delete happens. The parameters for this is passes as an object so this function can
        /// be launched as a separate thread for each VM.
        /// </summary>
        /// <param name="state">ThreadData object passed as object</param>
        private void DeleteSnapshotList(object state)
        {
            ThreadData td = state as ThreadData;

            // Create a VMSnapshotModule object and use that to apply the snapshot
            VMSnapshotModule vmsm = new VMSnapshotModule();
            List<Log> logs = new List<Log>();
            bool success = true;
            try
            {
                foreach (string snapshotName in td.SnapshotList)
                {
                    logs.Add(new Log("{0}: Deleting Snapshot: {1}", td.VM["ElementName"], snapshotName));
                    if (td.Debug == false)
                    {
                        DACommon.LogEvent(LoggingLevel.Information, "{0}: VMCleanUpTaskModule - Deleting Snapshot: {1}", td.VM["ElementName"], snapshotName);
                        //Do we want to break out if any of the deletes fail?
                        if (vmsm.DeleteSnapshot(td.VM, snapshotName, td.Force, td.DelChildren) == false)
                        {
                            DACommon.LogEvent(LoggingLevel.Error, "{0}: VMCleanUpTaskModule - Delete Snapshot Failed: {1}", td.VM["ElementName"], snapshotName);
                            success = false;
                        }
                    }
                }
            }
            catch (VMTimeoutException ex)
            {
                logs.Add(new Log("DeleteSnapshot : " + ex.Message));
            }

            // update the common results object
            lock (_result)
            {
                if (_result.ExecutedSuccessfully)
                    _result.ExecutedSuccessfully = success;
                if (vmsm.Result.Logs.Length > 0)
                    _result.AddLogs(vmsm.Result.Logs);
                if (logs.Count != 0)
                    _result.AddLogs(logs);
            }
        }

        #region ThreadData class
        internal class ThreadData
        {
            public ManagementObject VM { get; set; }
            public List<string> SnapshotList { get; set; }
            public bool Force { get; set; }
            public bool Debug { get; set; }
            public bool DelChildren { get; set; }

            public ThreadData() { }
            public ThreadData(ManagementObject vm, List<string> snapshotList, bool force)
            {
                VM = vm;
                SnapshotList = snapshotList;
                Force = force;
                Debug = false;
                DelChildren = false;
            }
            public ThreadData(ManagementObject vm, List<string> snapshotList, bool force, bool debug)
            {
                VM = vm;
                SnapshotList = snapshotList;
                Force = force;
                Debug = debug;
                DelChildren = false;
            }
            public ThreadData(ManagementObject vm, List<string> snapshotList, bool force, bool debug, bool delChildren)
            {
                VM = vm;
                SnapshotList = snapshotList;
                Force = force;
                Debug = debug;
                DelChildren = delChildren;
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\deployment\Automation\TaskModules\TfsPublishSTFResultsModule\TfsPublishSTFResultsModuleTests\TheModuleTests.cs ===
﻿using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.MMF;

using xonline.test.deployment.automation.taskmodules.TfsPublishSTFResultsTaskModule;
using xonline.test.deployment.automation.common;

namespace TfsPublishSTFResultsTaskModuleTests
{
    [TestClass]
    public class TheModuleTests
    {
        [TestMethod]
        public void Integration_run_module_with_no_logs_to_process()
        {
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.AddParameters(
                @"<parameters>" + Environment.NewLine +
                @"  <buildname>XOnline_R2</buildname>" + Environment.NewLine +
                @"  <buildnumber>09.02.0126.00</buildnumber>" + Environment.NewLine +
                @"  <stflogfolder>c:\</stflogfolder>" + Environment.NewLine +
                @"</parameters>");
            theModule.Perform();            
        }
        [TestMethod]
        public void Integration_ProccessLauncher_launch_cmd_with_output_to_stdout()
        {
            var stubLogger = StubFactory.Create<ILogger>();
            var launcher = new ProcessLauncher(stubLogger.Target);
            launcher.RunProccess("cmd.exe", "/c echo foo");
            stubLogger
                .IgnoresArgumentsAt(3)
                .WhenAssertingThat(l => l.LogEvent("TfsPublishSTFResultsTaskModule.ProcessLauncher", 
                    LoggingLevel.Information, "foo"))
                    .WasCalledOneTime();
        }

        [TestMethod]
        public void Integration_ProccessLauncher_launch_cmd_with_output_to_stderr()
        {
            var stubLogger = StubFactory.Create<ILogger>();
            var launcher = new ProcessLauncher(stubLogger.Target);
            launcher.RunProccess("cmd.exe", "/c badcommand");
            stubLogger
                .IgnoresArgumentsAt(3)
                .WhenAssertingThat(l => l.LogEvent("TfsPublishSTFResultsTaskModule.ProcessLauncher", 
                    LoggingLevel.Error, 
                    "'badcommand' is not recognized as an internal or external command,"))
                    .WasCalledOneTime();
        }

        [TestMethod]
        public void AddParameters_adds_build_name_lower_case()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();

            //act
            theModule.AddParameters(
                "<parameters>" + 
                "  <buildname>XOnline_R2</buildname>" + 
                "</parameters>");

            //assert
            Assert.AreEqual("xonline_r2", theModule.BuildName);
        }

        [TestMethod]
        public void AddParameters_can_add_build_version()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();

            //act
            theModule.AddParameters(
                "<parameters>" +
                "  <buildnumber>09.02.0126.00</buildnumber>" +
                "</parameters>");

            //assert
            Assert.AreEqual("09.02.0126.00", theModule.BuildNumber);
        }

        [TestMethod]
        public void AddParameters_can_add_STF_log_folder()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();

            //act
            theModule.AddParameters(
                "<parameters>" +
                @"  <stflogfolder>\foo\bar\stflogs\</stflogfolder>" +
                "</parameters>");

            //assert
            Assert.AreEqual(@"\foo\bar\stflogs\", theModule.STFLogFolder);
        }

        [TestMethod]
        public void AddParameters_can_add_Environment()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();

            //act
            theModule.AddParameters(
                "<parameters>" +
                @"  <environment>AutoNet</environment>" +
                "</parameters>");

            //assert
            Assert.AreEqual(@"AutoNet", theModule.Environment);
        }

        [TestMethod]
        public void AddParameters_can_add_Frequency()
        {
            //arrange
            var theModule = new TfsPublishSTFResultsTaskModule();

            //act
            theModule.AddParameters(
                "<parameters>" +
                @"  <frequency>BVT</frequency>" +
                "</parameters>");

            //assert
            Assert.AreEqual(@"BVT", theModule.Frequency);
        }

        [TestMethod]
        public void AddParameter_logs_an_error()
        {
            //Arrange
            var logStub = StubFactory.Create<ILogger>();
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.Logger = logStub.Target;

            //Act
            theModule.AddParameter("foo", "bar");

            //Assert
            logStub
                .IgnoresArgumentsAt(2,3)
                .WhenAssertingThat(l => l.LogEvent("TfsPublishSTFResultsTaskModule", LoggingLevel.Error, null))
                .WasCalledAtLeastOneTime();
        }

        [TestMethod]
        public void AddParameters_logs_a_warning_when_parameter_is_not_a_recognised_parameter()
        {
            //Arrange
            var logStub = StubFactory.Create<ILogger>();
            var theModule = new TfsPublishSTFResultsTaskModule();
            theModule.Logger = logStub.Target;

            //Act
            theModule.AddParameters(
                "<parameters>" +
                "  <something>foo.exe</something>" +
                "</parameters>");

            //Assert
            logStub
              