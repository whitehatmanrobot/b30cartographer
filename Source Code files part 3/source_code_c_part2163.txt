();
                                } else
                                    UN_INC(ch);

                            } /* end of WHILE loop */

                            if (negative)
                                num64 = (unsigned __int64 )(-(__int64)num64);
                        }
                        else {
                            while (!done_flag) {

                                if (_T('x') == comchr || _T('p') == comchr)

                                    if (_ISXDIGIT(ch)) {
                                        number = (number << 4);
                                        ch = _hextodec(ch);
                                    }
                                    else
                                        ++done_flag;

                                else if (_ISDIGIT(ch))

                                    if (_T('o') == comchr)
                                        if (_T('8') > ch)
                                            number = (number << 3);
                                        else {
                                            ++done_flag;
                                        }
                                    else /* _T('d') == comchr */
                                        number = MUL10(number);

                                else
                                    ++done_flag;

                                if (!done_flag) {
                                    ++started;
                                    number += ch - _T('0');

                                    if (widthset && !--width)
                                        ++done_flag;
                                    else
                                        ch = INC();
                                } else
                                    UN_INC(ch);

                            } /* end of WHILE loop */

                            if (negative)
                                number = (unsigned long)(-(long)number);
                        }
                        if (_T('F')==comchr) /* expected ':' in long pointer */
                            started = 0;

                        if (started)
                            if (!suppress) {

                                ++count;
assign_num:
                                if ( integer64 )
                                    *(__int64 UNALIGNED *)pointer = (unsigned __int64)num64;
                                else
                                if (longone)
                                    *(long UNALIGNED *)pointer = (unsigned long)number;
                                else
                                    *(short UNALIGNED *)pointer = (unsigned short)number;

                            } else /*NULL*/;
                        else
                            goto error_return;

                        break;

                    case _T('n') :      /* char count, don't inc return value */
                        number = charcount;
                        if(!suppress)
                            goto assign_num; /* found in number code above */
                        break;


                    case _T('e') :
                 /* case _T('E') : */
                    case _T('f') :
                    case _T('g') : /* scan a float */
                 /* case _T('G') : */
                        nFloatStrUsed=0;

                        if (_T('-') == ch) {
                            pFloatStr[nFloatStrUsed++] = _T('-');
                            goto f_incwidth;

                        } else if (_T('+') == ch) {
f_incwidth:
                            --width;
                            ch = INC();
                        }

                        if (!widthset)              /* must watch width */
                            width = -1;


                        /* now get integral part */

                        while (_ISDIGIT(ch) && width--) {
                            ++started;
                            pFloatStr[nFloatStrUsed++] = (char)ch;
                            if (__check_float_string(nFloatStrUsed,
                                                     &nFloatStrSz,
                                                     &pFloatStr,
                                                     floatstring,
                                                     &malloc_FloatStrFlag
                                                     )==FALSE) {
                                goto error_return;
                            }
                            ch = INC();
                        }

#ifdef _UNICODE
                        /* convert decimal point to wide-char */
                        /* if mbtowc fails (should never happen), we use L'.' */
                        decimal = L'.';
#ifdef _SAFECRT_IMPL
                        mbtowc(&decimal, _INTRN_LOCALE_CONV(_loc_update)->decimal_point, MB_CUR_MAX);
#else  /* _SAFECRT_IMPL */
                        _mbtowc_l(&decimal,
                                  _INTRN_LOCALE_CONV(_loc_update)->decimal_point,
                                  _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                  _loc_update.GetLocaleT());
#endif  /* _SAFECRT_IMPL */
#else  /* _UNICODE */
                        decimal=*_INTRN_LOCALE_CONV(_loc_update)->decimal_point;
#endif  /* _UNICODE */

                        /* now check for decimal */
                        if (decimal == (char)ch && width--) {
                            ch = INC();
                            pFloatStr[nFloatStrUsed++] = decimal;
                            if (__check_float_string(nFloatStrUsed,
                                                     &nFloatStrSz,
                                                     &pFloatStr,
                                                     floatstring,
                                                     &malloc_FloatStrFlag
                                                     )==FALSE) {
                                goto error_return;
                            }

                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                pFloatStr[nFloatStrUsed++] = (_TCHAR)ch;
                                if (__check_float_string(nFloatStrUsed,
                                                         &nFloatStrSz,
                                                         &pFloatStr,
                                                         floatstring,
                                                         &malloc_FloatStrFlag
                                                         )==FALSE) {
                                    goto error_return;
                                }
                                ch = INC();
                            }
                        }

                        /* now check for exponent */

                        if (started && (_T('e') == ch || _T('E') == ch) && width--) {
                            pFloatStr[nFloatStrUsed++] = _T('e');
                            if (__check_float_string(nFloatStrUsed,
                                                     &nFloatStrSz,
                                                     &pFloatStr,
                                                     floatstring,
                                                     &malloc_FloatStrFlag
                                                     )==FALSE) {
                                goto error_return;
                            }

                            if (_T('-') == (ch = INC())) {

                                pFloatStr[nFloatStrUsed++] = _T('-');
                                if (__check_float_string(nFloatStrUsed,
                                                         &nFloatStrSz,
                                                         &pFloatStr,
                                                         floatstring,
                                                         &malloc_FloatStrFlag
                                                         )==FALSE) {
                                    goto error_return;
                                }
                                goto f_incwidth2;

                            } else if (_T('+') == ch) {
f_incwidth2:
                                if (!width--)
                                    ++width;
                                else
                                    ch = INC();
                            }


                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                pFloatStr[nFloatStrUsed++] = (_TCHAR)ch;
                                if (__check_float_string(nFloatStrUsed,
                                                         &nFloatStrSz,
                                                         &pFloatStr,
                                                         floatstring,
                                                         &malloc_FloatStrFlag
                                                         )==FALSE) {
                                    goto error_return;
                                }
                                ch = INC();
                            }

                        }

                        UN_INC(ch);

                        if (started)
                            if (!suppress) {
                                ++count;
                                pFloatStr[nFloatStrUsed]= _T('\0');
#ifdef _UNICODE
                                {
                                    /* convert floatstring to char string */
                                    /* and do the conversion */
                                    size_t cfslength;
                                    char *cfloatstring;

                                    /*
                                     * Basically the code below assumes that the MULTI BYTE
                                     * Characters are at max 2 bytes. This is true for CRT
                                     * because currently we don't support UTF8.
                                     */
                                    cfslength =(size_t)(nFloatStrSz+1)*sizeof(wchar_t);

                                    if ((cfloatstring = (char *)_malloc_crt (cfslength)) == NULL)
                                        goto error_return;
                                    _ERRCHECK_EINVAL_ERANGE(wcstombs_s (NULL, cfloatstring, cfslength, pFloatStr, cfslength - 1));
                                    _FASSIGN( longone-1, (char*)pointer , cfloatstring, (char)decimal, _loc_update.GetLocaleT());
                                    _free_crt (cfloatstring);
                                }
#else  /* _UNICODE */
                                _FASSIGN( longone-1, (char*)pointer , pFloatStr, (char)decimal, _loc_update.GetLocaleT());
#endif  /* _UNICODE */
                            } else /*NULL */;
                        else
                            goto error_return;

                        break;


                    default:    /* either found '%' or something else */

                        if ((int)*format != (int)ch) {
                            UN_INC(ch);
#ifdef _SECURE_SCANF
                            /* error_return ASSERT's if format_error is true */
                                format_error = TRUE;
#endif  /* _SECURE_SCANF */
                            goto error_return;
                            }
                        else
                            match--; /* % found, compensate for inc below */

                        if (!suppress)
                            arglist = arglistsave;

                } /* SWITCH */

                match++;        /* matched a format field - set flag */

            } /* WHILE (width) */

            else {  /* zero-width field in format string */
                UN_INC(ch);  /* check for input error */
                goto error_return;
            }

            ++format;  /* skip to next char */

        } else  /*  ('%' != *format) */
            {
            if (_T('%') == *format && _T('%') == *(format + 1))
                {
                format++;
                }
            if ((int)*format++ != (int)(ch = INC()))
                {
                UN_INC(ch);
                goto error_return;
                }
#ifndef _UNICODE
            if (isleadbyte((unsigned char)ch))
                {
                int ch2;
                if ((int)*format++ != (ch2=INC()))
                    {
                    UN_INC(ch2);
                    UN_INC(ch);
                    goto error_return;
                    }

                    --charcount; /* only count as one character read */
                }
#endif  /* _UNICODE */
            }

#ifndef CPRFLAG
        if ( (_TEOF == ch) && ((*format != _T('%')) || (*(format + 1) != _T('n'))) )
            break;
#endif  /* CPRFLAG */

    }  /* WHILE (*format) */

error_return:
#if ALLOC_TABLE
    if (malloc_flag == 1)
    {
        _free_crt(table);
    }
#endif  /* ALLOC_TABLE */
    if (malloc_FloatStrFlag == 1)
    {
        _free_crt(pFloatStr);
    }

#ifndef CPRFLAG
    if (_TEOF == ch)
        /* If any fields were matched or assigned, return count */
        return ( (count || match) ? count : EOF);
    else
#endif  /* CPRFLAG */
#ifdef _SECURE_SCANF
        if(format_error == TRUE) {
            _VALIDATE_RETURN( ("Invalid Input Format",0), EINVAL, count);
        }
#endif  /* _SECURE_SCANF */
        return count;

}

/* _hextodec() returns a value of 0-15 and expects a char 0-9, a-f, A-F */
/* _inc() is the one place where we put the actual getc code. */
/* _whiteout() returns the first non-blank character, as defined by isspace() */

static _TINT __cdecl _hextodec ( _TCHAR chr)
{
    return _ISDIGIT(chr) ? chr : (chr & ~(_T('a') - _T('A'))) - _T('A') + 10 + _T('0');
}

#ifdef CPRFLAG

static _TINT __cdecl _inc(void)
{
    return (_gettche_nolock());
}

static void __cdecl _un_inc(_TINT chr)
{
    if (_TEOF != chr) {
        _ungettch_nolock(chr);
    }
}

static _TINT __cdecl _whiteout(REG1 int* counter)
{
    REG2 _TINT ch;

    do
    {
        ++*counter;
        ch = _inc();

        if (ch == _TEOF)
        {
            break;
        }
    }
    while(_istspace((_TUCHAR)ch));
    return ch;
}

#else  /* CPRFLAG */

static _TINT __cdecl _inc(FILE* fileptr)
{
    return (_gettc_nolock(fileptr));
}

static void __cdecl _un_inc(_TINT chr, FILE* fileptr)
{
    if (_TEOF != chr) {
        _ungettc_nolock(chr,fileptr);
    }
}

static _TINT __cdecl _whiteout(int* counter, FILE* fileptr)
{
    _TINT ch;

    do
    {
        ++*counter;
        ch = _inc(fileptr);

        if (ch == _TEOF)
        {
            break;
        }
    }
    while(_istspace((_TUCHAR)ch));
    return ch;
}

#endif  /* CPRFLAG */

#ifdef __cplusplus
} /* extern "C" */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\initmon.c ===
/***
*initmon.c - contains __init_monetary
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_monetary().
*
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*******************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <malloc.h>
#include <limits.h>
#include <dbgint.h>
#include <mtdll.h>

void __cdecl __free_lconv_mon(struct lconv *);
static void fix_grouping(char *);

/*
 *  Note that __lconv_c is used when the monetary category is in the C locale
 *  but the numeric category may not necessarily be in the C locale.
 */


/***
*int __init_monetary() - initialization for LC_MONETARY locale category.
*
*Purpose:
*       In non-C locales, read the localized monetary strings into
*       __lconv_intl, and also copy the numeric strings from __lconv into
*       __lconv_intl.  Set __lconv to point to __lconv_intl.  The old
*       __lconv_intl is not freed until the new one is fully established.
*
*       In the C locale, the monetary fields in lconv are filled with
*       contain C locale values.  Any allocated __lconv_intl fields are freed.
*
*       At startup, __lconv points to a static lconv structure containing
*       C locale strings.  This structure is never used again if
*       __init_monetary is called.
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_monetary (
        pthreadlocinfo ploci
        )
{
    struct lconv *lc;
    int ret;
    LCID ctryid;
    int *lc_refcount;
    int *lconv_mon_refcount = NULL;
    _locale_tstruct locinfo;

    locinfo.locinfo = ploci;
    locinfo.mbcinfo = 0;

    if ( (ploci->lc_handle[LC_MONETARY] != _CLOCALEHANDLE) ||
         (ploci->lc_handle[LC_NUMERIC] != _CLOCALEHANDLE) )
    {
        /*
         * Allocate structure filled with NULL pointers
         */
        if ( (lc = (struct lconv *)
             _calloc_crt(1, sizeof(struct lconv))) == NULL )
            return 1;

        /*
         * Allocate a new reference counter for the lconv structure
         */
        if ( (lc_refcount = _malloc_crt(sizeof(int))) == NULL )
        {
            _free_crt(lc);
            return 1;
        }
        *lc_refcount = 0;

        if ( ploci->lc_handle[LC_MONETARY] != _CLOCALEHANDLE )
        {
            /*
             * Allocate a new reference counter for the numeric info
             */
            if ( (lconv_mon_refcount = _malloc_crt(sizeof(int))) == NULL )
            {
                _free_crt(lc);
                _free_crt(lc_refcount);
                return 1;
            }
            *lconv_mon_refcount = 0;
            /*
             * Currency is country--not language--dependent. NT
             * work-around.
             */
            ctryid = MAKELCID(ploci->lc_id[LC_MONETARY].wCountry, SORT_DEFAULT);

            ret = 0;

            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SINTLSYMBOL, (void *)&lc->int_curr_symbol );
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SCURRENCY, (void *)&lc->currency_symbol );
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SMONDECIMALSEP, (void *)&lc->mon_decimal_point );
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SMONTHOUSANDSEP, (void *)&lc->mon_thousands_sep );
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SMONGROUPING, (void *)&lc->mon_grouping );

            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SPOSITIVESIGN, (void *)&lc->positive_sign);
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid,
                    LOCALE_SNEGATIVESIGN, (void *)&lc->negative_sign);

            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_IINTLCURRDIGITS, (void *)&lc->int_frac_digits);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_ICURRDIGITS, (void *)&lc->frac_digits);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_IPOSSYMPRECEDES, (void *)&lc->p_cs_precedes);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_IPOSSEPBYSPACE, (void *)&lc->p_sep_by_space);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_INEGSYMPRECEDES, (void *)&lc->n_cs_precedes);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_INEGSEPBYSPACE, (void *)&lc->n_sep_by_space);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_IPOSSIGNPOSN, (void *)&lc->p_sign_posn);
            ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid,
                    LOCALE_INEGSIGNPOSN, (void *)&lc->n_sign_posn);

            if ( ret != 0 ) {
                __free_lconv_mon(lc);
                _free_crt(lc);
                _free_crt(lc_refcount);
                _free_crt(lconv_mon_refcount);
                return 1;
            }

            fix_grouping(lc->mon_grouping);
        }
        else {
            /*
             * C locale for monetary category (the numeric category fields,
             * which are NOT of the C locale, get fixed up below). Note
             * that __lconv_c is copied, rather than directly assigning
             * the fields of lc because of the uncertainty of the values of
             * the int_frac_digits,..., n_sign_posn fields (SCHAR_MAX or
             * UCHAR_MAX, depending on whether or a compliand was built
             * with -J.
             */
            *lc = __lconv_c;
        }

        /*
         * Copy the numeric locale fields from the old struct
         */
        lc->decimal_point = ploci->lconv->decimal_point;
        lc->thousands_sep = ploci->lconv->thousands_sep;
        lc->grouping = ploci->lconv->grouping;

        *lc_refcount = 1;
        if (lconv_mon_refcount)
            *lconv_mon_refcount = 1;
    }
    else {
        /*
         * C locale for BOTH monetary and numeric categories.
         */
        lconv_mon_refcount = NULL;
        lc_refcount = NULL;
        lc = &__lconv_c;           /* point to new one */

    }

    if ( (ploci->lconv_mon_refcount != NULL) &&
         (InterlockedDecrement(ploci->lconv_mon_refcount) == 0))
    {
        _ASSERTE(ploci->lconv_mon_refcount > 0);
    }
    if ( (ploci->lconv_intl_refcount != NULL) &&
         (InterlockedDecrement(ploci->lconv_intl_refcount) == 0))
    {
        _free_crt(ploci->lconv);
        _free_crt(ploci->lconv_intl_refcount);
    }
    ploci->lconv_mon_refcount = lconv_mon_refcount;
    ploci->lconv_intl_refcount = lc_refcount;
    ploci->lconv = lc;                       /* point to new one */

    return 0;
}

static void fix_grouping(
        char *grouping
        )
{
    /*
     * ANSI specifies that the fields should contain "\3" [\3\0] to indicate
     * thousands groupings (100,000,000.00 for example).
     * NT uses "3;0"; ASCII 3 instead of value 3 and the ';' is extra.
     * So here we convert the NT version to the ANSI version.
     */

    while (*grouping)
    {
        /* convert '3' to '\3' */
        if (*grouping >= '0' && *grouping <= '9')
        {
            *grouping = *grouping - '0';
            grouping++;
        }

        /* remove ';' */
        else if (*grouping == ';')
        {
            char *tmp = grouping;

            do
                *tmp = *(tmp+1);
            while (*++tmp);
        }

        /* unknown (illegal) character, ignore */
        else
            grouping++;
    }
}


/*
 *  Free the lconv monetary strings.
 *  Numeric values do not need to be freed.
 */
void __cdecl __free_lconv_mon(
        struct lconv *l
        )
{
    if (l == NULL)
        return;

    if ( l->int_curr_symbol != __lconv_c.int_curr_symbol )
        _free_crt(l->int_curr_symbol);

    if ( l->currency_symbol != __lconv_c.currency_symbol )
        _free_crt(l->currency_symbol);

    if ( l->mon_decimal_point != __lconv_c.mon_decimal_point )
        _free_crt(l->mon_decimal_point);

    if ( l->mon_thousands_sep != __lconv_c.mon_thousands_sep )
        _free_crt(l->mon_thousands_sep);

    if ( l->mon_grouping != __lconv_c.mon_grouping )
        _free_crt(l->mon_grouping);

    if ( l->positive_sign != __lconv_c.positive_sign )
        _free_crt(l->positive_sign);

    if ( l->negative_sign != __lconv_c.negative_sign )
        _free_crt(l->negative_sign);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\invalidcontinue.c ===
/***
* invalidcontinue.c - Set the invalid parameter handler to an empty function.
*
*   Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/
#include <stdlib.h>
#include <sect_attribs.h>
#include <internal.h>

int __set_emptyinvalidparamhandler(void);

void __empty_invalid_parameter_handler(
    const wchar_t *pszExpression,
    const wchar_t *pszFunction,
    const wchar_t *pszFile,
    unsigned int nLine,
    uintptr_t pReserved
    )
{
    (pszExpression);
    (pszFunction);
    (pszFile);
    (nLine);
    (pReserved);
    return;
}

int __set_emptyinvalidparamhandler(void)
{
    _set_invalid_parameter_handler(__empty_invalid_parameter_handler);
    return 0;
}

#ifndef _M_CEE_PURE
_CRTALLOC(".CRT$XID") static _PIFV pinit = __set_emptyinvalidparamhandler;
#else  /* _M_CEE_PURE */
#pragma warning(disable:4074)
class __set_emptyinvalidparamhandler_class
{
public:
        __set_emptyinvalidparamhandler_class() { __set_emptyinvalidparamhandler(); }
};
#pragma init_seg(compiler)
static __set_emptyinvalidparamhandler_class __set_emptyinvalidparamhandler_instance;
#endif  /* _M_CEE_PURE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\inputs.c ===
/***
*inputs.c - formatted input with size used by scanf_s etc
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*******************************************************************************/


#define _SECURE_SCANF
#include "input.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\initctyp.c ===
/***
*initctyp.c - contains __init_ctype
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_ctype().
*
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*******************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <ctype.h>
#include <malloc.h>
#include <limits.h>
#include <awint.h>
#include <dbgint.h>
#include <mtdll.h>

#define _CTABSIZE   257     /* size of ctype tables */

/***
*int __init_ctype() - initialization for LC_CTYPE locale category.
*
*Purpose:
*       In non-C locales, preread ctype tables for chars and wide-chars.
*       Old tables are freed when new tables are fully established, else
*       the old tables remain intact (as if original state unaltered).
*       The leadbyte table is implemented as the high bit in ctype1.
*
*       In the C locale, ctype tables are freed, and pointers point to
*       the static ctype table.
*
*       Tables contain 257 entries: -1 to 256.
*       Table pointers point to entry 0 (to allow index -1).
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_ctype (
        pthreadlocinfo ploci
        )
{
    int *refcount = NULL;
    /* non-C locale table for char's    */
    unsigned short *newctype1 = NULL;          /* temp new table */
    unsigned char *newclmap = NULL;                    /* temp new map table */
    unsigned char *newcumap = NULL;                    /* temp new map table */

    /* non-C locale table for wchar_t's */

    unsigned char *cbuffer = NULL;      /* char working buffer */

    int i;                              /* general purpose counter */
    unsigned char *cp;                  /* char pointer */
    CPINFO lpCPInfo;                    /* struct for use with GetCPInfo */
    int mb_cur_max;
    _locale_tstruct locinfo;

    locinfo.locinfo = ploci;
    locinfo.mbcinfo = 0;

    /* allocate and set up buffers before destroying old ones */
    /* codepage will be restored by setlocale if error */

    if (ploci->lc_handle[LC_CTYPE] != _CLOCALEHANDLE)
    {
        if (ploci->lc_codepage == 0)
        { /* code page was not specified */
            if ( __getlocaleinfo( &locinfo, LC_INT_TYPE,
                                  MAKELCID(ploci->lc_id[LC_CTYPE].wLanguage, SORT_DEFAULT),
                                  LOCALE_IDEFAULTANSICODEPAGE,
                                  (char **)&ploci->lc_codepage ) )
                goto error_cleanup;
        }

        /* allocate a new (thread) reference counter */
        refcount = (int *)_malloc_crt(sizeof(int));

            /* allocate new buffers for tables */
            newctype1 = (unsigned short *)
                _calloc_crt((_COFFSET+_CTABSIZE), sizeof(unsigned short));
            newclmap = (char *)
                _calloc_crt((_COFFSET+_CTABSIZE), sizeof(char));
            newcumap = (char *)
                _calloc_crt((_COFFSET+_CTABSIZE), sizeof(char));
            cbuffer = (unsigned char *)
                _calloc_crt (_CTABSIZE, sizeof(char));

        if (!refcount || !newctype1 || !cbuffer || !newclmap || !newcumap)
            goto error_cleanup;

        *refcount = 0;

        /* construct string composed of first 256 chars in sequence */
        for (cp=cbuffer, i=0; i<_CTABSIZE-1; i++)
            *cp++ = (unsigned char)i;

        if (GetCPInfo( ploci->lc_codepage, &lpCPInfo) == FALSE)
            goto error_cleanup;

        if (lpCPInfo.MaxCharSize > MB_LEN_MAX)
            goto error_cleanup;

        mb_cur_max = (unsigned short) lpCPInfo.MaxCharSize;

        /* zero out leadbytes so GetStringType doesn't interpret as multi-byte chars */
        if (mb_cur_max > 1)
        {
            for (cp = (unsigned char *)lpCPInfo.LeadByte; cp[0] && cp[1]; cp += 2)
            {
                for (i = cp[0]; i <= cp[1]; i++)
                    cbuffer[i] = ' ';
            }
        }

        /* convert to newctype1 table - ignore invalid char errors */
        if ( __crtGetStringTypeA(NULL,  CT_CTYPE1,
                                  cbuffer,
                                  _CTABSIZE-1,
                                  newctype1+1+_COFFSET,
                                  ploci->lc_codepage,
                                  0,
                                  FALSE ) == FALSE )
            goto error_cleanup;

        /*
         * LCMapString will map past NULL. Must find NULL if in string
         * before cchSrc characters.
         */
        if ( __crtLCMapStringA(NULL,
                    ploci->lc_handle[LC_CTYPE],
                    LCMAP_LOWERCASE,
                    cbuffer+1,
                    _CTABSIZE-2,
                    newclmap+2+_COFFSET,
                    _CTABSIZE-2,
                    ploci->lc_codepage,
                    FALSE ) == FALSE)
            goto error_cleanup;

        if ( __crtLCMapStringA(NULL,
                    ploci->lc_handle[LC_CTYPE],
                    LCMAP_UPPERCASE,
                    cbuffer+1,
                    _CTABSIZE-2,
                    newcumap+2+_COFFSET,
                    _CTABSIZE-2,
                    ploci->lc_codepage,
                    FALSE ) == FALSE)
            goto error_cleanup;

        newctype1[_COFFSET] = 0; /* entry for EOF */
        newclmap[_COFFSET] = 0;
        newcumap[_COFFSET] = 0;
        newclmap[_COFFSET+1] = 0; /* entry for null */
        newcumap[_COFFSET+1] = 0; /* entry for null */

        /* ignore DefaultChar */

        /* mark lead-byte entries in newctype1 table */
        if (mb_cur_max > 1)
        {
            for (cp = (unsigned char *)lpCPInfo.LeadByte; cp[0] && cp[1]; cp += 2)
            {
                for (i = cp[0]; i <= cp[1]; i++)
                    newctype1[_COFFSET+i+1] = _LEADBYTE;
            }
        }
        /* copy last-1 _COFFSET unsigned short to front
         * note -1, we don't really want to copy 0xff
         */
        memcpy(newctype1,newctype1+_CTABSIZE-1,_COFFSET*sizeof(unsigned short));
        memcpy(newclmap,newclmap+_CTABSIZE-1,_COFFSET*sizeof(char));
        memcpy(newcumap,newcumap+_CTABSIZE-1,_COFFSET*sizeof(char));

        /* free old tables */
        if ((ploci->ctype1_refcount) &&
            (InterlockedDecrement(ploci->ctype1_refcount) == 0))
        {
            _ASSERT(0);
            _free_crt(ploci->ctype1 - _COFFSET);
            _free_crt((char *)(ploci->pclmap - _COFFSET - 1));
            _free_crt((char *)(ploci->pcumap - _COFFSET - 1));
            _free_crt(ploci->ctype1_refcount);
        }
        (*refcount) = 1;
        ploci->ctype1_refcount = refcount;
        /* set pointers to point to entry 0 of tables */
        ploci->pctype = newctype1 + 1 + _COFFSET;
        ploci->ctype1 = newctype1 + _COFFSET;
        ploci->pclmap = newclmap + 1 + _COFFSET;
        ploci->pcumap = newcumap + 1 + _COFFSET;
        ploci->mb_cur_max = mb_cur_max;

        /* cleanup and return success */
        _free_crt (cbuffer);
        return 0;

error_cleanup:
        _free_crt (refcount);
        _free_crt (newctype1);
        _free_crt (newclmap);
        _free_crt (newcumap);
        _free_crt (cbuffer);
        return 1;

    } else {

        if ( (ploci->ctype1_refcount != NULL)&&
             (InterlockedDecrement(ploci->ctype1_refcount) == 0))
        {
            _ASSERTE(ploci->ctype1_refcount > 0);
        }
        ploci->ctype1_refcount = NULL;
        ploci->ctype1 = NULL;
        ploci->pctype = __newctype + 1 + _COFFSET;
        ploci->pclmap = __newclmap + 1 + _COFFSET;
        ploci->pcumap = __newcumap + 1 + _COFFSET;
        ploci->mb_cur_max = 1;

        return 0;
    }
}

/* Define a number of functions which exist so, under _STATIC_CPPLIB, the
 * static multithread C++ Library libcpmt.lib can access data found in the
 * main CRT DLL without using __declspec(dllimport).
 */

_CRTIMP int __cdecl ___mb_cur_max_func(void)
{
    /*
     * Note that we don't need _LocaleUpdate in this function.
     * The main reason being, that this is a leaf function in
     * locale usage terms.
     */
    _ptiddata ptd = _getptd();
    pthreadlocinfo ptloci = ptd->ptlocinfo;

    __UPDATE_LOCALE(ptd, ptloci);

    return ptloci->mb_cur_max;
}

_CRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t loc)
{
    return (loc == NULL) ? ___mb_cur_max_func() : loc->locinfo->mb_cur_max;
}

_CRTIMP UINT __cdecl ___lc_codepage_func(void)
{
    /*
     * Note that we don't need _LocaleUpdate in this function.
     * The main reason being, that this is a leaf function in
     * locale usage terms.
     */
    _ptiddata ptd = _getptd();
    pthreadlocinfo ptloci = ptd->ptlocinfo;

    __UPDATE_LOCALE(ptd, ptloci);

    return ptloci->lc_codepage;
}


_CRTIMP UINT __cdecl ___lc_collate_cp_func(void)
{
    /*
     * Note that we don't need _LocaleUpdate in this function.
     * The main reason being, that this is a leaf function in
     * locale usage terms.
     */
    _ptiddata ptd = _getptd();
    pthreadlocinfo ptloci = ptd->ptlocinfo;

    __UPDATE_LOCALE(ptd, ptloci);

    return ptloci->lc_collate_cp;
}


_CRTIMP LCID* __cdecl ___lc_handle_func(void)
{
    /*
     * Note that we don't need _LocaleUpdate in this function.
     * The main reason being, that this is a leaf function in
     * locale usage terms.
     */
    _ptiddata ptd = _getptd();
    pthreadlocinfo ptloci = ptd->ptlocinfo;

    __UPDATE_LOCALE(ptd, ptloci);

    return ptloci->lc_handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\inittime.c ===
/***
*inittime.c - contains __init_time
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_time().
*
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*******************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <malloc.h>
#include <dbgint.h>
#include <mtdll.h>

static int __cdecl _get_lc_time(struct __lc_time_data *lc_time, pthreadlocinfo);
void __cdecl __free_lc_time(struct __lc_time_data *lc_time);

/* C locale time strings */
extern struct __lc_time_data __lc_time_c;

/***
*int __init_time() - initialization for LC_TIME locale category.
*
*Purpose:
*       In non-C locales, read the localized time/date strings into
*       __lc_time_intl, and set __lc_time_curr to point to it.  The old
*       __lc_time_intl is not freed until the new one is fully established.
*
*       In the C locale, __lc_time_curr is made to point to __lc_time_c.
*       Any allocated __lc_time_intl structures are freed.
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_time (
        pthreadlocinfo ploci
        )
{
    /* Temporary date/time strings */
    struct __lc_time_data *lc_time;

    if ( ploci->lc_handle[LC_TIME] != _CLOCALEHANDLE )
    {
            /* Allocate structure filled with NULL pointers */
            if ( (lc_time = (struct __lc_time_data *)
                 _calloc_crt(1, sizeof(struct __lc_time_data))) == NULL )
                    return 1;

            if (_get_lc_time(lc_time, ploci))
            {
                    __free_lc_time (lc_time);
                    _free_crt (lc_time);
                    return 1;
            }
            lc_time->refcount = 1;
    } else {
            lc_time = &__lc_time_c;      /* point to new one */
    }
    if (ploci->lc_time_curr != &__lc_time_c &&
        InterlockedDecrement(&(ploci->lc_time_curr->refcount)) == 0)
    {
        _ASSERTE(ploci->lc_time_curr->refcount > 0);
    }
    ploci->lc_time_curr = lc_time;           /* point to new one */
    return 0;
}

/*
 *  Get the localized time strings.
 *  Of course, this can be beautified with some loops!
 */
static int __cdecl _get_lc_time (
        struct __lc_time_data *lc_time,
        pthreadlocinfo ploci
        )
{
        int ret = 0;
        _locale_tstruct locinfo;

        /* Some things are language-dependent and some are country-dependent.
        This works around an NT limitation and lets us distinguish the two. */

        LCID langid = MAKELCID(ploci->lc_id[LC_TIME].wLanguage, SORT_DEFAULT);
        LCID ctryid = MAKELCID(ploci->lc_id[LC_TIME].wCountry, SORT_DEFAULT);

        if (lc_time == NULL)
                return -1;

        locinfo.locinfo = ploci;
        locinfo.mbcinfo = 0;

        /* All the text-strings are Language-dependent: */

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME1, (void *)&lc_time->wday_abbr[1]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME2, (void *)&lc_time->wday_abbr[2]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME3, (void *)&lc_time->wday_abbr[3]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME4, (void *)&lc_time->wday_abbr[4]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME5, (void *)&lc_time->wday_abbr[5]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME6, (void *)&lc_time->wday_abbr[6]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVDAYNAME7, (void *)&lc_time->wday_abbr[0]);

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME1, (void *)&lc_time->wday[1]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME2, (void *)&lc_time->wday[2]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME3, (void *)&lc_time->wday[3]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME4, (void *)&lc_time->wday[4]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME5, (void *)&lc_time->wday[5]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME6, (void *)&lc_time->wday[6]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SDAYNAME7, (void *)&lc_time->wday[0]);

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME1, (void *)&lc_time->month_abbr[0]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME2, (void *)&lc_time->month_abbr[1]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME3, (void *)&lc_time->month_abbr[2]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME4, (void *)&lc_time->month_abbr[3]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME5, (void *)&lc_time->month_abbr[4]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME6, (void *)&lc_time->month_abbr[5]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME7, (void *)&lc_time->month_abbr[6]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME8, (void *)&lc_time->month_abbr[7]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME9, (void *)&lc_time->month_abbr[8]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME10, (void *)&lc_time->month_abbr[9]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME11, (void *)&lc_time->month_abbr[10]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SABBREVMONTHNAME12, (void *)&lc_time->month_abbr[11]);

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME1, (void *)&lc_time->month[0]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME2, (void *)&lc_time->month[1]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME3, (void *)&lc_time->month[2]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME4, (void *)&lc_time->month[3]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME5, (void *)&lc_time->month[4]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME6, (void *)&lc_time->month[5]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME7, (void *)&lc_time->month[6]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME8, (void *)&lc_time->month[7]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME9, (void *)&lc_time->month[8]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME10, (void *)&lc_time->month[9]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME11, (void *)&lc_time->month[10]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_SMONTHNAME12, (void *)&lc_time->month[11]);

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_S1159, (void *)&lc_time->ampm[0]);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, langid, LOCALE_S2359, (void *)&lc_time->ampm[1]);


/* The following relate to time format and are Country-dependent: */

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid, LOCALE_SSHORTDATE, (void *)&lc_time->ww_sdatefmt);
        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid, LOCALE_SLONGDATE, (void *)&lc_time->ww_ldatefmt);

        ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid, LOCALE_STIMEFORMAT, (void *)&lc_time->ww_timefmt);

        ret |= __getlocaleinfo(&locinfo, LC_INT_TYPE, ctryid, LOCALE_ICALENDARTYPE, (void *)&lc_time->ww_caltype);

        lc_time->ww_lcid = ctryid;

        return ret;
}

/*
 *  Free the localized time strings.
 *  Of course, this can be beautified with some loops!
 */
void __cdecl __free_lc_time (
        struct __lc_time_data *lc_time
        )
{
        if (lc_time == NULL)
                return;

        _free_crt (lc_time->wday_abbr[1]);
        _free_crt (lc_time->wday_abbr[2]);
        _free_crt (lc_time->wday_abbr[3]);
        _free_crt (lc_time->wday_abbr[4]);
        _free_crt (lc_time->wday_abbr[5]);
        _free_crt (lc_time->wday_abbr[6]);
        _free_crt (lc_time->wday_abbr[0]);

        _free_crt (lc_time->wday[1]);
        _free_crt (lc_time->wday[2]);
        _free_crt (lc_time->wday[3]);
        _free_crt (lc_time->wday[4]);
        _free_crt (lc_time->wday[5]);
        _free_crt (lc_time->wday[6]);
        _free_crt (lc_time->wday[0]);

        _free_crt (lc_time->month_abbr[0]);
        _free_crt (lc_time->month_abbr[1]);
        _free_crt (lc_time->month_abbr[2]);
        _free_crt (lc_time->month_abbr[3]);
        _free_crt (lc_time->month_abbr[4]);
        _free_crt (lc_time->month_abbr[5]);
        _free_crt (lc_time->month_abbr[6]);
        _free_crt (lc_time->month_abbr[7]);
        _free_crt (lc_time->month_abbr[8]);
        _free_crt (lc_time->month_abbr[9]);
        _free_crt (lc_time->month_abbr[10]);
        _free_crt (lc_time->month_abbr[11]);

        _free_crt (lc_time->month[0]);
        _free_crt (lc_time->month[1]);
        _free_crt (lc_time->month[2]);
        _free_crt (lc_time->month[3]);
        _free_crt (lc_time->month[4]);
        _free_crt (lc_time->month[5]);
        _free_crt (lc_time->month[6]);
        _free_crt (lc_time->month[7]);
        _free_crt (lc_time->month[8]);
        _free_crt (lc_time->month[9]);
        _free_crt (lc_time->month[10]);
        _free_crt (lc_time->month[11]);

        _free_crt (lc_time->ampm[0]);
        _free_crt (lc_time->ampm[1]);

        _free_crt (lc_time->ww_sdatefmt);
        _free_crt (lc_time->ww_ldatefmt);
        _free_crt (lc_time->ww_timefmt);
/* Don't need to make these pointers NULL */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\iomanip.cpp ===
// iomanip -- instantiations of iomanip
#include <iomanip>
_STD_BEGIN

		// FUNCTION resetiosflags
static void __cdecl rsfun(ios_base& iostr, ios_base::fmtflags mask)
	{	// reset specified format flags
	iostr.setf(ios_base::_Fmtzero, mask);
	}

		// FUNCTION setiosflags
static void __cdecl sifun(ios_base& iostr, ios_base::fmtflags mask)
	{	// set specified format flags
	iostr.setf(ios_base::_Fmtmask, mask);
	}

		// FUNCTION setbase
static void __cdecl sbfun(ios_base& iostr, int base)
	{	// set base
	iostr.setf(base == 8 ? ios_base::oct
		: base == 10 ? ios_base::dec
		: base == 16 ? ios_base::hex
		: ios_base::_Fmtzero,
			ios_base::basefield);
	}

		// FUNCTION setprecision
static void __cdecl spfun(ios_base& iostr, streamsize prec)
	{	// set precision
	iostr.precision(prec);
	}

		// FUNCTION setw
static void __cdecl swfun(ios_base& iostr, streamsize wide)
	{	// set width
	iostr.width(wide);
	}

_MRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl resetiosflags(ios_base::fmtflags mask)
	{	// manipulator to reset format flags
	return (_Smanip<ios_base::fmtflags>(&rsfun, mask));
	}

_MRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl setiosflags(ios_base::fmtflags mask)
	{	// manipulator to set format flags
	return (_Smanip<ios_base::fmtflags>(&sifun, mask));
	}

_MRTIMP2 _Smanip<int> __cdecl setbase(int base)
	{	// manipulator to set base
	return (_Smanip<int>(&sbfun, base));
	}

_MRTIMP2 _Smanip<streamsize> __cdecl setprecision(streamsize prec)
	{	// manipulator to set precision
	return (_Smanip<streamsize>(&spfun, prec));
	}

_MRTIMP2 _Smanip<streamsize> __cdecl setw(streamsize wide)
	{	// manipulator to set width
	return (_Smanip<streamsize>(&swfun, wide));
	}
_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\instances.cpp ===
// instances -- force DLL instances for Microsoft
#define __FORCE_INSTANCE

#include <complex>
#include <fstream>
#include <ios>
#include <istream>
#include <limits>
#include <locale>
#include <ostream>
#include <sstream>
#include <streambuf>
#include <xlocale>
#include <xlocmes>
#include <xlocmon>
#include <xlocnum>
#include <xloctime>
#include <xstring>

#pragma warning(disable:4439)	// C4439: function with a managed parameter must have a __clrcall calling convention

_STD_BEGIN

template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, char *);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, char&);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, signed char *);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, signed char&);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char *);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char&);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);

 #ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, unsigned short *);
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, unsigned short&);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, const char *);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, char);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, const signed char *);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, signed char);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, const unsigned char *);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, unsigned char);
template _CRTIMP2_PURE basic_ostream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE basic_ostream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, wchar_t);

 #ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2_PURE basic_ostream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE basic_ostream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, unsigned short);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

template _CRTIMP2_PURE basic_string<char, char_traits<char>, allocator<char> > __CLRCALL_OR_CDECL operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE basic_string<char, char_traits<char>, allocator<char> > __CLRCALL_OR_CDECL operator+(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE basic_string<char, char_traits<char>, allocator<char> > __CLRCALL_OR_CDECL operator+(
        const char, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE basic_string<char, char_traits<char>, allocator<char> > __CLRCALL_OR_CDECL operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE basic_string<char, char_traits<char>, allocator<char> > __CLRCALL_OR_CDECL operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);

template _CRTIMP2_PURE basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __CLRCALL_OR_CDECL operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __CLRCALL_OR_CDECL operator+(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __CLRCALL_OR_CDECL operator+(
        const wchar_t, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __CLRCALL_OR_CDECL operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __CLRCALL_OR_CDECL operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2_PURE basic_ostream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);

 #ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2_PURE basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __CLRCALL_OR_CDECL operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __CLRCALL_OR_CDECL operator+(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __CLRCALL_OR_CDECL operator+(
        const unsigned short, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __CLRCALL_OR_CDECL operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __CLRCALL_OR_CDECL operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator<=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator>=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL getline(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL getline(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short);
template _CRTIMP2_PURE basic_ostream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, complex<float>&);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<float>&);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<float>&);
template _CRTIMP2_PURE basic_ostream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<float>&);

 #ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<float>&);
template _CRTIMP2_PURE basic_ostream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<float>&);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, complex<double>&);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<double>&);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<double>&);
template _CRTIMP2_PURE basic_ostream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<double>&);

 #ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<double>&);
template _CRTIMP2_PURE basic_ostream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<double>&);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

template _CRTIMP2_PURE basic_istream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<char, char_traits<char> >&, complex<long double>&);
template _CRTIMP2_PURE basic_ostream<char, char_traits<char> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<long double>&);
template _CRTIMP2_PURE basic_istream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<long double>&);
template _CRTIMP2_PURE basic_ostream<wchar_t, char_traits<wchar_t> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<long double>&);

 #ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2_PURE basic_istream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<long double>&);
template _CRTIMP2_PURE basic_ostream<unsigned short, char_traits<unsigned short> >& __CLRCALL_OR_CDECL operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<long double>&);
 #endif /* _NATIVE_WCHAR_T_DEFINED */

template _CRTIMP2_PURE float __CLRCALL_OR_CDECL imag(const complex<float>&);
template _CRTIMP2_PURE float __CLRCALL_OR_CDECL real(const complex<float>&);
template _CRTIMP2_PURE float __CLRCALL_OR_CDECL _Fabs(const complex<float>&, int *);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator+(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator+(const complex<float>&, const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator+(const float&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator-(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator-(const complex<float>&, const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator-(const float&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator*(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator*(const complex<float>&, const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator*(const float&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator/(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator/(const complex<float>&, const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator/(const float&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator+(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL operator-(const complex<float>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const complex<float>&, const float&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const float&, const complex<float>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const complex<float>&, const float&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const float&, const complex<float>&);
template _CRTIMP2_PURE float __CLRCALL_OR_CDECL abs(const complex<float>&);
template _CRTIMP2_PURE float __CLRCALL_OR_CDECL arg(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL conj(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL cos(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL cosh(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL exp(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL log(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL log10(const complex<float>&);
template _CRTIMP2_PURE float __CLRCALL_OR_CDECL norm(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL polar(const float&, const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL polar(const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL pow(const complex<float>&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL pow(const complex<float>&, const float&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL pow(const complex<float>&, int);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL pow(const float&, const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL sin(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL sinh(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL sqrt(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL tanh(const complex<float>&);
template _CRTIMP2_PURE complex<float> __CLRCALL_OR_CDECL tan(const complex<float>&);

template _CRTIMP2_PURE double __CLRCALL_OR_CDECL imag(const complex<double>&);
template _CRTIMP2_PURE double __CLRCALL_OR_CDECL real(const complex<double>&);
template _CRTIMP2_PURE double __CLRCALL_OR_CDECL _Fabs(const complex<double>&, int *);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator+(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator+(const complex<double>&, const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator+(const double&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator-(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator-(const complex<double>&, const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator-(const double&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator*(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator*(const complex<double>&, const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator*(const double&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator/(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator/(const complex<double>&, const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator/(const double&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator+(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL operator-(const complex<double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const complex<double>&, const double&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const double&, const complex<double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const complex<double>&, const double&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const double&, const complex<double>&);
template _CRTIMP2_PURE double __CLRCALL_OR_CDECL abs(const complex<double>&);
template _CRTIMP2_PURE double __CLRCALL_OR_CDECL arg(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL conj(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL cos(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL cosh(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL exp(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL log(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL log10(const complex<double>&);
template _CRTIMP2_PURE double __CLRCALL_OR_CDECL norm(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL polar(const double&, const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL polar(const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL pow(const complex<double>&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL pow(const complex<double>&, const double&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL pow(const complex<double>&, int);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL pow(const double&, const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL sin(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL sinh(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL sqrt(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL tanh(const complex<double>&);
template _CRTIMP2_PURE complex<double> __CLRCALL_OR_CDECL tan(const complex<double>&);

template _CRTIMP2_PURE long double __CLRCALL_OR_CDECL imag(const complex<long double>&);
template _CRTIMP2_PURE long double __CLRCALL_OR_CDECL real(const complex<long double>&);
template _CRTIMP2_PURE long double __CLRCALL_OR_CDECL _Fabs(const complex<long double>&, int *);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator+(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator+(const complex<long double>&, const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator+(const long double&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator-(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator-(const complex<long double>&, const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator-(const long double&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator*(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator*(const complex<long double>&, const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator*(const long double&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator/(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator/(const complex<long double>&, const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator/(const long double&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator+(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL operator-(const complex<long double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const complex<long double>&, const long double&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator==(const long double&, const complex<long double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const complex<long double>&, const long double&);
template _CRTIMP2_PURE bool __CLRCALL_OR_CDECL operator!=(const long double&, const complex<long double>&);
template _CRTIMP2_PURE long double __CLRCALL_OR_CDECL abs(const complex<long double>&);
template _CRTIMP2_PURE long double __CLRCALL_OR_CDECL arg(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL conj(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL cos(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL cosh(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL exp(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL log(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL log10(const complex<long double>&);
template _CRTIMP2_PURE long double __CLRCALL_OR_CDECL norm(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL polar(const long double&, const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL polar(const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL pow(const complex<long double>&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL pow(const complex<long double>&, const long double&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL pow(const complex<long double>&, int);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL pow(const long double&, const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL sin(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL sinh(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL sqrt(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL tanh(const complex<long double>&);
template _CRTIMP2_PURE complex<long double> __CLRCALL_OR_CDECL tan(const complex<long double>&);

#if defined(_DEBUG)
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Throw(const exception& ex)
	{	// report throw exception and die
#pragma warning(push)
#pragma warning(disable:4996)
	std::_Debug_message("exception: ", ex.what());
#pragma warning(pop)
	}
#endif

#if 0
__PURE_APPDOMAIN_GLOBAL locale::id collate<char>::id(0);

_MRTIMP2 locale::id& __cdecl collate<char>::_Id_func()
{
    return collate<char>::id;
}

__PURE_APPDOMAIN_GLOBAL locale::id collate<wchar_t>::id(0);

_MRTIMP2 locale::id& __cdecl collate<wchar_t>::_Id_func()
{
    return collate<wchar_t>::id;
}

 #ifdef _NATIVE_WCHAR_T_DEFINED
__PURE_APPDOMAIN_GLOBAL locale::id collate<unsigned short>::id(0);

_MRTIMP2 locale::id& __cdecl collate<unsigned short>::_Id_func()
{
    return collate<unsigned short>::id;
}

 #endif /* _NATIVE_WCHAR_T_DEFINED */
#endif


_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\intrin.h ===
/***
*intrin.h = declerations/definitions for some platform specific intrinsic stuff.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*Purpose:
*   This include file contains the declerations for platform specific intrinsic
*   functions, or will include other files that have decleration of intrinsic
*   functions. Also there will be some platform specific macros to be used with
*   intrinsic functions.
*
****/

#pragma once
#define __INTRIN_H_
#ifndef RC_INVOKED
#ifndef __midl

#include <crtdefs.h>
#include <setjmp.h>
#include <stddef.h>

#if !defined (_M_CEE_PURE)

#include <emmintrin.h>
#include <xmmintrin.h>
#include <mmintrin.h>

#if defined (_M_IX86)
#include <mm3dnow.h>
#if defined (__cplusplus)
#include <dvec.h>
#include <fvec.h>
#include <ivec.h>
#endif  /* defined (__cplusplus) */
#endif  /* defined (_M_IX86) */

#endif  /* !defined (_M_CEE_PURE) */

#if defined (__cplusplus)
extern "C" {
#endif  /* defined (__cplusplus) */

/*
** __MACHINE             : all compilers
** __MACHINEI            : Intel (32 bit x86) and X64
** __MACHINEX64          : X64 compiler only
** __MACHINEIA32         : 32 bit x86 arch only
** __MACHINEX86X_X64     : X86 Extended intrinsics supported on X64
** __MACHINEX86X_IA64    : X86 Extended intrinsics supported on IA64
** __MACHINEIA64         : IA64 compiler only
** __MACHINEW64          : WIN64(tm), 64 bit compilers only
** __MACHINEIW64         : IA32 + Win64 compilers only (__MACHINEI + __MACHINEW64)
** __MACHINESA           : ARM (StrongARM) only
** __MACHINEARMX         : ARM XSCALE intrinsics
** __MACHINECC           : Intel XSCALE Concan
** __MACHINECE           : common intrinsic functions for Windows CE
** __MACHINEZ            : nothing
*/

#define __MACHINEI            __MACHINE
#define __MACHINEX64          __MACHINE
#define __MACHINEIA32         __MACHINE
#define __MACHINEX86X_X64     __MACHINE
#define __MACHINEX86X_IA64    __MACHINE
#define __MACHINEIA64         __MACHINE
#define __MACHINEW64          __MACHINE
#define __MACHINEIW64         __MACHINE
#define __MACHINESA           __MACHINE
#define __MACHINEARMX         __MACHINE
#define __MACHINECC           __MACHINE
#define __MACHINECE           __MACHINE

/* No intrinsics available to pure managed code */
#if defined (_M_CEE_PURE)
#define __MACHINE(X)          __MACHINEZ(X)
#else  /* defined (_M_CEE_PURE) */
#define __MACHINE(X)          X;
#endif  /* defined (_M_CEE_PURE) */

#define __MACHINEZ(X)         /* NOTHING */

#if !(_M_IX86)
#undef __MACHINEIA32
#define __MACHINEIA32         __MACHINEZ
#endif  /* !(_M_IX86) */

#if !(_M_IA64)
#undef __MACHINEIA64
#define __MACHINEIA64         __MACHINEZ
#endif  /* !(_M_IA64) */

#if !(_M_AMD64)
#undef __MACHINEX64
#define __MACHINEX64          __MACHINEZ
#endif  /* !(_M_AMD64) */

#if !(_M_IA64 || _M_AMD64)
#undef __MACHINEW64
#define __MACHINEW64          __MACHINEZ
#endif  /* !(_M_IA64 || _M_AMD64) */

#if !(_M_IX86 || _M_AMD64 || _M_IA64)
#undef __MACHINEIW64
#define __MACHINEIW64         __MACHINEZ
#endif  /* !(_M_IX86 || _M_AMD64 || _M_IA64) */

#if !(_M_IX86 || _M_IA64)
#undef __MACHINEX86X_IA64
#define __MACHINEX86X_IA64    __MACHINEZ
#endif  /* !(_M_IX86 || _M_IA64) */

#if !(_M_IX86 || _M_AMD64)
#undef __MACHINEX86X_X64
#define __MACHINEX86X_X64     __MACHINEZ
#endif  /* !(_M_IX86 || _M_AMD64) */

#if !(_M_ARM)
#undef  __MACHINESA
#undef  __MACHINEARMX
#undef  __MACHINECC
#define __MACHINESA           __MACHINEZ
#define __MACHINEARMX         __MACHINEZ
#define __MACHINECC           __MACHINEZ
#endif  /* !(_M_ARM) */

#if !defined (_WIN32_WCE)
#undef __MACHINECE
#define __MACHINECE           __MACHINEZ
#endif  /* !defined (_WIN32_WCE) */

__MACHINEIA64(void _AcquireSpinLock(unsigned __int64 *))
__MACHINE(void * __cdecl _alloca(size_t))
__MACHINE(int __cdecl abs(_In_ int))
__MACHINEIA64(void __break(int))
__MACHINECE(__int64 __cdecl _abs64(__int64))
__MACHINE(_Check_return_ unsigned short __cdecl _byteswap_ushort(_In_ unsigned short value))
__MACHINE(_Check_return_ unsigned long __cdecl _byteswap_ulong(_In_ unsigned long value))
__MACHINE(_Check_return_ unsigned __int64 __cdecl _byteswap_uint64(_In_ unsigned __int64 value))
__MACHINECE(void __CacheRelease(void *))
__MACHINECE(void __CacheWriteback(void *))
__MACHINECE(_CRTIMP double ceil(double))
__MACHINEX64(_CRTIMP double ceil(double))
__MACHINECE(_CRTIMP double ceil(double))
__MACHINECE(double _CopyDoubleFromInt64(__int64))
__MACHINECE(float _CopyFloatFromInt32(__int32))
__MACHINECE(__int64 _CopyInt64FromDouble(double))
__MACHINECE(__int32 _CopyInt32FromFloat(float))
__MACHINECE(unsigned _CountLeadingOnes(long))
__MACHINECE(unsigned _CountLeadingOnes64(__int64))
__MACHINECE(unsigned _CountLeadingSigns(long))
__MACHINECE(unsigned _CountLeadingSigns64(__int64))
__MACHINECE(unsigned _CountLeadingZeros(long))
__MACHINECE(unsigned _CountLeadingZeros64(__int64))
__MACHINECE(unsigned _CountOneBits(long))
__MACHINECE(unsigned _CountOneBits64(__int64))
__MACHINE(void __cdecl __debugbreak(void))
__MACHINEI(void __cdecl _disable(void))
__MACHINEIA64(void __cdecl _disable(void))
__MACHINEIA64(void __dsrlz(void))
__MACHINEI(__int64 __emul(int,int))
__MACHINEI(unsigned __int64 __emulu(unsigned int,unsigned int))
__MACHINEI(void __cdecl _enable(void))
__MACHINEIA64(void __cdecl _enable(void))
__MACHINEIA64(void __fc(__int64))
__MACHINEIA64(void __fclrf(void))
__MACHINEIA64(void __fsetc(int, int))
__MACHINEIA64(void __fwb(void))
__MACHINEIA64(unsigned __int64 __getReg(int))
__MACHINEIA64(unsigned __int64 __getPSP(void))
__MACHINEIA64(unsigned __int64 __getCFS(void))
__MACHINECE(void __ICacheRefresh(void *))
__MACHINEIA64(long _InterlockedAdd(long volatile *, long))
__MACHINEIA64(long _InterlockedAdd_acq(long volatile *, long))
__MACHINEIA64(long _InterlockedAdd_rel(long volatile *, long))
__MACHINEIA64(__int64 _InterlockedAdd64(__int64 volatile *, __int64))
__MACHINEIA64(__int64 _InterlockedAdd64_acq(__int64 volatile *, __int64))
__MACHINEIA64(__int64 _InterlockedAdd64_rel(__int64 volatile *, __int64))
__MACHINEI(long __cdecl _InterlockedDecrement(long volatile *))
__MACHINEIA64(long _InterlockedDecrement(long volatile *))
__MACHINEIA64(long _InterlockedDecrement_acq(long volatile *))
__MACHINEIA64(long _InterlockedDecrement_rel(long volatile *))
__MACHINEIA64(__int64 _InterlockedDecrement64(__int64 volatile *))
__MACHINEIA64(__int64 _InterlockedDecrement64_acq(__int64 volatile *))
__MACHINEIA64(__int64 _InterlockedDecrement64_rel(__int64 volatile *))
__MACHINEX64(__int64 _InterlockedDecrement64(__int64 volatile *))
__MACHINEI(long _InterlockedExchange(long volatile *, long))
__MACHINEIA64(long _InterlockedExchange(long volatile *, long))
__MACHINEIA64(long _InterlockedExchange_acq(long volatile *, long))
__MACHINESA(long __stdcall _InterlockedExchange(long volatile *, long))
__MACHINEIA64(__int64 _InterlockedExchange64(__int64 volatile *, __int64))
__MACHINEIA64(__int64 _InterlockedExchange64_acq(__int64 volatile *, __int64))
__MACHINEX64(__int64 _InterlockedExchange64(__int64 volatile *, __int64))
__MACHINEIA64(void * _InterlockedExchangePointer(void * volatile *, void *))
__MACHINEIA64(void * _InterlockedExchangePointer_acq(void * volatile *, void *))
__MACHINEX64(void * _InterlockedExchangePointer(void * volatile *, void *))
__MACHINEI(long _InterlockedExchangeAdd(long volatile *, long))
__MACHINEIA64(long _InterlockedExchangeAdd(long volatile *, long))
__MACHINEIA64(long _InterlockedExchangeAdd_acq(long volatile *, long))
__MACHINEIA64(long _InterlockedExchangeAdd_rel(long volatile *, long))
__MACHINEIA64(__int64 _InterlockedExchangeAdd64(__int64 volatile *, __int64))
__MACHINEIA64(__int64 _InterlockedExchangeAdd64_acq(__int64 volatile *, __int64))
__MACHINEIA64(__int64 _InterlockedExchangeAdd64_rel(__int64 volatile *, __int64))
__MACHINEX64(__int64 _InterlockedExchangeAdd64(__int64 volatile *, __int64))
__MACHINEI(long _InterlockedCompareExchange (long volatile *, long, long))
__MACHINEIA64(long _InterlockedCompareExchange (long volatile *, long, long))
__MACHINEIA64(long _InterlockedCompareExchange_acq (long volatile *, long, long))
__MACHINEIA64(long _InterlockedCompareExchange_rel (long volatile *, long, long))
__MACHINEIA64(__int64 _InterlockedCompareExchange64(__int64 volatile *, __int64, __int64))
__MACHINEIA64(__int64 _InterlockedCompareExchange64_acq(__int64 volatile *, __int64, __int64))
__MACHINEIA64(__int64 _InterlockedCompareExchange64_rel(__int64 volatile *, __int64, __int64))
__MACHINEIA64(__int64 _InterlockedCompare64Exchange128(__int64 volatile *Destination, __int64 ExchangeHigh, __int64 ExchangeLow, __int64 Comparand))
__MACHINEIA64(__int64 _InterlockedCompare64Exchange128_acq(__int64 volatile *Destination, __int64 ExchangeHigh, __int64 ExchangeLow, __int64 Comparand))
__MACHINEIA64(__int64 _InterlockedCompare64Exchange128_rel(__int64 volatile *Destination, __int64 ExchangeHigh, __int64 ExchangeLow, __int64 Comparand))
__MACHINEIA64(void *_InterlockedCompareExchangePointer (void * volatile *, void *, void *))
__MACHINEIA64(void *_InterlockedCompareExchangePointer_acq (void * volatile *, void *, void *))
__MACHINEIA64(void *_InterlockedCompareExchangePointer_rel (void * volatile *, void *, void *))
__MACHINEI(__int64 _InterlockedCompareExchange64(__int64 volatile *, __int64, __int64))
__MACHINEX64(void *_InterlockedCompareExchangePointer (void * volatile *, void *, void *))
__MACHINEI(long __cdecl _InterlockedIncrement(long volatile *))
__MACHINEIA64(long _InterlockedIncrement(long volatile *))
__MACHINEIA64(long _InterlockedIncrement_acq(long volatile *))
__MACHINEIA64(long _InterlockedIncrement_rel(long volatile *))
__MACHINEIA64(__int64 _InterlockedIncrement64(__int64 volatile *))
__MACHINEIA64(__int64 _InterlockedIncrement64_acq(__int64 volatile *))
__MACHINEIA64(__int64 _InterlockedIncrement64_rel(__int64 volatile *))
__MACHINEX64(__int64 _InterlockedIncrement64(__int64 volatile *))
__MACHINEIW64(long _InterlockedOr(long volatile *, long))
__MACHINEIW64(char _InterlockedOr8(char volatile *, char))
__MACHINEIW64(short _InterlockedOr16(short volatile *, short))
__MACHINEW64(__int64 _InterlockedOr64(__int64 volatile *, __int64))
__MACHINEIA64(long _InterlockedOr_acq(long volatile *, long))
__MACHINEIA64(char _InterlockedOr8_acq(char volatile *, char))
__MACHINEIA64(short _InterlockedOr16_acq(short volatile *, short))
__MACHINEIA64(__int64 _InterlockedOr64_acq(__int64 volatile *, __int64))
__MACHINEIA64(long _InterlockedOr_rel(long volatile *, long))
__MACHINEIA64(char _InterlockedOr8_rel(char volatile *, char))
__MACHINEIA64(short _InterlockedOr16_rel(short volatile *, short))
__MACHINEIA64(__int64 _InterlockedOr64_rel(__int64 volatile *, __int64))
__MACHINEIW64(long _InterlockedXor(long volatile *, long))
__MACHINEIW64(char _InterlockedXor8(char volatile *, char))
__MACHINEIW64(short _InterlockedXor16(short volatile *, short))
__MACHINEW64(__int64 _InterlockedXor64(__int64 volatile *, __int64))
__MACHINEIA64(long _InterlockedXor_acq(long volatile *, long))
__MACHINEIA64(char _InterlockedXor8_acq(char volatile *, char))
__MACHINEIA64(short _InterlockedXor16_acq(short volatile *, short))
__MACHINEIA64(__int64 _InterlockedXor64_acq(__int64 volatile *, __int64))
__MACHINEIA64(long _InterlockedXor_rel(long volatile *, long))
__MACHINEIA64(char _InterlockedXor8_rel(char volatile *, char))
__MACHINEIA64(short _InterlockedXor16_rel(short volatile *, short))
__MACHINEIA64(__int64 _InterlockedXor64_rel(__int64 volatile *, __int64))
__MACHINEIW64(long _InterlockedAnd(long volatile *, long))
__MACHINEIW64(char _InterlockedAnd8(char volatile *, char))
__MACHINEIW64(short _InterlockedAnd16(short volatile *, short))
__MACHINEW64(__int64 _InterlockedAnd64(__int64 volatile *, __int64))
__MACHINEIA64(long _InterlockedAnd_acq(long volatile *, long))
__MACHINEIA64(char _InterlockedAnd8_acq(char volatile *, char))
__MACHINEIA64(short _InterlockedAnd16_acq(short volatile *, short))
__MACHINEIA64(__int64 _InterlockedAnd64_acq(__int64 volatile *, __int64))
__MACHINEIA64(long _InterlockedAnd_rel(long volatile *, long))
__MACHINEIA64(char _InterlockedAnd8_rel(char volatile *, char))
__MACHINEIA64(short _InterlockedAnd16_rel(short volatile *, short))
__MACHINEIA64(__int64 _InterlockedAnd64_rel(__int64 volatile *, __int64))
__MACHINEIA32(long _InterlockedAddLargeStatistic(__int64 volatile *, long))
__MACHINEI(int __cdecl _inp(unsigned short))
__MACHINEI(int __cdecl inp(unsigned short))
__MACHINEI(unsigned long __cdecl _inpd(unsigned short))
__MACHINEI(unsigned long __cdecl inpd(unsigned short))
__MACHINEI(unsigned short __cdecl _inpw(unsigned short))
__MACHINEI(unsigned short __cdecl inpw(unsigned short))
__MACHINEIA64(int __isNat(int))
__MACHINEIA64(void __isrlz(void))
__MACHINEIA64(void __invalat(void))
__MACHINECE(int _isnan(double))
__MACHINECE(int _isnanf(float))
__MACHINECE(int _isunordered(double,double))
__MACHINECE(int _isunorderedf(float,float))
__MACHINE(long __cdecl labs(_In_ long))
__MACHINEIA64(void __lfetch(int, volatile void const *))
__MACHINEIA64(void __lfetchfault(int, volatile void const *))
__MACHINEIA64(void __lfetch_excl(int, volatile void const *))
__MACHINEIA64(void __lfetchfault_excl(int, volatile void const *))
__MACHINEIA64(__int64 __load128(void *, __int64 *))
__MACHINEIA64(__int64 __load128_acq(void *, __int64 *))
__MACHINEZ(void __cdecl longjmp(jmp_buf, int))
__MACHINE(_Check_return_ unsigned long __cdecl _lrotl(_In_ unsigned long,_In_ int))
__MACHINE(_Check_return_ unsigned long __cdecl _lrotr(_In_ unsigned long,_In_ int))
__MACHINEI(unsigned __int64  __ll_lshift(unsigned __int64,int))
__MACHINEI(__int64  __ll_rshift(__int64,int))
__MACHINEIA64(__m64 __m64_czx1l(__m64))
__MACHINEIA64(__m64 __m64_czx1r(__m64))
__MACHINEIA64(__m64 __m64_czx2l(__m64))
__MACHINEIA64(__m64 __m64_czx2r(__m64))
__MACHINEIA64(__m64 __m64_dep_mi(const int,__m64,const int,const int))
__MACHINEIA64(__m64 __m64_dep_mr(__m64,__m64,const int,const int))
__MACHINEIA64(__m64 __m64_dep_zi(const int,const int,const int))
__MACHINEIA64(__m64 __m64_dep_zr(__m64,const int,const int))
__MACHINEIA64(__m64 __m64_extr(__m64,const int,const int))
__MACHINEIA64(__m64 __m64_extru(__m64,const int,const int))
__MACHINEIA64(__m64 __m64_mix1l(__m64,__m64))
__MACHINEIA64(__m64 __m64_mix1r(__m64,__m64))
__MACHINEIA64(__m64 __m64_mix2l(__m64,__m64))
__MACHINEIA64(__m64 __m64_mix2r(__m64,__m64))
__MACHINEIA64(__m64 __m64_mix4l(__m64,__m64))
__MACHINEIA64(__m64 __m64_mix4r(__m64,__m64))
__MACHINEIA64(__m64 __m64_mux1(__m64,const int))
__MACHINEIA64(__m64 __m64_mux2(__m64,const int))
__MACHINEIA64(__m64 __m64_muladd64hi(__m64,__m64,__m64))
__MACHINEIA64(__m64 __m64_muladd64hi_u(__m64,__m64,__m64))
__MACHINEIA64(__m64 __m64_muladd64lo(__m64,__m64,__m64))
__MACHINEIA64(__m64 __m64_padd1uus(__m64,__m64))
__MACHINEIA64(__m64 __m64_padd2uus(__m64,__m64))
__MACHINEIA64(__m64 __m64_pavg1_nraz(__m64,__m64))
__MACHINEIA64(__m64 __m64_pavg2_nraz(__m64,__m64))
__MACHINEIA64(__m64 __m64_pavgsub1(__m64,__m64))
__MACHINEIA64(__m64 __m64_pavgsub2(__m64,__m64))
__MACHINEIA64(__m64 __m64_pmpy2l(__m64,__m64))
__MACHINEIA64(__m64 __m64_pmpy2r(__m64,__m64))
__MACHINEIA64(__m64 __m64_pmpyshr2(__m64,__m64,const int))
__MACHINEIA64(__m64 __m64_pmpyshr2u(__m64,__m64,const int))
__MACHINEIA64(__m64 __m64_popcnt(__m64))
__MACHINEIA64(__m64 __m64_pshladd2(__m64,const int,__m64))
__MACHINEIA64(__m64 __m64_pshradd2(__m64,const int,__m64))
__MACHINEIA64(__m64 __m64_psub1uus(__m64,__m64))
__MACHINEIA64(__m64 __m64_psub2uus(__m64,__m64))
__MACHINEIA64(__m64 __m64_shladd(__m64,const int,__m64))
__MACHINEIA64(__m64 __m64_shrp(__m64,__m64,const int))
__MACHINECE(_CONST_RETURN void * __cdecl memchr(const void *,int,size_t))
__MACHINE(_Check_return_ int __cdecl memcmp(_In_opt_bytecount_(_Size) const void *,_In_opt_bytecount_(_Size) const void *,_In_ size_t _Size))
__MACHINE(void * __cdecl memcpy(_Out_opt_bytecapcount_(_Size) void *,_In_opt_bytecount_(_Size) const void *,_In_ size_t _Size))
__MACHINE(void * __cdecl memset(_Out_opt_bytecapcount_(_Size) void *,_In_ int,_In_ size_t _Size))
__MACHINEIA64(void __mf(void))
__MACHINEIA64(void __mfa(void))
__MACHINECE(long _MulHigh(long,long))
__MACHINECE(unsigned long _MulUnsignedHigh (unsigned long,unsigned long))
__MACHINEI(int __cdecl _outp(unsigned short,int))
__MACHINEI(int __cdecl outp(unsigned short,int))
__MACHINEI(unsigned long __cdecl _outpd(unsigned short,unsigned long))
__MACHINEI(unsigned long __cdecl outpd(unsigned short,unsigned long))
__MACHINEI(unsigned short __cdecl _outpw(unsigned short,unsigned short))
__MACHINEI(unsigned short __cdecl outpw(unsigned short,unsigned short))
__MACHINECE(void __cdecl __prefetch(unsigned long *addr))
__MACHINEIA64(void __ptcl(__int64, __int64))
__MACHINEIA64(void __ptcg(__int64, __int64))
__MACHINEIA64(void __ptcga(__int64, __int64))
__MACHINEIA64(void __ptrd(__int64, __int64))
__MACHINEIA64(void __ptri(__int64, __int64))
__MACHINEIA64(void *_rdteb(void))
__MACHINEIA64(void *_rdtebex(void))
__MACHINESA(int _ReadStatusReg(int))
__MACHINECE(void _ReadWriteBarrier(void))
__MACHINEIA64(void _ReleaseSpinLock(unsigned __int64 * ))
__MACHINEI(void * _ReturnAddress(void))
__MACHINEIA64(void * _ReturnAddress(void))
__MACHINESA(void * _ReturnAddress(void))
__MACHINECE(void * _ReturnAddress(void))
__MACHINE(_Check_return_ unsigned int __cdecl _rotl(_In_ unsigned int,_In_ int))
__MACHINECE(_Check_return_ unsigned __int64 __cdecl _rotl64(_In_ unsigned __int64,_In_ int))
__MACHINE(_Check_return_ unsigned int __cdecl _rotr(_In_ unsigned int,_In_ int))
__MACHINECE(_Check_return_ unsigned __int64 __cdecl _rotr64(_In_ unsigned __int64,_In_ int))
__MACHINEIA64(void __rsm(int))
__MACHINEIA64(void __rum(int))
__MACHINE(int __cdecl _setjmp(jmp_buf))
__MACHINEIA64(int __cdecl _setjmpex(jmp_buf))
__MACHINEX64(int __cdecl _setjmpex(jmp_buf))
__MACHINEIA64(void __setReg(int,unsigned __int64))
__MACHINEARMX(void _SmulAdd_SL_ACC(int, int))
__MACHINEARMX(void _SmulAddPack_2SW_ACC(int, int))
__MACHINEARMX(void _SmulAddLo_SW_ACC(int, int))
__MACHINEARMX(void _SmulAddHi_SW_ACC(int, int))
__MACHINEARMX(void _SmulAddHiLo_SW_ACC(int,int))
__MACHINEARMX(void _SmulAddLoHi_SW_ACC(int,int))
__MACHINEIA64(void __store128(void *, __int64, __int64))
__MACHINEIA64(void __store128_rel(void *, __int64, __int64))
__MACHINE(char * __cdecl strcat(_Pre_cap_for_(_Source) _Prepost_z_ char *,_In_z_ const char * _Source))
__MACHINE(_Check_return_ int __cdecl strcmp(_In_z_ const char *,_In_z_ const char *))
__MACHINE(char * __cdecl strcpy(_Pre_cap_for_(_Source) _Post_z_ char *,_In_z_ const char * _Source))
__MACHINE(_Check_return_ size_t __cdecl strlen(_In_z_ const char *))
__MACHINECE(int __cdecl strncmp(const char *,const char *,size_t))
__MACHINECE(char * __cdecl strncpy(char *,const char *,size_t))
__MACHINE(char * __cdecl _strset(_Inout_z_ char *,_In_ int))
__MACHINE(char * __cdecl strset(_Inout_z_ char *,_In_ int))
__MACHINEIA64(void __ssm(int))
__MACHINEIA64(void __sum(int))
__MACHINESA(int __swi(unsigned, ...))
__MACHINEIA64(void __synci(void))
__MACHINEIA64(__int64 __thash(__int64))
__MACHINEIA64(__int64 __ttag(__int64))
__MACHINECE(int __trap(int,...))
__MACHINEI(unsigned __int64 __ull_rshift(unsigned __int64,int))
__MACHINEIA64(unsigned __int64 __UMULH(unsigned __int64 a, unsigned __int64 b))
__MACHINECE(wchar_t * __cdecl wcscat(_Pre_cap_for_(_Source) _Prepost_z_ wchar_t *,_In_z_ const wchar_t * _Source))
__MACHINECE(_Check_return_ int __cdecl wcscmp(_In_z_ const wchar_t *,_In_z_ const wchar_t *))
__MACHINECE(wchar_t * __cdecl wcscpy(_Pre_cap_for_(_Source) _Post_z_ wchar_t *,_In_z_ const wchar_t * _Source))
__MACHINECE(_Check_return_ size_t __cdecl wcslen(_In_z_ const wchar_t *))
__MACHINECE(int __cdecl wcsncmp(const wchar_t *, const wchar_t *,size_t))
__MACHINECE(wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *,size_t))
__MACHINECE(wchar_t * __cdecl _wcsset(_Inout_z_ wchar_t *, wchar_t))
__MACHINECE(void _WriteBarrier(void))
__MACHINESA(void _WriteStatusReg(int,int, int))
__MACHINEI(void * _AddressOfReturnAddress(void))
__MACHINEIA64(void __yield(void))
__MACHINEIA64(void __fci(void*))

__MACHINEX86X_IA64(void  _m_empty(void))
__MACHINEX86X_IA64(__m64 _m_from_int(int))
__MACHINEX86X_IA64(int   _m_to_int(__m64))
__MACHINEX86X_IA64(__m64 _m_packsswb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_packssdw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_packuswb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_punpckhbw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_punpckhwd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_punpckhdq(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_punpcklbw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_punpcklwd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_punpckldq(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddsb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddsw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddusb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_paddusw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubsb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubsw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubusb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psubusw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pmaddwd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pmulhw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pmullw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psllw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psllwi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_pslld(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pslldi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_psllq(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psllqi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_psraw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psrawi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_psrad(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psradi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_psrlw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psrlwi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_psrld(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psrldi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_psrlq(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psrlqi(__m64,int))
__MACHINEX86X_IA64(__m64 _m_pand(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pandn(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_por(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pxor(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pcmpeqb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pcmpeqw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pcmpeqd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pcmpgtb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pcmpgtw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pcmpgtd(__m64,__m64))
__MACHINEX86X_IA64(__m64 _mm_setzero_si64(void))
__MACHINEX86X_IA64(__m64 _mm_set_pi32(int,int))
__MACHINEX86X_IA64(__m64 _mm_set_pi16(short,short,short,short))
__MACHINEX86X_IA64(__m64 _mm_set_pi8(char,char,char,char,char,char,char,char))
__MACHINEX86X_IA64(__m64 _mm_set1_pi32(int))
__MACHINEX86X_IA64(__m64 _mm_set1_pi16(short))
__MACHINEX86X_IA64(__m64 _mm_set1_pi8(char))
__MACHINEX86X_IA64(__m64 _mm_setr_pi32(int,int))
__MACHINEX86X_IA64(__m64 _mm_setr_pi16(short,short,short,short))
__MACHINEX86X_IA64(__m64 _mm_setr_pi8(char,char,char,char,char,char,char,char))
__MACHINEX86X_IA64(int _m_pextrw(__m64,int))
__MACHINEX86X_IA64(__m64 _m_pinsrw(__m64,int,int))
__MACHINEX86X_IA64(__m64 _m_pmaxsw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pmaxub(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pminsw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pminub(__m64,__m64))
__MACHINEX86X_IA64(int _m_pmovmskb(__m64))
__MACHINEX86X_IA64(__m64 _m_pmulhuw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pshufw(__m64,int))
__MACHINEX86X_IA64(void _m_maskmovq(__m64,__m64,char*))
__MACHINEX86X_IA64(__m64 _m_pavgb(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_pavgw(__m64,__m64))
__MACHINEX86X_IA64(__m64 _m_psadbw(__m64,__m64))
__MACHINEIA32(__m64 _m_from_float(float))
__MACHINEIA32(float _m_to_float(__m64))
__MACHINEX86X_X64(__m128 _mm_add_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_add_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_sub_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_sub_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_mul_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_mul_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_div_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_div_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_sqrt_ss(__m128))
__MACHINEX86X_X64(__m128 _mm_sqrt_ps(__m128))
__MACHINEX86X_X64(__m128 _mm_rcp_ss(__m128))
__MACHINEX86X_X64(__m128 _mm_rcp_ps(__m128))
__MACHINEX86X_X64(__m128 _mm_rsqrt_ss(__m128))
__MACHINEX86X_X64(__m128 _mm_rsqrt_ps(__m128))
__MACHINEX86X_X64(__m128 _mm_min_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_min_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_max_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_max_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_and_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_andnot_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_or_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_xor_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpeq_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpeq_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmplt_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmplt_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmple_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmple_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpgt_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpgt_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpge_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpge_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpneq_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpneq_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpnlt_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpnlt_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpnle_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpnle_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpngt_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpngt_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpnge_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpnge_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpord_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpord_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpunord_ss(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_cmpunord_ps(__m128,__m128))
__MACHINEX86X_X64(int _mm_comieq_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_comilt_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_comile_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_comigt_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_comige_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_comineq_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_ucomieq_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_ucomilt_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_ucomile_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_ucomigt_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_ucomige_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_ucomineq_ss(__m128,__m128))
__MACHINEX86X_X64(int _mm_cvt_ss2si(__m128))
__MACHINEIA32(__m64 _mm_cvt_ps2pi(__m128))
__MACHINEX86X_X64(int _mm_cvtt_ss2si(__m128))
__MACHINEIA32(__m64 _mm_cvtt_ps2pi(__m128))
__MACHINEX86X_X64(__m128 _mm_cvt_si2ss(__m128,int))
__MACHINEIA32(__m128 _mm_cvt_pi2ps(__m128,__m64))
__MACHINEX86X_X64(__m128 _mm_shuffle_ps(__m128,__m128,unsigned int))
__MACHINEX86X_X64(__m128 _mm_unpackhi_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_unpacklo_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_loadh_pi(__m128,__m64 const*))
__MACHINEX86X_X64(void _mm_storeh_pi(__m64*,__m128))
__MACHINEX86X_X64(__m128 _mm_loadl_pi(__m128,__m64 const*))
__MACHINEX86X_X64(void _mm_storel_pi(__m64*,__m128))
__MACHINEX86X_X64(int _mm_movemask_ps(__m128))
__MACHINEX86X_X64(__m128 _mm_set_ss(float))
__MACHINEX86X_X64(__m128 _mm_set_ps1(float))
__MACHINEX86X_X64(__m128 _mm_set_ps(float,float,float,float))
__MACHINEX86X_X64(__m128 _mm_setr_ps(float,float,float,float))
__MACHINEX86X_X64(__m128 _mm_setzero_ps(void))
__MACHINEX86X_X64(__m128 _mm_load_ss(float const*))
__MACHINEX86X_X64(__m128 _mm_load_ps1(float const*))
__MACHINEX86X_X64(__m128 _mm_load_ps(float const*))
__MACHINEX86X_X64(__m128 _mm_loadr_ps(float const*))
__MACHINEX86X_X64(__m128 _mm_loadu_ps(float const*))
__MACHINEX86X_X64(__m128 _mm_move_ss(__m128,__m128))
__MACHINEX86X_X64(void _mm_store_ss(float*,__m128))
__MACHINEX86X_X64(void _mm_store_ps1(float*,__m128))
__MACHINEX86X_X64(void _mm_store_ps(float*,__m128))
__MACHINEX86X_X64(void _mm_storer_ps(float*,__m128))
__MACHINEX86X_X64(void _mm_storeu_ps(float*,__m128))
__MACHINEX86X_X64(void _mm_prefetch(char const*,int))
__MACHINEIA32(void _mm_stream_pi(__m64*,__m64))
__MACHINEX86X_X64(void _mm_stream_ps(float*,__m128))
__MACHINEX86X_X64(void _mm_sfence(void))
__MACHINEX86X_X64(unsigned int _mm_getcsr(void))
__MACHINEX86X_X64(void _mm_setcsr(unsigned int))
__MACHINEX86X_X64(__m128 _mm_movelh_ps(__m128,__m128))
__MACHINEX86X_X64(__m128 _mm_movehl_ps(__m128,__m128))
__MACHINEX86X_X64(void  _m_prefetch(void*))
__MACHINEX86X_X64(void  _m_prefetchw(volatile const void*_Source))
__MACHINEIA32(void  _m_femms(void))
__MACHINEIA32(__m64 _m_pavgusb(__m64,__m64))
__MACHINEIA32(__m64 _m_pf2id(__m64))
__MACHINEIA32(__m64 _m_pfacc(__m64,__m64))
__MACHINEIA32(__m64 _m_pfadd(__m64,__m64))
__MACHINEIA32(__m64 _m_pfcmpeq(__m64,__m64))
__MACHINEIA32(__m64 _m_pfcmpge(__m64,__m64))
__MACHINEIA32(__m64 _m_pfcmpgt(__m64,__m64))
__MACHINEIA32(__m64 _m_pfmax(__m64,__m64))
__MACHINEIA32(__m64 _m_pfmin(__m64,__m64))
__MACHINEIA32(__m64 _m_pfmul(__m64,__m64))
__MACHINEIA32(__m64 _m_pfrcp(__m64))
__MACHINEIA32(__m64 _m_pfrcpit1(__m64,__m64))
__MACHINEIA32(__m64 _m_pfrcpit2(__m64,__m64))
__MACHINEIA32(__m64 _m_pfrsqrt(__m64))
__MACHINEIA32(__m64 _m_pfrsqit1(__m64,__m64))
__MACHINEIA32(__m64 _m_pfsub(__m64,__m64))
__MACHINEIA32(__m64 _m_pfsubr(__m64,__m64))
__MACHINEIA32(__m64 _m_pi2fd(__m64))
__MACHINEIA32(__m64 _m_pmulhrw(__m64,__m64))
__MACHINEIA32(__m64 _m_pf2iw(__m64))
__MACHINEIA32(__m64 _m_pfnacc(__m64,__m64))
__MACHINEIA32(__m64 _m_pfpnacc(__m64,__m64))
__MACHINEIA32(__m64 _m_pi2fw(__m64))
__MACHINEIA32(__m64 _m_pswapd(__m64))
__MACHINEX86X_X64(__m128d _mm_add_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_add_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_div_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_div_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_max_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_max_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_min_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_min_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_mul_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_mul_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_sqrt_sd(__m128d, __m128d))
__MACHINEX86X_X64(__m128d _mm_sqrt_pd(__m128d))
__MACHINEX86X_X64(__m128d _mm_sub_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_sub_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_and_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_andnot_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_or_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_xor_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpeq_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpeq_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmplt_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmplt_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmple_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmple_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpgt_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpgt_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpge_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpge_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpneq_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpneq_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpnlt_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpnlt_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpnle_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpnle_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpngt_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpngt_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpnge_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpnge_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpord_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpord_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpunord_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_cmpunord_pd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_comieq_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_comilt_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_comile_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_comigt_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_comige_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_comineq_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_ucomieq_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_ucomilt_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_ucomile_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_ucomigt_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_ucomige_sd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_ucomineq_sd(__m128d,__m128d))
__MACHINEX86X_X64(__m128 _mm_cvtpd_ps(__m128d))
__MACHINEX86X_X64(__m128d _mm_cvtps_pd(__m128))
__MACHINEX86X_X64(__m128d _mm_cvtepi32_pd(__m128i))
__MACHINEX86X_X64(__m128i _mm_cvtpd_epi32(__m128d))
__MACHINEX86X_X64(int _mm_cvtsd_si32(__m128d))
__MACHINEX86X_X64(__m128 _mm_cvtsd_ss(__m128,__m128d))
__MACHINEX86X_X64(__m128d _mm_cvtsi32_sd(__m128d,int))
__MACHINEX86X_X64(__m128d _mm_cvtss_sd(__m128d,__m128))
__MACHINEX86X_X64(__m128i _mm_cvttpd_epi32(__m128d))
__MACHINEX86X_X64(int _mm_cvttsd_si32(__m128d))
__MACHINEX86X_X64(__m128 _mm_cvtepi32_ps(__m128i))
__MACHINEX86X_X64(__m128i _mm_cvtps_epi32(__m128))
__MACHINEX86X_X64(__m128i _mm_cvttps_epi32(__m128))
__MACHINEX86X_IA64(__m64 _mm_cvtpd_pi32(__m128d))
__MACHINEX86X_IA64(__m64 _mm_cvttpd_pi32(__m128d))
__MACHINEX86X_IA64(__m128d _mm_cvtpi32_pd(__m64))
__MACHINEX86X_X64(__m128d _mm_unpackhi_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128d _mm_unpacklo_pd(__m128d,__m128d))
__MACHINEX86X_X64(int _mm_movemask_pd(__m128d))
__MACHINEX86X_X64(__m128d _mm_shuffle_pd(__m128d,__m128d,int))
__MACHINEX86X_X64(__m128d _mm_load_pd(double const*))
__MACHINEX86X_X64(__m128d _mm_load1_pd(double const*))
__MACHINEX86X_X64(__m128d _mm_loadr_pd(double const*))
__MACHINEX86X_X64(__m128d _mm_loadu_pd(double const*))
__MACHINEX86X_X64(__m128d _mm_load_sd(double const*))
__MACHINEX86X_X64(__m128d _mm_loadh_pd(__m128d,double const*))
__MACHINEX86X_X64(__m128d _mm_loadl_pd(__m128d,double const*))
__MACHINEX86X_X64(__m128d _mm_set_sd(double))
__MACHINEX86X_X64(__m128d _mm_set1_pd(double))
__MACHINEX86X_X64(__m128d _mm_set_pd(double,double))
__MACHINEX86X_X64(__m128d _mm_setr_pd(double,double))
__MACHINEX86X_X64(__m128d _mm_setzero_pd(void))
__MACHINEX86X_X64(__m128d _mm_move_sd(__m128d,__m128d))
__MACHINEX86X_X64(void _mm_store_sd(double*,__m128d))
__MACHINEX86X_X64(void _mm_store1_pd(double*,__m128d))
__MACHINEX86X_X64(void _mm_store_pd(double*,__m128d))
__MACHINEX86X_X64(void _mm_storeu_pd(double*,__m128d))
__MACHINEX86X_X64(void _mm_storer_pd(double*,__m128d))
__MACHINEX86X_X64(void _mm_storeh_pd(double*,__m128d))
__MACHINEX86X_X64(void _mm_storel_pd(double*,__m128d))
__MACHINEX86X_X64(__m128i _mm_add_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_add_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_add_epi32(__m128i,__m128i))
__MACHINEX86X_IA64(__m64 _mm_add_si64(__m64,__m64))
__MACHINEX86X_X64(__m128i _mm_add_epi64(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_adds_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_adds_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_adds_epu8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_adds_epu16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_avg_epu8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_avg_epu16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_madd_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_max_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_max_epu8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_min_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_min_epu8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_mulhi_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_mulhi_epu16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_mullo_epi16(__m128i,__m128i))
__MACHINEX86X_IA64(__m64 _mm_mul_su32(__m64,__m64))
__MACHINEX86X_X64(__m128i _mm_mul_epu32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_sad_epu8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_sub_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_sub_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_sub_epi32(__m128i,__m128i))
__MACHINEX86X_IA64(__m64 _mm_sub_si64(__m64,__m64))
__MACHINEX86X_X64(__m128i _mm_sub_epi64(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_subs_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_subs_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_subs_epu8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_subs_epu16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_andnot_si128(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_and_si128(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_or_si128(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_xor_si128(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_slli_si128(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_slli_epi16(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_sll_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_slli_epi32(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_sll_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_slli_epi64(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_sll_epi64(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_srai_epi16(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_sra_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_srai_epi32(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_sra_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_srli_si128(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_srli_epi16(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_srl_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_srli_epi32(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_srl_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_srli_epi64(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_srl_epi64(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmpeq_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmpeq_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmpeq_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmpgt_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmpgt_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmpgt_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmplt_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmplt_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cmplt_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_cvtsi32_si128(int))
__MACHINEX86X_X64(int _mm_cvtsi128_si32(__m128i))
__MACHINEX86X_X64(__m128i _mm_packs_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_packs_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_packus_epi16(__m128i,__m128i))
__MACHINEX86X_X64(int _mm_extract_epi16(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_insert_epi16(__m128i,int,int))
__MACHINEX86X_X64(int _mm_movemask_epi8(__m128i))
__MACHINEX86X_X64(__m128i _mm_shuffle_epi32(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_shufflehi_epi16(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_shufflelo_epi16(__m128i,int))
__MACHINEX86X_X64(__m128i _mm_unpackhi_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpackhi_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpackhi_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpackhi_epi64(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpacklo_epi8(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpacklo_epi16(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpacklo_epi32(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_unpacklo_epi64(__m128i,__m128i))
__MACHINEX86X_X64(__m128i _mm_load_si128(__m128i const*))
__MACHINEX86X_X64(__m128i _mm_loadu_si128(__m128i const*))
__MACHINEX86X_X64(__m128i _mm_loadl_epi64(__m128i const*))
__MACHINEX86X_IA64(__m128i _mm_set_epi64(__m64,__m64))
__MACHINEX86X_X64(__m128i _mm_set_epi32(int,int,int,int))
__MACHINEX86X_X64(__m128i _mm_set_epi16(short,short,short,short,short,short,short,short))
__MACHINEX86X_X64(__m128i _mm_set_epi8(char,char,char,char,char,char,char,char,char,char,char,char,char,char,char,char))
__MACHINEX86X_IA64(__m128i _mm_set1_epi64(__m64))
__MACHINEX86X_X64(__m128i _mm_set1_epi32(int))
__MACHINEX86X_X64(__m128i _mm_set1_epi16(short))
__MACHINEX86X_X64(__m128i _mm_set1_epi8(char))
__MACHINEX86X_X64(__m128i _mm_setl_epi64(__m128i))
__MACHINEX86X_IA64(__m128i _mm_setr_epi64(__m64,__m64))
__MACHINEX86X_X64(__m128i _mm_setr_epi32(int,int,int,int))
__MACHINEX86X_X64(__m128i _mm_setr_epi16(short,short,short,short,short,short,short,short))
__MACHINEX86X_X64(__m128i _mm_setr_epi8(char,char,char,char,char,char,char,char,char,char,char,char,char,char,char,char))
__MACHINEX86X_X64(__m128i _mm_setzero_si128(void))
__MACHINEX86X_X64(void _mm_store_si128(__m128i*,__m128i))
__MACHINEX86X_X64(void _mm_storeu_si128(__m128i*,__m128i))
__MACHINEX86X_X64(void _mm_storel_epi64(__m128i*,__m128i))
__MACHINEX86X_X64(void _mm_maskmoveu_si128(__m128i,__m128i,char*))
__MACHINEX86X_X64(__m128i _mm_move_epi64(__m128i))
__MACHINEX86X_IA64(__m128i _mm_movpi64_epi64(__m64))
__MACHINEX86X_IA64(__m64 _mm_movepi64_pi64(__m128i))
__MACHINEX86X_X64(void _mm_stream_pd(double*,__m128d))
__MACHINEX86X_X64(void _mm_stream_si128(__m128i*,__m128i))
__MACHINEX86X_X64(void _mm_clflush(void const *))
__MACHINEX86X_X64(void _mm_lfence(void))
__MACHINEX86X_X64(void _mm_mfence(void))
__MACHINEX86X_X64(void _mm_stream_si32(int*,int))
__MACHINEX86X_X64(void _mm_pause(void))
__MACHINEX86X_X64(__m128 _mm_addsub_ps(__m128,__m128))
__MACHINEX86X_X64(__m128d _mm_addsub_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128 _mm_hadd_ps(__m128,__m128))
__MACHINEX86X_X64(__m128d _mm_hadd_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128 _mm_hsub_ps(__m128,__m128))
__MACHINEX86X_X64(__m128d _mm_hsub_pd(__m128d,__m128d))
__MACHINEX86X_X64(__m128i _mm_lddqu_si128(__m128i const*))
__MACHINEX86X_X64(void _mm_monitor(void const*,unsigned int,unsigned int))
__MACHINEX86X_X64(__m128d _mm_movedup_pd(__m128d))
__MACHINEX86X_X64(__m128d _mm_loaddup_pd(double const*))
__MACHINEX86X_X64(__m128 _mm_movehdup_ps(__m128))
__MACHINEX86X_X64(__m128 _mm_moveldup_ps(__m128))
__MACHINEX86X_X64(void _mm_mwait(unsigned int,unsigned int))
__MACHINEX86X_X64(__m128i _mm_hadd_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_hadd_epi32 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_hadds_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m64 _mm_hadd_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m64 _mm_hadd_pi32 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m64 _mm_hadds_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m128i _mm_hsub_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_hsub_epi32 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_hsubs_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m64 _mm_hsub_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m64 _mm_hsub_pi32 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m64 _mm_hsubs_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m128i _mm_maddubs_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m64 _mm_maddubs_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m128i _mm_mulhrs_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m64 _mm_mulhrs_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m128i _mm_shuffle_epi8 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m64 _mm_shuffle_pi8 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m128i _mm_sign_epi8 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_sign_epi16 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_sign_epi32 (__m128i a, __m128i b))
__MACHINEX86X_X64(__m64 _mm_sign_pi8 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m64 _mm_sign_pi16 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m64 _mm_sign_pi32 (__m64 a, __m64 b))
__MACHINEX86X_X64(__m128i _mm_alignr_epi8 (__m128i a, __m128i b, int n))
__MACHINEX86X_X64(__m64 _mm_alignr_pi8 (__m64 a, __m64 b, int n))
__MACHINEX86X_X64(__m128i _mm_abs_epi8 (__m128i a))
__MACHINEX86X_X64(__m128i _mm_abs_epi16 (__m128i a))
__MACHINEX86X_X64(__m128i _mm_abs_epi32 (__m128i a))
__MACHINEX86X_X64(__m64 _mm_abs_pi8 (__m64 a))
__MACHINEX86X_X64(__m64 _mm_abs_pi16 (__m64 a))
__MACHINEX86X_X64(__m64 _mm_abs_pi32 (__m64 a))
__MACHINEX64(__int64 _mm_cvtss_si64(__m128 _A))
__MACHINEX64(__int64 _mm_cvttss_si64(__m128 _A))
__MACHINEX64(__m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B))
__MACHINEX64(__int64 _mm_cvtsd_si64(__m128d))
__MACHINEX64(__int64 _mm_cvttsd_si64(__m128d))
__MACHINEX64(__m128d _mm_cvtsi64_sd(__m128d, __int64))
__MACHINEX64(__m128i _mm_cvtsi64_si128(__int64))
__MACHINEX64(__int64 _mm_cvtsi128_si64(__m128i))
__MACHINEX86X_X64(__m128i _mm_blend_epi16 (__m128i v1, __m128i v2, const int mask))
__MACHINEX86X_X64(__m128i _mm_blendv_epi8 (__m128i v1, __m128i v2, __m128i mask))
__MACHINEX86X_X64(__m128  _mm_blend_ps (__m128  v1, __m128  v2, const int mask))
__MACHINEX86X_X64(__m128  _mm_blendv_ps(__m128  v1, __m128  v2, __m128 v3))
__MACHINEX86X_X64(__m128d _mm_blend_pd (__m128d v1, __m128d v2, const int mask))
__MACHINEX86X_X64(__m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3))
__MACHINEX86X_X64(__m128  _mm_dp_ps(__m128  val1, __m128  val2, const int mask))
__MACHINEX86X_X64(__m128d _mm_dp_pd(__m128d val1, __m128d val2, const int mask))
__MACHINEX86X_X64(__m128i _mm_cmpeq_epi64(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_min_epi8 (__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_max_epi8 (__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_min_epu16(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_max_epu16(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_min_epi32(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_max_epi32(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_min_epu32(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_max_epu32(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_mullo_epi32(__m128i a, __m128i b))
__MACHINEX86X_X64(__m128i _mm_mul_epi32(__m128i a, __m128i b))
__MACHINEX86X_X64(int _mm_testz_si128(__m128i mask, __m128i val))
__MACHINEX86X_X64(int _mm_testc_si128(__m128i mask, __m128i val))
__MACHINEX86X_X64(int _mm_testnzc_si128(__m128i mask, __m128i s2))
__MACHINEX86X_X64(__m128 _mm_insert_ps(__m128 dst, __m128 src, const int ndx))
__MACHINEX86X_X64(int _mm_extract_ps(__m128 src, const int ndx))
__MACHINEX86X_X64(__m128i _mm_insert_epi8 (__m128i dst, int s, const int ndx))
__MACHINEX86X_X64(__m128i _mm_insert_epi32(__m128i dst, int s, const int ndx))
__MACHINEX86X_X64(int   _mm_extract_epi8 (__m128i src, const int ndx))
__MACHINEX86X_X64(int   _mm_extract_epi32(__m128i src, const int ndx))
__MACHINEX86X_X64(__m128i _mm_minpos_epu16(__m128i shortValues))
__MACHINEX86X_X64(__m128d _mm_round_pd(__m128d val, int iRoundMode))
__MACHINEX86X_X64(__m128d _mm_round_sd(__m128d dst, __m128d val, int iRoundMode))
__MACHINEX86X_X64(__m128  _mm_round_ps(__m128  val, int iRoundMode))
__MACHINEX86X_X64(__m128  _mm_round_ss(__m128 dst, __m128  val, int iRoundMode))
__MACHINEX86X_X64(__m128i _mm_cvtepi8_epi32 (__m128i byteValues))
__MACHINEX86X_X64(__m128i _mm_cvtepi16_epi32(__m128i shortValues))
__MACHINEX86X_X64(__m128i _mm_cvtepi8_epi64 (__m128i byteValues))
__MACHINEX86X_X64(__m128i _mm_cvtepi32_epi64(__m128i intValues))
__MACHINEX86X_X64(__m128i _mm_cvtepi16_epi64(__m128i shortValues))
__MACHINEX86X_X64(__m128i _mm_cvtepi8_epi16 (__m128i byteValues))
__MACHINEX86X_X64(__m128i _mm_cvtepu8_epi32 (__m128i byteValues))
__MACHINEX86X_X64(__m128i _mm_cvtepu16_epi32(__m128i shortValues))
__MACHINEX86X_X64(__m128i _mm_cvtepu8_epi64 (__m128i shortValues))
__MACHINEX86X_X64(__m128i _mm_cvtepu32_epi64(__m128i intValues))
__MACHINEX86X_X64(__m128i _mm_cvtepu16_epi64(__m128i shortValues))
__MACHINEX86X_X64(__m128i _mm_cvtepu8_epi16 (__m128i byteValues))
__MACHINEX86X_X64(__m128i _mm_packus_epi32(__m128i val1, __m128i val2))
__MACHINEX86X_X64(__m128i _mm_mpsadbw_epu8(__m128i s1, __m128i s2, const int msk))
__MACHINEX86X_X64(__m128i _mm_stream_load_si128(__m128i* v1))
__MACHINEX64(__m128i _mm_insert_epi64(__m128i dst, __int64 s, const int ndx))
__MACHINEX64(__int64 _mm_extract_epi64(__m128i src, const int ndx))
__MACHINEX86X_X64(__m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(int     _mm_cmpistri (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(__m128i _mm_cmpestrm (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(int     _mm_cmpestri (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(int     _mm_cmpistrz (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(int     _mm_cmpistrc (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(int     _mm_cmpistrs (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(int     _mm_cmpistro (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(int     _mm_cmpistra (__m128i a, __m128i b, const int mode))
__MACHINEX86X_X64(int     _mm_cmpestrz (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(int     _mm_cmpestrc (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(int     _mm_cmpestrs (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(int     _mm_cmpestro (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(int     _mm_cmpestra (__m128i a, int la, __m128i b, int lb, const int mode))
__MACHINEX86X_X64(__m128i _mm_cmpgt_epi64(__m128i val1, __m128i val2))
__MACHINEX86X_X64(int _mm_popcnt_u32(unsigned int v))
__MACHINEX64(__int64 _mm_popcnt_u64(unsigned __int64 v))
__MACHINEX86X_X64(unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v))
__MACHINEX86X_X64(unsigned int _mm_crc32_u16(unsigned int crc, unsigned short v))
__MACHINEX86X_X64(unsigned int _mm_crc32_u32(unsigned int crc, unsigned int v))
__MACHINEX64(unsigned __int64 _mm_crc32_u64(unsigned __int64 crc, unsigned __int64 v))
__MACHINEI(void _WriteBarrier(void))
__MACHINEI(void _ReadWriteBarrier(void))
__MACHINEIA64(void _WriteBarrier(void))
__MACHINEIA64(void _ReadWriteBarrier(void))
__MACHINEX64(void __faststorefence(void))
__MACHINEX64(__int64 __mulh(__int64,__int64))
__MACHINEX64(unsigned __int64 __umulh(unsigned __int64,unsigned __int64))
__MACHINEX64(unsigned __int64 __readcr0(void))
__MACHINEX64(unsigned __int64 __readcr2(void))
__MACHINEX64(unsigned __int64 __readcr3(void))
__MACHINEX64(unsigned __int64 __readcr4(void))
__MACHINEX64(unsigned __int64 __readcr8(void))
__MACHINEIA32(unsigned long __readcr0(void))
__MACHINEIA32(unsigned long __readcr2(void))
__MACHINEIA32(unsigned long __readcr3(void))
__MACHINEIA32(unsigned long __readcr4(void))
__MACHINEIA32(unsigned long __readcr8(void))
__MACHINEX64(void __writecr0(unsigned __int64))
__MACHINEX64(void __writecr3(unsigned __int64))
__MACHINEX64(void __writecr4(unsigned __int64))
__MACHINEX64(void __writecr8(unsigned __int64))
__MACHINEIA32(void __writecr0(unsigned))
__MACHINEIA32(void __writecr3(unsigned))
__MACHINEIA32(void __writecr4(unsigned))
__MACHINEIA32(void __writecr8(unsigned))
__MACHINEX64(unsigned __int64 __readdr(unsigned int))
__MACHINEIA32(unsigned __readdr(unsigned int))
__MACHINEX64(void __writedr(unsigned int, unsigned __int64))
__MACHINEIA32(void __writedr(unsigned int, unsigned))
__MACHINEX64(unsigned __int64 __readeflags(void))
__MACHINEIA32(unsigned __readeflags(void))
__MACHINEX64(void __writeeflags(unsigned __int64))
__MACHINEIA32(void __writeeflags(unsigned))
__MACHINEI(void __wbinvd(void))
__MACHINEI(void __invlpg(void*))
__MACHINEI(unsigned __int64 __readmsr(unsigned long))
__MACHINEI(void __writemsr(unsigned long, unsigned __int64))
__MACHINEI(unsigned __int64 __rdtsc(void))
__MACHINEI(void __movsb(unsigned char *, unsigned char const *, size_t))
__MACHINEI(void __movsw(unsigned short *, unsigned short const *, size_t))
__MACHINEI(void __movsd(unsigned long *, unsigned long const *, size_t))
__MACHINEX64(void __movsq(unsigned long long *, unsigned long long const *, size_t))
__MACHINEX64(unsigned char __readgsbyte(unsigned long Offset))
__MACHINEX64(unsigned short __readgsword(unsigned long Offset))
__MACHINEX64(unsigned long __readgsdword(unsigned long Offset))
__MACHINEX64(unsigned __int64 __readgsqword(unsigned long Offset))
__MACHINEX64(void __writegsbyte(unsigned long Offset, unsigned char Data))
__MACHINEX64(void __writegsword(unsigned long Offset, unsigned short Data))
__MACHINEX64(void __writegsdword(unsigned long Offset, unsigned long Data))
__MACHINEX64(void __writegsqword(unsigned long Offset, unsigned __int64 Data))
__MACHINEI(unsigned char __inbyte(unsigned short Port))
__MACHINEI(unsigned short __inword(unsigned short Port))
__MACHINEI(unsigned long __indword(unsigned short Port))
__MACHINEI(void __outbyte(unsigned short Port, unsigned char Data))
__MACHINEI(void __outword(unsigned short Port, unsigned short Data))
__MACHINEI(void __outdword(unsigned short Port, unsigned long Data))
__MACHINEI(void __inbytestring(unsigned short Port, unsigned char *Buffer, unsigned long Count))
__MACHINEI(void __inwordstring(unsigned short Port, unsigned short *Buffer, unsigned long Count))
__MACHINEI(void __indwordstring(unsigned short Port, unsigned long *Buffer, unsigned long Count))
__MACHINEI(void __outbytestring(unsigned short Port, unsigned char *Buffer, unsigned long Count))
__MACHINEI(void __outwordstring(unsigned short Port, unsigned short *Buffer, unsigned long Count))
__MACHINEI(void __outdwordstring(unsigned short Port, unsigned long *Buffer, unsigned long Count))
__MACHINEI(unsigned int __getcallerseflags())
__MACHINEX64(unsigned char __vmx_vmclear(unsigned __int64*))
__MACHINEX64(unsigned char __vmx_vmlaunch(void))
__MACHINEX64(unsigned char __vmx_vmptrld(unsigned __int64*))
__MACHINEI(void __vmx_vmptrst(unsigned __int64 *))
__MACHINEX64(unsigned char __vmx_vmread(size_t, size_t*))
__MACHINEX64(unsigned char __vmx_vmresume(void))
__MACHINEX64(unsigned char __vmx_vmwrite(size_t, size_t))
__MACHINEI(void __vmx_off(void))
__MACHINEX64(unsigned char __vmx_on(unsigned __int64*))
__MACHINEI(void __svm_clgi(void))
__MACHINEI(void __svm_invlpga(void*, int))
__MACHINEI(void __svm_skinit(int))
__MACHINEI(void __svm_stgi(void))
__MACHINEI(void __svm_vmload(size_t))
__MACHINEI(void __svm_vmrun(size_t))
__MACHINEI(void __svm_vmsave(size_t))
__MACHINEI(void __halt(void))
__MACHINEI(void __sidt(void*))
__MACHINEI(void __lidt(void*))
__MACHINEI(void __ud2(void))
__MACHINEI(void __nop(void))
__MACHINEX64(__m128i _mm_set_epi64x(__int64 i1, __int64 i0))
__MACHINEX64(__m128i _mm_set1_epi64x(__int64 i))
__MACHINEX64(__int64 _mm_cvtsd_si64x(__m128d a))
__MACHINEX64(__m128d _mm_cvtsi64x_sd(__m128d a, __int64 b))
__MACHINEX64(__m128 _mm_cvtsi64x_ss(__m128 a, __int64 b))
__MACHINEX64(__int64 _mm_cvtss_si64x(__m128 a))
__MACHINEX64(__int64 _mm_cvttsd_si64x(__m128d a))
__MACHINEX64(__int64 _mm_cvttss_si64x(__m128 a))
__MACHINEX64(__m128i _mm_cvtsi64x_si128(__int64 a))
__MACHINEX64(__int64 _mm_cvtsi128_si64x(__m128i a))
__MACHINEX64(void _mm_stream_si64x(__int64 *,__int64))
__MACHINEI(void __stosb(unsigned char *, unsigned char, size_t))
__MACHINEI(void __stosw(unsigned short *,  unsigned short, size_t))
__MACHINEI(void __stosd(unsigned long *,  unsigned long, size_t))
__MACHINEX64(void __stosq(unsigned __int64 *,  unsigned __int64, size_t))
__MACHINEIW64(unsigned char _bittest(long const *a, long b))
__MACHINEIW64(unsigned char _bittestandset(long *a, long b))
__MACHINEIW64(unsigned char _bittestandreset(long *a, long b))
__MACHINEIW64(unsigned char _bittestandcomplement(long *a, long b))
__MACHINEI(unsigned char _interlockedbittestandset(long volatile *a, long b))
__MACHINEI(unsigned char _interlockedbittestandreset(long volatile *a, long b))
__MACHINEW64(unsigned char _bittest64(__int64 const *a, __int64 b))
__MACHINEW64(unsigned char _bittestandset64(__int64 *a, __int64 b))
__MACHINEW64(unsigned char _bittestandreset64(__int64 *a, __int64 b))
__MACHINEW64(unsigned char _bittestandcomplement64(__int64 *a, __int64 b))
__MACHINEX64(unsigned char _interlockedbittestandset64(__int64 volatile *a, __int64 b))
__MACHINEX64(unsigned char _interlockedbittestandreset64(__int64 volatile *a, __int64 b))
__MACHINEI(void __cpuid(int a[4], int b))
__MACHINEI(unsigned __int64 __readpmc(unsigned long a))
__MACHINEI(unsigned long __segmentlimit(unsigned long a))

__MACHINEIA32(unsigned char __readfsbyte(unsigned long Offset))
__MACHINEIA32(unsigned short __readfsword(unsigned long Offset))
__MACHINEIA32(unsigned long __readfsdword(unsigned long Offset))
__MACHINEIA32(unsigned __int64 __readfsqword(unsigned long Offset))
__MACHINEIA32(void __writefsbyte(unsigned long Offset, unsigned char Data))
__MACHINEIA32(void __writefsword(unsigned long Offset, unsigned short Data))
__MACHINEIA32(void __writefsdword(unsigned long Offset, unsigned long Data))
__MACHINEIA32(void __writefsqword(unsigned long Offset, unsigned __int64 Data))


__MACHINE(_Check_return_ unsigned __int64 __cdecl _rotl64(_In_ unsigned __int64,_In_ int))
__MACHINE(_Check_return_ unsigned __int64 __cdecl _rotr64(_In_ unsigned __int64,_In_ int))
__MACHINE(__int64 __cdecl _abs64(__int64))

__MACHINEIW64(unsigned char _BitScanForward(unsigned long* Index, unsigned long Mask))
__MACHINEIW64(unsigned char _BitScanReverse(unsigned long* Index, unsigned long Mask))
__MACHINEW64(unsigned char _BitScanForward64(unsigned long* Index, unsigned __int64 Mask))
__MACHINEW64(unsigned char _BitScanReverse64(unsigned long* Index, unsigned __int64 Mask))
__MACHINEIW64(_CRTIMP wchar_t * __cdecl wcscat( _Pre_cap_for_(_Source) _Prepost_z_ wchar_t *, _In_z_ const wchar_t * _Source))
__MACHINEIW64(_Check_return_ _CRTIMP int __cdecl wcscmp(_In_z_ const wchar_t *,_In_z_  const wchar_t *))
__MACHINEIW64(_CRTIMP wchar_t * __cdecl wcscpy(_Pre_cap_for_(_Source) _Post_z_ wchar_t *, _In_z_ const wchar_t * _Source))
__MACHINEIW64(_Check_return_ _CRTIMP size_t __cdecl wcslen(_In_z_ const wchar_t *))
#pragma warning(suppress: 4985)
__MACHINEIW64(_CRTIMP wchar_t * __cdecl _wcsset(_Inout_z_ wchar_t *, wchar_t))
__MACHINEW64(unsigned __int64 __shiftleft128(unsigned __int64 LowPart, unsigned __int64 HighPart, unsigned char Shift))
__MACHINEW64(unsigned __int64 __shiftright128(unsigned __int64 LowPart, unsigned __int64 HighPart, unsigned char Shift))
__MACHINEW64(unsigned __int64 _umul128(unsigned __int64 multiplier, unsigned __int64 multiplicand, unsigned __int64 *highproduct))
__MACHINEW64(__int64 _mul128(__int64 multiplier, __int64 multiplicand, __int64 *highproduct))
__MACHINEI(void __int2c(void))
__MACHINEIW64(void _ReadBarrier(void))
__MACHINEIW64(unsigned char _rotr8(unsigned char value, unsigned char shift))
__MACHINEIW64(unsigned short _rotr16(unsigned short value, unsigned char shift))
__MACHINEIW64(unsigned char _rotl8(unsigned char value, unsigned char shift))
__MACHINEIW64(unsigned short _rotl16(unsigned short value, unsigned char shift))
__MACHINEIW64(short _InterlockedIncrement16(short volatile *Addend))
__MACHINEIW64(short _InterlockedDecrement16(short volatile *Addend))
__MACHINEIW64(short _InterlockedCompareExchange16(short volatile *Destination, short Exchange, short Comparand))
__MACHINEIA64(short _InterlockedIncrement16_acq(short volatile *Addend))
__MACHINEIA64(short _InterlockedIncrement16_rel(short volatile *Addend))
__MACHINEIA64(short _InterlockedDecrement16_acq(short volatile *Addend))
__MACHINEIA64(short _InterlockedDecrement16_rel(short volatile *Addend))
__MACHINEIA64(short _InterlockedCompareExchange16_acq(short volatile *Destination, short Exchange, short Comparand))
__MACHINEIA64(short _InterlockedCompareExchange16_rel(short volatile *Destination, short Exchange, short Comparand))
__MACHINECC(unsigned __int64 _m_paddb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddsb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddsw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddsd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddusb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddusw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paddusd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubsb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubsw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubsd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubusb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubusw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psubusd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmaddwd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmadduwd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmulhw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmulhuw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmullw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmullw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmacsw(unsigned __int64 m1, unsigned __int64 m2, unsigned __int64 m3))
__MACHINECC(unsigned __int64 _m_pmacuw(unsigned __int64 m1, unsigned __int64 m2, unsigned __int64 m3))
__MACHINECC(unsigned __int64 _m_pmacszw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_padduzw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paccb(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_paccw(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_paccd(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_pmia(unsigned __int64 m1, int i1, int i0))
__MACHINECC(unsigned __int64 _m_pmiaph(unsigned __int64 m1, int i1, int i0))
__MACHINECC(unsigned __int64 _m_pmiabb(unsigned __int64 m1, int i1, int i0))
__MACHINECC(unsigned __int64 _m_pmiabt(unsigned __int64 m1, int i1, int i0))
__MACHINECC(unsigned __int64 _m_pmiatb(unsigned __int64 m1, int i1, int i0))
__MACHINECC(unsigned __int64 _m_pmiatt(unsigned __int64 m1, int i1, int i0))
__MACHINECC(unsigned __int64 _m_psllw(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psllwi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_pslld(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_pslldi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psllq(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psllqi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psraw(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psrawi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psrad(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psradi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psraq(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psraqi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psrlw(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psrlwi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psrld(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psrldi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_psrlq(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_psrlqi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_prorw(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_prorwi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_prord(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_prordi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_prorq(unsigned __int64 m1, unsigned __int64 count))
__MACHINECC(unsigned __int64 _m_prorqi(unsigned __int64 m1, int count))
__MACHINECC(unsigned __int64 _m_pand(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pandn(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_por(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pxor(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpeqb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpeqw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpeqd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpgtb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpgtub(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpgtw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpgtuw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpgtd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pcmpgtud(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_packsswb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_packssdw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_packssqd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_packuswb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_packusdw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_packusqd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpckhbw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpckhwd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpckhdq(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpcklbw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpcklwd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpckldq(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_punpckehsbw(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckehswd(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckehsdq(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckehubw(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckehuwd(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckehudq(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckelsbw(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckelswd(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckelsdq(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckelubw(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckeluwd(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_punpckeludq(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _mm_setzero_si64())
__MACHINECC(unsigned __int64 _mm_set_pi32(int i1, int i0))
__MACHINECC(unsigned __int64 _mm_set_pi16(short s3, short s2, short s1, short s0))
__MACHINECC(unsigned __int64 _mm_set_pi8(char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0))
__MACHINECC(unsigned __int64 _mm_set1_pi32(int i))
__MACHINECC(unsigned __int64 _mm_set1_pi16(short s))
__MACHINECC(unsigned __int64 _mm_set1_pi8(char b))
__MACHINECC(unsigned __int64 _mm_setr_pi32(int i1, int i0))
__MACHINECC(unsigned __int64 _mm_setr_pi16(short s3, short s2, short s1, short s0))
__MACHINECC(unsigned __int64 _mm_setr_pi8(char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0))
__MACHINECC(void  _mm_setwcx(int i1, int i0))
__MACHINECC(int   _mm_getwcx(int i))
__MACHINECC(int _m_pextrb(unsigned __int64 m1, const int c))
__MACHINECC(int _m_pextrw(unsigned __int64 m1, const int c))
__MACHINECC(int _m_pextrd(unsigned __int64 m1, const int c))
__MACHINECC(unsigned int _m_pextrub(unsigned __int64 m1, const int c))
__MACHINECC(unsigned int _m_pextruw(unsigned __int64 m1, const int c))
__MACHINECC(unsigned int _m_pextrud(unsigned __int64 m1, const int c))
__MACHINECC(unsigned __int64 _m_pinsrb(unsigned __int64 m1, int i, const int c))
__MACHINECC(unsigned __int64 _m_pinsrw(unsigned __int64 m1, int i, const int c))
__MACHINECC(unsigned __int64 _m_pinsrd(unsigned __int64 m1, int i, const int c))
__MACHINECC(unsigned __int64 _m_pmaxsb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmaxsw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmaxsd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmaxub(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmaxuw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pmaxud(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pminsb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pminsw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pminsd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pminub(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pminuw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pminud(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(int   _m_pmovmskb(unsigned __int64 m1))
__MACHINECC(int   _m_pmovmskw(unsigned __int64 m1))
__MACHINECC(int   _m_pmovmskd(unsigned __int64 m1))
__MACHINECC(unsigned __int64 _m_pshufw(unsigned __int64 m1, int i))
__MACHINECC(unsigned __int64 _m_pavgb(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pavgw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pavg2b(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_pavg2w(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psadbw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psadwd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psadzbw(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_psadzwd(unsigned __int64 m1, unsigned __int64 m2))
__MACHINECC(unsigned __int64 _m_paligniq(unsigned __int64 m1, unsigned __int64 m2, int i))
__MACHINECC(unsigned __int64 _m_cvt_si2pi(__int64 i))
__MACHINECC(__int64 _m_cvt_pi2si(unsigned __int64 m1))
__MACHINEIW64(void __nvreg_save_fence(void))
__MACHINEIW64(void __nvreg_restore_fence(void))

__MACHINEX64(short _InterlockedCompareExchange16_np(short volatile *Destination, short Exchange, short Comparand))
__MACHINEX64(long _InterlockedCompareExchange_np (long *, long, long))
__MACHINEX64(__int64 _InterlockedCompareExchange64_np(__int64 *, __int64, __int64))
__MACHINEX64(void *_InterlockedCompareExchangePointer_np (void **, void *, void *))
__MACHINEX64(unsigned char _InterlockedCompareExchange128(__int64 volatile *, __int64, __int64, __int64 *))
__MACHINEX64(unsigned char _InterlockedCompareExchange128_np(__int64 volatile *, __int64, __int64, __int64 *))
__MACHINEX64(long _InterlockedAnd_np(long *, long))
__MACHINEX64(char _InterlockedAnd8_np(char *, char))
__MACHINEX64(short _InterlockedAnd16_np(short *, short))
__MACHINEX64(__int64 _InterlockedAnd64_np(__int64 *, __int64))
__MACHINEX64(long _InterlockedOr_np(long *, long))
__MACHINEX64(char _InterlockedOr8_np(char *, char))
__MACHINEX64(short _InterlockedOr16_np(short *, short))
__MACHINEX64(__int64 _InterlockedOr64_np(__int64 *, __int64))
__MACHINEX64(long _InterlockedXor_np(long *, long))
__MACHINEX64(char _InterlockedXor8_np(char *, char))
__MACHINEX64(short _InterlockedXor16_np(short *, short))
__MACHINEX64(__int64 _InterlockedXor64_np(__int64 *, __int64))

__MACHINEI(unsigned short __lzcnt16(unsigned short))
__MACHINEI(unsigned int __lzcnt(unsigned int))
__MACHINEX64(unsigned __int64 __lzcnt64(unsigned __int64))
__MACHINEI(unsigned short __popcnt16(unsigned short))
__MACHINEI(unsigned int __popcnt(unsigned int))
__MACHINEX64(unsigned __int64 __popcnt64(unsigned __int64))
__MACHINEI(__m128i _mm_extract_si64(__m128i,__m128i))
__MACHINEI(__m128i _mm_extracti_si64(__m128i, int, int))
__MACHINEI(__m128i _mm_insert_si64(__m128i,__m128i))
__MACHINEI(__m128i _mm_inserti_si64(__m128i, __m128i, int, int))
__MACHINEI(void _mm_stream_sd(double*,__m128d))
__MACHINEI(void _mm_stream_ss(float*,__m128))
__MACHINEI(unsigned __int64 __rdtscp(unsigned int*))

#if defined (_M_IA64)

    /* Special Registers */

#define     __REG_IA64_Ip               1016

    /* General-Purpose Registers */

    /* Integer registers */
#define     __REG_IA64_IntR0            1024
#define     __REG_IA64_IntR1            1025
#define     __REG_IA64_IntR2            1026
#define     __REG_IA64_IntR3            1027
#define     __REG_IA64_IntR4            1028
#define     __REG_IA64_IntR5            1029
#define     __REG_IA64_IntR6            1030
#define     __REG_IA64_IntR7            1031
#define     __REG_IA64_IntR8            1032
#define     __REG_IA64_IntR9            1033
#define     __REG_IA64_IntR10           1034
#define     __REG_IA64_IntR11           1035
#define     __REG_IA64_IntR12           1036
#define     __REG_IA64_IntR13           1037
#define     __REG_IA64_IntR14           1038
#define     __REG_IA64_IntR15           1039
#define     __REG_IA64_IntR16           1040
#define     __REG_IA64_IntR17           1041
#define     __REG_IA64_IntR18           1042
#define     __REG_IA64_IntR19           1043
#define     __REG_IA64_IntR20           1044
#define     __REG_IA64_IntR21           1045
#define     __REG_IA64_IntR22           1046
#define     __REG_IA64_IntR23           1047
#define     __REG_IA64_IntR24           1048
#define     __REG_IA64_IntR25           1049
#define     __REG_IA64_IntR26           1050
#define     __REG_IA64_IntR27           1051
#define     __REG_IA64_IntR28           1052
#define     __REG_IA64_IntR29           1053
#define     __REG_IA64_IntR30           1054
#define     __REG_IA64_IntR31           1055

    /* Register Stack */
#define     __REG_IA64_IntR32           1056
#define     __REG_IA64_IntR33           1057
#define     __REG_IA64_IntR34           1058
#define     __REG_IA64_IntR35           1059
#define     __REG_IA64_IntR36           1060
#define     __REG_IA64_IntR37           1061
#define     __REG_IA64_IntR38           1062
#define     __REG_IA64_IntR39           1063
#define     __REG_IA64_IntR40           1064
#define     __REG_IA64_IntR41           1065
#define     __REG_IA64_IntR42           1066
#define     __REG_IA64_IntR43           1067
#define     __REG_IA64_IntR44           1068
#define     __REG_IA64_IntR45           1069
#define     __REG_IA64_IntR46           1070
#define     __REG_IA64_IntR47           1071
#define     __REG_IA64_IntR48           1072
#define     __REG_IA64_IntR49           1073
#define     __REG_IA64_IntR50           1074
#define     __REG_IA64_IntR51           1075
#define     __REG_IA64_IntR52           1076
#define     __REG_IA64_IntR53           1077
#define     __REG_IA64_IntR54           1078
#define     __REG_IA64_IntR55           1079
#define     __REG_IA64_IntR56           1080
#define     __REG_IA64_IntR57           1081
#define     __REG_IA64_IntR58           1082
#define     __REG_IA64_IntR59           1083
#define     __REG_IA64_IntR60           1084
#define     __REG_IA64_IntR61           1085
#define     __REG_IA64_IntR62           1086
#define     __REG_IA64_IntR63           1087
#define     __REG_IA64_IntR64           1088
#define     __REG_IA64_IntR65           1089
#define     __REG_IA64_IntR66           1090
#define     __REG_IA64_IntR67           1091
#define     __REG_IA64_IntR68           1092
#define     __REG_IA64_IntR69           1093
#define     __REG_IA64_IntR70           1094
#define     __REG_IA64_IntR71           1095
#define     __REG_IA64_IntR72           1096
#define     __REG_IA64_IntR73           1097
#define     __REG_IA64_IntR74           1098
#define     __REG_IA64_IntR75           1099
#define     __REG_IA64_IntR76           1100
#define     __REG_IA64_IntR77           1101
#define     __REG_IA64_IntR78           1102
#define     __REG_IA64_IntR79           1103
#define     __REG_IA64_IntR80           1104
#define     __REG_IA64_IntR81           1105
#define     __REG_IA64_IntR82           1106
#define     __REG_IA64_IntR83           1107
#define     __REG_IA64_IntR84           1108
#define     __REG_IA64_IntR85           1109
#define     __REG_IA64_IntR86           1110
#define     __REG_IA64_IntR87           1111
#define     __REG_IA64_IntR88           1112
#define     __REG_IA64_IntR89           1113
#define     __REG_IA64_IntR90           1114
#define     __REG_IA64_IntR91           1115
#define     __REG_IA64_IntR92           1116
#define     __REG_IA64_IntR93           1117
#define     __REG_IA64_IntR94           1118
#define     __REG_IA64_IntR95           1119
#define     __REG_IA64_IntR96           1120
#define     __REG_IA64_IntR97           1121
#define     __REG_IA64_IntR98           1122
#define     __REG_IA64_IntR99           1123
#define     __REG_IA64_IntR100          1124
#define     __REG_IA64_IntR101          1125
#define     __REG_IA64_IntR102          1126
#define     __REG_IA64_IntR103          1127
#define     __REG_IA64_IntR104          1128
#define     __REG_IA64_IntR105          1129
#define     __REG_IA64_IntR106          1130
#define     __REG_IA64_IntR107          1131
#define     __REG_IA64_IntR108          1132
#define     __REG_IA64_IntR109          1133
#define     __REG_IA64_IntR110          1134
#define     __REG_IA64_IntR111          1135
#define     __REG_IA64_IntR112          1136
#define     __REG_IA64_IntR113          1137
#define     __REG_IA64_IntR114          1138
#define     __REG_IA64_IntR115          1139
#define     __REG_IA64_IntR116          1140
#define     __REG_IA64_IntR117          1141
#define     __REG_IA64_IntR118          1142
#define     __REG_IA64_IntR119          1143
#define     __REG_IA64_IntR120          1144
#define     __REG_IA64_IntR121          1145
#define     __REG_IA64_IntR122          1146
#define     __REG_IA64_IntR123          1147
#define     __REG_IA64_IntR124          1148
#define     __REG_IA64_IntR125          1149
#define     __REG_IA64_IntR126          1150
#define     __REG_IA64_IntR127          1151

    /* Application Registers */

#define     __REG_IA64_ApKR0            3072
#define     __REG_IA64_ApKR1            3073
#define     __REG_IA64_ApKR2            3074
#define     __REG_IA64_ApKR3            3075
#define     __REG_IA64_ApKR4            3076
#define     __REG_IA64_ApKR5            3077
#define     __REG_IA64_ApKR6            3078
#define     __REG_IA64_ApKR7            3079
#define     __REG_IA64_AR8              3080
#define     __REG_IA64_AR9              3081
#define     __REG_IA64_AR10             3082
#define     __REG_IA64_AR11             3083
#define     __REG_IA64_AR12             3084
#define     __REG_IA64_AR13             3085
#define     __REG_IA64_AR14             3086
#define     __REG_IA64_AR15             3087
#define     __REG_IA64_RsRSC            3088
#define     __REG_IA64_RsBSP            3089
#define     __REG_IA64_RsBSPSTORE       3090
#define     __REG_IA64_RsRNAT           3091
#define     __REG_IA64_AR20             3092
#define     __REG_IA64_StFCR            3093
#define     __REG_IA64_AR22             3094
#define     __REG_IA64_AR23             3095
#define     __REG_IA64_EFLAG            3096
#define     __REG_IA64_CSD              3097
#define     __REG_IA64_SSD              3098
#define     __REG_IA64_CFLG             3099
#define     __REG_IA64_StFSR            3100
#define     __REG_IA64_StFIR            3101
#define     __REG_IA64_StFDR            3102
#define     __REG_IA64_AR31             3103
#define     __REG_IA64_ApCCV            3104
#define     __REG_IA64_AR33             3105
#define     __REG_IA64_AR34             3106
#define     __REG_IA64_AR35             3107
#define     __REG_IA64_ApUNAT           3108
#define     __REG_IA64_AR37             3109
#define     __REG_IA64_AR38             3110
#define     __REG_IA64_AR39             3111
#define     __REG_IA64_StFPSR           3112
#define     __REG_IA64_AR41             3113
#define     __REG_IA64_AR42             3114
#define     __REG_IA64_AR43             3115
#define     __REG_IA64_ApITC            3116
#define     __REG_IA64_AR45             3117
#define     __REG_IA64_AR46             3118
#define     __REG_IA64_AR47             3119
#define     __REG_IA64_AR48             3120
#define     __REG_IA64_AR49             3121
#define     __REG_IA64_AR50             3122
#define     __REG_IA64_AR51             3123
#define     __REG_IA64_AR52             3124
#define     __REG_IA64_AR53             3125
#define     __REG_IA64_AR54             3126
#define     __REG_IA64_AR55             3127
#define     __REG_IA64_AR56             3128
#define     __REG_IA64_AR57             3129
#define     __REG_IA64_AR58             3130
#define     __REG_IA64_AR59             3131
#define     __REG_IA64_AR60             3132
#define     __REG_IA64_AR61             3133
#define     __REG_IA64_AR62             3134
#define     __REG_IA64_AR63             3135
#define     __REG_IA64_RsPFS            3136
#define     __REG_IA64_ApLC             3137
#define     __REG_IA64_ApEC             3138
#define     __REG_IA64_AR67             3139
#define     __REG_IA64_AR68             3140
#define     __REG_IA64_AR69             3141
#define     __REG_IA64_AR70             3142
#define     __REG_IA64_AR71             3143
#define     __REG_IA64_AR72             3144
#define     __REG_IA64_AR73             3145
#define     __REG_IA64_AR74             3146
#define     __REG_IA64_AR75             3147
#define     __REG_IA64_AR76             3148
#define     __REG_IA64_AR77             3149
#define     __REG_IA64_AR78             3150
#define     __REG_IA64_AR79             3151
#define     __REG_IA64_AR80             3152
#define     __REG_IA64_AR81             3153
#define     __REG_IA64_AR82             3154
#define     __REG_IA64_AR83             3155
#define     __REG_IA64_AR84             3156
#define     __REG_IA64_AR85             3157
#define     __REG_IA64_AR86             3158
#define     __REG_IA64_AR87             3159
#define     __REG_IA64_AR88             3160
#define     __REG_IA64_AR89             3161
#define     __REG_IA64_AR90             3162
#define     __REG_IA64_AR91             3163
#define     __REG_IA64_AR92             3164
#define     __REG_IA64_AR93             3165
#define     __REG_IA64_AR94             3166
#define     __REG_IA64_AR95             3167
#define     __REG_IA64_AR96             3168
#define     __REG_IA64_AR97             3169
#define     __REG_IA64_AR98             3170
#define     __REG_IA64_AR99             3171
#define     __REG_IA64_AR100            3172
#define     __REG_IA64_AR101            3173
#define     __REG_IA64_AR102            3174
#define     __REG_IA64_AR103            3175
#define     __REG_IA64_AR104            3176
#define     __REG_IA64_AR105            3177
#define     __REG_IA64_AR106            3178
#define     __REG_IA64_AR107            3179
#define     __REG_IA64_AR108            3180
#define     __REG_IA64_AR109            3181
#define     __REG_IA64_AR110            3182
#define     __REG_IA64_AR111            3183
#define     __REG_IA64_AR112            3184
#define     __REG_IA64_AR113            3185
#define     __REG_IA64_AR114            3186
#define     __REG_IA64_AR115            3187
#define     __REG_IA64_AR116            3188
#define     __REG_IA64_AR117            3189
#define     __REG_IA64_AR118            3190
#define     __REG_IA64_AR119            3191
#define     __REG_IA64_AR120            3192
#define     __REG_IA64_AR121            3193
#define     __REG_IA64_AR122            3194
#define     __REG_IA64_AR123            3195
#define     __REG_IA64_AR124            3196
#define     __REG_IA64_AR125            3197
#define     __REG_IA64_AR126            3198
#define     __REG_IA64_AR127            3199

    /* CPUID Registers */

#define     __REG_IA64_CPUID0           3328
#define     __REG_IA64_CPUID1           3329
#define     __REG_IA64_CPUID2           3330
#define     __REG_IA64_CPUID3           3331
#define     __REG_IA64_CPUID4           3332

    /* Control Registers */

#define     __REG_IA64_ApDCR            4096
#define     __REG_IA64_ApITM            4097
#define     __REG_IA64_ApIVA            4098
#define     __REG_IA64_ApPTA            4104
#define     __REG_IA64_ApGPTA           4105
#define     __REG_IA64_StIPSR           4112
#define     __REG_IA64_StISR            4113
#define     __REG_IA64_StIIP            4115
#define     __REG_IA64_StIFA            4116
#define     __REG_IA64_StITIR           4117
#define     __REG_IA64_StIIPA           4118
#define     __REG_IA64_StIFS            4119
#define     __REG_IA64_StIIM            4120
#define     __REG_IA64_StIHA            4121
#define     __REG_IA64_SaLID            4160
#define     __REG_IA64_SaIVR            4161
#define     __REG_IA64_SaTPR            4162
#define     __REG_IA64_SaEOI            4163
#define     __REG_IA64_SaIRR0           4164
#define     __REG_IA64_SaIRR1           4165
#define     __REG_IA64_SaIRR2           4166
#define     __REG_IA64_SaIRR3           4167
#define     __REG_IA64_SaITV            4168
#define     __REG_IA64_SaPMV            4169
#define     __REG_IA64_SaCMCV           4170
#define     __REG_IA64_SaLRR0           4176
#define     __REG_IA64_SaLRR1           4177

    /* Performance Monitor Data Registers */

#define     __REG_IA64_PFD0      7168
#define     __REG_IA64_PFD1      7169
#define     __REG_IA64_PFD2      7170
#define     __REG_IA64_PFD3      7171
#define     __REG_IA64_PFD4      7172
#define     __REG_IA64_PFD5      7173
#define     __REG_IA64_PFD6      7174
#define     __REG_IA64_PFD7      7175
#define     __REG_IA64_PFD8      7176
#define     __REG_IA64_PFD9      7177
#define     __REG_IA64_PFD10     7178
#define     __REG_IA64_PFD11     7179
#define     __REG_IA64_PFD12     7180
#define     __REG_IA64_PFD13     7181
#define     __REG_IA64_PFD14     7182
#define     __REG_IA64_PFD15     7183
#define     __REG_IA64_PFD16     7184
#define     __REG_IA64_PFD17     7185

    /* Performance Monitor Config Registers */

#define     __REG_IA64_PFC0      7424
#define     __REG_IA64_PFC1      7425
#define     __REG_IA64_PFC2      7426
#define     __REG_IA64_PFC3      7427
#define     __REG_IA64_PFC4      7428
#define     __REG_IA64_PFC5      7429
#define     __REG_IA64_PFC6      7430
#define     __REG_IA64_PFC7      7431
#define     __REG_IA64_PFC8      7432
#define     __REG_IA64_PFC9      7433
#define     __REG_IA64_PFC10     7434
#define     __REG_IA64_PFC11     7435
#define     __REG_IA64_PFC12     7436
#define     __REG_IA64_PFC13     7437
#define     __REG_IA64_PFC14     7438
#define     __REG_IA64_PFC15     7439

    /* Instruction Breakpoint Registers */

#define     __REG_IA64_DbI0             8448
#define     __REG_IA64_DbI1             8449
#define     __REG_IA64_DbI2             8450
#define     __REG_IA64_DbI3             8451
#define     __REG_IA64_DbI4             8452
#define     __REG_IA64_DbI5             8453
#define     __REG_IA64_DbI6             8454
#define     __REG_IA64_DbI7             8455

    /* Data Breakpoint Registers */

#define     __REG_IA64_DbD0             8576
#define     __REG_IA64_DbD1             8577
#define     __REG_IA64_DbD2             8578
#define     __REG_IA64_DbD3             8579
#define     __REG_IA64_DbD4             8580
#define     __REG_IA64_DbD5             8581
#define     __REG_IA64_DbD6             8582
#define     __REG_IA64_DbD7             8583

#endif  /* defined (_M_IA64) */


#if defined (_NO_PREFETCHW)
#if defined (_M_AMD64)

#define _InterlockedCompareExchange16 _InterlockedCompareExchange16_np
#define _InterlockedCompareExchange _InterlockedCompareExchange_np
#define _InterlockedCompareExchange64 _InterlockedCompareExchange64_np
#define _InterlockedCompareExchangePointer _InterlockedCompareExchangePointer_np
#define _InterlockedCompareExchange128 _InterlockedCompareExchange128_np
#define _InterlockedAnd _InterlockedAnd_np
#define _InterlockedAnd8 _InterlockedAnd8_np
#define _InterlockedAnd16 _InterlockedAnd16_np
#define _InterlockedAnd64 _InterlockedAnd64_np
#define _InterlockedOr _InterlockedOr_np
#define _InterlockedOr8 _InterlockedOr8_np
#define _InterlockedOr16 _InterlockedOr16_np
#define _InterlockedOr64 _InterlockedOr64_np
#define _InterlockedXor _InterlockedXor_np
#define _InterlockedXor8 _InterlockedXor8_np
#define _InterlockedXor16 _InterlockedXor16_np
#define _InterlockedXor64 _InterlockedXor64_np

#endif  /* defined (_M_AMD64) */
#endif  /* defined (_NO_PREFETCHW) */

#if defined (__cplusplus)
}
#endif  /* defined (__cplusplus) */
#endif  /* __midl */
#endif  /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\iostream.cpp ===
// iostream -- ios::Init members, dummy for MS
#include <iostream>
_STD_BEGIN

		// OBJECT DECLARATIONS
__PURE_APPDOMAIN_GLOBAL int ios_base::Init::_Init_cnt = -1;
int& ios_base::Init::_Init_cnt_func()
{
    return ios_base::Init::_Init_cnt;
}

_CRTIMP2_PURE void __cdecl ios_base::Init::_Init_ctor( ios_base::Init *_This)
	{	// initialize standard streams first time
	if (0 <= _Init_cnt)
		++_Init_cnt;
	else
		_Init_cnt = 1;
	}

_CRTIMP2_PURE void __cdecl ios_base::Init::_Init_dtor(ios_base::Init *_This)
	{	// flush standard streams last time
	if (--_Init_cnt == 0)
		{	// flush standard streams
		if (_Ptr_cerr != 0)
			_Ptr_cerr->flush();
		if (_Ptr_clog != 0)
			_Ptr_clog->flush();
		if (_Ptr_cout != 0)
			_Ptr_cout->flush();
		}
	}
_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\isctype.c ===
/***
*isctype.c - support is* ctype functions/macros for two-byte multibyte chars
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _isctype.c - support is* ctype functions/macros for
*       two-byte multibyte chars.
*
*******************************************************************************/

#include <stdio.h>
#include <cruntime.h>
#include <ctype.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <mtdll.h>
#include <setlocal.h>


/*
 *  Use GetCharType() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if _UPPER   != C1_UPPER || \
        _LOWER   != C1_LOWER || \
        _DIGIT   != C1_DIGIT || \
        _SPACE   != C1_SPACE || \
        _PUNCT   != C1_PUNCT || \
        _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif  /* _UPPER   != C1_UPPER || \ */



/***
* __chvalidator
*
* Purpose:
*       This function is called by character testing functions in debug
*       versions. This function test for validation of c as character.
*       For improvement in performance, it is not used in non-debug
*       version.  It is available in the static single-thread non-debug
*       build, though, just in case C code that includes ctype.h is compiled
*       /D_DEBUG /ML.
*
*******************************************************************************/

#if defined (_DEBUG)
extern "C" int __cdecl _chvalidator(
        int c,
        int mask
        )
{
        _ASSERTE((unsigned)(c + 1) <= 256);
        return _chvalidator_l(NULL, c, mask);
}

extern "C" int __cdecl _chvalidator_l(
        _locale_t plocinfo,
        int c,
        int mask
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    _ASSERTE((unsigned)(c + 1) <= 256);
    if (c >= -1 && c <= 255)
    {
        return (_loc_update.GetLocaleT()->locinfo->pctype[c] & mask);
    }
    else
    {
        return (_loc_update.GetLocaleT()->locinfo->pctype[-1] & mask);
    }
}

#endif  /* defined (_DEBUG) */

/***
*_isctype - support is* ctype functions/macros for two-byte multibyte chars
*
*Purpose:
*       This function is called by the is* ctype functions/macros
*       (e.g. isalpha()) when their argument is a two-byte multibyte char.
*       Returns true or false depending on whether the argument satisfies
*       the character class property encoded by the mask.
*
*Entry:
*       int c - the multibyte character whose type is to be tested
*       unsigned int mask - the mask used by the is* functions/macros
*                  corresponding to each character class property
*
*       The leadbyte and the trailbyte should be packed into the int c as:
*
*       H.......|.......|.......|.......L
*           0       0   leadbyte trailbyte
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/

extern "C" int __cdecl _isctype_l (
        int c,
        int mask,
        _locale_t plocinfo
        )
{
        int size;
        unsigned short chartype;
        char buffer[3];
        _LocaleUpdate _loc_update(plocinfo);

        /* c valid between -1 and 255 */
        if ( c >= -1 && c <= 255 )
            return _loc_update.GetLocaleT()->locinfo->pctype[c] & mask;

        if ( _isleadbyte_l(c >> 8 & 0xff, _loc_update.GetLocaleT()) )
        {
            buffer[0] = (c >> 8 & 0xff); /* put lead-byte at start of str */
            buffer[1] = (char)c;
            buffer[2] = 0;
            size = 2;
        } else {
            buffer[0] = (char)c;
            buffer[1] = 0;
            size = 1;
        }

        if ( 0 == __crtGetStringTypeA(
                    _loc_update.GetLocaleT(),
                    CT_CTYPE1,
                    buffer,
                    size,
                    &chartype,
                    _loc_update.GetLocaleT()->locinfo->lc_codepage,
                    _loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE],
                    TRUE) )
        {
            return 0;
        }

        return (int)(chartype & mask);
}

extern "C" int __cdecl _isctype (
        int c,
        int mask
        )
{
    if (__locale_changed == 0)
    {
        return __initiallocinfo.pctype[c] & mask;
    }
    else
    {
        return _isctype_l(c, mask, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_IO
#define _INC_IO

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */


#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif  /* _FSIZE_T_DEFINED */

#ifndef _FINDDATA_T_DEFINED

struct _finddata32_t {
        unsigned    attrib;
        __time32_t  time_create;    /* -1 for FAT file systems */
        __time32_t  time_access;    /* -1 for FAT file systems */
        __time32_t  time_write;
        _fsize_t    size;
        char        name[260];
};

struct _finddata32i64_t {
        unsigned    attrib;
        __time32_t  time_create;    /* -1 for FAT file systems */
        __time32_t  time_access;    /* -1 for FAT file systems */
        __time32_t  time_write;
        __int64     size;
        char        name[260];
};

struct _finddata64i32_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        _fsize_t    size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#ifdef _USE_32BIT_TIME_T
#define _finddata_t     _finddata32_t
#define _finddatai64_t  _finddata32i64_t

#define _findfirst      _findfirst32
#define _findnext       _findnext32
#define _findfirsti64   _findfirst32i64
#define _findnexti64     _findnext32i64

#else  /* _USE_32BIT_TIME_T */
#define _finddata_t     _finddata64i32_t
#define _finddatai64_t  __finddata64_t

#define _findfirst      _findfirst64i32
#define _findnext       _findnext64i32
#define _findfirsti64   _findfirst64
#define _findnexti64    _findnext64

#endif  /* _USE_32BIT_TIME_T */


#define _FINDDATA_T_DEFINED
#endif  /* _FINDDATA_T_DEFINED */

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata32_t {
        unsigned    attrib;
        __time32_t  time_create;    /* -1 for FAT file systems */
        __time32_t  time_access;    /* -1 for FAT file systems */
        __time32_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata32i64_t {
        unsigned    attrib;
        __time32_t  time_create;    /* -1 for FAT file systems */
        __time32_t  time_access;    /* -1 for FAT file systems */
        __time32_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

struct _wfinddata64i32_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#ifdef _USE_32BIT_TIME_T
#define _wfinddata_t    _wfinddata32_t
#define _wfinddatai64_t _wfinddata32i64_t

#define _wfindfirst     _wfindfirst32
#define _wfindnext      _wfindnext32
#define _wfindfirsti64  _wfindfirst32i64
#define _wfindnexti64   _wfindnext32i64

#else  /* _USE_32BIT_TIME_T */
#define _wfinddata_t    _wfinddata64i32_t
#define _wfinddatai64_t _wfinddata64_t

#define _wfindfirst     _wfindfirst64i32
#define _wfindnext      _wfindnext64i32
#define _wfindfirsti64  _wfindfirst64
#define _wfindnexti64   _wfindnext64

#endif  /* _USE_32BIT_TIME_T */

#define _WFINDDATA_T_DEFINED
#endif  /* _WFINDDATA_T_DEFINED */

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef _W64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

_Check_return_ _CRTIMP int __cdecl _access(_In_z_ const char * _Filename, _In_ int _AccessMode);
_Check_return_wat_ _CRTIMP errno_t __cdecl _access_s(_In_z_ const char * _Filename, _In_ int _AccessMode);
_Check_return_ _CRTIMP int __cdecl _chmod(_In_z_ const char * _Filename, _In_ int _Mode);
/* note that the newly added _chsize_s takes a 64 bit value */
_Check_return_ _CRTIMP int __cdecl _chsize(_In_ int _FileHandle, _In_ long _Size);
_Check_return_wat_ _CRTIMP errno_t __cdecl _chsize_s(_In_ int _FileHandle,_In_ __int64 _Size);
_Check_return_opt_ _CRTIMP int __cdecl _close(_In_ int _FileHandle);
_Check_return_opt_ _CRTIMP int __cdecl _commit(_In_ int _FileHandle);
_Check_return_ _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl _creat(_In_z_ const char * _Filename, _In_ int _PermissionMode);
_Check_return_ _CRTIMP int __cdecl _dup(_In_ int _FileHandle);
_Check_return_ _CRTIMP int __cdecl _dup2(_In_ int _FileHandleSrc, _In_ int _FileHandleDst);
_Check_return_ _CRTIMP int __cdecl _eof(_In_ int _FileHandle);
_Check_return_ _CRTIMP long __cdecl _filelength(_In_ int _FileHandle);
_Check_return_ _CRTIMP intptr_t __cdecl _findfirst32(_In_z_ const char * _Filename, _Out_ struct _finddata32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _findnext32(_In_ intptr_t _FindHandle, _Out_ struct _finddata32_t * _FindData);
_Check_return_opt_ _CRTIMP int __cdecl _findclose(_In_ intptr_t _FindHandle);
_Check_return_ _CRTIMP int __cdecl _isatty(_In_ int _FileHandle);
_CRTIMP int __cdecl _locking(_In_ int _FileHandle, _In_ int _LockMode, _In_ long _NumOfBytes);
_Check_return_opt_ _CRTIMP long __cdecl _lseek(_In_ int _FileHandle, _In_ long _Offset, _In_ int _Origin);
_Check_return_wat_ _CRTIMP errno_t __cdecl _mktemp_s(_Inout_z_cap_(_Size) char * _TemplateName, _In_ size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _mktemp_s, _Deref_prepost_z_ char, _TemplateName)
_Check_return_ __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, _mktemp, _Inout_z_, char, _TemplateName)
_Check_return_ _CRTIMP int __cdecl _pipe(_Inout_cap_c_(2) int * _PtHandles, _In_ unsigned int _PipeSize, _In_ int _TextMode);
_Check_return_ _CRTIMP int __cdecl _read(_In_ int _FileHandle, _Out_bytecap_(_MaxCharCount) void * _DstBuf, _In_ unsigned int _MaxCharCount);

#ifndef _CRT_DIRECTORY_DEFINED
#define _CRT_DIRECTORY_DEFINED
_Check_return_ _CRTIMP int __cdecl remove(_In_z_ const char * _Filename);
_Check_return_ _CRTIMP int __cdecl rename(_In_z_ const char * _OldFilename, _In_z_ const char * _NewFilename);
_Check_return_ _CRTIMP int __cdecl _unlink(_In_z_ const char * _Filename);
#if !__STDC__
_Check_return_ _CRT_NONSTDC_DEPRECATE(_unlink) _CRTIMP int __cdecl unlink(_In_z_ const char * _Filename);
#endif  /* !__STDC__ */
#endif  /* _CRT_DIRECTORY_DEFINED */

_Check_return_ _CRTIMP int __cdecl _setmode(_In_ int _FileHandle, _In_ int _Mode);
_Check_return_ _CRTIMP long __cdecl _tell(_In_ int _FileHandle);
_CRT_INSECURE_DEPRECATE(_umask_s) _CRTIMP int __cdecl _umask(_In_ int _Mode);
_Check_return_wat_ _CRTIMP errno_t __cdecl _umask_s(_In_ int _NewMode, _Out_ int * _OldMode);
_CRTIMP int __cdecl _write(_In_ int _FileHandle, _In_bytecount_(_MaxCharCount) const void * _Buf, _In_ unsigned int _MaxCharCount);

_Check_return_ _CRTIMP __int64 __cdecl _filelengthi64(_In_ int _FileHandle);
_Check_return_ _CRTIMP intptr_t __cdecl _findfirst32i64(_In_z_ const char * _Filename, _Out_ struct _finddata32i64_t * _FindData);
_Check_return_ _CRTIMP intptr_t __cdecl _findfirst64i32(_In_z_ const char * _Filename, _Out_ struct _finddata64i32_t * _FindData);
_Check_return_ _CRTIMP intptr_t __cdecl _findfirst64(_In_z_ const char * _Filename, _Out_ struct __finddata64_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _findnext32i64(_In_ intptr_t _FindHandle, _Out_ struct _finddata32i64_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _findnext64i32(_In_ intptr_t _FindHandle, _Out_ struct _finddata64i32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _findnext64(_In_ intptr_t _FindHandle, _Out_ struct __finddata64_t * _FindData);
_Check_return_opt_ _CRTIMP __int64 __cdecl _lseeki64(_In_ int _FileHandle, _In_ __int64 _Offset, _In_ int _Origin);
_Check_return_ _CRTIMP __int64 __cdecl _telli64(_In_ int _FileHandle);

_Check_return_wat_ _CRTIMP errno_t __cdecl _sopen_s(_Out_ int * _FileHandle, _In_z_ const char * _Filename,_In_ int _OpenFlag, _In_ int _ShareFlag, _In_ int _PermissionMode);

#if !defined (__cplusplus)
_Check_return_ _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl _open(_In_z_ const char * _Filename, _In_ int _OpenFlag, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl _sopen(_In_z_ const char * _Filename, _In_ int _OpenFlag, int _ShareFlag, ...);
#else  /* !defined (__cplusplus) */

/* these function do not validate pmode; use _sopen_s */
extern "C++" _Check_return_ _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl _open(_In_z_ const char * _Filename, _In_ int _Openflag, _In_ int _PermissionMode = 0);
extern "C++" _Check_return_ _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl _sopen(_In_z_ const char * _Filename, _In_ int _Openflag, _In_ int _ShareFlag, _In_ int _PermissionMode = 0);

#endif  /* !defined (__cplusplus) */

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_Check_return_ _CRTIMP int __cdecl _waccess(_In_z_ const wchar_t * _Filename, _In_ int _AccessMode);
_Check_return_wat_ _CRTIMP errno_t __cdecl _waccess_s(_In_z_ const wchar_t * _Filename, _In_ int _AccessMode);
_Check_return_ _CRTIMP int __cdecl _wchmod(_In_z_ const wchar_t * _Filename, _In_ int _Mode);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wcreat(_In_z_ const wchar_t * _Filename, _In_ int _PermissionMode);
_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst32(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext32(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wunlink(_In_z_ const wchar_t * _Filename);
_Check_return_ _CRTIMP int __cdecl _wrename(_In_z_ const wchar_t * _OldFilename, _In_z_ const wchar_t * _NewFilename);
_CRTIMP errno_t __cdecl _wmktemp_s(_Inout_z_cap_(_SizeInWords) wchar_t * _TemplateName, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wmktemp_s, _Deref_prepost_z_ wchar_t, _TemplateName)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wmktemp, _Inout_z_, wchar_t, _TemplateName)

_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst32i64(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata32i64_t * _FindData);
_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst64i32(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata64i32_t * _FindData);
_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst64(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata64_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext32i64(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata32i64_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext64i32(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata64i32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext64(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata64_t * _FindData);

_Check_return_wat_ _CRTIMP errno_t __cdecl _wsopen_s(_Out_ int * _FileHandle, _In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, _In_ int _ShareFlag, _In_ int _PermissionFlag);

#if !defined (__cplusplus) || !defined (_M_IX86)

_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wsopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, int _ShareFlag, ...);

#else  /* !defined (__cplusplus) || !defined (_M_IX86) */

/* these function do not validate pmode; use _sopen_s */
extern "C++" _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, _In_ int _PermissionMode = 0);
extern "C++" _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wsopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, _In_ int _ShareFlag, int _PermissionMode = 0);

#endif  /* !defined (__cplusplus) || !defined (_M_IX86) */

#define _WIO_DEFINED
#endif  /* _WIO_DEFINED */

int  __cdecl __lock_fhandle(_In_ int _Filehandle);
void __cdecl _unlock_fhandle(_In_ int _Filehandle);

#ifndef _NOT_CRTL_BUILD_
_Check_return_ int __cdecl _chsize_nolock(_In_ int _FileHandle,_In_ __int64 _Size);
_Check_return_opt_ int __cdecl _close_nolock(_In_ int _FileHandle);
_Check_return_opt_ long __cdecl _lseek_nolock(_In_ int _FileHandle, _In_ long _Offset, _In_ int _Origin);
_Check_return_ int __cdecl _setmode_nolock(_In_ int _FileHandle, _In_ int _Mode);
_Check_return_ int __cdecl _read_nolock(_In_ int _FileHandle, _Out_bytecap_(_MaxCharCount) void * _DstBuf, _In_ unsigned int _MaxCharCount);
_Check_return_ int __cdecl _write_nolock(_In_ int _FileHandle, _In_bytecount_(_MaxCharCount) const void * _Buf, _In_ unsigned int _MaxCharCount);
_Check_return_opt_ __int64 __cdecl _lseeki64_nolock(_In_ int _FileHandle, _In_ __int64 _Offset, _In_ int _Origin);

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define _chsize(fh, size)               _chsize_nolock(fh, size)
#define _close(fh)                      _close_nolock(fh)
#define _lseek(fh, offset, origin)      _lseek_nolock(fh, offset, origin)
#define _setmode(fh, mode)              _setmode_nolock(fh, mode)
#define _read(fh, buff, count)          _read_nolock(fh, buff, count)
#define _write(fh, buff, count)         _write_nolock(fh, buff, count)
#define _lseeki64(fh,offset,origin)     _lseeki64_nolock(fh,offset,origin)
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */

#endif  /* _NOT_CRTL_BUILD_ */

_CRTIMP intptr_t __cdecl _get_osfhandle(_In_ int _FileHandle);
_CRTIMP int __cdecl _open_osfhandle(_In_ intptr_t _OSFileHandle, _In_ int _Flags);

#if !__STDC__

/* Non-ANSI names for compatibility */

#pragma warning(push)
#pragma warning(disable: 4141) /* Using deprecated twice */
_Check_return_ _CRT_NONSTDC_DEPRECATE(_access) _CRTIMP int __cdecl access(_In_z_ const char * _Filename, _In_ int _AccessMode);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_chmod) _CRTIMP int __cdecl chmod(_In_z_ const char * _Filename, int _AccessMode);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_chsize) _CRTIMP int __cdecl chsize(_In_ int _FileHandle, _In_ long _Size);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_close) _CRTIMP int __cdecl close(_In_ int _FileHandle);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_creat) _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl creat(_In_z_ const char * _Filename, _In_ int _PermissionMode);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_dup) _CRTIMP int __cdecl dup(_In_ int _FileHandle);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_dup2) _CRTIMP int __cdecl dup2(_In_ int _FileHandleSrc, _In_ int _FileHandleDst);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_eof) _CRTIMP int __cdecl eof(_In_ int _FileHandle);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_filelength) _CRTIMP long __cdecl filelength(_In_ int _FileHandle);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_isatty) _CRTIMP int __cdecl isatty(_In_ int _FileHandle);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_locking) _CRTIMP int __cdecl locking(_In_ int _FileHandle, _In_ int _LockMode, _In_ long _NumOfBytes);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_lseek) _CRTIMP long __cdecl lseek(_In_ int _FileHandle, _In_ long _Offset, _In_ int _Origin);
_CRT_NONSTDC_DEPRECATE(_mktemp) _CRT_INSECURE_DEPRECATE(_mktemp_s) _CRTIMP char * __cdecl mktemp(_Inout_z_ char * _TemplateName);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_open) _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl open(_In_z_ const char * _Filename, _In_ int _OpenFlag, ...);
_CRT_NONSTDC_DEPRECATE(_read) _CRTIMP int __cdecl read(int _FileHandle, _Out_bytecap_(_MaxCharCount) void * _DstBuf, _In_ unsigned int _MaxCharCount);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_setmode) _CRTIMP int __cdecl setmode(_In_ int _FileHandle, _In_ int _Mode);
_CRT_NONSTDC_DEPRECATE(_sopen) _CRT_INSECURE_DEPRECATE(_sopen_s) _CRTIMP int __cdecl sopen(const char * _Filename, _In_ int _OpenFlag, _In_ int _ShareFlag, ...);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_tell) _CRTIMP long __cdecl tell(_In_ int _FileHandle);
_CRT_NONSTDC_DEPRECATE(_umask) _CRT_INSECURE_DEPRECATE(_umask_s) _CRTIMP int __cdecl umask(_In_ int _Mode);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_write) _CRTIMP int __cdecl write(_In_ int _Filehandle, _In_bytecount_(_MaxCharCount) const void * _Buf, _In_ unsigned int _MaxCharCount);
#pragma warning(pop)

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\internal.h ===
/***
*internal.h - contains declarations of internal routines and variables
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares routines and variables used internally by the C run-time.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_INTERNAL
#define _INC_INTERNAL

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#include <cruntime.h>
#include <limits.h>

/*
 * Conditionally include windows.h to pick up the definition of
 * CRITICAL_SECTION.
 */
#include <windows.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/* Define function types used in several startup sources */

typedef void (__cdecl *_PVFV)(void);
typedef int  (__cdecl *_PIFV)(void);
typedef void (__cdecl *_PVFI)(int);

#if _MSC_VER >= 1400 && defined(_M_CEE)
typedef const void* (__clrcall *_PVFVM)(void);
typedef int (__clrcall *_PIFVM)(void);
typedef void (__clrcall *_CPVFV)(void);
#endif  /* _MSC_VER >= 1400 && defined(_M_CEE) */

#if defined (_M_CEE_PURE) || (defined (_DLL) && defined (_M_IX86))
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p__commode(void);
#endif  /* defined (_M_CEE_PURE) || (defined (_DLL) && defined (_M_IX86)) */
#if defined (SPECIAL_CRTEXE) && defined (_DLL)
        extern int _commode;
#else  /* defined (SPECIAL_CRTEXE) && defined (_DLL) */
#ifndef _M_CEE_PURE
_CRTIMP extern int _commode;
#else  /* _M_CEE_PURE */
#define _commode (*__p___commode())
#endif  /* _M_CEE_PURE */
#endif  /* defined (SPECIAL_CRTEXE) && defined (_DLL) */

#define __IOINFO_TM_ANSI    0   /* Regular Text */
#define __IOINFO_TM_UTF8    1   /* UTF8 Encoded */
#define __IOINFO_TM_UTF16LE 2   /* UTF16 Little Endian Encoded */

#define LF 10           /* line feed */
#define CR 13           /* carriage return */
#define CTRLZ 26        /* ctrl-z means eof for text */

extern char _lookuptrailbytes[256];

/* Most significant Bit */
#define _msbit(c) ((c) & 0x80)

/* Independent byte has most significant bit set to 0 */
#define  _utf8_is_independent(c)    (_msbit(c) == 0)

/* Any leadbyte will have the patterns 11000xxx 11100xxx or 11110xxx */
#define  _utf8_is_leadbyte(c)       (_lookuptrailbytes[(unsigned char)c] != 0)

/* Get no of trailing bytes from the lookup table */
#define  _utf8_no_of_trailbytes(c)  _lookuptrailbytes[(unsigned char)c]

/*
 * Control structure for lowio file handles
 */
typedef struct {
        intptr_t osfhnd;    /* underlying OS file HANDLE */
        char osfile;        /* attributes of file (e.g., open in text mode?) */
        char pipech;        /* one char buffer for handles opened on pipes */
        int lockinitflag;
        CRITICAL_SECTION lock;
#ifndef _SAFECRT_IMPL
        /* Not used in the safecrt downlevel. We do not define them, so we cannot use them accidentally */
        char textmode : 7;     /* __IOINFO_TM_ANSI or __IOINFO_TM_UTF8 or __IOINFO_TM_UTF16LE */
        char unicode : 1;      /* Was the file opened as unicode? */
        char pipech2[2];       /* 2 more peak ahead chars for UNICODE mode */
        __int64 startpos;      /* File position that matches buffer start */
        BOOL utf8translations; /* Buffer contains translations other than CRLF*/
        char dbcsBuffer;       /* Buffer for the lead byte of dbcs when converting from dbcs to unicode */
        BOOL dbcsBufferUsed;   /* Bool for the lead byte buffer is used or not */
#endif  /* _SAFECRT_IMPL */
    }   ioinfo;

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E          5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Definition of IOINFO_ARRAYS, maximum number of supported ioinfo arrays.
 */
#define IOINFO_ARRAYS       64

#define _NHANDLE_           (IOINFO_ARRAYS * IOINFO_ARRAY_ELTS)

#define _TZ_STRINGS_SIZE    64

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) ( __pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - \
                              1)) )
#define _osfhnd(i)  ( _pioinfo(i)->osfhnd )

#define _osfile(i)  ( _pioinfo(i)->osfile )

#define _pipech(i)  ( _pioinfo(i)->pipech )

#define _pipech2(i)  ( _pioinfo(i)->pipech2 )

#define _textmode(i) ( _pioinfo(i)->textmode )

#define _tm_unicode(i) ( _pioinfo(i)->unicode )

#define _startpos(i) ( _pioinfo(i)->startpos )

#define _utf8translations(i) ( _pioinfo(i)->utf8translations )

#define _dbcsBuffer(i) ( _pioinfo(i)->dbcsBuffer )

#define _dbcsBufferUsed(i) ( _pioinfo(i)->dbcsBufferUsed )

/*
 * Safer versions of the above macros. Currently, only _osfile_safe is
 * used.
 */
#define _pioinfo_safe(i)    ( (((i) != -1) && ((i) != -2)) ? _pioinfo(i) : &__badioinfo )

#define _osfhnd_safe(i)     ( _pioinfo_safe(i)->osfhnd )

#define _osfile_safe(i)     ( _pioinfo_safe(i)->osfile )

#define _pipech_safe(i)     ( _pioinfo_safe(i)->pipech )

#define _pipech2_safe(i)    ( _pioinfo_safe(i)->pipech2 )

#ifdef _SAFECRT_IMPL
/* safecrt does not have support for textmode, so we always return __IOINFO_TM_ANSI */
#define _textmode_safe(i)   __IOINFO_TM_ANSI
#define _tm_unicode_safe(i)  0
#define _startpos_safe(i)   ( 0 )
#define _utf8translations_safe(i)  ( FALSE )
#else  /* _SAFECRT_IMPL */
#define _textmode_safe(i)   ( _pioinfo_safe(i)->textmode )
#define _tm_unicode_safe(i) ( _pioinfo_safe(i)->unicode )
#define _startpos_safe(i)   ( _pioinfo_safe(i)->startpos )
#define _utf8translations_safe(i)  ( _pioinfo_safe(i)->utf8translations )
#endif  /* _SAFECRT_IMPL */

#ifndef _M_CEE_PURE
#ifdef _SAFECRT_IMPL
/* We need to get this from the downlevel DLL, even when we build safecrt.lib */
extern __declspec(dllimport) ioinfo __badioinfo;
extern __declspec(dllimport) ioinfo * __pioinfo[];
#else  /* _SAFECRT_IMPL */
/*
 * Special, static ioinfo structure used only for more graceful handling
 * of a C file handle value of -1 (results from common errors at the stdio
 * level).
 */
extern _CRTIMP ioinfo __badioinfo;

/*
 * Array of arrays of control structures for lowio files.
 */
extern _CRTIMP ioinfo * __pioinfo[];
#endif  /* _SAFECRT_IMPL */
#endif  /* _M_CEE_PURE */

/*
 * Current number of allocated ioinfo structures (_NHANDLE_ is the upper
 * limit).
 */
extern int _nhandle;

int __cdecl _alloc_osfhnd(void);
int __cdecl _free_osfhnd(int);
int __cdecl _set_osfhnd(int, intptr_t);

/*
    fileno for stdout, stdin & stderr when there is no console
*/
#define _NO_CONSOLE_FILENO (intptr_t)-2


extern const char __dnames[];
extern const char __mnames[];

extern int _days[];
extern int _lpdays[];

extern __time32_t __cdecl __loctotime32_t(int, int, int, int, int, int, int);
extern __time64_t __cdecl __loctotime64_t(int, int, int, int, int, int, int);

#ifdef _TM_DEFINED
extern int __cdecl _isindst(_In_ struct tm * _Time);
#endif  /* _TM_DEFINED */

extern void __cdecl __tzset(void);

extern int __cdecl _validdrive(unsigned);

/*
 * If we are only interested in years between 1901 and 2099, we could use this:
 *
 *      #define IS_LEAP_YEAR(y)  (y % 4 == 0)
 */

#define IS_LEAP_YEAR(y)  (((y) % 4 == 0 && (y) % 100 != 0) || (y) % 400 == 0)

/*
 *      get the buffer used by gmtime
 */
struct tm * __cdecl __getgmtimebuf ();

/*
 * This variable is in the C start-up; the length must be kept synchronized
 * It is used by the *cenvarg.c modules
 */

extern char _acfinfo[]; /* "_C_FILE_INFO=" */

#define CFI_LENGTH  12  /* "_C_FILE_INFO" is 12 bytes long */


/*
 * stdio internals
 */
#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif  /* _FILE_DEFINED */

#if !defined (_FILEX_DEFINED) && defined (_WINDOWS_)

/*
 * Variation of FILE type used for the dynamically allocated portion of
 * __piob[]. For single thread, _FILEX is the same as FILE. For multithread
 * models, _FILEX has two fields: the FILE struct and the CRITICAL_SECTION
 * struct used to serialize access to the FILE.
 */

typedef struct {
        FILE f;
        CRITICAL_SECTION lock;
        }   _FILEX;


#define _FILEX_DEFINED
#endif  /* !defined (_FILEX_DEFINED) && defined (_WINDOWS_) */

/*
 * Number of entries supported in the array pointed to by __piob[]. That is,
 * the number of stdio-level files which may be open simultaneously. This
 * is normally set to _NSTREAM_ by the stdio initialization code.
 */
extern int _nstream;

/*
 * Pointer to the array of pointers to FILE/_FILEX structures that are used
 * to manage stdio-level files.
 */
extern void **__piob;

FILE * __cdecl _getstream(void);
FILE * __cdecl _openfile(_In_z_ const char * _Filename, _In_z_ const char * _Mode, _In_ int _ShFlag, _Out_ FILE * _File);
FILE * __cdecl _wopenfile(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _In_ int _ShFlag, _Out_ FILE * _File);
void __cdecl _getbuf(_Out_ FILE * _File);
int __cdecl _filwbuf (_Inout_ FILE * _File);
int __cdecl _flswbuf(_In_ int _Ch, _Inout_ FILE * _File);
void __cdecl _freebuf(_Inout_ FILE * _File);
int __cdecl _stbuf(_Inout_ FILE * _File);
void __cdecl _ftbuf(int _Flag, _Inout_ FILE * _File);

#ifdef _SAFECRT_IMPL

int __cdecl _output(_Inout_ FILE * _File, _In_z_ __format_string const char *_Format, va_list _ArgList);
int __cdecl _woutput(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *_Format, va_list _ArgList);
int __cdecl _output_s(_Inout_ FILE * _File, _In_z_ __format_string const char *_Format, va_list _ArgList);
int __cdecl _output_p(_Inout_ FILE * _File, _In_z_ __format_string const char *_Format, va_list _ArgList);
int __cdecl _woutput_s(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *_Format, va_list _ArgList);
int __cdecl _woutput_p(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *_Format, va_list _ArgList);
typedef int (*OUTPUTFN)(FILE *, const char *, va_list);
typedef int (*WOUTPUTFN)(FILE *, const wchar_t *, va_list);

#else  /* _SAFECRT_IMPL */

int __cdecl _output_l(_Inout_ FILE * _File, _In_z_ __format_string const char *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _woutput_l(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _output_s_l(_Inout_ FILE * _File, _In_z_ __format_string const char *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _output_p_l(_Inout_ FILE * _File, _In_z_ __format_string const char *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _woutput_s_l(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _woutput_p_l(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
typedef int (*OUTPUTFN)(_Inout_ FILE * _File, const char *, _locale_t, va_list);
typedef int (*WOUTPUTFN)(_Inout_ FILE * _File, const wchar_t *, _locale_t, va_list);

#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL

int __cdecl _input(_In_ FILE * _File, _In_z_ __format_string const unsigned char * _Format, va_list _ArgList);
int __cdecl _winput(_In_ FILE * _File, _In_z_ __format_string const wchar_t * _Format, va_list _ArgList);
int __cdecl _input_s(_In_ FILE * _File, _In_z_ __format_string const unsigned char * _Format, va_list _ArgList);
int __cdecl _winput_s(_In_ FILE * _File, _In_z_ __format_string const wchar_t * _Format, va_list _ArgList);
typedef int (*INPUTFN)(FILE *, const unsigned char *, va_list);
typedef int (*WINPUTFN)(FILE *, const wchar_t *, va_list);

#else  /* _SAFECRT_IMPL */

int __cdecl _input_l(_Inout_ FILE * _File, _In_z_ __format_string const unsigned char *, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _winput_l(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _input_s_l(_Inout_ FILE * _File, _In_z_ __format_string const unsigned char *, _In_opt_ _locale_t _Locale, va_list _ArgList);
int __cdecl _winput_s_l(_Inout_ FILE * _File, _In_z_ __format_string const wchar_t *, _In_opt_ _locale_t _Locale, va_list _ArgList);
typedef int (*INPUTFN)(FILE *, const unsigned char *, _locale_t, va_list);
typedef int (*WINPUTFN)(FILE *, const wchar_t *, _locale_t, va_list);

#ifdef _UNICODE
#define TINPUTFN WINPUTFN
#else  /* _UNICODE */
#define TINPUTFN INPUTFN
#endif  /* _UNICODE */

#endif  /* _SAFECRT_IMPL */

int __cdecl _flush(_Inout_ FILE * _File);
void __cdecl _endstdio(void);

errno_t __cdecl _sopen_helper(_In_z_ const char * _Filename,
    _In_ int _OFlag, _In_ int _ShFlag, _In_ int _PMode,
    _Out_ int * _PFileHandle, int _BSecure);
errno_t __cdecl _wsopen_helper(_In_z_ const wchar_t * _Filename,
    _In_ int _OFlag, _In_ int _ShFlag, _In_ int _PMode,
    _Out_ int * _PFileHandle, int _BSecure);

#ifndef CRTDLL
extern int _cflush;
#endif  /* CRTDLL */

extern unsigned int _tempoff;

extern unsigned int _old_pfxlen;

extern int _umaskval;       /* the umask value */

extern char _pipech[];      /* pipe lookahead */

extern char _exitflag;      /* callable termination flag */

extern int _C_Termination_Done; /* termination done flag */

char * __cdecl _getpath(_In_z_ const char * _Src, _Out_z_cap_(_SizeInChars) char * _Dst, _In_ size_t _SizeInChars);
wchar_t * __cdecl _wgetpath(_In_z_ const wchar_t * _Src, _Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords);

extern int _dowildcard;     /* flag to enable argv[] wildcard expansion */

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif  /* _PNH_DEFINED */

#if _MSC_VER >= 1400 && defined(_M_CEE)
#ifndef __MPNH_DEFINED
typedef int (__clrcall * __MPNH)( size_t );
#define __MPNH_DEFINED
#endif  /* __MPNH_DEFINED */
#endif  /* _MSC_VER >= 1400 && defined(_M_CEE) */


/* calls the currently installed new handler */
int __cdecl _callnewh(_In_ size_t _Size);

extern int _newmode;    /* malloc new() handler mode */

/* pointer to initial environment block that is passed to [w]main */
#ifndef _M_CEE_PURE
extern _CRTIMP wchar_t **__winitenv;
extern _CRTIMP char **__initenv;
#endif  /* _M_CEE_PURE */

/* _calloca helper */
#define _calloca(count, size)  ((count<=0 || size<=0 || ((((size_t)_HEAP_MAXREQ) / ((size_t)count)) < ((size_t)size)))? NULL : _malloca(count * size))

/* startup set values */
extern char *_aenvptr;      /* environment ptr */
extern wchar_t *_wenvptr;   /* wide environment ptr */

/* command line */

#if defined (_DLL)
_CRTIMP char ** __cdecl __p__acmdln(void);
_CRTIMP wchar_t ** __cdecl __p__wcmdln(void);
#endif  /* defined (_DLL) */
#ifndef _M_CEE_PURE
_CRTIMP extern char *_acmdln;
_CRTIMP extern wchar_t *_wcmdln;
#else  /* _M_CEE_PURE */
#define _acmdln (*__p__acmdln())
#define _wcmdln (*__p__wcmdln())
#endif  /* _M_CEE_PURE */

/*
 * prototypes for internal startup functions
 */
int __cdecl _cwild(void);           /* wild.c */
int __cdecl _wcwild(void);          /* wwild.c */
int  __cdecl _mtinit(void);         /* tidtable.c */
void __cdecl _mtterm(void);         /* tidtable.c */
int  __cdecl _mtinitlocks(void);    /* mlock.c */
void __cdecl _mtdeletelocks(void);  /* mlock.c */
int  __cdecl _mtinitlocknum(_In_ int);   /* mlock.c */

/* Wrapper for InitializeCriticalSection API, with default spin count */
int __cdecl __crtInitCritSecAndSpinCount(PCRITICAL_SECTION, DWORD);
#define _CRT_SPINCOUNT  4000

/*
 * C source build only!!!!
 *
 * more prototypes for internal startup functions
 */
void __cdecl _amsg_exit(int);           /* crt0.c */
void __cdecl __crtExitProcess(int);     /* crt0dat.c */
void __cdecl __crtCorExitProcess(int);  /* crt0dat.c */
void __cdecl __crtdll_callstaticterminators(void); /* crt0dat.c */

/*
_cinit now allows the caller to suppress floating point precision init
This allows the DLLs that use the CRT to not initialise FP precision,
allowing the EXE's setting to persist even when a DLL is loaded
*/
int  __cdecl _cinit(int /* initFloatingPrecision */);   /* crt0dat.c */
void __cdecl __doinits(void);           /* astart.asm */
void __cdecl __doterms(void);           /* astart.asm */
void __cdecl __dopreterms(void);        /* astart.asm */
void __cdecl _FF_MSGBANNER(void);
void __cdecl _fpmath(int /*initPrecision*/);
void __cdecl _fpclear(void);
void __cdecl _fptrap(void);             /* crt0fp.c */
int  __cdecl _heap_init(_In_ int);
void __cdecl _heap_term(void);
void __cdecl _heap_abort(void);
void __cdecl __initconin(void);         /* initcon.c */
void __cdecl __initconout(void);        /* initcon.c */
int  __cdecl _ioinit(void);             /* crt0.c, crtlib.c */
void __cdecl _ioterm(void);             /* crt0.c, crtlib.c */
char * __cdecl _GET_RTERRMSG(int);
void __cdecl _NMSG_WRITE(int);
int  __CRTDECL _setargv(void);            /* setargv.c, stdargv.c */
int  __CRTDECL __setargv(void);           /* stdargv.c */
int  __CRTDECL _wsetargv(void);           /* wsetargv.c, wstdargv.c */
int  __CRTDECL __wsetargv(void);          /* wstdargv.c */
int  __cdecl _setenvp(void);            /* stdenvp.c */
int  __cdecl _wsetenvp(void);           /* wstdenvp.c */
void __cdecl __setmbctable(unsigned int);   /* mbctype.c */

#ifdef MRTDLL
_MRTIMP int __cdecl _onexit_process(_CPVFV);
_MRTIMP int __cdecl _onexit_app_domain(_CPVFV);
#endif  /* MRTDLL */

#ifdef _MBCS
int  __cdecl __initmbctable(void);      /* mbctype.c */
#endif  /* _MBCS */

#ifndef _MANAGED_MAIN
int __CRTDECL main(_In_ int _Argc, _In_count_(_Argc) _Pre_z_ char ** _Argv, _In_z_ char ** _Env);
int __CRTDECL wmain(_In_ int _Argc, _In_count_(_Argc) _Pre_z_ wchar_t ** _Argv, _In_z_ wchar_t ** _Env);
#endif  /* _MANAGED_MAIN */

/* helper functions for wide/multibyte environment conversion */
int __cdecl __mbtow_environ (void);
int __cdecl __wtomb_environ (void);

/* These two functions take a char ** for the environment option
   At some point during their execution, they take ownership of the
   memory block passed in using option. At this point, they
   NULL out the incoming char * / wchar_t * to ensure there is no
   double-free
*/
int __cdecl __crtsetenv (_Inout_ _Deref_prepost_opt_valid_ char ** _POption, _In_ const int _Primary);
int __cdecl __crtwsetenv (_Inout_ _Deref_prepost_opt_valid_ wchar_t ** _POption, _In_ const int _Primary);

#ifndef _M_CEE_PURE
_CRTIMP extern void (__cdecl * _aexit_rtn)(int);
#endif  /* _M_CEE_PURE */

#if defined (_DLL) || defined (CRTDLL)

#ifndef _STARTUP_INFO_DEFINED
typedef struct
{
        int newmode;
} _startupinfo;
#define _STARTUP_INFO_DEFINED
#endif  /* _STARTUP_INFO_DEFINED */

_CRTIMP int __cdecl __getmainargs(_Out_ int * _Argc, _Out_ _Deref_post_cap_(*_Argc) char *** _Argv,
                                  _Deref_out_opt_ char *** _Env, _In_ int _DoWildCard,
                                  _In_ _startupinfo * _StartInfo);

_CRTIMP int __cdecl __wgetmainargs(_Out_ int * _Argc, _Out_ _Deref_post_cap_(*_Argc)wchar_t *** _Argv,
                                   _Deref_out_opt_ wchar_t *** _Env, _In_ int _DoWildCard,
                                                                   _In_ _startupinfo * _StartInfo);

#endif  /* defined (_DLL) || defined (CRTDLL) */

/*
 * Prototype, variables and constants which determine how error messages are
 * written out.
 */
#define _UNKNOWN_APP    0
#define _CONSOLE_APP    1
#define _GUI_APP        2

extern int __app_type;

#if !defined (_M_CEE_PURE)

typedef enum {
    __uninitialized,
    __initializing,
    __initialized
} __enative_startup_state;

extern volatile __enative_startup_state __native_startup_state;
extern void * volatile __native_startup_lock;

#define __NO_REASON UINT_MAX
extern volatile unsigned int __native_dllmain_reason;
extern volatile unsigned int __native_vcclrit_reason;

#if defined (__cplusplus)

#pragma warning(push)
#pragma warning(disable: 4483)
#if _MSC_FULL_VER >= 140050415
#define _NATIVE_STARTUP_NAMESPACE  __identifier("<CrtImplementationDetails>")
#else  /* _MSC_FULL_VER >= 140050415 */
#define _NATIVE_STARTUP_NAMESPACE __CrtImplementationDetails
#endif  /* _MSC_FULL_VER >= 140050415 */

namespace _NATIVE_STARTUP_NAMESPACE
{
    class NativeDll
    {
    private:
        static const unsigned int ProcessDetach   = 0;
        static const unsigned int ProcessAttach   = 1;
        static const unsigned int ThreadAttach    = 2;
        static const unsigned int ThreadDetach    = 3;
        static const unsigned int ProcessVerifier = 4;

    public:

        inline static bool IsInDllMain()
        {
            return (__native_dllmain_reason != __NO_REASON);
        }

        inline static bool IsInProcessAttach()
        {
            return (__native_dllmain_reason == ProcessAttach);
        }

        inline static bool IsInProcessDetach()
        {
            return (__native_dllmain_reason == ProcessDetach);
        }

        inline static bool IsInVcclrit()
        {
            return (__native_vcclrit_reason != __NO_REASON);
        }

        inline static bool IsSafeForManagedCode()
        {
            if (!IsInDllMain())
            {
                return true;
            }

            if (IsInVcclrit())
            {
                return true;
            }

            return !IsInProcessAttach() && !IsInProcessDetach();
        }
    };
}
#pragma warning(pop)

#endif  /* defined (__cplusplus) */

#endif  /* !defined (_M_CEE_PURE) */

extern int __error_mode;

_CRTIMP void __cdecl __set_app_type(int);

/*
 * C source build only!!!!
 *
 * map Win32 errors into Xenix errno values -- for modules written in C
 */
_CRTIMP void __cdecl _dosmaperr(unsigned long);
extern int __cdecl _get_errno_from_oserr(unsigned long);

/*
 * internal routines used by the exec/spawn functions
 */

extern intptr_t __cdecl _dospawn(_In_ int _Mode, _In_opt_z_ const char * _Name, _Inout_z_ char * _Cmd, _In_opt_z_ char * _Env);
extern intptr_t __cdecl _wdospawn(_In_ int _Mode, _In_opt_z_ const wchar_t * _Name, _Inout_z_ wchar_t * _Cmd, _In_opt_z_ wchar_t * _Env);
extern int __cdecl _cenvarg(_In_z_ const char * const * _Argv, _In_opt_z_ const char * const * _Env,
        _Deref_out_opt_ char ** _ArgBlk, _Deref_out_opt_ char ** _EnvBlk, _In_z_ const char *_Name);
extern int __cdecl _wcenvarg(_In_z_ const wchar_t * const * _Argv, _In_opt_z_ const wchar_t * const * _Env,
        _Deref_out_opt_ wchar_t ** _ArgBlk, _Deref_out_opt_ wchar_t ** _EnvBlk, _In_z_ const wchar_t * _Name);
#ifndef _M_IX86
extern char ** _capture_argv(_In_ va_list *, _In_z_ const char * _FirstArg, _Out_z_cap_(_MaxCount) char ** _Static_argv, _In_ size_t _MaxCount);
extern wchar_t ** _wcapture_argv(_In_ va_list *, _In_z_ const wchar_t * _FirstArg, _Out_z_cap_(_MaxCount) wchar_t ** _Static_argv, _In_ size_t _MaxCount);
#endif  /* _M_IX86 */

/*
 * internal routine used by the abort
 */

extern _PHNDLR __cdecl __get_sigabrt(void);

/*
 * Type from ntdef.h
 */

typedef LONG NTSTATUS;

/*
 * Exception code used in _invalid_parameter
 */

#ifndef STATUS_INVALID_PARAMETER
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)
#endif  /* STATUS_INVALID_PARAMETER */

/*
 * Exception code used for abort and _CALL_REPORTFAULT
 */

#ifndef STATUS_FATAL_APP_EXIT
#define STATUS_FATAL_APP_EXIT            ((NTSTATUS)0x40000015L)
#endif  /* STATUS_FATAL_APP_EXIT */

/*
 * Validate functions
 */
#include <crtdbg.h> /* _ASSERTE */
#include <errno.h>

#define __STR2WSTR(str)    L##str

#define _STR2WSTR(str)     __STR2WSTR(str)

#define __FILEW__          _STR2WSTR(__FILE__)
#define __FUNCTIONW__      _STR2WSTR(__FUNCTION__)

/* We completely fill the buffer only in debug (see _SECURECRT__FILL_STRING
 * and _SECURECRT__FILL_BYTE macros).
 */
#if !defined (_SECURECRT_FILL_BUFFER)
#ifdef _DEBUG
#define _SECURECRT_FILL_BUFFER 1
#else  /* _DEBUG */
#define _SECURECRT_FILL_BUFFER 0
#endif  /* _DEBUG */
#endif  /* !defined (_SECURECRT_FILL_BUFFER) */

#ifndef _SAFECRT_IMPL
/* _invalid_parameter is already defined in safecrt.h and safecrt.lib */
#if !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE)
extern "C++"
#endif  /* !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE) */
_CRTIMP
#endif  /* _SAFECRT_IMPL */
void __cdecl _invalid_parameter(_In_opt_z_ const wchar_t *, _In_opt_z_ const wchar_t *, _In_opt_z_ const wchar_t *, unsigned int, uintptr_t);

#if !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE)
extern "C++"
#endif  /* !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE) */
_CRTIMP
void __cdecl _invoke_watson(_In_opt_z_ const wchar_t *, _In_opt_z_ const wchar_t *, _In_opt_z_ const wchar_t *, unsigned int, uintptr_t);

#ifndef _DEBUG
#if !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE)
extern "C++"
#endif  /* !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE) */
_CRTIMP
void __cdecl _invalid_parameter_noinfo(void);
#endif  /* _DEBUG */

/* Invoke Watson if _ExpressionError is not 0; otherwise simply return _EspressionError */
__forceinline
void _invoke_watson_if_error(
    errno_t _ExpressionError,
    const wchar_t *_Expression,
    const wchar_t *_Function,
    const wchar_t *_File,
    unsigned int _Line,
    uintptr_t _Reserved
    )
{
    if (_ExpressionError == 0)
    {
        return;
    }
    _invoke_watson(_Expression, _Function, _File, _Line, _Reserved);
}

/* Invoke Watson if _ExpressionError is not 0 and equal to _ErrorValue1 or _ErrorValue2; otherwise simply return _EspressionError */
__forceinline
errno_t _invoke_watson_if_oneof(
    errno_t _ExpressionError,
    errno_t _ErrorValue1,
    errno_t _ErrorValue2,
    const wchar_t *_Expression,
    const wchar_t *_Function,
    const wchar_t *_File,
    unsigned int _Line,
    uintptr_t _Reserved
    )
{
    if (_ExpressionError == 0 || (_ExpressionError != _ErrorValue1 && _ExpressionError != _ErrorValue2))
    {
        return _ExpressionError;
    }
    _invoke_watson(_Expression, _Function, _File, _Line, _Reserved);
    return _ExpressionError;
}

/*
 * Assert in debug builds.
 * set errno and return
 *
 */
#ifdef _DEBUG
#define _CALL_INVALID_PARAMETER_FUNC(funcname, expr) funcname(expr, __FUNCTIONW__, __FILEW__, __LINE__, 0)
#define _INVOKE_WATSON_IF_ERROR(expr) _invoke_watson_if_error((expr), __STR2WSTR(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0)
#define _INVOKE_WATSON_IF_ONEOF(expr, errvalue1, errvalue2) _invoke_watson_if_oneof(expr, (errvalue1), (errvalue2), __STR2WSTR(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0)
#else  /* _DEBUG */
#define _CALL_INVALID_PARAMETER_FUNC(funcname, expr) funcname(NULL, NULL, NULL, 0, 0)
#define _INVOKE_WATSON_IF_ERROR(expr) _invoke_watson_if_error(expr, NULL, NULL, NULL, 0, 0)
#define _INVOKE_WATSON_IF_ONEOF(expr, errvalue1, errvalue2) _invoke_watson_if_oneof((expr), (errvalue1), (errvalue2), NULL, NULL, NULL, 0, 0)
#endif  /* _DEBUG */

#define _INVALID_PARAMETER(expr) _CALL_INVALID_PARAMETER_FUNC(_invalid_parameter, expr)

#define _VALIDATE_RETURN_VOID( expr, errorcode )                               \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr));                              \
            return;                                                            \
        }                                                                      \
    }

/*
 * Assert in debug builds.
 * set errno and return value
 */

#ifndef _VALIDATE_RETURN
#define _VALIDATE_RETURN( expr, errorcode, retexpr )                           \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr) );                             \
            return ( retexpr );                                                \
        }                                                                      \
    }
#endif  /* _VALIDATE_RETURN */

#ifndef _VALIDATE_RETURN_NOEXC
#define _VALIDATE_RETURN_NOEXC( expr, errorcode, retexpr )                     \
    {                                                                          \
        if ( !(expr) )                                                         \
        {                                                                      \
            errno = errorcode;                                                 \
            return ( retexpr );                                                \
        }                                                                      \
    }
#endif  /* _VALIDATE_RETURN_NOEXC */

/*
 * Assert in debug builds.
 * set errno and set retval for later usage
 */

#define _VALIDATE_SETRET( expr, errorcode, retval, retexpr )                   \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr));                              \
            retval=( retexpr );                                                \
        }                                                                      \
    }

#define _CHECK_FH_RETURN( handle, errorcode, retexpr )                         \
    {                                                                          \
        if(handle == _NO_CONSOLE_FILENO)                                       \
        {                                                                      \
            errno = errorcode;                                                 \
            return ( retexpr );                                                \
        }                                                                      \
    }

/*
    We use _VALIDATE_STREAM_ANSI_RETURN to ensure that ANSI file operations(
    fprintf etc) aren't called on files opened as UNICODE. We do this check
    only if it's an actual FILE pointer & not a string
*/

#define _VALIDATE_STREAM_ANSI_RETURN( stream, errorcode, retexpr )                   \
    {                                                                                \
        FILE *_Stream=stream;                                                        \
        int fn;                                                                      \
        _VALIDATE_RETURN(( (_Stream->_flag & _IOSTRG) ||                             \
                           ( fn = _fileno(_Stream),                                  \
                             ( (_textmode_safe(fn) == __IOINFO_TM_ANSI) &&           \
                               !_tm_unicode_safe(fn)))),                             \
                         errorcode, retexpr)                                         \
    }

/*
    We use _VALIDATE_STREAM_ANSI_SETRET to ensure that ANSI file operations(
    fprintf etc) aren't called on files opened as UNICODE. We do this check
    only if it's an actual FILE pointer & not a string. It doesn't actually return
        immediately
*/

#define _VALIDATE_STREAM_ANSI_SETRET( stream, errorcode, retval, retexpr)            \
    {                                                                                \
        FILE *_Stream=stream;                                                        \
        int fn;                                                                      \
        _VALIDATE_SETRET(( (_Stream->_flag & _IOSTRG) ||                             \
                           ( fn = _fileno(_Stream),                                  \
                             ( (_textmode_safe(fn) == __IOINFO_TM_ANSI) &&           \
                               !_tm_unicode_safe(fn)))),                             \
                         errorcode, retval, retexpr)                                 \
    }

/*
 * Assert in debug builds.
 * Return value (do not set errno)
 */

#define _VALIDATE_RETURN_NOERRNO( expr, retexpr )                              \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            _INVALID_PARAMETER(_CRT_WIDE(#expr));                              \
            return ( retexpr );                                                \
        }                                                                      \
    }

/*
 * Assert in debug builds.
 * set errno and return errorcode
 */

#define _VALIDATE_RETURN_ERRCODE( expr, errorcode )                            \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr));                              \
            return ( errorcode );                                              \
        }                                                                      \
    }

#define _VALIDATE_RETURN_ERRCODE_NOEXC( expr, errorcode )                      \
    {                                                                          \
        if (!(expr))                                                           \
        {                                                                      \
            errno = errorcode;                                                 \
            return ( errorcode );                                              \
        }                                                                      \
    }

#define _VALIDATE_CLEAR_OSSERR_RETURN( expr, errorcode, retexpr )              \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            _doserrno = 0L;                                                    \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr) );                             \
            return ( retexpr );                                                \
        }                                                                      \
    }

#define _CHECK_FH_CLEAR_OSSERR_RETURN( handle, errorcode, retexpr )            \
    {                                                                          \
        if(handle == _NO_CONSOLE_FILENO)                                       \
        {                                                                      \
            _doserrno = 0L;                                                    \
            errno = errorcode;                                                 \
            return ( retexpr );                                                \
        }                                                                      \
    }

#define _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE( expr, errorcode )               \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            _doserrno = 0L;                                                    \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr));                              \
            return ( errorcode );                                              \
        }                                                                      \
    }

#define _CHECK_FH_CLEAR_OSSERR_RETURN_ERRCODE( handle, retexpr )               \
    {                                                                          \
        if(handle == _NO_CONSOLE_FILENO)                                       \
        {                                                                      \
            _doserrno = 0L;                                                    \
            return ( retexpr );                                                \
        }                                                                      \
    }

#ifdef _DEBUG
extern size_t __crtDebugFillThreshold;
#endif  /* _DEBUG */

#if !defined (_SECURECRT_FILL_BUFFER_THRESHOLD)
#ifdef _DEBUG
#define _SECURECRT_FILL_BUFFER_THRESHOLD __crtDebugFillThreshold
#else  /* _DEBUG */
#define _SECURECRT_FILL_BUFFER_THRESHOLD ((size_t)0)
#endif  /* _DEBUG */
#endif  /* !defined (_SECURECRT_FILL_BUFFER_THRESHOLD) */

#if _SECURECRT_FILL_BUFFER
#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)                            \
    if ((_Size) != ((size_t)-1) && (_Size) != INT_MAX &&                            \
        ((size_t)(_Offset)) < (_Size))                                              \
    {                                                                               \
        memset((_String) + (_Offset),                                               \
            _SECURECRT_FILL_BUFFER_PATTERN,                                         \
            (_SECURECRT_FILL_BUFFER_THRESHOLD < ((size_t)((_Size) - (_Offset))) ?   \
                _SECURECRT_FILL_BUFFER_THRESHOLD :                                  \
                ((_Size) - (_Offset))) * sizeof(*(_String)));                       \
    }
#else  /* _SECURECRT_FILL_BUFFER */
#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)
#endif  /* _SECURECRT_FILL_BUFFER */

#if _SECURECRT_FILL_BUFFER
#define _SECURECRT__FILL_BYTE(_Position)                \
    if (_SECURECRT_FILL_BUFFER_THRESHOLD > 0)           \
    {                                                   \
        (_Position) = _SECURECRT_FILL_BUFFER_PATTERN;   \
    }
#else  /* _SECURECRT_FILL_BUFFER */
#define _SECURECRT__FILL_BYTE(_Position)
#endif  /* _SECURECRT_FILL_BUFFER */

#ifdef __cplusplus
#define _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE extern "C"
#else  /* __cplusplus */
#define _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE
#endif  /* __cplusplus */

/* helper macros to redirect an mbs function to the corresponding _l version */
#define _REDIRECT_TO_L_VERSION_1(_ReturnType, _FunctionName, _Type1) \
    _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE \
    _ReturnType __cdecl _FunctionName(_Type1 _Arg1) \
    { \
        return _FunctionName##_l(_Arg1, NULL); \
    }

#define _REDIRECT_TO_L_VERSION_2(_ReturnType, _FunctionName, _Type1, _Type2) \
    _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE \
    _ReturnType __cdecl _FunctionName(_Type1 _Arg1, _Type2 _Arg2) \
    { \
        return _FunctionName##_l(_Arg1, _Arg2, NULL); \
    }

#define _REDIRECT_TO_L_VERSION_3(_ReturnType, _FunctionName, _Type1, _Type2, _Type3) \
    _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE \
    _ReturnType __cdecl _FunctionName(_Type1 _Arg1, _Type2 _Arg2, _Type3 _Arg3) \
    { \
        return _FunctionName##_l(_Arg1, _Arg2, _Arg3, NULL); \
    }

#define _REDIRECT_TO_L_VERSION_4(_ReturnType, _FunctionName, _Type1, _Type2, _Type3, _Type4) \
    _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE \
    _ReturnType __cdecl _FunctionName(_Type1 _Arg1, _Type2 _Arg2, _Type3 _Arg3, _Type4 _Arg4) \
    { \
        return _FunctionName##_l(_Arg1, _Arg2, _Arg3, _Arg4, NULL); \
    }

#define _REDIRECT_TO_L_VERSION_5(_ReturnType, _FunctionName, _Type1, _Type2, _Type3, _Type4, _Type5) \
    _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE \
    _ReturnType __cdecl _FunctionName(_Type1 _Arg1, _Type2 _Arg2, _Type3 _Arg3, _Type4 _Arg4, _Type5 _Arg5) \
    { \
        return _FunctionName##_l(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, NULL); \
    }

#define _REDIRECT_TO_L_VERSION_6(_ReturnType, _FunctionName, _Type1, _Type2, _Type3, _Type4, _Type5, _Type6) \
    _REDIRECT_TO_L_VERSION_FUNC_PROLOGUE \
    _ReturnType __cdecl _FunctionName(_Type1 _Arg1, _Type2 _Arg2, _Type3 _Arg3, _Type4 _Arg4, _Type5 _Arg5, _Type6 _Arg6) \
    { \
        return _FunctionName##_l(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, NULL); \
    }

/* internal helper functions for encoding and decoding pointers */
void __cdecl _init_pointers();
_CRTIMP void * __cdecl _encode_pointer(void *);
_CRTIMP void * __cdecl _encoded_null();
_CRTIMP void * __cdecl _decode_pointer(void *);

/* internal helper functions to wait and get module handle */
extern HMODULE _crt_waiting_on_module_handle(LPCWSTR szModuleName);

/***
*HMODULE _crt_wait_module_handle(LPCWSTR szModuleName)
*
*Purpose:
*   A help function.
*   Uses the same logic of _malloc_crt to load the specified module if the module is loaded failed by OOM
*
*Entry:
*   szModuleName - a pointer to the module name.
*
*Exit:
*   The module handle.
*
*Exceptions:
*
*******************************************************************************/
__forceinline HMODULE _crt_wait_module_handle(LPCWSTR szModuleName)
{
        HMODULE hMod = GetModuleHandleW(szModuleName);

        if(hMod)
        {
                return hMod;
        }
        return _crt_waiting_on_module_handle(szModuleName);
}

/* internal helper function for communicating with the debugger */
BOOL DebuggerKnownHandle();

/* Macros to simplify the use of Secure CRT in the CRT itself.
 * We should use [_BEGIN/_END]_SECURE_CRT_DEPRECATION_DISABLE sparingly.
 */
#define _BEGIN_SECURE_CRT_DEPRECATION_DISABLE \
    __pragma(warning(push)) \
    __pragma(warning(disable:4996)) \
    __pragma(warning(disable:6053))

#define _END_SECURE_CRT_DEPRECATION_DISABLE \
    __pragma(warning(pop))

#define _ERRCHECK(e) \
    _INVOKE_WATSON_IF_ERROR(e)

#define _ERRCHECK_EINVAL(e) \
    _INVOKE_WATSON_IF_ONEOF(e, EINVAL, EINVAL)

#define _ERRCHECK_EINVAL_ERANGE(e) \
    _INVOKE_WATSON_IF_ONEOF(e, EINVAL, ERANGE)

#define _ERRCHECK_SPRINTF(_PrintfCall) \
    { \
        errno_t _SaveErrno = errno; \
        errno = 0; \
        if ( ( _PrintfCall ) < 0) \
        { \
            _ERRCHECK_EINVAL_ERANGE(errno); \
        } \
        errno = _SaveErrno; \
    }

/* internal helper function to access environment variable in read-only mode */
const wchar_t * __cdecl _wgetenv_helper_nolock(const wchar_t *);
const char * __cdecl _getenv_helper_nolock(const char *);

/* internal helper routines used to query a PE image header. */
BOOL __cdecl _ValidateImageBase(PBYTE pImageBase);
PIMAGE_SECTION_HEADER __cdecl _FindPESection(PBYTE pImageBase, DWORD_PTR rva);
BOOL __cdecl _IsNonwritableInCurrentImage(PBYTE pTarget);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#define CRT_WARNING_DISABLE_PUSH(x,y)    __pragma(warning(push)); __pragma(warning(disable: x))
#define CRT_WARNING_POP                  __pragma(warning(pop))

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ioinit.c ===
/***
*ioinit.c - Initialization for lowio functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains initialization and termination routines for lowio.
*       Currently, this includes:
*           1. Initial allocation of array(s) of ioinfo structs.
*           2. Processing of inherited file info from parent process.
*           3. Special case initialization of the first three ioinfo structs,
*              the ones that correspond to handles 0, 1 and 2.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <internal.h>
#include <malloc.h>
#include <msdos.h>
#include <rterr.h>
#include <stddef.h>
#include <stdlib.h>
#include <dbgint.h>

/*
 * Special static ioinfo structure. This is referred to only by the
 * _pioinfo_safe() macro, and its derivatives, in internal.h. These, in turn
 * are used in certain stdio-level functions to more gracefully handle a FILE
 * with -1 in the _file field.
 */
_CRTIMP ioinfo __badioinfo = {
        (intptr_t)(-1), /* osfhnd */
        (char)FTEXT,          /* osfile */
        10,             /* pipech */
        0               /* lockinitflag */
        };

/*
 * Number of ioinfo structs allocated at any given time. This number ranges
 * from a minimum of IOINFO_ARRAY_ELTS to a maximum of _NHANDLE_ (==
 * IOINFO_ARRAY_ELTS * IOINFO_ARRAYS) in steps of IOINFO_ARRAY_ELTS.
 */
int _nhandle;

/*
 * Array of pointers to arrays of ioinfo structs.
 */
_CRTIMP ioinfo * __pioinfo[IOINFO_ARRAYS];

/*
 * macro used to map 0, 1 and 2 to right value for call to GetStdHandle
 */
#define stdhndl(fh)  ( (fh == 0) ? STD_INPUT_HANDLE : ((fh == 1) ? \
                       STD_OUTPUT_HANDLE : STD_ERROR_HANDLE) )

/***
*_ioinit() -
*
*Purpose:
*       Allocates and initializes initial array(s) of ioinfo structs. Then,
*       obtains and processes information on inherited file handles from the
*       parent process (e.g., cmd.exe).
*
*       Obtains the StartupInfo structure from the OS. The inherited file
*       handle information is pointed to by the lpReserved2 field. The format
*       of the information is as follows:
*
*           bytes 0 thru 3          - integer value, say N, which is the
*                                     number of handles information is passed
*                                     about
*
*           bytes 4 thru N+3        - the N values for osfile
*
*           bytes N+4 thru 5*N+3    - N double-words, the N OS HANDLE values
*                                     being passed
*
*       Next, osfhnd and osfile for the first three ioinfo structs,
*       corrsponding to handles 0, 1 and 2, are initialized as follows:
*
*           If the value in osfhnd is INVALID_HANDLE_VALUE, then try to
*           obtain a HANDLE by calling GetStdHandle, and call GetFileType to
*           help set osfile. Otherwise, assume _osfhndl and _osfile are
*           valid, but force it to text mode (standard input/output/error
*           are to always start out in text mode).
*
*       Notes:
*           1. In general, not all of the passed info from the parent process
*              will describe open handles! If, for example, only C handle 1
*              (STDOUT) and C handle 6 are open in the parent, info for C
*              handles 0 thru 6 is passed to the the child.
*
*           2. Care is taken not to 'overflow' the arrays of ioinfo structs.
*
*           3. See exec\dospawn.c for the encoding of the file handle info
*              to be passed to a child process.
*
*Entry:
*       No parameters: reads the STARTUPINFO structure.
*
*Exit:
*       0 on success, -1 if error encountered
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _ioinit (
        void
        )
{
        STARTUPINFO StartupInfo;
        int cfi_len;
        int fh;
        int i;
        ioinfo *pio;
        char *posfile;
        UNALIGNED intptr_t *posfhnd;
        intptr_t stdfh;
        DWORD htype;

        __try {
                        /*
                        Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so
                        the very general exception handler below is appropriate
                        */
            GetStartupInfo( &StartupInfo );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return -1;
        }

        /*
         * Allocate and initialize the first array of ioinfo structs. This
         * array is pointed to by __pioinfo[0]
         */
        if ( (pio = _calloc_crt( IOINFO_ARRAY_ELTS, sizeof(ioinfo) ))
             == NULL )
        {
            return -1;
        }

        __pioinfo[0] = pio;
        _nhandle = IOINFO_ARRAY_ELTS;

        for ( ; pio < __pioinfo[0] + IOINFO_ARRAY_ELTS ; pio++ ) {
            pio->osfile = 0;
            pio->osfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            pio->pipech = 10;                   /* linefeed/newline char */
            pio->lockinitflag = 0;              /* uninitialized lock */
            pio->textmode = 0;
            pio->unicode = 0;
            pio->pipech2[0] = 10;
            pio->pipech2[1] = 10;
            pio->dbcsBufferUsed = FALSE;
            pio->dbcsBuffer = '\0';
        }

        /*
         * Process inherited file handle information, if any
         */

        if ( (StartupInfo.cbReserved2 != 0) &&
             (StartupInfo.lpReserved2 != NULL) )
        {
            /*
             * Get the number of handles inherited.
             */
            cfi_len = *(UNALIGNED int *)(StartupInfo.lpReserved2);

            /*
             * Set pointers to the start of the passed file info and OS
             * HANDLE values.
             */
            posfile = (char *)(StartupInfo.lpReserved2) + sizeof( int );
            posfhnd = (UNALIGNED intptr_t *)(posfile + cfi_len);

            /*
             * Ensure cfi_len does not exceed the number of supported
             * handles!
             */
            cfi_len = __min( cfi_len, _NHANDLE_ );

            /*
             * Allocate sufficient arrays of ioinfo structs to hold inherited
             * file information.
             */
            for ( i = 1 ; _nhandle < cfi_len ; i++ ) {

                /*
                 * Allocate another array of ioinfo structs
                 */
                if ( (pio = _calloc_crt( IOINFO_ARRAY_ELTS, sizeof(ioinfo) ))
                    == NULL )
                {
                    /*
                     * No room for another array of ioinfo structs, reduce
                     * the number of inherited handles we process.
                     */
                    cfi_len = _nhandle;
                    break;
                }

                /*
                 * Update __pioinfo[] and _nhandle
                 */
                __pioinfo[i] = pio;
                _nhandle += IOINFO_ARRAY_ELTS;

                for ( ; pio < __pioinfo[i] + IOINFO_ARRAY_ELTS ; pio++ ) {
                    pio->osfile = 0;
                    pio->osfhnd = (intptr_t)INVALID_HANDLE_VALUE;
                    pio->pipech = 10;
                    pio->lockinitflag = 0;
                    pio->textmode = 0;
                    pio->pipech2[0] = 10;
                    pio->pipech2[1] = 10;
                    pio->dbcsBufferUsed = FALSE;
                    pio->dbcsBuffer = '\0';
                }
            }

            /*
             * Validate and copy the passed file information
             */
            for ( fh = 0 ; fh < cfi_len ; fh++, posfile++, posfhnd++ ) {
                /*
                 * Copy the passed file info iff it appears to describe
                 * an open, valid file or device.
                 *
                 * Note that GetFileType cannot be called for pipe handles
                 * since it may 'hang' if there is blocked read pending on
                 * the pipe in the parent.
                 */
                if ( (*posfhnd != (intptr_t)INVALID_HANDLE_VALUE) &&
                     (*posfhnd != _NO_CONSOLE_FILENO) &&
                     (*posfile & FOPEN) &&
                     ((*posfile & FPIPE) ||
                      (GetFileType( (HANDLE)*posfhnd ) != FILE_TYPE_UNKNOWN)) )
                {
                    pio = _pioinfo( fh );
                    pio->osfhnd = *posfhnd;
                    pio->osfile = *posfile;
                    /* Allocate the lock for this handle. */
                    if ( !__crtInitCritSecAndSpinCount( &pio->lock,
                                                        _CRT_SPINCOUNT ))
                        return -1;
                    pio->lockinitflag++;
                }
            }
        }

        /*
         * If valid HANDLE-s for standard input, output and error were not
         * inherited, try to obtain them directly from the OS. Also, set the
         * appropriate bits in the osfile fields.
         */
        for ( fh = 0 ; fh < 3 ; fh++ ) {

            pio = __pioinfo[0] + fh;

            if ( (pio->osfhnd == (intptr_t)INVALID_HANDLE_VALUE) ||
                 (pio->osfhnd == _NO_CONSOLE_FILENO)) {
                /*
                 * mark the handle as open in text mode.
                 */
                pio->osfile = (char)(FOPEN | FTEXT);

                if ( ((stdfh = (intptr_t)GetStdHandle( stdhndl(fh) )) != (intptr_t)INVALID_HANDLE_VALUE) &&
                     (stdfh!=((intptr_t)NULL)) &&
                     ((htype = GetFileType( (HANDLE)stdfh )) != FILE_TYPE_UNKNOWN) )
                {
                    /*
                     * obtained a valid HANDLE from GetStdHandle
                     */
                    pio->osfhnd = stdfh;

                    /*
                     * finish setting osfile: determine if it is a character
                     * device or pipe.
                     */
                    if ( (htype & 0xFF) == FILE_TYPE_CHAR )
                        pio->osfile |= FDEV;
                    else if ( (htype & 0xFF) == FILE_TYPE_PIPE )
                        pio->osfile |= FPIPE;

                    /* Allocate the lock for this handle. */
                    if ( !__crtInitCritSecAndSpinCount( &pio->lock,
                                                        _CRT_SPINCOUNT ))
                        return -1;
                    pio->lockinitflag++;
                }
                else {
                    /*
                     * For stdin, stdout & stderr, if there is no valid HANDLE,
                     * treat the CRT handle as being open in text mode on a
                     * device with _NO_CONSOLE_FILENO underlying it. We use this
                     * value different from _INVALID_HANDLE_VALUE to distinguish
                     * between a failure in opening a file & a program run
                     * without a console.
                     */
                    pio->osfile |= FDEV;
                    pio->osfhnd = _NO_CONSOLE_FILENO;
                }
            }
            else  {
                /*
                 * handle was passed to us by parent process. make
                 * sure it is text mode.
                 */
                pio->osfile |= FTEXT;
            }
        }

        /*
         * Set the number of supported HANDLE-s to _nhandle
         */
        (void)SetHandleCount( (unsigned)_nhandle );

        return 0;
}


/***
*_ioterm() -
*
*Purpose:
*       Free the memory holding the ioinfo arrays.
*
*       In the multi-thread case, first walk each array of ioinfo structs and
*       delete any all initialized critical sections (locks).
*
*Entry:
*       No parameters.
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _ioterm (
        void
        )
{
        int i;
        ioinfo *pio;

        for ( i = 0 ; i < IOINFO_ARRAYS ; i++ ) {

            if ( __pioinfo[i] != NULL ) {
                /*
                 * Delete any initialized critical sections.
                 */
                for ( pio = __pioinfo[i] ;
                      pio < __pioinfo[i] + IOINFO_ARRAY_ELTS ;
                      pio++ )
                {
                    if ( pio->lockinitflag )
                        DeleteCriticalSection( &(pio->lock) );
                }
                /*
                 * Free the memory which held the ioinfo array.
                 */
                _free_crt( __pioinfo[i] );
                __pioinfo[i] = NULL;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbalnm.c ===
/***
*ismbalnm - Test if character is alpha numeric (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is alpha numeric (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>


/***
* _ismbcalnum - Test if character is alpha numeric (MBCS)
*
*Purpose:
*       Test if the supplied character is alpha numeric or not.
*       Handles MBCS characters correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if c is an alpha numeric character; else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcalnum_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    if (c > 0x00FF)
    {


        char buf[2];
        unsigned short ctype[2] = {0};

        buf[0] = (c >> 8) & 0xFF;
        buf[1] = c & 0xFF;


        /* return FALSE if not in supported MB code page */
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

        /*
         * Since 'c' could be two one-byte MB chars, we need room in the
         * ctype return array to handle this. In this case, the
         * second word in the return array will be non-zero.
         */

        if ( __crtGetStringTypeA(
                    NULL,
                    CT_CTYPE1,
                    buf,
                    2,
                    ctype,
                    _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                    _loc_update.GetLocaleT()->mbcinfo->mblcid,
                    TRUE ) == 0 )
            return 0;

        /* ensure single MB character and test for type */
        return (ctype[1] == 0 && ctype[0] & (_ALPHA|_DIGIT));


    }
    else
    {
        return _ismbbalnum_l( c, _loc_update.GetLocaleT());
    }
}

extern "C" int (__cdecl _ismbcalnum)(
        unsigned int c
        )
{
        return _ismbcalnum_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\invarg.c ===
/***
*invarg.c - stub for invalid argument handler
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines _invalidarg() and _set_invalid_parameter_handler()
*
*******************************************************************************/

#include <ntstatus.h>
#define WIN32_NO_STATUS // so it won't fire duplicate macro definition in winnt.h
#include <cruntime.h>
#include <sect_attribs.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>
#include <windows.h>
#include <dbgint.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

void * _ReturnAddress(void);
#pragma intrinsic(_ReturnAddress)

#if defined (_X86_) || defined (_AMD64_)
void * _AddressOfReturnAddress(void);
#pragma intrinsic(_AddressOfReturnAddress)
#endif  /* defined (_X86_) || defined (_AMD64_) */

#if defined (_AMD64_)

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG64 ControlPc,
    OUT PULONG64 ImageBase,
    IN OUT PVOID HistoryTable OPTIONAL
    );

PVOID
RtlVirtualUnwind (
    IN ULONG HandlerType,
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PVOID *HandlerData,
    OUT PULONG64 EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL
    );

#define UNW_FLAG_NHANDLER 0x00

#endif  /* defined (_AMD64_) */

/* global variable which stores the user handler */

_invalid_parameter_handler __pInvalidArgHandler;

extern "C"
void _initp_misc_invarg(void* enull)
{
    __pInvalidArgHandler = (_invalid_parameter_handler) enull;
}

/***
*void _invalid_arg() -
*
*Purpose:
*   Called when an invalid argument is passed into a CRT function
*
*Entry:
*   pszExpression - validation expression (can be NULL)
*   pszFunction - function name (can be NULL)
*   pszFile - file name (can be NULL)
*   nLine - line number
*   pReserved - reserved for future use
*
*Exit:
*   return from this function results in error being returned from the function
*   that called the handler
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl _invalid_parameter(
    const wchar_t *pszExpression,
    const wchar_t *pszFunction,
    const wchar_t *pszFile,
    unsigned int nLine,
    uintptr_t pReserved
    )
{
    _invalid_parameter_handler pHandler = __pInvalidArgHandler;

    pszExpression;
    pszFunction;
    pszFile;

    pHandler = (_invalid_parameter_handler) _decode_pointer(pHandler);
    if (pHandler != NULL)
    {
        pHandler(pszExpression, pszFunction, pszFile, nLine, pReserved);
        return;
    }

    // No user handler is defined. Notify the debugger if attached.

    _CRT_DEBUGGER_HOOK(_CRT_DEBUGGER_INVALIDPARAMETER);

    _invoke_watson(pszExpression, pszFunction, pszFile, nLine, pReserved);
}

#ifndef _DEBUG

/* wrapper which passes no debug info; not available in debug
 * used in inline code: we don't pass the null params, so we gain some
 * speed and space in code generation
 */
_CRTIMP void __cdecl _invalid_parameter_noinfo(void)
{
    _invalid_parameter(NULL, NULL, NULL, 0, 0);
}

#endif  /* _DEBUG */

_CRTIMP void __cdecl _invoke_watson(
    const wchar_t *pszExpression,
    const wchar_t *pszFunction,
    const wchar_t *pszFile,
    unsigned int nLine,
    uintptr_t pReserved
    )
{
    /* Fake an exception to call reportfault. */
    EXCEPTION_RECORD   ExceptionRecord = {0};
    CONTEXT ContextRecord;
    EXCEPTION_POINTERS ExceptionPointers = {&ExceptionRecord, &ContextRecord};
    BOOL wasDebuggerPresent = FALSE;
    DWORD ret = 0;

    (pszExpression);
    (pszFunction);
    (pszFile);
    (nLine);
    (pReserved);

#ifdef _X86_

    __asm {
        mov dword ptr [ContextRecord.Eax], eax
        mov dword ptr [ContextRecord.Ecx], ecx
        mov dword ptr [ContextRecord.Edx], edx
        mov dword ptr [ContextRecord.Ebx], ebx
        mov dword ptr [ContextRecord.Esi], esi
        mov dword ptr [ContextRecord.Edi], edi
        mov word ptr [ContextRecord.SegSs], ss
        mov word ptr [ContextRecord.SegCs], cs
        mov word ptr [ContextRecord.SegDs], ds
        mov word ptr [ContextRecord.SegEs], es
        mov word ptr [ContextRecord.SegFs], fs
        mov word ptr [ContextRecord.SegGs], gs
        pushfd
        pop [ContextRecord.EFlags]
    }

    ContextRecord.ContextFlags = CONTEXT_CONTROL;
#pragma warning(push)
#pragma warning(disable:4311)
    ContextRecord.Eip = (ULONG)_ReturnAddress();
    ContextRecord.Esp = (ULONG)_AddressOfReturnAddress();
#pragma warning(pop)
    ContextRecord.Ebp = *((ULONG *)_AddressOfReturnAddress()-1);

#elif defined (_AMD64_)

    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;

    RtlCaptureContext(&ContextRecord);
    ControlPc = ContextRecord.Rip;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, NULL);
    if (FunctionEntry != NULL) {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                         ImageBase,
                         ControlPc,
                         FunctionEntry,
                         &ContextRecord,
                         &HandlerData,
                         &EstablisherFrame,
                         NULL);
    } else {
        ContextRecord.Rip = (ULONGLONG) _ReturnAddress();
        ContextRecord.Rsp = (ULONGLONG) _AddressOfReturnAddress();
    }

#elif defined (_IA64_)

    /* Need to fill up the Context in IA64. */
    RtlCaptureContext(&ContextRecord);

#else  /* defined (_IA64_) */

    ZeroMemory(&ContextRecord, sizeof(ContextRecord));

#endif  /* defined (_IA64_) */


    ExceptionRecord.ExceptionCode = STATUS_INVALID_CRUNTIME_PARAMETER;
    ExceptionRecord.ExceptionFlags    = EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionAddress = _ReturnAddress();


    wasDebuggerPresent = IsDebuggerPresent();

    /* Make sure any filter already in place is deleted. */
    SetUnhandledExceptionFilter(NULL);

    ret = UnhandledExceptionFilter(&ExceptionPointers);

    // if no handler found and no debugger previously attached
    // the execution must stop into the debugger hook.
    if (ret == EXCEPTION_CONTINUE_SEARCH && !wasDebuggerPresent) {
        _CRT_DEBUGGER_HOOK(_CRT_DEBUGGER_INVALIDPARAMETER);
    }

    TerminateProcess(GetCurrentProcess(), STATUS_INVALID_CRUNTIME_PARAMETER);
}

/***
*void _set_invalid_parameter_handler(void) -
*
*Purpose:
*       Establish a handler to be called when a CRT detects a invalid parameter
*
*       This function is not thread-safe
*
*Entry:
*   New handler
*
*Exit:
*   Old handler
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP _invalid_parameter_handler __cdecl
_set_invalid_parameter_handler( _invalid_parameter_handler pNew )
{
    _invalid_parameter_handler pOld = NULL;

    pOld = __pInvalidArgHandler;
    pOld = (_invalid_parameter_handler) _decode_pointer((PVOID)pOld);
    pNew = (_invalid_parameter_handler) _encode_pointer((PVOID)pNew);

    __pInvalidArgHandler = pNew;

    return pOld;
}

_CRTIMP _invalid_parameter_handler __cdecl
_get_invalid_parameter_handler( )
{
    _invalid_parameter_handler pOld = NULL;

    pOld = __pInvalidArgHandler;
    pOld = (_invalid_parameter_handler) _decode_pointer((PVOID)pOld);

    return pOld;
}

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef __cplusplus

#if defined (_NATIVE_WCHAR_T_DEFINED)
/*
unsigned short -> wchar_t
This is defined as a real function rather than an alias because the parameter types
are different in the two versions which means different metadata is required when building /clr apps.
*/
extern "C++" _CRTIMP void __cdecl _invalid_parameter(
    const unsigned short * pszExpression,
    const unsigned short * pszFunction,
    const unsigned short * pszFile,
    unsigned int nLine,
    uintptr_t pReserved
    )
{
    _invalid_parameter(
        reinterpret_cast<const wchar_t *>(pszExpression),
        reinterpret_cast<const wchar_t *>(pszFunction),
        reinterpret_cast<const wchar_t *>(pszFile),
        nLine,
        pReserved
        );
}

extern "C++" void __cdecl _invoke_watson(
    const unsigned short * pszExpression,
    const unsigned short * pszFunction,
    const unsigned short * pszFile,
    unsigned int nLine,
    uintptr_t pReserved
    )
{
    _invoke_watson(
        reinterpret_cast<const wchar_t *>(pszExpression),
        reinterpret_cast<const wchar_t *>(pszFunction),
        reinterpret_cast<const wchar_t *>(pszFile),
        nLine,
        pReserved
        );
}

#endif  /* defined (_NATIVE_WCHAR_T_DEFINED) */

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\iosptrs.cpp ===
// iosptrs -- iostream object pointers for Microsoft
#include <iostream>
_STD_BEGIN

#if defined(_M_CEE) && !defined(_M_CEE_MIXED)
#error This file cannot be built /clr:pure, etc. because of the use of _PGLOBAL.
#endif

#pragma warning(disable:4439)	// C4439: function with a managed parameter must have a __clrcall calling convention

#pragma warning(disable: 4074)
#pragma init_seg(compiler)
_PGLOBAL static std::_Init_locks initlocks;

		// OBJECT DECLARATIONS
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 istream *_Ptr_cin = 0;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream *_Ptr_cout = 0;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream *_Ptr_cerr = 0;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream *_Ptr_clog = 0;

		// WIDE OBJECTS
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wistream *_Ptr_wcin = 0;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream *_Ptr_wcout = 0;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream *_Ptr_wcerr = 0;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream *_Ptr_wclog = 0;
_STD_END

_C_STD_BEGIN
		// FINALIZATION CODE
#define NATS	10	/* fclose, xgetloc, locks, facet free, etc. */

		/* static data */
__PURE_APPDOMAIN_GLOBAL static void (__cdecl* atfuns_cdecl[NATS])(void) = {0};
__PURE_APPDOMAIN_GLOBAL static size_t atcount_cdecl = {NATS};
_MRTIMP2 void __cdecl _Atexit(void (__cdecl *pf)())
	{	// add to wrapup list
	if (atcount_cdecl == 0)
		abort();	/* stack full, give up */
	else
		atfuns_cdecl[--atcount_cdecl] = pf;
	}

struct _Init_atexit
	{	// controller for atexit processing
	__CLR_OR_THIS_CALL ~_Init_atexit()
		{	// process wrapup functions
		while (atcount_cdecl < NATS)
			if (atfuns_cdecl[atcount_cdecl++])
                (*atfuns_cdecl[atcount_cdecl-1])();
		}
	};

__PURE_APPDOMAIN_GLOBAL static _Init_atexit init_atexit;

char _PJP_CPP_Copyright[] =
	"Copyright (c) 1992-2004 by P.J. Plauger,"
	" licensed by Dinkumware, Ltd."
	" ALL RIGHTS RESERVED.";
_C_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ios.cpp ===
// ios_base -- ios_base basic members
#include <new>
#include <xdebug>
#include <xiosbase>
_STD_BEGIN

#define NSTDSTR	8	/* cin, wcin, cout, wcout, cerr, wcerr, clog, wclog */

_PGLOBAL _CRTDATA2 const streamoff _BADOFF = -1;	// initialize constant for bad file offset
_PGLOBAL _CRTDATA2 fpos_t _Fpz = {0};	// initialize constant for beginning of file

_MRTIMP2 fpos_t& __cdecl _Fpz_func()
{
    return _Fpz;
}

_MRTIMP2 const streamoff& __cdecl _BADOFF_func()
{
    return _BADOFF;
}

__PURE_APPDOMAIN_GLOBAL int ios_base::_Index = 0;	// initialize source of unique indexes
__PURE_APPDOMAIN_GLOBAL bool ios_base::_Sync = true;	// initialize synchronization flag
_MRTIMP2 int& ios_base::_Index_func()
{
    return ios_base::_Index;
}
_MRTIMP2 bool& ios_base::_Sync_func()
{
    return ios_base::_Sync;
}

__PURE_APPDOMAIN_GLOBAL static ios_base *stdstr[NSTDSTR + 2] =
	{0};	// [1, NSTDSTR] hold pointers to standard streams
__PURE_APPDOMAIN_GLOBAL static char stdopens[NSTDSTR + 2] =
	{0};	// [1, NSTDSTR] hold open counts for standard streams

//void __CLR_OR_THIS_CALL ios_base::clear(iostate state, bool reraise)
//	{	// set state, possibly reraise exception
//	_Mystate = (iostate)(state & _Statmask);
//	if ((_Mystate & _Except) == 0)
//		;
//	else if (reraise)
//		_RERAISE;
//	else if (_Mystate & _Except & badbit)
//		_THROW(failure, "ios_base::badbit set");
//	else if (_Mystate & _Except & failbit)
//		_THROW(failure, "ios_base::failbit set");
//	else
//		_THROW(failure, "ios_base::eofbit set");
//	}

_MRTIMP2_NPURE void __cdecl ios_base::_Ios_base_dtor(ios_base *_This)
	{	// destroy the object
	if (0 < _This->_Stdstr && 0 < --stdopens[_This->_Stdstr])
		return;
	_This->_Tidy();
	_DELETE_CRT(_This->_Ploc);
	}

//ios_base::_Iosarray& __CLR_OR_THIS_CALL ios_base::_Findarr(int idx)
//	{	// locate or make a variable array element
//	static _Iosarray stub(0, 0);
//	_Iosarray *p, *q;
//
//	if (idx < 0)
//		{	// handle bad index
//		setstate(badbit);
//		return (stub);
//		}
//
//	for (p = _Arr, q = 0; p != 0; p = p->_Next)
//		if (p->_Index == idx)
//			return (*p);	// found element, return it
//		else if (q == 0 && p->_Lo == 0 && p->_Vp == 0)
//			q = p;	// found recycling candidate
//
//	if (q != 0)
//		{	// recycle existing element
//		q->_Index = idx;
//		return (*q);
//		}
//
//	_Arr = _NEW_CRT _Iosarray(idx, _Arr);	// make a new element
//	return (*_Arr);
//	}

_MRTIMP2_NPURE void __cdecl ios_base::_Addstd(ios_base *_This)
	{	// add standard stream to destructor list
	_BEGIN_LOCK(_LOCK_STREAM)
		for (_This->_Stdstr = 0; ++_This->_Stdstr < NSTDSTR; )
			if (stdstr[_This->_Stdstr] == 0 || stdstr[_This->_Stdstr] == _This)
				break;	// found a candidate

		stdstr[_This->_Stdstr] = _This;
		++stdopens[_This->_Stdstr];
	_END_LOCK()
	}

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbbyte.c ===
/***
*ismbbyte.c - Function versions of MBCS ctype macros
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This files provides function versions of the character
*       classification a*d conversion macros in mbctype.h.
*
*******************************************************************************/

#ifdef _MBCS

#include <cruntime.h>
#include <ctype.h>
#include <mtdll.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>

/* defined in mbctype.h
; Define masks

; set bit masks for the possible kanji character types
; (all MBCS bit masks start with "_M")

_MS             equ     01h     ; MBCS non-ascii single byte char
_MP             equ     02h     ; MBCS punct
_M1             equ     04h     ; MBCS 1st (lead) byte
_M2             equ     08h     ; MBCS 2nd byte

*/

/* defined in ctype.h
; set bit masks for the possible character types

_UPPER          equ     01h     ; upper case letter
_LOWER          equ     02h     ; lower case letter
_DIGIT          equ     04h     ; digit[0-9]
_SPACE          equ     08h     ; tab, carriage return, newline,
                                ; vertical tab or form feed
_PUNCT          equ     10h     ; punctuation character
_CONTROL        equ     20h     ; control character
_BLANK          equ     40h     ; space char
_HEX            equ     80h     ; hexadecimal digit

*/

/* defined in ctype.h, mbdata.h
        extrn   __mbctype:byte          ; MBCS ctype table
        extrn   __ctype_:byte           ; ANSI/ASCII ctype table
*/


/***
* ismbbyte - Function versions of mbctype macros
*
*Purpose:
*
*Entry:
*       int = character to be tested
*Exit:
*       ax = non-zero = character is of the requested type
*          =        0 = character is NOT of the requested type
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl x_ismbbtype_l(_locale_t plocinfo, unsigned int, int, int);


/* ismbbk functions */

extern "C" int (__cdecl _ismbbkalnum_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,0,_MS);
}

extern "C" int (__cdecl _ismbbkalnum) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,0,_MS);
}

extern "C" int (__cdecl _ismbbkprint_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,0,(_MS | _MP));
}

extern "C" int (__cdecl _ismbbkprint) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,0,(_MS | _MP));
}

extern "C" int (__cdecl _ismbbkpunct_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,0,_MP);
}

extern "C" int (__cdecl _ismbbkpunct) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,0,_MP);
}


/* ismbb functions */

extern "C" int (__cdecl _ismbbalnum_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,(_ALPHA | _DIGIT), _MS);
}

extern "C" int (__cdecl _ismbbalnum) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,(_ALPHA | _DIGIT), _MS);
}

extern "C" int (__cdecl _ismbbalpha_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,_ALPHA, _MS);
}

extern "C" int (__cdecl _ismbbalpha) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,_ALPHA, _MS);
}

extern "C" int (__cdecl _ismbbgraph_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,(_PUNCT | _ALPHA | _DIGIT),(_MS | _MP));
}

extern "C" int (__cdecl _ismbbgraph) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,(_PUNCT | _ALPHA | _DIGIT),(_MS | _MP));
}

extern "C" int (__cdecl _ismbbprint_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,(_BLANK | _PUNCT | _ALPHA | _DIGIT),(_MS | _MP));
}

extern "C" int (__cdecl _ismbbprint) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,(_BLANK | _PUNCT | _ALPHA | _DIGIT),(_MS | _MP));
}

extern "C" int (__cdecl _ismbbpunct_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,_PUNCT, _MP);
}

extern "C" int (__cdecl _ismbbpunct) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,_PUNCT, _MP);
}


/* lead and trail */

extern "C" int (__cdecl _ismbblead_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,0,_M1);
}

extern "C" int (__cdecl _ismbblead) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,0,_M1);
}

extern "C" int (__cdecl _ismbbtrail_l) (unsigned int tst, _locale_t plocinfo)
{
        return x_ismbbtype_l(plocinfo,tst,0,_M2);
}

extern "C" int (__cdecl _ismbbtrail) (unsigned int tst)
{
        return x_ismbbtype_l(NULL,tst,0,_M2);
}


/* 932 specific */

extern "C" int (__cdecl _ismbbkana_l) (unsigned int tst, _locale_t plocinfo)
{
    _LocaleUpdate _loc_update(plocinfo);
    if(_loc_update.GetLocaleT()->mbcinfo &&
       _loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP)
    {
        return x_ismbbtype_l(plocinfo,tst,0,(_MS | _MP));
    }
    return FALSE;
}

extern "C" int (__cdecl _ismbbkana) (unsigned int tst)
{
    return _ismbbkana_l(tst, NULL);
}

/***
* Common code
*
*      cmask = mask for _ctype[] table
*      kmask = mask for _mbctype[] table
*
*******************************************************************************/

static int __cdecl x_ismbbtype_l (_locale_t plocinfo, unsigned int tst, int cmask, int kmask)
{
    _LocaleUpdate _loc_update(plocinfo);

    /*
     * get input character and make sure < 256
     */
        tst = (unsigned int)(unsigned char)tst;

        return  ((*(_loc_update.GetLocaleT()->mbcinfo->mbctype+1+tst)) & kmask) ||
                ((cmask) ? ((*(_loc_update.GetLocaleT()->locinfo->pctype+tst)) & cmask) : 0);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbdgt.c ===
/***
*ismbdgt.c - Test if character is a digit (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is a digit (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <cruntime.h>
#include <ctype.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <mtdll.h>
#include <mbdata.h>
#include <setlocal.h>


/***
* _ismbcdigit - Test if character is a digit (MBCS)
*
*Purpose:
*       Tests the character to see if it is a digit.
*       Handles MBCS chars correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int *c = character to test
*
*Exit:
*       Returns TRUE if character is a digit, else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcdigit_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    if (c > 0x00FF)
    {


        char buf[2];
        unsigned short ctype[2] = {0};


        buf[0] = (c >> 8) & 0xFF;
        buf[1] = c & 0xFF;

        /* return FALSE if not in supported MB code page */
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return 0;

        /*
         * Since 'c' could be two one-byte MB chars, we need room in the
         * ctype return array to handle this. In this case, the
         * second word in the return array will be non-zero.
         */

        if ( __crtGetStringTypeA(
                    _loc_update.GetLocaleT(),
                    CT_CTYPE1,
                    buf,
                    2,
                    ctype,
                    _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                    _loc_update.GetLocaleT()->mbcinfo->mblcid,
                    TRUE) == 0)
            return 0;

        /* ensure single MB character and test for type */
        return (ctype[1] == 0 && ctype[0] & (_DIGIT));


    } else
    {
        return _isdigit_l(c, _loc_update.GetLocaleT());
    }
}

extern "C" int (__cdecl _ismbcdigit)(
        unsigned int c
        )
{
       return _ismbcdigit_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbgrph.c ===
/***
*ismbgrph - Test if character is graphical (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is graphical (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _ismbcgraph - Test if character is graphical (MBCS)
*
*Purpose:
*       Test if the supplied character is graphical or not.
*       Handles MBCS characters correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if c is an graphical character; else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcgraph_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    if (c > 0x00FF)
    {


        char buf[2];
        unsigned short ctype[2] = {0};

        buf[0] = (c >> 8) & 0xFF;
        buf[1] = c & 0xFF;

        /* return FALSE if not in supported MB code page */
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return 0;

        /*
         * Since 'c' could be two one-byte MB chars, we need room in the
         * ctype return array to handle this. In this case, the
         * second word in the return array will be non-zero.
         */

        if ( __crtGetStringTypeA(
                    _loc_update.GetLocaleT(),
                    CT_CTYPE1,
                    buf,
                    2,
                    ctype,
                    _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                    _loc_update.GetLocaleT()->mbcinfo->mblcid,
                    TRUE) == 0 )
            return 0;

        /* ensure single MB character and test for type */
        return (ctype[1] == 0 && ctype[0] & (_PUNCT|_ALPHA|_DIGIT));


    } else
    {
        return _ismbbgraph_l( c, _loc_update.GetLocaleT());
    }
}

extern "C" int (__cdecl _ismbcgraph)(
        unsigned int c
        )
{
        return _ismbcgraph_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbknj.c ===
/***
*ismbcknj.c - contains the Kanji specific is* functions.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Provide non-portable Kanji support for MBCS libs.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <locale.h>
#include <setlocal.h>


/***
*int _ismbchira(c) - test character for hiragana (Japanese)
*
*Purpose:
*       Test if the character c is a hiragana character.
*
*Entry:
*       unsigned int c - character to test
*
*Exit:
*       returns TRUE if CP == KANJI and character is hiragana, else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbchira_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return(_loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP && c >= 0x829f && c <= 0x82f1);
}

extern "C" int __cdecl _ismbchira(
        unsigned int c
        )
{
    return _ismbchira_l(c, NULL);
}


/***
*int _ismbckata(c) - test character for katakana (Japanese)
*
*Purpose:
*       Tests to see if the character c is a katakana character.
*
*Entry:
*       unsigned int c - character to test
*
*Exit:
*       Returns TRUE if CP == KANJI and c is a katakana character, else FALSE.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbckata_l (
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return(_loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP && c >= 0x8340 && c <= 0x8396 && c != 0x837f);
}
extern "C" int __cdecl _ismbckata(
        unsigned int c
        )
{
    return _ismbckata_l(c, NULL);
}


/***
*int _ismbcsymbol(c) - Tests if char is punctuation or symbol of Microsoft Kanji
*                  code.
*
*Purpose:
*       Returns non-zero if the character is kanji punctuation.
*
*Entry:
*       unsigned int c - character to be tested
*
*Exit:
*       Returns non-zero if CP == KANJI and the specified char is punctuation or symbol of
*               Microsoft Kanji code, else 0.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcsymbol_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return(_loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP && c >= 0x8141 && c <= 0x81ac && c != 0x817f);
}

extern "C" int (__cdecl _ismbcsymbol)(
        unsigned int c
        )
{
    return _ismbcsymbol_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismblgl.c ===
/***
*ismblgl.c - Tests to see if a given character is a legal MBCS char.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Tests to see if a given character is a legal MBCS character.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
*int _ismbclegal(c) - tests for a valid MBCS character.
*
*Purpose:
*       Tests to see if a given character is a legal MBCS character.
*
*Entry:
*       unsigned int c - character to test
*
*Exit:
*       returns non-zero if Microsoft Kanji code, else 0
*
*Exceptions:
*
******************************************************************************/

extern "C" int __cdecl _ismbclegal_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        return( (_ismbblead_l(c >> 8, _loc_update.GetLocaleT())) &&
                (_ismbbtrail_l(c & 0x0ff, _loc_update.GetLocaleT())) );
}
extern "C" int (__cdecl _ismbclegal)(
        unsigned int c
        )
{
    return _ismbclegal_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbpunc.c ===
/***
*ismbpunc - Test if character is punctuation (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is punctuation (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _ismbcpunct - Test if character is punctuation (MBCS)
*
*Purpose:
*       Test if the supplied character is punctuation or not.
*       Handles MBCS characters correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if c is an punctuation character; else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcpunct_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {


            char buf[2];
            unsigned short ctype[2] = {0};

            buf[0] = (c >> 8) & 0xFF;
            buf[1] = c & 0xFF;

            /* return FALSE if not in supported MB code page */
            if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

            /*
             * Since 'c' could be two one-byte MB chars, we need room in the
             * ctype return array to handle this. In this case, the
             * second word in the return array will be non-zero.
             */

            if ( __crtGetStringTypeA(_loc_update.GetLocaleT(),  CT_CTYPE1,
                                      buf,
                                      2,
                                      ctype,
                                      _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                      _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                      TRUE ) == 0 )
                return 0;

            /* ensure single MB character and test for type */
            return (ctype[1] == 0 && ctype[0] & _PUNCT);


        } else
        {
            return _ismbbpunct_l( c, _loc_update.GetLocaleT());
        }
}

extern "C" int (__cdecl _ismbcpunct)(
        unsigned int c
        )
{
        return _ismbcpunct_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\isatty.c ===
/***
*isatty.c - check if file handle refers to a device
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _isatty() - check if file handle refers to a device
*
*******************************************************************************/

#include <cruntime.h>
#include <msdos.h>
#include <internal.h>
#include <io.h>

/***
*int _isatty(handle) - check if handle is a device
*
*Purpose:
*       Checks if the given handle is associated with a character device
*       (terminal, console, printer, serial port)
*
*Entry:
*       int handle - handle of file to be tested
*
*Exit:
*       returns non-0 if handle refers to character device,
*       returns 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _isatty (
        int fh
        )
{
#if defined (_DEBUG) && !defined (_SYSCRT)
        /* make sure we ask debugger only once and cache the answer */
        static int knownHandle = -1;
#endif  /* defined (_DEBUG) && !defined (_SYSCRT) */

        /* see if file handle is valid, otherwise return FALSE */
        _CHECK_FH_RETURN(fh, EBADF, 0);
        _VALIDATE_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, 0);

#if defined (_DEBUG) && !defined (_SYSCRT)
        if (knownHandle == -1) {
            knownHandle = DebuggerKnownHandle();
        }

        if (knownHandle) {
            return TRUE;
        }
#endif  /* defined (_DEBUG) && !defined (_SYSCRT) */

        /* check file handle database to see if device bit set */
        return (int)(_osfile(fh) & FDEV);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbupr.c ===
/***
*ismbupr - Test if character is upper case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is upper case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _ismbcupper - Test if character is upper case (MBCS)
*
*Purpose:
*       Test if the supplied character is upper case or not.
*       Handles MBCS characters correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if c is an upper case character; else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcupper_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {


            char buf[2];
            unsigned short ctype[2] = {0};

            buf[0] = (c >> 8) & 0xFF;
            buf[1] = c & 0xFF;

            /* return FALSE if not in supported MB code page */
            if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

            /*
             * Since 'c' could be two one-byte MB chars, we need room
             * in the ctype return array to handle this. In this case,
             * the second word in the return array will be nonzero.
             */

            if ( __crtGetStringTypeA(_loc_update.GetLocaleT(),  CT_CTYPE1,
                                      buf,
                                      2,
                                      ctype,
                                      _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                      _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                      TRUE ) == 0 )
                return 0;

            /* ensure single MB character and test for type */
            return (ctype[1] == 0 && ctype[0] & _UPPER);


        }
        else
        {
            return _mbbisupper_l(c, _loc_update.GetLocaleT());
        }
}

extern "C" int (__cdecl _ismbcupper)(
        unsigned int c
        )
{
    return _ismbcupper_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\iswctype.c ===
/***
*iswctype.c - support isw* wctype functions/macros for wide characters
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines iswctype - support isw* wctype functions/macros for
*       wide characters (esp. > 255).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <locale.h>
#include <awint.h>
#include <ctype.h>
#include <mtdll.h>
#include <setlocal.h>

/*
 *  Use GetStringTypeW() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if _UPPER != C1_UPPER  || \
        _LOWER != C1_LOWER  || \
        _DIGIT != C1_DIGIT  || \
        _SPACE != C1_SPACE  || \
        _PUNCT != C1_PUNCT  || \
        _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif  /* _UPPER != C1_UPPER  || \ */

/***
*iswctype - support isw* wctype functions/macros.
*
*Purpose:
*       This function is called by the isw* wctype functions/macros
*       (e.g. iswalpha()) when their argument is a wide character > 255.
*       It is also a standard ITSCJ (proposed) ISO routine and can be called
*       by the user, even for characters < 256.
*       Returns true or false depending on whether the argument satisfies
*       the character class property encoded by the mask.  Returns 0 if the
*       argument is WEOF.
*
*       NOTE: The isw* functions are neither locale nor codepage dependent.
*
*Entry:
*       wchar_t c    - the wide character whose type is to be tested
*       wchar_t mask - the mask used by the isw* functions/macros
*                       corresponding to each character class property
*
*Exit:
*       Returns non-zero if c is of the character class.
*       Returns 0 if c is not of the character class.
*
*Exceptions:
*       Returns 0 on any error.
*
*******************************************************************************/

extern "C" int __cdecl _iswctype_l (
        wint_t c,
        wctype_t mask,
        _locale_t plocinfo
        )
{
    wint_t d;

    if ( c == WEOF )
        d = 0;
    else if ( c < 256 )
        d = (int)(_pwctype[c] & mask);
    else
    {
        _LocaleUpdate _loc_update(plocinfo);

        if ( __crtGetStringTypeW(
                    _loc_update.GetLocaleT(),
                    CT_CTYPE1,
                    (LPCWSTR)&c,
                    1,
                    &d,
                    _loc_update.GetLocaleT()->locinfo->lc_codepage,
                    _loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE]
                    ) == 0)
            d = 0;
    }

    return (int)(d & mask);
}

extern "C" int __cdecl iswctype (
        wint_t c,
        wctype_t mask
        )
{
    if (c == WEOF)
    {
        return 0;
    }
    if (c < 256)
    {
        return (int)(_pwctype[c] & mask);
    }

    if (__locale_changed == 0)
    {
        wint_t d;
        if ( __crtGetStringTypeW(
                    &__initiallocalestructinfo,
                    CT_CTYPE1,
                    (LPCWSTR)&c,
                    1,
                    &d,
                    __initiallocinfo.lc_codepage,
                    __initiallocinfo.lc_handle[LC_CTYPE]
                    ) == 0)
            d = 0;
    }

    return _iswctype_l(c, mask, NULL);
}


/***
 *is_wctype - support obsolete name
 *
 *Purpose:
 *       Name changed from is_wctype to iswctype. is_wctype must be supported.
 *
 *Entry:
 *       wchar_t c    - the wide character whose type is to be tested
 *       wchar_t mask - the mask used by the isw* functions/macros
 *                       corresponding to each character class property
 *
 *Exit:
 *       Returns non-zero if c is of the character class.
 *       Returns 0 if c is not of the character class.
 *
 *Exceptions:
 *       Returns 0 on any error.
 *
 *******************************************************************************/
extern "C" int __cdecl is_wctype (
        wint_t c,
        wctype_t mask
        )
{
    return iswctype(c, mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\labs.c ===
/***
*labs.c - find absolute value of a long integer
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines labs() - find absolute value of a long integer.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma function(labs)
#endif  /* _MSC_VER */

/***
*long labs(lnumber) - find absolute value of long.
*
*Purpose:
*       Find the absolute value of a long integer (lnumber if lnumber >= 0),
*       -lnumber if lnumber < 0).
*
*Entry:
*       long lnumber - number to find absolute value of
*
*Exit:
*       returns the absolute value of lnumber
*
*Exceptions:
*
*******************************************************************************/

long __cdecl labs (
        long lnumber
        )
{
        return( lnumber>=0L ? lnumber : -lnumber );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbalph.c ===
/***
*ismbalph.c - Test if character is alphabetic (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is alphabetic (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>


/***
* _ismbcalpha - Test if character is alphabetic (MBCS)
*
*Purpose:
*       Test if character is alphabetic.
*       Handles MBCS chars correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if c is alphabetic, else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcalpha_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {


            char buf[2];
            unsigned short ctype[2] = {0};

            buf[0] = (c >> 8) & 0xFF;
            buf[1] = c & 0xFF;

            /* return FALSE if not in supported MB code page */
            if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

            /*
            * Since 'c' could be two one-byte MB chars, we need room in the
            * ctype return array to handle this. In this case, the
            * second word in the return array will be non-zero.
            */

            if ( __crtGetStringTypeA( _loc_update.GetLocaleT(),
                                      CT_CTYPE1,
                                      buf,
                                      2,
                                      ctype,
                                      _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                      _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                      TRUE ) == 0)
                return 0;

            /* ensure single MB character and test for type */
            return (ctype[1] == 0 && ctype[0] & (_ALPHA));


        } else
        {
            return _ismbbalpha_l( c, _loc_update.GetLocaleT());
        }
}

extern "C" int (__cdecl _ismbcalpha)(
        unsigned int c
        )
{
        return _ismbcalpha_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lcnvinit.c ===
/***
*lcnvinit.c - called at startup to initialize lconv structure
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       initialize lconv structure to CHAR_MAX
*
*       According to ANSI, certain elements of the lconv structure must be
*       initialized to CHAR_MAX and the value of CHAR_MAX changes when
*       the user compiles -J.  To reflect this change in the lconv structure,
*       we initialize the structure to SCHAR_MAX, and when any of the users
*       modules are compiled -J, the structure is updated.
*
*       Note that this is not done for DLLs linked to the CRT DLL, because
*       we do not want such DLLs to override the -J setting for an EXE
*       linked to the CRT DLL.  See comments in crtexe.c.
*
*       Files involved:
*
*       locale.h - if -J, generates an unresolved external to _charmax
*       charmax.c - defines _charmax and sets to UCHAR_MAX (255), places
*               __lconv_init in startup initializer table if pulled in by -J
*       lconv.c - initializes lconv structure to SCHAR_MAX (127),
*               since libraries built without -J
*       lcnvinit.c - sets lconv members to 25.
**
*******************************************************************************/

#include <limits.h>
#include <locale.h>
#include <setlocal.h>

int __lconv_init(void)
{
        __lconv_c.int_frac_digits = (char)UCHAR_MAX;
        __lconv_c.frac_digits = (char)UCHAR_MAX;
        __lconv_c.p_cs_precedes = (char)UCHAR_MAX;
        __lconv_c.p_sep_by_space = (char)UCHAR_MAX;
        __lconv_c.n_cs_precedes = (char)UCHAR_MAX;
        __lconv_c.n_sep_by_space = (char)UCHAR_MAX;
        __lconv_c.p_sign_posn = (char)UCHAR_MAX;
        __lconv_c.n_sign_posn = (char)UCHAR_MAX;

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lconv.c ===
/***
*lconv.c - Contains the localeconv function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the localeconv() function.
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>

/* pointer to original static to avoid freeing */
char __lconv_static_decimal[] = ".";
char __lconv_static_null[] = "";

/* lconv settings for "C" locale */
struct lconv __lconv_c = {
                __lconv_static_decimal, /* decimal_point */
                __lconv_static_null,       /* thousands_sep */
                __lconv_static_null,       /* grouping */
                __lconv_static_null,       /* int_curr_symbol */
                __lconv_static_null,       /* currency_symbol */
                __lconv_static_null,       /* mon_decimal_point */
                __lconv_static_null,       /* mon_thousands_sep */
                __lconv_static_null,       /* mon_grouping */
                __lconv_static_null,       /* positive_sign */
                __lconv_static_null,       /* negative_sign */
                CHAR_MAX,                           /* int_frac_digits */
                CHAR_MAX,                           /* frac_digits */
                CHAR_MAX,                           /* p_cs_precedes */
                CHAR_MAX,                           /* p_sep_by_space */
                CHAR_MAX,                           /* n_cs_precedes */
                CHAR_MAX,                           /* n_sep_by_space */
                CHAR_MAX,                           /* p_sign_posn */
                CHAR_MAX                               /* n_sign_posn */
                };


/* pointer to current lconv structure */

struct lconv *__lconv = &__lconv_c;

/***
*struct lconv *localeconv(void) - Return the numeric formatting convention
*
*Purpose:
*       The localeconv() routine returns the numeric formatting conventions
*       for the current locale setting.  [ANSI]
*
*Entry:
*       void
*
*Exit:
*       struct lconv * = pointer to struct indicating current numeric
*                        formatting conventions.
*
*Exceptions:
*
*******************************************************************************/

struct lconv * __cdecl localeconv (
        void
        )
{
    /*
     * Note that we don't need _LocaleUpdate in this function.
     * The main reason being, that this is a leaf function in
     * locale usage terms.
     */
    _ptiddata ptd = _getptd();
    pthreadlocinfo ptloci = ptd->ptlocinfo;

    __UPDATE_LOCALE(ptd, ptloci);
    return(__lconv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbspc.c ===
/***
*ismbspc.c - Test is character is whitespace (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test is character is whitespace (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _ismbcspace - Test is character is whitespace (MBCS)
*
*Purpose:
*       Test if the character is a whitespace character.
*       Handles MBCS chars correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if character is whitespace, else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcspace_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {


            char buf[2];
            unsigned short ctype[2] = {0};

            buf[0] = (c >> 8) & 0xFF;
            buf[1] = c & 0xFF;

            /* return FALSE if not in supported MB code page */
            if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

            /*
             * Since 'c' could be two one-byte MB chars, we need room in the
             * ctype return array to handle this. In this case, the
             * second word in the return array will be non-zero.
             */

            if ( __crtGetStringTypeA(NULL,  CT_CTYPE1,
                                      buf,
                                      2,
                                      ctype,
                                      _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                      _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                      TRUE ) == 0 )
                return 0;

            /* ensure single MB character and test for type */
            return (ctype[1] == 0 && ctype[0] & (_SPACE));


        }
        else
        {
            return _isspace_l(c, _loc_update.GetLocaleT());
        }
}

extern "C" int (__cdecl _ismbcspace)(
        unsigned int c
        )
{
        return _ismbcspace_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lfind.c ===
/***
*lfind.c - do a linear search
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _lfind() - do a linear search of an array.
*
*******************************************************************************/

#include <cruntime.h>
#include <search.h>
#include <stddef.h>
#include <internal.h>

#if defined (_M_CEE)
#define __fileDECL  __clrcall
#else  /* defined (_M_CEE) */
#define __fileDECL  __cdecl
#endif  /* defined (_M_CEE) */

/***
*char *_lfind(key, base, num, width, compare) - do a linear search
*
*Purpose:
*       Performs a linear search on the array, looking for the value key
*       in an array of num elements of width bytes in size.  Returns
*       a pointer to the array value if found, NULL if not found.
*
*Entry:
*       char *key - key to search for
*       char *base - base of array to search
*       unsigned *num - number of elements in array
*       int width - number of bytes in each array element
*       int (*compare)() - pointer to function that compares two
*               array values, returning 0 if they are equal and non-0
*               if they are different.  Two pointers to array elements
*               are passed to this function.
*
*Exit:
*       if key found:
*               returns pointer to array element
*       if key not found:
*               returns NULL
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#define __COMPARE(context, p1, p2) (*compare)(context, p1, p2)
#else  /* __USE_CONTEXT */
#define __COMPARE(context, p1, p2) (*compare)(p1, p2)
#endif  /* __USE_CONTEXT */

#if !defined (_M_CEE)
_CRTIMP
#endif  /* !defined (_M_CEE) */

#ifdef __USE_CONTEXT
void *__fileDECL _lfind_s (
        REG2 const void *key,
        REG1 const void *base,
        REG3 unsigned int *num,
        size_t width,
        int (__fileDECL *compare)(void *, const void *, const void *),
        void *context
        )
#else  /* __USE_CONTEXT */
void *__fileDECL _lfind (
        REG2 const void *key,
        REG1 const void *base,
        REG3 unsigned int *num,
        unsigned int width,
        int (__fileDECL *compare)(const void *, const void *)
        )
#endif  /* __USE_CONTEXT */
{
        unsigned int place = 0;

        /* validation section */
        _VALIDATE_RETURN(key != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(num != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(base != NULL || *num == 0, EINVAL, NULL);
        _VALIDATE_RETURN(width > 0, EINVAL, NULL);
        _VALIDATE_RETURN(compare != NULL, EINVAL, NULL);

        while (place < *num)
        {
                if (__COMPARE(context, key, base) == 0)
                {
                        return (void *)base;
                }
                else
                {
                        base = (char*)base + width;
                        place++;
                }
        }
        return NULL;
}

#undef __fileDECL
#undef __COMPARE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismblwr.c ===
/***
*ismblwr - Test if character is lower case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test if character is lower case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _ismbclower - Test if character is lower case (MBCS)
*
*Purpose:
*       Test if the supplied character is lower case or not.
*       Handles MBCS characters correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       returns TRUE if character is lower case, else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbclower_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {


            char buf[2];
            unsigned short ctype[2] = {0};

            buf[0] = (c >> 8) & 0xFF;
            buf[1] = c & 0xFF;

            /* return FALSE if not in supported MB code page */
            if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

            /*
             * Since 'c' could be two one-byte MB chars, we need room
             * in the ctype return array to handle this. In this case,
             * the second word in the return array will be nonzero.
             */

            if ( __crtGetStringTypeA( _loc_update.GetLocaleT(),  CT_CTYPE1,
                                      buf,
                                      2,
                                      ctype,
                                      _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                      _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                      TRUE ) == 0 )
                return 0;

            /* ensure single MB character and test for type */
            return (ctype[1] == 0 && ctype[0] & (_LOWER));


        }
        else
        {
            return _mbbislower_l(c, _loc_update.GetLocaleT());
        }
}

extern "C" int (__cdecl _ismbclower)(
        unsigned int c
        )
{
        return _ismbclower_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbprn.c ===
/***
*ismbprn.c - Test character for display character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Test character for display character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <awint.h>

#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _ismbcprint - Test character for display character (MBCS)
*
*Purpose:
*       Test if the character is a display character.
*       Handles MBCS chars correctly.
*
*       Note:  Use test against 0x00FF to ensure that we don't
*       call SBCS routine with a two-byte value.
*
*Entry:
*       unsigned int c = character to test
*
*Exit:
*       Returns TRUE if character is display character, else FALSE
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcprint_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {


            char buf[2];
            unsigned short ctype[2] = {0};

            buf[0] = (c >> 8) & 0xFF;
            buf[1] = c & 0xFF;

            /* return FALSE if not in supported MB code page */
            if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return 0;

            /*
             * Since 'c' could be two one-byte MB chars, we need room in the
             * ctype return array to handle this. In this case, the
             * second word in the return array will be non-zero.
             */

            if ( __crtGetStringTypeA( _loc_update.GetLocaleT(),  CT_CTYPE1,
                                      buf,
                                      2,
                                      ctype,
                                      _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                      _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                      TRUE ) == 0 )
                return 0;

            /* ensure single MB character and test for type */
            return (ctype[1] == 0 && !(ctype[0] & _CONTROL));


        } else
        {
            return _ismbbprint_l( c, _loc_update.GetLocaleT());
        }
}

extern "C" int (__cdecl _ismbcprint)(
        unsigned int c
        )
{
        return _ismbcprint_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ldiv.c ===
/***
*ldiv.c - contains the ldiv routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Performs a signed divide on longs and returns quotient
*       and remainder.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

/***
*ldiv_t div(long numer, long denom) - do signed divide
*
*Purpose:
*       This routine does an long divide and returns the results.
*
*Entry:
*       long numer - Numerator passed in on stack
*       long denom - Denominator passed in on stack
*
*Exit:
*       returns quotient and remainder in structure
*
*Exceptions:
*       No validation is done on [denom]* thus, if [denom] is 0,
*       this routine will trap.
*
*******************************************************************************/

ldiv_t __cdecl ldiv (
        long numer,
        long denom
        )
{
        ldiv_t result;

        result.quot = numer / denom;
        result.rem = numer % denom;

        return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbstr.c ===
/***
*ismbstrail.c - True _ismbstrail function
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains the function _ismbstrail, which is a true context-sensitive
*       MBCS trail-byte function.  While much less efficient than _ismbbtrail,
*       it is also much more sophisticated, in that it determines whether a
*       given sub-string pointer points to a trail byte or not, taking into
*       account the context in the string.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <stddef.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* int _ismbstrail(const unsigned char *string, const unsigned char *current);
*
*Purpose:
*
*       _ismbstrail - Check, in context, for MBCS trail byte
*
*Entry:
*       unsigned char *string   - ptr to start of string or previous known lead byte
*       unsigned char *current  - ptr to position in string to be tested
*
*Exit:
*       TRUE    : -1
*       FALSE   : 0
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _ismbstrail_l(
        const unsigned char *string,
        const unsigned char *current,
        _locale_t plocinfo
        )
{
        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, 0);
        _VALIDATE_RETURN(current != NULL, EINVAL, 0);

        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return 0;

        while ( string <= current && *string ) {
            if ( _ismbblead_l((*string), _loc_update.GetLocaleT()) ) {
                if (++string == current)        /* check trail byte */
                    return -1;
                if (!(*string))
                    return 0;
            }
            ++string;
        }

        return 0;
}
extern "C" int (__cdecl _ismbstrail)(
        const unsigned char *string,
        const unsigned char *current
        )
{
        return _ismbstrail_l(string, current, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#include <crtdefs.h>

#ifndef _INC_LIMITS
#define _INC_LIMITS

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else  /* _CHAR_UNSIGNED */
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */
#define LLONG_MAX     9223372036854775807i64       /* maximum signed long long int value */
#define LLONG_MIN   (-9223372036854775807i64 - 1)  /* minimum signed long long int value */
#define ULLONG_MAX    0xffffffffffffffffui64       /* maximum unsigned long long int value */

#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */

#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */

#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */

/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64

#if _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif  /* _INTEGRAL_MAX_BITS >= 128 */

#ifndef SIZE_MAX
#ifdef _WIN64
#define SIZE_MAX _UI64_MAX
#else  /* _WIN64 */
#define SIZE_MAX UINT_MAX
#endif  /* _WIN64 */
#endif  /* SIZE_MAX */

#if __STDC_WANT_SECURE_LIB__
/* While waiting to the C standard committee to finalize the decision on RSIZE_MAX and rsize_t,
 * we define RSIZE_MAX as SIZE_MAX
 */
#ifndef RSIZE_MAX
#define RSIZE_MAX SIZE_MAX
#endif  /* RSIZE_MAX */
#endif  /* __STDC_WANT_SECURE_LIB__ */


#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\loaddll.c ===
/***
*loaddll.c - load or free a Dynamic Link Library
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _loaddll() and _unloaddll() - load and unload DLL
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <errno.h>

#define _CRT_ENABLE_OBSOLETE_LOADLIBRARY_FUNCTIONS

#include <process.h>

/***
*int _loaddll(filename) - Load a dll
*
*Purpose:
*       Load a DLL into memory
*
*Entry:
*       char *filename - file to load
*
*Exit:
*       returns a unique DLL (module) handle if succeeds
*       returns 0 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _loaddll(char * szName)
{
        return ((intptr_t)LoadLibrary(szName));
}

/***
*int _unloaddll(handle) - Unload a dll
*
*Purpose:
*       Unloads a DLL. The resources of the DLL will be freed if no other
*       processes are using it.
*
*Entry:
*       int handle - handle from _loaddll
*
*Exit:
*       returns 0 if succeeds
*       returns DOS error if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _unloaddll(intptr_t hMod)
{
        if (!FreeLibrary((HANDLE)hMod)) {
            return ((int)GetLastError());
        }
        return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\locale.cpp ===
// locale -- class locale member functions
#if !defined(STDCPP_IMPLIB)
#define STDCPP_IMPLIB 0
#endif

// In debug, force the instantiation of the string classes with _DEFINE_EMPTY_STRING_CONSTRUCTOR.
// This will force basic_string::basic_string(void) to be exported by the dll, avoiding bincompa problems
// See VSW#449741 and VSW#426913
#if _DEBUG
#define __FORCE_INSTANCE
#define _DEFINE_EMPTY_STRING_CONSTRUCTOR
#include <xstring>
#undef __FORCE_INSTANCE
#undef _DEFINE_EMPTY_STRING_CONSTRUCTOR
#endif

#include <cstdlib>
#include <istream>
#include <xlocale>
#include <xdebug>
#include <dbgint.h>

 #pragma warning(disable: 4074)
 #pragma init_seg(compiler)

  #include <dbgint.h>

 #ifndef _CAT_TO_LC
  #define _CAT_TO_LC(cat)	(cat)
 #endif /* _CAT_TO_LC */


_STD_BEGIN

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

#if !STDCPP_IMPLIB || !defined(_M_CEE_PURE)

_MRTIMP2 locale __cdecl locale::global(const locale& loc)
	{	// change global locale
	locale _Oldglobal;
	_BEGIN_LOCK(_LOCK_LOCALE)
		locale::_Locimp *_Ptr = _Getgloballocale();

		if (_Ptr != loc._Ptr)
			{	// set new global locale
			_DELETE_CRT(_Ptr->_Decref());
			_Setgloballocale(_Ptr = loc._Ptr);
			_Ptr->_Incref();
			category _Cmask = _Ptr->_Catmask & all;
			if (_Cmask == all)
				setlocale(LC_ALL, _Ptr->_Name.c_str());
			else
				for (int catindex = 0; catindex <= _X_MAX; ++catindex)
					if ((_CATMASK(catindex) & _Cmask) != 0)
						setlocale(_CAT_TO_LC(catindex), _Ptr->_Name.c_str());
			}
		return (_Oldglobal);
	_END_LOCK()
	}

#endif // STDCPP_IMPLIB || !defined(_M_CEE_PURE)

#if STDCPP_IMPLIB || !defined(_M_CEE_PURE)
	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

typedef ctype<char> _T1;
typedef num_get<char, _Initer> _T2;
typedef num_put<char, _Outiter> _T3;
typedef numpunct<char> _T4;
// others moved to wlocale and xlocale to ease subsetting
typedef codecvt<char, char, _Mbstatet> _Tc1;


locale::_Locimp * locale::_Locimp::_Makeloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup a new locale
	ADDFAC(_T1, cat, ptrimp, ptrloc);
	ADDFAC(_T2, cat, ptrimp, ptrloc);
	ADDFAC(_T3, cat, ptrimp, ptrloc);
	ADDFAC(_T4, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Tc1, cat, ptrimp, ptrloc);

	_Locimp::_Makexloc(lobj, cat, ptrimp, ptrloc);
	_Locimp::_Makewloc(lobj, cat, ptrimp, ptrloc);
#ifdef _NATIVE_WCHAR_T_DEFINED
	_Locimp::_Makeushloc(lobj, cat, ptrimp, ptrloc);
#endif
	ptrimp->_Catmask |= cat;
	ptrimp->_Name = lobj._Getname();
	return (ptrimp);
	}

void locale::_Locimp::_Locimp_ctor(locale::_Locimp *_This, const locale::_Locimp& imp)
	{	// construct a _Locimp from a copy
	if (&imp == _This->_Clocptr)
		{
		_BEGIN_LOCINFO(_Lobj)
			_Makeloc(_Lobj, locale::all, _This, 0);
		_END_LOCINFO()
		}
	else
		{	// lock to keep facets from disappearing
		_BEGIN_LOCK(_LOCK_LOCALE)
			if (0 < _This->_Facetcount)
				{	// copy over nonempty facet vector
				if ((_This->_Facetvec = (locale::facet **)_malloc_crt(
					_This->_Facetcount * sizeof (locale::facet *))) == 0)
					{	// report no memory
					static const _XSTD bad_alloc nomem;
					_RAISE(nomem);
					}
				for (size_t count = _This->_Facetcount; 0 < count; )
					{	// copy over facet pointers
					locale::facet *ptrfac = imp._Facetvec[--count];
					if ((_This->_Facetvec[count] = ptrfac) != 0)
						ptrfac->_Incref();
					}
				}
		_END_LOCK()
		}
	}
#endif // STDCPP_IMPLIB || !defined(_M_CEE_PURE)

#if !STDCPP_IMPLIB || !defined(_M_CEE_PURE)

_MRTIMP2 void __cdecl locale::_Locimp::_Locimp_Addfac(_Locimp *_This, locale::facet *ptrfac, size_t id)
	{	// add a facet to a locale
	_BEGIN_LOCK(_LOCK_LOCALE)
		const size_t MINCAT = 40;	// minimum number of facets in a locale

		if (_This->_Facetcount <= id)
			{	// make facet vector larger
			size_t count = id + 1;
			if (count < MINCAT)
				count = MINCAT;
			locale::facet **ptrnewvec = (locale::facet **)_realloc_crt(_This->_Facetvec,
				count * sizeof (locale::facet **));
			if (ptrnewvec == 0)
				{	// report no memory
				static const _XSTD bad_alloc nomem;
				_RAISE(nomem);
				}

			_This->_Facetvec = ptrnewvec;
			for (; _This->_Facetcount < count; ++_This->_Facetcount)
				_This->_Facetvec[_This->_Facetcount] = 0;
			}

		ptrfac->_Incref();
		if (_This->_Facetvec[id] != 0)
			_DELETE_CRT(_This->_Facetvec[id]->_Decref());
		_This->_Facetvec[id] = ptrfac;
	_END_LOCK()
	}

_MRTIMP2_NPURE void __cdecl _Locinfo::_Locinfo_ctor(_Locinfo *pLocinfo, int cat, const char *locname)
	{	// capture a named locale
	const char *oldlocname = setlocale(LC_ALL, 0);

	pLocinfo->_Oldlocname = oldlocname == 0 ? "" : oldlocname;
	_Locinfo_Addcats(pLocinfo, cat, locname);
	}

_MRTIMP2_NPURE _Locinfo& __cdecl _Locinfo::_Locinfo_Addcats(_Locinfo *pLocinfo, int cat, const char *locname)
	{	// merge in another named locale
	const char *oldlocname = 0;

	if (locname == 0)
		_THROW_NCEE(runtime_error, "bad locale name");
	if (locname[0] == '*' && locname[1] == '\0')
		;
	else if (cat == 0)
		oldlocname = setlocale(LC_ALL, 0);
	else if (cat == _M_ALL)
		oldlocname = setlocale(LC_ALL, locname);
	else
		{	// alter selected categories
		for (int catindex = 0; catindex <= _X_MAX; ++catindex)
			if ((_CATMASK(catindex) & cat) != 0)
				setlocale(_CAT_TO_LC(catindex), locname);
		oldlocname = setlocale(LC_ALL, locname);
		}
	if (oldlocname == 0)
		pLocinfo->_Newlocname = "*";
	else if (pLocinfo->_Newlocname.compare("*") != 0)
		pLocinfo->_Newlocname = oldlocname;
	return (*pLocinfo);
	}

#endif // STDCPP_IMPLIB || !defined(_M_CEE_PURE)

_STD_END


/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_LOCALE
#define _INC_LOCALE

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif  /* _LCONV_DEFINED */

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy(void) { return _charmax; }
#endif  /* _CHAR_UNSIGNED */

/* function prototypes */

#ifndef _CONFIG_LOCALE_SWT
#define _ENABLE_PER_THREAD_LOCALE           0x1
#define _DISABLE_PER_THREAD_LOCALE          0x2
#define _ENABLE_PER_THREAD_LOCALE_GLOBAL    0x10
#define _DISABLE_PER_THREAD_LOCALE_GLOBAL   0x20
#define _ENABLE_PER_THREAD_LOCALE_NEW       0x100
#define _DISABLE_PER_THREAD_LOCALE_NEW      0x200
#define _CONFIG_LOCALE_SWT
#endif  /* _CONFIG_LOCALE_SWT */

_Check_return_opt_ _CRTIMP int __cdecl _configthreadlocale(_In_ int _Flag);
_Check_return_opt_ _CRTIMP char * __cdecl setlocale(_In_ int _Category, _In_opt_z_ const char * _Locale);
_Check_return_opt_ _CRTIMP struct lconv * __cdecl localeconv(void);
_Check_return_opt_ _CRTIMP _locale_t __cdecl _get_current_locale(void);
_Check_return_opt_ _CRTIMP _locale_t __cdecl _create_locale(_In_ int _Category, _In_z_ const char * _Locale);
_CRTIMP void __cdecl _free_locale(_In_opt_ _locale_t _Locale);

/* use _get_current_locale, _create_locale and _free_locale, instead of these functions with double leading underscore */
_Check_return_ _CRT_OBSOLETE(_get_current_locale) _CRTIMP _locale_t __cdecl __get_current_locale(void);
_Check_return_ _CRT_OBSOLETE(_create_locale) _CRTIMP _locale_t __cdecl __create_locale(_In_ int _Category, _In_z_ const char * _Locale);
_CRT_OBSOLETE(_free_locale) _CRTIMP void __cdecl __free_locale(_In_opt_ _locale_t _Locale);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_Check_return_opt_ _CRTIMP wchar_t * __cdecl _wsetlocale(_In_ int _Category, _In_opt_z_ const wchar_t * _Locale);

#define _WLOCALE_DEFINED
#endif  /* _WLOCALE_DEFINED */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\locale0.cpp ===
// locale0 -- class locale basic member functions
#include <climits>
#include <locale>
#include <xdebug>
#include <stdlib.h>

_C_STD_BEGIN

#if defined(_M_CEE) 
void _AtModuleExit_m(void (__clrcall *pf)())
#else
void _AtModuleExit(void (__cdecl *pf)())
#endif
	{
	int err = 0;
#if defined(_M_CEE) 
	err = _atexit_m_appdomain(pf);
#else
	err = atexit(pf);
#endif
	if(err != 0)
		abort();
	}

_C_STD_END


_STD_BEGIN
struct _Fac_node
	{	// node for lazy facet recording
	__CLR_OR_THIS_CALL _Fac_node(_Fac_node *_Nextarg, std::locale::facet *_Facptrarg)
		: _Next(_Nextarg), _Facptr(_Facptrarg)
		{	// construct a node with value
		}

	__CLR_OR_THIS_CALL ~_Fac_node()
		{	// destroy a facet
		_DELETE_CRT(_Facptr->_Decref());
		}

	_Fac_node *_Next;
	std::locale::facet *_Facptr;
	};

__PURE_APPDOMAIN_GLOBAL static _Fac_node *_Fac_head = 0;

_STD_END

_C_STD_BEGIN
_EXTERN_C

#if defined(_M_CEE) 
void __clrcall _Fac_tidy_m()
#else
void __cdecl _Fac_tidy()
#endif
	{	// destroy lazy facets
	_BEGIN_LOCK(_LOCK_LOCALE)	// prevent double delete
		for (; std::_Fac_head != 0; )
			{	// destroy a lazy facet node
			std::_Fac_node *nodeptr = std::_Fac_head;
			std::_Fac_head = nodeptr->_Next;
			_DELETE_CRT(nodeptr);
			}
	_END_LOCK()
	}

_END_EXTERN_C
_C_STD_END

_STD_BEGIN

#if defined(_M_CEE) 
void __CLRCALL_OR_CDECL locale::facet::facet_Register_m(locale::facet *_This)
#else
void __CLRCALL_OR_CDECL locale::facet::facet_Register(locale::facet *_This)
#endif
	{	// queue up lazy facet for destruction
	if (_Fac_head == 0)
		{
#if defined(_M_CEE) 
		::_AtModuleExit_m(&::_Fac_tidy_m);
#else
		::_AtModuleExit(&::_Fac_tidy);
#endif
		}

	_Fac_head = _NEW_CRT _Fac_node(_Fac_head, _This);
	}

_STD_END


#if !STDCPP_IMPLIB 
_C_STD_BEGIN
_EXTERN_C

void __CLRCALL_OR_CDECL _Deletegloballocale(void *ptr)
	{	// delete a global locale reference
	std::locale::_Locimp *locptr = *(std::locale::_Locimp **)ptr;
	if (locptr != 0)
		_DELETE_CRT(locptr->_Decref());
	}

__PURE_APPDOMAIN_GLOBAL static std::locale::_Locimp *global_locale = 0;	// pointer to current locale

static void __cdecl tidy_global()
	{	// delete static global locale reference
	_BEGIN_LOCK(_LOCK_LOCALE)	// prevent double delete
		_Deletegloballocale(&global_locale);
		global_locale=NULL;
	_END_LOCK()
	}

_END_EXTERN_C
_C_STD_END

_STD_BEGIN

_MRTIMP2 std::locale::_Locimp *__cdecl std::locale::_Getgloballocale()
	{	// return pointer to current locale
	return (global_locale);
	}

_MRTIMP2 void std::locale::_Setgloballocale(void *ptr)
	{	// alter pointer to current locale
	__PURE_APPDOMAIN_GLOBAL static bool registered = false;

	if (!registered)
		{	// register cleanup first time
		registered = true;
		::_Atexit(&tidy_global);
		}
	global_locale = (std::locale::_Locimp *)ptr;
	}

 #pragma warning(disable: 4786)

__PURE_APPDOMAIN_GLOBAL static locale classic_locale(_Noinit);	// "C" locale object, uninitialized

__PURE_APPDOMAIN_GLOBAL locale::_Locimp *locale::_Locimp::_Clocptr = 0;	// pointer to classic_locale

_MRTIMP2 locale::_Locimp*& __cdecl locale::_Locimp::_Clocptr_func()
{
    return locale::_Locimp::_Clocptr;
}

__PURE_APPDOMAIN_GLOBAL int locale::id::_Id_cnt = 0;	// unique id counter for facets

_MRTIMP2 int& __cdecl locale::id::_Id_cnt_func()
{
    return locale::id::_Id_cnt;
}

__PURE_APPDOMAIN_GLOBAL locale::id ctype<char>::id(0);

_MRTIMP2 locale::id& __cdecl ctype<char>::_Id_func()
{
    return ctype<char>::id;
}

__PURE_APPDOMAIN_GLOBAL locale::id ctype<wchar_t>::id(0);

_MRTIMP2 locale::id& __cdecl ctype<wchar_t>::_Id_func()
{
    return ctype<wchar_t>::id;
}

__PURE_APPDOMAIN_GLOBAL locale::id codecvt<wchar_t, char, mbstate_t>::id(0);

_MRTIMP2 locale::id& __cdecl codecvt<wchar_t, char, mbstate_t>::_Id_func()
{
    return codecvt<wchar_t, char, mbstate_t>::id;
}


 #ifdef _NATIVE_WCHAR_T_DEFINED
__PURE_APPDOMAIN_GLOBAL locale::id ctype<unsigned short>::id(0);

_MRTIMP2 locale::id& __cdecl ctype<unsigned short>::_Id_func()
{
    return ctype<unsigned short>::id;
}

__PURE_APPDOMAIN_GLOBAL locale::id codecvt<unsigned short, char, mbstate_t>::id(0);
_MRTIMP2 locale::id& __cdecl codecvt<unsigned short, char, mbstate_t>::_Id_func()
{
    return codecvt<unsigned short, char, mbstate_t>::id;
}

 #endif /* _NATIVE_WCHAR_T_DEFINED */

_MRTIMP2 const locale& __cdecl locale::classic()
	{	// get reference to "C" locale
	_Init();
	return (classic_locale);
	}

_MRTIMP2 locale __cdecl locale::empty()
	{	// make empty transparent locale
	_Init();
	return (locale(_NEW_CRT _Locimp(true)));
	}

_MRTIMP2 locale::_Locimp *__cdecl locale::_Init()
	{	// setup global and "C" locales
	locale::_Locimp *ptr = _Getgloballocale();
	if (ptr == 0)
		{	// lock and test again
		_BEGIN_LOCK(_LOCK_LOCALE)	// prevent double initialization

			ptr = _Getgloballocale();
			if (ptr == 0)
				{	// create new locales
				_Setgloballocale(ptr = _NEW_CRT _Locimp);
				ptr->_Catmask = all;	// set current locale to "C"
				ptr->_Name = "C";

				_Locimp::_Clocptr = ptr;	// set classic to match
				_Locimp::_Clocptr->_Incref();
				new (&classic_locale) locale(_Locimp::_Clocptr);
				}
		_END_LOCK()
		}
	return (ptr);
	}

_MRTIMP2 void __cdecl locale::_Locimp::_Locimp_dtor(_Locimp* _This)
	{	// destruct a _Locimp
	_BEGIN_LOCK(_LOCK_LOCALE)	// prevent double delete
		for (size_t count = _This->_Facetcount; 0 < count; )
			if (_This->_Facetvec[--count] != 0)
				_DELETE_CRT(_This->_Facetvec[count]->_Decref());
		free(_This->_Facetvec);
	_END_LOCK()
	}

_MRTIMP2 void __cdecl _Locinfo::_Locinfo_ctor(_Locinfo *pLocinfo, const char *locname)
	{	// switch to a named locale
	const char *oldlocname = setlocale(LC_ALL, 0);

	pLocinfo->_Oldlocname = oldlocname == 0 ? "" : oldlocname;
	if (locname != 0)
		locname = setlocale(LC_ALL, locname);
	pLocinfo->_Newlocname = locname == 0 ? "*" : locname;
	}

_MRTIMP2 void __cdecl _Locinfo::_Locinfo_ctor(_Locinfo * pLocinfo, const string& locstr)
	{	// switch to a named locale
	const char *locname = locstr.c_str();
	const char *oldlocname = setlocale(LC_ALL, 0);

	pLocinfo->_Oldlocname = oldlocname == 0 ? "" : oldlocname;
	if (locname != 0)
		locname = setlocale(LC_ALL, locname);
	pLocinfo->_Newlocname = locname == 0 ? "*" : locname;
	}

_MRTIMP2 void __cdecl _Locinfo::_Locinfo_dtor(_Locinfo *pLocinfo)
	{	// destroy a _Locinfo object, revert locale
	if (0 < pLocinfo->_Oldlocname.size())
		setlocale(LC_ALL, pLocinfo->_Oldlocname.c_str());
	}
_STD_END

#endif// !STDCPP_IMPLIB 

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ismbsle.c ===
/***
*ismbslead.c - True _ismbslead function
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains the function _ismbslead, which is a true context-sensitive
*       MBCS lead-byte function.  While much less efficient than _ismbblead,
*       it is also much more sophisticated, in that it determines whether a
*       given sub-string pointer points to a lead byte or not, taking into
*       account the context in the string.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <stddef.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* int _ismbslead(const unsigned char *string, const unsigned char *current);
*
*Purpose:
*
*       _ismbslead - Check, in context, for MBCS lead byte
*
*Entry:
*       unsigned char *string   - ptr to start of string or previous known lead byte
*       unsigned char *current  - ptr to position in string to be tested
*
*Exit:
*       TRUE    : -1
*       FALSE   : 0
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _ismbslead_l(
        const unsigned char *string,
        const unsigned char *current,
        _locale_t plocinfo
        )
{
        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, 0);
        _VALIDATE_RETURN(current != NULL, EINVAL, 0);

        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return 0;

        while (string <= current && *string) {
            if ( _ismbblead_l((*string), _loc_update.GetLocaleT()) ) {
                if (string++ == current)        /* check lead byte */
                    return -1;
                if (!(*string))
                    return 0;
            }
            ++string;
        }

        return 0;
}

extern "C" int (__cdecl _ismbslead)(
        const unsigned char *string,
        const unsigned char *current
        )
{
        return _ismbslead_l(string, current, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\locale0_implib.cpp ===
#if defined(_DLL)
#ifdef CRTDLL2
#undef CRTDLL2
#endif

#ifdef MRTDLL
#undef MRTDLL
#endif

#define STDCPP_IMPLIB 1
#include "locale0.cpp"

#endif // defined(_DLL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lsearch.c ===
/***
*lsearch.c - linear search of an array
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the _lsearch() function - linear search of an array
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <search.h>
#include <memory.h>
#include <internal.h>

#if defined (_M_CEE)
#define __fileDECL  __clrcall
#else  /* defined (_M_CEE) */
#define __fileDECL  __cdecl
#endif  /* defined (_M_CEE) */
/***
*char *_lsearch(key, base, num, width, compare) - do a linear search
*
*Purpose:
*       Performs a linear search on the array, looking for the value key
*       in an array of num elements of width bytes in size.  Returns
*       a pointer to the array value if found; otherwise adds the
*       key to the end of the list.
*
*Entry:
*       char *key - key to search for
*       char *base - base of array to search
*       unsigned *num - number of elements in array
*       int width - number of bytes in each array element
*       int (*compare)() - pointer to function that compares two
*               array values, returning 0 if they are equal and non-0
*               if they are different. Two pointers to array elements
*               are passed to this function.
*
*Exit:
*       if key found:
*               returns pointer to array element
*       if key not found:
*               adds the key to the end of the list, and increments
*               *num.
*               returns pointer to new element.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#define __COMPARE(context, p1, p2) (*compare)(context, p1, p2)
#else  /* __USE_CONTEXT */
#define __COMPARE(context, p1, p2) (*compare)(p1, p2)
#endif  /* __USE_CONTEXT */

#if !defined (_M_CEE)
_CRTIMP
#endif  /* !defined (_M_CEE) */
#ifdef __USE_CONTEXT
void *__fileDECL _lsearch_s (
        REG2 const void *key,
        REG1 void *base,
        REG3 unsigned int *num,
        size_t width,
        int (__fileDECL *compare)(void *, const void *, const void *),
        void *context
        )
#else  /* __USE_CONTEXT */
void *__fileDECL _lsearch (
        REG2 const void *key,
        REG1 void *base,
        REG3 unsigned int *num,
        unsigned int width,
        int (__fileDECL *compare)(const void *, const void *)
        )
#endif  /* __USE_CONTEXT */
{
        unsigned int place = 0;

        /* validation section */
        _VALIDATE_RETURN(key != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(num != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(base != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(width > 0, EINVAL, NULL);
        _VALIDATE_RETURN(compare != NULL, EINVAL, NULL);

        while (place < *num)
        {
                if (__COMPARE(context, key, base) == 0)
                {
                        return base;
                }
                else
                {
                        base = (char*)base + width;
                        place++;
                }
        }
        memcpy(base, key, width);
        (*num)++;
        return base;
}

#undef __fileDECL
#undef __COMPARE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\loosefpmath.c ===
/***
* loosefpmath.c - Set DAZ and FTZ for SSE2 architectures
*
*   Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/
#include <float.h>
#include <sect_attribs.h>
#include <internal.h>

int __set_loosefpmath(void);

int __set_loosefpmath(void)
{
    _ERRCHECK(_controlfp_s(NULL, _DN_FLUSH, _MCW_DN));
    return 0;
}

_CRTALLOC(".CRT$XID") static _PIFV pinit = __set_loosefpmath;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ivec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to MMX(TM) instruction intrinsics.
 *
 */

#ifndef _IVEC_H_INCLUDED
#define _IVEC_H_INCLUDED
#ifndef RC_INVOKED

#if !defined __cplusplus
        #error ERROR: This file is only supported in C++ compilations!
#endif  /* !defined __cplusplus */

#if defined (_M_CEE_PURE)
        #error ERROR: This file is not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <mmintrin.h>
#include <assert.h>

/*
 * Define _SILENCE_IVEC_C4799 to disable warning C4799 inside this header.
 * Be careful that any code that uses these functions properly executes EMMS
 * or _m_empty() after using any MMX instruction and before using the x87 NDP.
 */
#if defined (_SILENCE_IVEC_C4799)
        #pragma warning(push)
        #pragma warning(disable: 4799)
#endif  /* defined (_SILENCE_IVEC_C4799) */

/*
 * Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output
 */
#if defined (_ENABLE_VEC_DEBUG)
        #include <iostream>
#endif  /* defined (_ENABLE_VEC_DEBUG) */

#define EXPLICIT explicit

class I8vec8;                   /* 8 elements, each element a signed or unsigned char data type */
class Is8vec8;                  /* 8 elements, each element a signed char data type */
class Iu8vec8;                  /* 8 elements, each element an unsigned char data type */
class I16vec4;                  /* 4 elements, each element a signed or unsigned short */
class Is16vec4;                 /* 4 elements, each element a signed short */
class Iu16vec4;                 /* 4 elements, each element an unsigned short */
class I32vec2;                  /* 2 elements, each element a signed or unsigned long */
class Is32vec2;                 /* 2 elements, each element a signed long */
class Iu32vec2;                 /* 2 elements, each element a unsigned long */
class I64vec1;                  /* 1 element, a __m64 data type - Base I64vec1 class  */

#define _MM_8UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_8B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_4UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_4W(element,vector) (*((short*)&##vector + ##element))

#define _MM_2UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_2DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_QW (*((__int64*)&vec))

/* M64 Class:
 * 1 element, a __m64 data type
 * Contructors & Logical Operations
 */
class M64
{
protected:
                __m64 vec;

public:
        M64()                                                                   { }
        M64(__m64 mm)                                                   { vec = mm; }
        M64(__int64 mm)                                                 { _MM_QW = mm; }
        M64(int i)                                                              { vec = _m_from_int(i); }

        operator __m64() const                                  { return vec; }

        /* Logical Operations */
        M64& operator&=(const M64 &a)                                   { return *this = (M64) _m_pand(vec,a); }
        M64& operator|=(const M64 &a)                                   { return *this = (M64) _m_por(vec,a); }
        M64& operator^=(const M64 &a)                                   { return *this = (M64) _m_pxor(vec,a); }

};

inline M64 operator&(const M64 &a, const M64 &b)        { return _m_pand( a,b); }
inline M64 operator|(const M64 &a, const M64 &b)        { return _m_por(a,b); }
inline M64 operator^(const M64 &a, const M64 &b)        { return _m_pxor(a,b); }
inline M64 andnot(const M64 &a, const M64 &b)           { return _m_pandn(a,b); }

/* I64vec1 Class:
 * 1 element, a __m64 data type
 * Contains Operations which can operate on any __m64 data type
 */

class I64vec1 : public M64
{
public:
        I64vec1()                                                               { }
        I64vec1(__m64 mm) : M64(mm)                             { }
        EXPLICIT I64vec1(int i) : M64(i)                { }
        EXPLICIT I64vec1(__int64 mm) : M64(mm)  { }

        I64vec1& operator= (const M64 &a) { return *this = (I64vec1) a; }
        I64vec1& operator&=(const M64 &a) { return *this = (I64vec1) _m_pand(vec,a); }
        I64vec1& operator|=(const M64 &a) { return *this = (I64vec1) _m_por(vec,a); }
        I64vec1& operator^=(const M64 &a) { return *this = (I64vec1) _m_pxor(vec,a); }

        /* Shift Logical Operations */
        I64vec1 operator<<(const M64 &a)                                { return _m_psllq(vec, a); }
        I64vec1 operator<<(int count)                               { return _m_psllqi(vec, count); }
        I64vec1& operator<<=(const M64 &a)                              { return *this = (I64vec1) _m_psllq(vec, a); }
        I64vec1& operator<<=(int count)                                 { return *this = (I64vec1) _m_psllqi(vec, count); }
        I64vec1 operator>>(const M64 &a)                                { return _m_psrlq(vec, a); }
        I64vec1 operator>>(int count)                                   { return _m_psrlqi(vec, count); }
        I64vec1& operator>>=(const M64 &a)                              { return *this = (I64vec1) _m_psrlq(vec, a); }
        I64vec1& operator>>=(int count)                                 { return *this = (I64vec1) _m_psrlqi(vec, count); }
};

/* I32vec2 Class:
 * 2 elements, each element either a signed or unsigned int
 */
class I32vec2 : public M64
{
public:
        I32vec2() { }
        I32vec2(__m64 mm) : M64(mm) { }
        EXPLICIT I32vec2(int i) : M64 (i) { }
        EXPLICIT I32vec2(__int64 i): M64(i) {}

        /* Assignment Operator */
        I32vec2& operator= (const M64 &a) { return *this = (I32vec2) a; }

        /* Logical Assignment Operators */
        I32vec2& operator&=(const M64 &a) { return *this = (I32vec2) _m_pand(vec,a); }
        I32vec2& operator|=(const M64 &a) { return *this = (I32vec2) _m_por(vec,a); }
        I32vec2& operator^=(const M64 &a) { return *this = (I32vec2) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I32vec2& operator +=(const I32vec2 &a)                  { return *this = (I32vec2) _m_paddd(vec,a); }
        I32vec2& operator -=(const I32vec2 &a)                  { return *this = (I32vec2) _m_psubd(vec,a); }

        /* Shift Logical Operators */
        I32vec2 operator<<(const I32vec2 &a)                    { return _m_pslld(vec,a); }
        I32vec2 operator<<(int count)                               { return _m_pslldi(vec,count); }
        I32vec2& operator<<=(const I32vec2 &a)                  { return *this = (I32vec2) _m_pslld(vec,a); }
        I32vec2& operator<<=(int count)                                 { return *this = (I32vec2) _m_pslldi(vec,count); }

};

/* Compare For Equality */
inline I32vec2 cmpeq(const I32vec2 &a, const I32vec2 &b)            { return _m_pcmpeqd(a,b); }
inline I32vec2 cmpneq(const I32vec2 &a, const I32vec2 &b)           { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline I32vec2 unpack_low(const I32vec2 &a, const I32vec2 &b)   {return _m_punpckldq(a,b); }
inline I32vec2 unpack_high(const I32vec2 &a, const I32vec2 &b)  {return _m_punpckhdq(a,b); }

/* Is32vec2 Class:
 * 2 elements, each element a signed int
 */
class Is32vec2 : public I32vec2
{
public:
        Is32vec2() { }
        Is32vec2(__m64 mm) : I32vec2(mm) { }
        Is32vec2(signed int i0, signed int i1)
        {
                _MM_2DW(0,vec) = i1;
                _MM_2DW(1,vec) = i0;
        }
        EXPLICIT Is32vec2(int i) : I32vec2 (i)          {}
        EXPLICIT Is32vec2(__int64 i): I32vec2(i)        {}

        /* Assignment Operator */
        Is32vec2& operator= (const M64 &a)              { return *this = (Is32vec2) a; }

        /* Logical Assignment Operators */
        Is32vec2& operator&=(const M64 &a)              { return *this = (Is32vec2) _m_pand(vec,a); }
        Is32vec2& operator|=(const M64 &a)              { return *this = (Is32vec2) _m_por(vec,a); }
        Is32vec2& operator^=(const M64 &a)              { return *this = (Is32vec2) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Is32vec2& operator +=(const I32vec2 &a) { return *this = (Is32vec2) _m_paddd(vec,a); }
        Is32vec2& operator -=(const I32vec2 &a) { return *this = (Is32vec2) _m_psubd(vec,a); }

        /* Shift Logical Operators */
        Is32vec2 operator<<(const M64 &a)               { return _m_pslld(vec,a); }
        Is32vec2 operator<<(int count)                  { return _m_pslldi(vec,count); }
        Is32vec2& operator<<=(const M64 &a)             { return *this = (Is32vec2) _m_pslld(vec,a); }
        Is32vec2& operator<<=(int count)                { return *this = (Is32vec2) _m_pslldi(vec,count); }
        /* Shift Arithmetic Operations */
        Is32vec2 operator>>(const M64 &a)               { return _m_psrad(vec, a); }
        Is32vec2 operator>>(int count)                  { return _m_psradi(vec, count); }
        Is32vec2& operator>>=(const M64 &a)             { return *this = (Is32vec2) _m_psrad(vec, a); }
        Is32vec2& operator>>=(int count)                { return *this = (Is32vec2) _m_psradi(vec, count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Is32vec2 &a)
        {
                os << " [1]:" << _MM_2DW(1,a)
                << " [0]:" << _MM_2DW(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const int& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 2);       /* Only 2 elements to access */
                return _MM_2DW(i,vec);
        }

        /* Element Access and Assignment for Debug */
        int& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 2);       /* Only 2 elements to access */
                return _MM_2DW(i,vec);
        }
};

/* Compares */
inline Is32vec2 cmpeq(const Is32vec2 &a, const Is32vec2 &b)         { return _m_pcmpeqd(a,b); }
inline Is32vec2 cmpneq(const Is32vec2 &a, const Is32vec2 &b)        { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpgt(const Is32vec2 &a, const Is32vec2 &b)                     { return _m_pcmpgtd(a,b); }
inline Is32vec2 cmplt(const Is32vec2 &a, const Is32vec2 &b)                     { return _m_pcmpgtd(b,a); }
inline Is32vec2 cmple(const Is32vec2 &a, const Is32vec2 &b)                     { return _m_pandn(_m_pcmpgtd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpge(const Is32vec2 &a, const Is32vec2 &b)                     { return _m_pandn(_m_pcmpgtd(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks & Pack */
inline Is32vec2 unpack_low(const Is32vec2 &a, const Is32vec2 &b)        { return _m_punpckldq(a,b); }
inline Is32vec2 unpack_high(const Is32vec2 &a, const Is32vec2 &b)       { return _m_punpckhdq(a,b); }

/* Iu32vec2 Class:
 * 2 elements, each element unsigned int
 */
class Iu32vec2 : public I32vec2
{
public:
        Iu32vec2() { }
        Iu32vec2(__m64 mm) : I32vec2(mm) { }
        Iu32vec2(unsigned int ui0, unsigned int ui1)
        {
                _MM_2UDW(0,vec) = ui1;
                _MM_2UDW(1,vec) = ui0;
        }

        EXPLICIT Iu32vec2(int i) : I32vec2 (i)          { }
        EXPLICIT Iu32vec2(__int64 i) : I32vec2 (i)      { }

        /* Assignment Operator */
        Iu32vec2& operator= (const M64 &a)              { return *this = (Iu32vec2) a; }

        /* Logical Assignment Operators */
        Iu32vec2& operator&=(const M64 &a)              { return *this = (Iu32vec2) _m_pand(vec,a); }
        Iu32vec2& operator|=(const M64 &a)              { return *this = (Iu32vec2) _m_por(vec,a); }
        Iu32vec2& operator^=(const M64 &a)              { return *this = (Iu32vec2) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Iu32vec2& operator +=(const I32vec2 &a) { return *this = (Iu32vec2) _m_paddd(vec,a); }
        Iu32vec2& operator -=(const I32vec2 &a) { return *this = (Iu32vec2) _m_psubd(vec,a); }

        /* Shift Logical Operators */
        Iu32vec2 operator<<(const M64 &a)               { return _m_pslld(vec,a); }
        Iu32vec2 operator<<(int count)                  { return _m_pslldi(vec,count); }
        Iu32vec2& operator<<=(const M64 &a)             { return *this = (Iu32vec2) _m_pslld(vec,a); }
        Iu32vec2& operator<<=(int count)                { return *this = (Iu32vec2) _m_pslldi(vec,count); }
        Iu32vec2 operator>>(const M64 &a)               { return _m_psrld(vec,a); }
        Iu32vec2 operator>>(int count)                  { return _m_psrldi(vec,count); }
        Iu32vec2& operator>>=(const M64 &a)             { return *this = (Iu32vec2) _m_psrld(vec,a); }
        Iu32vec2& operator>>=(int count)                { return *this = (Iu32vec2) _m_psrldi(vec,count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Iu32vec2 &a)
        {
                os << " [1]:" << _MM_2UDW(1,a)
                << " [0]:" << _MM_2UDW(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const unsigned int& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 2);       /* Only 2 elements to access */
                return _MM_2UDW(i,vec);
        }

        /* Element Access and Assignment for Debug */
        unsigned int& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 2);       /* Only 2 elements to access */
                return _MM_2UDW(i,vec);
        }
};

/* Compares For Equality / Inequality */
inline Iu32vec2 cmpeq(const Iu32vec2 &a, const Iu32vec2 &b)         { return _m_pcmpeqd(a,b); }
inline Iu32vec2 cmpneq(const Iu32vec2 &a, const Iu32vec2 &b)        { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Iu32vec2 unpack_low(const Iu32vec2 &a, const Iu32vec2 &b)        {return _m_punpckldq(a,b); }
inline Iu32vec2 unpack_high(const Iu32vec2 &a, const Iu32vec2 &b)       {return _m_punpckhdq(a,b); }

/* I16vec4 Class:
 * 4 elements, each element either a signed or unsigned short
 */
class I16vec4 : public M64
{
public:
        I16vec4() { }
        I16vec4(__m64 mm) : M64(mm) { }
        EXPLICIT I16vec4(__int64 i) : M64 (i) { }
        EXPLICIT I16vec4(int i) : M64 (i) { }

        /* Assignment Operator */
        I16vec4& operator= (const M64 &a)                               { return *this = (I16vec4) a; }

        /* Addition & Subtraction Assignment Operators */
        I16vec4& operator&=(const M64 &a)                               { return *this = (I16vec4) _m_pand(vec,a); }
        I16vec4& operator|=(const M64 &a)                               { return *this = (I16vec4) _m_por(vec,a); }
        I16vec4& operator^=(const M64 &a)                               { return *this = (I16vec4) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I16vec4& operator +=(const I16vec4 &a)                  { return *this = (I16vec4)_m_paddw(vec,a); }
        I16vec4& operator -=(const I16vec4 &a)                  { return *this = (I16vec4)_m_psubw(vec,a); }
        I16vec4& operator *=(const I16vec4 &a)                  { return *this = (I16vec4)_m_pmullw(vec,a); }

        /* Shift Logical Operators */
        I16vec4 operator<<(const I16vec4 &a)                    { return _m_psllw(vec,a); }
        I16vec4 operator<<(int count)                               { return _m_psllwi(vec,count); }
        I16vec4& operator<<=(const I16vec4 &a)                  { return *this = (I16vec4)_m_psllw(vec,a); }
        I16vec4& operator<<=(int count)                                 { return *this = (I16vec4)_m_psllwi(vec,count); }
};

inline I16vec4 operator*(const I16vec4 &a, const I16vec4 &b)    { return _m_pmullw(a,b); }
inline I16vec4 cmpeq(const I16vec4 &a, const I16vec4 &b)            { return _m_pcmpeqw(a,b); }
inline I16vec4 cmpneq(const I16vec4 &a, const I16vec4 &b)           { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline I16vec4 unpack_low(const I16vec4 &a, const I16vec4 &b)   { return _m_punpcklwd(a,b); }
inline I16vec4 unpack_high(const I16vec4 &a, const I16vec4 &b)  { return _m_punpckhwd(a,b); }

/* Is16vec4 Class:
 * 4 elements, each element signed short
 */
class Is16vec4 : public I16vec4
{
public:
        Is16vec4() { }
        Is16vec4(__m64 mm) : I16vec4(mm) { }
        Is16vec4(short i0, short i1, short i2, short i3)
        {
                _MM_4W(0,vec) = i3;
                _MM_4W(1,vec) = i2;
                _MM_4W(2,vec) = i1;
                _MM_4W(3,vec) = i0;
        }

        EXPLICIT Is16vec4(__int64 i) : I16vec4 (i)      { }
        EXPLICIT Is16vec4(int i) : I16vec4 (i)          { }

        /* Assignment Operator */
        Is16vec4& operator= (const M64 &a)              { return *this = (Is16vec4) a; }

        /* Addition & Subtraction Assignment Operators */
        Is16vec4& operator&=(const M64 &a)              { return *this = (Is16vec4) _m_pand(vec,a); }
        Is16vec4& operator|=(const M64 &a)              { return *this = (Is16vec4) _m_por(vec,a); }
        Is16vec4& operator^=(const M64 &a)              { return *this = (Is16vec4) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Is16vec4& operator +=(const I16vec4 &a) { return *this = (Is16vec4)_m_paddw(vec,a); }
        Is16vec4& operator -=(const I16vec4 &a) { return *this = (Is16vec4)_m_psubw(vec,a); }
        Is16vec4& operator *=(const I16vec4 &a) { return *this = (Is16vec4)_m_pmullw(vec,a); }

        /* Shift Logical Operators */
        Is16vec4 operator<<(const M64 &a)               { return _m_psllw(vec,a); }
        Is16vec4 operator<<(int count)                  { return _m_psllwi(vec,count); }
        Is16vec4& operator<<=(const M64 &a)             { return *this = (Is16vec4)_m_psllw(vec,a); }
        Is16vec4& operator<<=(int count)                { return *this = (Is16vec4)_m_psllwi(vec,count); }
        /* Shift Arithmetic Operations */
        Is16vec4 operator>>(const M64 &a)               { return _m_psraw(vec,a); }
        Is16vec4 operator>>(int count)                  { return _m_psrawi(vec,count); }
        Is16vec4& operator>>=(const M64 &a)             { return *this = (Is16vec4) _m_psraw(vec,a); }
        Is16vec4& operator>>=(int count)                { return *this = (Is16vec4) _m_psrawi(vec,count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Is16vec4 &a)
        {
                os << "[3]:" << _MM_4W(3,a)
                        << " [2]:" << _MM_4W(2,a)
                        << " [1]:" << _MM_4W(1,a)
                        << " [0]:" << _MM_4W(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const short& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4W(i,vec);
        }

        /* Element Access for Debug */
        short& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4W(i,vec);
        }
};

inline Is16vec4 operator*(const Is16vec4 &a, const Is16vec4 &b)         { return _m_pmullw(a,b); }

/* Compares */
inline Is16vec4 cmpeq(const Is16vec4 &a, const Is16vec4 &b)         { return _m_pcmpeqw(a,b); }
inline Is16vec4 cmpneq(const Is16vec4 &a, const Is16vec4 &b)        { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpgt(const Is16vec4 &a, const Is16vec4 &b)                     { return _m_pcmpgtw(a,b); }
inline Is16vec4 cmplt(const Is16vec4 &a, const Is16vec4 &b)                     { return _m_pcmpgtw(b,a); }
inline Is16vec4 cmple(const Is16vec4 &a, const Is16vec4 &b)                     { return _m_pandn(_m_pcmpgtw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpge(const Is16vec4 &a, const Is16vec4 &b)                     { return _m_pandn(_m_pcmpgtw(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Is16vec4 unpack_low(const Is16vec4 &a, const Is16vec4 &b)        { return _m_punpcklwd(a,b); }
inline Is16vec4 unpack_high(const Is16vec4 &a, const Is16vec4 &b)       { return _m_punpckhwd(a,b); }

inline Is16vec4 sat_add(const Is16vec4 &a, const Is16vec4 &b)           { return _m_paddsw(a,b); }
inline Is16vec4 sat_sub(const Is16vec4 &a, const Is16vec4 &b)           { return _m_psubsw(a,b); }
inline Is16vec4 mul_high(const Is16vec4 &a, const Is16vec4 &b)          { return _m_pmulhw(a,b); }
inline Is32vec2 mul_add(const Is16vec4 &a, const Is16vec4 &b)           { return _m_pmaddwd(a,b);}


/* Iu16vec4 Class:
 * 4 elements, each element unsigned short
 */
class Iu16vec4 : public I16vec4
{
public:
        Iu16vec4() { }
        Iu16vec4(__m64 mm) : I16vec4(mm) { }
        Iu16vec4(unsigned short ui0, unsigned short ui1, unsigned short ui2, unsigned short ui3)
        {
                _MM_4UW(0,vec) = ui3;
                _MM_4UW(1,vec) = ui2;
                _MM_4UW(2,vec) = ui1;
                _MM_4UW(3,vec) = ui0;
        }
        EXPLICIT Iu16vec4(__int64 i) : I16vec4 (i) { }
        EXPLICIT Iu16vec4(int i) : I16vec4 (i) { }

        /* Assignment Operator */
        Iu16vec4& operator= (const M64 &a)              { return *this = (Iu16vec4) a; }

        /* Logical Assignment Operators */
        Iu16vec4& operator&=(const M64 &a)              { return *this = (Iu16vec4) _m_pand(vec,a); }
        Iu16vec4& operator|=(const M64 &a)              { return *this = (Iu16vec4) _m_por(vec,a); }
        Iu16vec4& operator^=(const M64 &a)              { return *this = (Iu16vec4) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Iu16vec4& operator +=(const I16vec4 &a) { return *this = (Iu16vec4)_m_paddw(vec,a); }
        Iu16vec4& operator -=(const I16vec4 &a) { return *this = (Iu16vec4)_m_psubw(vec,a); }
        Iu16vec4& operator *=(const I16vec4 &a) { return *this = (Iu16vec4)_m_pmullw(vec,a); }

        /* Shift Logical Operators */
        Iu16vec4 operator<<(const M64 &a)                               { return _m_psllw(vec,a); }
        Iu16vec4 operator<<(int count)                              { return _m_psllwi(vec,count); }
        Iu16vec4& operator<<=(const M64 &a)                             { return *this = (Iu16vec4)_m_psllw(vec,a); }
        Iu16vec4& operator<<=(int count)                                { return *this = (Iu16vec4)_m_psllwi(vec,count); }
        Iu16vec4 operator>>(const M64 &a)                               { return _m_psrlw(vec,a); }
        Iu16vec4 operator>>(int count)                              { return _m_psrlwi(vec,count); }
        Iu16vec4& operator>>=(const M64 &a)                             { return *this = (Iu16vec4) _m_psrlw(vec,a); }
        Iu16vec4& operator>>=(int count)                                { return *this = (Iu16vec4) _m_psrlwi(vec,count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Iu16vec4 &a)
        {
                os << "[3]:" << _MM_4UW(3,a)
                        << " [2]:" << _MM_4UW(2,a)
                        << " [1]:" << _MM_4UW(1,a)
                        << " [0]:" << _MM_4UW(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const unsigned short& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4UW(i,vec);
        }

        /* Element Access and Assignment for Debug */
        unsigned short& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4UW(i,vec);
        }
};

inline Iu16vec4 operator*(const Iu16vec4 &a, const Iu16vec4 &b)         { return _m_pmullw(a,b); }
inline Iu16vec4 cmpeq(const Iu16vec4 &a, const Iu16vec4 &b)         { return _m_pcmpeqw(a,b); }
inline Iu16vec4 cmpneq(const Iu16vec4 &a, const Iu16vec4 &b)        { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline Iu16vec4 sat_add(const Iu16vec4 &a, const Iu16vec4 &b)   { return _m_paddusw(a,b); }
inline Iu16vec4 sat_sub(const Iu16vec4 &a, const Iu16vec4 &b)   { return _m_psubusw(a,b); }

inline Iu16vec4 unpack_low(const Iu16vec4 &a, const Iu16vec4 &b)        { return _m_punpcklwd(a,b); }
inline Iu16vec4 unpack_high(const Iu16vec4 &a, const Iu16vec4 &b)       { return _m_punpckhwd(a,b); }

/* I8vec8 Class:
 * 8 elements, each element either unsigned or signed char
 */
class I8vec8 : public M64
{
public:
        I8vec8() { }
        I8vec8(__m64 mm) : M64(mm) { }
        EXPLICIT I8vec8(__int64 i) : M64 (i) { }
        EXPLICIT I8vec8(int i) : M64 (i) { }

        /* Assignment Operator */
        I8vec8& operator= (const M64 &a)                { return *this = (I8vec8) a; }

        /* Logical Assignment Operators */
        I8vec8& operator&=(const M64 &a)                { return *this = (I8vec8) _m_pand(vec,a); }
        I8vec8& operator|=(const M64 &a)                { return *this = (I8vec8) _m_por(vec,a); }
        I8vec8& operator^=(const M64 &a)                { return *this = (I8vec8) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I8vec8& operator +=(const I8vec8 &a)    { return *this = (I8vec8) _m_paddb(vec,a); }
        I8vec8& operator -=(const I8vec8 &a)    { return *this = (I8vec8) _m_psubb(vec,a); }
};


inline I8vec8 cmpeq(const I8vec8 &a, const I8vec8 &b)           { return _m_pcmpeqb(a,b); }
inline I8vec8 cmpneq(const I8vec8 &a, const I8vec8 &b)          { return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline I8vec8 unpack_low(const I8vec8 &a, const I8vec8 &b)      { return _m_punpcklbw(a,b); }
inline I8vec8 unpack_high(const I8vec8 &a, const I8vec8 &b) { return _m_punpckhbw(a,b); }

/* Is8vec8 Class:
 * 8 elements, each element signed char
 */
class Is8vec8 : public I8vec8
{
public:
        Is8vec8() { }
        Is8vec8(__m64 mm) : I8vec8(mm) { }
        Is8vec8(signed char s0,signed char s1,signed char s2,signed char s3,signed char s4,signed char s5,signed char s6,signed char s7)
         {
                _MM_8B(0,vec) = s7;
                _MM_8B(1,vec) = s6;
                _MM_8B(2,vec) = s5;
                _MM_8B(3,vec) = s4;
                _MM_8B(4,vec) = s3;
                _MM_8B(5,vec) = s2;
                _MM_8B(6,vec) = s1;
                _MM_8B(7,vec) = s0;
        }

        EXPLICIT Is8vec8(__int64 i) : I8vec8 (i) { }
        EXPLICIT Is8vec8(int i) : I8vec8 (i) { }

        /* Assignment Operator */
        Is8vec8& operator= (const M64 &a)               { return *this = (Is8vec8) a; }

        /* Logical Assignment Operators */
        Is8vec8& operator&=(const M64 &a)               { return *this = (Is8vec8) _m_pand(vec,a); }
        Is8vec8& operator|=(const M64 &a)               { return *this = (Is8vec8) _m_por(vec,a); }
        Is8vec8& operator^=(const M64 &a)               { return *this = (Is8vec8) _m_pxor(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Is8vec8& operator +=(const I8vec8 &a)   { return *this = (Is8vec8) _m_paddb(vec,a); }
        Is8vec8& operator -=(const I8vec8 &a)   { return *this = (Is8vec8) _m_psubb(vec,a); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Is8vec8 &a)
        {
                os << "[7]:" << short(_MM_8B(7,a))
                        << " [6]:" << short(_MM_8B(6,a))
                        << " [5]:" << short(_MM_8B(5,a))
                        << " [4]:" << short(_MM_8B(4,a))
                        << " [3]:" << short(_MM_8B(3,a))
                        << " [2]:" << short(_MM_8B(2,a))
                        << " [1]:" << short(_MM_8B(1,a))
                        << " [0]:" << short(_MM_8B(0,a));
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const signed char& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8B(i,vec);
        }

        /* Element Access and Assignment for Debug */
        signed char& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8B(i,vec);
        }
};

/* Additional Is8vec8 functions: compares, unpacks, sat add/sub */
inline Is8vec8 cmpeq(const Is8vec8 &a, const Is8vec8 &b)                { return _m_pcmpeqb(a,b); }
inline Is8vec8 cmpneq(const Is8vec8 &a, const Is8vec8 &b)               { return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpgt(const Is8vec8 &a, const Is8vec8 &b)                { return _m_pcmpgtb(a,b); }
inline Is8vec8 cmplt(const Is8vec8 &a, const Is8vec8 &b)                { return _m_pcmpgtb(b,a); }
inline Is8vec8 cmple(const Is8vec8 &a, const Is8vec8 &b)                { return _m_pandn(_m_pcmpgtb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpge(const Is8vec8 &a, const Is8vec8 &b)                { return _m_pandn(_m_pcmpgtb(b,a), M64(0xffffffffffffffffi64)); }

inline Is8vec8 unpack_low(const Is8vec8 &a, const Is8vec8 &b)   { return _m_punpcklbw(a,b); }
inline Is8vec8 unpack_high(const Is8vec8 &a, const Is8vec8 &b)  { return _m_punpckhbw(a,b); }

inline Is8vec8 sat_add(const Is8vec8 &a, const Is8vec8 &b)              { return _m_paddsb(a,b); }
inline Is8vec8 sat_sub(const Is8vec8 &a, const Is8vec8 &b)              { return _m_psubsb(a,b); }

/* Iu8vec8 Class:
 * 8 elements, each element unsigned char
 */
class Iu8vec8 : public I8vec8
{
public:
        Iu8vec8() { }
        Iu8vec8(__m64 mm) : I8vec8(mm) { }
        Iu8vec8(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsigned char s5,unsigned char s6,unsigned char s7)
        {
                _MM_8UB(0,vec) = s7;
                _MM_8UB(1,vec) = s6;
                _MM_8UB(2,vec) = s5;
                _MM_8UB(3,vec) = s4;
                _MM_8UB(4,vec) = s3;
                _MM_8UB(5,vec) = s2;
                _MM_8UB(6,vec) = s1;
                _MM_8UB(7,vec) = s0;
        }
        EXPLICIT Iu8vec8(__int64 i) : I8vec8 (i) { }
        EXPLICIT Iu8vec8(int i) : I8vec8 (i) { }

        /* Assignment Operator */
        Iu8vec8& operator= (const M64 &a)               { return *this = (Iu8vec8) a; }
        /* Logical Assignment Operators */
        Iu8vec8& operator&=(const M64 &a)               { return *this = (Iu8vec8) _m_pand(vec,a); }
        Iu8vec8& operator|=(const M64 &a)               { return *this = (Iu8vec8) _m_por(vec,a); }
        Iu8vec8& operator^=(const M64 &a)               { return *this = (Iu8vec8) _m_pxor(vec,a); }
        /* Addition & Subtraction Assignment Operators */
        Iu8vec8& operator +=(const I8vec8 &a)   { return *this = (Iu8vec8) _m_paddb(vec,a); }
        Iu8vec8& operator -=(const I8vec8 &a)   { return *this = (Iu8vec8) _m_psubb(vec,a); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator << (std::ostream &os, const Iu8vec8 &a)
        {
                 os << "[7]:"  << unsigned short(_MM_8UB(7,a))
                        << " [6]:" << unsigned short(_MM_8UB(6,a))
                        << " [5]:" << unsigned short(_MM_8UB(5,a))
                        << " [4]:" << unsigned short(_MM_8UB(4,a))
                        << " [3]:" << unsigned short(_MM_8UB(3,a))
                        << " [2]:" << unsigned short(_MM_8UB(2,a))
                        << " [1]:" << unsigned short(_MM_8UB(1,a))
                        << " [0]:" << unsigned short(_MM_8UB(0,a));
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const unsigned char& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8UB(i,vec);
        }

        /* Element Access for Debug */
        unsigned char& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8UB(i,vec);
        }
};

/* Additional Iu8vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu8vec8 cmpeq(const Iu8vec8 &a, const Iu8vec8 &b)                { return _m_pcmpeqb(a,b); }
inline Iu8vec8 cmpneq(const Iu8vec8 &a, const Iu8vec8 &b)               { return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline Iu8vec8 unpack_low(const Iu8vec8 &a, const Iu8vec8 &b)   { return _m_punpcklbw(a,b); }
inline Iu8vec8 unpack_high(const Iu8vec8 &a, const Iu8vec8 &b)  { return _m_punpckhbw(a,b); }

inline Iu8vec8 sat_add(const Iu8vec8 &a, const Iu8vec8 &b)              { return _m_paddusb(a,b); }
inline Iu8vec8 sat_sub(const Iu8vec8 &a, const Iu8vec8 &b)              { return _m_psubusb(a,b); }

inline Is16vec4 pack_sat(const Is32vec2 &a, const Is32vec2 &b)          { return _m_packssdw(a,b); }
inline Is8vec8 pack_sat(const Is16vec4 &a, const Is16vec4 &b)           { return _m_packsswb(a,b); }
inline Iu8vec8 packu_sat(const Is16vec4 &a, const Is16vec4 &b)  { return _m_packuswb(a,b); }

/********************************* Logicals ****************************************/
#define IVEC_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pand( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_por( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pxor( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pandn( a,b); }

IVEC_LOGICALS(8,8)
IVEC_LOGICALS(u8,8)
IVEC_LOGICALS(s8,8)
IVEC_LOGICALS(16,4)
IVEC_LOGICALS(u16,4)
IVEC_LOGICALS(s16,4)
IVEC_LOGICALS(32,2)
IVEC_LOGICALS(u32,2)
IVEC_LOGICALS(s32,2)
IVEC_LOGICALS(64,1)
#undef IVEC_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_padd##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_psub##opsize( a,b); }

IVEC_ADD_SUB(8,8, b)
IVEC_ADD_SUB(u8,8, b)
IVEC_ADD_SUB(s8,8, b)
IVEC_ADD_SUB(16,4, w)
IVEC_ADD_SUB(u16,4, w)
IVEC_ADD_SUB(s16,4, w)
IVEC_ADD_SUB(32,2, d)
IVEC_ADD_SUB(u32,2, d)
IVEC_ADD_SUB(s32,2, d)
#undef IVEC_ADD_SUB

/********************************* Conditional Select ****************************************/
/*      version of: retval = (a OP b)? c : d;                                                                                                    *
 *      Where OP is one of the possible comparision operators.                                                                   *
 *      Example: r = select_eq(a,b,c,d);                                                                                                                 *
 *      if "member at position x of the vector a" == "member at position x of vector b"                  *
 *      assign the corresponding member in r from c, else assign from d.                                                         *
 ********************************* Conditional Select ****************************************/

#define IVEC_SELECT(vect12,vect34,element,selop,arg1,arg2) \
        inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d)     \
{                                                                                                                               \
        I##vect12##vec##element mask = cmp##selop(a,b);                                         \
        return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_m_pandn(mask, arg2 )))));  \
}
IVEC_SELECT(8,s8,8,eq,c,d)
IVEC_SELECT(8,u8,8,eq,c,d)
IVEC_SELECT(8,8,8,eq,c,d)
IVEC_SELECT(8,s8,8,neq,c,d)
IVEC_SELECT(8,u8,8,neq,c,d)
IVEC_SELECT(8,8,8,neq,c,d)

IVEC_SELECT(16,s16,4,eq,c,d)
IVEC_SELECT(16,u16,4,eq,c,d)
IVEC_SELECT(16,16,4,eq,c,d)
IVEC_SELECT(16,s16,4,neq,c,d)
IVEC_SELECT(16,u16,4,neq,c,d)
IVEC_SELECT(16,16,4,neq,c,d)

IVEC_SELECT(32,s32,2,eq,c,d)
IVEC_SELECT(32,u32,2,eq,c,d)
IVEC_SELECT(32,32,2,eq,c,d)
IVEC_SELECT(32,s32,2,neq,c,d)
IVEC_SELECT(32,u32,2,neq,c,d)
IVEC_SELECT(32,32,2,neq,c,d)


IVEC_SELECT(s8,s8,8,gt,c,d)
IVEC_SELECT(s8,u8,8,gt,c,d)
IVEC_SELECT(s8,8,8,gt,c,d)
IVEC_SELECT(s8,s8,8,lt,c,d)
IVEC_SELECT(s8,u8,8,lt,c,d)
IVEC_SELECT(s8,8,8,lt,c,d)
IVEC_SELECT(s8,s8,8,le,c,d)
IVEC_SELECT(s8,u8,8,le,c,d)
IVEC_SELECT(s8,8,8,le,c,d)
IVEC_SELECT(s8,s8,8,ge,c,d)
IVEC_SELECT(s8,u8,8,ge,c,d)
IVEC_SELECT(s8,8,8,ge,c,d)

IVEC_SELECT(s16,s16,4,gt,c,d)
IVEC_SELECT(s16,u16,4,gt,c,d)
IVEC_SELECT(s16,16,4,gt,c,d)
IVEC_SELECT(s16,s16,4,lt,c,d)
IVEC_SELECT(s16,u16,4,lt,c,d)
IVEC_SELECT(s16,16,4,lt,c,d)
IVEC_SELECT(s16,s16,4,le,c,d)
IVEC_SELECT(s16,u16,4,le,c,d)
IVEC_SELECT(s16,16,4,le,c,d)
IVEC_SELECT(s16,s16,4,ge,c,d)
IVEC_SELECT(s16,u16,4,ge,c,d)
IVEC_SELECT(s16,16,4,ge,c,d)

IVEC_SELECT(s32,s32,2,gt,c,d)
IVEC_SELECT(s32,u32,2,gt,c,d)
IVEC_SELECT(s32,32,2,gt,c,d)
IVEC_SELECT(s32,s32,2,lt,c,d)
IVEC_SELECT(s32,u32,2,lt,c,d)
IVEC_SELECT(s32,32,2,lt,c,d)
IVEC_SELECT(s32,s32,2,le,c,d)
IVEC_SELECT(s32,u32,2,le,c,d)
IVEC_SELECT(s32,32,2,le,c,d)
IVEC_SELECT(s32,s32,2,ge,c,d)
IVEC_SELECT(s32,u32,2,ge,c,d)
IVEC_SELECT(s32,32,2,ge,c,d)


#undef IVEC_SELECT

inline static void empty(void)          { _m_empty(); }

#if defined (_SILENCE_IVEC_C4799)
        #pragma warning(pop)
#endif  /* defined (_SILENCE_IVEC_C4799) */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* RC_INVOKED */
#endif  /* _IVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\locale_implib_pure.cpp ===
#define STDCPP_IMPLIB 1
#include "locale.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\localtim.c ===
/***
*localtim.c - Convert __time32_t value to time structure
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts time stored as a __time32_t value to a structure of type
*       struct tm expressed as local time.
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <time.h>
#include <stddef.h>
#include <memory.h>
#include <ctime.h>
#include <internal.h>


/***
*struct tm *_localtime32_s(ptm, ptime) - convert __time32_t value to tm structure
*
*Purpose:
*       Convert a value in 32-bit internal (__time32_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime and localtime use a single statically allocated buffer.
*           Each call to one of these routines destroys the contents of the
*           previous call.
*       (3) __time32_t is a 32-bit long integer representing the number of seconds
*           since 00:00:00, 01-01-70 (UTC) (i.e., the Posix/Unix Epoch. Only
*           non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       __time32_t *ptime - pointer to a long time value
*
*Exit:
*       errno_t = 0 success
*                 tm members filled-in
*       errno_t = non zero
*                 tm members initialized to -1 if ptm != NULL
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

errno_t __cdecl _localtime32_s (
        struct tm *ptm,
        const __time32_t *ptime
        )
{
        __time32_t ltime;
        errno_t e = 0;
        int daylight = 0;
        long dstbias = 0;
        long timezone = 0;

        _VALIDATE_RETURN_ERRCODE( ( ptm != NULL ), EINVAL )
        memset( ptm, 0xff, sizeof( struct tm ) );

        _VALIDATE_RETURN_ERRCODE( ( ptime != NULL ), EINVAL )

        /*
         * Check for illegal __time32_t value
         */
        _VALIDATE_RETURN_ERRCODE_NOEXC( ( *ptime >= 0 ), EINVAL )

        __tzset();

        _ERRCHECK(_get_daylight(&daylight));
        _ERRCHECK(_get_dstbias(&dstbias));
        _ERRCHECK(_get_timezone(&timezone));


        if ( (*ptime > 3 * _DAY_SEC) && (*ptime < LONG_MAX - 3 * _DAY_SEC) ) {
                /*
                 * The date does not fall within the first three, or last
                 * three, representable days of the Epoch. Therefore, there
                 * is no possibility of overflowing or underflowing the
                 * __time32_t representation as we compensate for timezone and
                 * Daylight Savings Time.
                 */

                ltime = *ptime - timezone;
                e = _gmtime32_s( ptm, &ltime );
                if ( e != 0 )
                {
                    return e;
                }

                /*
                 * Check and adjust for Daylight Saving Time.
                 */
                if ( daylight && _isindst( ptm ) ) {
                        ltime -= dstbias;
                        e = _gmtime32_s( ptm, &ltime );
                        if ( e != 0 )
                        {
                            return e;
                        }
                        ptm->tm_isdst = 1;
                }
        }
        else {
                e = _gmtime32_s( ptm, ptime );
                if ( e != 0 )
                {
                    return e;
                }

                /*
                     * The date falls with the first three, or last three days
                 * of the Epoch. It is possible the __time32_t representation
                 * would overflow or underflow while compensating for
                 * timezone and Daylight Savings Time. Therefore, make the
                 * timezone and Daylight Savings Time adjustments directly
                 * in the tm structure. The beginning of the Epoch is
                 * 00:00:00, 01-01-70 (UTC) and the last representable second
                 * in the Epoch is 03:14:07, 01-19-2038 (UTC). This will be
                 * used in the calculations below.
                 *
                 * First, adjust for the timezone.
                 */
                if ( daylight && _isindst(ptm) ) {
                        ltime = (__time32_t)ptm->tm_sec - (timezone + dstbias);
                        ptm->tm_isdst = 1;
                }
                else
                        ltime = (__time32_t)ptm->tm_sec - timezone;
                ptm->tm_sec = (int)(ltime % 60);
                if ( ptm->tm_sec < 0 ) {
                        ptm->tm_sec += 60;
                        ltime -= 60;
                }

                ltime = (__time32_t)ptm->tm_min + ltime/60;
                ptm->tm_min = (int)(ltime % 60);
                if ( ptm->tm_min < 0 ) {
                        ptm->tm_min += 60;
                        ltime -= 60;
                }

                ltime = (__time32_t)ptm->tm_hour + ltime/60;
                ptm->tm_hour = (int)(ltime % 24);
                if ( ptm->tm_hour < 0 ) {
                        ptm->tm_hour += 24;
                        ltime -=24;
                }

                ltime /= 24;

                if ( ltime > 0 ) {
                        /*
                         * There is no possibility of overflowing the tm_mday
                         * and tm_yday fields since the date can be no later
                         * than January 19.
                         */
                        ptm->tm_wday = (ptm->tm_wday + (int)ltime) % 7;
                        ptm->tm_mday += (int)ltime;
                        ptm->tm_yday += (int)ltime;
                }
                else if ( ltime < 0 ) {
                        /*
                         * It is possible to underflow the tm_mday and tm_yday
                         * fields. If this happens, then adjusted date must
                         * lie in December 1969.
                         */
                        ptm->tm_wday = (ptm->tm_wday + 7 + (int)ltime) % 7;
                        if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                ptm->tm_mday += 31;
                                // according to assumption 4 above, timezone can
                                // cause the date to underflow the epoch by
                                // more than a day
                                ptm->tm_yday = ptm->tm_yday + (int)ltime + 365;
                                ptm->tm_mon = 11;
                                ptm->tm_year--;
                        }
                        else {
                                ptm->tm_yday += (int)ltime;
                        }
                }


        }


        return 0;
}


/***
*struct tm *_localtime32(ptime) - convert __time32_t value to tm structure
*
*Purpose:
*       Convert a value in 32-bit internal (__time32_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime and localtime use a single statically allocated buffer.
*           Each call to one of these routines destroys the contents of the
*           previous call.
*       (3) It is assumed that __time32_t is a 32-bit long integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       __time32_t *ptime - pointer to a long time value
*
*Exit:
*       If *ptime is non-negative, returns a pointer to the tm structure.
*       Otherwise, returns NULL.
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

struct tm * __cdecl _localtime32 (
        const __time32_t *ptime
        )
{
        errno_t e;
        struct tm *ptm = __getgmtimebuf();
        if ( ptm == NULL )
        {
            return NULL;
        }

        e = _localtime32_s( ptm, ptime );
        if ( e != 0 )
        {
            return NULL;
        }
        return ptm;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lsearch_s.c ===
/***
*lsearch_s.c - linear search of an array
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   contains the _lsearch_s() function - linear search of an array
*
*******************************************************************************/

/***
*char *_lsearch_s(key, base, num, width, compare, context) - do a linear search
*
*Purpose:
*   Performs a linear search on the array, looking for the value key
*   in an array of num elements of width bytes in size.  Returns
*   a pointer to the array value if found; otherwise adds the
*   key to the end of the list.
*
*Entry:
*   char *key - key to search for
*   char *base - base of array to search
*   unsigned *num - number of elements in array
*   int width - number of bytes in each array element
*   int (*compare)() - pointer to function that compares two
*       array values, returning 0 if they are equal and non-0
*       if they are different. Two pointers to array elements
*       are passed to this function, together with a pointer to
*       a context.
*   void *context - pointer to the context in which the function is
*       called. This context is passed to the comparison function.
*
*Exit:
*   if key found:
*       returns pointer to array element
*   if key not found:
*       adds the key to the end of the list, and increments
*       *num.
*       returns pointer to new element.
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "lsearch.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lfind_s.c ===
/***
*lfind_s.c - do a linear search
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines _lfind_s() - do a linear search of an array.
*
*******************************************************************************/

/***
*char *_lfind_s(key, base, num, width, compare, context) - do a linear search
*
*Purpose:
*   Performs a linear search on the array, looking for the value key
*   in an array of num elements of width bytes in size.  Returns
*   a pointer to the array value if found, NULL if not found.
*   The function accepts a context pointer as last parameter, which is
*   passed to comparison function.
*
*Entry:
*   char *key - key to search for
*   char *base - base of array to search
*   unsigned *num - number of elements in array
*   int width - number of bytes in each array element
*   int (*compare)() - pointer to function that compares two
*       array values, returning 0 if they are equal and non-0
*       if they are different.  Two pointers to array elements
*       are passed to this function, together with a pointer to
*       a context.
*   void *context - pointer to the context in which the function is
*       called. This context is passed to the comparison function.
*
*Exit:
*   if key found:
*       returns pointer to array element
*   if key not found:
*       returns NULL
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "lfind.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\locking.c ===
/***
*locking.c - file locking function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defined the _locking() function - file locking and unlocking
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <sys\locking.h>
#include <io.h>
#include <stdlib.h>
#include <internal.h>
#include <msdos.h>
#include <mtdll.h>

static int __cdecl _locking_nolock(int, int, long);

/***
*int _locking(fh,lmode,nbytes) - file record locking function
*
*Purpose:
*       Locks or unlocks nbytes of a specified file
*
*       Multi-thread - Must lock/unlock the file handle to prevent
*       other threads from working on the file at the same time as us.
*       [NOTE: We do NOT release the lock during the 1 second delays
*       since some other thread could get in and do something to the
*       file.  The DOSFILELOCK call locks out other processes, not
*       threads, so there is no multi-thread deadlock at the DOS file
*       locking level.]
*
*Entry:
*       int fh -        file handle
*       int lmode -     locking mode:
*                           _LK_LOCK/_LK_RLCK -> lock, retry 10 times
*                           _LK_NBLCK/_LK_N_BRLCK -> lock, don't retry
*                           _LK_UNLCK -> unlock
*       long nbytes -   number of bytes to lock/unlock
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _locking (
        int fh,
        int lmode,
        long nbytes
        )
{
        int retval;

        /* validate file handle */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);


        _lock_fh(fh);                   /* acquire file handle lock */

        __try {
                if ( _osfile(fh) & FOPEN )
                        retval = _locking_nolock(fh, lmode, nbytes);
                else {
                        errno = EBADF;
                        _doserrno = 0;  /* not an o.s. error */
                        retval = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(fh);
        }

        return retval;
}

static int __cdecl _locking_nolock (
        int fh,
        int lmode,
        long nbytes
        )
{
        ULONG dosretval;                /* o.s. return code */
        LONG lockoffset;
        int retry;                      /* retry count */


        /* obtain current position in file by calling _lseek */
        /* Use _lseek_nolock as we already own lock */
        lockoffset = _lseek_nolock(fh, 0L, 1);
        if (lockoffset == -1)
                return -1;

        /* set retry count based on mode */
        if (lmode == _LK_LOCK || lmode == _LK_RLCK)
                retry = 9;              /* retry 9 times */
        else
                retry = 0;              /* don't retry */

        /* ask o.s. to lock the file until success or retry count finished */
        /* note that the only error possible is a locking violation, since */
        /* an invalid handle would have already failed above */
        for (;;) {

                dosretval = 0;
                if (lmode == _LK_UNLCK) {
                    if ( !(UnlockFile((HANDLE)_get_osfhandle(fh),
                                      lockoffset,
                                      0L,
                                      nbytes,
                                      0L))
                       )
                        dosretval = GetLastError();

                } else {
                    if ( !(LockFile((HANDLE)_get_osfhandle(fh),
                                    lockoffset,
                                    0L,
                                    nbytes,
                                    0L))
                       )
                        dosretval = GetLastError();
                }

                if (retry <= 0 || dosretval == 0)
                        break;  /* exit loop on success or retry exhausted */

                Sleep(1000L);

                --retry;
        }

        if (dosretval != 0) {
                /* o.s. error occurred -- file was already locked; if a
                   blocking call, then return EDEADLOCK, otherwise map
                   error normally */
                if (lmode == _LK_LOCK || lmode == _LK_RLCK) {
                        errno = EDEADLOCK;
                        _doserrno = dosretval;
                }
                else {
                        _dosmaperr(dosretval);
                }
                return -1;
        }
        else
                return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\makepath.c ===
/***
*makepath.c - create path name from components
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To provide support for creation of full path names from components
*
*******************************************************************************/

#include <mtdll.h>
#include <cruntime.h>
#include <stdlib.h>
#ifdef _MBCS
#include <mbdata.h>
#include <mbstring.h>
#endif  /* _MBCS */
#include <tchar.h>
#include <internal.h>
#include <limits.h>

/***
*void _makepath - build path name from components
*
*Purpose:
*       create a path name from its individual components
*
*Entry:
*       _TSCHAR *path  - pointer to buffer for constructed path
*       _TSCHAR *drive - pointer to drive component, may or may not contain
*                     trailing ':'
*       _TSCHAR *dir   - pointer to subdirectory component, may or may not include
*                     leading and/or trailing '/' or '\' characters
*       _TSCHAR *fname - pointer to file base name component
*       _TSCHAR *ext   - pointer to extension component, may or may not contain
*                     a leading '.'.
*
*Exit:
*       path - pointer to constructed path name
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _tmakepath (
        register _TSCHAR *path,
        const _TSCHAR *drive,
        const _TSCHAR *dir,
        const _TSCHAR *fname,
        const _TSCHAR *ext
        )
{
        _tmakepath_s(path, (size_t)-1, drive, dir, fname, ext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\makepath_s.c ===
/***
*makepath_s.c - create path name from components
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   To provide support for creation of full path names from components
*
*******************************************************************************/

#include <stdlib.h>
#include <mbstring.h>
#include <internal_securecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _makepath_s
#define _CHAR char
#define _DEST _Dst
#define _SIZE _SizeInBytes
#define _T(_Character) _Character

#define _MBS_SUPPORT 1

#include <tmakepath_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\loctim64.c ===
/***
*loctim64.c - Convert __time64_t value to time structure
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts time stored as a __time64_t value to a structure of type
*       struct tm expressed as local time.
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <time.h>
#include <stddef.h>
#include <memory.h>
#include <ctime.h>
#include <internal.h>


/***
*struct tm *_localtime64_s(ptm, ptime) - convert __time64_t value to tm structure
*
*Purpose:
*       Convert a value in 64-bit internal (__time64_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime, _gtime64, localtime and _localtime64() all use a single
*           statically allocated buffer. Each call to one of these routines
*           destroys the contents of the previous call.
*       (3) It is assumed that __time64_t is a 64-bit integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       __time64_t *ptime - pointer to a long time value
*
*Exit:
*       errno_t = 0 success
*                 tm members filled-in
*       errno_t = non zero
*                 tm members initialized to -1 if ptm != NULL
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

errno_t __cdecl _localtime64_s (
        struct tm *ptm,
        const __time64_t *ptime
        )
{
        __time64_t ltime;
        errno_t e = 0;
        int daylight = 0;
        long dstbias = 0;
        long timezone = 0;

        _VALIDATE_RETURN_ERRCODE( ( ptm != NULL ), EINVAL )
        memset( ptm, 0xff, sizeof( struct tm ) );

        _VALIDATE_RETURN_ERRCODE( ( ptime != NULL ), EINVAL )

        /*
         * Check for illegal __time64_t value
         */
        _VALIDATE_RETURN_ERRCODE_NOEXC( (*ptime >= 0), EINVAL);
        _VALIDATE_RETURN_ERRCODE_NOEXC( (*ptime <= _MAX__TIME64_T), EINVAL);

        __tzset();

        _ERRCHECK(_get_daylight(&daylight));
        _ERRCHECK(_get_dstbias(&dstbias));
        _ERRCHECK(_get_timezone(&timezone));

        if ( *ptime > 3 * _DAY_SEC ) {
                /*
                 * The date does not fall within the first three representable
                 * days of the Epoch. Therefore, there is no possibility of
                 * underflowing the __time64_t representation as we compensate
                 * for timezone and Daylight Savings Time.
                 */

                ltime = *ptime - timezone;
                e = _gmtime64_s( ptm, &ltime );
                if ( e != 0)
                {
                    return e;
                }

                /*
                 * Check and adjust for Daylight Saving Time.
                 */
                if ( daylight && _isindst( ptm ) ) {
                        ltime -= dstbias;
                        e = _gmtime64_s( ptm, &ltime );
                        if ( e != 0 )
                        {
                            return e;
                        }
                        ptm->tm_isdst = 1;
                }
        }
        else {
                e = _gmtime64_s( ptm, ptime );
                if ( e != 0 )
                {
                    return e;
                }

                /*
                 * The date falls with the first three days of the Epoch.
                 * It is possible the time_t representation would underflow
                 * while compensating for timezone and Daylight Savings Time
                 * Therefore, make the timezone and Daylight Savings Time
                 * adjustments directly in the tm structure. The beginning of
                 * the Epoch is 00:00:00, 01-01-70 (UTC).
                 *
                 * First, adjust for the timezone.
                 */
                if ( daylight && _isindst(ptm) ) {
                        ltime = (__time64_t)ptm->tm_sec - (timezone + dstbias);
                        ptm->tm_isdst = 1;
                }
                else
                        ltime = (__time64_t)ptm->tm_sec - timezone;

                ptm->tm_sec = (int)(ltime % 60);
                if ( ptm->tm_sec < 0 ) {
                        ptm->tm_sec += 60;
                        ltime -= 60;
                }

                ltime = (__time64_t)ptm->tm_min + ltime/60;
                ptm->tm_min = (int)(ltime % 60);
                if ( ptm->tm_min < 0 ) {
                        ptm->tm_min += 60;
                        ltime -= 60;
                }

                ltime = (__time64_t)ptm->tm_hour + ltime/60;
                ptm->tm_hour = (int)(ltime % 24);
                if ( ptm->tm_hour < 0 ) {
                        ptm->tm_hour += 24;
                        ltime -=24;
                }

                ltime /= 24;

                if ( ltime > 0 ) {
                        /*
                         * There is no possibility of overflowing the tm_mday
                         * and tm_yday fields since the date can be no later
                         * than January 19.
                         */
                        ptm->tm_wday = (ptm->tm_wday + (int)ltime) % 7;
                        ptm->tm_mday += (int)ltime;
                        ptm->tm_yday += (int)ltime;
                }
                else if ( ltime < 0 ) {
                        /*
                         * It is possible to underflow the tm_mday and tm_yday
                         * fields. If this happens, then adjusted date must
                         * lie in December 1969.
                         */
                        ptm->tm_wday = (ptm->tm_wday + 7 + (int)ltime) % 7;
                        if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                ptm->tm_mday += 31;
                                // according to assumption 4 above, timezone can
                                // cause the date to underflow the epoch by
                                // more than a day
                                ptm->tm_yday = ptm->tm_yday + (int)ltime + 365;
                                ptm->tm_mon = 11;
                                ptm->tm_year--;
                        }
                        else {
                                ptm->tm_yday += (int)ltime;
                        }
                }
        }


        return 0;
}

/***
*struct tm *_localtime64(ptime) - convert __time64_t value to tm structure
*
*Purpose:
*       Convert a value in 64-bit internal (__time64_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime, _gtime64, localtime and _localtime64() all use a single
*           statically allocated buffer. Each call to one of these routines
*           destroys the contents of the previous call.
*       (3) It is assumed that __time64_t is a 64-bit integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       __time64_t *ptime - pointer to a long time value
*
*Exit:
*       If *ptime is non-negative, returns a pointer to the tm structure.
*       Otherwise, returns NULL.
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

struct tm * __cdecl _localtime64 (
        const __time64_t *ptime
        )
{
        errno_t e;
        struct tm *ptm = __getgmtimebuf();
        if ( ptm == NULL )
        {
            return NULL;
        }

        e = _localtime64_s( ptm, ptime );
        if ( e != 0 )
        {
            return NULL;
        }
        return ptm;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\malloc.c ===
/***
*malloc.c - Get a block of memory from the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the malloc() function.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rterr.h>

#include <windows.h>
#include <winheap.h>
#include <rtcsup.h>

extern int _newmode;    /* malloc new() handler mode */

#ifndef _WIN64

void *V6_HeapAlloc(size_t size)
{
    void *pvReturn = NULL;
    if ( size <= __sbh_threshold )
    {
        _mlock( _HEAP_LOCK );
        __try {
            pvReturn = __sbh_alloc_block((int)size);
        }
        __finally {
            _munlock( _HEAP_LOCK );
        }
    }
    return pvReturn;
}

#ifdef CRTDLL
void *V5_HeapAlloc(size_t size)
{
    void * pvReturn = NULL;

    /* round up to the nearest paragraph */
    if ( size ) {
        size = (size + _OLD_PARASIZE - 1) & ~(_OLD_PARASIZE - 1);
    } else {
        size = _OLD_PARASIZE;
    }

    if ( size  <= __old_sbh_threshold ) {
        _mlock(_HEAP_LOCK);
        __try {
            pvReturn = __old_sbh_alloc_block(size >> _OLD_PARASHIFT);
        }
        __finally {
            _munlock(_HEAP_LOCK);
        }
    }
    return pvReturn;
}
#endif  /* CRTDLL */
#endif  /* _WIN64 */

#ifdef _DEBUG
#define _heap_alloc _heap_alloc_base
#endif  /* _DEBUG */

/***
*void *_heap_alloc_base(size_t size) - does actual allocation
*
*Purpose:
*       Same as malloc() except the new handler is not called.
*
*Entry:
*       See malloc
*
*Exit:
*       See malloc
*
*Exceptions:
*
*******************************************************************************/

__forceinline void * __cdecl _heap_alloc (size_t size)

{
#ifndef _WIN64
    void *pvReturn;
#endif  /* _WIN64 */

    if (_crtheap == 0) {
        _FF_MSGBANNER();    /* write run-time error banner */
        _NMSG_WRITE(_RT_CRT_NOTINIT);  /* write message */
        __crtExitProcess(255);  /* normally _exit(255) */
    }

#ifdef _WIN64
    return HeapAlloc(_crtheap, 0, size ? size : 1);
#else  /* _WIN64 */
    if (__active_heap == __SYSTEM_HEAP) {
        return HeapAlloc(_crtheap, 0, size ? size : 1);
    } else
    if ( __active_heap == __V6_HEAP ) {
        if (pvReturn = V6_HeapAlloc(size)) {
            return pvReturn;
        }
    }
#ifdef CRTDLL
    else if ( __active_heap == __V5_HEAP )
    {
        if (pvReturn = V5_HeapAlloc(size)) {
            return pvReturn;
        }
    }
#endif  /* CRTDLL */

    if (size == 0)
        size = 1;

    size = (size + BYTES_PER_PARA - 1) & ~(BYTES_PER_PARA - 1);

    return HeapAlloc(_crtheap, 0, size);

#endif  /* _WIN64 */
}


/***
*void *malloc(size_t size) - Get a block of memory from the heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the heap and
*       return a pointer to it.
*
*       Calls the new appropriate new handler (if installed).
*
*Entry:
*       size_t size - size of block requested
*
*Exit:
*       Success:  Pointer to memory block
*       Failure:  NULL (or some error value)
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _malloc_base (size_t size)
{
    void *res = NULL;

    //  validate size
    if (size <= _HEAP_MAXREQ) {
        for (;;) {

            //  allocate memory block
            res = _heap_alloc(size);

            //  if successful allocation, return pointer to memory
            //  if new handling turned off altogether, return NULL

            if (res != NULL)
            {
                break;
            }
            if (_newmode == 0)
            {
                errno = ENOMEM;
                break;
            }

            //  call installed new handler
            if (!_callnewh(size))
                break;

            //  new handler was successful -- try to allocate again
        }
    } else {
        _callnewh(size);
        errno = ENOMEM;
        return NULL;
    }

    RTCCALLBACK(_RTC_Allocate_hook, (res, size, 0));
    if (res == NULL)
    {
        errno = ENOMEM;
    }
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\managedmain.cpp ===
/***
*ManagedMain.cpp - Initialization for Windows EXE using CRT DLL and managed entry point
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the startup routine for applications using the managed entry
*       point int __clrcall main(array<String^>^).
*       It calls the user's main routine after performing C Run-Time Library initialization.
*
*******************************************************************************/

#define _MANAGED_MAIN

#define WPRFLAG 1 /* Flag used by startup code to indicate wide strings */

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */


#include "mcrtexe.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbccpy.c ===
/***
*mbccpy.c - Copy one character  to another (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Copy one MBCS character to another (1 or 2 bytes)
*
*******************************************************************************/

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <memory.h>
#include <crtdefs.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbccpy - Copy one character to another (MBCS)
*
*Purpose:
*       Copies exactly one MBCS character from src to dst.  Copies _mbclen(src)
*       bytes from src to dst.
*
*Entry:
*       unsigned char *dst = destination for copy
*       unsigned char *src = source for copy
*
*Exit:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" void __cdecl _mbccpy_l(
        unsigned char *dst,
        const unsigned char *src,
        _locale_t plocinfo
        )
{
    /* _mbccpy_s_l sets errno */
    _mbccpy_s_l(dst, 2, NULL, src, plocinfo);
}

extern "C" void (__cdecl _mbccpy)(
        unsigned char *dst,
        const unsigned char *src
        )
{
    _mbccpy_s_l(dst, 2, NULL, src, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbccpy_s.c ===
/***
*mbccpy_s.c - Copy one character  to another (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Copy one MBCS character to another (1 or 2 bytes)
*
*******************************************************************************/

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbccpy_s
#define _DEST _Dst
#define _SRC _Src

#include <mbccpy_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbccpy_s, unsigned char *, size_t , int *, const unsigned char *)

#endif  /* _SYSCRT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbccpy_s_l.c ===
/***
*mbccpy_s_l.c - Copy one character  to another (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Copy one MBCS character to another (1 or 2 bytes)
*
*******************************************************************************/

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbccpy_s_l
#define _DEST _Dst
#define _SRC _Src

#include <mbccpy_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lseeki64.c ===
/***
*lseeki64.c - change file position
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _lseeki64() - move the file pointer
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <io.h>
#include <internal.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <stdio.h>

/*
 * Convenient union for accessing the upper and lower 32-bits of a 64-bit
 * integer.
 */
typedef union doubleint {
        __int64 bigint;
        struct {
            unsigned long lowerhalf;
            long upperhalf;
        } twoints;
} DINT;


/***
*__int64 _lseeki64( fh, pos, mthd ) - move the file pointer
*
*Purpose:
*       Moves the file pointer associated with fh to a new position. The new
*       position is pos bytes (pos may be negative) away from the origin
*       specified by mthd.
*
*       If mthd == SEEK_SET, the origin in the beginning of file
*       If mthd == SEEK_CUR, the origin is the current file pointer position
*       If mthd == SEEK_END, the origin is the end of the file
*
*       Multi-thread:
*       _lseeki64()    = locks/unlocks the file
*       _lseeki64_nolock() = does NOT lock/unlock the file (it is assumed that
*                        the caller has the aquired the file lock, if needed).
*
*Entry:
*       int     fh   - file handle to move file pointer on
*       __int64 pos  - position to move to, relative to origin
*       int     mthd - specifies the origin pos is relative to (see above)
*
*Exit:
*       returns the offset, in bytes, of the new position from the beginning
*       of the file.
*       returns -1i64 (and sets errno) if fails.
*       Note that seeking beyond the end of the file is not an error.
*       (although seeking before the beginning is.)
*
*Exceptions:
*
*******************************************************************************/


__int64 __cdecl _lseeki64 (
        int fh,
        __int64 pos,
        int mthd
        )
{
        __int64 r = -1i64;

        /* validate fh */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1i64 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1i64);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1i64);

        _lock_fh(fh);                   /* lock file handle */
        __try {
                /* make sure the file is open (after locking) */
                if ( _osfile(fh) & FOPEN )
                        r = _lseeki64_nolock( fh, pos, mthd );  /* seek */
                else {
                        errno = EBADF;
                        _doserrno = 0;  /* not OS error */
                        r =  -1i64;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(fh);         /* unlock file handle */
        }

        return( r );
}


/***
*__int64 _lseeki64_nolock( fh, pos, mthd ) - move the file pointer
*
*Purpose:
*       Non-locking version of _lseeki64 for internal use only.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

__int64 __cdecl _lseeki64_nolock (
        int fh,
        __int64 pos,
        int mthd
        )
{
        DINT newpos;                    /* new file position */
        unsigned long err;          /* error code from API call */
        HANDLE osHandle;        /* o.s. handle value */


        newpos.bigint = pos;

        /* tell OS to seek */

#if SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END
    #error Xenix and Win32 seek constants not compatible
#endif  /* SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END */

        if ((osHandle = (HANDLE)_get_osfhandle(fh)) == (HANDLE)-1)
        {
            errno = EBADF;
            _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
            return( -1i64 );
        }

        if ( ((newpos.twoints.lowerhalf =
               SetFilePointer( osHandle,
                               newpos.twoints.lowerhalf,
                               &(newpos.twoints.upperhalf),
                               mthd )) == -1L) &&
             ((err = GetLastError()) != NO_ERROR) )
        {
                _dosmaperr( err );
                return( -1i64 );
        }

        _osfile(fh) &= ~FEOFLAG;        /* clear the ctrl-z flag on the file */
        return( newpos.bigint );        /* return */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\lseek.c ===
/***
*lseek.c - change file position
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _lseek() - move the file pointer
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <io.h>
#include <internal.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <stdio.h>

/***
*long _lseek(fh,pos,mthd) - move the file pointer
*
*Purpose:
*       Moves the file pointer associated with fh to a new position.
*       The new position is pos bytes (pos may be negative) away
*       from the origin specified by mthd.
*
*       If mthd == SEEK_SET, the origin in the beginning of file
*       If mthd == SEEK_CUR, the origin is the current file pointer position
*       If mthd == SEEK_END, the origin is the end of the file
*
*       Multi-thread:
*       _lseek()    = locks/unlocks the file
*       _lseek_nolock() = does NOT lock/unlock the file (it is assumed that
*                     the caller has the aquired the file lock,if needed).
*
*Entry:
*       int fh - file handle to move file pointer on
*       long pos - position to move to, relative to origin
*       int mthd - specifies the origin pos is relative to (see above)
*
*Exit:
*       returns the offset, in bytes, of the new position from the beginning
*       of the file.
*       returns -1L (and sets errno) if fails.
*       Note that seeking beyond the end of the file is not an error.
*       (although seeking before the beginning is.)
*
*Exceptions:
*
*******************************************************************************/


/* define locking/validating lseek */
long __cdecl _lseek (
        int fh,
        long pos,
        int mthd
        )
{
        int r;

        /* validate fh */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        _lock_fh(fh);                   /* lock file handle */

        __try {
                if ( _osfile(fh) & FOPEN )
                        r = _lseek_nolock(fh, pos, mthd);   /* seek */
                else {
                        errno = EBADF;
                        _doserrno = 0;
                        r = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(fh);         /* unlock file handle */
        }

        return r;
}

/* define core _lseek -- doesn't lock or validate fh */
long __cdecl _lseek_nolock (
        int fh,
        long pos,
        int mthd
        )
{
        ULONG newpos;                   /* new file position */
        ULONG dosretval;                /* o.s. return value */
        HANDLE osHandle;        /* o.s. handle value */


        /* tell o.s. to seek */

#if SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END
    #error Xenix and Win32 seek constants not compatible
#endif  /* SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END */
        if ((osHandle = (HANDLE)_get_osfhandle(fh)) == (HANDLE)-1)
        {
            errno = EBADF;
            _ASSERTE(("Invalid file descriptor",0));
            return -1;
        }

        if ((newpos = SetFilePointer(osHandle, pos, NULL, mthd)) == -1)
                dosretval = GetLastError();
        else
                dosretval = 0;

        if (dosretval) {
                /* o.s. error */
                _dosmaperr(dosretval);
                return -1;
        }

        _osfile(fh) &= ~FEOFLAG;        /* clear the ctrl-z flag on the file */
        return newpos;                  /* return */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbclen.c ===
/***
*mbclen.c - Find length of MBCS character
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Find length of MBCS character
*
*******************************************************************************/

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>


/***
* _mbclen - Find length of MBCS character
*
*Purpose:
*       Find the length of the MBCS character (in bytes).
*
*Entry:
*       unsigned char *c = MBCS character
*
*Exit:
*       Returns the number of bytes in the MBCS character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _mbclen_l(
        const unsigned char *c,
        _locale_t plocinfo
        )

{
        /*  Don't return two if we have leadbyte, EOS.
            Don't assert here; too low level
        */
        return ((_ismbblead_l)(*c, plocinfo) && c[1]!='\0')  ? 2 : 1;
}

size_t (__cdecl _mbclen)(
        const unsigned char *c
        )

{
        /*  Don't return two if we have leadbyte, EOS.
            Don't assert here; too low level
        */
        return (_ismbblead(*c) && c[1]!='\0')  ? 2 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\makefile.inc ===
####
# makefile.inc - Included makefile for VCRT build process
#
#   Copyright (c) Microsoft Corporation. All rights reserved.
#
#
###############################################################################

PREOBJDIR = $(CPUDIR)\$(BLD_MODEL)_lib
PURE_PREOBJDIR = $(PREOBJDIR)\$(PURE_OBJ_DIR)
CLR_PREOBJDIR = $(PREOBJDIR)\$(CLR_OBJ_DIR)

# These are the prebuilt objects which are static link components in the
# MSVCRXX[D].DLL implib

DLL_STAT_PREBLD = \
!if "$(TARGET_CPU)"=="AMD64"
        $(OBJDIR)\gshandlereh.obj \
!elseif "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\gshandlereh.obj \
!elseif "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\ehprolg2.obj \
        $(OBJDIR)\ehprolg3.obj \
        $(OBJDIR)\ehprolg3a.obj \
        $(OBJDIR)\ehprolog.obj \
        $(OBJDIR)\cpu_disp.obj \
        $(OBJDIR)\ftol2.obj \
!endif
        $(OBJDIR)\ehvccctr.obj \
        $(OBJDIR)\ehvcccvb.obj \
        $(OBJDIR)\ehvecctr.obj \
        $(OBJDIR)\ehveccvb.obj \
!if "$(BLD_SYSCRT)" != "1"
        $(OBJDIR)\tncleanup.obj \
!endif
        $(OBJDIR)\ehvecdtr.obj

# !if "$(BLD_SYSCRT)" != "1"

DLL_STAT_PURE = \
        $(PURE_OBJDIR)\mehvccctr.obj \
        $(PURE_OBJDIR)\mehvcccvb.obj \
        $(PURE_OBJDIR)\mehvecctr.obj \
        $(PURE_OBJDIR)\mehveccvb.obj \
        $(PURE_OBJDIR)\mehvecdtr.obj \
        $(PURE_OBJDIR)\xtxtmode.obj \
        $(PURE_OBJDIR)\xthdloc.obj \
        $(PURE_OBJDIR)\xncommod.obj \
        $(PURE_OBJDIR)\_newmode.obj \
!if "$(TARGET_CPU)"=="AMD64"
        $(PURE_OBJDIR)\dllsupp.obj \
!elseif "$(TARGET_CPU)"=="IA64"
        $(PURE_OBJDIR)\dllsupp.obj \
        $(PURE_OBJDIR)\divhelp.obj \
!endif
        $(PURE_OBJDIR)\rtti.obj \


DLL_STAT_CLR = \
        $(CLR_OBJDIR)\mehvccctr.obj \
        $(CLR_OBJDIR)\mehvcccvb.obj \
        $(CLR_OBJDIR)\mehvecctr.obj \
        $(CLR_OBJDIR)\mehveccvb.obj \
        $(CLR_OBJDIR)\mehvecdtr.obj \
        $(CLR_OBJDIR)\xtxtmode.obj \
        $(CLR_OBJDIR)\xthdloc.obj \
        $(CLR_OBJDIR)\xncommod.obj \
        $(CLR_OBJDIR)\_newmode.obj \
        $(CLR_OBJDIR)\tlssup.obj \

PT_CLR_OBJECTS = \
        $(CLR_OBJDIR)\ptrust.obj

PT_PURE_OBJECTS = \
        $(PURE_OBJDIR)\ptrust.obj

CLR_SAFE_OBJECTS = \
        $(CLR_SAFE_OBJDIR)\generics.obj

# !endif

# Here is the target for building LIBC{,D} / LIBCMT{,D} / MSVCRT{,D}.LIB

all: \
        $(OBJDIR)\convert.lib  \
        $(OBJDIR)\direct.lib   \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\dllstuff.lib \
!endif
        $(OBJDIR)\dos.lib      \
        $(OBJDIR)\eh.lib       \
        $(OBJDIR)\exec.lib     \
        $(OBJDIR)\heap.lib     \
!if "$(TARGET_CPU)"!="AMD64"
        $(OBJDIR)\helper.lib   \
!endif
!if "$(BLD_DLL)"!="1"
        $(OBJDIR)\linkopts.lib \
        $(OBJDIR)\plinkopts.lib \
!endif
        $(OBJDIR)\lowio.lib    \
        $(OBJDIR)\mbstring.lib \
        $(OBJDIR)\misc.lib     \
!if "$(RTC)"=="YES"
        $(OBJDIR)\rtc.lib      \
!endif
        $(OBJDIR)\startup.lib  \
        $(OBJDIR)\stdio.lib    \
        $(OBJDIR)\string.lib   \
        $(OBJDIR)\time.lib     \
        $(OBJDIR)\conv.lib     \
        $(OBJDIR)\tran.lib     \
!if "$(BLD_BSKU)"=="1"
        $(OBJDIR)\bsku.obj     \
!endif
        $(OBJDIR)\matherr.obj  \
!if "$(BLD_DLL)"=="1"
        $(DLL_STAT_PREBLD)
!endif


# Here is the target for building LIBCP{,D} / LIBCPMT{,D} / MSVCPRT{,D}.LIB

MIXED_SRC=mix_

_mix_ : \
    $(OBJDIR)\$(MIXED_SRC).lib

_pure_ : \
    $(OBJDIR)\pure.lib \
    $(OBJDIR)\clr.lib \
    $(DLL_STAT_CLR) \
    $(DLL_STAT_PURE) \
    $(PT_CLR_OBJECTS) \
    $(PT_PURE_OBJECTS)
    

STDCPP_SRC = stdcpp

_stdcpp_ : \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\newaop_s.obj  \
!endif
!if "$(BLD_BSKU)"=="1"
        $(OBJDIR)\bsku.obj     \
!endif
        $(OBJDIR)\$(STDCPP_SRC).lib

CONVERT_OBJECTS = \
        $(OBJDIR)\_fptostr.obj 		\
        $(OBJDIR)\atox.obj     		\
        $(OBJDIR)\swab.obj     		\
        $(OBJDIR)\wchtodig.obj 		\
        $(OBJDIR)\wtox.obj     		\
        $(OBJDIR)\xtoa.obj     		\
        $(OBJDIR)\xtoas.obj    		\
        $(OBJDIR)\xtow.obj     		\
        $(OBJDIR)\xtows.obj    		\
        $(CPP_OBJDIR)\_ctype.obj	\
        $(CPP_OBJDIR)\_mbslen.obj	\
        $(CPP_OBJDIR)\_mbslen_s.obj \
        $(CPP_OBJDIR)\_wctype.obj  	\
        $(CPP_OBJDIR)\atodbl.obj   	\
        $(CPP_OBJDIR)\atof.obj     	\
        $(CPP_OBJDIR)\fcvt.obj     	\
        $(CPP_OBJDIR)\gcvt.obj     	\
        $(CPP_OBJDIR)\iswctype.obj 	\
        $(CPP_OBJDIR)\isctype.obj  	\
        $(CPP_OBJDIR)\mblen.obj    	\
        $(CPP_OBJDIR)\mbstowcs.obj 	\
        $(CPP_OBJDIR)\mbtowc.obj   	\
        $(CPP_OBJDIR)\mbrtowc.obj  	\
        $(CPP_OBJDIR)\strtod.obj   	\
        $(CPP_OBJDIR)\strtol.obj   	\
        $(CPP_OBJDIR)\strtoq.obj   	\
        $(CPP_OBJDIR)\tolower.obj  	\
        $(CPP_OBJDIR)\toupper.obj  	\
        $(CPP_OBJDIR)\towlower.obj 	\
        $(CPP_OBJDIR)\towupper.obj 	\
        $(CPP_OBJDIR)\wcrtomb.obj  	\
        $(CPP_OBJDIR)\wcstod.obj   	\
        $(CPP_OBJDIR)\wcstol.obj   	\
        $(CPP_OBJDIR)\wcstoq.obj   	\
        $(CPP_OBJDIR)\wcstombs.obj 	\
        $(CPP_OBJDIR)\wctomb.obj	\
        $(CPP_OBJDIR)\wtof.obj

DIRECT_OBJECTS = \
        $(OBJDIR)\drivemap.obj \
        $(OBJDIR)\drivfree.obj \
        $(OBJDIR)\findfile.obj \
        $(OBJDIR)\findf64.obj  \
        $(OBJDIR)\findfi32.obj \
        $(OBJDIR)\findfi64.obj \
        $(OBJDIR)\seterrm.obj  \
        $(OBJDIR)\slbeep.obj   \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\enable.obj   \
!endif
        $(OBJDIR)\wfindfil.obj \
        $(OBJDIR)\wfndf64.obj  \
        $(OBJDIR)\wfndfi32.obj \
        $(OBJDIR)\wfndfi64.obj

DLLSTUFF_OBJECTS = \
        $(OBJDIR)\atonexit.obj \
        $(OBJDIR)\crtlib.obj   \
        $(OBJDIR)\crtexe.obj   \
        $(OBJDIR)\crtexew.obj  \
        $(OBJDIR)\crtdll.obj   \
        $(OBJDIR)\cinitexe.obj \
        $(OBJDIR)\dllargv.obj  \
        $(OBJDIR)\dll_argv.obj \
        $(OBJDIR)\merr.obj     \
        $(OBJDIR)\natstart.obj \
        $(OBJDIR)\oldexcpt.obj \
        $(OBJDIR)\ti_inst.obj  \
        $(OBJDIR)\unhandld.obj \
        $(OBJDIR)\wcrtexe.obj  \
        $(OBJDIR)\wcrtexew.obj \
        $(OBJDIR)\wdllargv.obj \
        $(OBJDIR)\wdll_av.obj  \
        $(OBJDIR)\wildcard.obj \
        $(OBJDIR)\xtxtmode.obj \
        $(OBJDIR)\xthdloc.obj \
        $(OBJDIR)\xncommod.obj \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\dllsupp.obj  \
        $(OBJDIR)\adjustfd.obj \
!endif
!if "$(TARGET_CPU)"=="AMD64"
        $(OBJDIR)\dllsupp.obj  \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\dllsupp.obj  \
!endif

DLLSTUFF_OBJECTS_PURE = \
        $(OBJDIR)\pure_xtxtmode.obj \
        $(OBJDIR)\pure_xthdloc.obj \
        $(OBJDIR)\pure_xncommod.obj

DOS_OBJECTS = \
        $(OBJDIR)\access.obj   \
        $(OBJDIR)\chmod.obj    \
        $(OBJDIR)\chdir.obj    \
        $(OBJDIR)\dosmap.obj   \
        $(OBJDIR)\drive.obj    \
        $(OBJDIR)\fullpath.obj \
        $(OBJDIR)\getcwd.obj   \
        $(OBJDIR)\getpid.obj   \
        $(OBJDIR)\mkdir.obj    \
        $(OBJDIR)\mterrno.obj  \
        $(OBJDIR)\rename.obj   \
        $(OBJDIR)\rmdir.obj    \
        $(OBJDIR)\stat.obj     \
        $(OBJDIR)\stat64.obj   \
        $(OBJDIR)\stati32.obj  \
        $(OBJDIR)\stati64.obj  \
        $(OBJDIR)\unlink.obj   \
        $(OBJDIR)\waccess.obj  \
        $(OBJDIR)\wchdir.obj   \
        $(OBJDIR)\wchmod.obj   \
        $(OBJDIR)\wfullpat.obj \
        $(OBJDIR)\wgetcwd.obj  \
        $(OBJDIR)\wmkdir.obj   \
        $(OBJDIR)\wrename.obj  \
        $(OBJDIR)\wrmdir.obj   \
        $(OBJDIR)\wstat.obj    \
        $(OBJDIR)\wstat64.obj  \
        $(OBJDIR)\wstati32.obj \
        $(OBJDIR)\wstati64.obj \
        $(OBJDIR)\wunlink.obj

EXEC_OBJECTS = \
        $(OBJDIR)\cenvarg.obj  \
        $(OBJDIR)\dospawn.obj  \
        $(OBJDIR)\execl.obj    \
        $(OBJDIR)\execle.obj   \
        $(OBJDIR)\execlp.obj   \
        $(OBJDIR)\execlpe.obj  \
        $(OBJDIR)\execv.obj    \
        $(OBJDIR)\execve.obj   \
        $(OBJDIR)\execvp.obj   \
        $(OBJDIR)\execvpe.obj  \
        $(OBJDIR)\getproc.obj  \
        $(OBJDIR)\loaddll.obj  \
        $(OBJDIR)\spawnl.obj   \
        $(OBJDIR)\spawnle.obj  \
        $(OBJDIR)\spawnlp.obj  \
        $(OBJDIR)\spawnlpe.obj \
        $(OBJDIR)\spawnv.obj   \
        $(OBJDIR)\spawnve.obj  \
        $(OBJDIR)\spawnvp.obj  \
        $(OBJDIR)\spawnvpe.obj \
        $(OBJDIR)\system.obj   \
        $(OBJDIR)\wait.obj     \
        $(OBJDIR)\wcenvarg.obj \
        $(OBJDIR)\wdospawn.obj \
        $(OBJDIR)\wexecl.obj   \
        $(OBJDIR)\wexecle.obj  \
        $(OBJDIR)\wexeclp.obj  \
        $(OBJDIR)\wexeclpe.obj \
        $(OBJDIR)\wexecv.obj   \
        $(OBJDIR)\wexecve.obj  \
        $(OBJDIR)\wexecvp.obj  \
        $(OBJDIR)\wexecvpe.obj \
        $(OBJDIR)\wspawnl.obj  \
        $(OBJDIR)\wspawnle.obj \
        $(OBJDIR)\wspawnlp.obj \
        $(OBJDIR)\wspwnlpe.obj \
        $(OBJDIR)\wspawnv.obj  \
        $(OBJDIR)\wspawnve.obj \
        $(OBJDIR)\wspawnvp.obj \
        $(OBJDIR)\wspwnvpe.obj \
        $(OBJDIR)\wsystem.obj

HEAP_OBJECTS = \
        $(OBJDIR)\align.obj    \
        $(OBJDIR)\resetstk.obj  \
        $(OBJDIR)\calloc.obj   \
        $(OBJDIR)\calloc_impl.obj   \
        $(OBJDIR)\crtheap.obj   \
!IF "$(WINHEAP)" == "YES"
        $(OBJDIR)\expand.obj   \
!ELSE
        $(OBJDIR)\findaddr.obj \
!ENDIF
        $(OBJDIR)\free.obj     \
        $(OBJDIR)\freea.obj    \
        $(OBJDIR)\heapadd.obj  \
        $(OBJDIR)\heapchk.obj  \
!IF "$(WINHEAP)" == "NO"
        $(OBJDIR)\heapgrow.obj \
!ENDIF
        $(OBJDIR)\heapinit.obj \
        $(OBJDIR)\heapmin.obj  \
!IF "$(WINHEAP)" == "NO"
        $(OBJDIR)\heapprm.obj  \
!ENDIF
!IF "$(WINHEAP)" == "NO"
        $(OBJDIR)\heapsrch.obj \
!ENDIF
        $(OBJDIR)\hpabort.obj  \
        $(OBJDIR)\heapused.obj \
        $(OBJDIR)\heapwalk.obj \
        $(OBJDIR)\malloc.obj   \
        $(OBJDIR)\msize.obj    \
        $(OBJDIR)\realloc.obj  \
        $(OBJDIR)\recalloc.obj  \
!IF "$(WINHEAP)" == "YES"
        $(OBJDIR)\sbheap.obj   \
!ENDIF
        $(OBJDIR)\handler.obj  \
        $(OBJDIR)\setnewh.obj  \
        $(OBJDIR)\new_mode.obj \
        $(OBJDIR)\nothrow0.obj \
        $(OBJDIR)\delete.obj   \
        $(OBJDIR)\delete2.obj  \
        $(OBJDIR)\_newmode.obj \
        $(OBJDIR)\new.obj      \
!if "$(BLD_SYSCRT)" != "1"
        $(OBJDIR)\nomemoryh.obj \
!endif
        $(OBJDIR)\new2.obj     \
        $(OBJDIR)\delaopnt.obj \
        $(OBJDIR)\delopnt.obj  \
        $(OBJDIR)\newaopnt.obj \
        $(OBJDIR)\newopnt.obj

HELPER_OBJECTS = \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\lldiv.obj    \
        $(OBJDIR)\lldvrm.obj   \
        $(OBJDIR)\llmul.obj    \
        $(OBJDIR)\llrem.obj    \
        $(OBJDIR)\llshl.obj    \
        $(OBJDIR)\llshr.obj    \
        $(OBJDIR)\ulldiv.obj   \
        $(OBJDIR)\ulldvrm.obj  \
        $(OBJDIR)\ullrem.obj   \
        $(OBJDIR)\ullshr.obj   \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\divhelp.obj
!endif

LINKOPTS_OBJECTS = \
        $(OBJDIR)\binmode.obj  \
        $(OBJDIR)\commode.obj  \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\fp10.obj     \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\fp10.obj     \
!endif
        $(OBJDIR)\invalidcontinue.obj \
        $(OBJDIR)\loosefpmath.obj \
        $(OBJDIR)\newmode.obj  \
        $(OBJDIR)\noarg.obj    \
        $(OBJDIR)\nochkclr.obj \
        $(OBJDIR)\noenv.obj    \
        $(OBJDIR)\nothrownew.obj \
        $(OBJDIR)\setargv.obj  \
        $(OBJDIR)\smalheap.obj \
        $(OBJDIR)\threadlocale.obj \
        $(OBJDIR)\thrownew.obj \
        $(OBJDIR)\wsetargv.obj \

PLINKOPTS_OBJECTS = \
        $(PURE_OBJDIR)\pbinmode.obj  \
        $(PURE_OBJDIR)\pcommode.obj  \
        $(PURE_OBJDIR)\pinvalidcontinue.obj \
        $(PURE_OBJDIR)\pnewmode.obj  \
        $(PURE_OBJDIR)\pnoarg.obj    \
        $(PURE_OBJDIR)\pnoenv.obj    \
        $(PURE_OBJDIR)\pnothrownew.obj \
        $(PURE_OBJDIR)\psetargv.obj  \
        $(PURE_OBJDIR)\pthreadlocale.obj \
        $(PURE_OBJDIR)\pwsetargv.obj

LOWIO_OBJECTS = \
        $(OBJDIR)\chsize.obj   \
        $(OBJDIR)\close.obj    \
        $(OBJDIR)\commit.obj   \
        $(OBJDIR)\creat.obj    \
        $(OBJDIR)\dup.obj      \
        $(OBJDIR)\dup2.obj     \
        $(OBJDIR)\eof.obj      \
        $(OBJDIR)\flength.obj  \
        $(OBJDIR)\fleni64.obj  \
        $(OBJDIR)\fstat.obj    \
        $(OBJDIR)\fstat64.obj  \
        $(OBJDIR)\fstati32.obj \
        $(OBJDIR)\fstati64.obj \
        $(OBJDIR)\initcon.obj  \
        $(OBJDIR)\ioinit.obj   \
        $(OBJDIR)\isatty.obj   \
        $(OBJDIR)\locking.obj  \
        $(OBJDIR)\lseek.obj    \
        $(OBJDIR)\lseeki64.obj \
        $(OBJDIR)\mktemp.obj   \
        $(OBJDIR)\open.obj     \
        $(OBJDIR)\openo.obj    \
        $(OBJDIR)\osfinfo.obj  \
        $(OBJDIR)\pipe.obj     \
        $(OBJDIR)\read.obj     \
        $(OBJDIR)\setmode.obj  \
        $(OBJDIR)\tell.obj     \
        $(OBJDIR)\telli64.obj  \
        $(OBJDIR)\txtmode.obj  \
        $(OBJDIR)\write.obj    \
        $(OBJDIR)\cgets.obj    \
        $(OBJDIR)\cgetws.obj   \
        $(OBJDIR)\cputs.obj    \
        $(OBJDIR)\getch.obj    \
        $(OBJDIR)\getwch.obj   \
        $(OBJDIR)\putch.obj    \
        $(OBJDIR)\putwch.obj   \
        $(OBJDIR)\wcreat.obj   \
        $(OBJDIR)\wmktemp.obj  \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\inp.obj      \
        $(OBJDIR)\outp.obj     \
!endif
        $(OBJDIR)\wopen.obj

MBSTRING_OBJECTS = \
        $(OBJDIR)\mbclen.obj   \
        $(OBJDIR)\mbsinc.obj   \
        $(OBJDIR)\mbsninc.obj  \
        $(OBJDIR)\mbtohira.obj \
        $(OBJDIR)\mbtokata.obj \
        $(CPP_OBJDIR)\ismbalnm.obj \
        $(CPP_OBJDIR)\ismbalph.obj \
        $(CPP_OBJDIR)\ismbbyte.obj \
        $(CPP_OBJDIR)\ismbdgt.obj  \
        $(CPP_OBJDIR)\ismbgrph.obj \
        $(CPP_OBJDIR)\ismbknj.obj  \
        $(CPP_OBJDIR)\ismblgl.obj  \
        $(CPP_OBJDIR)\ismblwr.obj  \
        $(CPP_OBJDIR)\ismbprn.obj  \
        $(CPP_OBJDIR)\ismbpunc.obj \
        $(CPP_OBJDIR)\ismbsle.obj  \
        $(CPP_OBJDIR)\ismbspc.obj  \
        $(CPP_OBJDIR)\ismbstr.obj  \
        $(CPP_OBJDIR)\ismbupr.obj  \
        $(CPP_OBJDIR)\mbbtype.obj  \
        $(CPP_OBJDIR)\mbccpy.obj   \
        $(CPP_OBJDIR)\mbccpy_s.obj \
        $(CPP_OBJDIR)\mbccpy_s_l.obj \
        $(CPP_OBJDIR)\mbscat_s_l.obj \
        $(CPP_OBJDIR)\mbscpy_s_l.obj \
        $(CPP_OBJDIR)\mbsnbcat_s_l.obj \
        $(CPP_OBJDIR)\mbsnbcpy_s_l.obj \
        $(CPP_OBJDIR)\mbsnbset_s_l.obj \
        $(CPP_OBJDIR)\mbsncat_s_l.obj \
        $(CPP_OBJDIR)\mbsncpy_s_l.obj \
        $(CPP_OBJDIR)\mbsnset_s_l.obj \
        $(CPP_OBJDIR)\mbsset_s_l.obj \
        $(CPP_OBJDIR)\mbclevel.obj \
        $(CPP_OBJDIR)\mbctype.obj  \
        $(CPP_OBJDIR)\mbsbtype.obj \
        $(CPP_OBJDIR)\mbscat_s.obj \
        $(CPP_OBJDIR)\mbschr.obj   \
        $(CPP_OBJDIR)\mbscmp.obj   \
        $(CPP_OBJDIR)\mbscpy_s.obj \
        $(CPP_OBJDIR)\mbscoll.obj  \
        $(CPP_OBJDIR)\mbscspn.obj  \
        $(CPP_OBJDIR)\mbsdec.obj   \
        $(CPP_OBJDIR)\mbsicmp.obj  \
        $(CPP_OBJDIR)\mbsicoll.obj \
        $(CPP_OBJDIR)\mbslen.obj   \
        $(CPP_OBJDIR)\mbslen_s.obj \
        $(CPP_OBJDIR)\mbslwr.obj   \
        $(CPP_OBJDIR)\mbsnbcat.obj \
        $(CPP_OBJDIR)\mbsnbcat_s.obj \
        $(CPP_OBJDIR)\mbsnbcmp.obj \
        $(CPP_OBJDIR)\mbsnbcnt.obj \
        $(CPP_OBJDIR)\mbsnbcol.obj \
        $(CPP_OBJDIR)\mbsnbcpy.obj \
        $(CPP_OBJDIR)\mbsnbcpy_s.obj \
        $(CPP_OBJDIR)\mbsnbicm.obj \
        $(CPP_OBJDIR)\mbsnbico.obj \
        $(CPP_OBJDIR)\mbsnbset.obj \
        $(CPP_OBJDIR)\mbsnbset_s.obj \
        $(CPP_OBJDIR)\mbsncat.obj  \
        $(CPP_OBJDIR)\mbsncat_s.obj  \
        $(CPP_OBJDIR)\mbsnccnt.obj \
        $(CPP_OBJDIR)\mbsncmp.obj  \
        $(CPP_OBJDIR)\mbsncoll.obj \
        $(CPP_OBJDIR)\mbsncpy.obj  \
        $(CPP_OBJDIR)\mbsncpy_s.obj \
        $(CPP_OBJDIR)\mbsnextc.obj \
        $(CPP_OBJDIR)\mbsnicmp.obj \
        $(CPP_OBJDIR)\mbsnicol.obj \
        $(CPP_OBJDIR)\mbsnset.obj  \
        $(CPP_OBJDIR)\mbsnset_s.obj  \
        $(CPP_OBJDIR)\mbspbrk.obj  \
        $(CPP_OBJDIR)\mbsrchr.obj  \
        $(CPP_OBJDIR)\mbsrev.obj   \
        $(CPP_OBJDIR)\mbsset.obj   \
        $(CPP_OBJDIR)\mbsset_s.obj \
        $(CPP_OBJDIR)\mbsspn.obj   \
        $(CPP_OBJDIR)\mbsspnp.obj  \
        $(CPP_OBJDIR)\mbsstr.obj   \
        $(CPP_OBJDIR)\mbstok.obj   \
        $(CPP_OBJDIR)\mbstok_s.obj \
        $(CPP_OBJDIR)\mbsupr.obj   \
        $(CPP_OBJDIR)\mbtolwr.obj  \
        $(CPP_OBJDIR)\mbtoupr.obj  \
        $(CPP_OBJDIR)\tojisjms.obj \
        $(CPP_OBJDIR)\tombbmbc.obj

MISC_OBJECTS = \
!if "$(TARGET_CPU)"=="i386"
        $(OBJDIR)\chandler4.obj\
        $(OBJDIR)\chandler4gs.obj\
        $(OBJDIR)\chkesp.obj   \
        $(OBJDIR)\eh3valid.obj \
        $(OBJDIR)\exsup.obj    \
        $(OBJDIR)\exsup2.obj   \
        $(OBJDIR)\exsup3.obj   \
        $(OBJDIR)\exsup4.obj   \
        $(OBJDIR)\loadcfg.obj  \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\secchk.obj   \
        $(OBJDIR)\sehprolg.obj \
        $(OBJDIR)\sehprolg4.obj\
        $(OBJDIR)\sehprolg4gs.obj\
        $(OBJDIR)\sehsupp.obj  \
        $(OBJDIR)\calldtor.obj \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmp3.obj  \
        $(OBJDIR)\setjmpex.obj \
!endif
!if "$(TARGET_CPU)"=="AMD64"
        $(OBJDIR)\amdsecgs.obj \
        $(OBJDIR)\chandler.obj \
        $(OBJDIR)\gshandler.obj \
        $(OBJDIR)\gshandlerseh.obj \
        $(OBJDIR)\jmpuwind.obj \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\rtcmd.obj    \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmpex.obj \
!endif
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\chandler.obj \
        $(OBJDIR)\cinitone.obj \
        $(OBJDIR)\gshandler.obj \
        $(OBJDIR)\gshandlerseh.obj \
        $(OBJDIR)\jmpuwind.obj \
        $(OBJDIR)\longjmp.obj  \
        $(OBJDIR)\miscs.obj    \
        $(OBJDIR)\rtcmd.obj    \
        $(OBJDIR)\secchk.obj   \
        $(OBJDIR)\setjmp.obj   \
        $(OBJDIR)\setjmpex.obj \
!endif
        $(CPP_OBJDIR)\a_cmp.obj    \
        $(OBJDIR)\a_env.obj    \
        $(CPP_OBJDIR)\a_loc.obj    \
        $(CPP_OBJDIR)\a_map.obj    \
        $(CPP_OBJDIR)\a_str.obj    \
        $(OBJDIR)\abort.obj    \
        $(OBJDIR)\abs.obj      \
        $(OBJDIR)\assert.obj   \
        $(OBJDIR)\aw_com.obj   \
        $(OBJDIR)\bsearch.obj  \
        $(OBJDIR)\bsearch_s.obj \
        $(OBJDIR)\bswap.obj    \
        $(OBJDIR)\charmax.obj  \
!if "$(BLD_DLL)"!="1"
        $(OBJDIR)\cmiscdat.obj \
!endif
        $(OBJDIR)\crtmbox.obj  \
        $(OBJDIR)\crtmboxw.obj \
        $(OBJDIR)\ctype.obj    \
        $(OBJDIR)\div.obj      \
        $(CPP_OBJDIR)\dbgcalloc.obj \
        $(CPP_OBJDIR)\dbgfree.obj \
        $(CPP_OBJDIR)\dbgheap.obj \
        $(CPP_OBJDIR)\dbgmalloc.obj \
        $(CPP_OBJDIR)\dbgrealloc.obj \
        $(OBJDIR)\dbghook.obj  \
        $(OBJDIR)\dbgdel.obj   \
        $(OBJDIR)\dbgnew.obj   \
        $(OBJDIR)\dbgrpt.obj   \
        $(OBJDIR)\dbgrptt.obj  \
        $(CPP_OBJDIR)\dbgrptw.obj  \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\dbgsec.obj  \
!endif
        $(OBJDIR)\errmode.obj  \
        $(OBJDIR)\getenv.obj   \
        $(OBJDIR)\getpath.obj  \
        $(OBJDIR)\getqloc.obj  \
        $(OBJDIR)\glstatus.obj \
        $(OBJDIR)\gs_cookie.obj \
        $(OBJDIR)\gs_report.obj \
        $(OBJDIR)\gs_support.obj \
        $(OBJDIR)\initcoll.obj \
        $(OBJDIR)\initcrit.obj \
        $(OBJDIR)\initctyp.obj \
        $(OBJDIR)\inithelp.obj \
        $(OBJDIR)\initmon.obj  \
        $(OBJDIR)\initnum.obj  \
        $(OBJDIR)\inittime.obj \
        $(CPP_OBJDIR)\invarg.obj   \
        $(OBJDIR)\labs.obj     \
        $(OBJDIR)\lcnvinit.obj \
        $(OBJDIR)\lconv.obj    \
        $(OBJDIR)\ldiv.obj     \
        $(OBJDIR)\lfind.obj    \
        $(OBJDIR)\lfind_s.obj  \
        $(OBJDIR)\lsearch.obj  \
        $(OBJDIR)\lsearch_s.obj \
        $(OBJDIR)\makepath.obj \
        $(OBJDIR)\makepath_s.obj \
        $(OBJDIR)\mbtowenv.obj \
        $(OBJDIR)\onexit.obj   \
        $(OBJDIR)\nlsdata1.obj \
        $(OBJDIR)\nlsdata2.obj \
        $(OBJDIR)\nlsdata3.obj \
        $(OBJDIR)\perror.obj   \
        $(OBJDIR)\pesect.obj   \
        $(OBJDIR)\purevirt.obj \
        $(OBJDIR)\putenv.obj   \
        $(OBJDIR)\qsort.obj    \
        $(OBJDIR)\qsort_s.obj  \
        $(OBJDIR)\rand.obj     \
        $(OBJDIR)\rand_s.obj   \
        $(OBJDIR)\rotl.obj     \
        $(OBJDIR)\rotr.obj     \
        $(OBJDIR)\searchen.obj \
        $(OBJDIR)\setenv.obj   \
        $(OBJDIR)\setlocal.obj \
        $(OBJDIR)\splitpat.obj \
        $(OBJDIR)\splitpath_s.obj \
        $(OBJDIR)\_strerr.obj  \
        $(OBJDIR)\strerror.obj \
        $(OBJDIR)\syserr.obj   \
        $(OBJDIR)\convrtcp.obj \
        $(OBJDIR)\umask.obj    \
        $(CPP_OBJDIR)\w_cmp.obj    \
        $(OBJDIR)\w_env.obj    \
        $(CPP_OBJDIR)\w_loc.obj    \
        $(CPP_OBJDIR)\w_map.obj    \
        $(CPP_OBJDIR)\w_str.obj    \
        $(OBJDIR)\wassert.obj  \
        $(OBJDIR)\wcserror.obj \
        $(OBJDIR)\_wcserr.obj  \
        $(OBJDIR)\winsig.obj   \
        $(OBJDIR)\winxfltr.obj \
        $(OBJDIR)\wgetenv.obj  \
        $(OBJDIR)\wgetpath.obj \
        $(OBJDIR)\wmakepat.obj \
        $(OBJDIR)\wmakepath_s.obj \
        $(OBJDIR)\wperror.obj  \
        $(OBJDIR)\wputenv.obj  \
        $(OBJDIR)\wsearche.obj \
        $(OBJDIR)\wsetenv.obj  \
        $(OBJDIR)\wsetloca.obj \
        $(OBJDIR)\wsplitpa.obj \
        $(OBJDIR)\wsplitpath_s.obj \
        $(OBJDIR)\wrt2err.obj  \
        $(OBJDIR)\wtombenv.obj

STARTUP_OBJECTS = \
        $(OBJDIR)\_setargv.obj \
        $(OBJDIR)\_wstargv.obj \
        $(OBJDIR)\chkstk.obj   \
!if "$(TARGET_CPU)" == "i386"
        $(OBJDIR)\alloca16.obj  \
!endif
!if "$(TARGET_CPU)" == "AMD64"
        $(OBJDIR)\chkstk2.obj  \
!endif
        $(OBJDIR)\crt0.obj     \
        $(OBJDIR)\crt0dat.obj  \
        $(OBJDIR)\crt0fp.obj   \
        $(OBJDIR)\crt0init.obj \
        $(OBJDIR)\crt0msg.obj  \
        $(OBJDIR)\dllcrt0.obj  \
        $(OBJDIR)\dllmain.obj  \
        $(OBJDIR)\mlock.obj    \
        $(OBJDIR)\stdargv.obj  \
        $(OBJDIR)\stdenvp.obj  \
        $(OBJDIR)\thread.obj   \
        $(OBJDIR)\threadex.obj \
        $(OBJDIR)\tidtable.obj \
        $(OBJDIR)\tlsdtor.obj  \
        $(OBJDIR)\tlsdyn.obj   \
        $(OBJDIR)\tlssup.obj   \
        $(OBJDIR)\wcrt0.obj    \
        $(OBJDIR)\wild.obj     \
        $(OBJDIR)\wincmdln.obj \
        $(OBJDIR)\wincrt0.obj  \
        $(OBJDIR)\wstdargv.obj \
        $(OBJDIR)\wstdenvp.obj \
        $(OBJDIR)\wwncmdln.obj \
        $(OBJDIR)\wwild.obj    \
        $(OBJDIR)\wwincrt0.obj \
!if "$(TARGET_CPU)" == "i386"
        $(OBJDIR)\atlssup.obj  \
        $(OBJDIR)\fp8.obj      \
!endif
!if "$(TARGET_CPU)" == "IA64"
        $(OBJDIR)\fp8.obj      \
!endif


MIXED_OBJECTS = \
        $(OBJDIR)\exedefad.obj      \
        $(CLR_OBJDIR)\mmatherr.obj  \
!if "$(BLD_DBG)"=="1"
        $(CLR_OBJDIR)\mdbghook.obj  \
        $(CLR_OBJDIR)\mdbgheap.obj  \
!endif
        $(CLR_OBJDIR)\mhandler.obj  \
!if "$(TARGET_CPU)"=="IA64"
        $(OBJDIR)\memcpy.obj \
        $(OBJDIR)\memcpy_s.obj \
        $(OBJDIR)\memmove.obj \
        $(OBJDIR)\memmove_s.obj \
        $(OBJDIR)\memset.obj \
!endif
        $(CLR_OBJDIR)\muser.obj  \
        $(CLR_OBJDIR)\mfpieeeflt.obj  \
        $(CLR_OBJDIR)\mstdexpt.obj \
        $(CLR_OBJDIR)\mstartup.obj \
        $(CLR_OBJDIR)\thread.obj \
        $(CLR_OBJDIR)\threadex.obj \
#	STDCPP objects for support of STL and SCP in /clr:pure
        $(CLR_OBJDIR)\iomanip.obj \
        $(CLR_OBJDIR)\ios.obj \
        $(CLR_OBJDIR)\iostream.obj \
        $(CLR_OBJDIR)\wiostrea.obj \
        $(CLR_OBJDIR)\iosptrs.obj \
        $(CLR_OBJDIR)\ushiostr.obj \
        $(CLR_OBJDIR)\cerr.obj \
        $(CLR_OBJDIR)\cin.obj \
        $(CLR_OBJDIR)\clog.obj \
        $(CLR_OBJDIR)\cout.obj \
        $(CLR_OBJDIR)\ushcerr.obj \
        $(CLR_OBJDIR)\ushcin.obj \
        $(CLR_OBJDIR)\ushclog.obj \
        $(CLR_OBJDIR)\ushcout.obj \
        $(CLR_OBJDIR)\wcerr.obj \
        $(CLR_OBJDIR)\wcin.obj \
        $(CLR_OBJDIR)\wclog.obj \
        $(CLR_OBJDIR)\wcout.obj \
        $(CLR_OBJDIR)\locale.obj \
        $(CLR_OBJDIR)\locale0.obj \
        $(CLR_OBJDIR)\wlocale.obj \
        $(CLR_OBJDIR)\xdateord.obj \
        $(CLR_OBJDIR)\xgetwctype.obj \
        $(CLR_OBJDIR)\xmbtowc.obj \
        $(CLR_OBJDIR)\xtowlower.obj \
        $(CLR_OBJDIR)\xtowupper.obj \
        $(CLR_OBJDIR)\xstrcoll.obj \
        $(CLR_OBJDIR)\xstrxfrm.obj \
        $(CLR_OBJDIR)\xwcscoll.obj \
        $(CLR_OBJDIR)\xwcsxfrm.obj \
        $(CLR_OBJDIR)\xwctomb.obj \
        $(CLR_OBJDIR)\xmutex.obj \
        $(CLR_OBJDIR)\xlock.obj \
        $(CLR_OBJDIR)\xmtx.obj \
        $(CLR_OBJDIR)\xcosh.obj \
        $(CLR_OBJDIR)\xdnorm.obj \
        $(CLR_OBJDIR)\xdscale.obj \
        $(CLR_OBJDIR)\xdtest.obj \
        $(CLR_OBJDIR)\xexp.obj \
        $(CLR_OBJDIR)\xsinh.obj \
        $(CLR_OBJDIR)\xpoly.obj \
        $(CLR_OBJDIR)\xvalues.obj \
        $(CLR_OBJDIR)\xfcosh.obj \
        $(CLR_OBJDIR)\xfdnorm.obj \
        $(CLR_OBJDIR)\xfdscale.obj \
        $(CLR_OBJDIR)\xfdtest.obj \
        $(CLR_OBJDIR)\xfexp.obj \
        $(CLR_OBJDIR)\xfsinh.obj \
        $(CLR_OBJDIR)\xfvalues.obj \
        $(CLR_OBJDIR)\xlcosh.obj \
        $(CLR_OBJDIR)\xldscale.obj \
        $(CLR_OBJDIR)\xldtest.obj \
        $(CLR_OBJDIR)\xlexp.obj \
        $(CLR_OBJDIR)\xlsinh.obj \
        $(CLR_OBJDIR)\xlpoly.obj \
        $(CLR_OBJDIR)\xlvalues.obj \
        $(CLR_OBJDIR)\xferaise.obj \
        $(CLR_OBJDIR)\fiopen.obj \
        $(CLR_OBJDIR)\string.obj \
!if "$(BLD_DBG)"=="1"
        $(CLR_OBJDIR)\xdebug.obj \
!endif
        $(CLR_OBJDIR)\stdthrow.obj \
        $(CLR_OBJDIR)\nomemory.obj \
        $(CLR_OBJDIR)\uncaught.obj \
        $(CLR_OBJDIR)\_tolower.obj \
        $(CLR_OBJDIR)\_toupper.obj \
        $(CLR_OBJDIR)\wctrans.obj \
        $(CLR_OBJDIR)\wctype.obj \
        $(CLR_OBJDIR)\xlocale.obj  \
        $(CLR_OBJDIR)\xstod.obj \
        $(CLR_OBJDIR)\xstof.obj \
        $(CLR_OBJDIR)\xstol.obj \
        $(CLR_OBJDIR)\xstoll.obj \
        $(CLR_OBJDIR)\xstold.obj \
        $(CLR_OBJDIR)\xstoul.obj \
        $(CLR_OBJDIR)\xstoull.obj

STDCPP_OBJECTS = \
        $(OBJDIR)\cerr.obj      \
        $(OBJDIR)\cin.obj       \
        $(OBJDIR)\clog.obj      \
        $(OBJDIR)\cout.obj      \
        $(OBJDIR)\fiopen.obj    \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\instances.obj \
!endif
        $(OBJDIR)\iomanip.obj   \
        $(OBJDIR)\ios.obj       \
        $(OBJDIR)\iosptrs.obj   \
        $(OBJDIR)\iostream.obj  \
        $(OBJDIR)\locale.obj    \
        $(OBJDIR)\locale0.obj   \
        $(OBJDIR)\newaop.obj    \
        $(OBJDIR)\nomemory.obj  \
        $(OBJDIR)\nothrow.obj   \
        $(OBJDIR)\raisehan.obj  \
        $(OBJDIR)\stdhndlr.obj  \
        $(OBJDIR)\stdthrow.obj  \
        $(OBJDIR)\string.obj    \
!if "$(BLD_DLL)"=="1"
        $(OBJDIR)\strstrea.obj  \
!endif
        $(OBJDIR)\ushcerr.obj   \
        $(OBJDIR)\ushcout.obj   \
        $(OBJDIR)\ushcin.obj    \
        $(OBJDIR)\ushclog.obj   \
        $(OBJDIR)\ushiostr.obj  \
        $(OBJDIR)\uncaught.obj  \
        $(OBJDIR)\wcerr.obj     \
        $(OBJDIR)\wcin.obj      \
        $(OBJDIR)\wclog.obj     \
        $(OBJDIR)\wcout.obj     \
        $(OBJDIR)\wctrans.obj   \
        $(OBJDIR)\wctype.obj    \
        $(OBJDIR)\wiostrea.obj  \
        $(OBJDIR)\wlocale.obj   \
        $(OBJDIR)\xcosh.obj     \
        $(OBJDIR)\xdateord.obj  \
        $(OBJDIR)\xdebug.obj    \
        $(OBJDIR)\xdnorm.obj    \
        $(OBJDIR)\xdscale.obj   \
        $(OBJDIR)\xdtest.obj    \
        $(OBJDIR)\xexp.obj      \
        $(OBJDIR)\xfcosh.obj    \
        $(OBJDIR)\xfdnorm.obj   \
        $(OBJDIR)\xfdscale.obj  \
        $(OBJDIR)\xfdtest.obj   \
        $(OBJDIR)\xferaise.obj  \
        $(OBJDIR)\xfexp.obj     \
        $(OBJDIR)\xfsinh.obj    \
        $(OBJDIR)\xfvalues.obj  \
        $(OBJDIR)\xgetwctype.obj\
        $(OBJDIR)\xlcosh.obj    \
        $(OBJDIR)\xldnorm.obj   \
        $(OBJDIR)\xldscale.obj  \
        $(OBJDIR)\xldtest.obj   \
        $(OBJDIR)\xlexp.obj     \
        $(OBJDIR)\xlocale.obj   \
        $(OBJDIR)\xlock.obj     \
        $(OBJDIR)\xlpoly.obj    \
        $(OBJDIR)\xlsinh.obj    \
        $(OBJDIR)\xlvalues.obj  \
        $(OBJDIR)\xmbtowc.obj   \
        $(OBJDIR)\xmtx.obj      \
        $(OBJDIR)\xmutex.obj    \
        $(OBJDIR)\xpoly.obj     \
        $(OBJDIR)\xsinh.obj     \
        $(OBJDIR)\xstod.obj     \
        $(OBJDIR)\xstof.obj     \
        $(OBJDIR)\xstol.obj     \
        $(OBJDIR)\xstold.obj    \
        $(OBJDIR)\xstoll.obj    \
        $(OBJDIR)\xstoul.obj    \
        $(OBJDIR)\xstoull.obj   \
        $(OBJDIR)\xstrcoll.obj  \
        $(OBJDIR)\xstrxfrm.obj  \
        $(OBJDIR)\xtowlower.obj \
        $(OBJDIR)\xtowupper.obj \
        $(OBJDIR)\xvalues.obj   \
        $(OBJDIR)\xwcscoll.obj  \
        $(OBJDIR)\xwcsxfrm.obj  \
        $(OBJDIR)\xwctomb.obj   \
        $(OBJDIR)\_tolower.obj  \
        $(OBJDIR)\_toupper.obj


STDIO_OBJECTS = \
        $(OBJDIR)\feoferr.obj  \
        $(OBJDIR)\fgetc.obj    \
        $(OBJDIR)\fgetchar.obj \
        $(OBJDIR)\fgets.obj    \
        $(OBJDIR)\fgetwc.obj   \
        $(OBJDIR)\fgetws.obj   \
        $(OBJDIR)\fgetwchr.obj \
        $(OBJDIR)\fileno.obj   \
        $(OBJDIR)\fputc.obj    \
        $(OBJDIR)\fputs.obj    \
        $(OBJDIR)\fputchar.obj \
        $(OBJDIR)\fputwc.obj   \
        $(OBJDIR)\fputws.obj   \
        $(OBJDIR)\fputwchr.obj \
        $(OBJDIR)\_filbuf.obj  \
        $(OBJDIR)\_filwbuf.obj \
        $(OBJDIR)\_file.obj    \
        $(OBJDIR)\_flsbuf.obj  \
        $(OBJDIR)\_flswbuf.obj \
        $(OBJDIR)\_freebuf.obj \
        $(OBJDIR)\_getbuf.obj  \
        $(OBJDIR)\_open.obj    \
        $(OBJDIR)\_sftbuf.obj  \
        $(OBJDIR)\clearerr.obj \
        $(OBJDIR)\closeall.obj \
        $(OBJDIR)\fclose.obj   \
        $(OBJDIR)\fdopen.obj   \
        $(OBJDIR)\fflush.obj   \
        $(OBJDIR)\fgetpos.obj  \
        $(OBJDIR)\fopen.obj    \
        $(OBJDIR)\fprintf.obj  \
        $(OBJDIR)\fread.obj    \
        $(OBJDIR)\freopen.obj  \
        $(OBJDIR)\fscanf.obj   \
        $(OBJDIR)\fseek.obj    \
        $(OBJDIR)\fseeki64.obj \
        $(OBJDIR)\fsetpos.obj  \
        $(OBJDIR)\ftell.obj    \
        $(OBJDIR)\ftelli64.obj \
        $(OBJDIR)\fwprintf.obj \
        $(OBJDIR)\fwrite.obj   \
        $(OBJDIR)\fwscanf.obj  \
        $(OBJDIR)\gets.obj     \
        $(OBJDIR)\getw.obj     \
        $(OBJDIR)\getws.obj    \
        $(OBJDIR)\outputformat.obj \
        $(OBJDIR)\popen.obj    \
        $(OBJDIR)\printf.obj   \
        $(OBJDIR)\puts.obj     \
        $(OBJDIR)\putw.obj     \
        $(OBJDIR)\putws.obj    \
        $(OBJDIR)\rewind.obj   \
        $(OBJDIR)\rmtmp.obj    \
        $(OBJDIR)\scanf.obj    \
        $(OBJDIR)\setmaxf.obj  \
        $(OBJDIR)\setbuf.obj   \
        $(OBJDIR)\setvbuf.obj  \
        $(OBJDIR)\snprintf.obj \
        $(OBJDIR)\snprnc.obj   \
        $(OBJDIR)\snscanf.obj  \
        $(OBJDIR)\snwprint.obj \
        $(OBJDIR)\snwscanf.obj \
        $(OBJDIR)\sprintf.obj  \
        $(OBJDIR)\sscanf.obj   \
        $(OBJDIR)\stream.obj   \
        $(OBJDIR)\swprintf.obj \
        $(OBJDIR)\swprintn.obj \
        $(OBJDIR)\swprnc.obj   \
        $(OBJDIR)\swscanf.obj  \
        $(OBJDIR)\tempnam.obj  \
        $(OBJDIR)\tmpfile.obj  \
        $(OBJDIR)\ungetc.obj   \
        $(OBJDIR)\ungetwc.obj  \
        $(OBJDIR)\vprintf.obj  \
        $(OBJDIR)\vfprintf.obj \
        $(OBJDIR)\vfwprint.obj \
        $(OBJDIR)\vsprintf.obj \
        $(OBJDIR)\vsnprint.obj \
        $(OBJDIR)\vsnprnc.obj  \
        $(OBJDIR)\vsnwprnt.obj \
        $(OBJDIR)\vswprint.obj \
        $(OBJDIR)\vswprinn.obj \
        $(OBJDIR)\vswprnc.obj  \
        $(OBJDIR)\vwprintf.obj \
        $(OBJDIR)\wfdopen.obj  \
        $(OBJDIR)\wfopen.obj   \
        $(OBJDIR)\wfreopen.obj \
        $(OBJDIR)\_wopen.obj   \
        $(OBJDIR)\wpopen.obj   \
        $(OBJDIR)\wprintf.obj  \
        $(OBJDIR)\wscanf.obj   \
        $(OBJDIR)\wtempnam.obj \
        $(OBJDIR)\wtmpfile.obj \
        $(OBJDIR)\ncommode.obj \
        $(CPP_OBJDIR)\cscanf.obj   \
        $(CPP_OBJDIR)\cscanfs.obj  \
        $(CPP_OBJDIR)\cwscanf.obj  \
        $(CPP_OBJDIR)\cwscanfs.obj \
        $(CPP_OBJDIR)\cprintf.obj  \
        $(CPP_OBJDIR)\cprintfp.obj \
        $(CPP_OBJDIR)\cprintfs.obj \
        $(CPP_OBJDIR)\cwprintf.obj \
        $(CPP_OBJDIR)\cwprntfp.obj \
        $(CPP_OBJDIR)\cwprntfs.obj \
        $(CPP_OBJDIR)\input.obj    \
        $(CPP_OBJDIR)\inputs.obj   \
        $(CPP_OBJDIR)\output.obj   \
        $(CPP_OBJDIR)\outputp.obj  \
        $(CPP_OBJDIR)\outputs.obj  \
        $(CPP_OBJDIR)\winput.obj   \
        $(CPP_OBJDIR)\winputs.obj  \
        $(CPP_OBJDIR)\woutput.obj  \
        $(CPP_OBJDIR)\woutputp.obj \
        $(CPP_OBJDIR)\woutputs.obj

STRING_OBJECTS = \
!if "$(TARGET_CPU)" == "IA64"
        $(OBJDIR)\memccpy.obj  \
        $(OBJDIR)\memchr.obj   \
        $(OBJDIR)\memcmp.obj   \
        $(OBJDIR)\memcpy.obj   \
        $(OBJDIR)\memcpy_s.obj \
        $(OBJDIR)\memcpyi.obj  \
        $(OBJDIR)\memmove.obj  \
        $(OBJDIR)\memmove_s.obj \
        $(OBJDIR)\memset.obj   \
        $(OBJDIR)\memseti.obj  \
        $(OBJDIR)\strcat.obj   \
        $(OBJDIR)\strchr.obj   \
        $(OBJDIR)\strcmp.obj   \
        $(OBJDIR)\strcpy.obj   \
        $(OBJDIR)\strcspn.obj  \
        $(OBJDIR)\strdup.obj   \
        $(OBJDIR)\strlen.obj   \
        $(OBJDIR)\strncat.obj  \
        $(OBJDIR)\strncmp.obj  \
        $(OBJDIR)\strncpy.obj  \
        $(OBJDIR)\strnset.obj  \
        $(OBJDIR)\strpbrk.obj  \
        $(OBJDIR)\strrchr.obj  \
        $(OBJDIR)\strrev.obj   \
        $(OBJDIR)\strset.obj   \
        $(OBJDIR)\strspn.obj   \
        $(OBJDIR)\strstr.obj   \
!endif
!if "$(TARGET_CPU)" == "i386"
        $(OBJDIR)\memcpy.obj   \
        $(OBJDIR)\p4_memcpy.obj \
        $(OBJDIR)\memcpy_s.obj \
        $(OBJDIR)\memchr.obj   \
        $(OBJDIR)\memcmp.obj   \
        $(OBJDIR)\memccpy.obj  \
        $(OBJDIR)\_memicmp.obj \
        $(OBJDIR)\memmove.obj  \
        $(OBJDIR)\memmove_s.obj \
        $(OBJDIR)\memset.obj   \
        $(OBJDIR)\p4_memset.obj \
        $(OBJDIR)\strcat.obj   \
        $(OBJDIR)\strchr.obj   \
        $(OBJDIR)\strcmp.obj   \
        $(OBJDIR)\strcspn.obj  \
        $(OBJDIR)\strdup.obj   \
        $(OBJDIR)\strlen.obj   \
        $(OBJDIR)\strncat.obj  \
        $(OBJDIR)\strncmp.obj  \
        $(OBJDIR)\strncpy.obj  \
        $(OBJDIR)\_strnicm.obj \
        $(OBJDIR)\strnset.obj  \
        $(OBJDIR)\strpbrk.obj  \
        $(OBJDIR)\strrchr.obj  \
        $(OBJDIR)\strrev.obj   \
        $(OBJDIR)\strset.obj   \
        $(OBJDIR)\strspn.obj   \
        $(OBJDIR)\strstr.obj   \
!endif
!if "$(TARGET_CPU)" == "AMD64"
# memcpy.obj contains memmove as well
        $(OBJDIR)\memcpy.obj   \
        $(OBJDIR)\memcpy_s.obj \
        $(OBJDIR)\memchr.obj   \
        $(OBJDIR)\memcmp.obj   \
        $(OBJDIR)\memccpy.obj  \
        $(OBJDIR)\memmove_s.obj \
        $(OBJDIR)\memset.obj   \
        $(OBJDIR)\strcat.obj   \
        $(OBJDIR)\strchr.obj   \
        $(OBJDIR)\strcmp.obj   \
        $(OBJDIR)\strcspn.obj  \
        $(OBJDIR)\strdup.obj   \
        $(OBJDIR)\strlen.obj   \
        $(OBJDIR)\strncat.obj  \
        $(OBJDIR)\strncmp.obj  \
        $(OBJDIR)\strncpy.obj  \
        $(OBJDIR)\strnset.obj  \
        $(OBJDIR)\strpbrk.obj  \
        $(OBJDIR)\strrchr.obj  \
        $(OBJDIR)\strrev.obj   \
        $(OBJDIR)\strset.obj   \
        $(OBJDIR)\strspn.obj   \
        $(OBJDIR)\strstr.obj   \
!endif
        $(OBJDIR)\strlen_s.obj \
        $(OBJDIR)\strcat_s.obj \
        $(OBJDIR)\strncat_s.obj \
        $(OBJDIR)\strcpy_s.obj \
        $(OBJDIR)\strncpy_s.obj \
        $(OBJDIR)\strncnt.obj  \
        $(OBJDIR)\strset_s.obj \
        $(OBJDIR)\strnset_s.obj \
        $(OBJDIR)\strtok.obj   \
        $(OBJDIR)\strtok_s.obj \
        $(OBJDIR)\wcscat.obj   \
        $(OBJDIR)\wcscat_s.obj \
        $(OBJDIR)\wcschr.obj   \
        $(OBJDIR)\wcscmp.obj   \
        $(OBJDIR)\wcscpy_s.obj \
        $(OBJDIR)\wcscspn.obj  \
        $(OBJDIR)\wcsdup.obj   \
        $(OBJDIR)\wcslen.obj   \
        $(OBJDIR)\wcslen_s.obj \
        $(OBJDIR)\wcsncat.obj  \
        $(OBJDIR)\wcsncat_s.obj \
        $(OBJDIR)\wcsncmp.obj  \
        $(OBJDIR)\wcsncnt.obj  \
        $(OBJDIR)\wcsncpy.obj  \
        $(OBJDIR)\wcsncpy_s.obj  \
        $(OBJDIR)\wcsnset.obj  \
        $(OBJDIR)\wcsnset_s.obj  \
        $(OBJDIR)\wcspbrk.obj  \
        $(OBJDIR)\wcsrchr.obj  \
        $(OBJDIR)\wcsrev.obj   \
        $(OBJDIR)\wcsset.obj   \
        $(OBJDIR)\wcsset_s.obj \
        $(OBJDIR)\wcsspn.obj   \
        $(OBJDIR)\wcsstr.obj   \
        $(OBJDIR)\wcstok.obj   \
        $(OBJDIR)\wcstok_s.obj \
        $(CPP_OBJDIR)\memicmp.obj  \
        $(CPP_OBJDIR)\strcoll.obj  \
        $(CPP_OBJDIR)\stricmp.obj  \
        $(CPP_OBJDIR)\stricoll.obj \
        $(CPP_OBJDIR)\strlwr.obj   \
        $(CPP_OBJDIR)\strncoll.obj \
        $(CPP_OBJDIR)\strnicmp.obj \
        $(CPP_OBJDIR)\strnicol.obj \
        $(CPP_OBJDIR)\strupr.obj   \
        $(CPP_OBJDIR)\strxfrm.obj  \
        $(CPP_OBJDIR)\wcscoll.obj  \
        $(CPP_OBJDIR)\wcsicmp.obj  \
        $(CPP_OBJDIR)\wcsicoll.obj \
        $(CPP_OBJDIR)\wcslwr.obj   \
        $(CPP_OBJDIR)\wcsncoll.obj \
        $(CPP_OBJDIR)\wcsnicmp.obj \
        $(CPP_OBJDIR)\wcsnicol.obj \
        $(CPP_OBJDIR)\wcsupr.obj   \
        $(CPP_OBJDIR)\wcsxfrm.obj 

TIME_OBJECTS = \
        $(OBJDIR)\asctime.obj  \
        $(OBJDIR)\clock.obj    \
        $(OBJDIR)\ctime.obj    \
        $(OBJDIR)\days.obj     \
        $(OBJDIR)\difftime.obj \
        $(OBJDIR)\difftm64.obj \
        $(OBJDIR)\dtoxtime.obj \
        $(OBJDIR)\ftime.obj    \
        $(OBJDIR)\gmtime.obj   \
        $(OBJDIR)\localtim.obj \
        $(OBJDIR)\mktime.obj   \
        $(CPP_OBJDIR)\strftime.obj \
        $(OBJDIR)\strdate.obj  \
        $(OBJDIR)\strtime.obj  \
        $(OBJDIR)\time.obj     \
        $(OBJDIR)\timeset.obj  \
        $(OBJDIR)\tzset.obj    \
        $(OBJDIR)\utime.obj    \
        $(OBJDIR)\ctime64.obj  \
        $(OBJDIR)\dtoxtm64.obj \
        $(OBJDIR)\ftime64.obj  \
        $(OBJDIR)\gmtime64.obj \
        $(OBJDIR)\loctim64.obj \
        $(OBJDIR)\mktime64.obj \
        $(OBJDIR)\systime.obj  \
        $(OBJDIR)\time64.obj   \
        $(OBJDIR)\utime64.obj  \
        $(CPP_OBJDIR)\wcsftime.obj \
        $(OBJDIR)\wasctime.obj \
        $(OBJDIR)\wctime.obj   \
        $(OBJDIR)\wctime64.obj \
        $(OBJDIR)\wstrdate.obj \
        $(OBJDIR)\wstrtime.obj \
        $(OBJDIR)\wutime.obj   \
        $(OBJDIR)\wutime64.obj

CLR_OBJECTS = \
        $(CLR_OBJDIR)\delaopnt.obj \
        $(CLR_OBJDIR)\delopnt.obj \
        $(CLR_OBJDIR)\dll_argv.obj \
        $(CLR_OBJDIR)\dllargv.obj \
        $(CLR_OBJDIR)\mehvccctr.obj \
        $(CLR_OBJDIR)\mehvcccvb.obj \
        $(CLR_OBJDIR)\mehvecctr.obj \
        $(CLR_OBJDIR)\mehveccvb.obj \
        $(CLR_OBJDIR)\mehvecdtr.obj \
        $(CLR_OBJDIR)\helperfunc.obj \
        $(CLR_OBJDIR)\managdeh.obj \
        $(CLR_OBJDIR)\ManagedMain.obj \
        $(CLR_OBJDIR)\mcrtexe.obj \
        $(CLR_OBJDIR)\mcrtexew.obj \
        $(CLR_OBJDIR)\merr.obj \
        $(CLR_OBJDIR)\mbsearch.obj \
        $(CLR_OBJDIR)\mqsort.obj  \
        $(CLR_OBJDIR)\mlfind.obj \
        $(CLR_OBJDIR)\mlsearch.obj \
        $(CLR_OBJDIR)\msilexit.obj \
        $(CLR_OBJDIR)\mstartup.obj \
        $(CLR_OBJDIR)\mwcrtexe.obj \
        $(CLR_OBJDIR)\mwcrtexew.obj \
        $(CLR_OBJDIR)\newaopnt.obj \
        $(CLR_OBJDIR)\newopnt.obj \
        $(CLR_OBJDIR)\nothrow0.obj \
        $(CLR_OBJDIR)\puremsilcode.obj \
        $(CLR_OBJDIR)\wdll_av.obj \
        $(CLR_OBJDIR)\wdllargv.obj \
        $(CLR_OBJDIR)\wildcard.obj \
!if "$(TARGET_CPU)"=="AMD64"
        $(CLR_OBJDIR)\dllsupp.obj \
!elseif "$(TARGET_CPU)"=="IA64"
        $(CLR_OBJDIR)\dllsupp.obj \
        $(CLR_OBJDIR)\divhelp.obj \
!endif

PURE_OBJECTS = \
!if "$(BLD_DBG)"=="1"
        $(PURE_OBJDIR)\dbgdel.obj \
!else
        $(PURE_OBJDIR)\delete.obj \
!endif
        $(PURE_OBJDIR)\delete2.obj \
        $(PURE_OBJDIR)\delaopnt.obj \
        $(PURE_OBJDIR)\delopnt.obj \
        $(PURE_OBJDIR)\dll_argv.obj \
        $(PURE_OBJDIR)\dllargv.obj \
        $(PURE_OBJDIR)\locale_implib_pure.obj \
        $(PURE_OBJDIR)\mehvccctr.obj \
        $(PURE_OBJDIR)\mehvcccvb.obj \
        $(PURE_OBJDIR)\mehvecctr.obj \
        $(PURE_OBJDIR)\mehveccvb.obj \
        $(PURE_OBJDIR)\mehvecdtr.obj \
        $(PURE_OBJDIR)\helperfunc.obj \
        $(PURE_OBJDIR)\managdeh.obj \
        $(PURE_OBJDIR)\ManagedMain.obj \
        $(PURE_OBJDIR)\mcrtexe.obj \
        $(PURE_OBJDIR)\mcrtexew.obj \
        $(PURE_OBJDIR)\merr.obj \
        $(PURE_OBJDIR)\mbsearch.obj \
        $(PURE_OBJDIR)\mqsort.obj  \
        $(PURE_OBJDIR)\mlfind.obj \
        $(PURE_OBJDIR)\mlsearch.obj \
        $(PURE_OBJDIR)\mpiostream.obj \
        $(PURE_OBJDIR)\mpushiostream.obj \
        $(PURE_OBJDIR)\msilexit.obj \
        $(PURE_OBJDIR)\mstartup.obj \
        $(PURE_OBJDIR)\mwcrtexe.obj \
        $(PURE_OBJDIR)\mwcrtexew.obj \
        $(PURE_OBJDIR)\new.obj \
        $(PURE_OBJDIR)\new2.obj \
        $(PURE_OBJDIR)\newaopnt.obj \
        $(PURE_OBJDIR)\newopnt.obj \
        $(PURE_OBJDIR)\nothrow0.obj \
        $(PURE_OBJDIR)\puremsilcode.obj \
        $(PURE_OBJDIR)\rtti.obj \
        $(PURE_OBJDIR)\ti_inst.obj \
        $(PURE_OBJDIR)\wdll_av.obj \
        $(PURE_OBJDIR)\wdllargv.obj \
        $(PURE_OBJDIR)\wildcard.obj \
        $(PURE_OBJDIR)\xvalues.obj  \
        $(PURE_OBJDIR)\xfvalues.obj \
        $(PURE_OBJDIR)\xlvalues.obj \
        $(PURE_OBJDIR)\xmutex.obj \
        $(PURE_OBJDIR)\xmtx.obj \
        $(PURE_OBJDIR)\xcosh.obj \
        $(PURE_OBJDIR)\xferaise.obj \
        $(PURE_OBJDIR)\xdtest.obj \
        $(PURE_OBJDIR)\xexp.obj \
        $(PURE_OBJDIR)\xsinh.obj \
        $(PURE_OBJDIR)\xfcosh.obj \
        $(PURE_OBJDIR)\xfdtest.obj \
        $(PURE_OBJDIR)\xfexp.obj \
        $(PURE_OBJDIR)\xfsinh.obj \
        $(PURE_OBJDIR)\xdateord.obj \
        $(PURE_OBJDIR)\xdnorm.obj \
        $(PURE_OBJDIR)\xdscale.obj \
        $(PURE_OBJDIR)\xpoly.obj \
        $(PURE_OBJDIR)\xfdnorm.obj \
        $(PURE_OBJDIR)\xfdscale.obj \
        $(PURE_OBJDIR)\xlcosh.obj \
        $(PURE_OBJDIR)\xldnorm.obj \
        $(PURE_OBJDIR)\xldscale.obj \
        $(PURE_OBJDIR)\xldtest.obj \
        $(PURE_OBJDIR)\xlexp.obj \
        $(PURE_OBJDIR)\xlsinh.obj \
        $(PURE_OBJDIR)\xlpoly.obj \
        $(PURE_OBJDIR)\fiopen.obj \
        $(PURE_OBJDIR)\stdthrow.obj \
        $(PURE_OBJDIR)\xstrcoll.obj \
        $(PURE_OBJDIR)\_tolower.obj \
        $(PURE_OBJDIR)\xgetwctype.obj \
        $(PURE_OBJDIR)\xstod.obj \
        $(PURE_OBJDIR)\xstof.obj \
        $(PURE_OBJDIR)\xstold.obj \
        $(PURE_OBJDIR)\xstoll.obj \
        $(PURE_OBJDIR)\xstoul.obj \
        $(PURE_OBJDIR)\xstoull.obj \
        $(PURE_OBJDIR)\xstol.obj \
        $(PURE_OBJDIR)\xstrxfrm.obj \
        $(PURE_OBJDIR)\_toupper.obj \
        $(PURE_OBJDIR)\xtowlower.obj \
        $(PURE_OBJDIR)\xtowupper.obj \
        $(PURE_OBJDIR)\xwcscoll.obj \
        $(PURE_OBJDIR)\xwcsxfrm.obj \
!if "$(TARGET_CPU)"=="AMD64"
        $(PURE_OBJDIR)\dllsupp.obj \
!elseif "$(TARGET_CPU)"=="IA64"
        $(PURE_OBJDIR)\dllsupp.obj \
        $(PURE_OBJDIR)\divhelp.obj \
!endif

$(OBJDIR)\convert.lib: $(CONVERT_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(CONVERT_OBJECTS: =^
)
<<keep


$(OBJDIR)\direct.lib: $(DIRECT_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(DIRECT_OBJECTS: =^
)
<<keep


$(OBJDIR)\dllstuff.lib: $(DLLSTUFF_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(DLLSTUFF_OBJECTS: =^
)
<<keep


$(OBJDIR)\dos.lib: $(DOS_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(DOS_OBJECTS: =^
)
<<keep


$(OBJDIR)\exec.lib: $(EXEC_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(EXEC_OBJECTS: =^
)
<<keep


$(OBJDIR)\heap.lib: $(HEAP_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(HEAP_OBJECTS: =^
)
<<keep


$(OBJDIR)\helper.lib: $(HELPER_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(HELPER_OBJECTS: =^
)
<<keep


$(OBJDIR)\linkopts.lib: $(LINKOPTS_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(LINKOPTS_OBJECTS: =^
)
<<keep

$(OBJDIR)\plinkopts.lib: $(PLINKOPTS_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(PLINKOPTS_OBJECTS: =^
)
<<keep

$(OBJDIR)\lowio.lib: $(LOWIO_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(LOWIO_OBJECTS: =^
)
<<keep


$(OBJDIR)\mbstring.lib: $(MBSTRING_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(MBSTRING_OBJECTS: =^
)
<<keep


$(OBJDIR)\misc.lib: $(MISC_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(MISC_OBJECTS: =^
)
<<keep


!if "$(BLD_DLL)"=="1"
$(OBJDIR)\startup.lib: $(STARTUP_OBJECTS)
!else
$(OBJDIR)\startup.lib: $(STARTUP_OBJECTS)
!endif
    $(LIB) -out:$@ @<<$*.rsp
$(STARTUP_OBJECTS: =^
)
<<keep


$(OBJDIR)\$(MIXED_SRC).lib: $(MIXED_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(MIXED_OBJECTS: =^
)
<<keep

$(OBJDIR)\$(STDCPP_SRC).lib: $(STDCPP_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STDCPP_OBJECTS: =^
)
<<keep


$(OBJDIR)\stdio.lib: $(STDIO_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STDIO_OBJECTS: =^
)
<<keep


$(OBJDIR)\string.lib: $(STRING_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(STRING_OBJECTS: =^
)
<<keep


$(OBJDIR)\time.lib: $(TIME_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(TIME_OBJECTS: =^
)
<<keep

$(OBJDIR)\clr.lib: $(CLR_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(CLR_OBJECTS: =^
)
<<keep

$(OBJDIR)\pure.lib: $(PURE_OBJECTS)
    $(LIB) -out:$@ @<<$*.rsp
$(PURE_OBJECTS: =^
)
<<keep

$(OBJDIR)\eh.lib: $(PREOBJDIR)\eh.lib
        copy $(PREOBJDIR)\eh.lib $@

$(OBJDIR)\unhandld.obj: $(PREOBJDIR)\unhandld.obj
        copy $(PREOBJDIR)\unhandld.obj $@

!if "$(RTC)"=="YES"
$(OBJDIR)\rtc.lib: $(PREOBJDIR)\rtc.lib
        copy $(PREOBJDIR)\rtc.lib $@
!endif

$(OBJDIR)\conv.lib: $(PREOBJDIR)\conv.lib
        copy $(PREOBJDIR)\conv.lib $@

$(OBJDIR)\tran.lib: $(PREOBJDIR)\tran.lib
        copy $(PREOBJDIR)\tran.lib $@

$(OBJDIR)\chkesp.obj: $(PREOBJDIR)\chkesp.obj
        copy $(PREOBJDIR)\chkesp.obj $@

$(OBJDIR)\rtcmd.obj: $(PREOBJDIR)\rtcmd.obj
        copy $(PREOBJDIR)\rtcmd.obj $@

$(OBJDIR)\ehvccctr.obj: $(PREOBJDIR)\ehvccctr.obj
        copy $(PREOBJDIR)\ehvccctr.obj $@

$(OBJDIR)\ehvcccvb.obj: $(PREOBJDIR)\ehvcccvb.obj
        copy $(PREOBJDIR)\ehvcccvb.obj $@

$(OBJDIR)\ehvecctr.obj: $(PREOBJDIR)\ehvecctr.obj
        copy $(PREOBJDIR)\ehvecctr.obj $@

$(OBJDIR)\ehveccvb.obj: $(PREOBJDIR)\ehveccvb.obj
        copy $(PREOBJDIR)\ehveccvb.obj $@

$(OBJDIR)\ehvecdtr.obj: $(PREOBJDIR)\ehvecdtr.obj
        copy $(PREOBJDIR)\ehvecdtr.obj $@

# !if "$(BLD_SYSCRT)" != "1"

$(CLR_OBJDIR)\mehvccctr.obj :: $(CLR_PREOBJDIR)\mehvccctr.obj
	copy $(CLR_PREOBJDIR)\mehvccctr.obj $@

$(CLR_OBJDIR)\mehvcccvb.obj :: $(CLR_PREOBJDIR)\mehvcccvb.obj
	copy $(CLR_PREOBJDIR)\mehvcccvb.obj $@

$(CLR_OBJDIR)\mehvecctr.obj :: $(CLR_PREOBJDIR)\mehvecctr.obj
	copy $(CLR_PREOBJDIR)\mehvecctr.obj $@

$(CLR_OBJDIR)\mehveccvb.obj :: $(CLR_PREOBJDIR)\mehveccvb.obj
	copy $(CLR_PREOBJDIR)\mehveccvb.obj $@

$(CLR_OBJDIR)\mehvecdtr.obj :: $(CLR_PREOBJDIR)\mehvecdtr.obj
	copy $(CLR_PREOBJDIR)\mehvecdtr.obj $@

$(CLR_OBJDIR)\managdeh.obj :: $(CLR_PREOBJDIR)\managdeh.obj
	copy $(CLR_PREOBJDIR)\managdeh.obj $@

$(CLR_OBJDIR)\mstdexpt.obj :: $(CLR_PREOBJDIR)\mstdexpt.obj
	copy $(CLR_PREOBJDIR)\mstdexpt.obj $@

$(CLR_OBJDIR)\mtypinfo.obj :: $(CLR_PREOBJDIR)\mtypinfo.obj
	copy $(CLR_PREOBJDIR)\mtypinfo.obj $@

$(CLR_OBJDIR)\atlssup.obj :: $(CLR_PREOBJDIR)\atlssup.obj
	copy $(CLR_PREOBJDIR)\atlssup.obj $@

$(PURE_OBJDIR)\mehvccctr.obj :: $(PURE_PREOBJDIR)\mehvccctr.obj
	copy $(PURE_PREOBJDIR)\mehvccctr.obj $@

$(PURE_OBJDIR)\mehvcccvb.obj :: $(PURE_PREOBJDIR)\mehvcccvb.obj
	copy $(PURE_PREOBJDIR)\mehvcccvb.obj $@

$(PURE_OBJDIR)\mehvecctr.obj :: $(PURE_PREOBJDIR)\mehvecctr.obj
	copy $(PURE_PREOBJDIR)\mehvecctr.obj $@

$(PURE_OBJDIR)\mehveccvb.obj :: $(PURE_PREOBJDIR)\mehveccvb.obj
	copy $(PURE_PREOBJDIR)\mehveccvb.obj $@

$(PURE_OBJDIR)\mehvecdtr.obj :: $(PURE_PREOBJDIR)\mehvecdtr.obj
	copy $(PURE_PREOBJDIR)\mehvecdtr.obj $@

$(PURE_OBJDIR)\managdeh.obj :: $(PURE_PREOBJDIR)\managdeh.obj
	copy $(PURE_PREOBJDIR)\managdeh.obj $@

$(PURE_OBJDIR)\mtypinfo.obj :: $(PURE_PREOBJDIR)\mtypinfo.obj
	copy $(PURE_PREOBJDIR)\mtypinfo.obj $@

$(PURE_OBJDIR)\atlssup.obj :: $(PURE_PREOBJDIR)\atlssup.obj
	copy $(PURE_PREOBJDIR)\atlssup.obj $@

$(PURE_OBJDIR)\rtti.obj :: $(PURE_PREOBJDIR)\rtti.obj
	copy $(PURE_PREOBJDIR)\rtti.obj $@

$(OBJDIR)\tncleanup.obj: $(PREOBJDIR)\tncleanup.obj
        copy $(PREOBJDIR)\tncleanup.obj $@

$(OBJDIR)\oldexcpt.obj: $(PREOBJDIR)\oldexcpt.obj
        copy $(PREOBJDIR)\oldexcpt.obj $@

$(OBJDIR)\sehprolg.obj: $(PREOBJDIR)\sehprolg.obj
        copy $(PREOBJDIR)\sehprolg.obj $@

$(OBJDIR)\sehprolg4.obj: $(PREOBJDIR)\sehprolg4.obj
        copy $(PREOBJDIR)\sehprolg4.obj $@

$(OBJDIR)\sehprolg4gs.obj: $(PREOBJDIR)\sehprolg4gs.obj
        copy $(PREOBJDIR)\sehprolg4gs.obj $@

$(OBJDIR)\sehsupp.obj: $(PREOBJDIR)\sehsupp.obj
        copy $(PREOBJDIR)\sehsupp.obj $@

$(OBJDIR)\calldtor.obj: $(PREOBJDIR)\calldtor.obj
        copy $(PREOBJDIR)\calldtor.obj $@

$(OBJDIR)\setjmp.obj: $(PREOBJDIR)\setjmp.obj
        copy $(PREOBJDIR)\setjmp.obj $@

$(PURE_OBJDIR)\pbinmode.obj : $(PURE_OBJDIR)\binmode.obj 
	copy $** $@

$(PURE_OBJDIR)\pcommode.obj : $(PURE_OBJDIR)\commode.obj 
	copy $** $@

$(PURE_OBJDIR)\pinvalidcontinue.obj : $(PURE_OBJDIR)\invalidcontinue.obj
	copy $** $@

$(PURE_OBJDIR)\pnewmode.obj : $(PURE_OBJDIR)\newmode.obj
	copy $** $@

$(PURE_OBJDIR)\pnoarg.obj : $(PURE_OBJDIR)\noarg.obj
	copy $** $@

$(PURE_OBJDIR)\pnoenv.obj : $(PURE_OBJDIR)\noenv.obj
	copy $** $@

$(PURE_OBJDIR)\pnothrownew.obj : $(PURE_OBJDIR)\nothrownew.obj
	copy $** $@

$(PURE_OBJDIR)\psetargv.obj : $(PURE_OBJDIR)\setargv.obj
	copy $** $@

$(PURE_OBJDIR)\pthreadlocale.obj : $(PURE_OBJDIR)\threadlocale.obj
	copy $** $@

$(PURE_OBJDIR)\puthrownew.obj	: $(PURE_OBJDIR)\thrownew.obj	
	copy $** $@

$(PURE_OBJDIR)\pwsetargv.obj : $(PURE_OBJDIR)\wsetargv.obj
	copy $** $@


!if "$(TARGET_CPU)" == "i386"

$(OBJDIR)\atlssup.obj: $(PREOBJDIR)\atlssup.obj
        copy $(PREOBJDIR)\atlssup.obj $@

$(OBJDIR)\bsku.obj: $(PREOBJDIR)\bsku.obj
        copy $(PREOBJDIR)\bsku.obj $@

$(OBJDIR)\chandler4.obj: $(PREOBJDIR)\chandler4.obj
        copy $(PREOBJDIR)\chandler4.obj $@

$(OBJDIR)\chandler4gs.obj: $(PREOBJDIR)\chandler4gs.obj
        copy $(PREOBJDIR)\chandler4gs.obj $@

$(OBJDIR)\ehprolg2.obj: $(PREOBJDIR)\ehprolg2.obj
        copy $(PREOBJDIR)\ehprolg2.obj $@

$(OBJDIR)\ehprolg3.obj: $(PREOBJDIR)\ehprolg3.obj
        copy $(PREOBJDIR)\ehprolg3.obj $@

$(OBJDIR)\ehprolg3a.obj: $(PREOBJDIR)\ehprolg3a.obj
        copy $(PREOBJDIR)\ehprolg3a.obj $@

$(OBJDIR)\ehprolog.obj: $(PREOBJDIR)\ehprolog.obj
        copy $(PREOBJDIR)\ehprolog.obj $@

$(OBJDIR)\eh3valid.obj: $(PREOBJDIR)\eh3valid.obj
        copy $(PREOBJDIR)\eh3valid.obj $@

$(OBJDIR)\exsup.obj: $(PREOBJDIR)\exsup.obj
        copy $(PREOBJDIR)\exsup.obj $@

$(OBJDIR)\exsup2.obj: $(PREOBJDIR)\exsup2.obj
        copy $(PREOBJDIR)\exsup2.obj $@

$(OBJDIR)\exsup3.obj: $(PREOBJDIR)\exsup3.obj
        copy $(PREOBJDIR)\exsup3.obj $@

$(OBJDIR)\exsup4.obj: $(PREOBJDIR)\exsup4.obj
        copy $(PREOBJDIR)\exsup4.obj $@

$(OBJDIR)\cpu_disp.obj: $(PREOBJDIR)\cpu_disp.obj
        copy $(PREOBJDIR)\cpu_disp.obj $@

$(OBJDIR)\ftol2.obj: $(PREOBJDIR)\ftol2.obj
        copy $(PREOBJDIR)\ftol2.obj $@

$(OBJDIR)\longjmp.obj: $(PREOBJDIR)\longjmp.obj
        copy $(PREOBJDIR)\longjmp.obj $@

$(OBJDIR)\matherr.obj: $(PREOBJDIR)\matherr.obj
        copy $(PREOBJDIR)\matherr.obj $@

$(OBJDIR)\memcmp.obj: $(PREOBJDIR)\memcmp.obj
        copy $(PREOBJDIR)\memcmp.obj $@

$(OBJDIR)\p4_memcpy.obj: $(PREOBJDIR)\p4_memcpy.obj
        copy $(PREOBJDIR)\p4_memcpy.obj $@

$(OBJDIR)\p4_memset.obj: $(PREOBJDIR)\p4_memset.obj
        copy $(PREOBJDIR)\p4_memset.obj $@

$(OBJDIR)\setjmp3.obj: $(PREOBJDIR)\setjmp3.obj
        copy $(PREOBJDIR)\setjmp3.obj $@

$(OBJDIR)\setjmpex.obj: $(PREOBJDIR)\setjmpex.obj
        copy $(PREOBJDIR)\setjmpex.obj $@

########
#
# These objects can be built from (assembler) source by editing
# makefile.sub so that the symbol BLD_ASM is set to the value 1.
# To assembler these objects, you must have MASM 6.11a or later.
#
########

!if "$(BLD_ASM)"=="0"

$(OBJDIR)\alloca16.obj: $(PREOBJDIR)\alloca16.obj
        copy $(PREOBJDIR)\alloca16.obj $@

$(OBJDIR)\chkstk.obj: $(PREOBJDIR)\chkstk.obj
        copy $(PREOBJDIR)\chkstk.obj $@

$(OBJDIR)\dllsupp.obj: $(PREOBJDIR)\dllsupp.obj
        copy $(PREOBJDIR)\dllsupp.obj $@

$(OBJDIR)\enable.obj: $(PREOBJDIR)\enable.obj
        copy $(PREOBJDIR)\enable.obj $@

$(OBJDIR)\inp.obj: $(PREOBJDIR)\inp.obj
        copy $(PREOBJDIR)\inp.obj $@

$(OBJDIR)\lldiv.obj: $(PREOBJDIR)\lldiv.obj
        copy $(PREOBJDIR)\lldiv.obj $@

$(OBJDIR)\lldvrm.obj: $(PREOBJDIR)\lldvrm.obj
        copy $(PREOBJDIR)\lldvrm.obj $@

$(OBJDIR)\llmul.obj: $(PREOBJDIR)\llmul.obj
        copy $(PREOBJDIR)\llmul.obj $@

$(OBJDIR)\llrem.obj: $(PREOBJDIR)\llrem.obj
        copy $(PREOBJDIR)\llrem.obj $@

$(OBJDIR)\llshl.obj: $(PREOBJDIR)\llshl.obj
        copy $(PREOBJDIR)\llshl.obj $@

$(OBJDIR)\llshr.obj: $(PREOBJDIR)\llshr.obj
        copy $(PREOBJDIR)\llshr.obj $@

$(OBJDIR)\memccpy.obj: $(PREOBJDIR)\memccpy.obj
        copy $(PREOBJDIR)\memccpy.obj $@

$(OBJDIR)\memchr.obj: $(PREOBJDIR)\memchr.obj
        copy $(PREOBJDIR)\memchr.obj $@

$(OBJDIR)\memcpy.obj: $(PREOBJDIR)\memcpy.obj
        copy $(PREOBJDIR)\memcpy.obj $@

$(OBJDIR)\_memicmp.obj: $(PREOBJDIR)\_memicmp.obj
        copy $(PREOBJDIR)\_memicmp.obj $@

$(OBJDIR)\memmove.obj: $(PREOBJDIR)\memmove.obj
        copy $(PREOBJDIR)\memmove.obj $@

$(OBJDIR)\memset.obj: $(PREOBJDIR)\memset.obj
        copy $(PREOBJDIR)\memset.obj $@

$(OBJDIR)\outp.obj: $(PREOBJDIR)\outp.obj
        copy $(PREOBJDIR)\outp.obj $@

$(OBJDIR)\strcat.obj: $(PREOBJDIR)\strcat.obj
        copy $(PREOBJDIR)\strcat.obj $@

$(OBJDIR)\strchr.obj: $(PREOBJDIR)\strchr.obj
        copy $(PREOBJDIR)\strchr.obj $@

$(OBJDIR)\strcmp.obj: $(PREOBJDIR)\strcmp.obj
        copy $(PREOBJDIR)\strcmp.obj $@

$(OBJDIR)\strcspn.obj: $(PREOBJDIR)\strcspn.obj
        copy $(PREOBJDIR)\strcspn.obj $@

$(OBJDIR)\strlen.obj: $(PREOBJDIR)\strlen.obj
        copy $(PREOBJDIR)\strlen.obj $@

$(OBJDIR)\strncat.obj: $(PREOBJDIR)\strncat.obj
        copy $(PREOBJDIR)\strncat.obj $@

$(OBJDIR)\strncpy.obj: $(PREOBJDIR)\strncpy.obj
        copy $(PREOBJDIR)\strncpy.obj $@

$(OBJDIR)\_strnicm.obj: $(PREOBJDIR)\_strnicm.obj
        copy $(PREOBJDIR)\_strnicm.obj $@

$(OBJDIR)\strnset.obj: $(PREOBJDIR)\strnset.obj
        copy $(PREOBJDIR)\strnset.obj $@

$(OBJDIR)\strpbrk.obj: $(PREOBJDIR)\strpbrk.obj
        copy $(PREOBJDIR)\strpbrk.obj $@

$(OBJDIR)\strrchr.obj: $(PREOBJDIR)\strrchr.obj
        copy $(PREOBJDIR)\strrchr.obj $@

$(OBJDIR)\strrev.obj: $(PREOBJDIR)\strrev.obj
        copy $(PREOBJDIR)\strrev.obj $@

$(OBJDIR)\strset.obj: $(PREOBJDIR)\strset.obj
        copy $(PREOBJDIR)\strset.obj $@

$(OBJDIR)\strspn.obj: $(PREOBJDIR)\strspn.obj
        copy $(PREOBJDIR)\strspn.obj $@

$(OBJDIR)\strstr.obj: $(PREOBJDIR)\strstr.obj
        copy $(PREOBJDIR)\strstr.obj $@

$(OBJDIR)\ulldiv.obj: $(PREOBJDIR)\ulldiv.obj
        copy $(PREOBJDIR)\ulldiv.obj $@

$(OBJDIR)\ulldvrm.obj: $(PREOBJDIR)\ulldvrm.obj
        copy $(PREOBJDIR)\ulldvrm.obj $@

$(OBJDIR)\ullrem.obj: $(PREOBJDIR)\ullrem.obj
        copy $(PREOBJDIR)\ullrem.obj $@

$(OBJDIR)\ullshr.obj    : $(PREOBJDIR)\ullshr.obj
        copy $(PREOBJDIR)\ullshr.obj $@

!endif # BLD_ASM==0
!endif # TARGET_CPU == i386

!if "$(TARGET_CPU)" == "IA64"

$(OBJDIR)\chandler.obj: $(PREOBJDIR)\chandler.obj
        copy $(PREOBJDIR)\chandler.obj $@

$(OBJDIR)\cinitone.obj: $(PREOBJDIR)\cinitone.obj
        copy $(PREOBJDIR)\cinitone.obj $@

$(OBJDIR)\gshandler.obj: $(PREOBJDIR)\gshandler.obj
        copy $(PREOBJDIR)\gshandler.obj $@

$(OBJDIR)\gshandlereh.obj: $(PREOBJDIR)\gshandlereh.obj
        copy $(PREOBJDIR)\gshandlereh.obj $@

$(OBJDIR)\gshandlerseh.obj: $(PREOBJDIR)\gshandlerseh.obj
        copy $(PREOBJDIR)\gshandlerseh.obj $@

$(OBJDIR)\jmpuwind.obj: $(PREOBJDIR)\jmpuwind.obj
        copy $(PREOBJDIR)\jmpuwind.obj $@

$(OBJDIR)\longjmp.obj: $(PREOBJDIR)\longjmp.obj
        copy $(PREOBJDIR)\longjmp.obj $@

$(OBJDIR)\miscs.obj: $(PREOBJDIR)\miscs.obj
        copy $(PREOBJDIR)\miscs.obj $@

$(OBJDIR)\setjmpex.obj: $(PREOBJDIR)\setjmpex.obj
        copy $(PREOBJDIR)\setjmpex.obj $@

$(OBJDIR)\strcat.obj: $(PREOBJDIR)\strcat.obj
        copy $(PREOBJDIR)\strcat.obj $@

$(OBJDIR)\strcpy.obj: $(PREOBJDIR)\strcpy.obj
        copy $(PREOBJDIR)\strcpy.obj $@

$(OBJDIR)\strcmp.obj: $(PREOBJDIR)\strcmp.obj
        copy $(PREOBJDIR)\strcmp.obj $@

$(OBJDIR)\strlen.obj: $(PREOBJDIR)\strlen.obj
        copy $(PREOBJDIR)\strlen.obj $@

$(OBJDIR)\memcmp.obj: $(PREOBJDIR)\memcmp.obj
        copy $(PREOBJDIR)\memcmp.obj $@

$(OBJDIR)\memcpy.obj: $(PREOBJDIR)\memcpy.obj
        copy $(PREOBJDIR)\memcpy.obj $@

$(OBJDIR)\memcpyi.obj: $(PREOBJDIR)\memcpyi.obj
        copy $(PREOBJDIR)\memcpyi.obj $@

$(OBJDIR)\memmove.obj: $(PREOBJDIR)\memmove.obj
        copy $(PREOBJDIR)\memmove.obj $@

$(OBJDIR)\memset.obj: $(PREOBJDIR)\memset.obj
        copy $(PREOBJDIR)\memset.obj $@

$(OBJDIR)\memseti.obj: $(PREOBJDIR)\memseti.obj
        copy $(PREOBJDIR)\memseti.obj $@

$(OBJDIR)\chkstk.obj: $(PREOBJDIR)\chkstk.obj
        copy $(PREOBJDIR)\chkstk.obj $@

$(OBJDIR)\matherr.obj: $(PREOBJDIR)\matherr.obj
        copy $(PREOBJDIR)\matherr.obj $@

!endif
!if "$(TARGET_CPU)"=="AMD64"
$(OBJDIR)\jmpuwind.obj: $(PREOBJDIR)\jmpuwind.obj
        copy $(PREOBJDIR)\jmpuwind.obj $@

$(OBJDIR)\longjmp.obj: $(PREOBJDIR)\longjmp.obj
        copy $(PREOBJDIR)\longjmp.obj $@

$(OBJDIR)\setjmpex.obj: $(PREOBJDIR)\setjmpex.obj
        copy $(PREOBJDIR)\setjmpex.obj $@

$(OBJDIR)\amdsecgs.obj: $(PREOBJDIR)\amdsecgs.obj
        copy $(PREOBJDIR)\amdsecgs.obj $@

$(OBJDIR)\chandler.obj: $(PREOBJDIR)\chandler.obj
        copy $(PREOBJDIR)\chandler.obj $@

$(OBJDIR)\chkstk.obj: $(PREOBJDIR)\chkstk.obj
        copy $(PREOBJDIR)\chkstk.obj $@

$(OBJDIR)\chkstk2.obj: $(PREOBJDIR)\chkstk2.obj
        copy $(PREOBJDIR)\chkstk2.obj $@

$(OBJDIR)\gshandler.obj: $(PREOBJDIR)\gshandler.obj
        copy $(PREOBJDIR)\gshandler.obj $@

$(OBJDIR)\gshandlereh.obj: $(PREOBJDIR)\gshandlereh.obj
        copy $(PREOBJDIR)\gshandlereh.obj $@

$(OBJDIR)\gshandlerseh.obj: $(PREOBJDIR)\gshandlerseh.obj
        copy $(PREOBJDIR)\gshandlerseh.obj $@

$(OBJDIR)\matherr.obj: $(PREOBJDIR)\matherr.obj
        copy $(PREOBJDIR)\matherr.obj $@

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbclevel.c ===
/***
*mbclevel.c - Tests if char is hiragana, katakana, alphabet or digit.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Tests for the various industry defined levels of Microsoft Kanji
*       Code.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <locale.h>
#include <setlocal.h>


/***
*int _ismbcl0(c) - Tests if char is hiragana, katakana, alphabet or digit.
*
*Purpose:
*       Tests if a given char is hiragana, katakana, alphabet, digit or symbol
*       of Microsoft Kanji code.
*
*Entry:
*       unsigned int c - Character to test.
*
*Exit:
*       Returns non-zero if 0x8140 <= c <= 0x889E, else 0.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcl0_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return( (_loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP) &&
            (_ismbblead_l(c >> 8, _loc_update.GetLocaleT())) &&
            (_ismbbtrail_l(c & 0x0ff, _loc_update.GetLocaleT())) &&
            (c < 0x889f) );
}

extern "C" int (__cdecl _ismbcl0)(
        unsigned int c
        )
{
    return _ismbcl0_l(c, NULL);
}


/***
*int _ismbcl1(c) - Tests for 1st-level Microsoft Kanji code set.
*
*Purpose:
*       Tests if a given char belongs to Microsoft 1st-level Kanji code set.
*
*Entry:
*       unsigned int c - character to test.
*
*Exit:
*       Returns non-zero if 1st-level, else 0.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcl1_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return( (_loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP) &&
            (_ismbblead_l(c >> 8, _loc_update.GetLocaleT())) &&
            (_ismbbtrail_l(c & 0x0ff, _loc_update.GetLocaleT())) &&
            (c >= 0x889f) && (c <= 0x9872) );
}

extern "C" int (__cdecl _ismbcl1)(
    unsigned int c
    )
{
    return _ismbcl1_l(c, NULL);
}


/***
*int _ismbcl2(c) - Tests for a 2nd-level Microsoft Kanji code character.
*
*Purpose:
*       Tests if a given char belongs to the Microsoft 2nd-level Kanji code set.
*
*Entry:
*       unsigned int c - character to test.
*
*Exit:
*       Returns non-zero if 2nd-level, else 0.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _ismbcl2_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return( (_loc_update.GetLocaleT()->mbcinfo->mbcodepage == _KANJI_CP) &&
            (_ismbblead_l(c >> 8, _loc_update.GetLocaleT())) &&
            (_ismbbtrail_l(c & 0x0ff, _loc_update.GetLocaleT())) &&
            (c >= 0x989f) && (c <= 0xEAA4) );
}
extern "C" int __cdecl _ismbcl2(
        unsigned int c
        )
{
    return _ismbcl2_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbdata.h ===
/***
*mbdata.h - MBCS lib data
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines data for use when building MBCS libs and routines
*
*       [Internal].
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MBDATA
#define _INC_MBDATA

#include <crtdefs.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#if defined (_WIN32)

#define NUM_ULINFO 6 /* multibyte full-width-latin upper/lower info */

#else  /* defined (_WIN32) */

#define NUM_ULINFO 12 /* multibyte full-width-latin upper/lower info */

#endif  /* defined (_WIN32) */

#ifndef _THREADMBCINFO
typedef struct threadmbcinfostruct {
        int refcount;
        int mbcodepage;
        int ismbcodepage;
        int mblcid;
        unsigned short mbulinfo[6];
        unsigned char mbctype[257];
        unsigned char mbcasemap[256];
} threadmbcinfo;
#define _THREADMBCINFO
#endif  /* _THREADMBCINFO */

#ifndef _TAGLC_ID_DEFINED
typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED
#endif  /* _TAGLC_ID_DEFINED */

#ifndef _THREADLOCALEINFO
typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; /* LCID */
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
#define _THREADLOCALEINFO
#endif  /* _THREADLOCALEINFO */

/* global variable to indicate current code page */
extern int __mbcodepage;

/* global flag indicating if the current code page is a multibyte code page */
extern int __ismbcodepage;

#if defined (_WIN32)
/* global variable to indicate current LCID */
extern int __mblcid;
#endif  /* defined (_WIN32) */

/* global variable to indicate current full-width-latin upper/lower info */
extern unsigned short __mbulinfo[NUM_ULINFO];

/* global variable pointing to the current mbc information structure */
extern pthreadmbcinfo __ptmbcinfo;
/* function to update mbc info used by the current thread */
pthreadmbcinfo __cdecl __updatetmbcinfo(void);

/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * general use macros for model dependent/independent versions.
 */

#define _ISMBCP     (__ismbcodepage != 0)
#define _ISNOTMBCP  (__ismbcodepage == 0)

#define _ISMBCP_MT(p)       (p->ismbcodepage != 0)
#define _ISNOTMBCP_MT(p)    (p->ismbcodepage == 0)

#define _ismbbtruelead(_lb,_ch) (!(_lb) && _ismbblead((_ch)))

/* internal use macros since tolower/toupper are locale-dependent */
#define _mbbisupper(_c) ((_mbctype[(_c) + 1] & _SBUP) == _SBUP)
#define _mbbislower(_c) ((_mbctype[(_c) + 1] & _SBLOW) == _SBLOW)

#define _mbbtolower(_c) (_mbbisupper(_c) ? _mbcasemap[_c] : _c)
#define _mbbtoupper(_c) (_mbbislower(_c) ? _mbcasemap[_c] : _c)

#define _ismbbtruelead_l(_lb,_ch,p)   (!(_lb) && _ismbblead_l((_ch), p))
#define _mbbisupper_l(_c, p)      ((p->mbcinfo->mbctype[(_c) + 1] & _SBUP) == _SBUP)
#define _mbbislower_l(_c, p)      ((p->mbcinfo->mbctype[(_c) + 1] & _SBLOW) == _SBLOW)
#define _mbbtolower_l(_c, p)      (_mbbisupper_l(_c, p) ? p->mbcinfo->mbcasemap[_c] : _c)
#define _mbbtoupper_l(_c, p)      (_mbbislower_l(_c, p) ? p->mbcinfo->mbcasemap[_c] : _c)

/* define full-width-latin upper/lower ranges */

#define _MBUPPERLOW1    __mbulinfo[0]
#define _MBUPPERHIGH1   __mbulinfo[1]
#define _MBCASEDIFF1    __mbulinfo[2]

#define _MBUPPERLOW2    __mbulinfo[3]
#define _MBUPPERHIGH2   __mbulinfo[4]
#define _MBCASEDIFF2    __mbulinfo[5]

#define _MBUPPERLOW1_MT(p)  p->mbcinfo->mbulinfo[0]
#define _MBUPPERHIGH1_MT(p) p->mbcinfo->mbulinfo[1]
#define _MBCASEDIFF1_MT(p)  p->mbcinfo->mbulinfo[2]

#define _MBUPPERLOW2_MT(p)  p->mbcinfo->mbulinfo[3]
#define _MBUPPERHIGH2_MT(p) p->mbcinfo->mbulinfo[4]
#define _MBCASEDIFF2_MT(p)  p->mbcinfo->mbulinfo[5]

#if !defined (_WIN32)

#define _MBLOWERLOW1    __mbulinfo[6]
#define _MBLOWERHIGH1   __mbulinfo[7]

#define _MBLOWERLOW2    __mbulinfo[8]
#define _MBLOWERHIGH2   __mbulinfo[9]

#define _MBDIGITLOW     __mbulinfo[10]
#define _MBDIGITHIGH    __mbulinfo[11]

#endif  /* !defined (_WIN32) */

/* Kanji-specific ranges */
#define _MBHIRALOW      0x829f  /* hiragana */
#define _MBHIRAHIGH     0x82f1

#define _MBKATALOW      0x8340  /* katakana */
#define _MBKATAHIGH     0x8396
#define _MBKATAEXCEPT   0x837f  /* exception */

#define _MBKIGOULOW     0x8141  /* kanji punctuation */
#define _MBKIGOUHIGH    0x81ac
#define _MBKIGOUEXCEPT  0x817f  /* exception */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBDATA */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mblen.c ===
/***
*mblen.c - length of multibyte character
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return the number of bytes contained in a multibyte character.
*
*******************************************************************************/


#include <internal.h>
#include <locale.h>
#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>
#include <dbgint.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int mblen() - length of multibyte character
*
*Purpose:
*       Return the number of bytes contained in a multibyte character.
*       [ANSI].
*
*Entry:
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*
*Exit:
*       If s = NULL, returns 0, indicating we use (only) state-independent
*       character encodings.
*
*       If s != NULL, returns:   0  (if *s = null char),
*                               -1  (if the next n or fewer bytes not valid
*                                   mbc),
*                               number of bytes contained in multibyte char
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _mblen_l
        (
        const char * s,
        size_t n,
        _locale_t plocinfo
        )
{
    if ( !s || !(*s) || (n == 0) )
        /* indicate do not have state-dependent encodings,
           empty string length is 0 */
        return 0;

    _LocaleUpdate _loc_update(plocinfo);

    _ASSERTE (_loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 || _loc_update.GetLocaleT()->locinfo->mb_cur_max == 2);


    if ( _isleadbyte_l((unsigned char)*s, _loc_update.GetLocaleT()) )
    {
        /* multi-byte char */

        /* verify valid MB char */
        if ( _loc_update.GetLocaleT()->locinfo->mb_cur_max <= 1 ||
             (int)n < _loc_update.GetLocaleT()->locinfo->mb_cur_max ||
             MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                  s,
                                  _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                  NULL,
                                  0 ) == 0 )
            /* bad MB char */
            return -1;
        else
            return _loc_update.GetLocaleT()->locinfo->mb_cur_max;
    }
    else {
        /* single byte char */

        /* verify valid SB char */
        if ( MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                  s,
                                  1,
                                  NULL,
                                  0 ) == 0 )
            return -1;
        return sizeof(char);
    }

}

extern "C" int __cdecl mblen
        (
        const char * s,
        size_t n
        )
{
    if (__locale_changed == 0)
    {
        return _mblen_l(s, n, &__initiallocalestructinfo);
    }
    else
    {
        return _mblen_l(s, n, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbbtype.c ===
/***
*mbbtype.c - Return type of byte based on previous byte (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Return type of byte based on previous byte (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>

/***
*int _mbbtype(c, ctype) - Return type of byte based on previous byte (MBCS)
*
*Purpose:
*       Returns type of supplied byte.  This decision is context
*       sensitive so a control test condition is supplied.  Normally,
*       this is the type of the previous byte in the string.
*
*Entry:
*       unsigned char c = character to be checked
*       int ctype = control test condition (i.e., type of previous char)
*
*Exit:
*       _MBC_LEAD      = if 1st byte of MBCS char
*       _MBC_TRAIL     = if 2nd byte of MBCS char
*       _MBC_SINGLE    = valid single byte char
*
*       _MBC_ILLEGAL   = if illegal char
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _mbbtype_l(
        unsigned char c,
        int ctype,
        _locale_t plocinfo
        )
{
        _LocaleUpdate _loc_update(plocinfo);

        switch(ctype) {

            case(_MBC_LEAD):
                if ( _ismbbtrail_l(c, _loc_update.GetLocaleT()) )
                    return(_MBC_TRAIL);
                else
                    return(_MBC_ILLEGAL);

            case(_MBC_TRAIL):
            case(_MBC_SINGLE):
            case(_MBC_ILLEGAL):
            default:
                if ( _ismbblead_l(c, _loc_update.GetLocaleT()) )
                    return(_MBC_LEAD);
                else if (_ismbbprint_l( c, _loc_update.GetLocaleT()))
                    return(_MBC_SINGLE);
                else
                    return(_MBC_ILLEGAL);

        }

}

extern "C" int (__cdecl _mbbtype)(
        unsigned char c,
        int ctype
        )
{
        return( _mbbtype_l(c, ctype, NULL) );
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsbtype.c ===
/***
*mbsbtype.c - Return type of byte within a string (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Return type of byte within a string (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


#define _MBBTYPE(p,c)   _mbbtype(p,c)

/***
* _mbsbtype - Return type of byte within a string
*
*Purpose:
*       Test byte within a string for MBCS char type.
*       This function requires the start of the string because
*       context must be taken into account.
*
*Entry:
*       const unsigned char *string = pointer to string
*       size_t len = position of the char in string
*
*Exit:
*       returns one of the following values:
*
*       _MBC_LEAD      = if 1st byte of MBCS char
*       _MBC_TRAIL     = if 2nd byte of MBCS char
*       _MBC_SINGLE    = valid single byte char
*
*       _MBC_ILLEGAL   = if illegal char
*
*Exceptions:
*       Returns _MBC_ILLEGAL if char is invalid.
*       Calls invalid parameter if len is bigger than string length (and errno is set to EINVAL).
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsbtype_l
(
        const unsigned char *string,
        size_t len,
        _locale_t plocinfo
)
{
        int chartype;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, _MBC_ILLEGAL);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _MBC_SINGLE;

        chartype = _MBC_ILLEGAL;

        do
        {
            /* If the char at the position asked for is a '\0' we return
            _MBC_ILLEGAL. But, If any char before the position asked for is
            a '\0', then we call invalid_param */

            if ((len == 0) && (*string == '\0'))
                return(_MBC_ILLEGAL);

            _VALIDATE_RETURN(*string != '\0', EINVAL, _MBC_ILLEGAL);
            chartype = _mbbtype_l(*string++, chartype, _loc_update.GetLocaleT());
        }  while (len--);

        return(chartype);
}

int (__cdecl _mbsbtype)(
        const unsigned char *string,
        size_t len
        )
{
        return _mbsbtype_l(string, len, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscat_s.inl ===
/***
*mbscat_s.inl - implementation of _mbscat_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the algorithm for _mbscat_s.
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC)
#endif  /* _USE_LOCALE_ARG */
{
    unsigned char *p;
    size_t available;
    BOOL fFoundInvalidMBC, fIsLeadPrefix;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SizeInBytes);
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SizeInBytes);

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return _SB_FUNC_NAME((char *)_DEST, _SizeInBytes, (const char *)_SRC);
    }
#endif  /* _USE_LOCALE_ARG */

    fFoundInvalidMBC = FALSE;
    p = _DEST;
    available = _SizeInBytes;
    while (available > 0 && *p != 0)
    {
        p++;
        available--;
    }

    /*
     * Ran out of room while looking for end of dst string.
     * p points 1 past end of buffer. We can't look past
     * end of buffer so can't tell if dst ended with an
     * invalid mbc.
     */

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SizeInBytes);
    }

    /*
     * Otherwise we have space available, p points at null that lies
     * within _SizeInBytes, so available > 0. Check if dst ended with
     * an invalid MBC (lead+null), if so then clear that lead byte,
     * move the pointer back one and increase available by one.
     */

    _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, p-1);
    if (fIsLeadPrefix)
    {
        fFoundInvalidMBC = TRUE;
        p--;
        *p = 0;
        available++;
    }

    /* Append dst to src. */

    while ((*p++ = *_SRC++) != 0 && --available > 0)
    {
    }

    /*
     * We've run out of room in the destination before finding null in the src.
     * It could be that the src was terminated with an invalid mbc (lead+null).
     * In that case its ok to clear the copied lead byte and return mbcs_error.
     */

    if (available == 0)
    {
        if (*_SRC == 0)
        {
            _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, p-1);
            if (fIsLeadPrefix)
            {
                /* the source string ended with a lead byte: we remove it */
                p[-1] = 0;
                _RETURN_MBCS_ERROR;
            }
        }
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SizeInBytes);
    }

    /*
     * If the src string ended with an invalid mbc (lead+null) then clear the
     * lead byte.
     */

    _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, p-2);
    if (fIsLeadPrefix)
    {
        p[-2] = 0;
        available++;
        fFoundInvalidMBC = TRUE;
    }

    _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);

    if (fFoundInvalidMBC)
    {
        _RETURN_MBCS_ERROR;
    }

    _RETURN_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MALLOC
#define _INC_MALLOC

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Maximum heap request the heap manager will attempt */

#ifdef _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else  /* _WIN64 */
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif  /* _WIN64 */

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif  /* _STATIC_ASSERT */

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif  /* _HEAPINFO_DEFINED */

/* External variable declarations */
#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP unsigned int * __cdecl __p__amblksiz(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */

#if !defined (_M_CEE_PURE)
extern _CRT_INSECURE_DEPRECATE_GLOBALS(_get_amblksiz) unsigned int _amblksiz;
#else  /* !defined (_M_CEE_PURE) */
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_amblksiz) _CRTIMP unsigned int * __cdecl __p__amblksiz(void);
#define _amblksiz (*__p__amblksiz())
#endif  /* !defined (_M_CEE_PURE) */

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("calloc")
#pragma push_macro("free")
#pragma push_macro("malloc")
#pragma push_macro("realloc")
#pragma push_macro("_recalloc")
#pragma push_macro("_aligned_free")
#pragma push_macro("_aligned_malloc")
#pragma push_macro("_aligned_offset_malloc")
#pragma push_macro("_aligned_realloc")
#pragma push_macro("_aligned_recalloc")
#pragma push_macro("_aligned_offset_realloc")
#pragma push_macro("_aligned_offset_recalloc")
#pragma push_macro("_aligned_msize")
#pragma push_macro("_freea")
#undef calloc
#undef free
#undef malloc
#undef realloc
#undef _recalloc
#undef _aligned_free
#undef _aligned_malloc
#undef _aligned_offset_malloc
#undef _aligned_realloc
#undef _aligned_recalloc
#undef _aligned_offset_realloc
#undef _aligned_offset_recalloc
#undef _aligned_msize
#undef _freea
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

#ifndef _CRT_ALLOCATION_DEFINED
#define _CRT_ALLOCATION_DEFINED
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRT_JIT_INTRINSIC _CRTNOALIAS _CRTRESTRICT    void * __cdecl calloc(_In_ size_t _Count, _In_ size_t _Size);
_CRTIMP                     _CRTNOALIAS                                                                             void   __cdecl free(_Inout_opt_ void * _Memory);
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP _CRT_JIT_INTRINSIC _CRTNOALIAS _CRTRESTRICT                              void * __cdecl malloc(_In_ size_t _Size);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP _CRTNOALIAS _CRTRESTRICT                           void * __cdecl realloc(_In_opt_ void * _Memory, _In_ size_t _NewSize);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                       void * __cdecl _recalloc(_In_opt_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size);
_CRTIMP                     _CRTNOALIAS                                                                             void   __cdecl _aligned_free(_Inout_opt_ void * _Memory);
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_malloc(_In_ size_t _Size, _In_ size_t _Alignment);
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_offset_malloc(_In_ size_t _Size, _In_ size_t _Alignment, _In_ size_t _Offset);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_realloc(_In_opt_ void * _Memory, _In_ size_t _NewSize, _In_ size_t _Alignment);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                       void * __cdecl _aligned_recalloc(_In_opt_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size, _In_ size_t _Alignment);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_offset_realloc(_In_opt_ void * _Memory, _In_ size_t _NewSize, _In_ size_t _Alignment, _In_ size_t _Offset);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                       void * __cdecl _aligned_offset_recalloc(_In_opt_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size, _In_ size_t _Alignment, _In_ size_t _Offset);
_Check_return_ _CRTIMP                                                  size_t __cdecl _aligned_msize(_In_ void * _Memory, _In_ size_t _Alignment, _In_ size_t _Offset);
#endif  /* _CRT_ALLOCATION_DEFINED */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("calloc")
#pragma pop_macro("free")
#pragma pop_macro("malloc")
#pragma pop_macro("realloc")
#pragma pop_macro("_recalloc")
#pragma pop_macro("_aligned_free")
#pragma pop_macro("_aligned_malloc")
#pragma pop_macro("_aligned_offset_malloc")
#pragma pop_macro("_aligned_realloc")
#pragma pop_macro("_aligned_recalloc")
#pragma pop_macro("_aligned_offset_realloc")
#pragma pop_macro("_aligned_offset_recalloc")
#pragma pop_macro("_aligned_msize")
#pragma pop_macro("_freea")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_CRTIMP int     __cdecl _resetstkoflw (void);

#define _MAX_WAIT_MALLOC_CRT 60000

_CRTIMP unsigned long __cdecl _set_malloc_crt_max_wait(_In_ unsigned long _NewValue);


#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_expand")
#pragma push_macro("_msize")
#undef _expand
#undef _msize
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP void *  __cdecl _expand(_In_opt_ void * _Memory, _In_ size_t _NewSize);
_Check_return_ _CRTIMP size_t  __cdecl _msize(_In_ void * _Memory);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_expand")
#pragma pop_macro("_msize")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _Ret_bytecap_(_Size) void *          __cdecl _alloca(_In_ size_t _Size);
_Check_return_ _CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(_In_ size_t _NewValue);
_CRTIMP errno_t __cdecl _set_amblksiz(_In_ size_t _Value);
_CRTIMP errno_t __cdecl _get_amblksiz(_Out_ size_t * _Value);
_Check_return_ _CRTIMP int     __cdecl _heapadd(_In_ void * _Memory, _In_ size_t _Size);
_Check_return_ _CRTIMP int     __cdecl _heapchk(void);
_Check_return_ _CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(_In_ unsigned int _Fill);
_CRTIMP _CRT_MANAGED_HEAP_DEPRECATE int     __cdecl _heapwalk(_Inout_ _HEAPINFO * _EntryInfo);
_CRTIMP size_t  __cdecl _heapused(size_t * _Used, size_t * _Commit);

_CRTIMP intptr_t __cdecl _get_heap_handle(void);

#define _ALLOCA_S_THRESHOLD     1024
#define _ALLOCA_S_STACK_MARKER  0xCCCC
#define _ALLOCA_S_HEAP_MARKER   0xDDDD

#if defined (_M_IX86)
#define _ALLOCA_S_MARKER_SIZE   8
#elif defined (_M_IA64)
#define _ALLOCA_S_MARKER_SIZE   16
#elif defined (_M_AMD64)
#define _ALLOCA_S_MARKER_SIZE   16
#endif  /* defined (_M_AMD64) */

_STATIC_ASSERT(sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE);

#if !defined (__midl) && !defined (RC_INVOKED)
#pragma warning(push)
#pragma warning(disable:6540)
__inline void *_MarkAllocaS(_Out_opt_ __crt_typefix(unsigned int*) void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;
    }
    return _Ptr;
}
#pragma warning(pop)
#endif  /* !defined (__midl) && !defined (RC_INVOKED) */

#if defined (_DEBUG)
#if !defined (_CRTDBG_MAP_ALLOC)
#undef _malloca
#define _malloca(size) \
__pragma(warning(suppress: 6255)) \
        _MarkAllocaS(malloc((size) + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_HEAP_MARKER)
#endif  /* !defined (_CRTDBG_MAP_ALLOC) */
#else  /* defined (_DEBUG) */
#undef _malloca
#define _malloca(size) \
__pragma(warning(suppress: 6255)) \
    ((((size) + _ALLOCA_S_MARKER_SIZE) <= _ALLOCA_S_THRESHOLD) ? \
        _MarkAllocaS(_alloca((size) + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_STACK_MARKER) : \
        _MarkAllocaS(malloc((size) + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_HEAP_MARKER))
#endif  /* defined (_DEBUG) */

#undef _FREEA_INLINE
#ifndef _INTERNAL_IFSTRIP_
#ifndef _CRT_NOFREEA
#define _FREEA_INLINE
#else  /* _CRT_NOFREEA */
#undef _FREEA_INLINE
#endif  /* _CRT_NOFREEA */
#else  /* _INTERNAL_IFSTRIP_ */
#define _FREEA_INLINE
#endif  /* _INTERNAL_IFSTRIP_ */

#ifdef _FREEA_INLINE
/* _freea must be in the header so that its allocator matches _malloca */
#if !defined (__midl) && !defined (RC_INVOKED)
#undef _freea
_CRTNOALIAS __inline void __CRTDECL _freea(_Inout_opt_ void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - _ALLOCA_S_MARKER_SIZE;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == _ALLOCA_S_HEAP_MARKER)
        {
            free(_Memory);
        }
#if defined (_ASSERTE)
        else if (_Marker != _ALLOCA_S_STACK_MARKER)
        {
            _ASSERTE(("Corrupted pointer passed to _freea", 0));
        }
#endif  /* defined (_ASSERTE) */
    }
}
#endif  /* !defined (__midl) && !defined (RC_INVOKED) */
#endif  /* _FREEA_INLINE */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* !__STDC__ */




#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscat_s_l.c ===
/***
*mbscat_s_l.c - Concatenate one string to another (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Concatenate one string to another (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbscat_s_l
#define _SB_FUNC_NAME strcat_s
#define _DEST _Dst
#define _SRC _Src

#include <mbscat_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbctype.c ===
/***
*mbctype.c - MBCS table used by the functions that test for types of char
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       table used to determine the type of char
*
*******************************************************************************/

#ifdef _MBCS

#include <windows.h>
#include <sect_attribs.h>
#include <cruntime.h>
#include <dbgint.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mtdll.h>
#include <stdlib.h>
#include <stdio.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <rterr.h>

#ifndef CRTDLL

extern "C" int __cdecl __initmbctable(void);
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern "C" int __mbctype_initialized;

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __initmbctable;

#endif  /* CRTDLL */

#define _CHINESE_SIMP_CP    936
#define _KOREAN_WANGSUNG_CP 949
#define _CHINESE_TRAD_CP    950
#define _KOREAN_JOHAB_CP    1361

#define NUM_CHARS 257 /* -1 through 255 */

#define NUM_CTYPES 4 /* table contains 4 types of info */
#define MAX_RANGES 8 /* max number of ranges needed given languages so far */

/* character type info in ranges (pair of low/high), zeros indicate end */
typedef struct
{
    int             code_page;
    unsigned short  mbulinfo[NUM_ULINFO];
    unsigned char   rgrange[NUM_CTYPES][MAX_RANGES];
} code_page_info;

extern "C"
{
threadmbcinfo __initialmbcinfo =
{
    0,
    _CLOCALECP, /* _MB_CP_ANSI */
    0,
    0,
    { 0, 0, 0, 0, 0, 0 },
    {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00 /* rest is zero */
    },
    {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00 /* rest is zero */
    }
};

/* MBCS ctype array */
unsigned char _mbctype[NUM_CHARS] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00 /* rest is zero */
};
unsigned char _mbcasemap[256] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00 /* rest is zero */
};

/* global variable to indicate current code page */
int __mbcodepage = _CLOCALECP; /* __initialmbcinfo.mbcodepage; */

/* global flag indicating if current code page is a multibyte code page */
int __ismbcodepage = 0; /*__initialmbcinfo.ismbcodepage; */

/* global variable to indicate current LCID */
int __mblcid = 0; /* __initialmbcinfo.mblcid; */

/* global variable to indicate current full-width-latin upper/lower info */
unsigned short __mbulinfo[NUM_ULINFO]; /* __initialmbcinfo.mbulinfo */

/* global pointer to the current per-thread mbc information structure. */
pthreadmbcinfo __ptmbcinfo = &__initialmbcinfo;
}

static int fSystemSet;

static char __rgctypeflag[NUM_CTYPES] = { _MS, _MP, _M1, _M2 };

static code_page_info __rgcode_page_info[] =
{
    {
      _KANJI_CP, /* Kanji (Japanese) Code Page */
      { 0x8260, 0x8279,   /* Full-Width Latin Upper Range 1 */
        0x8281 - 0x8260,  /* Full-Width Latin Case Difference 1 */

        0x0000, 0x0000,   /* Full-Width Latin Upper Range 2 */
        0x0000            /* Full-Width Latin Case Difference 2 */
#ifndef _WIN32
        ,
        0x8281, 0x829A,   /* Full-Width Latin Lower Range 1 */

        0x0000, 0x0000,   /* Full-Width Latin Lower Range 2 */

        0x824F, 0x8258    /* Full-Width Latin Digit Range */
#endif  /* _WIN32 */
      },
      {
        { 0xA6, 0xDF, 0,    0,    0,    0,    0, 0, }, /* Single Byte Ranges */
        { 0xA1, 0xA5, 0,    0,    0,    0,    0, 0, }, /* Punctuation Ranges */
        { 0x81, 0x9F, 0xE0, 0xFC, 0,    0,    0, 0, }, /* Lead Byte Ranges */
        { 0x40, 0x7E, 0x80, 0xFC, 0,    0,    0, 0, }, /* Trail Byte Ranges */
      }
    },
    {
      _CHINESE_SIMP_CP, /* Chinese Simplified (PRC) Code Page */
      { 0xA3C1, 0xA3DA,   /* Full-Width Latin Upper Range 1 */
        0xA3E1 - 0xA3C1,  /* Full-Width Latin Case Difference 1 */

        0x0000, 0x0000,   /* Full-Width Latin Upper Range 2 */
        0x0000            /* Full-Width Latin Case Difference 2 */
#ifndef _WIN32
        ,
        0xA3E1, 0xA3FA,   /* Full-Width Latin Lower Range 1 */

        0x0000, 0x0000,   /* Full-Width Latin Lower Range 2 */

        0xA3B0, 0xA3B9    /* Full-Width Latin Digit Range */
#endif  /* _WIN32 */
      },
      {
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Single Byte Ranges */
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Punctuation Ranges */
        { 0x81, 0xFE, 0,    0,    0,    0,    0, 0, }, /* Lead Byte Ranges */
        { 0x40, 0xFE, 0,    0,    0,    0,    0, 0, }, /* Trail Byte Ranges */
      }
    },
    {
      _KOREAN_WANGSUNG_CP, /* Wangsung (Korean) Code Page */
      { 0xA3C1, 0xA3DA,   /* Full-Width Latin Upper Range 1 */
        0xA3E1 - 0xA3C1,  /* Full-Width Latin Case Difference 1 */

        0x0000, 0x0000,   /* Full-Width Latin Upper Range 2 */
        0x0000            /* Full-Width Latin Case Difference 2 */
#ifndef _WIN32
        ,
        0xA3E1, 0xA3FA,   /* Full-Width Latin Lower Range 1 */

        0x0000, 0x0000,   /* Full-Width Latin Lower Range 2 */

        0xA3B0, 0xA3B9    /* Full-Width Latin Digit Range */
#endif  /* _WIN32 */
      },
      {
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Single Byte Ranges */
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Punctuation Ranges */
        { 0x81, 0xFE, 0,    0,    0,    0,    0, 0, }, /* Lead Byte Ranges */
        { 0x41, 0xFE, 0,    0,    0,    0,    0, 0, }, /* Trail Byte Ranges */
      }
    },
    {
      _CHINESE_TRAD_CP, /* Chinese Traditional (Taiwan) Code Page */
      { 0xA2CF, 0xA2E4,   /* Full-Width Latin Upper Range 1 */
        0xA2E9 - 0xA2CF,  /* Full-Width Latin Case Difference 1 */

        0xA2E5, 0xA2E8,   /* Full-Width Latin Upper Range 2 */
        0xA340 - 0XA2E5   /* Full-Width Latin Case Difference 2 */
#ifndef _WIN32
        ,
        0xA2E9, 0xA2FE,   /* Full-Width Latin Lower Range 1 */

        0xA340, 0xA343,   /* Full-Width Latin Lower Range 2 */

        0xA2AF, 0xA2B8    /* Full-Width Latin Digit Range */
#endif  /* _WIN32 */
      },
      {
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Single Byte Ranges */
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Punctuation Ranges */
        { 0x81, 0xFE, 0,    0,    0,    0,    0, 0, }, /* Lead Byte Ranges */
        { 0x40, 0x7E, 0xA1, 0xFE, 0,    0,    0, 0, }, /* Trail Byte Ranges */
      }
    },
    {
      _KOREAN_JOHAB_CP, /* Johab (Korean) Code Page */
      { 0xDA51, 0xDA5E,   /* Full-Width Latin Upper Range 1 */
        0xDA71 - 0xDA51,  /* Full-Width Latin Case Difference 1 */

        0xDA5F, 0xDA6A,   /* Full-Width Latin Upper Range 2 */
        0xDA91 - 0xDA5F   /* Full-Width Latin Case Difference 2 */
#ifndef _WIN32
        ,
        0xDA71, 0xDA7E,   /* Full-Width Latin Lower Range 1 */

        0xDA91, 0xDA9C,   /* Full-Width Latin Lower Range 2 */

        0xDA40, 0xDA49    /* Full-Width Latin Digit Range */
#endif  /* _WIN32 */
      },
      {
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Single Byte Ranges */
        { 0,    0,    0,    0,    0,    0,    0, 0, }, /* Punctuation Ranges */
        { 0x81, 0xD3, 0xD8, 0xDE, 0xE0, 0xF9, 0, 0, }, /* Lead Byte Ranges */
        { 0x31, 0x7E, 0x81, 0xFE, 0,    0,    0, 0, }, /* Trail Byte Ranges */
      }
    }
};

extern "C" int __cdecl _setmbcp_nolock(int, pthreadmbcinfo);

/***
*getSystemCP - Get system default CP if requested.
*
*Purpose:
*       Get system default CP if requested.
*
*Entry:
*       codepage - user requested code page/world script
*Exit:
*       requested code page
*
*Exceptions:
*
*******************************************************************************/

static int getSystemCP (int codepage)
{
    _locale_t plocinfo = NULL;
    _LocaleUpdate _loc_update(plocinfo);
    fSystemSet = 0;

    /* get system code page values if requested */

    if (codepage == _MB_CP_OEM)
    {
        fSystemSet = 1;
        return GetOEMCP();
    }

    else if (codepage == _MB_CP_ANSI)
    {
        fSystemSet = 1;
        return GetACP();
    }

    else
    if (codepage == _MB_CP_LOCALE)
    {
        fSystemSet = 1;
        return __LC_CODEPAGE(_loc_update.GetLocaleT()->locinfo);
    }

    return codepage;
}


/***
*CPtoLCID() - Code page to LCID.
*
*Purpose:
*       Some API calls want an LCID, so convert MB CP to appropriate LCID,
*       and then API converts back to ANSI CP for that LCID.
*
*Entry:
*   codepage - code page to convert
*Exit:
*       returns appropriate LCID
*
*Exceptions:
*
*******************************************************************************/

static int CPtoLCID (int codepage)
{
    switch (codepage) {
    case 932:
        return MAKELCID(MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT),
                        SORT_DEFAULT);
    case 936:
        return MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),
                        SORT_DEFAULT);
    case 949:
        return MAKELCID(MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT),
                        SORT_DEFAULT);
    case 950:
        return MAKELCID(MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL),
                        SORT_DEFAULT);
    }

    return 0;
}


/***
*setSBCS() - Set MB code page to SBCS.
*
*Purpose:
*           Set MB code page to SBCS.
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static void setSBCS (pthreadmbcinfo ptmbci)
{
    int i;

    /* set for single-byte code page */
    for (i = 0; i < NUM_CHARS; i++)
        ptmbci->mbctype[i] = 0;

    /* code page has changed, set global flag */
    ptmbci->mbcodepage = 0;

    /* clear flag to indicate single-byte code */
    ptmbci->ismbcodepage = 0;

    ptmbci->mblcid = 0;

    for (i = 0; i < NUM_ULINFO; i++)
        ptmbci->mbulinfo[i] = 0;

    for ( i = 0 ; i < 257 ; i++ )
        ptmbci->mbctype[i] = __initialmbcinfo.mbctype[i];

    for ( i = 0 ; i < 256 ; i++ )
        ptmbci->mbcasemap[i] = __initialmbcinfo.mbcasemap[i];
}

/***
*setSBUpLow() - Set single byte upper/lower mappings
*
*Purpose:
*           Set single byte mapping for tolower/toupper.
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static void setSBUpLow (pthreadmbcinfo ptmbci)
{
    BYTE *  pbPair;
    UINT    ich;
    CPINFO  cpinfo;
    UCHAR   sbVector[256];
    UCHAR   upVector[256];
    UCHAR   lowVector[256];
    USHORT  wVector[256];

    //    test if codepage exists
    if (GetCPInfo(ptmbci->mbcodepage, &cpinfo) != 0)
    {
        //  if so, create vector 0-255
        for (ich = 0; ich < 256; ich++)
            sbVector[ich] = (UCHAR) ich;

        //  set byte 0 and any leading byte value to non-alpha char ' '
        sbVector[0] = (UCHAR)' ';
        for (pbPair = &cpinfo.LeadByte[0]; *pbPair; pbPair += 2)
            for (ich = *pbPair; ich <= *(pbPair + 1); ich++)
                sbVector[ich] = (UCHAR)' ';

        //  get char type for character vector

        __crtGetStringTypeA(NULL, CT_CTYPE1, (LPCSTR)sbVector, 256, wVector,
                            ptmbci->mbcodepage, ptmbci->mblcid, FALSE);

        //  get lower case mappings for character vector

        __crtLCMapStringA(NULL, ptmbci->mblcid, LCMAP_LOWERCASE, (LPCSTR)sbVector, 256,
                                    (LPSTR)lowVector, 256, ptmbci->mbcodepage, FALSE);

        //  get upper case mappings for character vector

        __crtLCMapStringA(NULL, ptmbci->mblcid, LCMAP_UPPERCASE, (LPCSTR)sbVector, 256,
                                    (LPSTR)upVector, 256, ptmbci->mbcodepage, FALSE);

        //  set _SBUP, _SBLOW in ptmbci->mbctype if type is upper. lower
        //  set mapping array with lower or upper mapping value

        for (ich = 0; ich < 256; ich++)
            if (wVector[ich] & _UPPER)
            {
                ptmbci->mbctype[ich + 1] |= _SBUP;
                ptmbci->mbcasemap[ich] = lowVector[ich];
            }
            else if (wVector[ich] & _LOWER)
            {
                ptmbci->mbctype[ich + 1] |= _SBLOW;
                ptmbci->mbcasemap[ich] = upVector[ich];
            }
            else
                ptmbci->mbcasemap[ich] = 0;
    }
    else
    {
        //  if no codepage, set 'A'-'Z' as upper, 'a'-'z' as lower

        for (ich = 0; ich < 256; ich++)
            if (ich >= (UINT)'A' && ich <= (UINT)'Z')
            {
                ptmbci->mbctype[ich + 1] |= _SBUP;
                ptmbci->mbcasemap[ich] = ich + ('a' - 'A');
            }
            else if (ich >= (UINT)'a' && ich <= (UINT)'z')
            {
                ptmbci->mbctype[ich + 1] |= _SBLOW;
                ptmbci->mbcasemap[ich] = ich - ('a' - 'A');
            }
            else
                ptmbci->mbcasemap[ich] = 0;
    }
}


/***
*__updatetmbcinfo() - refresh the thread's mbc info
*
*Purpose:
*       Update the current thread's reference to the multibyte character
*       information to match the current global mbc info. Decrement the
*       reference on the old mbc information struct and if this count is now
*       zero (so that no threads are using it), free it.
*
*Entry:
*
*Exit:
*       _getptd()->ptmbcinfo == __ptmbcinfo
*
*Exceptions:
*
*******************************************************************************/

extern "C" pthreadmbcinfo __cdecl __updatetmbcinfo(void)
{
        pthreadmbcinfo ptmbci;

        _ptiddata ptd = _getptd();
        if (!(ptd->_ownlocale & __globallocalestatus)|| !ptd->ptlocinfo) {
        _mlock(_MB_CP_LOCK);

        __try
        {

            if ( (ptmbci = ptd->ptmbcinfo) != __ptmbcinfo )
            {
                /*
                 * Decrement the reference count in the old mbc info structure
                 * and free it, if necessary
                 */
                    if ( (ptmbci != NULL) && (InterlockedDecrement((volatile LONG *)&(ptmbci->refcount)) == 0) && ptmbci != &__initialmbcinfo )
                {
                    /*
                     * Free it
                     */
                    _free_crt(ptmbci);
                }

                /*
                 * Point to the current mbc info structure and increment its
                 * reference count.
                 */
                ptmbci = ptd->ptmbcinfo = __ptmbcinfo;
                    InterlockedIncrement((volatile LONG *)&(ptmbci->refcount));
            }
        }
        __finally
        {
            _munlock(_MB_CP_LOCK);
        }
        } else {
            ptmbci = ptd->ptmbcinfo;
        }

        if(!ptmbci)
        {
            _amsg_exit(_RT_LOCALE);
        }

        return ptmbci;
}


/***
*_setmbcp() - Set MBC data based on code page
*
*Purpose:
*       Init MBC character type tables based on code page number. If
*       given code page is supported, load that code page info into
*       mbctype table. If not, query OS to find the information,
*       otherwise set up table with single byte info.
*
*       Multithread Notes: First, allocate an mbc information struct. Set the
*       mbc info in the static vars and arrays as does the single-thread
*       version. Then, copy this info into the new allocated struct and set
*       the current mbc info pointer (__ptmbcinfo) to point to it.
*
*Entry:
*       codepage - code page to initialize MBC table
*           _MB_CP_OEM = use system OEM code page
*           _MB_CP_ANSI = use system ANSI code page
*           _MB_CP_SBCS = set to single byte 'code page'
*
*Exit:
*        0 = Success
*       -1 = Error, code page not changed.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _setmbcp (int codepage)
{
    int retcode = -1;           /* initialize to failure */
    pthreadmbcinfo ptmbci;
    int i;

    _ptiddata ptd = _getptd();

    __updatetmbcinfo();
    ptmbci = ptd->ptmbcinfo;


    codepage = getSystemCP(codepage);

    if ( codepage != ptmbci->mbcodepage )
    {
        /*
         * Always allocate space so that we don't have to take lock
         * for any update.
         */
        ptmbci = (pthreadmbcinfo)_malloc_crt( sizeof(threadmbcinfo) );

        if (ptmbci != NULL)
        {
            *ptmbci = *(ptd->ptmbcinfo);
            /*
             * Note that refcount for this structure is just one so
             * update the refcount.
             */
            /*
             * Note that the refcount is set to zero because we don't count this
             * refcount as we won't be calling InterlockedDecrement for this when
             * the variable goes out of scope.
             */
            ptmbci->refcount = 0;

            /*
             * Install the codepage and copy the info into the struct
             */
            if ( (retcode = _setmbcp_nolock(codepage, ptmbci)) == 0)
            {
                if (InterlockedDecrement((volatile LONG *)&ptd->ptmbcinfo->refcount) == 0 && ptd->ptmbcinfo != &__initialmbcinfo)
                    _free_crt(ptd->ptmbcinfo);
                /*
                 * Assign and increment the refcount of this structure.
                 */
                ptd->ptmbcinfo = ptmbci;
                InterlockedIncrement((volatile LONG *)&(ptd->ptmbcinfo->refcount));
                if (!(ptd->_ownlocale & _PER_THREAD_LOCALE_BIT) &&
                        !(__globallocalestatus & _GLOBAL_LOCALE_BIT)) {

                    _mlock(_MB_CP_LOCK);
                    __try
                    {
                        /*
                         * Fill in the mbc info struct
                         */
                        __mbcodepage = ptmbci->mbcodepage;
                        __ismbcodepage = ptmbci->ismbcodepage;
                        __mblcid = ptmbci->mblcid;
                        for ( i = 0 ; i < 5 ; i++ )
                            __mbulinfo[i] = ptmbci->mbulinfo[i];
                        for ( i = 0 ; i < 257 ; i++ )
                            _mbctype[i] = ptmbci->mbctype[i];
                        for ( i = 0 ; i < 256 ; i++ )
                            _mbcasemap[i] = ptmbci->mbcasemap[i];

                        if (InterlockedDecrement((volatile LONG *)&__ptmbcinfo->refcount) == 0 && __ptmbcinfo != &__initialmbcinfo)
                            _free_crt(__ptmbcinfo);
                        /*
                         * Update __ptmbcinfo
                         */
                        __ptmbcinfo = ptmbci;
                        InterlockedIncrement((volatile LONG *)&ptmbci->refcount);
                    }
                    __finally
                    {
                        _munlock(_MB_CP_LOCK);
                    }
                }
            }
            else if (retcode == -1)
            {
                /*
                 * Free up the newly malloc-ed struct (note: a free of
                 * NULL is legal)
                 */
                if (ptmbci != &__initialmbcinfo)
                    _free_crt(ptmbci);
                errno = EINVAL;
                /* note that if malloc fails, it sets errno to ENOMEM already */
            }
        }

    }
    else
        /*
         * Not a new codepage after all. Nothing to do but return
         * success.
         */
        retcode = 0;

#pragma warning(disable:4390)
    if ( (retcode == -1) && (__ptmbcinfo == NULL) )
        /*
         * Fatal error!
         */
        ;

    return retcode;
}

extern "C" int __cdecl _setmbcp_nolock(int codepage, pthreadmbcinfo ptmbci)
{
        unsigned int icp;
        unsigned int irg;
        unsigned int ich;
        unsigned char *rgptr;
        CPINFO cpinfo;

        codepage = getSystemCP(codepage);

        /* user wants 'single-byte' MB code page */
        if (codepage == _MB_CP_SBCS)
        {
            setSBCS(ptmbci);
            return 0;
        }

        /* check for CRT code page info */
        for (icp = 0;
            icp < (sizeof(__rgcode_page_info) / sizeof(code_page_info));
            icp++)
        {
            /* see if we have info for this code page */
            if (__rgcode_page_info[icp].code_page == codepage)
            {
                /* clear the table */
                for (ich = 0; ich < NUM_CHARS; ich++)
                    ptmbci->mbctype[ich] = 0;

                /* for each type of info, load table */
                for (irg = 0; irg < NUM_CTYPES; irg++)
                {
                    /* go through all the ranges for each type of info */
                    for (rgptr = (unsigned char *)__rgcode_page_info[icp].rgrange[irg];
                        rgptr[0] && rgptr[1];
                        rgptr += 2)
                    {
                        /* set the type for every character in range */
                        for (ich = rgptr[0]; ich <= rgptr[1]; ich++)
                            ptmbci->mbctype[ich + 1] |= __rgctypeflag[irg];
                    }
                }
                /* code page has changed */
                ptmbci->mbcodepage = codepage;
                /* all the code pages we keep info for are truly multibyte */
                ptmbci->ismbcodepage = 1;
                ptmbci->mblcid = CPtoLCID(ptmbci->mbcodepage);
                for (irg = 0; irg < NUM_ULINFO; irg++)
                    ptmbci->mbulinfo[irg] = __rgcode_page_info[icp].mbulinfo[irg];

                /* return success */
                setSBUpLow(ptmbci);
                return 0;
            }
        }

        /*  verify codepage validity */
        if (codepage == 0 || codepage == CP_UTF7 || codepage == CP_UTF8 ||
            !IsValidCodePage((WORD)codepage))
        {
            /* return failure, code page not changed */
            return -1;
        }


        /* code page not supported by CRT, try the OS */
        if (GetCPInfo(codepage, &cpinfo) != 0) {
            BYTE *lbptr;

            /* clear the table */
            for (ich = 0; ich < NUM_CHARS; ich++)
                ptmbci->mbctype[ich] = 0;

            ptmbci->mbcodepage = codepage;
            ptmbci->mblcid = 0;

            if (cpinfo.MaxCharSize > 1)
            {
                /* LeadByte range always terminated by two 0's */
                for (lbptr = cpinfo.LeadByte; *lbptr && *(lbptr + 1); lbptr += 2)
                {
                    for (ich = *lbptr; ich <= *(lbptr + 1); ich++)
                        ptmbci->mbctype[ich + 1] |= _M1;
                }

                /* All chars > 1 must be considered valid trail bytes */
                for (ich = 0x01; ich < 0xFF; ich++)
                    ptmbci->mbctype[ich + 1] |= _M2;

                /* code page has changed */
                ptmbci->mblcid = CPtoLCID(ptmbci->mbcodepage);

                /* really a multibyte code page */
                ptmbci->ismbcodepage = 1;
            }
            else
                /* single-byte code page */
                ptmbci->ismbcodepage = 0;

            for (irg = 0; irg < NUM_ULINFO; irg++)
                ptmbci->mbulinfo[irg] = 0;

            setSBUpLow(ptmbci);
            /* return success */
            return 0;
        }


        /* If system default call, don't fail - set to SBCS */
        if (fSystemSet)
        {
            setSBCS(ptmbci);
            return 0;
        }

        /* return failure, code page not changed */
        return -1;
}

/***
*_getmbcp() - Get the current MBC code page
*
*Purpose:
*           Get code page value.
*Entry:
*       none.
*Exit:
*           return current MB codepage value.
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _getmbcp (void)
{
    _locale_t plocinfo = NULL;
    _LocaleUpdate _loc_update(plocinfo);
    if ( _loc_update.GetLocaleT()->mbcinfo->ismbcodepage )
        return _loc_update.GetLocaleT()->mbcinfo->mbcodepage;
    else
        return 0;
}


/***
*_initmbctable() - Set MB ctype table to initial default value.
*
*Purpose:
*       Initialization.
*Entry:
*       none.
*Exit:
*       Returns 0 to indicate no error.
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl __initmbctable (void)
{
#ifdef CRTDLL

        _setmbcp(_MB_CP_ANSI);

#else  /* CRTDLL */

        /*
         * Ensure we only initialize _mbctype[] once
         */
        if ( __mbctype_initialized == 0 ) {
            _setmbcp(_MB_CP_ANSI);
            __mbctype_initialized = 1;
        }

#endif  /* CRTDLL */

        return 0;
}

#endif  /* _MBCS */


/************************ Code Page info from NT/Win95 ********************


*** Code Page 932 ***

0x824f  ;Fullwidth Digit Zero
0x8250  ;Fullwidth Digit One
0x8251  ;Fullwidth Digit Two
0x8252  ;Fullwidth Digit Three
0x8253  ;Fullwidth Digit Four
0x8254  ;Fullwidth Digit Five
0x8255  ;Fullwidth Digit Six
0x8256  ;Fullwidth Digit Seven
0x8257  ;Fullwidth Digit Eight
0x8258  ;Fullwidth Digit Nine

0x8281  0x8260  ;Fullwidth Small A -> Fullwidth Capital A
0x8282  0x8261  ;Fullwidth Small B -> Fullwidth Capital B
0x8283  0x8262  ;Fullwidth Small C -> Fullwidth Capital C
0x8284  0x8263  ;Fullwidth Small D -> Fullwidth Capital D
0x8285  0x8264  ;Fullwidth Small E -> Fullwidth Capital E
0x8286  0x8265  ;Fullwidth Small F -> Fullwidth Capital F
0x8287  0x8266  ;Fullwidth Small G -> Fullwidth Capital G
0x8288  0x8267  ;Fullwidth Small H -> Fullwidth Capital H
0x8289  0x8268  ;Fullwidth Small I -> Fullwidth Capital I
0x828a  0x8269  ;Fullwidth Small J -> Fullwidth Capital J
0x828b  0x826a  ;Fullwidth Small K -> Fullwidth Capital K
0x828c  0x826b  ;Fullwidth Small L -> Fullwidth Capital L
0x828d  0x826c  ;Fullwidth Small M -> Fullwidth Capital M
0x828e  0x826d  ;Fullwidth Small N -> Fullwidth Capital N
0x828f  0x826e  ;Fullwidth Small O -> Fullwidth Capital O
0x8290  0x826f  ;Fullwidth Small P -> Fullwidth Capital P
0x8291  0x8270  ;Fullwidth Small Q -> Fullwidth Capital Q
0x8292  0x8271  ;Fullwidth Small R -> Fullwidth Capital R
0x8293  0x8272  ;Fullwidth Small S -> Fullwidth Capital S
0x8294  0x8273  ;Fullwidth Small T -> Fullwidth Capital T
0x8295  0x8274  ;Fullwidth Small U -> Fullwidth Capital U
0x8296  0x8275  ;Fullwidth Small V -> Fullwidth Capital V
0x8297  0x8276  ;Fullwidth Small W -> Fullwidth Capital W
0x8298  0x8277  ;Fullwidth Small X -> Fullwidth Capital X
0x8299  0x8278  ;Fullwidth Small Y -> Fullwidth Capital Y
0x829a  0x8279  ;Fullwidth Small Z -> Fullwidth Capital Z


*** Code Page 936 ***

0xa3b0  ;Fullwidth Digit Zero
0xa3b1  ;Fullwidth Digit One
0xa3b2  ;Fullwidth Digit Two
0xa3b3  ;Fullwidth Digit Three
0xa3b4  ;Fullwidth Digit Four
0xa3b5  ;Fullwidth Digit Five
0xa3b6  ;Fullwidth Digit Six
0xa3b7  ;Fullwidth Digit Seven
0xa3b8  ;Fullwidth Digit Eight
0xa3b9  ;Fullwidth Digit Nine

0xa3e1  0xa3c1  ;Fullwidth Small A -> Fullwidth Capital A
0xa3e2  0xa3c2  ;Fullwidth Small B -> Fullwidth Capital B
0xa3e3  0xa3c3  ;Fullwidth Small C -> Fullwidth Capital C
0xa3e4  0xa3c4  ;Fullwidth Small D -> Fullwidth Capital D
0xa3e5  0xa3c5  ;Fullwidth Small E -> Fullwidth Capital E
0xa3e6  0xa3c6  ;Fullwidth Small F -> Fullwidth Capital F
0xa3e7  0xa3c7  ;Fullwidth Small G -> Fullwidth Capital G
0xa3e8  0xa3c8  ;Fullwidth Small H -> Fullwidth Capital H
0xa3e9  0xa3c9  ;Fullwidth Small I -> Fullwidth Capital I
0xa3ea  0xa3ca  ;Fullwidth Small J -> Fullwidth Capital J
0xa3eb  0xa3cb  ;Fullwidth Small K -> Fullwidth Capital K
0xa3ec  0xa3cc  ;Fullwidth Small L -> Fullwidth Capital L
0xa3ed  0xa3cd  ;Fullwidth Small M -> Fullwidth Capital M
0xa3ee  0xa3ce  ;Fullwidth Small N -> Fullwidth Capital N
0xa3ef  0xa3cf  ;Fullwidth Small O -> Fullwidth Capital O
0xa3f0  0xa3d0  ;Fullwidth Small P -> Fullwidth Capital P
0xa3f1  0xa3d1  ;Fullwidth Small Q -> Fullwidth Capital Q
0xa3f2  0xa3d2  ;Fullwidth Small R -> Fullwidth Capital R
0xa3f3  0xa3d3  ;Fullwidth Small S -> Fullwidth Capital S
0xa3f4  0xa3d4  ;Fullwidth Small T -> Fullwidth Capital T
0xa3f5  0xa3d5  ;Fullwidth Small U -> Fullwidth Capital U
0xa3f6  0xa3d6  ;Fullwidth Small V -> Fullwidth Capital V
0xa3f7  0xa3d7  ;Fullwidth Small W -> Fullwidth Capital W
0xa3f8  0xa3d8  ;Fullwidth Small X -> Fullwidth Capital X
0xa3f9  0xa3d9  ;Fullwidth Small Y -> Fullwidth Capital Y
0xa3fa  0xa3da  ;Fullwidth Small Z -> Fullwidth Capital Z


*** Code Page 949 ***

0xa3b0  ;Fullwidth Digit Zero
0xa3b1  ;Fullwidth Digit One
0xa3b2  ;Fullwidth Digit Two
0xa3b3  ;Fullwidth Digit Three
0xa3b4  ;Fullwidth Digit Four
0xa3b5  ;Fullwidth Digit Five
0xa3b6  ;Fullwidth Digit Six
0xa3b7  ;Fullwidth Digit Seven
0xa3b8  ;Fullwidth Digit Eight
0xa3b9  ;Fullwidth Digit Nine

0xa3e1  0xa3c1  ;Fullwidth Small A -> Fullwidth Capital A
0xa3e2  0xa3c2  ;Fullwidth Small B -> Fullwidth Capital B
0xa3e3  0xa3c3  ;Fullwidth Small C -> Fullwidth Capital C
0xa3e4  0xa3c4  ;Fullwidth Small D -> Fullwidth Capital D
0xa3e5  0xa3c5  ;Fullwidth Small E -> Fullwidth Capital E
0xa3e6  0xa3c6  ;Fullwidth Small F -> Fullwidth Capital F
0xa3e7  0xa3c7  ;Fullwidth Small G -> Fullwidth Capital G
0xa3e8  0xa3c8  ;Fullwidth Small H -> Fullwidth Capital H
0xa3e9  0xa3c9  ;Fullwidth Small I -> Fullwidth Capital I
0xa3ea  0xa3ca  ;Fullwidth Small J -> Fullwidth Capital J
0xa3eb  0xa3cb  ;Fullwidth Small K -> Fullwidth Capital K
0xa3ec  0xa3cc  ;Fullwidth Small L -> Fullwidth Capital L
0xa3ed  0xa3cd  ;Fullwidth Small M -> Fullwidth Capital M
0xa3ee  0xa3ce  ;Fullwidth Small N -> Fullwidth Capital N
0xa3ef  0xa3cf  ;Fullwidth Small O -> Fullwidth Capital O
0xa3f0  0xa3d0  ;Fullwidth Small P -> Fullwidth Capital P
0xa3f1  0xa3d1  ;Fullwidth Small Q -> Fullwidth Capital Q
0xa3f2  0xa3d2  ;Fullwidth Small R -> Fullwidth Capital R
0xa3f3  0xa3d3  ;Fullwidth Small S -> Fullwidth Capital S
0xa3f4  0xa3d4  ;Fullwidth Small T -> Fullwidth Capital T
0xa3f5  0xa3d5  ;Fullwidth Small U -> Fullwidth Capital U
0xa3f6  0xa3d6  ;Fullwidth Small V -> Fullwidth Capital V
0xa3f7  0xa3d7  ;Fullwidth Small W -> Fullwidth Capital W
0xa3f8  0xa3d8  ;Fullwidth Small X -> Fullwidth Capital X
0xa3f9  0xa3d9  ;Fullwidth Small Y -> Fullwidth Capital Y
0xa3fa  0xa3da  ;Fullwidth Small Z -> Fullwidth Capital Z


*** Code Page 950 ***

0xa2af  ;Fullwidth Digit Zero
0xa2b0  ;Fullwidth Digit One
0xa2b1  ;Fullwidth Digit Two
0xa2b2  ;Fullwidth Digit Three
0xa2b3  ;Fullwidth Digit Four
0xa2b4  ;Fullwidth Digit Five
0xa2b5  ;Fullwidth Digit Six
0xa2b6  ;Fullwidth Digit Seven
0xa2b7  ;Fullwidth Digit Eight
0xa2b8  ;Fullwidth Digit Nine

0xa2e9  0xa2cf  ;Fullwidth Small A -> Fullwidth Capital A
0xa2ea  0xa2d0  ;Fullwidth Small B -> Fullwidth Capital B
0xa2eb  0xa2d1  ;Fullwidth Small C -> Fullwidth Capital C
0xa2ec  0xa2d2  ;Fullwidth Small D -> Fullwidth Capital D
0xa2ed  0xa2d3  ;Fullwidth Small E -> Fullwidth Capital E
0xa2ee  0xa2d4  ;Fullwidth Small F -> Fullwidth Capital F
0xa2ef  0xa2d5  ;Fullwidth Small G -> Fullwidth Capital G
0xa2f0  0xa2d6  ;Fullwidth Small H -> Fullwidth Capital H
0xa2f1  0xa2d7  ;Fullwidth Small I -> Fullwidth Capital I
0xa2f2  0xa2d8  ;Fullwidth Small J -> Fullwidth Capital J
0xa2f3  0xa2d9  ;Fullwidth Small K -> Fullwidth Capital K
0xa2f4  0xa2da  ;Fullwidth Small L -> Fullwidth Capital L
0xa2f5  0xa2db  ;Fullwidth Small M -> Fullwidth Capital M
0xa2f6  0xa2dc  ;Fullwidth Small N -> Fullwidth Capital N
0xa2f7  0xa2dd  ;Fullwidth Small O -> Fullwidth Capital O
0xa2f8  0xa2de  ;Fullwidth Small P -> Fullwidth Capital P
0xa2f9  0xa2df  ;Fullwidth Small Q -> Fullwidth Capital Q
0xa2fa  0xa2e0  ;Fullwidth Small R -> Fullwidth Capital R
0xa2fb  0xa2e1  ;Fullwidth Small S -> Fullwidth Capital S
0xa2fc  0xa2e2  ;Fullwidth Small T -> Fullwidth Capital T
0xa2fd  0xa2e3  ;Fullwidth Small U -> Fullwidth Capital U
0xa2fe  0xa2e4  ;Fullwidth Small V -> Fullwidth Capital V

...Note break in sequence...

0xa340  0xa2e5  ;Fullwidth Small W -> Fullwidth Capital W
0xa341  0xa2e6  ;Fullwidth Small X -> Fullwidth Capital X
0xa342  0xa2e7  ;Fullwidth Small Y -> Fullwidth Capital Y
0xa343  0xa2e8  ;Fullwidth Small Z -> Fullwidth Capital Z


*** Code Page 1361 ***

Not yet available (05/17/94)



****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _INC_MATH
#define _INC_MATH

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef __assembler

/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif  /* _EXCEPTION_DEFINED */


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif  /* !__STDC__ && !defined (__cplusplus) */

#define _COMPLEX_DEFINED
#endif  /* _COMPLEX_DEFINED */
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler
#if !defined (_M_CEE_PURE)
_CRTIMP extern double _HUGE;
#else  /* !defined (_M_CEE_PURE) */
const double _HUGE = System::Double::PositiveInfinity;
#endif  /* !defined (_M_CEE_PURE) */
#endif  /* __assembler */

#define HUGE_VAL _HUGE

/* Function prototypes */

#if !defined (__assembler)
#ifndef _CRT_ABS_DEFINED
#define _CRT_ABS_DEFINED
        int     __cdecl abs(_In_ int _X);
        long    __cdecl labs(_In_ long _X);
#endif  /* _CRT_ABS_DEFINED */

        double  __cdecl acos(_In_ double _X);
        double  __cdecl asin(_In_ double _X);
        double  __cdecl atan(_In_ double _X);
        double  __cdecl atan2(_In_ double _Y, _In_ double _X);
#ifndef _SIGN_DEFINED
_Check_return_ _CRTIMP double __cdecl _copysign (_In_ double _Number, _In_ double _Sign);
_Check_return_ _CRTIMP double __cdecl _chgsign (_In_ double _X);
#define _SIGN_DEFINED
#endif  /* _SIGN_DEFINED */
        double  __cdecl cos(_In_ double _X);
        double  __cdecl cosh(_In_ double _X);
        double  __cdecl exp(_In_ double _X);
_CRT_JIT_INTRINSIC double  __cdecl fabs(_In_ double _X);
        double  __cdecl fmod(_In_ double _X, _In_ double _Y);
        double  __cdecl log(_In_ double _X);
        double  __cdecl log10(_In_ double _X);
        double  __cdecl pow(_In_ double _X, _In_ double _Y);
        double  __cdecl sin(_In_ double _X);
        double  __cdecl sinh(_In_ double _X);
        double  __cdecl tan(_In_ double _X);
        double  __cdecl tanh(_In_ double _X);
        double  __cdecl sqrt(_In_ double _X);
#ifndef _CRT_ATOF_DEFINED
#define _CRT_ATOF_DEFINED
_Check_return_ _CRTIMP double  __cdecl atof(_In_z_ const char *_String);
_Check_return_ _CRTIMP double  __cdecl _atof_l(_In_z_ const char *_String, _In_opt_ _locale_t _Locale);
#endif  /* _CRT_ATOF_DEFINED */

_CRTIMP double  __cdecl _cabs(_In_ struct _complex _Complex_value);
_CRTIMP double  __cdecl ceil(_In_ double _X);
_CRTIMP double  __cdecl floor(_In_ double _X);
_CRTIMP double  __cdecl frexp(_In_ double _X, _Out_ int * _Y);
_CRTIMP double  __cdecl _hypot(_In_ double _X, _In_ double _Y);
_CRTIMP double  __cdecl _j0(_In_ double _X );
_CRTIMP double  __cdecl _j1(_In_ double _X );
_CRTIMP double  __cdecl _jn(int _X, _In_ double _Y);
_CRTIMP double  __cdecl ldexp(_In_ double _X, _In_ int _Y);
#ifndef _CRT_MATHERR_DEFINED
#define _CRT_MATHERR_DEFINED
#if defined (MRTDLL) || defined (_M_CEE_PURE)
        int     __CRTDECL _matherr(_Inout_ struct _exception * _Except);
#else  /* defined (MRTDLL) || defined (_M_CEE_PURE) */
        int     __cdecl _matherr(_Inout_ struct _exception * _Except);
#endif  /* defined (MRTDLL) || defined (_M_CEE_PURE) */
#endif  /* _CRT_MATHERR_DEFINED */
_CRTIMP double  __cdecl modf(_In_ double _X, _Out_ double * _Y);

_CRTIMP double  __cdecl _y0(_In_ double _X);
_CRTIMP double  __cdecl _y1(_In_ double _X);
_CRTIMP double  __cdecl _yn(_In_ int _X, _In_ double _Y);


#if defined (_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(_In_ int _Flag);
_CRTIMP float  __cdecl _hypotf(_In_ float _X, _In_ float _Y);

#endif  /* defined (_M_IX86) */

#if defined (_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

_CRTIMP float  __cdecl acosf( _In_ float _X);
_CRTIMP float  __cdecl asinf( _In_ float _X);
_CRTIMP float  __cdecl atanf( _In_ float _X);
_CRTIMP float  __cdecl atan2f( _In_ float  _Y, float  _X);
_CRTIMP float  __cdecl cosf( _In_ float _X);
_CRTIMP float  __cdecl sinf( _In_ float _X);
_CRTIMP float  __cdecl tanf( _In_ float _X);

/* 4.5.3 Hyperbolic functions */
_CRTIMP float  __cdecl coshf( _In_ float _X);
_CRTIMP float  __cdecl sinhf( _In_ float _X);
_CRTIMP float  __cdecl tanhf( _In_ float _X);

/* 4.5.4 Exponential and logarithmic functions */
_CRTIMP float  __cdecl expf( _In_ float  _X);
_CRTIMP float  __cdecl logf( _In_ float  _X);
_CRTIMP float  __cdecl log10f( _In_ float  _X);
_CRTIMP float  __cdecl modff( float  _X, _Out_ float*  _Y);

/* 4.5.5 Power functions */
_CRTIMP float  __cdecl powf( _In_ float _Base, _In_ float _Exp);
_CRTIMP float  __cdecl sqrtf( _In_ float  _X);

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
_CRTIMP float  __cdecl ceilf( _In_ float  _X);
_CRT_JIT_INTRINSIC  _CRTIMP float  __cdecl fabsf( _In_ float  _X);
_CRTIMP float  __cdecl floorf( _In_ float  _X);
_CRTIMP float  __cdecl fmodf( _In_ float _X, _In_ float _Y);

_CRTIMP float  __cdecl _hypotf(_In_ float _X, _In_ float _Y);
_CRTIMP float  __cdecl ldexpf(_In_ float _X, _In_ int _Y);

#endif  /* defined (_M_IA64) */

#if defined (_M_AMD64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

_CRTIMP float  __cdecl acosf( _In_ float _X);
_CRTIMP float  __cdecl asinf( _In_ float _X);
_CRTIMP float  __cdecl atanf( _In_ float _X);
_CRTIMP float  __cdecl atan2f( _In_ float  _Y, _In_ float  _X);
_CRTIMP float  __cdecl cosf( _In_ float _X);
_CRTIMP float  __cdecl sinf( _In_ float _X);
_CRTIMP float  __cdecl tanf( _In_ float _X);

/* 4.5.3 Hyperbolic functions */
_CRTIMP float  __cdecl coshf( _In_ float _X);
_CRTIMP float  __cdecl sinhf( _In_ float _X);
_CRTIMP float  __cdecl tanhf( _In_ float _X);

/* 4.5.4 Exponential and logarithmic functions */
_CRTIMP float  __cdecl expf( _In_ float  _X);
_CRTIMP float  __cdecl logf( _In_ float  _X);
_CRTIMP float  __cdecl log10f( _In_ float  _X);
_CRTIMP float  __cdecl modff( _In_ float  _X, _Out_ float*  _Y);

/* 4.5.5 Power functions */
_CRTIMP float  __cdecl powf( _In_ float _X, _In_ float _Y);
_CRTIMP float  __cdecl sqrtf( _In_ float  _X);

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
_CRTIMP float  __cdecl ceilf( _In_ float  _X);
_CRTIMP float  __cdecl floorf( _In_ float  _X);
_CRTIMP float  __cdecl fmodf( _In_ float  _X, _In_ float _Y);

_CRTIMP float  __cdecl _hypotf(_In_ float  _X, _In_ float _Y);

_CRTIMP float __cdecl _copysignf (_In_ float _Number, _In_ float _Sign);
_CRTIMP float __cdecl _chgsignf (_In_ float _X);
_CRTIMP float __cdecl _logbf(_In_ float _X);
_CRTIMP float __cdecl _nextafterf(_In_ float _X, _In_ float _Y);
_CRTIMP int    __cdecl _finitef(_In_ float _X);
_CRTIMP int    __cdecl _isnanf(_In_ float _X);
_CRTIMP int    __cdecl _fpclassf(_In_ float _X);

#endif  /* defined (_M_AMD64) */


/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)        ((long double)acos((double)(x)))
#define asinl(x)        ((long double)asin((double)(x)))
#define atanl(x)        ((long double)atan((double)(x)))
#define atan2l(y,x)     ((long double)atan2((double)(y), (double)(x)))
#define ceill(x)        ((long double)ceil((double)(x)))
#define cosl(x)         ((long double)cos((double)(x)))
#define coshl(x)        ((long double)cosh((double)(x)))
#define expl(x)         ((long double)exp((double)(x)))
#define fabsl(x)        ((long double)fabs((double)(x)))
#define floorl(x)       ((long double)floor((double)(x)))
#define fmodl(x,y)      ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y)     ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)        ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y)     ((long double)ldexp((double)(x), (y)))
#define logl(x)         ((long double)log((double)(x)))
#define log10l(x)       ((long double)log10((double)(x)))
#define _matherrl       _matherr
#define modfl(x,y)      ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)       ((long double)pow((double)(x), (double)(y)))
#define sinl(x)         ((long double)sin((double)(x)))
#define sinhl(x)        ((long double)sinh((double)(x)))
#define sqrtl(x)        ((long double)sqrt((double)(x)))
#define tanl(x)         ((long double)tan((double)(x)))
#define tanhl(x)        ((long double)tanh((double)(x)))
#define _chgsignl(x)    ((long double)_chgsign((double)(x)))
#define _copysignl(x,y) ((long double)_copysign((double)(x), (double)(y)))

#define frexpf(x,y) ((float)frexp((double)(x),(y)))

#if !defined (_M_IA64)
#define fabsf(x)    ((float)fabs((double)(x)))
#define ldexpf(x,y) ((float)ldexp((double)(x),(y)))

#if !defined (_M_AMD64)

#define acosf(x)    ((float)acos((double)(x)))
#define asinf(x)    ((float)asin((double)(x)))
#define atanf(x)    ((float)atan((double)(x)))
#define atan2f(y,x) ((float)atan2((double)(y), (double)(x)))
#define ceilf(x)    ((float)ceil((double)(x)))
#define cosf(x)     ((float)cos((double)(x)))
#define coshf(x)    ((float)cosh((double)(x)))
#define expf(x)     ((float)exp((double)(x)))
#define floorf(x)   ((float)floor((double)(x)))
#define fmodf(x,y)  ((float)fmod((double)(x), (double)(y)))
#define logf(x)     ((float)log((double)(x)))
#define log10f(x)   ((float)log10((double)(x)))
#define modff(x,y)  ((float)modf((double)(x), (double *)(y)))
#define powf(x,y)   ((float)pow((double)(x), (double)(y)))
#define sinf(x)     ((float)sin((double)(x)))
#define sinhf(x)    ((float)sinh((double)(x)))
#define sqrtf(x)    ((float)sqrt((double)(x)))
#define tanf(x)     ((float)tan((double)(x)))
#define tanhf(x)    ((float)tanh((double)(x)))

#endif  /* !defined (_M_AMD64) */
#endif  /* !defined (_M_IA64) */

#else  /* __cplusplus */
inline long double acosl(_In_ long double _X)
        {return (acos((double)_X)); }
inline long double asinl(_In_ long double _X)
        {return (asin((double)_X)); }
inline long double atanl(_In_ long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(_In_ long double _Y, _In_ long double _X)
        {return (atan2((double)_Y, (double)_X)); }
inline long double ceill(_In_ long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(_In_ long double _X)
        {return (cos((double)_X)); }
inline long double coshl(_In_ long double _X)
        {return (cosh((double)_X)); }
inline long double expl(_In_ long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(_In_ long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(_In_ long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(_In_ long double _X, _In_ long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(_In_ long double _X, _Out_ int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(_In_ long double _X, _In_ int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(_In_ long double _X)
        {return (log((double)_X)); }
inline long double log10l(_In_ long double _X)
        {return (log10((double)_X)); }
inline long double modfl(_In_ long double _X, _Out_ long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(_In_ long double _X, _In_ long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(_In_ long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(_In_ long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(_In_ long double _X)
        {return (sqrt((double)_X)); }
#ifndef _M_IA64
inline long double tanl(_In_ long double _X)
        {return (tan((double)_X)); }
#else  /* _M_IA64 */
_CRTIMP long double __cdecl tanl(_In_ long double _X);
#endif  /* _M_IA64 */

inline long double tanhl(_In_ long double _X)
        {return (tanh((double)_X)); }

inline long double _chgsignl(_In_ long double _Number)
{
    return _chgsign(static_cast<double>(_Number));
}

inline long double _copysignl(_In_ long double _Number, _In_ long double _Sign)
{
    return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign));
}

inline float frexpf(_In_ float _X, _Out_ int *_Y)
        {return ((float)frexp((double)_X, _Y)); }

#if !defined (_M_IA64)
inline float fabsf(_In_ float _X)
        {return ((float)fabs((double)_X)); }
inline float ldexpf(_In_ float _X, _In_ int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if !defined (_M_AMD64)
inline float acosf(_In_ float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(_In_ float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(_In_ float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(_In_ float _Y, _In_ float _X)
        {return ((float)atan2((double)_Y, (double)_X)); }
inline float ceilf(_In_ float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(_In_ float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(_In_ float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(_In_ float _X)
        {return ((float)exp((double)_X)); }
inline float floorf(_In_ float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(_In_ float _X, _In_ float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(_In_ float _X)
        {return ((float)log((double)_X)); }
inline float log10f(_In_ float _X)
        {return ((float)log10((double)_X)); }
inline float modff(_In_ float _X, _Out_ float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(_In_ float _X, _In_ float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(_In_ float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(_In_ float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(_In_ float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(_In_ float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(_In_ float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined (_M_AMD64) */
#endif  /* !defined (_M_IA64) */
#endif  /* __cplusplus */
#endif  /* !defined (__assembler) */

#if !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler

#if !defined (_M_CEE_PURE)
_CRTIMP extern double HUGE;
#else  /* !defined (_M_CEE_PURE) */
    const double HUGE = _HUGE;
#endif  /* !defined (_M_CEE_PURE) */

_CRT_NONSTDC_DEPRECATE(_cabs) _CRTIMP double  __cdecl cabs(_In_ struct _complex _X);
_CRT_NONSTDC_DEPRECATE(_hypot) _CRTIMP double  __cdecl hypot(_In_ double _X, _In_ double _Y);
_CRT_NONSTDC_DEPRECATE(_j0) _CRTIMP double  __cdecl j0(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_j1) _CRTIMP double  __cdecl j1(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_jn) _CRTIMP double  __cdecl jn(_In_ int _X, _In_ double _Y);
_CRT_NONSTDC_DEPRECATE(_y0) _CRTIMP double  __cdecl y0(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_y1) _CRTIMP double  __cdecl y1(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_yn) _CRTIMP double  __cdecl yn(_In_ int _X, _In_ double _Y);

#endif  /* __assembler */

#endif  /* !__STDC__ */

#ifdef __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline long __CRTDECL abs(_In_ long _X)
        {return (labs(_X)); }
inline double __CRTDECL abs(_In_ double _X)
        {return (fabs(_X)); }
inline double __CRTDECL pow(_In_ double _X, _In_ int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __CRTDECL abs(_In_ float _X)
        {return (fabsf(_X)); }
inline float __CRTDECL acos(_In_ float _X)
        {return (acosf(_X)); }
inline float __CRTDECL asin(_In_ float _X)
        {return (asinf(_X)); }
inline float __CRTDECL atan(_In_ float _X)
        {return (atanf(_X)); }
inline float __CRTDECL atan2(_In_ float _Y, _In_ float _X)
        {return (atan2f(_Y, _X)); }
inline float __CRTDECL ceil(_In_ float _X)
        {return (ceilf(_X)); }
inline float __CRTDECL cos(_In_ float _X)
        {return (cosf(_X)); }
inline float __CRTDECL cosh(_In_ float _X)
        {return (coshf(_X)); }
inline float __CRTDECL exp(_In_ float _X)
        {return (expf(_X)); }
inline float __CRTDECL fabs(_In_ float _X)
        {return (fabsf(_X)); }
inline float __CRTDECL floor(_In_ float _X)
        {return (floorf(_X)); }
inline float __CRTDECL fmod(_In_ float _X, _In_ float _Y)
        {return (fmodf(_X, _Y)); }
inline float __CRTDECL frexp(_In_ float _X, _Out_ int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __CRTDECL ldexp(_In_ float _X, _In_ int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __CRTDECL log(_In_ float _X)
        {return (logf(_X)); }
inline float __CRTDECL log10(_In_ float _X)
        {return (log10f(_X)); }
inline float __CRTDECL modf(_In_ float _X, _Out_ float * _Y)
        {return (modff(_X, _Y)); }
inline float __CRTDECL pow(_In_ float _X, _In_ float _Y)
        {return (powf(_X, _Y)); }
inline float __CRTDECL pow(_In_ float _X, _In_ int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __CRTDECL sin(_In_ float _X)
        {return (sinf(_X)); }
inline float __CRTDECL sinh(_In_ float _X)
        {return (sinhf(_X)); }
inline float __CRTDECL sqrt(_In_ float _X)
        {return (sqrtf(_X)); }
inline float __CRTDECL tan(_In_ float _X)
        {return (tanf(_X)); }
inline float __CRTDECL tanh(_In_ float _X)
        {return (tanhf(_X)); }
inline long double __CRTDECL abs(_In_ long double _X)
        {return (fabsl(_X)); }
inline long double __CRTDECL acos(_In_ long double _X)
        {return (acosl(_X)); }
inline long double __CRTDECL asin(_In_ long double _X)
        {return (asinl(_X)); }
inline long double __CRTDECL atan(_In_ long double _X)
        {return (atanl(_X)); }
inline long double __CRTDECL atan2(_In_ long double _Y, _In_ long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __CRTDECL ceil(_In_ long double _X)
        {return (ceill(_X)); }
inline long double __CRTDECL cos(_In_ long double _X)
        {return (cosl(_X)); }
inline long double __CRTDECL cosh(_In_ long double _X)
        {return (coshl(_X)); }
inline long double __CRTDECL exp(_In_ long double _X)
        {return (expl(_X)); }
inline long double __CRTDECL fabs(_In_ long double _X)
        {return (fabsl(_X)); }
inline long double __CRTDECL floor(_In_ long double _X)
        {return (floorl(_X)); }
inline long double __CRTDECL fmod(_In_ long double _X, _In_ long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __CRTDECL frexp(_In_ long double _X, _Out_ int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __CRTDECL ldexp(_In_ long double _X, _In_ int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __CRTDECL log(_In_ long double _X)
        {return (logl(_X)); }
inline long double __CRTDECL log10(_In_ long double _X)
        {return (log10l(_X)); }
inline long double __CRTDECL modf(_In_ long double _X, _Out_ long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __CRTDECL pow(_In_ long double _X, _In_ long double _Y)
        {return (powl(_X, _Y)); }
inline long double __CRTDECL pow(_In_ long double _X, _In_ int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __CRTDECL sin(_In_ long double _X)
        {return (sinl(_X)); }
inline long double __CRTDECL sinh(_In_ long double _X)
        {return (sinhl(_X)); }
inline long double __CRTDECL sqrt(_In_ long double _X)
        {return (sqrtl(_X)); }
inline long double __CRTDECL tan(_In_ long double _X)
        {return (tanl(_X)); }
inline long double __CRTDECL tanh(_In_ long double _X)
        {return (tanhl(_X)); }

}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */

#if defined (_USE_MATH_DEFINES) && !defined (_MATH_DEFINES_DEFINED)
#define _MATH_DEFINES_DEFINED

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* defined (_USE_MATH_DEFINES) && !defined (_MATH_DEFINES_DEFINED) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#include <crtdefs.h>
#include <ctype.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_Check_return_ _CRTIMP unsigned char * __cdecl __p__mbctype(void);
_Check_return_ _CRTIMP unsigned char * __cdecl __p__mbcasemap(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */
#if !defined (_M_CEE_PURE)
/* No data exports in pure code */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];
#else  /* !defined (_M_CEE_PURE) */
_Check_return_ _CRTIMP unsigned char * __cdecl __p__mbctype(void);
_Check_return_ _CRTIMP unsigned char * __cdecl __p__mbcasemap(void);
#define _mbctype   (__p__mbctype())
#define _mbcasemap (__p__mbcasemap())
#endif  /* !defined (_M_CEE_PURE) */

#ifndef _INTERNAL_IFSTRIP_
extern pthreadmbcinfo __ptmbcinfo;
extern int __globallocalestatus;
extern int __locale_changed;
extern struct threadmbcinfostruct __initialmbcinfo;
pthreadmbcinfo __cdecl __updatetmbcinfo(void);
#endif  /* _INTERNAL_IFSTRIP_ */

/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(_In_ int _CodePage);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_Check_return_ _CRTIMP int __cdecl _ismbbkalnum( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbkalnum_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbkana( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbkana_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbkpunct( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbkpunct_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbkprint( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbkprint_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbalpha( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbalpha_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbpunct( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbpunct_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbalnum( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbalnum_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbprint( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbprint_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbgraph( _In_ unsigned int _C );
_Check_return_ _CRTIMP int __cdecl _ismbbgraph_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale);

#ifndef _MBLEADTRAIL_DEFINED
_Check_return_ _CRTIMP int __cdecl _ismbblead( _In_ unsigned int _C);
_Check_return_ _CRTIMP int __cdecl _ismbblead_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale );
_Check_return_ _CRTIMP int __cdecl _ismbbtrail( _In_ unsigned int _C);
_Check_return_ _CRTIMP int __cdecl _ismbbtrail_l(_In_ unsigned int _C, _In_opt_ _locale_t _Locale );
_Check_return_ _CRTIMP int __cdecl _ismbslead(_In_bytecount_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos);
_Check_return_ _CRTIMP int __cdecl _ismbslead_l(_In_bytecount_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbstrail(_In_bytecount_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos);
_Check_return_ _CRTIMP int __cdecl _ismbstrail_l(_In_bytecount_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos, _In_opt_ _locale_t _Locale);

#define _MBLEADTRAIL_DEFINED
#endif  /* _MBLEADTRAIL_DEFINED */

#define _MBCTYPE_DEFINED
#endif  /* _MBCTYPE_DEFINED */

/*
 * char byte classification macros
 */

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_pctype)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_pctype)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_pctype)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_pctype)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_pctype)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */

#ifndef _INTERNAL_IFSTRIP_
#define _ismbbalnum_l(_c, pt)  ((((pt)->locinfo->pctype)[(unsigned char)(_c)] & \
                                (_ALPHA|_DIGIT)) || \
                                (((pt)->mbcinfo->mbctype+1)[(unsigned char)(_c)] & _MS))
#define _ismbbalpha_l(_c, pt)  ((((pt)->locinfo->pctype)[(unsigned char)(_c)] & \
                            (_ALPHA)) || \
                            (((pt)->mbcinfo->mbctype+1)[(unsigned char)(_c)] & _MS))
#define _ismbbgraph_l(_c, pt)  ((((pt)->locinfo->pctype)[(unsigned char)(_c)] & \
                            (_PUNCT|_ALPHA|_DIGIT)) || \
                            (((pt)->mbcinfo->mbctype+1)[(unsigned char)(_c)] & (_MS|_MP)))
#define _ismbbprint_l(_c, pt)  ((((pt)->locinfo->pctype)[(unsigned char)(_c)] & \
                            (_BLANK|_PUNCT|_ALPHA|_DIGIT)) || \
                            (((pt)->mbcinfo->mbctype + 1)[(unsigned char)(_c)] & (_MS|_MP)))
#define _ismbbpunct_l(_c, pt)  ((((pt)->locinfo->pctype)[(unsigned char)(_c)] & _PUNCT) || \
                                (((pt)->mbcinfo->mbctype+1)[(unsigned char)(_c)] & _MP))
#define _ismbblead_l(_c, p)   ((p->mbcinfo->mbctype + 1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail_l(_c, p)  ((p->mbcinfo->mbctype + 1)[(unsigned char)(_c)] & _M2)
#endif  /* _INTERNAL_IFSTRIP_ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbccpy_s.inl ===
/***
*mbccpy_s.inl - general implementation of _mbccpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the algorithm for _mbccpy_s.
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, int *_PCopied, const unsigned char *_SRC, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, int *_PCopied, const unsigned char *_SRC)
#endif  /* _USE_LOCALE_ARG */
{
    /* validation section */
    _ASSIGN_IF_NOT_NULL(_PCopied, 0);
    _VALIDATE_STRING(_DEST, _SizeInBytes);
    if (_SRC == NULL)
    {
        *_DEST = '\0';
        _RETURN_EINVAL;
    }

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
#endif  /* _USE_LOCALE_ARG */

    /* copy */
    if (_ISMBBLEAD(*_SRC))
    {
        if (_SRC[1] == '\0')
        {
            /* the source string contained a lead byte followed by the null terminator:
               we copy only the null terminator and return EILSEQ to indicate the
               malformed char */
            *_DEST = '\0';
            _ASSIGN_IF_NOT_NULL(_PCopied, 1);
            _RETURN_MBCS_ERROR;
        }
        if (_SizeInBytes < 2)
        {
            *_DEST = '\0';
            _RETURN_BUFFER_TOO_SMALL(_DEST, _SizeInBytes);
        }
        *_DEST++ = *_SRC++;
        *_DEST = *_SRC;
        _ASSIGN_IF_NOT_NULL(_PCopied, 2);
    }
    else
    {
        *_DEST = *_SRC;
        _ASSIGN_IF_NOT_NULL(_PCopied, 1);
    }

    _RETURN_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbschr.c ===
/***
* mbschr.c - Search MBCS string for character
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Search MBCS string for a character
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbschr - Search MBCS string for character
*
*Purpose:
*       Search the given string for the specified character.
*       MBCS characters are handled correctly.
*
*Entry:
*       unsigned char *string = string to search
*       int c = character to search for
*
*Exit:
*       returns a pointer to the first occurence of the specified char
*       within the string.
*
*       returns NULL if the character is not found n the string.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/


extern "C" _CONST_RETURN unsigned char * __cdecl _mbschr_l(
        const unsigned char *string,
        unsigned int c,
        _locale_t plocinfo
        )
{
        unsigned short cc;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (_CONST_RETURN unsigned char *)strchr((const char *)string, (int)c);

        for (; (cc = *string); string++)
        {
            if ( _ismbblead_l(cc, _loc_update.GetLocaleT()) )
            {
                if (*++string == '\0')
                    return NULL;        /* error */
                if ( c == (unsigned int)((cc << 8) | *string) ) /* DBCS match */
                    return (unsigned char *)(string - 1);
            }
            else if (c == (unsigned int)cc)
                break;  /* SBCS match */
        }

        if (c == (unsigned int)cc)      /* check for SBCS match--handles NUL char */
            return (unsigned char *)(string);

        return NULL;
}

extern "C" _CONST_RETURN unsigned char * (__cdecl _mbschr)(
        const unsigned char *string,
        unsigned int c
        )
{
    return _mbschr_l(string, c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscpy_s.c ===
/***
*mbscpy_s.c - Copy one string to another (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbscpy_s
#define _DEST _Dst
#define _SRC _Src

#include <mbscpy_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_3(errno_t, _mbscpy_s, unsigned char *, size_t, const unsigned char *)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscoll.c ===
/***
*mbscoll.c - Collate MBCS strings
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Collate MBCS strings
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <internal.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbscoll - Collate MBCS strings
*
*Purpose:
*       Collates two strings for lexical order.   Strings
*       are collated on a character basis, not a byte basis.
*
*Entry:
*       char *s1, *s2 = strings to collate
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbscoll_l(
        const unsigned char *s1,
        const unsigned char *s2,
        _locale_t plocinfo
        )
{
        int ret;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strcoll_l((const char *)s1, (const char *)s2, plocinfo);

        if (0 == (ret = __crtCompareStringA(
                        _loc_update.GetLocaleT(),
                        _loc_update.GetLocaleT()->mbcinfo->mblcid,
                        SORT_STRINGSORT,
                        (LPCSTR)s1,
                        -1,
                        (LPSTR)s2,
                        -1,
                        _loc_update.GetLocaleT()->mbcinfo->mbcodepage )))
        {
            errno = EINVAL;

            return _NLSCMPERROR;
        }

        return ret - 2;

}

extern "C" int (__cdecl _mbscoll)(
        const unsigned char *s1,
        const unsigned char *s2
        )
{
    return _mbscoll_l(s1, s2, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscat_s.c ===
/***
*mbscat_s.c - Concatenate one string to another (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Concatenate one string to another (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbscat_s
#define _DEST _Dst
#define _SRC _Src

#include <mbscat_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_3(errno_t, _mbscat_s, unsigned char *, size_t, const unsigned char *)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscpy_s.inl ===
/***
*mbscpy_s.inl - implementation of _mbscpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the algorithm for _mbscpy_s.
*
****/


_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC)
#endif  /* _USE_LOCALE_ARG */
{
    unsigned char *p;
    size_t available;
    BOOL fIsLeadPrefix;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SizeInBytes);
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SizeInBytes);

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return _SB_FUNC_NAME((char *)_DEST, _SizeInBytes, (const char *)_SRC);
    }
#endif  /* _USE_LOCALE_ARG */

    p = _DEST;
    available = _SizeInBytes;
    while ((*p++ = *_SRC++) != 0 && --available > 0)
    {
    }

    /*
     * If we ran out of destination bytes then we did so before copying null.
     * Only exception to that is if last mbc was invalid (leadbyte+null), which
     * is treated as null. In that case clear the copied lead byte and return ok.
     */

    if (available == 0)
    {
        if (*_SRC == 0) {
            _ISMBBLEADPREFIX(fIsLeadPrefix,_DEST,p-1);
            if (fIsLeadPrefix)
            {
                p[-1] = 0;
                _RETURN_MBCS_ERROR;
            }
        }
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SizeInBytes);
    }

    /*
     * Otherwise we have space left in the dst buffer and stopped copying because
     * we saw a null in the src. If null is part of invalid MBC (lead byte + null)
     * then clear the lead byte also.
     */

    _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, p-2);
    if (fIsLeadPrefix && (p - 2) >= _DEST)
    {
        p[-2] = 0;
        available++;
        _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);
        _RETURN_MBCS_ERROR;
    }

    _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);
    _RETURN_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscpy_s_l.c ===
/***
*mbscpy_s_l.c - Copy one string to another (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbscpy_s_l
#define _SB_FUNC_NAME strcpy_s
#define _DEST _Dst
#define _SRC _Src

#include <mbscpy_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscspn.c ===
/***
*mbscspn.c - Find first string char in charset (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Find first string char in charset (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
*ifndef _RETURN_PTR
* _mbscspn - Find first string char in charset (MBCS)
*else
* _mbspbrk - Find first string char in charset, pointer return (MBCS)
*endif
*
*Purpose:
*       Returns maximum leading segment of string
*       which consists solely of characters NOT from charset.
*       Handles MBCS chars correctly.
*
*Entry:
*       char *string = string to search in
*       char *charset = set of characters to scan over
*
*Exit:
*
*ifndef _RETURN_PTR
*       Returns the index of the first char in string
*       that is in the set of characters specified by control.
*
*       Returns 0, if string begins with a character in charset.
*else
*       Returns pointer to first character in charset.
*
*       Returns NULL if string consists entirely of characters
*       not from charset.
*endif
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifndef _RETURN_PTR

extern "C" size_t __cdecl _mbscspn_l(
        const unsigned char *string,
        const unsigned char *charset,
        _locale_t plocinfo
        )
#else  /* _RETURN_PTR */

extern "C" const unsigned char * __cdecl _mbspbrk_l(
        const unsigned char *string,
        const unsigned char  *charset,
        _locale_t plocinfo
        )
#endif  /* _RETURN_PTR */

{
        unsigned char *p, *q;
        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
#ifndef _RETURN_PTR
            return strcspn((const char *)string, (const char *)charset);
#else  /* _RETURN_PTR */
            return (const unsigned char *)strpbrk((const char *)string, (const char *)charset);
#endif  /* _RETURN_PTR */

        /* validation section */
#ifndef _RETURN_PTR
        _VALIDATE_RETURN(string != NULL, EINVAL, 0);
        _VALIDATE_RETURN(charset != NULL, EINVAL, 0);
#else  /* _RETURN_PTR */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(charset != NULL, EINVAL, NULL);
#endif  /* _RETURN_PTR */

        /* loop through the string to be inspected */
        for (q = (unsigned char *)string; *q ; q++) {

            /* loop through the charset */
            for (p = (unsigned char *)charset; *p ; p++) {

                if ( _ismbblead_l(*p, _loc_update.GetLocaleT()) ) {
                    if (((*p == *q) && (p[1] == q[1])) || p[1] == '\0')
                        break;
                    p++;
                }
                else
                    if (*p == *q)
                        break;
            }

            if (*p != '\0')         /* end of charset? */
                break;              /* no, match on this char */

            if ( _ismbblead_l(*q, _loc_update.GetLocaleT()) )
                if (*++q == '\0')
                    break;
        }

#ifndef _RETURN_PTR
        return((size_t) (q - string));  /* index */
#else  /* _RETURN_PTR */
        return((*q) ? q : NULL);        /* pointer */
#endif  /* _RETURN_PTR */

}

#ifndef _RETURN_PTR

extern "C" size_t (__cdecl _mbscspn)(
        const unsigned char *string,
        const unsigned char *charset
        )
#else  /* _RETURN_PTR */

extern "C" const unsigned char * (__cdecl _mbspbrk)(
        const unsigned char *string,
        const unsigned char  *charset
        )
#endif  /* _RETURN_PTR */

{
#ifndef _RETURN_PTR
        return _mbscspn_l(string, charset, NULL);
#else  /* _RETURN_PTR */
        return _mbspbrk_l(string, charset, NULL);
#endif  /* _RETURN_PTR */
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsdec.c ===
/***
*mbsdec.c - Move MBCS string pointer backward one charcter.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Move MBCS string pointer backward one character.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <stddef.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
*_mbsdec - Move MBCS string pointer backward one charcter.
*
*Purpose:
*       Move the supplied string pointer backwards by one
*       character.  MBCS characters are handled correctly.
*
*Entry:
*       const unsigned char *string = pointer to beginning of string
*       const unsigned char *current = current char pointer (legal MBCS boundary)
*
*Exit:
*       Returns pointer after moving it.
*       Returns NULL if string >= current.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsdec_l(
        const unsigned char *string,
        const unsigned char *current,
        _locale_t plocinfo
        )
{
        const unsigned char *temp;

        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(current != NULL, EINVAL, NULL);

        if (string >= current)
                return(NULL);

        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)--current;

        temp = current - 1;

/* There used to be an optimisation here:
 *
 *  If (current-1) returns true from _ismbblead, it is a trail byte, because
 *  current is a known character start point, and so current-1 would have to be a
 *  legal single byte MBCS character, which a lead byte is not.  Therefore, if so,
 *  return (current-2) because it must be the trailbyte's lead.
 *
 *      if ( _ismbblead(*temp) )
 *           return (unsigned char *)(temp - 1);
 *
 * But this is not a valid optimisation if you want to cope correctly with an
 * MBCS string which is terminated by a leadbyte and a 0 byte, when you are passed
 * an initial position pointing to the \0 at the end of the string.
 *
 * This optimisation is also invalid if you are passed a pointer to half-way
 * through an MBCS pair.
 *
 * Neither of these are truly valid input conditions, but to ensure predictably
 * correct behaviour in the presence of these conditions, we have removed
 * the optimisation.
 */

/*
 *  It is unknown whether (current - 1) is a single byte character or a
 *  trail.  Now decrement temp until
 *      a)  The beginning of the string is reached, or
 *      b)  A non-lead byte (either single or trail) is found.
 *  The difference between (current-1) and temp is the number of non-single
 *  byte characters preceding (current-1).  There are two cases for this:
 *      a)  (current - temp) is odd, and
 *      b)  (current - temp) is even.
 *  If odd, then there are an odd number of "lead bytes" preceding the
 *  single/trail byte (current - 1), indicating that it is a trail byte.
 *  If even, then there are an even number of "lead bytes" preceding the
 *  single/trail byte (current - 1), indicating a single byte character.
 */
        while ( (string <= --temp) && (_ismbblead_l(*temp, _loc_update.GetLocaleT())) )
                ;

        return (unsigned char *)(current - 1 - ((current - temp) & 0x01) );
}

extern "C" unsigned char * (__cdecl _mbsdec)(
        const unsigned char *string,
        const unsigned char *current
        )
{
    return _mbsdec_l(string, current, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsearch.cpp ===
/***
*mbsearch.cpp - do a binary search
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines bsearch() - do a binary search an an array
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#if defined (_M_CEE)
#include "bsearch.c"

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "bsearch.c"
#endif  /* defined (_M_CEE) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbrtowc.c ===
/***
*mbrtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>
#include <wchar.h>
#include <limits.h>              /* for INT_MAX */
#include <stdio.h>               /* for EOF */

/***
*errno_t _mbrtowc_s_l() - Helper function to convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t *dst       = pointer to (single) destination wide character
*       const char *s      = pointer to multibyte character
*       size_t n           = maximum length of multibyte character to consider
*       mbstate_t *pmbst   = pointer to state (must be not NULL)
*       _locale_t plocinfo = locale info
*
*Exit:
*       returns, in *pRetValue:
*       If s = NULL, 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL:  0 (if *s = null char)
*                      -1 (if the next n or fewer bytes not valid mbc)
*                      number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

static errno_t __cdecl _mbrtowc_s_l(
    int *pRetValue,
    wchar_t *dst,
    const char *s,
    size_t n,
    mbstate_t *pmbst,
    _locale_t plocinfo
)
{
    _ASSERTE (pmbst != NULL);
    _ASSIGN_IF_NOT_NULL(dst, 0);

    if ( !s || n == 0 )
    {
        /* indicate do not have state-dependent encodings,
            handle zero length string */
        _ASSIGN_IF_NOT_NULL(pRetValue, 0);
        return 0;
    }

    if ( !*s )
    {
        /* handle NULL char */
        _ASSIGN_IF_NOT_NULL(pRetValue, 0);
        return 0;
    }

    _LocaleUpdate _loc_update(plocinfo);
    _ASSERTE (_loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 || _loc_update.GetLocaleT()->locinfo->mb_cur_max == 2);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
    {
        _ASSIGN_IF_NOT_NULL(dst, (wchar_t)(unsigned char)*s);
        _ASSIGN_IF_NOT_NULL(pRetValue, 1);
        return 0;
    }

    if (*pmbst != 0)
    {
        /* complete two-byte multibyte character */
        ((char *)pmbst)[1] = *s;
        if (_loc_update.GetLocaleT()->locinfo->mb_cur_max <= 1 ||
            (MultiByteToWideChar(
                _loc_update.GetLocaleT()->locinfo->lc_codepage,
                MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                (char *)pmbst,
                2,
                dst,
                (dst != NULL ? 1 : 0)) == 0))
        {
            /* translation failed */
            *pmbst = 0;
            errno = EILSEQ;
            _ASSIGN_IF_NOT_NULL(dst, 0);
            _ASSIGN_IF_NOT_NULL(pRetValue, -1);
            return errno;
        }
        *pmbst = 0;
        _ASSIGN_IF_NOT_NULL(pRetValue, _loc_update.GetLocaleT()->locinfo->mb_cur_max);
        return 0;
    }
    else if ( _isleadbyte_l((unsigned char)*s, _loc_update.GetLocaleT()) )
    {
        /* multi-byte char */
        if (n < (size_t)_loc_update.GetLocaleT()->locinfo->mb_cur_max)
        {   /* save partial multibyte character */
            ((char *)pmbst)[0] = *s;
            _ASSIGN_IF_NOT_NULL(pRetValue, -2);
            return 0;
        }
        else if ( _loc_update.GetLocaleT()->locinfo->mb_cur_max <= 1 ||
                  (MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                        MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                        s,
                                        _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                        dst,
                                        (dst != NULL ? 1 : 0)) == 0) )
        {
            /* validate high byte of mbcs char */
            if (!*(s+1))
            {
                *pmbst = 0;
                errno = EILSEQ;
                _ASSIGN_IF_NOT_NULL(dst, 0);
                _ASSIGN_IF_NOT_NULL(pRetValue, -1);
                return errno;
            }
        }
        _ASSIGN_IF_NOT_NULL(pRetValue, _loc_update.GetLocaleT()->locinfo->mb_cur_max);
        return 0;
    }
    else {
        /* single byte char */
        if ( MultiByteToWideChar(
               _loc_update.GetLocaleT()->locinfo->lc_codepage,
               MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
               s,
               1,
               dst,
               (dst != NULL ? 1 : 0)) == 0 )
        {
            errno = EILSEQ;
            _ASSIGN_IF_NOT_NULL(dst, 0);
            _ASSIGN_IF_NOT_NULL(pRetValue, -1);
            return errno;
        }

        _ASSIGN_IF_NOT_NULL(pRetValue, sizeof(char));
        return 0;
    }
}


/***
*wint_t btowc(c) - translate single byte to wide char
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

extern "C" wint_t __cdecl btowc (
    int c
)
{
    if (c == EOF)
    {
        return WEOF;
    }
    else
    {
        /* convert as one-byte string */
        char ch = (char)c;
        mbstate_t mbst = 0;
        wchar_t wc = 0;
        int retValue = -1;

        _mbrtowc_s_l(&retValue, &wc, &ch, 1, &mbst, NULL);
        return (retValue < 0 ? WEOF : wc);
    }
}


/***
*size_t mbrlen(s, n, pst) - determine next multibyte code, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

extern "C" size_t __cdecl mbrlen (
    const char *s,
    size_t n,
    mbstate_t *pst
)
{
    static mbstate_t mbst = {0};
    int retValue = -1;

    _mbrtowc_s_l(&retValue, NULL, s, n, (pst != NULL ? pst : &mbst), NULL);
    return retValue;
}


/***
*size_t mbrtowc(pwc, s, n, pst) - translate multibyte to wchar_t, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

extern "C" size_t __cdecl mbrtowc (
    wchar_t *dst,
    const char *s,
    size_t n,
    mbstate_t *pst
)
{
    static mbstate_t mbst = {0};
    int retValue = -1;

    if (s != NULL)
    {
        _mbrtowc_s_l(&retValue, dst, s, n, (pst != NULL ? pst : &mbst), NULL);
    }
    else
    {
        _mbrtowc_s_l(&retValue, NULL, "", 1, (pst != NULL ? pst : &mbst), NULL);
    }
    return retValue;
}


/***
*size_t mbsrtowcs(wcs, ps, n, pst) - translate multibyte string to wide,
*       restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

/* Helper function shared by the secure and non-secure versions. */

extern "C" size_t __cdecl _mbsrtowcs_helper (
    wchar_t *wcs,
    const char **ps,
    size_t n,
    mbstate_t *pst
)
{
    /* validation section */
    _VALIDATE_RETURN(ps != NULL, EINVAL, (size_t)-1);

    static mbstate_t mbst = {0};
    const char *s = *ps;
    int i = 0;
    size_t nwc = 0;
    _LocaleUpdate _loc_update(NULL);

    if (pst == NULL)
    {
        pst = &mbst;
    }

    if (wcs == NULL)
    {
        for (; ; ++nwc, s += i)
        {
            /* translate but don't store */
            wchar_t wc;
            _mbrtowc_s_l(&i, &wc, s, INT_MAX, pst, _loc_update.GetLocaleT());
            if (i < 0)
            {
                return (size_t)-1;
            }
            else if (i == 0)
            {
                return nwc;
            }
        }
    }

    for (; 0 < n; ++nwc, s += i, ++wcs, --n)
    {
        /* translate and store */
        _mbrtowc_s_l(&i, wcs, s, INT_MAX, pst, _loc_update.GetLocaleT());
        if (i < 0)
        {
            /* encountered invalid sequence */
            nwc = (size_t)-1;
            break;
        }
        else if (i == 0)
        {
            /* encountered terminating null */
            s = 0;
            break;
        }
    }

    *ps = s;
    return nwc;
}

extern "C" size_t __cdecl mbsrtowcs (
    wchar_t *wcs,
    const char **ps,
    size_t n,
    mbstate_t *pst
)
{
    /* Call a non-deprecated helper to do the work. */

    return _mbsrtowcs_helper(wcs, ps, n, pst);
}


/***
*errno_t mbsrtowcs_s() - Convert multibyte char string to wide char string.
*
*Purpose:
*       Convert a multi-byte char string into the equivalent wide char string,
*       according to the LC_CTYPE category of the current locale.
*       Same as mbstowcs(), but the destination is ensured to be null terminated.
*       If there's not enough space, we return EINVAL.
*
*Entry:
*       size_t *pRetValue = Number of bytes modified including the terminating NULL
*                           This pointer can be NULL.
*       wchar_t *pwcs = pointer to destination wide character string buffer
*       size_t sizeInWords = size of the destination buffer
*       const char **s = pointer to source multibyte character string
*       size_t n = maximum number of wide characters to store (not including the terminating NULL)
*       mbstate_t *pst = pointer to the conversion state
*
*Exit:
*       The error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" errno_t __cdecl mbsrtowcs_s (
    size_t *pRetValue,
    wchar_t *dst,
    size_t sizeInWords,
    const char **ps,
    size_t n,
    mbstate_t *pmbst
)
{
    size_t retsize;

    /* validation section */
    _ASSIGN_IF_NOT_NULL(pRetValue, (size_t)-1);
    _VALIDATE_RETURN_ERRCODE((dst == NULL && sizeInWords == 0) || (dst != NULL && sizeInWords > 0), EINVAL);
    if (dst != NULL)
    {
        _RESET_STRING(dst, sizeInWords);
    }
    _VALIDATE_RETURN_ERRCODE(ps != NULL, EINVAL);

    /* Call a non-deprecated helper to do the work. */

    retsize = _mbsrtowcs_helper(dst, ps, (n > sizeInWords ? sizeInWords : n), pmbst);

    if (retsize == (size_t)-1)
    {
        if (dst != NULL)
        {
            _RESET_STRING(dst, sizeInWords);
        }
        return errno;
    }

    /* count the null terminator */
    retsize++;

    if (dst != NULL)
    {
        /* return error if the string does not fit */
        if (retsize > sizeInWords)
        {
            _RESET_STRING(dst, sizeInWords);
            _VALIDATE_RETURN_ERRCODE(sizeInWords <= retsize, ERANGE);
        }
        else
        {
            /* ensure the string is null terminated */
            dst[retsize - 1] = '\0';
        }
    }

    _ASSIGN_IF_NOT_NULL(pRetValue, retsize);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsicoll.c ===
/***
*mbsicoll.c - Collate MBCS strings, ignoring case
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Collate MBCS strings, ignoring case
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <internal.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsicoll - Collate MBCS strings, ignoring case
*
*Purpose:
*       Collates two strings for lexical order.   Strings
*       are collated on a character basis, not a byte basis.
*
*Entry:
*       char *s1, *s2 = strings to collate
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsicoll_l(
        const unsigned char *s1,
        const unsigned char *s2,
        _locale_t plocinfo
        )
{
        int ret;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _stricoll_l((const char *)s1, (const char *)s2, plocinfo);

        if ( 0 == (ret = __crtCompareStringA(
                        _loc_update.GetLocaleT(),
                        _loc_update.GetLocaleT()->mbcinfo->mblcid,
                        SORT_STRINGSORT | NORM_IGNORECASE,
                        (LPCSTR)s1,
                        -1,
                        (LPSTR)s2,
                        -1,
                        _loc_update.GetLocaleT()->mbcinfo->mbcodepage )) )
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return ret - 2;

}

extern "C" int (__cdecl _mbsicoll)(
        const unsigned char *s1,
        const unsigned char *s2
        )
{
    return _mbsicoll_l(s1, s2, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbslen.c ===
/***
*mbslen.c - Find length of MBCS string
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Find length of MBCS string
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbslen - Find length of MBCS string
*
*Purpose:
*       Find the length of the MBCS string (in characters).
*
*Entry:
*       unsigned char *s = string
*
*Exit:
*       Returns the number of MBCS chars in the string.
*
*Exceptions:
*
*******************************************************************************/

extern "C" size_t __cdecl _mbslen_l(
        const unsigned char *s,
        _locale_t plocinfo
        )
{
        int n;
        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return strlen((const char *)s);

        for (n = 0; *s; n++, s++) {
            if ( _ismbblead_l(*s, _loc_update.GetLocaleT()) ) {
                if (*++s == '\0')
                    break;
            }
        }

        return(n);
}

extern "C" size_t (__cdecl _mbslen)(
        const unsigned char *s
        )
{
    return _mbslen_l(s, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbslwr.c ===
/***
*mbslwr.c - Convert string lower case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Convert string lower case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <locale.h>
#include <setlocal.h>
#include <string.h>


/***
* _mbslwr - Convert string lower case (MBCS)
*
*Purpose:
*       Convrts all the upper case characters in a string
*       to lower case in place.  MBCS chars are handled
*       correctly.
*
*Entry:
*       unsigned char *string = pointer to string
*
*Exit:
*       Returns a pointer to the input string.
*       Returns NULL on error.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

errno_t __cdecl _mbslwr_s_l(
        unsigned char *string,
        size_t sizeInBytes,
        _locale_t plocinfo
        )
{
        size_t stringlen;

        /* validation section */
        _VALIDATE_RETURN_ERRCODE((string != NULL && sizeInBytes > 0) || (string == NULL && sizeInBytes == 0), EINVAL);

        if (string == NULL)
        {
            /* nothing to do */
            return 0;
        }

        stringlen = strnlen((char *)string, sizeInBytes);
        if (stringlen >= sizeInBytes)
        {
            _RESET_STRING(string, sizeInBytes);
            _RETURN_DEST_NOT_NULL_TERMINATED(string, sizeInBytes);
        }
        _FILL_STRING(string, sizeInBytes, stringlen + 1);

        unsigned char *cp, *dst;
        _LocaleUpdate _loc_update(plocinfo);

        for (cp = string, dst = string; *cp != NULL; ++cp)
        {
            if (_ismbblead_l(*cp, _loc_update.GetLocaleT()))
            {


                int retval;
                unsigned char ret[4];
                if ((retval = __crtLCMapStringA(
                                _loc_update.GetLocaleT(),
                                _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                LCMAP_LOWERCASE,
                                (const char *)cp,
                                2,
                                (char *)ret,
                                2,
                                _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                TRUE )) == 0 )
                {
                    errno = EILSEQ;
                    _RESET_STRING(string, sizeInBytes);
                    return errno;
                }

                *(dst++) = ret[0];
                ++cp;
                if (retval > 1)
                {
                    *(dst++) = ret[1];
                }


            }
            else
            {
                /* single byte, macro version */
                *(dst++) = (unsigned char) _mbbtolower_l(*cp, _loc_update.GetLocaleT());
            }
        }
        /* null terminate the string */
        *dst = '\0';

        return 0;
}

errno_t (__cdecl _mbslwr_s)(
        unsigned char *string,
        size_t sizeInBytes
        )
{
    return _mbslwr_s_l(string, sizeInBytes, NULL);
}

unsigned char * (__cdecl _mbslwr_l)(
        unsigned char *string,
        _locale_t plocinfo
        )
{
    return (_mbslwr_s_l(string, (string == NULL ? 0 : (size_t)-1), plocinfo) == 0 ? string : NULL);
}

unsigned char * (__cdecl _mbslwr)(
        unsigned char *string
        )
{
    return (_mbslwr_s_l(string, (string == NULL ? 0 : (size_t)-1), NULL) == 0 ? string : NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcat.c ===
/***
*mbsnbcat.c - concatenate string2 onto string1, max length n bytes
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines mbsnbcat() - concatenate maximum of n bytes
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsnbcat - concatenate max cnt bytes onto dst
*
*Purpose:
*       Concatenates src onto dst, with a maximum of cnt bytes copied.
*       Handles 2-byte MBCS characters correctly.
*
*Entry:
*       unsigned char *dst - string to concatenate onto
*       unsigned char *src - string to concatenate from
*       int cnt - number of bytes to copy
*
*Exit:
*       returns dst, with src (at least part) concatenated on
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsnbcat_l(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt,
        _locale_t plocinfo
        )
{
        unsigned char *start;

        if (!cnt)
                return(dst);

        /* validation section */
        _VALIDATE_RETURN(dst != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(src != NULL, EINVAL, NULL);

        _LocaleUpdate _loc_update(plocinfo);

        _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)strncat((char *)dst, (const char *)src, cnt);
        _END_SECURE_CRT_DEPRECATION_DISABLE

        start = dst;
        while (*dst++)
                ;
        --dst;          // dst now points to end of dst string

        /* if last char in string is a lead byte, back up pointer */
        if ( dst!=start && _mbsbtype_l(start, (int) ((dst - start) - 1), _loc_update.GetLocaleT()) == _MBC_LEAD )
        {
            --dst;
        }

        /* copy over the characters */

        while (cnt--) {

            if ( _ismbblead_l(*src, _loc_update.GetLocaleT()) ) {
                *dst++ = *src++;
                if (cnt == 0) {   /* write null if cnt exhausted */
                    dst[-1] = '\0';
                    break;
                }
                cnt--;
                if ((*dst++ = *src++)=='\0') { /* or if no trail byte */
                    dst[-2] = '\0';
                    break;
                }
            }
            else if ((*dst++ = *src++) == '\0')
                break;

        }

        if ( dst!=start && _mbsbtype_l(start, (int) ((dst - start) - 1), _loc_update.GetLocaleT()) == _MBC_LEAD )
        {
            dst[-1] = '\0';
        }
        else
        {
            *dst = '\0';
        }

        return(start);
}

extern "C" unsigned char * (__cdecl _mbsnbcat)(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt
        )
{
    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsnbcat_l(dst, src, cnt, NULL);
    _END_SECURE_CRT_DEPRECATION_DISABLE
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcnt.c ===
/***
*mbsnbcnt.c - Returns byte count of MBCS string
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Returns byte count of MBCS string
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnbcnt - Returns byte count of MBCS string
*
*Purpose:
*       Returns the number of bytes between the start of the supplied
*       string and the char count supplied.  That is, this routine
*       indicates how many bytes are in the first "ccnt" characters
*       of the string.
*
*Entry:
*       unsigned char *string = pointer to string
*       unsigned int ccnt = number of characters to scan
*
*Exit:
*       Returns number of bytes between string and ccnt.
*
*       If the end of the string is encountered before ccnt chars were
*       scanned, then the length of the string in bytes is returned.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" size_t __cdecl _mbsnbcnt_l(
        const unsigned char *string,
        size_t ccnt,
        _locale_t plocinfo
        )
{
        unsigned char *p;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(string != NULL || ccnt == 0, EINVAL, 0);

        for (p = (unsigned char *)string; (ccnt-- && *p); p++) {
            if ( _ismbblead_l(*p, _loc_update.GetLocaleT()) ) {
                if (*++p == '\0') {
                    --p;
                    break;
                }
            }
        }

        return ((size_t) ((char *)p - (char *)string));
}

extern "C" size_t (__cdecl _mbsnbcnt)(
        const unsigned char *string,
        size_t ccnt
        )
{
        return _mbsnbcnt_l(string, ccnt, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbscmp.c ===
/***
*mbscmp.c - Compare MBCS strings
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Compare MBCS strings
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbscmp - Compare MBCS strings
*
*Purpose:
*       Compares two strings for lexical order.   Strings
*       are compared on a character basis, not a byte basis.
*
*Entry:
*       char *s1, *s2 = strings to compare
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbscmp_l(
        const unsigned char *s1,
        const unsigned char *s2,
        _locale_t plocinfo
        )
{
        unsigned short c1, c2;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return strcmp((const char *)s1, (const char *)s2);

        for (;;) {

            c1 = *s1++;
            if ( _ismbblead_l(c1, _loc_update.GetLocaleT()) )
                c1 = ( (*s1 == '\0') ? 0 : ((c1<<8) | *s1++) );

            c2 = *s2++;
            if ( _ismbblead_l(c2, _loc_update.GetLocaleT()) )
                c2 = ( (*s2 == '\0') ? 0 : ((c2<<8) | *s2++) );

            if (c1 != c2)
                return (c1 > c2) ? 1 : -1;

            if (c1 == 0)
                return 0;

        }
}

extern "C" int (__cdecl _mbscmp)(
        const unsigned char *s1,
        const unsigned char *s2
        )
{
    return _mbscmp_l(s1, s2, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsicmp.c ===
/***
*mbsicmp.c - Case-insensitive string comparision routine (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Case-insensitive string comparision routine (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsicmp - Case-insensitive string comparision routine (MBCS)
*
*Purpose:
*       Compares two strings for lexical order without regard to case.
*       Strings are compared on a character basis, not a byte basis.
*
*Entry:
*       char *s1, *s2 = strings to compare
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR if something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsicmp_l(
        const unsigned char *s1,
        const unsigned char *s2,
        _locale_t plocinfo
        )
{
        unsigned short c1, c2;
        _LocaleUpdate _loc_update(plocinfo);
        int    retval;
        unsigned char szResult[4];

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _stricmp_l((const char *)s1, (const char *)s2, _loc_update.GetLocaleT());

        for (;;)
        {
            c1 = *s1++;
            if ( _ismbblead_l(c1, _loc_update.GetLocaleT()) )
            {
                if (*s1 == '\0')
                    c1 = 0;
                else
                {
                    retval = __crtLCMapStringA(
                            _loc_update.GetLocaleT(),
                            _loc_update.GetLocaleT()->mbcinfo->mblcid,
                            LCMAP_UPPERCASE,
                            (LPCSTR)s1 - 1,
                            2,
                            (LPSTR)szResult,
                            2,
                            _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                            TRUE );

                    if (retval == 1)
                        c1 = szResult[0];
                    else if (retval == 2)
                        c1 = (szResult[0] << 8) + szResult[1];
                    else
                    {
                        errno = EINVAL;
                        return _NLSCMPERROR;
                    }
                    s1++;
                }
            }
            else
                c1 = _mbbtolower_l(c1, _loc_update.GetLocaleT());

            c2 = *s2++;
            if ( _ismbblead_l(c2, _loc_update.GetLocaleT()) )
            {
                if (*s2 == '\0')
                    c2 = 0;
                else
                {
                    retval = __crtLCMapStringA(
                            _loc_update.GetLocaleT(),
                            _loc_update.GetLocaleT()->mbcinfo->mblcid,
                            LCMAP_UPPERCASE,
                            (LPCSTR)s2 - 1,
                            2,
                            (LPSTR)szResult,
                            2,
                            _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                            TRUE );

                    if (retval == 1)
                        c2 = szResult[0];
                    else if (retval == 2)
                        c2 = (szResult[0] << 8) + szResult[1];
                    else
                    {
                        errno = EINVAL;
                        return _NLSCMPERROR;
                    }
                    s2++;
                }
            }
            else
                c2 = _mbbtolower_l(c2, _loc_update.GetLocaleT());

            if (c1 != c2)
                return( (c1 > c2) ? 1 : -1 );

            if (c1 == 0)
                return(0);
        }
}

extern "C" int (__cdecl _mbsicmp)(
        const unsigned char *s1,
        const unsigned char *s2
        )
{
    return _mbsicmp_l(s1, s2, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcat_s.c ===
/***
*mbsnbcat_s.c - concatenate string2 onto string1, max length n bytes
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines mbsnbcat_s() - concatenate maximum of n bytes
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnbcat_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInBytes
#define _COUNT_IN_BYTES 1

#include <mbsncat_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbsnbcat_s, unsigned char *, size_t, const unsigned char *, size_t)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcat_s_l.c ===
/***
*mbsnbcat_s_l.c - concatenate string2 onto string1, max length n bytes
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines mbsnbcat_s_l() - concatenate maximum of n bytes
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnbcat_s_l
#define _SB_FUNC_NAME strncat_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInBytes
#define _COUNT_IN_BYTES 1

#include <mbsncat_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcmp.c ===
/***
*mbsnbcmp.c - Compare n bytes of two MBCS strings
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Compare n bytes of two MBCS strings
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
*int mbsnbcmp(s1, s2, n) - Compare n bytes of two MBCS strings
*
*Purpose:
*       Compares up to n bytes of two strings for lexical order.
*
*Entry:
*       unsigned char *s1, *s2 = strings to compare
*       size_t n = maximum number of bytes to compare
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsnbcmp_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        unsigned short c1, c2;

        if (n==0)
                return(0);

        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return strncmp((const char *)s1, (const char *)s2, n);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        while (n--) {

            c1 = *s1++;
            if ( _ismbblead_l(c1, _loc_update.GetLocaleT()) )
            {
                if (n==0)
                {
                    c1 = 0; /* 'naked' lead - end of string */
                    c2 = _ismbblead_l(*s2, _loc_update.GetLocaleT()) ? 0 : *s2;
                    goto test;
                }
                c1 = ( (*s1 == '\0') ? 0 : ((c1<<8) | *s1++) );
            }

            c2 = *s2++;
            if ( _ismbblead_l(c2, _loc_update.GetLocaleT()) )
            {
                if (n==0)
                {
                    c2 = 0; /* 'naked' lead - end of string */
                    goto test;
                }
                --n;
                c2 = ( (*s2 == '\0') ? 0 : ((c2<<8) | *s2++) );
            }
test:
            if (c1 != c2)
                return( (c1 > c2) ? 1 : -1);

            if (c1 == 0)
                return(0);
        }

        return(0);
}

extern "C" int (__cdecl _mbsnbcmp)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsnbcmp_l(s1, s2, n, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcpy.c ===
/***
*mbsnbcpy.c - Copy one string to another, n bytes only (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another, n bytes only (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnbcpy - Copy one string to another, n bytes only (MBCS)
*
*Purpose:
*       Copies exactly cnt bytes from src to dst.  If strlen(src) < cnt, the
*       remaining character are padded with null bytes.  If strlen >= cnt, no
*       terminating null byte is added.  2-byte MBCS characters are handled
*       correctly.
*
*Entry:
*       unsigned char *dst = destination for copy
*       unsigned char *src = source for copy
*       int cnt = number of bytes to copy
*
*Exit:
*       returns dst = destination of copy
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

unsigned char * __cdecl _mbsnbcpy_l(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt,
        _locale_t plocinfo
        )
{

        unsigned char *start = dst;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(dst != NULL || cnt == 0, EINVAL, NULL);
        _VALIDATE_RETURN(src != NULL || cnt == 0, EINVAL, NULL);

        _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)strncpy((char *)dst, (const char *)src, cnt);
        _END_SECURE_CRT_DEPRECATION_DISABLE

        while (cnt) {

            cnt--;
            if ( _ismbblead_l(*src, _loc_update.GetLocaleT()) ) {
                *dst++ = *src++;
                if (!cnt) {
                    dst[-1] = '\0';
                    break;
                }
                cnt--;
                if ((*dst++ = *src++) == '\0') {
                    dst[-2] = '\0';
                    break;
                }
            }

            else
                if ((*dst++ = *src++) == '\0')
                    break;

        }

        /* pad with nulls as needed */

        while (cnt--)
            *dst++ = '\0';

        return start;
}
unsigned char * (__cdecl _mbsnbcpy)(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt
        )
{
    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsnbcpy_l(dst, src, cnt, NULL);
    _END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcpy_s_l.c ===
/***
*mbsnbcpy_s_l.c - Copy one string to another, n bytes only (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another, n bytes only (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnbcpy_s_l
#define _SB_FUNC_NAME strncpy_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInBytes
#define _COUNT_IN_BYTES 1

#include <mbsncpy_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcpy_s.c ===
/***
*mbsnbcpy_s.c - Copy one string to another, n bytes only (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another, n bytes only (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnbcpy_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInBytes
#define _COUNT_IN_BYTES 1

#include <mbsncpy_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbsnbcpy_s, unsigned char *, size_t, const unsigned char *, size_t)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsinc.c ===
/***
*mbsinc.c - Move MBCS string pointer ahead one charcter.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Move MBCS string pointer ahead one character.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <stddef.h>
#include <internal.h>

/***
*_mbsinc - Move MBCS string pointer ahead one charcter.
*
*Purpose:
*       Move the supplied string pointer ahead by one
*       character.  MBCS characters are handled correctly.
*
*Entry:
*       const unsigned char *current = current char pointer (legal MBCS boundary)
*
*Exit:
*       Returns pointer after moving it.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

unsigned char * __cdecl _mbsinc_l(
        const unsigned char *current,
        _locale_t plocinfo
        )
{
        if ( (_ismbblead_l)(*(current++),plocinfo))
        {
            /* don't move forward two if we get leadbyte, EOS
               also don't assert here as we are too low level
            */
            if(*current!='\0')
            {
                current++;
            }
        }

        return (unsigned char *)current;
}

unsigned char * (__cdecl _mbsinc)(
        const unsigned char *current
        )
{
        /* validation section */
        _VALIDATE_RETURN(current != NULL, EINVAL, NULL);

        if ( _ismbblead(*(current++)))
        {
            /* don't move forward two if we get leadbyte, EOS
               also don't assert here as we are too low level
            */
            if(*current!='\0')
            {
                current++;
            }
        }

        return (unsigned char *)current;
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbset.c ===
/***
*mbsnbset.c - Sets first n bytes of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets first n bytes of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <crtdbg.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnbset - Sets first n bytes of string to given character (MBCS)
*
*Purpose:
*       Sets the first n bytes of string to the supplied
*       character value.  If the length of string is less than n,
*       the length of string is used in place of n.  Handles
*       MBCS chars correctly.
*
*       There are several factors that make this routine complicated:
*               (1) The fill value may be 1 or 2 bytes long.
*               (2) The fill operation may end by hitting the count value
*               or by hitting the end of the string.
*               (3) A null terminating char is NOT placed at the end of
*               the string.
*
*       Cases to be careful of (both of these can occur at once):
*               (1) Leaving an "orphaned" trail byte in the string (e.g.,
*               overwriting a lead byte but not the corresponding trail byte).
*               (2) Writing only the 1st byte of a 2-byte fill value because the
*               end of string was encountered.
*
*Entry:
*       unsigned char *string = string to modify
*       unsigned int val = value to fill string with
*       size_t count = count of characters to fill
*
*
*Exit:
*       Returns string = now filled with char val
*
*Uses:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsnbset_l(
        unsigned char *string,
        unsigned int val,
        size_t count,
        _locale_t plocinfo
        )
{
        unsigned char *start = string;
        unsigned char highval, lowval;
        _LocaleUpdate _loc_update(plocinfo);

_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)_strnset((char *)string, val, count);
_END_SECURE_CRT_DEPRECATION_DISABLE

        /* validation section */
        _VALIDATE_RETURN(string != NULL || count == 0, EINVAL, NULL);

        /*
         * leadbyte flag indicates if the last byte we overwrote was
         * a lead byte or not.
         */

        if (highval = (unsigned char)(val>>8)) {

                /* double byte value */

                lowval = (unsigned char)(val & 0x00ff);

                if(lowval=='\0')
                {
                    _ASSERTE(("invalid MBCS pair passed to mbsnbset",0));

                    /* Ideally we would return NULL here and signal an error
                       condition. But since this function has no other
                       error modes, there would be a good chance of crashing
                       the caller. So instead we fill the string with spaces
                       to ensure that no information leaks through
                       unexpectedly. Anyway, we do set errno to EINVAL.
                    */
                    errno = EINVAL;
                    lowval=highval=' ';
                }

                while ((count--) && *string) {

                        /* pad with ' ' if no room for both bytes -- odd len */
                        if ((!count--) || (!*(string+1))) {
                                *string = ' ';
                                break;
                        }

                        *string++ = highval;
                        *string++ = lowval;
                }
        }

        else {
                /* single byte value */

                while (count-- && *string) {
                        *string++ = (unsigned char)val;
                }

        }

        return( start );
}

extern "C" unsigned char * (__cdecl _mbsnbset)(
        unsigned char *string,
        unsigned int val,
        size_t count
        )
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsnbset_l(string, val, count, NULL);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbslen_s.c ===
/***
*mbslen_s.c - Find length of MBCS string
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Find length of MBCS string
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnlen - Find length of MBCS string
*
*Purpose:
*       Find the length of the MBCS string (in characters).
*
*Entry:
*       unsigned char *s = string
*       size_t maxsize
*
*Exit:
*       Returns the number of MBCS chars in the string.
*       Only the first sizeInBytes bytes of the string are inspected: if the null
*       terminator is not found, sizeInBytes is returned.
*       If the string is null terminated in sizeInBytes bytes, the return value
*       will always be less than sizeInBytes.
*       Returns (size_t)-1 if something went wrong.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

size_t __cdecl _mbsnlen_l(
        const unsigned char *s,
        size_t sizeInBytes,
        _locale_t plocinfo
        )
{
        size_t n, size;
        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return strnlen((const char *)s, sizeInBytes);

        /* Note that we do not check if s == NULL, because we do not
         * return errno_t...
         */

        /* Note that sizeInBytes here is the number of bytes, not mb characters! */
        for (n = 0, size = 0; size < sizeInBytes && *s; n++, s++, size++)
        {
            if ( _ismbblead_l(*s, _loc_update.GetLocaleT()) )
                        {
                                size++;
                                if (size >= sizeInBytes)
                                {
                                        break;
                                }
                if (*++s == '\0')
                                {
                    break;
                                }
            }
        }

                return (size >= sizeInBytes ? sizeInBytes : n);
}

size_t __cdecl _mbsnlen(
        const unsigned char *s,
        size_t maxsize
        )
{
    return _mbsnlen_l(s,maxsize, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbcol.c ===
/***
*mbsnbcol.c - Collate n bytes of two MBCS strings
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Collate n bytes of two MBCS strings
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <internal.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnbcoll(s1, s2, n) - Collate n bytes of two MBCS strings
*
*Purpose:
*       Collates up to n bytes of two strings for lexical order.
*
*Entry:
*       unsigned char *s1, *s2 = strings to collate
*       size_t n = maximum number of bytes to collate
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsnbcoll_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        int ret;

        if (n == 0)
            return 0;

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(n <= INT_MAX, EINVAL, _NLSCMPERROR);

        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strncoll_l((const char *)s1, (const char *)s2, n, plocinfo);

        if ( 0 == (ret = __crtCompareStringA(_loc_update.GetLocaleT(),
                                              _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                              SORT_STRINGSORT,
                                              (const char *)s1,
                                              (int)n,
                                              (char *)s2,
                                              (int)n,
                                              _loc_update.GetLocaleT()->mbcinfo->mbcodepage )) )
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return ret - 2;

}

extern "C" int (__cdecl _mbsnbcoll)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsnbcoll_l(s1, s2, n, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbset_s_l.c ===
/***
*mbsset_s_l.c - Sets first n bytes of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets first n bytes of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnbset_s_l
#define _SB_FUNC_NAME _strnset_s
#define _DEST _Dst
#define _COUNT _CountInBytes
#define _COUNT_IN_BYTES 1

#include <mbsnset_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncat_s.c ===
/***
*mbsncat_s.c - concatenate string2 onto string1, max length n
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines mbsncat_s() - concatenate maximum of n characters
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsncat_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInChars
#define _COUNT_IN_BYTES 0

#include <mbsncat_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbsncat_s, unsigned char *, size_t, const unsigned char *, size_t)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncat.c ===
/***
*mbsncat.c - concatenate string2 onto string1, max length n
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines mbsncat() - concatenate maximum of n characters
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsncat - concatenate max cnt characters onto dst
*
*Purpose:
*       Concatenates src onto dst, with a maximum of cnt characters copied.
*       Handles 2-byte MBCS characters correctly.
*
*Entry:
*       unsigned char *dst - string to concatenate onto
*       unsigned char *src - string to concatenate from
*       int cnt - number of characters to copy
*
*Exit:
*       returns dst, with src (at least part) concatenated on
*
*Exceptions:
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsncat_l(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt,
        _locale_t plocinfo
        )
{
        unsigned char *start;

        if (!cnt)
            return(dst);

        /* validation section */
        _VALIDATE_RETURN(dst != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(src != NULL, EINVAL, NULL);

        _LocaleUpdate _loc_update(plocinfo);

        _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)strncat((char *)dst, (const char *)src, cnt);
        _END_SECURE_CRT_DEPRECATION_DISABLE

        start = dst;
        while (*dst++)
                ;
        --dst;          // dst now points to end of dst string


        /* if last char in string is a lead byte, back up pointer */

        if ( _ismbslead_l(start, dst, _loc_update.GetLocaleT()) )
            --dst;

        /* copy over the characters */

        while (cnt--) {
            if ( _ismbblead_l(*src, _loc_update.GetLocaleT()) ) {
                *dst++ = *src++;
                if ((*dst++ = *src++) == '\0') {
                    dst[-2] = '\0';
                    break;
                }
            }

            else if ((*dst++ = *src++) == '\0')
                break;

        }

        /* enter final nul, if necessary */
        if ( dst!=start && _mbsbtype_l(start, (int) ((dst - start) - 1), _loc_update.GetLocaleT()) == _MBC_LEAD )
        {
            dst[-1] = '\0';
        }
        else
        {
            *dst = '\0';
        }

        return(start);
}

extern "C" unsigned char * (__cdecl _mbsncat)(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt
        )
{
    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsncat_l(dst, src, cnt, NULL);
    _END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncat_s.inl ===
/***
*mbscat_s.inl - general implementation of _mbsncat_s and _mbsnbcat_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for _mbsncat_s and _mbsnbcat_s.
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC, size_t _COUNT, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC, size_t _COUNT)
#endif  /* _USE_LOCALE_ARG */
{
    unsigned char *p;
    size_t available;
    BOOL fIsLeadPrefix;
    BOOL fFoundInvalidMBC;

    fFoundInvalidMBC = FALSE;

    if (_COUNT == 0 && _DEST == NULL && _SizeInBytes == 0)
    {
        /* this case is allowed; nothing to do */
        _RETURN_NO_ERROR;
    }

    /* validation section */
    _VALIDATE_STRING(_DEST, _SizeInBytes);
    if (_COUNT != 0)
    {
        _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SizeInBytes);
    }

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return _SB_FUNC_NAME((char *)_DEST, _SizeInBytes, (const char *)_SRC, _COUNT);
    }
#endif  /* _USE_LOCALE_ARG */

    p = _DEST;
    available = _SizeInBytes;
    while (available > 0 && *p != 0)
    {
        p++;
        available--;
    }

    /*
     * Ran out of room while looking for end of dst string.
     * p points 1 past end of buffer. We can't look past
     * end of buffer so can't tell if dst ended with an
     * invalid mbc.
     */

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SizeInBytes);
    }


    if (available < _SizeInBytes)
    {
        /*
         * Dst may have terminated with an invalid MBCS, in that case we clear
         * the bogus lead byte.
         */
        fIsLeadPrefix = FALSE;
        _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, &p[-1]);
        if (fIsLeadPrefix) {
            /* the original string ended with a lead byte: we remove it */
            p--;
            *p = 0;
            available++;
            fFoundInvalidMBC = TRUE;
        }
    }

    if (_COUNT == _TRUNCATE)
    {
        while ((*p++ = *_SRC++) != 0 && --available > 0)
        {
        }
    }
    else
    {
        _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT < available), L"Buffer is too small");

#if _COUNT_IN_BYTES
        while (_COUNT > 0 && (*p++ = *_SRC++) != 0 && --available > 0)
        {
            _COUNT--;
        }
#else  /* _COUNT_IN_BYTES */
        while (_COUNT > 0)
        {
            if (_ISMBBLEAD(*_SRC))
            {
                if (_SRC[1] == 0)
                {
                    /* the source string ended with a lead byte: we remove it */
                    *p = 0;
                    fFoundInvalidMBC = TRUE;
                    break;
                }
                if (available <= 2)
                {
                    /* not enough space */
                    available = 0;
                    break;
                }
                *p++ = *_SRC++;
                *p++ = *_SRC++;
                available -= 2;
            }
            else
            {
                if ((*p++ = *_SRC++) == 0 || --available == 0)
                {
                    break;
                }
            }
            _COUNT--;
        }
#endif  /* _COUNT_IN_BYTES */
        if (_COUNT == 0)
        {
            *p++ = 0;
        }
    }

    if (available == 0)
    {
#if _COUNT_IN_BYTES
        /*
         * defined(_COUNT_IN_BYTES) loop does not track mbc context,
         * so we must iterate backwards to discover character context.
         */
        if (*_SRC == 0 || _COUNT == 1)
        {
            _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, &p[-1]);
            if (fIsLeadPrefix)
            {
                /* the source string ended with a lead byte: we remove it */
                p[-1] = 0;
                _RETURN_MBCS_ERROR;
            }
        }
#endif  /* _COUNT_IN_BYTES */

        /*
         * _COUNT == _TRUNCATE loop terminated because available became 0.
         * This means that we copied at least one character, and it wasn't
         * a null. If this last character acted as a lead then overwrite
         * it with null. Do not set the mbcs error in this case, due that the
         * user cannot predict this case and he/she's only asking for truncation.
         */
        if (_COUNT == _TRUNCATE)
        {
            if (fFoundInvalidMBC)
            {
                _SET_MBCS_ERROR;
            }

            if (_SizeInBytes > 1)
            {
                fIsLeadPrefix = FALSE;
                _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, &_DEST[_SizeInBytes - 2]);
                if (fIsLeadPrefix)
                {
                    _DEST[_SizeInBytes - 2] = 0;
                    _FILL_BYTE(_DEST[_SizeInBytes - 1]);
                    _RETURN_TRUNCATE;
                }
            }

            _DEST[_SizeInBytes - 1] = 0;

            _RETURN_TRUNCATE;
        }
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SizeInBytes);
    }
#if _COUNT_IN_BYTES
    if (available < _SizeInBytes)
    {
        _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, &p[-2]);
        if (fIsLeadPrefix)
        {
            /* the source string ended with a lead byte: we remove it */
            p[-2] = 0;
            available++;
            fFoundInvalidMBC = TRUE;
        }
    }
#endif  /* _COUNT_IN_BYTES */
    _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);

    if (fFoundInvalidMBC)
    {
        _RETURN_MBCS_ERROR;
    }

    _RETURN_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnccnt.c ===
/***
*mbsnccnt.c - Return char count of MBCS string
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Return char count of MBCS string
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnccnt - Return char count of MBCS string
*
*Purpose:
*       Returns the number of chars between the start of the supplied
*       string and the byte count supplied.  That is, this routine
*       indicates how many chars are in the first "bcnt" bytes
*       of the string.
*
*Entry:
*       const unsigned char *string = pointer to string
*       unsigned int bcnt = number of bytes to scan
*
*Exit:
*       Returns number of chars between string and bcnt.
*
*       If the end of the string is encountered before bcnt chars were
*       scanned, then the length of the string in chars is returned.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" size_t __cdecl _mbsnccnt_l(
        const unsigned char *string,
        size_t bcnt,
        _locale_t plocinfo
        )
{
        size_t n;
        _LocaleUpdate _loc_update(plocinfo);

        _VALIDATE_RETURN(string != NULL || bcnt == 0, EINVAL, 0);

        for (n = 0; (bcnt-- && *string); n++, string++) {
            if ( _ismbblead_l(*string, _loc_update.GetLocaleT()) ) {
                if ( (!bcnt--) || (*++string == '\0'))
                    break;
            }
        }

        return(n);
}
extern "C" size_t (__cdecl _mbsnccnt)(
        const unsigned char *string,
        size_t bcnt
        )
{
    return _mbsnccnt_l(string, bcnt, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncmp.c ===
/***
*mbsncmp.c - Compare n characters of two MBCS strings
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Compare n characters of two MBCS strings
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
*int mbsncmp(s1, s2, n) - Compare n characters of two MBCS strings
*
*Purpose:
*       Compares up to n charcters of two strings for lexical order.
*       Strings are compared on a character basis, not a byte basis.
*
*Entry:
*       unsigned char *s1, *s2 = strings to compare
*       size_t n = maximum number of characters to compare
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsncmp_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        unsigned short c1, c2;
        _LocaleUpdate _loc_update(plocinfo);

        if (n==0)
            return(0);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return strncmp((const char *)s1, (const char *)s2, n);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        while (n--) {

            c1 = *s1++;
            if ( _ismbblead_l(c1, _loc_update.GetLocaleT()) )
                c1 = ( (*s1 == '\0') ? 0 : ((c1<<8) | *s1++) );

            c2 = *s2++;
            if ( _ismbblead_l(c2, _loc_update.GetLocaleT()) )
                c2 = ( (*s2 == '\0') ? 0 : ((c2<<8) | *s2++) );

            if (c1 != c2)
                return( (c1 > c2) ? 1 : -1);

            if (c1 == 0)
                return(0);
        }

        return(0);
}

extern "C" int (__cdecl _mbsncmp)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsncmp_l(s1, s2, n, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncpy.c ===
/***
*mbsncpy.c - Copy one string to another, n chars only (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another, n chars only (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsncpy - Copy one string to another, n chars only (MBCS)
*
*Purpose:
*       Copies exactly cnt character from src to dst.  If strlen(src) < cnt, the
*       remaining character are padded with null bytes.  If strlen >= cnt, no
*       terminating null byte is added.  2-byte MBCS characters are handled
*       correctly.
*
*Entry:
*       unsigned char *dst = destination for copy
*       unsigned char *src = source for copy
*       int cnt = number of characters to copy
*
*Exit:
*       returns dst = destination of copy
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsncpy_l(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt,
        _locale_t plocinfo
        )
{

        unsigned char *start = dst;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(dst != NULL || cnt == 0, EINVAL, NULL);
        _VALIDATE_RETURN(src != NULL || cnt == 0, EINVAL, NULL);

        _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)strncpy((char *)dst, (const char *)src, cnt);
        _END_SECURE_CRT_DEPRECATION_DISABLE

        while (cnt) {

            cnt--;
            if ( _ismbblead_l(*src, _loc_update.GetLocaleT()) ) {
                *dst++ = *src++;
                if ((*dst++ = *src++) == '\0') {
                    dst[-2] = '\0';
                    break;
                }
            }
            else
                if ((*dst++ = *src++) == '\0')
                    break;

        }

        /* pad with nulls as needed */

        while (cnt--)
            *dst++ = '\0';

        return start;
}
extern "C" unsigned char * (__cdecl _mbsncpy)(
        unsigned char *dst,
        const unsigned char *src,
        size_t cnt
        )
{
    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsncpy_l(dst, src, cnt, NULL);
    _END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncpy_s.c ===
/***
*mbsncpy_s.c - Copy one string to another, n chars only (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another, n chars only (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsncpy_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInChars
#define _COUNT_IN_BYTES 0

#include <mbsncpy_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbsncpy_s, unsigned char *, size_t, const unsigned char *, size_t)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncpy_s.inl ===
/***
*mbsncpy_s.inl - general implementation of _mbsncpy_s and _mbsnbcpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for _mbsncpy_s and _mbsnbcpy_s.
*
*       _COUNT_IN_BYTES defined to 1 implements _mbsnbcpy_s
*       _COUNT_IN_BYTES defined to 0 implements _mbsncpy_s
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC, size_t _COUNT, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, const unsigned char *_SRC, size_t _COUNT)
#endif  /* _USE_LOCALE_ARG */
{
    unsigned char *p;
    size_t available;
    BOOL fFoundInvalidMBC;
    BOOL fIsLeadPrefix;

    fFoundInvalidMBC = FALSE;

    if (_COUNT == 0 && _DEST == NULL && _SizeInBytes == 0)
    {
        /* this case is allowed; nothing to do */
        _RETURN_NO_ERROR;
    }

    /* validation section */
    _VALIDATE_STRING(_DEST, _SizeInBytes);
    if (_COUNT == 0)
    {
        /* notice that the source string pointer can be NULL in this case */
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_NO_ERROR;
    }
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SizeInBytes);

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return _SB_FUNC_NAME((char *)_DEST, _SizeInBytes, (const char *)_SRC, _COUNT);
    }
#endif  /* _USE_LOCALE_ARG */

    p = _DEST;
    available = _SizeInBytes;
    if (_COUNT == _TRUNCATE)
    {
        while ((*p++ = *_SRC++) != 0 && --available > 0)
        {
        }

        /*
         * loop terminates with either:
         * - src, p pointing 1 byte past null, avail includes the null
         * - available == 0, p points 1 past end of dst buffer
         */
    }
    else
    {
        _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT < _SizeInBytes), L"Buffer is too small");

#if _COUNT_IN_BYTES
        while ((*p++ = *_SRC++) != 0 && --available > 0 && --_COUNT > 0)
        {
        }

        /*
         * loop terminates with either:
         * - p points 1 byte past null, avail includes null, count includes null
         * - available == 0, p points 1 past end of dst buffer (inaccessible)
         * - count == 0, p points 1 past last written byte, space available in dst buffer
         *
         * always p[-1] is written.
         * sometimes p[-1] is null.
         */
#else  /* _COUNT_IN_BYTES */

        /* at this point, avail count be 1. */

        /* Need to track lead-byte context in order to track character count. */
        do
        {
            if (_ISMBBLEAD(*_SRC))
            {
                if (_SRC[1] == 0)
                {
                    /*
                     * Invalid MBC, write null to dst string, we are finished
                     * copying. We know that available is >= 1, so there is
                     * room for the null termination. If we decrement available
                     * then we will incorrectly report BUFFER_TOO_SMALL.
                     */

                    *p++ = 0;
                    fFoundInvalidMBC = TRUE;
                    break;
                }
                if (available <= 2)
                {
                    /* not enough space for a dbc and null */
                    available = 0;
                    break;
                }
                *p++ = *_SRC++;
                *p++ = *_SRC++;
                available -= 2;
            }
            else
            {
                if ((*p++ = *_SRC++) == 0 || --available == 0)
                {
                    break;
                }
            }
        }
        while (--_COUNT > 0);
#endif  /* _COUNT_IN_BYTES */

        /* If count == 0 then at least one byte was copied and available is still > 0 */
        if (_COUNT == 0)
        {
            *p++ = 0;
            /* Note that available is not decremented here. */
        }
    }

    if (available == 0)
    {
#if _COUNT_IN_BYTES
        /*
         * For COUNT_IN_BYTES, the above loop copied at least one byte so src,p point
         * past a written byte.
         */

        if (*_SRC == 0 || _COUNT == 1)
        {
            fIsLeadPrefix = FALSE;
            _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST, &p[-1]);
            if (fIsLeadPrefix)
            {
                /* the source string ended with a lead byte: we remove it */
                p[-1] = 0;
                _RETURN_MBCS_ERROR;
            }
        }
#endif  /* _COUNT_IN_BYTES */

        if (_COUNT == _TRUNCATE)
        {
            if (fFoundInvalidMBC)
            {
                _SET_MBCS_ERROR;
            }

            if (_SizeInBytes > 1)
            {
                fIsLeadPrefix = FALSE;
                /* Check if 2nd to last copied byte acted as a lead.
                 * Do not set mbcs error because we are truncating.
                 */
                _ISMBBLEADPREFIX(fIsLeadPrefix,_DEST,&_DEST[_SizeInBytes - 2]);
                if (fIsLeadPrefix)
                {
                    _DEST[_SizeInBytes - 2] = 0;
                    _FILL_BYTE(_DEST[_SizeInBytes - 1]);
                    _RETURN_TRUNCATE;
                }
            }

            _DEST[_SizeInBytes - 1] = 0;
            _RETURN_TRUNCATE;
        }
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SizeInBytes);
    }

#if _COUNT_IN_BYTES
    /*
     * COUNT_IN_BYTES copy loop doesn't track lead-byte context, so can't detect
     * invalid mbc. Detect them here.

     * available < _SizeInBytes means that at least one byte was copied so p is >= &dstBuffer[1]
     */

    if ((p - _DEST) >= 2)
    {
        _ISMBBLEADPREFIX(fIsLeadPrefix, _DEST,&p[-2]);
        if (fIsLeadPrefix)
        {
            /* the source string ended with a lead byte: we remove it */
            p[-2] = 0;
            available++;
            fFoundInvalidMBC = TRUE;
        }
    }
#endif  /* _COUNT_IN_BYTES */

    _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);

    if (fFoundInvalidMBC)
    {
        _RETURN_MBCS_ERROR;
    }

    _RETURN_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnextc.c ===
/***
*mbsnextc.c - Get the next character in an MBCS string.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To return the value of the next character in an MBCS string.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <internal.h>
#include <stdlib.h>
#include <locale.h>
#include <setlocal.h>

/***
*_mbsnextc:  Returns the next character in a string.
*
*Purpose:
*       To return the value of the next character in an MBCS string.
*       Does not advance pointer to the next character.
*
*Entry:
*       unsigned char *s = string
*
*Exit:
*       unsigned int next = next character.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned int __cdecl _mbsnextc_l(
        const unsigned char *s,
        _locale_t plocinfo
        )
{
        unsigned int  next = 0;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(s != NULL, EINVAL, 0);

        /* don't skip forward 2 if the leadbyte is followed by EOS (dud string)
           also don't assert as we are too low-level
        */
        if ( _ismbblead_l(*s, _loc_update.GetLocaleT()) && s[1]!='\0')
            next = ((unsigned int) *s++) << 8;

        next += (unsigned int) *s;

        return(next);
}
extern "C" unsigned int (__cdecl _mbsnextc)(
        const unsigned char *s
        )
{
    return _mbsnextc_l(s, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnicol.c ===
/***
*mbsnicol.c - Collate n characters of strings, ignoring case (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Collate n characters of strings, ignoring case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <internal.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsnicoll - Collate n characters of strings, ignoring case (MBCS)
*
*Purpose:
*       Collates up to n charcters of two strings for lexical order.
*       Strings are collated on a character basis, not a byte basis.
*       Case of characters is not considered.
*
*Entry:
*       unsigned char *s1, *s2 = strings to collate
*       size_t n = maximum number of characters to collate
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsnicoll_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        int ret;
        size_t bcnt1, bcnt2;
        _LocaleUpdate _loc_update(plocinfo);

        if (n == 0)
            return 0;

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(n <= INT_MAX, EINVAL, _NLSCMPERROR);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strnicoll_l((const char *)s1, (const char *)s2, n, plocinfo);

        bcnt1 = _mbsnbcnt_l(s1, n, _loc_update.GetLocaleT());
        bcnt2 = _mbsnbcnt_l(s2, n, _loc_update.GetLocaleT());

        if ( 0 == (ret = __crtCompareStringA(
                        _loc_update.GetLocaleT(),
                        _loc_update.GetLocaleT()->mbcinfo->mblcid,
                        SORT_STRINGSORT | NORM_IGNORECASE,
                        (const char *)s1,
                        (int)bcnt1,
                        (char *)s2,
                        (int)bcnt2,
                        _loc_update.GetLocaleT()->mbcinfo->mbcodepage )) )
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return ret - 2;

}

extern "C" int (__cdecl _mbsnicoll)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsnicoll_l(s1, s2, n, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbset_s.c ===
/***
*mbsnbset_s.c - Sets first n bytes of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets first n bytes of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnbset_s
#define _DEST _Dst
#define _COUNT _CountInBytes
#define _COUNT_IN_BYTES 1

#include <mbsnset_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbsnbset_s, unsigned char *, size_t, unsigned int, size_t)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbico.c ===
/***
*mbsnbico.c - Collate n bytes of strings, ignoring case (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Collate n bytes of strings, ignoring case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <internal.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsnbicoll - Collate n bytes of strings, ignoring case (MBCS)
*
*Purpose:
*       Collates up to n bytes of two strings for lexical order.
*       Strings are collated on a character basis, not a byte basis.
*       Case of characters is not considered.
*
*Entry:
*       unsigned char *s1, *s2 = strings to collate
*       size_t n = maximum number of bytes to collate
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsnbicoll_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        int ret;
        _LocaleUpdate _loc_update(plocinfo);

        if (n == 0)
            return 0;

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(n <= INT_MAX, EINVAL, _NLSCMPERROR);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strnicoll_l((const char *)s1, (const char *)s2, n, plocinfo);

        if ( 0 == (ret = __crtCompareStringA(_loc_update.GetLocaleT(),  _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              (const char *)s1,
                                              (int)n,
                                              (char *)s2,
                                              (int)n,
                                              _loc_update.GetLocaleT()->mbcinfo->mbcodepage )) )
            return _NLSCMPERROR;

        return ret - 2;

}
extern "C" int __cdecl _mbsnbicoll(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsnbicoll_l(s1, s2, n, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnbicm.c ===
/***
*mbsnbicmp.c - Compare n bytes of strings, ignoring case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Compare n bytes of strings, ignoring case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnbicmp - Compare n bytes of strings, ignoring case (MBCS)
*
*Purpose:
*       Compares up to n bytes of two strings for lexical order.
*       Strings are compared on a character basis, not a byte basis.
*       Case of characters is not considered.
*
*Entry:
*       unsigned char *s1, *s2 = strings to compare
*       size_t n = maximum number of bytes to compare
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

int __cdecl _mbsnbicmp_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        unsigned short c1, c2;
        _LocaleUpdate _loc_update(plocinfo);

        if (n==0)
            return(0);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strnicmp((const char *)s1, (const char *)s2, n);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        while (n--) {

            c1 = *s1++;
            if ( _ismbblead_l(c1, _loc_update.GetLocaleT()) )
            {
                if (n==0)
                {
                    c1 = 0; /* 'naked' lead - end of string */
                    c2 = _ismbblead_l(*s2, _loc_update.GetLocaleT()) ? 0 : *s2;
                    goto test;
                }
                if (*s1 == '\0')
                    c1 = 0;
                else {
                    c1 = ((c1<<8) | *s1++);

                    if ( ((c1 >= _MBUPPERLOW1_MT(_loc_update.GetLocaleT())) &&
                          (c1 <= _MBUPPERHIGH1_MT(_loc_update.GetLocaleT()))) )
                        c1 += _MBCASEDIFF1_MT(_loc_update.GetLocaleT());
                    else if ( ((c1 >= _MBUPPERLOW2_MT(_loc_update.GetLocaleT())) &&
                               (c1 <= _MBUPPERHIGH2_MT(_loc_update.GetLocaleT()))) )
                        c1 += _MBCASEDIFF2_MT(_loc_update.GetLocaleT());
                }
            }
            else
                c1 = _mbbtolower_l(c1, _loc_update.GetLocaleT());

                c2 = *s2++;
                if ( _ismbblead_l(c2, _loc_update.GetLocaleT()) )
                {
                    if (n==0)
                    {
                        c2 = 0; /* 'naked' lead - end of string */
                        goto test;
                    }
                    n--;
                    if (*s2 == '\0')
                        c2 = 0;
                    else {
                        c2 = ((c2<<8) | *s2++);

                        if ( ((c2 >= _MBUPPERLOW1_MT(_loc_update.GetLocaleT())) &&
                              (c2 <= _MBUPPERHIGH1_MT(_loc_update.GetLocaleT()))) )
                            c2 += _MBCASEDIFF1_MT(_loc_update.GetLocaleT());
                        else if ( ((c2 >= _MBUPPERLOW2_MT(_loc_update.GetLocaleT())) &&
                                   (c2 <= _MBUPPERHIGH2_MT(_loc_update.GetLocaleT()))) )
                            c2 += _MBCASEDIFF2_MT(_loc_update.GetLocaleT());
                    }
                }
                else
                    c2 = _mbbtolower_l(c2, _loc_update.GetLocaleT());

test:
            if (c1 != c2)
                return( (c1 > c2) ? 1 : -1);

            if (c1 == 0)
                return(0);
        }

        return(0);
}

int (__cdecl _mbsnbicmp)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsnbicmp_l(s1, s2, n, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsninc.c ===
/***
*mbsninc.c - Increment MBCS string pointer by specified char count.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Increment MBCS string pointer by specified char count.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <stddef.h>

/***
*_mbsninc - Increment MBCS string pointer by specified char count.
*
*Purpose:
*       Increment the supplied string pointer by the specified number
*       of characters.  MBCS characters are handled correctly.
*
*Entry:
*       const unsigned char *string = pointer to string
*       unsigned int ccnt = number of char to advance the pointer
*
*Exit:
*       Returns pointer after advancing it.
*       Returns pointer to end of string if string is not ccnt chars long.
*       Returns NULL is supplied pointer is NULL.
*
*Exceptions:
*
*******************************************************************************/

unsigned char * __cdecl _mbsninc_l(
        const unsigned char *string,
        size_t ccnt,
        _locale_t plocinfo
        )
{
        if (string == NULL)
                return(NULL);

        return((char *)string + (unsigned int)_mbsnbcnt_l(string, ccnt, plocinfo));
}

unsigned char * (__cdecl _mbsninc)(
        const unsigned char *string,
        size_t ccnt
        )
{
    return _mbsninc_l(string, ccnt, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnset_s.inl ===
/***
*mbsnset_s.inl - general implementation of _mbsnset_s and _mbsnbset_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for _mbsnset_s and _mbsnbset_s.
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, unsigned int _Value, size_t _COUNT, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, unsigned int _Value, size_t _COUNT)
#endif  /* _USE_LOCALE_ARG */
{
    int mbcs_error = 0;
    unsigned char *p;
    size_t available;
    unsigned char highval, lowval;
    int mblead = 0;

    /* validation section */
    if (_COUNT == 0 && _DEST == NULL && _SizeInBytes == 0)
    {
        /* this case is allowed; nothing to do */
        _RETURN_NO_ERROR;
    }
    _VALIDATE_STRING(_DEST, _SizeInBytes);

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return _SB_FUNC_NAME((char *)_DEST, _SizeInBytes, (int)_Value, _COUNT);
    }
#endif  /* _USE_LOCALE_ARG */

    p = _DEST;
    available = _SizeInBytes;
    highval = (unsigned char)(_Value >> 8);
    lowval = (unsigned char)(_Value & 0x00ff);

    /* ensure _Value is a valid mbchar */
    if ((highval != 0 && (lowval == 0 || !_ISMBBLEAD(highval))) ||
        (highval == 0 && _ISMBBLEAD(lowval)))
    {
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_MBCS_ERROR;
    }

    _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT < _SizeInBytes), L"Buffer is too small");

    if (highval != 0)
    {
#if _COUNT_IN_BYTES
        /* if _COUNT is odd, make it even subtracting 1 */
        /* divide _COUNT by 2 to have a count in chars instead of bytes */
        if ((_COUNT & 1) == 1)
        {
            --_COUNT;
            mbcs_error = 1;
        }
        _COUNT = _COUNT / 2;
#endif  /* _COUNT_IN_BYTES */
        while (*p != 0 && _COUNT > 0 && --available > 0)
        {
            if (p[1] == 0)
            {
                /* do not orphan leadbyte */
                *p = 0;
                ++available;
                mbcs_error = 1;
                break;
            }
            /* track the mblead status in the original string */
            mblead = mblead ? 0 : _ISMBBLEAD(*p);
            *p++ = highval;
            if (--available == 0)
            {
                break;
            }
            mblead = mblead ? 0 : _ISMBBLEAD(*p);
            *p++ = lowval;
            --_COUNT;
        }
    }
    else
    {
        while (*p != 0 && _COUNT > 0 && --available > 0)
        {
            /* track the mblead status in the original string */
            mblead = mblead ? 0 : _ISMBBLEAD(*p);
            *p++ = lowval;
            --_COUNT;
        }
    }

    /* if the last written byte overlapps a leadbyte,
     * copy a space over the corresponding trailbyte */
    if (_COUNT == 0 && mblead && *p != 0 && --available > 0)
    {
        mbcs_error = 1;
        if (p[1] == 0)
        {
            /* special case: if the space would be followed by 0, just put a 0 */
            *p = 0;
            ++available;
        }
        else
        {
            *p++ = ' ';
        }
    }

    if (_COUNT == 0)
    {
        /* ensure the string is null-terminated */
        while (*p != 0 && --available > 0)
        {
            ++p;
        }
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SizeInBytes);
    }
    _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);
    if (mbcs_error)
    {
        _RETURN_MBCS_ERROR;
    }
    else
    {
        _RETURN_NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnset_s.c ===
/***
*mbsnset_s.c - Sets first n characters of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets first n characters of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnset_s
#define _DEST _Dst
#define _COUNT _CountInChars
#define _COUNT_IN_BYTES 0

#include <mbsnset_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_4(errno_t, _mbsnset_s, unsigned char *, size_t, unsigned int, size_t)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnset_s_l.c ===
/***
*mbsnset_s_l.c - Sets first n characters of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets first n characters of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsnset_s_l
#define _SB_FUNC_NAME _strnset_s
#define _DEST _Dst
#define _COUNT _CountInChars
#define _COUNT_IN_BYTES 0

#include <mbsnset_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncpy_s_l.c ===
/***
*mbsncpy_s_l.c - Copy one string to another, n chars only (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Copy one string to another, n chars only (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsncpy_s_l
#define _SB_FUNC_NAME strncpy_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInChars
#define _COUNT_IN_BYTES 0

#include <mbsncpy_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncat_s_l.c ===
/***
*mbsncat_s_l.c - concatenate string2 onto string1, max length n
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines mbsncat_s_l() - concatenate maximum of n characters
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsncat_s_l
#define _SB_FUNC_NAME strncat_s
#define _DEST _Dst
#define _SRC _Src
#define _COUNT _CountInChars
#define _COUNT_IN_BYTES 0

#include <mbsncat_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsncoll.c ===
/***
*mbsncol.c - Collate n characters of two MBCS strings
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Collate n characters of two MBCS strings
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <internal.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsncoll(s1, s2, n) - Collate n characters of two MBCS strings
*
*Purpose:
*       Collates up to n charcters of two strings for lexical order.
*       Strings are collated on a character basis, not a byte basis.
*
*Entry:
*       unsigned char *s1, *s2 = strings to collate
*       size_t n = maximum number of characters to collate
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsncoll_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        int ret;
        size_t bcnt1, bcnt2;
        _LocaleUpdate _loc_update(plocinfo);

        if (n == 0)
            return 0;

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(n <= INT_MAX, EINVAL, _NLSCMPERROR);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strncoll_l((const char *)s1, (const char *)s2, n, plocinfo);

        bcnt1 = _mbsnbcnt_l(s1, n, _loc_update.GetLocaleT());
        bcnt2 = _mbsnbcnt_l(s2, n, _loc_update.GetLocaleT());

        if ( 0 == (ret = __crtCompareStringA(
                        _loc_update.GetLocaleT(),
                        _loc_update.GetLocaleT()->mbcinfo->mblcid,
                        SORT_STRINGSORT,
                        (const char *)s1,
                        (int)bcnt1,
                        (char *)s2,
                        (int)bcnt2,
                        _loc_update.GetLocaleT()->mbcinfo->mbcodepage )) )
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return ret - 2;

}

extern "C" int (__cdecl _mbsncoll)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsncoll_l(s1, s2, n, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsrchr.c ===
/***
*mbsrchr.c - Search for last occurence of character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Search for last occurence of character (MBCS)
*
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsrchr - Search for last occurence of character (MBCS)
*
*Purpose:
*       Find the last occurrence of the specified character in
*       the supplied string.  Handles MBCS chars/strings correctly.
*
*Entry:
*       unsigned char *str = string to search in
*       unsigned int c = character to search for
*
*Exit:
*       returns pointer to last occurrence of c in str
*       returns NULL if c not found
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" _CONST_RETURN unsigned char * __cdecl _mbsrchr_l(
        const unsigned char *str,
        unsigned int c,
        _locale_t plocinfo
        )
{
        char *r = NULL;
        unsigned int cc;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(str != NULL, EINVAL, 0);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (_CONST_RETURN unsigned char *)strrchr((const char *)str, c);

        do {
            cc = *str;
            if ( _ismbblead_l(cc, _loc_update.GetLocaleT()) ) {
                if(*++str) {
                    if (c == ((cc<<8)|*str))
                        r = (char *)str - 1;
                }
                else if(!r)
                    /* return pointer to '\0' */
                    r = (char *)str;
            }
            else if (c == cc)
                r = (char *)str;
        }
        while (*str++);

        return((_CONST_RETURN unsigned char *)r);
}

extern "C" _CONST_RETURN unsigned char * (__cdecl _mbsrchr)(
        const unsigned char *str,
        unsigned int c
        )
{
    return _mbsrchr_l(str, c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbspbrk.c ===
/***
*mbspbrk.c - Find first string char in charset, pointer return (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Find first string char in charset, pointer return (MBCS)
*       Shares common source file with mbscspn.c.
*
*******************************************************************************/

#ifdef _MBCS
#define _RETURN_PTR
#include "mbscspn.c"
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsset_s.c ===
/***
*mbsset_s.c - Sets all charcaters of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets all charcaters of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>

#ifdef _SYSCRT

#include <internal_safecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsset_s
#define _DEST _Dst

#include <mbsset_s.inl>

#else  /* _SYSCRT */

#include <internal.h>

_REDIRECT_TO_L_VERSION_3(errno_t, _mbsset_s, unsigned char *, size_t, unsigned int)

#endif  /* _SYSCRT */

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsspn.c ===
/***
*mbsspn.c - Search for init substring of chars from control string (MBCS).
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Search for init substring of chars from control string (MBCS).
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>
#include <tchar.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
*ifndef _RETURN_PTR
* _mbsspn - Find first string char not in charset (MBCS)
*else
* _mbsspnp - Find first string char not in charset, return pointer (MBCS)
*endif
*
*Purpose:
*       Returns maximum leading segment of string consisting solely
*       of characters from charset.  Handles MBCS characters correctly.
*
*Entry:
*       unsigned char *string = string to search in
*       unsigned char *charset = set of characters to scan over
*
*Exit:
*
*ifndef _RETURN_PTR
*       Returns index of first char in string not in control.
*       Returns 0, if string begins with a character not in charset.
*else
*       Returns pointer to first character not in charset.
*       Returns NULL if string consists entirely of characters from charset.
*endif
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifndef _RETURN_PTR
extern "C" size_t __cdecl _mbsspn_l
#else  /* _RETURN_PTR */
extern "C" unsigned char * __cdecl _mbsspnp_l
#endif  /* _RETURN_PTR */
        (
        const unsigned char *string,
        const unsigned char *charset,
        _locale_t plocinfo
        )
{
        unsigned char *p, *q;
        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
#ifndef _RETURN_PTR
            return strspn((const char *)string, (const char *)charset);
#else  /* _RETURN_PTR */
        {
            size_t retval;
            retval = strspn((const char *)string, (const char *)charset);
            return (unsigned char *)(*(string + retval) ? string + retval : NULL);
        }
#endif  /* _RETURN_PTR */

        /* validation section */
#ifndef _RETURN_PTR
        _VALIDATE_RETURN(string != NULL, EINVAL, 0);
        _VALIDATE_RETURN(charset != NULL, EINVAL, 0);
#else  /* _RETURN_PTR */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);
        _VALIDATE_RETURN(charset != NULL, EINVAL, NULL);
#endif  /* _RETURN_PTR */

        /* loop through the string to be inspected */
        for (q = (unsigned char *)string; *q; q++) {

            /* loop through the charset */
            for (p = (unsigned char *)charset; *p; p++) {
                if ( _ismbblead_l(*p, _loc_update.GetLocaleT()) ) {
                    if (((*p == *q) && (p[1] == q[1])) || p[1] == '\0')
                        break;
                    p++;
                }
                else
                    if (*p == *q)
                        break;
            }

            if (*p == '\0')         /* end of charset? */
                break;              /* yes, no match on this char */

            if ( _ismbblead_l(*q, _loc_update.GetLocaleT()) )
                if (*++q == '\0')
                    break;
        }

#ifndef _RETURN_PTR
        return((size_t) (q - string));          /* index */
#else  /* _RETURN_PTR */
        return((*q) ? q : NULL);        /* pointer */
#endif  /* _RETURN_PTR */

}

#ifndef _RETURN_PTR
extern "C" size_t (__cdecl _mbsspn)
#else  /* _RETURN_PTR */
extern "C" unsigned char * (__cdecl _mbsspnp)
#endif  /* _RETURN_PTR */
        (
        const unsigned char *string,
        const unsigned char *charset
        )
{
#ifndef _RETURN_PTR
        return _mbsspn_l(string, charset, NULL);
#else  /* _RETURN_PTR */
        return _mbsspnp_l(string, charset, NULL);
#endif  /* _RETURN_PTR */
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsspnp.c ===
/***
*mbsspnp.c - Find first string char in charset, pointer return (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Returns maximum leading segment of string consisting solely
*       of characters from charset.  Handles MBCS characters correctly.
*
*******************************************************************************/

#ifdef _MBCS
#define _RETURN_PTR
#include "mbsspn.c"
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnicmp.c ===
/***
*mbsnicmp.c - Compare n characters of strings, ignoring case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Compare n characters of strings, ignoring case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <string.h>
#include <mbstring.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsnicmp - Compare n characters of strings, ignoring case (MBCS)
*
*Purpose:
*       Compares up to n charcters of two strings for lexical order.
*       Strings are compared on a character basis, not a byte basis.
*       Case of characters is not considered.
*
*Entry:
*       unsigned char *s1, *s2 = strings to compare
*       size_t n = maximum number of characters to compare
*
*Exit:
*       Returns <0 if s1 < s2
*       Returns  0 if s1 == s2
*       Returns >0 if s1 > s2
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _mbsnicmp_l(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n,
        _locale_t plocinfo
        )
{
        unsigned short c1, c2;

        if (n==0)
            return(0);

        _LocaleUpdate _loc_update(plocinfo);
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return _strnicmp((const char *)s1, (const char *)s2, n);

        /* validation section */
        _VALIDATE_RETURN(s1 != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(s2 != NULL, EINVAL, _NLSCMPERROR);

        while (n--) {

            c1 = *s1++;
            if ( _ismbblead_l(c1, _loc_update.GetLocaleT()) ) {
                if (*s1 == '\0')
                    c1 = 0;
                else {
                    c1 = ((c1<<8) | *s1++);

                    if ( ((c1 >= _MBUPPERLOW1_MT(_loc_update.GetLocaleT())) &&
                          (c1 <= _MBUPPERHIGH1_MT(_loc_update.GetLocaleT()))) )
                        c1 += _MBCASEDIFF1_MT(_loc_update.GetLocaleT());
                    else if ( ((c1 >= _MBUPPERLOW2_MT(_loc_update.GetLocaleT())) &&
                               (c1 <= _MBUPPERHIGH2_MT(_loc_update.GetLocaleT()))) )
                        c1 += _MBCASEDIFF2_MT(_loc_update.GetLocaleT());
                }
            }
            else
                c1 = _mbbtolower_l(c1, _loc_update.GetLocaleT());

            c2 = *s2++;
            if ( _ismbblead_l(c2, _loc_update.GetLocaleT()) ) {
                if (*s2 == '\0')
                    c2 = 0;
                else {
                    c2 = ((c2<<8) | *s2++);
                    if ( ((c2 >= _MBUPPERLOW1_MT(_loc_update.GetLocaleT())) &&
                          (c2 <= _MBUPPERHIGH1_MT(_loc_update.GetLocaleT()))) )
                        c2 += _MBCASEDIFF1_MT(_loc_update.GetLocaleT());
                    else if ( ((c2 >= _MBUPPERLOW2_MT(_loc_update.GetLocaleT())) &&
                               (c2 <= _MBUPPERHIGH2_MT(_loc_update.GetLocaleT()))) )
                        c2 += _MBCASEDIFF2_MT(_loc_update.GetLocaleT());
                }
            }
            else
                c2 = _mbbtolower_l(c2, _loc_update.GetLocaleT());

            if (c1 != c2)
                return( (c1 > c2) ? 1 : -1 );

            if (c1 == 0)
                return(0);
        }

        return(0);
}

extern "C" int (__cdecl _mbsnicmp)(
        const unsigned char *s1,
        const unsigned char *s2,
        size_t n
        )
{
    return _mbsnicmp_l(s1, s2, n, NULL);
}
#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbstok_s.c ===
/***
*mbstok_s.c - Break string into tokens (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Break string into tokens (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbstok_s_l
#define _SB_FUNC_NAME strtok_s

#include <mbstok_s.inl>

_REDIRECT_TO_L_VERSION_3(unsigned char *, _mbstok_s, unsigned char *, const unsigned char *, unsigned char **)

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsnset.c ===
/***
*mbsnset.c - Sets first n charcaters of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets first n charcaters of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <crtdbg.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsnset - Sets first n charcaters of string to given character (MBCS)
*
*Purpose:
*       Sets the first n characters of string to the supplied
*       character value.  If the length of string is less than n,
*       the length of string is used in place of n.  Handles
*       MBCS chars correctly.
*
*       There are several factors that make this routine complicated:
*               (1) The fill value may be 1 or 2 bytes long.
*               (2) The fill operation may end by hitting the count value
*               or by hitting the end of the string.
*               (3) A null terminating char is NOT placed at the end of
*               the string.
*
*       Cases to be careful of (both of these can occur at once):
*               (1) Leaving an "orphaned" trail byte in the string (e.g.,
*               overwriting a lead byte but not the corresponding trail byte).
*               (2) Writing only the 1st byte of a 2-byte fill value because the
*               end of string was encountered.
*
*Entry:
*       unsigned char *string = string to modify
*       unsigned int val = value to fill string with
*       size_t count = count of characters to fill
*
*
*Exit:
*       Returns string = now filled with char val
*
*Uses:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsnset_l(
        unsigned char *string,
        unsigned int val,
        size_t count,
        _locale_t plocinfo
        )
{
        unsigned char  *start = string;
        unsigned int leadbyte = 0;
        unsigned char highval, lowval;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(string != NULL || count == 0, EINVAL, NULL);

        /*
         * leadbyte flag indicates if the last byte we overwrote was
         * a lead byte or not.
         */
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)_strnset((char *)string, val, count);
_END_SECURE_CRT_DEPRECATION_DISABLE

        if (highval = (unsigned char)(val>>8)) {

            /* double byte value */

            lowval = (unsigned char)(val & 0x00ff);

            if(lowval=='\0')
            {
                _ASSERTE(("invalid MBCS pair passed to mbsnset",0));

                /* Ideally we would return NULL here and signal an error
                    condition. But since this function has no other
                    error modes, there would be a good chance of crashing
                    the caller. So instead we fill the string with spaces
                    to ensure that no information leaks through
                    unexpectedly. Anyway, we do set errno to EINVAL.
                */
                errno = EINVAL;
                lowval=highval=' ';
            }

            while (count-- && *string) {
                leadbyte = _ismbbtruelead_l(leadbyte, *string, _loc_update.GetLocaleT());
                *string++ = highval;

                if (*string) {
                    leadbyte = _ismbbtruelead_l(leadbyte, *string, _loc_update.GetLocaleT());
                    *string++ = lowval;
                }
                else
                    /* overwrite orphaned highval byte */
                    *(string-1) = ' ';
            }
        }

        else {
            /* single byte value */

            while (count-- && *string) {
                leadbyte = _ismbbtruelead_l(leadbyte, *string, _loc_update.GetLocaleT());
                *string++ = (unsigned char)val;
            }
        }

        /* overwrite orphaned trailing byte, if necessary */
        if(leadbyte && *string)
            *string = ' ';

        return( start );
}

unsigned char * (__cdecl _mbsnset)(
        unsigned char *string,
        unsigned int val,
        size_t count
        )
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsnset_l(string, val, count, NULL);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsset_s_l.c ===
/***
*mbsset_s_l.c - Sets all charcaters of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Sets all charcaters of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mbstring.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _mbsset_s_l
#define _SB_FUNC_NAME _strset_s
#define _DEST _Dst

#include <mbsset_s.inl>

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsstr.c ===
/***
* mbsstr.c - Search for one MBCS string inside another
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Search for one MBCS string inside another
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>
#include <string.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbsstr - Search for one MBCS string inside another
*
*Purpose:
*       Find the first occurrence of str2 in str1.
*
*Entry:
*       unsigned char *str1 = beginning of string
*       unsigned char *str2 = string to search for
*
*Exit:
*       Returns a pointer to the first occurrence of str2 in
*       str1, or NULL if str2 does not occur in str1
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" _CONST_RETURN unsigned char * __cdecl _mbsstr_l(
        const unsigned char *str1,
        const unsigned char *str2,
        _locale_t plocinfo
        )
{
        unsigned char *cp, *s1, *s2, *endp;
        _LocaleUpdate _loc_update(plocinfo);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)strstr((const char *)str1, (const char *)str2);

        /* validation section */
        _VALIDATE_RETURN(str2 != NULL, EINVAL, 0);
        if ( *str2 == '\0')
            return (unsigned char *)str1;
        _VALIDATE_RETURN(str1 != NULL, EINVAL, 0);

        cp = (unsigned char *) str1;
        endp = (unsigned char *) (str1 + (strlen((const char *)str1) - strlen((const char *)str2)));

        while (*cp && (cp <= endp))
        {
            s1 = cp;
            s2 = (unsigned char *) str2;

            /*
             * MBCS: ok to ++ since doing equality comparison.
             * [This depends on MBCS strings being "legal".]
             */
            while ( *s1 && *s2 && (*s1 == *s2) )
                s1++, s2++;

            if (!(*s2))
                return(cp);     /* success! */

            /*
             * bump pointer to next char
             */
            if ( _ismbblead_l(*(cp++), _loc_update.GetLocaleT()) )
            {
                /*  don't move forward if we have leadbyte, EOS
                    means dud string was passed in.
                    Don't assert - too low level
                */
                if(*cp!='\0')
                {
                    cp++;
                }
            }
        }

        return(NULL);

}

extern "C" _CONST_RETURN unsigned char * (__cdecl _mbsstr)(
        const unsigned char *str1,
        const unsigned char *str2
        )
{
    return _mbsstr_l(str1, str2, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsset_s.inl ===
/***
*mbsset_s.inl - implementation of _mbsset_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the algorithm for _mbsset_s.
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, unsigned int _Value, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
errno_t __cdecl _FUNC_NAME(unsigned char *_DEST, size_t _SizeInBytes, unsigned int _Value)
#endif  /* _USE_LOCALE_ARG */
{
    int mbcs_error = 0;
    unsigned char *p;
    size_t available;
    unsigned char highval, lowval;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SizeInBytes);

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return _SB_FUNC_NAME((char *)_DEST, _SizeInBytes, (int)_Value);
    }
#endif  /* _USE_LOCALE_ARG */

    p = _DEST;
    available = _SizeInBytes;
    highval = (unsigned char)(_Value >> 8);
    lowval = (unsigned char)(_Value & 0x00ff);

    /* ensure _Value is a valid mbchar */
    if ((highval != 0 && (lowval == 0 || !_ISMBBLEAD(highval))) ||
        (highval == 0 && _ISMBBLEAD(lowval)))
    {
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_MBCS_ERROR;
    }

    if (highval != 0)
    {
        while (*p != 0 && --available > 0)
        {
            if (p[1] == 0)
            {
                /* do not orphan leadbyte */
                *p = 0;
                ++available;
                mbcs_error = 1;
                break;
            }
            *p++ = highval;
            if (--available == 0)
            {
                break;
            }
            *p++ = lowval;
        }
    }
    else
    {
        while (*p != 0 && --available > 0)
        {
            *p++ = lowval;
        }
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SizeInBytes);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SizeInBytes);
    }
    _FILL_STRING(_DEST, _SizeInBytes, _SizeInBytes - available + 1);

    if (mbcs_error)
    {
        _RETURN_MBCS_ERROR;
    }
    else
    {
        _RETURN_NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsrev.c ===
/***
*mbsrev.c - Reverse a string in place (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Reverse a string in place (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <crtdbg.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbsrev - Reverse a string in place (MBCS)
*
*Purpose:
*       Reverses the order of characters in the string.  The terminating
*       null character remains in place.  The order of MBCS characters
*       is not changed.
*
*Entry:
*       unsigned char *string = string to reverse
*
*Exit:
*       returns string - now with reversed characters
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsrev_l(
        unsigned char *string,
        _locale_t plocinfo
        )
{
        unsigned char *start = string;
        unsigned char *left  = string;
        unsigned char c;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);

        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
            return (unsigned char *)_strrev((char *)string);


        /* first go through and reverse the bytes in MBCS chars */
        while ( *string ) {
            if ( _ismbblead_l(*string++, _loc_update.GetLocaleT()) ) {
                if ( *string ) {
                    c = *string;
                    *string = *(string - 1);
                    *(string - 1) = c;
                    string++;
                }
                else
                {
                    /*  second byte is EOS
                        There is nothing really satisfying to do here. We have a string
                        that ends in leadbyte,'\0'. Reversing this would lead to the leadbyte
                        becoming falsely attached to the character before it:
                        (XL0 -> LX0, X has suddenly become a trailbyte)

                        So what we choose to do is assert and purge the dud byte from within the
                        string.
                    */
                    errno = EINVAL;
                    _ASSERTE(("Bad MBCS string passed into _mbsrev",0));

                    /* String has at least moved once already, so this is safe */
                    _ASSERTE(string>start);

                    /* move back one to point at the dud leadbyte */
                    --string;

                    /* now truncate the string one byte earlier */
                    *string='\0';

                    break;
                }
            }
        }

        /* now reverse the whole string */
        string--;
        while ( left < string ) {
            c = *left;
            *left++ = *string;
            *string-- = c;
        }

        return ( start );
}

extern "C" unsigned char * (__cdecl _mbsrev)(
        unsigned char *string
        )
{
    return _mbsrev_l(string, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbtohira.c ===
/***
*mbtohira.c - Convert character from katakana to hiragana (Japanese).
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _jtohira() - convert character to hiragana.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <stdlib.h>


/***
*unsigned int _mbctohira(c) - Converts character to hiragana.
*
*Purpose:
*       Converts the character c from katakana to hiragana, if possible.
*
*Entry:
*       unsigned int c - Character to convert.
*
*Exit:
*       Returns the converted character.
*
*Exceptions:
*
*******************************************************************************/

unsigned int __cdecl _mbctohira_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        if (_ismbckata_l(c, plocinfo) && c <= 0x8393) {
                if (c < 0x837f)
                        c -= 0xa1;
                else
                        c -= 0xa2;
        }
        return(c);
}

unsigned int (__cdecl _mbctohira)(
        unsigned int c
        )
{
    return _mbctohira_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsset.c ===
/***
*mbsset.c - Sets all charcaters of string to given character (MBCS)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets all charcaters of string to given character (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <crtdbg.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* mbsset - Sets all charcaters of string to given character (MBCS)
*
*Purpose:
*       Sets all of characters in string (except the terminating '/0'
*       character) equal to the supplied character.  Handles MBCS
*       chars correctly.
*
*Entry:
*       unsigned char *string = string to modify
*       unsigned int val = value to fill string with
*
*Exit:
*       returns string = now filled with the specified char
*
*Uses:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbsset_l(
        unsigned char *string,
        unsigned int val,
        _locale_t plocinfo
        )
{
        unsigned char  *start = string;
        unsigned char highval, lowval;
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);

_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        if (_loc_update.GetLocaleT()->mbcinfo->ismbcodepage == 0)
                return (unsigned char *)_strset((char *)string, val);
_END_SECURE_CRT_DEPRECATION_DISABLE

        if (highval = (unsigned char) (val>>8)) {

                /* 2-byte value */

                lowval = (unsigned char)(val & 0x00ff);

                if(lowval=='\0')
                {
                    _ASSERTE(("invalid MBCS pair passed to mbsset",0));

                    /* Ideally we would return NULL here and signal an error
                       condition. But since this function has no other
                       error modes, there would be a good chance of crashing
                       the caller. So instead we fill the string with spaces
                       to ensure that no information leaks through
                       unexpectedly. Anyway, we do set errno to EINVAL.
                    */
                    errno = EINVAL;
                    lowval=highval=' ';
                }

                while (*string) {

                        *string++ = highval;
                        if (*string)
                                *string++ = lowval;
                        else
                                /* don't orphan lead byte */
                                string[-1] = ' ';
                        }

        }

        else {
                /* single byte value */

                while (*string)
                        *string++ = (unsigned char)val;
        }

        return(start);
}

extern "C" unsigned char * (__cdecl _mbsset)(
        unsigned char *string,
        unsigned int val
        )
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbsset_l(string, val, NULL);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbtokata.c ===
/***
*mbtokata.c - Converts character to katakana.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character from hiragana to katakana.
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <stdlib.h>


/***
*unsigned short _mbctokata(c) - Converts character to katakana.
*
*Purpose:
*       If the character c is hiragana, convert to katakana.
*
*Entry:
*       unsigned int c - Character to convert.
*
*Exit:
*       Returns converted character.
*
*Exceptions:
*
*******************************************************************************/

unsigned int __cdecl _mbctokata_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        if (_ismbchira_l(c, plocinfo)) {
                c += 0xa1;
                if (c >= 0x837f)
                        c++;
        }
        return(c);
}
unsigned int (__cdecl _mbctokata)(
        unsigned int c
        )
{
    return _mbctokata_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbtoupr.c ===
/***
*mbtoupr.c - Convert character to upper case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Convert character to upper case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>

#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbctoupper - Convert character to upper case (MBCS)
*
*Purpose:
*       If the given character is lower case, convert to upper case.
*       Handles MBCS chars correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to convert
*
*Exit:
*       Returns converted character
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP unsigned int __cdecl _mbctoupper_l(
        unsigned int c,
        _locale_t plocinfo
        )
{
        unsigned char val[2];
        unsigned char ret[4];
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {

            val[0] = (c >> 8) & 0xFF;
            val[1] = c & 0xFF;

            if ( !_ismbblead_l(val[0], _loc_update.GetLocaleT()) )
                return c;


            if ( __crtLCMapStringA(
                        _loc_update.GetLocaleT(),
                        _loc_update.GetLocaleT()->mbcinfo->mblcid,
                        LCMAP_UPPERCASE,
                        (const char *)val,
                        2,
                        (char *)ret,
                        2,
                        _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                        TRUE ) == 0 )
                return c;

            c = ret[1];
            c += ret[0] << 8;

            return c;


        }
        else
            return (unsigned int)_mbbtoupper_l((int)c, _loc_update.GetLocaleT());
}
unsigned int (__cdecl _mbctoupper)(
        unsigned int c
        )
{
    return _mbctoupper_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbstok_s.inl ===
/***
*tcstok_s.inl - implementation of _mbstok_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the algorithm for _mbstok_s.
*
****/

_FUNC_PROLOGUE
#if _USE_LOCALE_ARG
unsigned char * __cdecl _FUNC_NAME(unsigned char *_String, const unsigned char *_Control, unsigned char **_Context, _LOCALE_ARG_DECL)
#else  /* _USE_LOCALE_ARG */
unsigned char * __cdecl _FUNC_NAME(unsigned char *_String, const unsigned char *_Control, unsigned char **_Context)
#endif  /* _USE_LOCALE_ARG */
{
    unsigned char *token;
    const unsigned char *ctl;
    int dbc;

    /* validation section */
    _VALIDATE_POINTER_ERROR_RETURN(_Context, EINVAL, NULL);
    _VALIDATE_POINTER_ERROR_RETURN(_Control, EINVAL, NULL);
    _VALIDATE_CONDITION_ERROR_RETURN(_String != NULL || *_Context != NULL, EINVAL, NULL);

#if _USE_LOCALE_ARG
    _LOCALE_UPDATE;
    if (_LOCALE_SHORTCUT_TEST)
    {
        return (unsigned char*)_SB_FUNC_NAME((char *)_String, (const char *)_Control, (char **)_Context);
    }
#endif  /* _USE_LOCALE_ARG */

    /* If string==NULL, continue with previous string */
    if (!_String)
    {
        _String = *_Context;
    }

    /* Find beginning of token (skip over leading delimiters). Note that
    * there is no token iff this loop sets string to point to the terminal null. */
    for ( ; *_String != 0; _String++)
    {
        for (ctl = _Control; *ctl != 0; ctl++)
        {
            if (_ISMBBLEAD(*ctl))
            {
                if (ctl[1] == 0)
                {
                    ctl++;
                    _SET_MBCS_ERROR;
                    break;
                }
                if (*ctl == *_String && ctl[1] == _String[1])
                {
                    break;
                }
                ctl++;
            }
            else
            {
                if (*ctl == *_String)
                {
                    break;
                }
            }
        }
        if (*ctl == 0)
        {
            break;
        }
        if (_ISMBBLEAD(*_String))
        {
            _String++;
            if (*_String == 0)
            {
                _SET_MBCS_ERROR;
                break;
            }
        }
    }

    token = _String;

    /* Find the end of the token. If it is not the end of the string,
    * put a null there. */
    for ( ; *_String != 0; _String++)
    {
        for (ctl = _Control, dbc = 0; *ctl != 0; ctl++)
        {
            if (_ISMBBLEAD(*ctl))
            {
                if (ctl[1] == 0)
                {
                    ctl++;
                    break;
                }
                if (ctl[0] == _String[0] && ctl[1] == _String[1])
                {
                    dbc = 1;
                    break;
                }
                ctl++;
            }
            else
            {
                if (*ctl == *_String)
                {
                    break;
                }
            }
        }
        if (*ctl != 0)
        {
            *_String++ = 0;
            if (dbc)
            {
                *_String++ = 0;
            }
            break;
        }
        if (_ISMBBLEAD(_String[0]))
        {
            if (_String[1] == 0)
            {
                *_String = 0;
                break;
            }
            _String++;
        }
    }

    /* Update the context */
    *_Context = _String;

    /* Determine if a token has been found. */
    if (token == _String)
    {
        return NULL;
    }
    else
    {
        return token;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbstok.c ===
/***
*mbstok.c - Break string into tokens (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Break string into tokens (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <mtdll.h>
#include <cruntime.h>
#include <string.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <stddef.h>
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

/***
* _mbstok - Break string into tokens (MBCS)
*
*Purpose:
*       strtok considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into string immediately
*       following the returned token. subsequent calls with zero for the first
*       argument (string) will work thru the string until no tokens remain. the
*       control string may be different from call to call. when no tokens remain
*       in string a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*       MBCS chars supported correctly.
*
*Entry:
*       char *string = string to break into tokens.
*       char *sepset = set of characters to use as seperators
*
*Exit:
*       returns pointer to token, or NULL if no more tokens
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" unsigned char * __cdecl _mbstok_l(
        unsigned char * string,
        const unsigned char * sepset,
        _locale_t plocinfo
        )
{
        _ptiddata ptd = _getptd();
        return _mbstok_s_l(string, sepset, &ptd->_mtoken, plocinfo);
}

extern "C" unsigned char * __cdecl _mbstok(
        unsigned char * string,
        const unsigned char * sepset
        )
{
    /* We call the deprecated _mbstok_l (and not _mbstok_s_l) so that we keep one
     * single nextoken in the single thread case, i.e. the nextoken declared as static
     * inside _mbstok_l
     */
    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    return _mbstok_l(string, sepset, NULL);
    _END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbtowc.c ===
/***
*mbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <internal.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int mbtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*       If errors are encountered, -1 is returned and errno is set to EILSEQ.
*
*******************************************************************************/

extern "C" int __cdecl _mbtowc_l (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        _locale_t plocinfo
        )
{
    if ( !s || n == 0 )
        /* indicate do not have state-dependent encodings,
           handle zero length string */
        return 0;

    if ( !*s )
    {
        /* handle NULL char */
        if (pwc)
            *pwc = 0;
        return 0;
    }


    _LocaleUpdate _loc_update(plocinfo);
    _ASSERTE (_loc_update.GetLocaleT()->locinfo->mb_cur_max == 1 || _loc_update.GetLocaleT()->locinfo->mb_cur_max == 2);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
    {
        if (pwc)
            *pwc = (wchar_t)(unsigned char)*s;
        return sizeof(char);
    }

    if ( _isleadbyte_l((unsigned char)*s, _loc_update.GetLocaleT()) )
    {
        /* multi-byte char */

        if ( (_loc_update.GetLocaleT()->locinfo->mb_cur_max <= 1) || ((int)n < _loc_update.GetLocaleT()->locinfo->mb_cur_max) ||
             (MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                  s,
                                  _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                  pwc,
                                  (pwc) ? 1 : 0 ) == 0) )
        {
            /* validate high byte of mbcs char */
            if ( (n < (size_t)_loc_update.GetLocaleT()->locinfo->mb_cur_max) || (!*(s + 1)) )
            {
                errno = EILSEQ;
                return -1;
            }
        }
        return _loc_update.GetLocaleT()->locinfo->mb_cur_max;
    }
    else {
        /* single byte char */
         if ( MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                  s,
                                  1,
                                  pwc,
                                  (pwc) ? 1 : 0 ) == 0 )
        {
            errno = EILSEQ;
            return -1;
        }
        return sizeof(char);
    }

}

extern "C" int __cdecl mbtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n
        )
{
    return _mbtowc_l(pwc, s, n, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbstowcs.c ===
/***
*mbstowcs.c - Convert multibyte char string to wide char string.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte char string into the equivalent wide char string.
*
*******************************************************************************/


#include <internal.h>
#include <internal_securecrt.h>
#include <locale.h>
#include <errno.h>
#include <cruntime.h>
#include <stdlib.h>
#include <string.h>
#include <dbgint.h>
#include <stdio.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*size_t mbstowcs() - Convert multibyte char string to wide char string.
*
*Purpose:
*       Convert a multi-byte char string into the equivalent wide char string,
*       according to the LC_CTYPE category of the current locale.
*       [ANSI].
*
*Entry:
*       wchar_t *pwcs = pointer to destination wide character string buffer
*       const char *s = pointer to source multibyte character string
*       size_t      n = maximum number of wide characters to store
*
*Exit:
*       If pwcs != NULL returns the number of words modified (<=n): note that
*       if the return value == n, then no destination string is not 0 terminated.
*       If pwcs == NULL returns the length (not size) needed for the destination buffer.
*
*Exceptions:
*       Returns (size_t)-1 if s is NULL or invalid mbcs character encountered
*       and errno is set to EILSEQ.
*
*******************************************************************************/

/* Helper shared by secure and non-secure functions */

extern "C" size_t __cdecl _mbstowcs_l_helper (
        wchar_t  *pwcs,
        const char *s,
        size_t n,
        _locale_t plocinfo
        )
{
    size_t count = 0;

    if (pwcs && n == 0)
        /* dest string exists, but 0 bytes converted */
        return (size_t) 0;

    if (pwcs && n > 0)
    {
        *pwcs = '\0';
    }

    /* validation section */
    _VALIDATE_RETURN(s != NULL, EINVAL, (size_t)-1);


    _LocaleUpdate _loc_update(plocinfo);
    /* if destination string exists, fill it in */
    if (pwcs)
    {
        if (_loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE)
        {
            /* C locale: easy and fast */
            while (count < n)
            {
                *pwcs = (wchar_t) ((unsigned char)s[count]);
                if (!s[count])
                    return count;
                count++;
                pwcs++;
            }
            return count;

        } else {
            int bytecnt, charcnt;
            unsigned char *p;

            /* Assume that the buffer is large enough */
            if ( (count = MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                               MB_PRECOMPOSED |
                                                MB_ERR_INVALID_CHARS,
                                               s,
                                               -1,
                                               pwcs,
                                               (int)n )) != 0 )
                return count - 1; /* don't count NUL */

            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            {
                errno = EILSEQ;
                *pwcs = '\0';
                return (size_t)-1;
            }

            /* User-supplied buffer not large enough. */

            /* How many bytes are in n characters of the string? */
            charcnt = (int)n;
            for (p = (unsigned char *)s; (charcnt-- && *p); p++)
            {
                if (
                    _isleadbyte_l(*p, _loc_update.GetLocaleT())
                    )
                {
                    if(p[1]=='\0')
                    {
                        /*  this is a leadbyte followed by EOS -- a dud MBCS string
                            We choose not to assert here because this
                            function is defined to deal with dud strings on
                            input and return a known value
                        */
                        errno = EILSEQ;
                        *pwcs = '\0';
                        return (size_t)-1;
                    }
                    else
                    {
                        p++;
                    }
                }
            }
            bytecnt = ((int) ((char *)p - (char *)s));

            if ( (count = MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                               MB_PRECOMPOSED,
                                               s,
                                               bytecnt,
                                               pwcs,
                                               (int)n )) == 0 )
            {
                errno = EILSEQ;
                *pwcs = '\0';
                return (size_t)-1;
            }

            return count; /* no NUL in string */
        }
    }
    else { /* pwcs == NULL, get size only, s must be NUL-terminated */
        if (_loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE) {
            return strlen(s);
        } else if ( (count = MultiByteToWideChar( _loc_update.GetLocaleT()->locinfo->lc_codepage,
                                                  MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                                  s,
                                                  -1,
                                                  NULL,
                                                  0 )) == 0 ) {
            errno = EILSEQ;
            return (size_t)-1;
        } else {
            return count - 1;
        }
    }

}

extern "C" size_t __cdecl _mbstowcs_l (
        wchar_t  *pwcs,
        const char *s,
        size_t n,
        _locale_t plocinfo
        )
{
    /* Call a non-deprecated helper to do the work. */

    return _mbstowcs_l_helper(pwcs, s, n, plocinfo);
}

extern "C" size_t __cdecl mbstowcs
(
        wchar_t  *pwcs,
        const char *s,
        size_t n
        )
{
    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    if (__locale_changed == 0)
    {
        return _mbstowcs_l(pwcs, s, n, &__initiallocalestructinfo);
    }
    else
    {
        return _mbstowcs_l(pwcs, s, n, NULL);
    }
    _END_SECURE_CRT_DEPRECATION_DISABLE
}

/***
*errno_t mbstowcs_s() - Convert multibyte char string to wide char string.
*
*Purpose:
*       Convert a multi-byte char string into the equivalent wide char string,
*       according to the LC_CTYPE category of the current locale.
*       Same as mbstowcs(), but the destination is ensured to be null terminated.
*       If there's not enough space, we return EINVAL.
*
*Entry:
*       size_t *pConvertedChars = Number of bytes modified including the terminating NULL
*                                 This pointer can be NULL.
*       wchar_t *pwcs = pointer to destination wide character string buffer
*       size_t sizeInWords = size of the destination buffer
*       const char *s = pointer to source multibyte character string
*       size_t n = maximum number of wide characters to store (not including the terminating NULL)
*
*Exit:
*       The error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" errno_t __cdecl _mbstowcs_s_l (
        size_t *pConvertedChars,
        wchar_t  *pwcs,
        size_t sizeInWords,
        const char *s,
        size_t n,
        _locale_t plocinfo
        )
{
    size_t retsize;
    errno_t retvalue = 0;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE((pwcs == NULL && sizeInWords == 0) || (pwcs != NULL && sizeInWords > 0), EINVAL);

    if (pwcs != NULL)
    {
        _RESET_STRING(pwcs, sizeInWords);
    }

    if (pConvertedChars != NULL)
    {
        *pConvertedChars = 0;
    }

    _LocaleUpdate _loc_update(plocinfo);

    size_t bufferSize = n > sizeInWords ? sizeInWords : n;
    /* n must fit into an int for MultiByteToWideChar */
    _VALIDATE_RETURN_ERRCODE(bufferSize <= INT_MAX, EINVAL);

    /* Call a non-deprecated helper to do the work. */

    retsize = _mbstowcs_l_helper(pwcs, s, bufferSize, _loc_update.GetLocaleT());

    if (retsize == (size_t)-1)
    {
        if (pwcs != NULL)
        {
            _RESET_STRING(pwcs, sizeInWords);
        }
        return errno;
    }

    /* count the null terminator */
    retsize++;

    if (pwcs != NULL)
    {
        /* return error if the string does not fit, unless n == _TRUNCATE */
        if (retsize > sizeInWords)
        {
            if (n != _TRUNCATE)
            {
                _RESET_STRING(pwcs, sizeInWords);
                _VALIDATE_RETURN_ERRCODE(retsize <= sizeInWords, ERANGE);
            }
            retsize = sizeInWords;
            retvalue = STRUNCATE;
        }

        /* ensure the string is null terminated */
        pwcs[retsize - 1] = '\0';
    }

    if (pConvertedChars != NULL)
    {
        *pConvertedChars = retsize;
    }

    return retvalue;
}

extern "C" errno_t __cdecl mbstowcs_s (
        size_t *pConvertedChars,
        wchar_t  *pwcs,
        size_t sizeInWords,
        const char *s,
        size_t n
)
{
    return _mbstowcs_s_l(pConvertedChars, pwcs, sizeInWords, s, n, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbsupr.c ===
/***
*mbsupr.c - Convert string upper case (MBCS)
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Convert string upper case (MBCS)
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>
#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbstring.h>
#include <mbctype.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <locale.h>
#include <setlocal.h>
#include <string.h>


/***
* _mbsupr - Convert string upper case (MBCS)
*
*Purpose:
*       Converts all the lower case characters in a string
*       to upper case in place.   Handles MBCS chars correctly.
*
*Entry:
*       unsigned char *string = pointer to string
*
*Exit:
*       Returns a pointer to the input string.
*       Returns NULL on error.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" errno_t __cdecl _mbsupr_s_l(
        unsigned char *string,
        size_t sizeInBytes,
        _locale_t plocinfo
        )
{
        size_t stringlen;

        /* validation section */
        _VALIDATE_RETURN_ERRCODE((string != NULL && sizeInBytes > 0) || (string == NULL && sizeInBytes == 0), EINVAL);

        if (string == NULL)
        {
            /* nothing to do */
            return 0;
        }

        stringlen = strnlen((char *)string, sizeInBytes);
        if (stringlen >= sizeInBytes)
        {
            _RESET_STRING(string, sizeInBytes);
            _RETURN_DEST_NOT_NULL_TERMINATED(string, sizeInBytes);
        }
        _FILL_STRING(string, sizeInBytes, stringlen + 1);

        unsigned char *cp, *dst;
        _LocaleUpdate _loc_update(plocinfo);

        for (cp = string, dst = string; *cp; ++cp)
        {
            if ( _ismbblead_l(*cp, _loc_update.GetLocaleT()) )
            {


                int retval;
                unsigned char ret[4];

                if ( (retval = __crtLCMapStringA(
                                _loc_update.GetLocaleT(),
                                _loc_update.GetLocaleT()->mbcinfo->mblcid,
                                LCMAP_UPPERCASE,
                                (const char *)cp,
                                2,
                                (char *)ret,
                                2,
                                _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                                TRUE )) == 0 )
                {
                    errno = EILSEQ;
                    _RESET_STRING(string, sizeInBytes);
                    return errno;
                }

                *(dst++) = ret[0];
                ++cp;
                if (retval > 1)
                {
                    *(dst++) = ret[1];
                }


            }
            else
                /* single byte, macro version */
                *(dst++) = (unsigned char) _mbbtoupper_l(*cp, _loc_update.GetLocaleT());
        }
        /* null terminate the string */
        *dst = '\0';

        return 0;
}

extern "C" errno_t (__cdecl _mbsupr_s)(
        unsigned char *string,
        size_t sizeInBytes
        )
{
    return _mbsupr_s_l(string, sizeInBytes, NULL);
}

extern "C" unsigned char * (__cdecl _mbsupr_l)(
        unsigned char *string,
        _locale_t plocinfo
        )
{
    return (_mbsupr_s_l(string, (string == NULL ? 0 : (size_t)-1), plocinfo) == 0 ? string : NULL);
}

extern "C" unsigned char * (__cdecl _mbsupr)(
        unsigned char *string
        )
{
    return (_mbsupr_s_l(string, (string == NULL ? 0 : (size_t)-1), NULL) == 0 ? string : NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mdbgheap.cpp ===
/***
*dbgheap.c - Debug CRT Heap Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines pure MSIL C++ debug heap routine.
*
*******************************************************************************/

#ifdef _DEBUG

#include <crtdbg.h>
#include <internal.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention

typedef void (__clrcall *_PHEAP_m)(void *, void *);

static _PHEAP_m __pfnHeapfunc = (_PHEAP_m) _encoded_null();

static void __cdecl CrtDoForAllClientObjects_thunk(void *pData, void *pContext)
{
    _PHEAP_m pFunc = (_PHEAP_m) _decode_pointer(__pfnHeapfunc);

    if (pFunc)
    {
        pFunc(pData, pContext);
    }
}

_MRTIMP void __cdecl _CrtDoForAllClientObjects(
            _PHEAP_m pfn,
            void *pContext)
{
    __pfnHeapfunc = (_PHEAP_m) _encode_pointer(pfn);
    return _CrtDoForAllClientObjects(CrtDoForAllClientObjects_thunk, pContext);
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbtolwr.c ===
/***
*mbtolwr.c - Convert character to lower case (MBCS).
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Convert character to lower case (MBCS).
*
*******************************************************************************/

#ifdef _MBCS

#include <awint.h>
#include <mtdll.h>

#include <cruntime.h>
#include <ctype.h>
#include <mbdata.h>
#include <mbctype.h>
#include <mbstring.h>
#include <locale.h>
#include <setlocal.h>


/***
* _mbctolower - Convert character to lower case (MBCS)
*
*Purpose:
*       If the given character is upper case, convert it to lower case.
*       Handles MBCS characters correctly.
*
*       Note:  Use test against 0x00FF instead of _ISLEADBYTE
*       to ensure that we don't call SBCS routine with a two-byte
*       value.
*
*Entry:
*       unsigned int c = character to convert
*
*Exit:
*       Returns converted character
*
*Exceptions:
*
*******************************************************************************/

extern "C" unsigned int __cdecl _mbctolower_l (
        unsigned int c,
        _locale_t plocinfo
        )
{
        unsigned char val[2];
        unsigned char ret[4];
        _LocaleUpdate _loc_update(plocinfo);

        if (c > 0x00FF)
        {
            val[0] = (c >> 8) & 0xFF;
            val[1] = c & 0xFF;

            if ( !_ismbblead_l(val[0], _loc_update.GetLocaleT()) )
                return c;


            if ( __crtLCMapStringA(
                        _loc_update.GetLocaleT(),
                        _loc_update.GetLocaleT()->mbcinfo->mblcid,
                        LCMAP_LOWERCASE,
                        (const char *)val,
                        2,
                        (char *)ret,
                        2,
                        _loc_update.GetLocaleT()->mbcinfo->mbcodepage,
                        TRUE ) == 0 )
                return c;

            c = ret[1];
            c += ret[0] << 8;

            return c;


        }
        else
            return (unsigned int)_mbbtolower_l((int)c, _loc_update.GetLocaleT());
}

extern "C" unsigned int (__cdecl _mbctolower) (
        unsigned int c
        )
{
    return _mbctolower_l(c, NULL);
}

#endif  /* _MBCS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#include <crtdefs.h>


#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif  /* _FILE_DEFINED */

#ifndef _INTERNAL_IFSTRIP_
/*
 * MBCS - Multi-Byte Character Set
 */
#ifndef _THREADMBCINFO
typedef struct threadmbcinfostruct {
        int refcount;
        int mbcodepage;
        int ismbcodepage;
        int mblcid;
        unsigned short mbulinfo[6];
        unsigned char mbctype[257];
        unsigned char mbcasemap[256];
} threadmbcinfo;
#define _THREADMBCINFO
#endif  /* _THREADMBCINFO */
extern pthreadmbcinfo __ptmbcinfo;
pthreadmbcinfo __cdecl __updatetmbcinfo(void);
#endif  /* _INTERNAL_IFSTRIP_ */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_mbsdup")
#undef _mbsdup
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP unsigned char * __cdecl _mbsdup(_In_z_ const unsigned char * _Str);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_mbsdup")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP unsigned int __cdecl _mbbtombc(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbbtombc_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbbtype(_In_ unsigned char _Ch, _In_ int _CType);
_Check_return_ _CRTIMP int __cdecl _mbbtype_l(_In_ unsigned char _Ch, _In_ int _CType, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctombb(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctombb_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_CRTIMP int __cdecl _mbsbtype(_In_bytecount_(_Pos) _Pre_z_ const unsigned char * _Str, _In_ size_t _Pos);
_CRTIMP int __cdecl _mbsbtype_l(_In_bytecount_(_Pos) _Pre_z_ const unsigned char * _Str, _In_ size_t _Pos, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbscat_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_z_ const unsigned char * _Src);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _mbscat_s, unsigned char, _Dst, _In_z_ const unsigned char *, _DstSizeInBytes)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbscat, _Pre_cap_for_(_Source) _Prepost_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source)
_CRTIMP errno_t __cdecl _mbscat_s_l(_Inout_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const unsigned char * _Src, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbscat_s_l, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbscat_l, _mbscat_s_l, _Inout_z_ unsigned char, _Inout_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbschr(_In_z_ const unsigned char * _Str, _In_ unsigned int _Ch);
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbschr_l(_In_z_ const unsigned char * _Str, _In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbscmp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2);
_Check_return_ _CRTIMP int __cdecl _mbscmp_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbscoll(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2);
_Check_return_ _CRTIMP int __cdecl _mbscoll_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbscpy_s(_Out_z_cap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_z_ const unsigned char * _Src);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _mbscpy_s, unsigned char, _Dest, _In_z_ const unsigned char *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbscpy, _Pre_cap_for_(_Source) _Post_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source)
_CRTIMP errno_t __cdecl _mbscpy_s_l(_Out_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const unsigned char * _Src, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbscpy_s, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbscpy_l, _mbscpy_s_l, _Pre_notnull_ _Post_z_ unsigned char, _Pre_notnull_ _Post_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP size_t __cdecl _mbscspn(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Control);
_Check_return_ _CRTIMP size_t __cdecl _mbscspn_l(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Control, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsdec(_In_count_x_(_Pos-_Start +1) _Pre_z_ const unsigned char * _Start, _In_z_ const unsigned char * _Pos);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsdec_l(_In_count_x_(_Pos-_Start+1) _Pre_z_ const unsigned char * _Start, _In_z_ const unsigned char * _Pos, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsicmp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2);
_Check_return_ _CRTIMP int __cdecl _mbsicmp_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsicoll(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2);
_Check_return_ _CRTIMP int __cdecl _mbsicoll_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsinc(_In_z_ const unsigned char * _Ptr);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsinc_l(_In_z_ const unsigned char * _Ptr, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP size_t __cdecl _mbslen(_In_z_ const unsigned char * _Str);
_Check_return_ _CRTIMP size_t __cdecl _mbslen_l(_In_z_ const unsigned char * _Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP size_t __cdecl _mbsnlen(_In_z_ const unsigned char * _Str, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP size_t __cdecl _mbsnlen_l(_In_z_ const unsigned char * _Str, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRTIMP errno_t __cdecl _mbslwr_s(_Inout_opt_z_bytecap_(_SizeInBytes) unsigned char *_Str, _In_ size_t _SizeInBytes);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _mbslwr_s, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbslwr, _Inout_z_, unsigned char, _String)
_CRTIMP errno_t __cdecl _mbslwr_s_l(_Inout_opt_z_bytecap_(_SizeInBytes) unsigned char *_Str, _In_ size_t _SizeInBytes, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _mbslwr_s_l, unsigned char, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbslwr_l, _mbslwr_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_, unsigned char, _String, _In_opt_ _locale_t, _Locale)
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsnbcat_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsnbcat_s, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnbcat, _Inout_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
_CRTIMP errno_t __cdecl _mbsnbcat_s_l(_Inout_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbsnbcat_s_l, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnbcat_l, _mbsnbcat_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP int __cdecl _mbsnbcmp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsnbcmp_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsnbcoll(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsnbcoll_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP size_t __cdecl _mbsnbcnt(_In_bytecount_(_MaxCount) _Pre_z_ const unsigned char * _Str, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP size_t __cdecl _mbsnbcnt_l(_In_bytecount_(_MaxCount) _Pre_z_ const unsigned char * _Str, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsnbcpy_s(_Out_z_cap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsnbcpy_s, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnbcpy, _Out_cap_(_Count) _Post_maybez_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
_CRTIMP errno_t __cdecl _mbsnbcpy_s_l(_Out_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbsnbcpy_s_l, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnbcpy_l, _mbsnbcpy_s_l, _Deref_out_z_bytecap_c_(_Size) unsigned char, _Out_cap_(_Count) _Post_maybez_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP int __cdecl _mbsnbicmp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsnbicmp_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsnbicoll(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsnbicoll_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsnbset_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Ch, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsnbset_s, _Deref_prepost_z_ unsigned char, _Dest, _In_ unsigned int, _Val, _In_ size_t, _MaxCount)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnbset, _mbsnbset_s, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_bytecap_(_MaxCount), unsigned char, _String, _In_ unsigned int, _Val, _In_ size_t, _MaxCount)
_CRTIMP errno_t __cdecl _mbsnbset_s_l(_Inout_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_ unsigned int _Ch, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbsnbset_s_l, _Deref_prepost_z_ unsigned char, _Dest, _In_ unsigned int, _Val, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnbset_l, _mbsnbset_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_bytecap_(_MaxCount), unsigned char, _String, _In_ unsigned int, _Val, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsncat_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsncat_s, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsncat, _Inout_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
_CRTIMP errno_t __cdecl _mbsncat_s_l(_Inout_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbsncat_s_l, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsncat_l, _mbsncat_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP size_t __cdecl _mbsnccnt(_In_bytecount_(_MaxCount) _Pre_z_ const unsigned char * _Str, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP size_t __cdecl _mbsnccnt_l(_In_bytecount_(_MaxCount) _Pre_z_ const unsigned char * _Str, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsncmp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsncmp_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsncoll(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsncoll_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsncpy_s(_Out_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsncpy_s, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsncpy, _Pre_notnull_ _Out_cap_m_(2,_Count) _Post_maybez_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count)
_CRTIMP errno_t __cdecl _mbsncpy_s_l(_Out_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const unsigned char * _Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbsncpy_s_l, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsncpy_l, _mbsncpy_s_l, _Deref_out_z_bytecap_c_(_Size) unsigned char, _Out_cap_(_Count)  _Post_maybez_, unsigned char, _Dest, _In_z_ const unsigned char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP unsigned int __cdecl _mbsnextc (_In_z_ const unsigned char * _Str);
_Check_return_ _CRTIMP unsigned int __cdecl _mbsnextc_l(_In_z_ const unsigned char * _Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsnicmp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsnicmp_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _mbsnicoll(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _mbsnicoll_l(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsninc(_In_bytecount_(_Count) _Pre_z_ const unsigned char * _Str, _In_ size_t _Count);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsninc_l(_In_bytecount_(_Count) _Pre_z_ const unsigned char * _Str, _In_ size_t _Count, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsnset_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Val, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsnset_s, _Deref_prepost_z_ unsigned char, _Dest, _In_ unsigned int, _Val, _In_ size_t, _MaxCount)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnset, _mbsnset_s, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_bytecap_(_MaxCount), unsigned char, _String, _In_ unsigned int, _Val, _In_ size_t, _MaxCount)
_CRTIMP errno_t __cdecl _mbsnset_s_l(_Inout_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_ unsigned int _Val, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbsnset_s_l, _Deref_prepost_z_ unsigned char, _Dest, _In_ unsigned int, _Val, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsnset_l, _mbsnset_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_bytecap_(_MaxCount), unsigned char, _String, _In_ unsigned int, _Val, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbspbrk(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Control);
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbspbrk_l(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Control, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbsrchr(_In_z_ const unsigned char * _Str, _In_ unsigned int _Ch);
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbsrchr_l(_In_z_ const unsigned char *_Str, _In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_CRTIMP unsigned char * __cdecl _mbsrev(_Inout_z_ unsigned char * _Str);
_CRTIMP unsigned char * __cdecl _mbsrev_l(_Inout_z_ unsigned char *_Str, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbsset_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Val);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _mbsset_s, _Deref_prepost_z_ unsigned char, _Dest, _In_ unsigned int, _Val)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsset, _mbsset_s, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_, unsigned char, _String, _In_ unsigned int, _Val)
_CRTIMP errno_t __cdecl _mbsset_s_l(_Inout_z_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _In_ unsigned int _Val, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbsset_s_l, _Deref_prepost_z_ unsigned char, _Dest, _In_ unsigned int, _Val, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsset_l, _mbsset_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_, unsigned char, _String, _In_ unsigned int, _Val, _In_opt_ _locale_t, _Locale)
_Check_return_ _CRTIMP size_t __cdecl _mbsspn(_In_z_ const unsigned char *_Str, _In_z_ const unsigned char * _Control);
_Check_return_ _CRTIMP size_t __cdecl _mbsspn_l(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Control, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsspnp(_In_z_ const unsigned char * _Str1, _In_z_ const unsigned char *_Str2);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbsspnp_l(_In_z_ const unsigned char *_Str1, _In_z_ const unsigned char *_Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbsstr(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Substr);
_Check_return_ _CRTIMP  _CONST_RETURN unsigned char * __cdecl _mbsstr_l(_In_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Substr, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_mbstok_s) unsigned char * __cdecl _mbstok(_Inout_opt_z_ unsigned char * _Str, _In_z_ const unsigned char * _Delim);
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_mbstok_s_l) unsigned char * __cdecl _mbstok_l(_Inout_opt_z_ unsigned char *_Str, _In_z_ const unsigned char * _Delim, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP_ALTERNATIVE unsigned char * __cdecl _mbstok_s(_Inout_opt_z_ unsigned char *_Str, _In_z_ const unsigned char * _Delim, _Inout_ _Deref_prepost_opt_z_ unsigned char ** _Context);
_Check_return_ _CRTIMP unsigned char * __cdecl _mbstok_s_l(_Inout_opt_z_ unsigned char * _Str, _In_z_ const unsigned char * _Delim, _Inout_ _Deref_prepost_opt_z_ unsigned char ** _Context, _In_opt_ _locale_t _Locale);
_CRTIMP errno_t __cdecl _mbsupr_s(_Inout_z_bytecap_(_SizeInBytes) unsigned char *_Str, _In_ size_t _SizeInBytes);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _mbsupr_s, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsupr, _Inout_z_, unsigned char, _String)
_CRTIMP errno_t __cdecl _mbsupr_s_l(_Inout_z_bytecap_(_SizeInBytes) unsigned char *_Str, _In_ size_t _SizeInBytes, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _mbsupr_s_l, unsigned char, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(unsigned char *, __RETURN_POLICY_DST, _CRTIMP, _mbsupr_l, _mbsupr_s_l, _Deref_inout_z_bytecap_c_(_Size) unsigned char, _Inout_z_, unsigned char, _String, _In_opt_ _locale_t, _Locale)

_Check_return_ _CRTIMP size_t __cdecl _mbclen(_In_z_ const unsigned char *_Str);
_Check_return_ _CRTIMP size_t __cdecl _mbclen_l(_In_z_ const unsigned char * _Str, _In_opt_ _locale_t _Locale);
_CRTIMP _CRT_INSECURE_DEPRECATE(_mbccpy_s) void __cdecl _mbccpy(_Out_bytecap_c_(2) unsigned char * _Dst, _In_z_ const unsigned char * _Src);
_CRTIMP _CRT_INSECURE_DEPRECATE(_mbccpy_s_l) void __cdecl _mbccpy_l(_Out_bytecap_c_(2) unsigned char *_Dst, _In_z_ const unsigned char *_Src, _In_opt_ _locale_t _Locale);
_CRTIMP_ALTERNATIVE errno_t __cdecl _mbccpy_s(_Out_z_bytecap_(_SizeInBytes) unsigned char * _Dst, _In_ size_t _SizeInBytes, _Out_opt_ int * _PCopied, _In_z_ const unsigned char * _Src);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _mbccpy_s, unsigned char, _Dest, _Out_opt_ int *, _PCopied, _In_z_ const unsigned char *, _Source)
_CRTIMP errno_t __cdecl _mbccpy_s_l(_Out_bytecap_(_DstSizeInBytes) unsigned char * _Dst, _In_ size_t _DstSizeInBytes, _Out_opt_ int * _PCopied, _In_z_ const unsigned char * _Src, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _mbccpy_s_l, unsigned char, _Dest, _Out_opt_ int *,_PCopied, _In_z_ const unsigned char *,_Source, _In_opt_ _locale_t, _Locale)
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

#ifdef __cplusplus
#ifndef _CPP_MBCS_INLINES_DEFINED
#define _CPP_MBCS_INLINES_DEFINED
extern "C++" {
_Check_return_ inline unsigned char * __CRTDECL _mbschr(_In_z_ unsigned char *_String, _In_ unsigned int _Char)
{
    return ((unsigned char *)_mbschr((const unsigned char *)_String, _Char));
}

_Check_return_ inline unsigned char * __CRTDECL _mbschr_l(_In_z_ unsigned char *_String, _In_ unsigned int _Char, _In_opt_ _locale_t _Locale)
{
    return ((unsigned char *)_mbschr_l((const unsigned char *)_String, _Char, _Locale));
}

_Check_return_ inline unsigned char * __CRTDECL _mbspbrk(_In_z_ unsigned char *_String, _In_z_ const unsigned char *_CharSet)
{
    return ((unsigned char *)_mbspbrk((const unsigned char *)_String, _CharSet));
}

_Check_return_ inline unsigned char * __CRTDECL _mbspbrk_l(_In_z_ unsigned char *_String, _In_z_ const unsigned char *_CharSet, _In_opt_ _locale_t _Locale)
{
    return ((unsigned char *)_mbspbrk_l((const unsigned char *)_String, _CharSet, _Locale));
}

_Check_return_ inline unsigned char * __CRTDECL _mbsrchr(_In_z_ unsigned char *_String, _In_ unsigned int _Char)
{
    return ((unsigned char *)_mbsrchr((const unsigned char *)_String, _Char));
}

_Check_return_ inline unsigned char * __CRTDECL _mbsrchr_l(_In_z_ unsigned char *_String, _In_ unsigned int _Char, _In_opt_ _locale_t _Locale)
{
    return ((unsigned char *)_mbsrchr_l((const unsigned char *)_String, _Char, _Locale));
}

_Check_return_ inline unsigned char * __CRTDECL _mbsstr(_In_z_ unsigned char *_String, _In_z_ const unsigned char *_Match)
{
    return ((unsigned char *)_mbsstr((const unsigned char *)_String, _Match));
}

_Check_return_ inline unsigned char * __CRTDECL _mbsstr_l(_In_z_ unsigned char *_String, _In_z_ const unsigned char *_Match, _In_opt_ _locale_t _Locale)
{
    return ((unsigned char *)_mbsstr_l((const unsigned char *)_String, _Match, _Locale));
}
}
#endif  /* _CPP_MBCS_INLINES_DEFINED */
#endif  /* __cplusplus */

/* character routines */

_Check_return_ _CRTIMP int __cdecl _ismbcalnum(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcalnum_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcalpha(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcalpha_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcdigit(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcdigit_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcgraph(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcgraph_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbclegal(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbclegal_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbclower(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbclower_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcprint(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcprint_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcpunct(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcpunct_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcspace(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcspace_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcupper(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcupper_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);

_Check_return_ _CRTIMP unsigned int __cdecl _mbctolower(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctolower_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctoupper(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctoupper_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);

#define _MBSTRING_DEFINED
#endif  /* _MBSTRING_DEFINED */

#ifndef _MBLEADTRAIL_DEFINED
_Check_return_ _CRTIMP int __cdecl _ismbblead(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbblead_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbbtrail(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbbtrail_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbslead(_In_count_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos);
_Check_return_ _CRTIMP int __cdecl _ismbslead_l(_In_count_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbstrail(_In_count_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos);
_Check_return_ _CRTIMP int __cdecl _ismbstrail_l(_In_count_x_(_Pos - _Str+1) _Pre_z_ const unsigned char * _Str, _In_z_ const unsigned char * _Pos, _In_opt_ _locale_t _Locale);
#define _MBLEADTRAIL_DEFINED
#endif  /* _MBLEADTRAIL_DEFINED */

/*  Kanji specific prototypes.  */

_Check_return_ _CRTIMP int __cdecl _ismbchira(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbchira_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbckata(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbckata_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcsymbol(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcsymbol_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcl0(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcl0_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcl1(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcl1_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _ismbcl2(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP int __cdecl _ismbcl2_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned int __cdecl _mbcjistojms(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbcjistojms_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned int __cdecl _mbcjmstojis(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbcjmstojis_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctohira(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctohira_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctokata(_In_ unsigned int _Ch);
_Check_return_ _CRTIMP unsigned int __cdecl _mbctokata_l(_In_ unsigned int _Ch, _In_opt_ _locale_t _Locale);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mdbghook.cpp ===
/***
*dbgrpt.c - Debug CRT Reporting Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef _DEBUG

#include <internal.h>
#include <crtdbg.h>
#include <mtdll.h>
#include <malloc.h>

#pragma warning(disable:4439) // C4439: function with a managed parameter must have a __clrcall calling convention

volatile _CRT_REPORT_HOOK_M __declspec(appdomain) __pfnReportHookManaged = (_CRT_REPORT_HOOK_M) _encoded_null();

static int __cdecl _CrtReportHook_managed_thunk(int i, char *pCh, int *pInt)
{
    // Avoid thread-sync issues
    _CRT_REPORT_HOOK_M pfnReportHookManaged = (_CRT_REPORT_HOOK_M) _decode_pointer(__pfnReportHookManaged);

    if (pfnReportHookManaged != NULL)
    {
        return (*pfnReportHookManaged)(i, pCh, pInt);
    }
    else
    {
        return 0;
    }
}

static void __clrcall _CrtReportHook_managed_cleanup(void)
{
    _CRT_REPORT_HOOK pfnReportHook=_CrtGetReportHook();
    _CRT_REPORT_HOOK_M enull = (_CRT_REPORT_HOOK_M) _encoded_null();
    if(pfnReportHook==_CrtReportHook_managed_thunk && __pfnReportHookManaged!=enull)
    {
        _CrtSetReportHook((_CRT_REPORT_HOOK)NULL);
    }
    __pfnReportHookManaged=enull;
}

/***
*_CRT_REPORT_HOOK_M _CrtSetReportHook() - set client report hook
*
*Purpose:
*       set client report hook
*
*Entry:
*       _CRT_REPORT_HOOK_M pfnNewHook - new report hook
*
*Exit:
*       return previous hook
*
*Exceptions:
*
*******************************************************************************/
_MRTIMP _CRT_REPORT_HOOK_M __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK_M pfnNewHook
        )
{
    if(_atexit_m_appdomain(_CrtReportHook_managed_cleanup)!=0)
    {
        return NULL;
    }

    _CRT_REPORT_HOOK_M pfnOldHook = (_CRT_REPORT_HOOK_M) _decode_pointer(__pfnReportHookManaged);
    if (pfnNewHook)
    {
        __pfnReportHookManaged = (_CRT_REPORT_HOOK_M) _encode_pointer(pfnNewHook);
        _CrtSetReportHook((_CRT_REPORT_HOOK)_CrtReportHook_managed_thunk);
    }
    else
    {
        _CRT_REPORT_HOOK_M enull = (_CRT_REPORT_HOOK_M) _encoded_null();
        __pfnReportHookManaged = enull;
        _CrtSetReportHook((_CRT_REPORT_HOOK)NULL);
    }
    return pfnOldHook;
}

_MRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        int pfnNewHook
        )
{
    _VALIDATE_RETURN(pfnNewHook == NULL, EINVAL, NULL);

    return _CrtSetReportHook((_CRT_REPORT_HOOK)NULL);
}

/***
static int __cdecl _CrtAllocHook_managed_thunk
(
    int allocType,
    void *userData,
    size_t size,
    int blockType,
    long requestNumber,
    const unsigned char *filename,
    int lineNumber
)
*
*Purpose:
*       thunk m-> client alloc hook
*
*Exceptions:
*
*******************************************************************************/
volatile _CRT_ALLOC_HOOK_M __declspec(appdomain) __pfnAllocHookManaged = (_CRT_ALLOC_HOOK_M) _encoded_null();

static int __cdecl _CrtAllocHook_managed_thunk
(
    int allocType,
    void *userData,
    size_t size,
    int blockType,
    long requestNumber,
    const unsigned char *filename,
    int lineNumber
)
{
    // Avoid thread-sync issues
    _CRT_ALLOC_HOOK_M pfnAllocHookManaged= (_CRT_ALLOC_HOOK_M) _decode_pointer(__pfnAllocHookManaged);

    if (pfnAllocHookManaged != NULL)
    {
        return (*pfnAllocHookManaged)(allocType, userData, size, blockType, requestNumber, filename, lineNumber);
    }
    else
    {
        // we want to return 1 (TRUE) here
        // because if we return 0 (FALSE) it will call _CrtDbgReport()
        return 1;
    }
}

static void __clrcall _CrtAllocHook_managed_cleanup(void)
{
    _CRT_ALLOC_HOOK pfnAllocHook=_CrtGetAllocHook();
    _CRT_ALLOC_HOOK_M enull = (_CRT_ALLOC_HOOK_M) _encoded_null();
    if(pfnAllocHook==_CrtAllocHook_managed_thunk && __pfnAllocHookManaged!=enull)
    {
        _CrtSetAllocHook((_CRT_ALLOC_HOOK)NULL);
    }
    __pfnAllocHookManaged=enull;
}

/***
*_CRT_ALLOC_HOOK_M _CrtSetAllocHook() - set client report hook
*
*Purpose:
*       set client alloc hook
*
*Entry:
*       _CRT_ALLOC_HOOK_M pfnNewHook - new alloc hook
*
*Exit:
*       return previous hook
*
*Exceptions:
*
*******************************************************************************/
_MRTIMP _CRT_ALLOC_HOOK_M __cdecl _CrtSetAllocHook
(
    _CRT_ALLOC_HOOK_M pfnNewHook
)
{
    if(_atexit_m_appdomain(_CrtAllocHook_managed_cleanup)!=0)
    {
        return NULL;
    }

    _CRT_ALLOC_HOOK_M pfnOldHook = (_CRT_ALLOC_HOOK_M) _decode_pointer(__pfnAllocHookManaged);
    if (pfnNewHook)
    {
        __pfnAllocHookManaged = (_CRT_ALLOC_HOOK_M) _encode_pointer(pfnNewHook);
        _CrtSetAllocHook((_CRT_ALLOC_HOOK)_CrtAllocHook_managed_thunk);
    }
    else
    {
        _CRT_ALLOC_HOOK_M enull = (_CRT_ALLOC_HOOK_M) _encoded_null();
        __pfnAllocHookManaged = enull;
        _CrtSetAllocHook((_CRT_ALLOC_HOOK)NULL);
    }
    return pfnOldHook;
}

_MRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook
(
    int pfnNewHook
)
{
    _VALIDATE_RETURN(pfnNewHook == NULL, EINVAL, NULL);

    return _CrtSetAllocHook((_CRT_ALLOC_HOOK)NULL);
}

/***
static void __cdecl _CrtDumpClient_managed_thunk
(
    void *userPortion,
    size_t blockSize
)
*
*Purpose:
*       thunk m-> client dump hook
*
*Exceptions:
*
*******************************************************************************/
volatile _CRT_DUMP_CLIENT_M __declspec(appdomain) __pfnDumpClientManaged = (_CRT_DUMP_CLIENT_M) _encoded_null();

static void __cdecl _CrtDumpClient_managed_thunk
(
    void *userPortion,
    size_t blockSize
)
{
    // Avoid thread-sync issues
    _CRT_DUMP_CLIENT_M pfnDumpClientManaged = (_CRT_DUMP_CLIENT_M) _decode_pointer(__pfnDumpClientManaged);

    if (pfnDumpClientManaged != NULL)
    {
        (*pfnDumpClientManaged)(userPortion, blockSize);
    }
}

static void __clrcall _CrtDumpClient_managed_cleanup(void)
{
    _CRT_DUMP_CLIENT pfnDumpClient=_CrtGetDumpClient();
    _CRT_DUMP_CLIENT_M enull = (_CRT_DUMP_CLIENT_M) _encoded_null();
    if(pfnDumpClient==_CrtDumpClient_managed_thunk && __pfnDumpClientManaged!=enull)
    {
        _CrtSetDumpClient((_CRT_DUMP_CLIENT)NULL);
    }
    __pfnDumpClientManaged=enull;
}

/***
*_CRT_DUMP_CLIENT_M _CrtSetDumpClient() - set client dump hook
*
*Purpose:
*       set client dump hook
*
*Entry:
*       _CRT_DUMP_CLIENT_M pfnNewHook - new dump hook
*
*Exit:
*       return previous hook
*
*Exceptions:
*
*******************************************************************************/
_MRTIMP _CRT_DUMP_CLIENT_M __cdecl _CrtSetDumpClient
(
    _CRT_DUMP_CLIENT_M pfnNewHook
)
{
    if(_atexit_m_appdomain(_CrtDumpClient_managed_cleanup)!=0)
    {
        return NULL;
    }

    _CRT_DUMP_CLIENT_M pfnOldHook = (_CRT_DUMP_CLIENT_M) _decode_pointer(__pfnDumpClientManaged);
    if (pfnNewHook)
    {
        __pfnDumpClientManaged = (_CRT_DUMP_CLIENT_M) _encode_pointer(pfnNewHook);
        _CrtSetDumpClient((_CRT_DUMP_CLIENT)_CrtDumpClient_managed_thunk);
    }
    else
    {
        _CRT_DUMP_CLIENT_M enull = (_CRT_DUMP_CLIENT_M) _encoded_null();
        __pfnDumpClientManaged = enull;
        _CrtSetDumpClient((_CRT_DUMP_CLIENT)NULL);
    }
    return pfnOldHook;
}

_MRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient
(
    int pfnNewHook
)
{
    _VALIDATE_RETURN(pfnNewHook == NULL, EINVAL, NULL);

    return _CrtSetDumpClient((_CRT_DUMP_CLIENT)NULL);
}

/*
 * The implementation here is not ideal. The problem is when to free the list.
 * If we free it before process shutdown, any problem after that could not be
 * reported.
 */

/***
* CCrtReportHook2DB Class for keeping track of all the report hooks.
*******************************************************************************/

/*
FUTURE: I did a trivial templatisation of this code to support W hooks. Cleanup to bind into a single template class would be nice.
*/

template<typename HookType>
static int __cdecl _CrtSetReportHook2_thunk
(
    int mode,
    HookType pfnNewHook
);

template<>
static int __cdecl _CrtSetReportHook2_thunk
(
    int mode,
    _CRT_REPORT_HOOK pfnNewHook
)
{
    return _CrtSetReportHook2(mode, pfnNewHook);
}

template<>
static int __cdecl _CrtSetReportHook2_thunk
(
    int mode,
    _CRT_REPORT_HOOKW pfnNewHook
)
{
    return _CrtSetReportHookW2(mode, pfnNewHook);
}

template<typename HookType, typename CharType>
class CCrtReportHook2DB
{
public:
    struct CReportHookList
    {
        CReportHookList *m_pNext;
        CReportHookList *m_pPrev;
        HookType m_Hook;
        int m_Refcount;

        CReportHookList()
            : m_pNext(NULL), m_pPrev(NULL), m_Hook(NULL), m_Refcount(0)
        {
        }

        static CReportHookList* create()
        {
            return reinterpret_cast<CReportHookList*>(calloc(1, sizeof(CReportHookList)));
        }

        static void destroy(CReportHookList* pReportHookList)
        {
            free(pReportHookList);
        }
    };

    CReportHookList *findHook(HookType pfnHook)
    {
        CReportHookList *retval=NULL;

        for (retval = m_HeadNode.m_pNext;
                retval != NULL && retval->m_Hook != pfnHook;
                retval = retval->m_pNext);

        return retval;
    }

    int updateHook(CReportHookList *pCReportHookList)
    {
        int retval = 0;
        if (pCReportHookList->m_pPrev != NULL)
        {
            disconnect(pCReportHookList);
            setHead(pCReportHookList);
            retval = pCReportHookList->m_Refcount++;
        }
        else
        {
            setHead(pCReportHookList);
            retval = pCReportHookList->m_Refcount = 1;
        }
        return retval;
    }

    int deleteHook(CReportHookList *pCReportHookList)
    {
        int retval = 0;
        if ((retval = --pCReportHookList->m_Refcount) == 0)
        {
            disconnect(pCReportHookList);
            CReportHookList::destroy(pCReportHookList);
        }
        return retval;
    }

    /* lock must be already held */
    int callReportHooks(int i, CharType *pCh, int *pInt)
    {
        int retval = 0;
        for (CReportHookList *ptmp = m_HeadNode.m_pNext;
                ptmp != NULL;
                ptmp = ptmp->m_pNext)
        {
            if (ptmp->m_Hook)
            {
                if (retval = (*(ptmp->m_Hook))(i, pCh, pInt))
                    break;
            }
        }
        return retval;
    }

    /* lock must be already held */
    void removeReportHooks()
    {
        CReportHookList* ptmp = m_HeadNode.m_pNext;
        while (ptmp != NULL)
        {
            CReportHookList* current = ptmp;
            ptmp = ptmp->m_pNext;
            CReportHookList::destroy(current);
        }
    }

    CCrtReportHook2DB()
    {
    }

    static __declspec(appdomain) bool callback_registered;
    static __declspec(appdomain) class CCrtReportHook2DB<HookType, CharType> __ReportHookDB;

private:
    void disconnect(CReportHookList* pCReportHookList)
    {
        // Remove an item from the list

        // Assume item is in list
        pCReportHookList->m_pPrev->m_pNext = pCReportHookList->m_pNext;

        // Check whether item is at end of list
        if (pCReportHookList->m_pNext)
        {
            pCReportHookList->m_pNext->m_pPrev = pCReportHookList->m_pPrev;
        }
    }

    void setHead(CReportHookList* pCReportHookList)
    {
        pCReportHookList->m_pNext = m_HeadNode.m_pNext;
        if (pCReportHookList->m_pNext != NULL)
        {
            pCReportHookList->m_pNext->m_pPrev = pCReportHookList;
        }
        m_HeadNode.m_pNext = pCReportHookList;
        pCReportHookList->m_pPrev = &m_HeadNode;
    }

    // Data members
private:
    CReportHookList m_HeadNode;
};

template<typename HookType, typename CharType>
__declspec(appdomain) bool CCrtReportHook2DB<HookType, CharType>::callback_registered=false;

template<typename HookType, typename CharType>
__declspec(appdomain) CCrtReportHook2DB<HookType, CharType> CCrtReportHook2DB<HookType, CharType>::__ReportHookDB;

template<typename CharType, typename DBType>
static int __cdecl _CrtReportHook2_managed_thunk(int i, CharType *pCh, int *pInt)
{
    /* lock was already taken by caller */
    return DBType::__ReportHookDB.callReportHooks(i, pCh, pInt);
}

template<typename NativeHookType, typename CharType, typename DBType>
static void __clrcall _CrtReportHook2_managed_cleanup(void)
{
    _CrtSetReportHook2_thunk(_CRT_RPTHOOK_REMOVE, static_cast<NativeHookType>(_CrtReportHook2_managed_thunk<CharType, DBType>) );

    _mlock(_DEBUG_LOCK);
    __try
    {
        DBType::__ReportHookDB.removeReportHooks();
    }
    __finally
    {
        _munlock(_DEBUG_LOCK);
    }
}

/***
*_CRT_REPORT_HOOK_M _CrtSetReportHook2() - configure client report hook in list
*
*Purpose:
*       Install or remove a client report hook from the report list.  Exists
*       separately from _CrtSetReportHook because the older function doesn't
*       work well in an environment where DLLs that are loaded and unloaded
*       dynamically out of LIFO order want to install report hooks.
*
*Entry:
*       int mode - _CRT_RPTHOOK_INSTALL or _CRT_RPTHOOK_REMOVE
*       _CRT_REPORT_HOOK_M pfnNewHook - report hook to install/remove/query
*
*Exit:
*       Returns -1 if an error was encountered, with EINVAL or ENOMEM set,
*       else returns the reference count of pfnNewHook after the call.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

template<typename NativeHookType, typename HookType, typename CharType, typename DBType>
int __cdecl _CrtSetReportHook2_impl
(
    int mode,
    HookType pfnNewHook,
    int (* pfnHook)(int, NativeHookType)
)
{
    DBType::CReportHookList *pHook=NULL;
    int ret=0;

    /* validation section */
    _VALIDATE_RETURN(mode == _CRT_RPTHOOK_INSTALL || mode == _CRT_RPTHOOK_REMOVE, EINVAL, -1);
    _VALIDATE_RETURN(pfnNewHook != NULL, EINVAL, -1);

    _mlock(_DEBUG_LOCK);
    __try
    {

        /* Search for new hook function to see if it's already installed */
        pHook = DBType::__ReportHookDB.findHook(pfnNewHook);

        if (mode == _CRT_RPTHOOK_REMOVE)
        {
            /* Remove request - free list node if refcount goes to zero */
            if (pHook != NULL)
            {
                DBType::__ReportHookDB.deleteHook(pHook);
            }
            else
            {
                _RPTF0(_CRT_ASSERT, "The hook function is not in the list!");
                ret = -1;
                errno = EINVAL;
            }
        }
        else
        {
            /* Insert request */
            if (pHook != NULL)
            {
                /* Hook function already registered, move to head of list */
                ret = DBType::__ReportHookDB.updateHook(pHook);
            }
            else
            {
                /* Hook function not already registered, insert new node */
                pHook = DBType::CReportHookList::create();
                if (pHook == NULL)
                {
                    /* malloc fails: we do not assert here */
                    ret = -1;
                    errno = ENOMEM;
                }
                else
                {
                    pHook->m_Hook = pfnNewHook;
                    ret = DBType::__ReportHookDB.updateHook(pHook);
                    if (DBType::callback_registered == false)
                    {
                        if(_atexit_m_appdomain(_CrtReportHook2_managed_cleanup<NativeHookType, CharType, DBType>)!=0)
                        {
                            ret=-1;
                            errno=ENOMEM;
                        }
                        else
                        {
                            pfnHook(_CRT_RPTHOOK_INSTALL, static_cast<NativeHookType>(_CrtReportHook2_managed_thunk<CharType, DBType>));

                            DBType::callback_registered=true;
                        }
                    }
                }
            }
        }

    }
    __finally
    {
        _munlock(_DEBUG_LOCK);
    }

    return ret;
}

_MRTIMP int __cdecl _CrtSetReportHook2
(
    int mode,
    _CRT_REPORT_HOOK_M pfnNewHook
)
{
    return _CrtSetReportHook2_impl<_CRT_REPORT_HOOK, _CRT_REPORT_HOOK_M, char, CCrtReportHook2DB<_CRT_REPORT_HOOK_M, char> >(mode, pfnNewHook, _CrtSetReportHook2_thunk );
}

_MRTIMP int __cdecl _CrtSetReportHookW2
(
    int mode,
    _CRT_REPORT_HOOKW_M pfnNewHook
)
{
    return _CrtSetReportHook2_impl<_CRT_REPORT_HOOKW, _CRT_REPORT_HOOKW_M, wchar_t, CCrtReportHook2DB<_CRT_REPORT_HOOKW_M, wchar_t> >(mode, pfnNewHook, _CrtSetReportHook2_thunk);
}
#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mbtowenv.c ===
/***
*mbtowenv.c - convert multibyte environment block to wide
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __mbtow_environ(). Create a wide character equivalent of
*       an existing multibyte environment block.
*
*******************************************************************************/


#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <dbgint.h>

/***
*__mbtow_environ - copy multibyte environment block to wide environment block
*
*Purpose:
*       Create a wide character equivalent of an existing multibyte
*       environment block.
*
*Entry:
*       Assume _environ (global pointer) points to existing multibyte
*       environment block.
*
*Exit:
*       If success, every multibyte environment variable has been added to
*       the wide environment block and returns 0.
*       If failure, returns -1.
*
*Exceptions:
*       If space cannot be allocated, returns -1.
*
*******************************************************************************/

int __cdecl __mbtow_environ (
        void
        )
{
        int size;
        wchar_t *wenvp=NULL;
        char **envp = _environ;

        /*
         * For every environment variable in the multibyte environment,
         * convert it and add it to the wide environment.
         */

        while (*envp)
        {
            /* find out how much space is needed */
            if ((size = MultiByteToWideChar(CP_ACP, 0, *envp, -1, NULL, 0)) == 0)
                return -1;

            /* allocate space for variable */
            if ((wenvp = (wchar_t *) _calloc_crt(size, sizeof(wchar_t))) == NULL)
                return -1;

            /* convert it */
            if ((size = MultiByteToWideChar(CP_ACP, 0, *envp, -1, wenvp, size)) == 0)
            {
                _free_crt(wenvp);
                return -1;
            }

            /* set it - this is not primary call, so set primary == 0 */
            if(__crtwsetenv(&wenvp, 0)<0)
            {
                /* If the set fails, free the duplicated env string and bail */
                if(wenvp)
                {
                    _free_crt(wenvp);
                    wenvp=NULL;
                }
                return -1;
            }

            envp++;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mcrtexew.cpp ===
/***
*wcrtexew.c - Initialization for Windows EXE using CRT DLL, wchar_t version
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps using wide
*       characters.  It calls the user's main routine wWinMain() after
*       performing C Run-Time Library initialization.
*
*******************************************************************************/

#ifdef MRTDLL

#define _WINMAIN_
#include "mcrtexe.cpp"

#endif  /* MRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memccpy.c ===
/***
*memccpy.c - copy bytes until a character is found
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _memccpy() - copies bytes until a specifed character
*       is found, or a maximum number of characters have been copied.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_memccpy(dest, src, c, count) - copy bytes until character found
*
*Purpose:
*       Copies bytes from src to dest until count bytes have been
*       copied, or up to and including the character c, whichever
*       comes first.
*
*Entry:
*       void *dest - pointer to memory to receive copy
*       void *src  - source of bytes
*       int  c     - character to stop copy at
*       size_t count - max number of bytes to copy
*
*Exit:
*       returns pointer to byte immediately after c in dest
*       returns NULL if c was never found
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _memccpy (
        void * dest,
        const void * src,
        int c,
        size_t count
        )
{
        while ( count && (*((char *)(dest = (char *)dest + 1) - 1) =
        *((char *)(src = (char *)src + 1) - 1)) != (char)c )
                count--;

        return(count ? dest : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mcrtexe.cpp ===
/***
*crtexe.c - Initialization for console EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps linking to the CRT DLL.
*       It calls the user's main routine [w]main() or [w]WinMain after
*       performing C Run-Time Library initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrtexe.c   the startup routine for console apps with wide chars
*       crtexew.c   the startup routine for Windows apps
*       wcrtexew.c  the startup routine for Windows apps with wide chars
*
*******************************************************************************/

#ifdef MRTDLL
#using <mscorlib.dll>

/*
 * SPECIAL BUILD MACROS! Note that crtexe.c (and crtexew.c) is linked in with
 * the client's code. It does not go into crtdll.dll! Therefore, it must be
 * built under the _DLL switch (like user code) and MRTDLL must be undefined.
 * The symbol SPECIAL_CRTEXE is turned on to suppress the normal CRT DLL
 * definition of _fmode and _commode using __declspec(dllexport).  Otherwise
 * this module would not be able to refer to both the local and DLL versions
 * of these two variables.
 */

#undef  MRTDLL
#ifndef _DLL
#define _DLL
#endif  /* _DLL */

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <process.h>
#include <math.h>
#include <rterr.h>
#include <stdlib.h>
#include <tchar.h>
#include <sect_attribs.h>
#include <stddef.h>
#include <locale.h>
#include <dbgint.h>
#include <new.h>
#include <rtcapi.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention

/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  The atexit/_onexit code is shared for both EXE's and
 * DLL's but different behavior is required.  These values are set to -1 to
 * mark this module as an EXE.
 * NOTE - the pointers are stored encoded.
 */

#if defined (_M_CEE_MIXED)
extern "C"
{
extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;
}

#pragma managed(push, off)

static int __cdecl _mixed_pre_c_init(void);

_CRTALLOC(".CRT$XIAA") static _PIFV mixed_pcinit = _mixed_pre_c_init;

#pragma managed(pop)

#endif  /* defined (_M_CEE_MIXED) */

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

#if !defined (_MANAGED_MAIN)
#if defined (UNICODE)
        extern "C" int __CxxPureMSILEntry(int, wchar_t **, wchar_t **);
        #define __tinit_cmdline __winit_cmdline
#else  /* defined (UNICODE) */
        extern "C" int __CxxPureMSILEntry(int, char **, char **);
        #define __tinit_cmdline __init_cmdline
#endif  /* defined (UNICODE) */
    using System::String;
    using System::Int32;
    static int __clrcall __tinit_cmdline(cli::array<String^> ^arguments);
#else  /* !defined (_MANAGED_MAIN) */
    using System::String;
    using System::Int32;
    int __clrcall main(cli::array<String^>^);
    static void __clrcall __set_managed_app_type(void);
#endif  /* !defined (_MANAGED_MAIN) */
static void __CLRCALL_OR_CDECL _common_init();

/*
 * Declare the names of the exports corresponding to _fmode and _commode
 */

#define _IMP___FMODE    (__p__fmode())
#define _IMP___COMMODE  (__p__commode())

#if defined (WPRFLAG)
#define _IMP___WCMDLN   (__p__wcmdln())
#else  /* defined (WPRFLAG) */
#define _IMP___ACMDLN   (__p__acmdln())
#endif  /* defined (WPRFLAG) */

#if !defined (_M_IX86)
extern "C"
{
    _CRTIMP int* (__cdecl __p__fmode)();
    _CRTIMP int* (__cdecl __p__commode)();
}
#endif  /* !defined (_M_IX86) */

extern int _fmode;          /* must match the definition in <stdlib.h> */
extern int _commode;        /* must match the definition in <internal.h> */
extern int _dowildcard;     /* passed to __getmainargs() */

/*
 * Declare/define communal that serves as indicator the default matherr
 * routine is being used.
 */
extern "C"
{
    extern int __defaultmatherr;
    void __clrcall __set_matherr();

    /*
     * Declare function used to install a user-supplied _matherr routine.
     */
    _CRTIMP void __setusermatherr( int (__cdecl *)(struct _exception *) );
}

#if defined (_M_CEE_MIXED)

#pragma managed(push, off)

/***
*_mixed_pre_c_init(void)
*
*Purpose:
*       The code in mainCRTStartup that was executed before executing C
*       initializers was shifted in this function. Also this funciton is the
*       first thing that is executed in c init section.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

static int __cdecl _mixed_pre_c_init(void)
{
    /*
     * Mark this module as an EXE file so that atexit/_onexit
     * will do the right thing when called, including for C++
     * d-tors.
     */
    __onexitbegin = __onexitend = (_PVFV *)_encode_pointer((_PVFV *)(-1));

    if ( !__defaultmatherr )
            __setusermatherr(_matherr);

    /*
     * Run the RTC initialization code
     */
#ifdef _RTC
    _RTC_Initialize();
#endif  /* _RTC */

    _common_init();

    return 0;
}

#pragma managed(pop)

#endif  /* defined (_M_CEE_MIXED) */

/***
*mainCRTStartup(void)
*wmainCRTStartup(void)
*WinMainCRTStartup(void)
*wWinMainCRTStartup(void)
*
*Purpose:
*       These routines do the C runtime initialization, call the appropriate
*       user entry function, and handle termination cleanup.  For a managed
*       app, they then return the exit code back to the calling routine, which
*       is the managed startup code.  For an unmanaged app, they call exit and
*       never return.
*
*       Function:               User entry called:
*       mainCRTStartup          main
*       wmainCRTStartup         wmain
*       WinMainCRTStartup       WinMain
*       wWinMainCRTStartup      wWinMain
*
*Entry:
*
*Exit:
*       Managed app: return value from main() et al, or the exception code if
*                 execution was terminated by the __except guarding the call
*                 to main().
*       Unmanaged app: never return.
*
*******************************************************************************/

#if !defined (_MANAGED_MAIN)
#ifdef _WINMAIN_
#ifdef WPRFLAG
  #define _mainCRTStartup wWinMainCRTStartup
#else  /* WPRFLAG */
  #define _mainCRTStartup WinMainCRTStartup
#endif  /* WPRFLAG */
#else  /* _WINMAIN_ */
#ifdef WPRFLAG
  #define _mainCRTStartup wmainCRTStartup
#else  /* WPRFLAG */
  #define _mainCRTStartup mainCRTStartup
#endif  /* WPRFLAG */
#endif  /* _WINMAIN_ */
#else  /* !defined (_MANAGED_MAIN) */
    #define _mainCRTStartup __clrcall mainCRTStartupStrArray
#endif  /* !defined (_MANAGED_MAIN) */

#if !defined (_MANAGED_MAIN) && defined (_WINMAIN_)
int _mainCRTStartup(void)
#else  /* !defined (_MANAGED_MAIN) && defined (_WINMAIN_) */
int _mainCRTStartup(array<String^>^ arguments)
#endif  /* !defined (_MANAGED_MAIN) && defined (_WINMAIN_) */
{
        int argc;   /* three standard arguments to main */
        _TCHAR **argv;
        _TCHAR **envp;

        int argret;
        int mainret;
        _startupinfo    startinfo;

#ifdef _WINMAIN_
        _TCHAR *lpszCommandLine;
        BOOL inDoubleQuote=FALSE;

        STARTUPINFO __startup_info;
        GetStartupInfo(&__startup_info);
#endif  /* _WINMAIN_ */
        /*
         * Guard the initialization code and the call to user's main, or
         * WinMain, function in a __try/__except statement.
         */

        __try {

#if defined (_M_CEE_PURE)
            _common_init();
#endif  /* defined (_M_CEE_PURE) */

            /*
             * Call _setargv(), which will trigger a call to __setargv() if
             * SETARGV.OBJ is linked with the EXE.  If SETARGV.OBJ is not
             * linked with the EXE, a dummy _setargv() will be called.
             */
#ifdef WPRFLAG
            _wsetargv();
#else  /* WPRFLAG */
            _setargv();
#endif  /* WPRFLAG */

#if defined (_M_CEE_PURE)
            /*
             * If the user has supplied a _matherr routine then set
             * __pusermatherr to point to it.
             */
            __set_matherr();
#endif  /* defined (_M_CEE_PURE) */

            startinfo.newmode = _query_new_mode();


#if !defined (_MANAGED_MAIN) && !defined (_WINMAIN_)
            /* init the cmdline (_acmdln or _wcmdln) with the array<String^> */
            /* no need to do this if we use managed main or WinMain */
            argret = __tinit_cmdline(arguments);
            if (argret < 0)
                _amsg_exit(_RT_SPACEARG);
#endif  /* !defined (_MANAGED_MAIN) && !defined (_WINMAIN_) */

#ifdef WPRFLAG
            argret = __wgetmainargs(&argc, &argv, &envp,
                                    _dowildcard, &startinfo);
#else  /* WPRFLAG */
            argret = __getmainargs(&argc, &argv, &envp,
                                   _dowildcard, &startinfo);
#endif  /* WPRFLAG */

            if (argret < 0)
                _amsg_exit(_RT_SPACEARG);

#if defined (_MANAGED_MAIN)
            mainret = main(arguments);
#else  /* defined (_MANAGED_MAIN) */

#ifdef _WINMAIN_
            /*
             * Skip past program name (first token in command line).
             * Check for and handle quoted program name.
             */
#ifdef WPRFLAG
            /* OS may not support "W" flavors */
            lpszCommandLine = (wchar_t *) *_IMP___WCMDLN;
            if ( lpszCommandLine == NULL)
                return 255;
#else  /* WPRFLAG */
            lpszCommandLine = (char *) *_IMP___ACMDLN;
#endif  /* WPRFLAG */

            while (*lpszCommandLine > SPACECHAR ||
                   (*lpszCommandLine&&inDoubleQuote)) {
                /*
                 * Flip the count from 1 to 0 or 0 to 1 if current character
                 * is DOUBLEQUOTE
                 */
                if (*lpszCommandLine==DQUOTECHAR) inDoubleQuote=!inDoubleQuote;
#ifdef _MBCS
                if (_ismbblead(*lpszCommandLine)) {
                    if (lpszCommandLine) {
                        lpszCommandLine++;
                    }
                }
#endif  /* _MBCS */
                ++lpszCommandLine;
            }

            /*
             * Skip past any white space preceeding the second token.
             */
            while (*lpszCommandLine && (*lpszCommandLine <= SPACECHAR)) {
                lpszCommandLine++;
            }

            mainret = _tWinMain(
                       NULL,
                       NULL,
                       lpszCommandLine,
                       __startup_info.dwFlags & STARTF_USESHOWWINDOW
                        ? __startup_info.wShowWindow
                        : SW_SHOWDEFAULT
                      );
#else  /* _WINMAIN_ */

            mainret = __CxxPureMSILEntry(argc, argv, envp);

#endif  /* _WINMAIN_ */

#endif  /* defined (_MANAGED_MAIN) */

        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
            /*
             * Should never reach here
             */
            mainret = GetExceptionCode();
        } /* end of try - except */

        return mainret;
}

#if !defined (_MANAGED_MAIN) && !defined (_WINMAIN_)

static int __clrcall __tinit_cmdline(array<String^> ^arguments)
{
    ::System::Text::StringBuilder sb;
    const ::System::Char SPACE_SCHAR = ' ';
    const ::System::Char DQUOTE_SCHAR = '\"';
    const ::System::Char SLASH_SCHAR = '\\';
    const _TCHAR SPACE_TCHAR = _T(' ');
    const _TCHAR DQUOTE_TCHAR = _T('\"');
    const _TCHAR QUESTIONMARK_TCHAR = _T('?');

    /* To add the arguments to the cmdline, we use the same rules used to parse the cmdline,
       from parse_cmdline, in stdargv.c. The rules are:

            2N backslashes + "      ==> N backslashes and begin/end quote
            2N+1 backslashes + "    ==> N backslashes + literal "
            N backslashes           ==> N backslashes

       so here we use the reverse:

            always surround each argument with doublequotes
            a literal " in the argument becomes 1 backslash + literal "
            N backslashes + literal " become 2N+1 backslashes + literal "
            N backslashes at the end of the argument become 2N backslashes (because we have the closing doublequote)
     */
    for each (String ^arg in arguments)
    {
        sb.Append(SPACE_SCHAR); /* insert a space between the args */
        sb.Append(DQUOTE_SCHAR); /* begin with a double quote */
        for (int i = 0; i < arg->Length; ++i)
        {
            if (arg[i] == DQUOTE_SCHAR)
            {
                sb.Append(SLASH_SCHAR);
                sb.Append(DQUOTE_SCHAR);
            }
            else if (arg[i] == SLASH_SCHAR)
            {
                int numSlash = 0;
                while (i < arg->Length && arg[i] == SLASH_SCHAR)
                {
                    ++numSlash;
                    ++i;
                }
                if (i < arg->Length)
                {
                    if (arg[i] == DQUOTE_SCHAR)
                    {
                        /* we have a 'literal' double quote preceeded by numSlash backslashes:
                        we will need to append 2 * numSlash backslashes + 1 backslash + 1 double quote */
                        sb.Append(SLASH_SCHAR, (2 * numSlash) + 1);
                        sb.Append(DQUOTE_SCHAR);
                    }
                    else
                    {
                        /* we have a non double quote char (arg[i]) preceeded by numSlash backslashes:
                        we will simply need to append numSlash backslashes + arg[i] */
                        sb.Append(SLASH_SCHAR, numSlash);
                        sb.Append(arg[i]);
                    }
                }
                else
                {
                    /* the string ends with numSlash backslashes: we need to append 2 * numSlash backslashes
                    and then add the final double quote (below) */
                    sb.Append(SLASH_SCHAR, 2 * numSlash);
                    break;
                }
            }
            else
            {
                /* normal char (not a double quote nor a backslash) */
                sb.Append(arg[i]);
            }
        }
        sb.Append(DQUOTE_SCHAR); /* end with a double quote */
    }

    size_t cchArguments = sb.Length;
#ifndef WPRFLAG
    cchArguments *= MB_CUR_MAX; /* for multibyte chars, assume that every char will use the maximum space (for this locale) */
#endif  /* WPRFLAG */
    size_t cmdlineSize =
        1 +             /* begin double quote for argv[0] */
        MAX_PATH +      /* argv[0] */
        1 +             /* end double quote for argv[0] */
        cchArguments +  /* argv[1..(argc - 1)] (contains initial space) */
        1;              /* terminating null */

    _TCHAR *tcmdline = (_TCHAR *)_malloc_crt(cmdlineSize * sizeof(_TCHAR));
    if (tcmdline == NULL)
    {
        return -1;
    }

    _TCHAR *p = tcmdline;

    *p++ = DQUOTE_TCHAR;
    int cch = GetModuleFileName(NULL, p, MAX_PATH);
    p += cch;
    *p++ = DQUOTE_TCHAR;

#ifndef WPRFLAG
    int bytesWritten = -1;
    errno_t saveErrno = errno;
#endif  /* WPRFLAG */
    for (int i = 0; i < sb.Length; ++i)
    {
        wchar_t wc = sb[i];
#ifdef WPRFLAG
        *p++ = wc;
#else  /* WPRFLAG */
        wctomb_s(&bytesWritten, p, cmdlineSize - (p - tcmdline), wc);
        if (bytesWritten == -1)
        {
            *p++ = QUESTIONMARK_TCHAR;
        }
        else
        {
            p += bytesWritten;
        }
#endif  /* WPRFLAG */
    }
    *p = 0;
#ifndef WPRFLAG
    errno = saveErrno;
#endif  /* WPRFLAG */

#ifdef WPRFLAG
    _wcmdln = tcmdline;
#else  /* WPRFLAG */
    _acmdln = tcmdline;
#endif  /* WPRFLAG */

    return 0;
}

#endif  /* !defined (_MANAGED_MAIN) && !defined (_WINMAIN_) */

#if defined (_MANAGED_MAIN)

static void __clrcall __set_managed_app_type(void)
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;
        PIMAGE_OPTIONAL_HEADER pNTHeader;

        pDOSHeader = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
        if ( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);
        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return;

        pNTHeader = (PIMAGE_OPTIONAL_HEADER)&pPEHeader->OptionalHeader;
        if ( pNTHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
            return;

        switch (pNTHeader->Subsystem) {
        case IMAGE_SUBSYSTEM_WINDOWS_CUI:
            __set_app_type(_CONSOLE_APP);
            break;
        default:
            __set_app_type(_GUI_APP);
        }
}

#endif  /* defined (_MANAGED_MAIN) */

/*
 * This function is the shared initialization between MIXED and PURE.  In Mixed, this function
 * is called during _mixed_pre_c_init(), but in PURE, this function is called during
 * mainCRTStartup.
 */
static void __CLRCALL_OR_CDECL _common_init()
{
        /*
         * Set __app_type properly
         */
#if defined (_MANAGED_MAIN)
        __set_managed_app_type();
#elif defined (_WINMAIN_)
        __set_app_type(_GUI_APP);
#else  /* defined (_WINMAIN_) */
        __set_app_type(_CONSOLE_APP);
#endif  /* defined (_WINMAIN_) */

        /*
         * Propogate the _fmode and _commode variables to the DLL
         */
        *_IMP___FMODE = _fmode;
        *_IMP___COMMODE = _commode;


        /* Enable per-thread locale if user asked for it */
        if(__globallocalestatus == -1)
        {
                _configthreadlocale(-1);
        }
}
#endif  /* MRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memcmp.c ===
/***
*memcmp.c - compare two blocks of memory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines memcmp() - compare two memory blocks lexically and
*       find their order.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef _MSC_VER
#pragma function(memcmp)
#endif  /* _MSC_VER */

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*       Compares count bytes of memory starting at buf1 and buf2
*       and find if equal or which one is first in lexical order.
*
*Entry:
*       void *buf1, *buf2 - pointers to memory sections to compare
*       size_t count - length of sections to compare
*
*Exit:
*       returns < 0 if buf1 < buf2
*       returns  0  if buf1 == buf2
*       returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

#if defined (_M_AMD64)

    {


        __declspec(dllimport)


        size_t RtlCompareMemory( const void * src1, const void * src2, size_t length );

        size_t length;

        if ( ( length = RtlCompareMemory( buf1, buf2, count ) ) == count ) {
            return(0);
        }

        buf1 = (char *)buf1 + length;
        buf2 = (char *)buf2 + length;
    }

#else  /* defined (_M_AMD64) */

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

#endif  /* defined (_M_AMD64) */

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memchr.c ===
/***
*memchr.c - search block of memory for a given character
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines memchr() - search memory until a character is
*       found or a limit is reached.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *memchr(buf, chr, cnt) - search memory for given character.
*
*Purpose:
*       Searches at buf for the given character, stopping when chr is
*       first found or cnt bytes have been searched through.
*
*Entry:
*       void *buf  - memory buffer to be searched
*       int chr    - character to search for
*       size_t cnt - max number of bytes to search
*
*Exit:
*       returns pointer to first occurence of chr in buf
*       returns NULL if chr not found in the first cnt bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memchr (
        const void * buf,
        int chr,
        size_t cnt
        )
{
        while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
                buf = (unsigned char *)buf + 1;
                cnt--;
        }

        return(cnt ? (void *)buf : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memcpy_s.c ===
/***
*memcpy_s.c - contains memcpy_s routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memcpy_s() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are not treated specially, so propagation may occur.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <internal.h>

/***
*memcpy_s - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy_s() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propagation.
*
*       For cases where propagation must be avoided, memmove_s() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       size_t sizeInBytes = size in bytes of the destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns 0 if everything is ok, else return the error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*       On error, the error code is returned and the destination buffer is zeroed.
*
*******************************************************************************/

errno_t __cdecl memcpy_s(
    void * dst,
    size_t sizeInBytes,
    const void * src,
    size_t count
)
{
    if (count == 0)
    {
        /* nothing to do */
        return 0;
    }

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(dst != NULL, EINVAL);
    if (src == NULL || sizeInBytes < count)
    {
        /* zeroes the destination buffer */
        memset(dst, 0, sizeInBytes);

        _VALIDATE_RETURN_ERRCODE(src != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInBytes >= count, ERANGE);
        /* useless, but prefast is confused */
        return EINVAL;
    }

    memcpy(dst, src, count);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memicmp.c ===
/***
*memicmp.c - compare memory, ignore case
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _memicmp() - compare two blocks of memory for lexical
*       order.  Case is ignored in the comparison.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <ctype.h>
#include <locale.h>
#include <internal.h>
#include <setlocal.h>

/***
*int _memicmp(first, last, count) - compare two blocks of memory, ignore case
*
*Purpose:
*       Compares count bytes of the two blocks of memory stored at first
*       and last.  The characters are converted to lowercase before
*       comparing (not permanently), so case is ignored in the search.
*
*Entry:
*       char *first, *last - memory buffers to compare
*       size_t count - maximum length to compare
*
*Exit:
*       Returns < 0 if first < last
*       Returns 0 if first == last
*       Returns > 0 if first > last
*       Returns _NLSCMPERROR is something went wrong
*
*Uses:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _memicmp_l (
        const void * first,
        const void * last,
        size_t count,
        _locale_t plocinfo
        )
{
    int f = 0, l = 0;
    const char *dst = (const char *)first, *src = (const char *)last;
    _LocaleUpdate _loc_update(plocinfo);

    /* validation section */
    _VALIDATE_RETURN(first != NULL || count == 0, EINVAL, _NLSCMPERROR);
    _VALIDATE_RETURN(last != NULL || count == 0, EINVAL, _NLSCMPERROR);

    if ( __LC_HANDLE(_loc_update.GetLocaleT()->locinfo)[LC_CTYPE] == _CLOCALEHANDLE )
    {
        return __ascii_memicmp(first, last, count);
    }
    else
    {
        while (count-- && f==l)
        {
            f = _tolower_l( (unsigned char)(*(dst++)), _loc_update.GetLocaleT() );
            l = _tolower_l( (unsigned char)(*(src++)), _loc_update.GetLocaleT() );
        }
    }
    return ( f - l );
}


#ifndef _M_IX86

extern "C" int __cdecl __ascii_memicmp (
        const void * first,
        const void * last,
        size_t count
        )
{
    int f = 0;
    int l = 0;

    while ( count-- )
    {
        if ( (*(unsigned char *)first == *(unsigned char *)last) ||
             ((f = __ascii_tolower( *(unsigned char *)first )) ==
              (l = __ascii_tolower( *(unsigned char *)last ))) )
        {
                first = (char *)first + 1;
                last = (char *)last + 1;
        }
        else
            break;
    }
    return ( f - l );
}

#endif  /* _M_IX86 */

extern "C" int __cdecl _memicmp (
        const void * first,
        const void * last,
        size_t count
        )
{
    if (__locale_changed == 0)
    {
        /* validation section */
        _VALIDATE_RETURN(first != NULL || count == 0, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(last != NULL || count == 0, EINVAL, _NLSCMPERROR);

        return __ascii_memicmp(first, last, count);
    }
    else
    {
        return _memicmp_l(first, last, count, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memmove.c ===
/***
*memmove.c - contains memmove routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memmove() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are treated specially, to avoid propogation.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*memmove - Copy source buffer to destination buffer
*
*Purpose:
*       memmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propogation.
*       For cases where propogation is not a problem, memcpy() can be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memmove (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined (_M_IA64) || defined (_M_AMD64)

        {


        __declspec(dllimport)


        void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );

        }

#else  /* defined (_M_IA64) || defined (_M_AMD64) */
        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                /*
                 * Non-Overlapping Buffers
                 * copy from lower addresses to higher addresses
                 */
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                /*
                 * Overlapping Buffers
                 * copy from higher addresses to lower addresses
                 */
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
#endif  /* defined (_M_IA64) || defined (_M_AMD64) */

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memset.c ===
/***
*memset.c - set a section of memory to all one byte
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the memset() routine
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef _MSC_VER
#pragma function(memset)
#endif  /* _MSC_VER */

/***
*char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
*
*Purpose:
*       Sets the first "count" bytes of the memory starting
*       at "dst" to the character value "val".
*
*Entry:
*       void *dst - pointer to memory to fill with val
*       int val   - value to put in dst bytes
*       size_t count - number of bytes of dst to fill
*
*Exit:
*       returns dst, with filled bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

#if defined (_M_IA64) || defined (_M_AMD64)

        {


        __declspec(dllimport)


        void RtlFillMemory( void *, size_t count, char );

        RtlFillMemory( dst, count, (char)val );

        }

#else  /* defined (_M_IA64) || defined (_M_AMD64) */
        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }
#endif  /* defined (_M_IA64) || defined (_M_AMD64) */

        return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memmove_s.c ===
/***
*memmove_s.c - contains memmove_s routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memmove_s() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are treated specially, to avoid propagation.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <internal.h>

/***
*memmove - Copy source buffer to destination buffer
*
*Purpose:
*       memmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propagation.
*
*       For cases where propagation is not a problem, memcpy_s() can be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       size_t sizeInBytes = size in bytes of the destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns 0 if everything is ok, else return the error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*       On error, the error code is returned. Nothing is written to the destination buffer.
*
*******************************************************************************/

errno_t __cdecl memmove_s(
    void * dst,
    size_t sizeInBytes,
    const void * src,
    size_t count
)
{
    if (count == 0)
    {
        /* nothing to do */
        return 0;
    }

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(dst != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(src != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sizeInBytes >= count, ERANGE);

    memmove(dst, src, count);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mfpieeeflt.cpp ===
/***
*mfpieeeflt.cpp - Managed floatin point exception filter
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <fpieee.h>
#include <mtdll.h>
#include <stdio.h>
#include <internal.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention
#pragma warning(disable:4483)   // disable warning/error about __identifier(<string>)

typedef int (__clrcall *filter_m)(_FPIEEE_RECORD *);

namespace __identifier("<CrtImplementationDetails>")
{

class HandlersFP
{
public:
[System::ThreadStaticAttribute] __declspec(appdomain) static filter_m __pFilter_m;
};

__declspec(appdomain) filter_m HandlersFP::__pFilter_m = (filter_m) _encoded_null();
}

using namespace __identifier("<CrtImplementationDetails>");

int __cdecl fpieee_flt_thunk_func(_FPIEEE_RECORD *pfpieee_record)
{
    filter_m pFunc = (filter_m) _decode_pointer(HandlersFP::__pFilter_m);
    if (pFunc)
    {
        return pFunc(pfpieee_record);
    }
    else
    {
        return 0;
    }
}

_MRTIMP int __cdecl _fpieee_flt
(
    unsigned long exceptionCode,
    struct _EXCEPTION_POINTERS *pExceptionPointers,
    int (__clrcall *pFunc)(_FPIEEE_RECORD *)
)
{
    HandlersFP::__pFilter_m = (filter_m) _encode_pointer(pFunc);
    return _fpieee_flt(exceptionCode, pExceptionPointers, fpieee_flt_thunk_func);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\merr.c ===
/***
*merr.c - floating point exception handling
*
*       Copyright (c) Microsoft Corporation.    All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <internal.h>
#include <math.h>

/*
 * Define flag signifying the default _matherr routine is being used.
 */
int __defaultmatherr = 1;

/***
*int _matherr(struct _exception *pexcept) - handle math errors
*
*Purpose:
*   Permits the user customize fp error handling by redefining this function.
*
*   The default matherr does nothing and returns 0
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
int __CRTDECL _matherr (struct _exception *pexcept)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mkdir.c ===
/***
*mkdir.c - make directory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines function _mkdir() - make a directory
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>

/***
*int _mkdir(path) - make a directory
*
*Purpose:
*       creates a new directory with the specified name
*
*Entry:
*       _TSCHAR *path - name of new directory
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tmkdir (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        /* ask OS to create directory */

        if (!CreateDirectory((LPTSTR)path, (LPSECURITY_ATTRIBUTES)NULL))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif  /* max */

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif  /* min */

#endif  /* _INC_MINMAX */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mlfind.cpp ===
/***
*mlfind.cpp - do a binary search
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _lfind() - do a binary search an an array
*
*******************************************************************************/
#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#if defined (_M_CEE)
#include "lfind.c"

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "lfind.c"
#endif  /* defined (_M_CEE) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mktemp.c ===
/***
*mktemp.c - create a unique file name
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _mktemp() - create a unique file name
*
*******************************************************************************/

#include <mtdll.h>
#include <cruntime.h>
#include <stdio.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include <dbgint.h>
#include <stddef.h>
#ifdef _MBCS
#include <mbctype.h>
#include <mbdata.h>
#endif  /* _MBCS */
#include <tchar.h>
#include <internal.h>
#include <internal_securecrt.h>

/***
*_TSCHAR *_mktemp_s(template, size) - create a unique file name
*
*Purpose:
*       given a template of the form "fnamXXXXXX", insert number on end
*       of template, insert unique letter if needed until unique filename
*       found or run out of letters.  The number is generated from the Win32
*       Process ID for single-thread libraries, or the Win32 Thread ID for
*       multi-thread libraries.
*
*Entry:
*       _TSCHAR *template - template of form "fnamXXXXXX"
*       size_t size - size of the template buffer
*
*Exit:
*       returns 0 on success & sets pfile
*       returns errno_t on failure.
*       The template buffer contains the generated filename on success
*
*Exceptions:
*
*******************************************************************************/

errno_t  __cdecl _tmktemp_s (_TSCHAR *template, size_t sizeInChars)
{
        _TSCHAR *string = template;
        unsigned number;
        int letter = _T('a');
        size_t xcount = 0;
        errno_t save_errno;

        _VALIDATE_RETURN_ERRCODE((template != NULL) && (sizeInChars > 0), EINVAL);
        xcount = _tcsnlen(template, sizeInChars);
        if (xcount >= sizeInChars)
        {
            _RESET_STRING(template, sizeInChars);
            _RETURN_DEST_NOT_NULL_TERMINATED(template, sizeInChars);
        }
        _FILL_STRING(template, sizeInChars, xcount + 1);

        /*
         * The Process ID is not a good choice in multi-threaded programs
         * because of the likelihood that two threads might call mktemp()
         * almost simultaneously, thus getting the same temporary name.
         * Instead, the Win32 Thread ID is used, because it is unique across
         * all threads in all processes currently running.
         *
         * Note, however, that unlike *NIX process IDs, which are not re-used
         * until all values up to 32K have been used, Win32 process IDs are
         * re-used and tend to always be relatively small numbers.  Same for
         * thread IDs.
         */
        number = __threadid();

        /* string points to the terminating null */
        string += xcount;

        if((xcount < 6) || (sizeInChars <= xcount))
        {
            _RESET_STRING(template, sizeInChars);
            _VALIDATE_RETURN_ERRCODE(("Incorrect Input for mktemp", 0), EINVAL);
        }

        xcount = 0;

        /* replace last five X's */
#ifdef _MBCS
        while ((--string>=template) && (!_ismbstrail(template,string))
                && (*string == 'X') && xcount < 5)
#else  /* _MBCS */
        while ((--string>=template) && *string == _T('X') && xcount < 5)
#endif  /* _MBCS */
        {
                xcount++;
                *string = (_TSCHAR)((number % 10) + '0');
                number /= 10;
        }

        /* too few X's ? */
        if (*string != _T('X') || xcount < 5)
        {
            _RESET_STRING(template, sizeInChars);
            _VALIDATE_RETURN_ERRCODE(("Incorrect Input for mktemp", 0), EINVAL);
        }

        /* set first X */
        *string = letter++;

        save_errno = errno;
        errno = 0;

        /* check all the files 'a'-'z' */
        while ((_taccess_s(template,0) == 0) || (errno == EACCES))
        /* while file exists */
        {
                if (letter == _T('z') + 1) {
                        _RESET_STRING(template, sizeInChars);
                        errno = EEXIST;
                        return errno;
                }

                *string = (_TSCHAR)letter++;
                errno = 0;
        }

        /* restore the old value of errno and return success */
        errno = save_errno;
        return 0;
}

/***
*_TSCHAR *_mktemp(template) - create a unique file name
*
*Purpose:
*       given a template of the form "fnamXXXXXX", insert number on end
*       of template, insert unique letter if needed until unique filename
*       found or run out of letters.  The number is generated from the Win32
*       Process ID for single-thread libraries, or the Win32 Thread ID for
*       multi-thread libraries.
*
*Entry:
*       _TSCHAR *template - template of form "fnamXXXXXX"
*
*Exit:
*       return pointer to modifed template
*       returns NULL if template malformed or no more unique names
*
*Exceptions:
*
*******************************************************************************/
_TSCHAR * __cdecl _tmktemp(
        _TSCHAR *template
        )
{
    errno_t e;

    _VALIDATE_RETURN( (template != NULL), EINVAL, NULL);

    e = _tmktemp_s(template, (size_t)(_tcslen(template) + 1));

    return  e ? NULL : template ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mhandler.cpp ===
/***
*handler.cpp - defines C++ setHandler routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines pure MSIL C++ setHandler routine.
*
*******************************************************************************/


#include <internal.h>
#include <mtdll.h>
#include <new.h>
#include <signal.h>
#include <unknwn.h>
#include <minternal.h>

volatile __declspec(appdomain) __MPNH __mpnhHeap= (__MPNH) _encoded_null();
volatile __declspec(appdomain) _new_handler_m __nhmHeap= (_new_handler_m) _encoded_null();

/***
*int _callnewh - call the appropriate new handler
*
*Purpose:
*       Call the appropriate new handler.
*
*Entry:
*       None
*
*Return:
*       1 for success
*       0 for failure
*       may throw bad_alloc
*
*******************************************************************************/
static int __cdecl _callnewh_thunk(size_t size)
{
    __MPNH pnh = (__MPNH) _decode_pointer(__mpnhHeap);

    if (pnh != NULL)
    {
        return (*pnh)(size);
    }
    else
    {
        return 0;
    }
}

static void __clrcall _callnewh_cleanup(void)
{
    _PNH pnh=_query_new_handler();
    __MPNH enull = (__MPNH) _encoded_null();
    if(pnh==_callnewh_thunk && __mpnhHeap!=enull)
    {
        _set_new_handler((_PNH)NULL);
    }
    __mpnhHeap=enull;
}

static int __cdecl _callnewhandler_thunk
(
    size_t size
)
{
    _new_handler_m pnh = (_new_handler_m) _decode_pointer(__nhmHeap);

    if ( pnh != NULL)
    {
        pnh();
    }
    else
    {
        return 0;
    }

    return 1;
}

static void __clrcall _callnewhandler_cleanup(void)
{
    _PNH pnh=_query_new_handler();
    _new_handler_m enull = (_new_handler_m) _encoded_null();
    if(pnh==_callnewhandler_thunk && __nhmHeap!=enull)
    {
        _set_new_handler((_PNH)NULL);
    }
    __nhmHeap=enull;
}

/***
*__MPNH _set_new_handler(__MPNH pnh) - set the new handler
*
*Purpose:
*       _set_new_handler is different from the ANSI C++ working standard definition
*       of set_new_handler.  Therefore it has a leading underscore in its name.
*
*Entry:
*       Pointer to the new handler to be installed.
*
*Return:
*       Previous new handler
*
*******************************************************************************/
__MPNH _MRTIMP __cdecl _set_new_handler
(
    __MPNH pnh
)
{
    if(_atexit_m_appdomain(_callnewh_cleanup)!=0)
    {
        return NULL;
    }

    __MPNH pnhOld = (__MPNH) _decode_pointer(__mpnhHeap);
    __mpnhHeap = (__MPNH) _encode_pointer(pnh);
    _set_new_handler((_PNH)_callnewh_thunk);

    return(pnhOld);
}

std::_new_handler_m _MRTIMP __cdecl std::set_new_handler
(
    std::_new_handler_m pnh
) throw()
{
    if(_atexit_m_appdomain(_callnewhandler_cleanup)!=0)
    {
        return NULL;
    }

    _new_handler_m pnhOld = (_new_handler_m) _decode_pointer(__nhmHeap);
    __nhmHeap = (_new_handler_m) _encode_pointer(pnh);
    _set_new_handler((_PNH)_callnewhandler_thunk);

    return(pnhOld);
}

/***
*__MPNH __query_new_handler_m(void) - query value of new handler
*
*Purpose:
*       Obtain current new handler value.
*
*Entry:
*       None
*
*       WARNING: This function is OBSOLETE. Use _query_new_ansi_handler instead.
*
*Return:
*       Currently installed new handler
*
*******************************************************************************/
__MPNH __cdecl __query_new_handler_m
(
    void
)
{
    return (__MPNH) _decode_pointer(__mpnhHeap);
}

typedef void (__clrcall *_PHNDLR_m)(int);
volatile __declspec(appdomain) static _PHNDLR_m __psignal_func[NSIG];

class __signal_init
{
public:
        __signal_init()
        {
                _PHNDLR_m enull = (_PHNDLR_m) _encoded_null();
                for(int i=0; i<NSIG; ++i)
                {
                        __psignal_func[i]=enull;
                }
        };
};

#pragma warning(push)
#pragma warning(disable: 4074)
#pragma init_seg(compiler)
#pragma warning(pop)
static __signal_init _init;

static void __cdecl __signal_thunk(int i)
{
    _PHNDLR_m local_func = (_PHNDLR_m) _decode_pointer(__psignal_func[i]);
    if (local_func != NULL)
    {
        local_func(i);
    }
}

static void __clrcall _signal_cleanup(void)
{
    _PHNDLR_m enull = (_PHNDLR_m) _encoded_null();
    for(int i=0; i<NSIG; ++i)
    {
        if(__psignal_func[i]!=enull)
        {
            _PHNDLR _handler=signal(i, SIG_GET);
            if(_handler==__signal_thunk)
            {
                signal(i, SIG_DFL);
            }
            __psignal_func[i]=enull;
        }
    }
}

/***
*_PHNDLR_m signal(signum, sigact) - Define a signal handler
*
*Purpose:
*       The signal routine allows the user to define what action should
*       be taken when various signals occur. The Win32/Dosx32 implementation
*       supports seven signals, divided up into three general groups
*
*       1. Signals corresponding to OS exceptions. These are:
*                       SIGFPE
*                       SIGILL
*                       SIGSEGV
*          Signal actions for these signals are installed by altering the
*          XcptAction and SigAction fields for the appropriate entry in the
*          exception-action table (XcptActTab[]).
*
*       2. Signals corresponding to ^C and ^Break. These are:
*                       SIGINT
*                       SIGBREAK
*          Signal actions for these signals are installed by altering the
*          _ctrlc_action and _ctrlbreak_action variables.
*
*       3. Signals which are implemented only in the runtime. That is, they
*          occur only as the result of a call to raise().
*                       SIGABRT
*                       SIGTERM
*
*
*Entry:
*       int signum      signal type. recognized signal types are:
*
*                       SIGABRT         (ANSI)
*                       SIGBREAK
*                       SIGFPE          (ANSI)
*                       SIGILL          (ANSI)
*                       SIGINT          (ANSI)
*                       SIGSEGV         (ANSI)
*                       SIGTERM         (ANSI)
*                       SIGABRT_COMPAT
*
*       _PHNDLR sigact  signal handling function or action code. the action
*                       codes are:
*
*                       SIG_DFL - take the default action, whatever that may
*                       be, upon receipt of this type type of signal.
*
*                       SIG_DIE - *** ILLEGAL ***
*                       special code used in the XcptAction field of an
*                       XcptActTab[] entry to indicate that the runtime is
*                       to terminate the process upon receipt of the exception.
*                       not accepted as a value for sigact.
*
*                       SIG_IGN - ignore this type of signal
*
*                       [function address] - transfer control to this address
*                       when a signal of this type occurs.
*
*Exit:
*       Good return:
*       Signal returns the previous value of the signal handling function
*       (e.g., SIG_DFL, SIG_IGN, etc., or [function address]). This value is
*       returned in DX:AX.
*
*       Error return:
*       Signal returns -1 and errno is set to EINVAL. The error return is
*       generally taken if the user submits bogus input values.
*
*Exceptions:
*       None.
*
*******************************************************************************/
_MRTIMP _PHNDLR_m __cdecl signal(int signum, _PHNDLR_m sigact)
{
    if(signum<0 || signum>=NSIG)
    {
        /* call signal to allow it to do error detection and handling, but without setting us up */
        signal(signum, static_cast<_PHNDLR>(NULL));
        return (void (__clrcall *)(int))-1;
    }

    if(_atexit_m_appdomain(_signal_cleanup)!=0)
    {
        return NULL;
    }

    _PHNDLR_m __psignal_func_old = (_PHNDLR_m) _decode_pointer(__psignal_func[signum]);
    __psignal_func[signum] = (_PHNDLR_m) _encode_pointer(sigact);
    void (__cdecl *pnative_signal_func_old)(int) = signal(signum, (void (__cdecl *)(int))__signal_thunk);
    if (pnative_signal_func_old == __signal_thunk)
    {
        return __psignal_func_old;
    }
    else if (pnative_signal_func_old == NULL)
    {
        return NULL;
    }
    else
    {
        return (void (__clrcall *)(int))-1;
    }
}

_MRTIMP _PHNDLR_m __cdecl signal(int signum, int sigact)
{
    _VALIDATE_RETURN(sigact == NULL, EINVAL, NULL);

    return signal(signum, static_cast<_PHNDLR_m>(NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\minternal.h ===
/***
*minternal.h - contains declarations of managed internal routines and variables
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares routines and variables used internally by the C run-time.
*
*       [Internal]
*
****/

//
//  _CPP_MSTARTUP indicates that the file is included from mstartup.cpp
//      _PARTIAL_TRUST_OBJ indicates that ptrust*.obj is being built
// !_CPP_MSTARTUP building msvcm*
//

#pragma once

#if defined (_PARTIAL_TRUST_OBJ) || !defined (_CPP_MSTARTUP)

#include <unknwn.h>
// Don't pull have IID defns in the obj
#ifdef EXTERN_GUID
#undef EXTERN_GUID
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif  /* EXTERN_GUID */
#include <mscoree.h>

#if defined (_DEBUG)
#using <system.dll>
#endif  /* defined (_DEBUG) */

#endif  /* defined (_PARTIAL_TRUST_OBJ) || !defined (_CPP_MSTARTUP) */

#define _INC_MINTERNAL

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention
#pragma warning(disable:4483)   // disable warning/error about __identifier(<string>)

namespace __identifier("<CrtImplementationDetails>")
{
    using System::AppDomain;
    using System::Object;
    using System::String;
    using System::EventHandler;
    using System::EventArgs;
    using System::Threading::Interlocked;
    using System::SerializableAttribute;
    using System::CrossAppDomainDelegate;
    using System::Collections::Stack;
    using System::Threading::Interlocked;
    using System::Runtime::Serialization::SerializationInfo;
    using System::Runtime::Serialization::StreamingContext;

#ifdef _CPP_MSTARTUP
#ifndef _PARTIAL_TRUST_OBJ
    // Declarations for MSVCMXX.dll exports
#if defined (_M_CEE_MIXED)
        typedef HRESULT (__stdcall* MixedFunctionType)(void*);
        _MRTIMP void __cdecl DoCallBackInDefaultDomain(MixedFunctionType function, void* cookie);
#endif  /* defined (_M_CEE_MIXED) */
    _MRTIMP void __cdecl DoDllLanguageSupportValidation();
    _MRTIMP void __cdecl RegisterModuleUninitializer(EventHandler^ handler);
    _MRTIMP void __cdecl ThrowModuleLoadException(String^ errorMessage);
    _MRTIMP void __cdecl ThrowModuleLoadException(String^ errorMessage, System::Exception^ innerException);
    _MRTIMP void __cdecl ThrowNestedModuleLoadException(System::Exception^ innerException, System::Exception^ nestedException);
#else  /* _PARTIAL_TRUST_OBJ */
#if defined (_M_CEE_MIXED)
        typedef HRESULT (__stdcall* MixedFunctionType)(void*);
        void __cdecl DoCallBackInDefaultDomain(MixedFunctionType function, void* cookie);
#endif  /* defined (_M_CEE_MIXED) */
    void RegisterModuleUninitializer(EventHandler^ handler);
    void ThrowModuleLoadException(String^ errorMessage);
    void ThrowModuleLoadException(String^ errorMessage, System::Exception^ innerException);
    void ThrowNestedModuleLoadException(System::Exception^ innerException, System::Exception^ nestedException);
#endif  /* _PARTIAL_TRUST_OBJ */
#else  /* _CPP_MSTARTUP */
    typedef HRESULT (__stdcall* MixedFunctionType)(void*);
#endif  /* _CPP_MSTARTUP */

#if defined (_DEBUG)
    #define MANAGED_ASSERT( test, message) System::Diagnostics::Debug::Assert(test, message)
#else  /* defined (_DEBUG) */
    #define MANAGED_ASSERT( test, message )
#endif  /* defined (_DEBUG) */

}   // namespace __identifier("<CrtImplementationDetails>")

///////////////////////////////////////////////////////////////////////////////
//
// building msvcm or ptrust*.obj
//

#if defined (_PARTIAL_TRUST_OBJ) || !defined (_CPP_MSTARTUP)

namespace __identifier("<CrtImplementationDetails>")
{

///////////////////////////////////////////////////////////////////////////////
//
// Exception
//

// This is the base class for all managed exceptions thrown by the CRT
[System::SerializableAttribute]
ref class Exception : public System::Exception
{
public:
    Exception(System::String^ message)
        : System::Exception(message)
    {
    }

    Exception(System::String^ message, System::Exception^ innerException)
        : System::Exception(message, innerException)
    {
    }
protected:
    Exception(SerializationInfo^ info, StreamingContext context)
        : System::Exception(info, context)
    {
    }
};

// This is thrown by the CRT during module construction (errors thrown
// by the cctor)
[System::SerializableAttribute]
ref class ModuleLoadException : public System::Exception
{
public:
    ModuleLoadException(System::String^ message)
        : Exception(message)
    {
    }

    ModuleLoadException(System::String^ message, System::Exception^ innerException)
        : Exception(message, innerException)
    {
    }

    literal System::String^ Nested = "A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n";

protected:
    ModuleLoadException(SerializationInfo^ info, StreamingContext context)
        : Exception(info, context)
    {
    }
};

// This is thrown when an exception occurs in the cleanup code executed while handling
// an exception thrown by the module constructor.
[System::SerializableAttribute]
ref class ModuleLoadExceptionHandlerException : public ModuleLoadException
{
private:
    typedef ModuleLoadException base;
    literal System::String^ formatString = "\n{0}: {1}\n--- Start of primary exception ---\n{2}\n--- End of primary exception ---\n\n--- Start of nested exception ---\n{3}\n--- End of nested exception ---\n";

public:

    ModuleLoadExceptionHandlerException(System::String^ message, System::Exception^ innerException, System::Exception^ nestedException)
        : base(message, innerException)
    {
        NestedException = nestedException;
    }

    property System::Exception^ NestedException;

    virtual System::String^ ToString() override
    {
        System::String^ inner = InnerException ? InnerException->ToString() : System::String::Empty;
        System::String^ nested = NestedException ? NestedException->ToString() : System::String::Empty;
        System::String^ result = System::String::Format(
            formatString,
            this->GetType(),
            Message ? Message : System::String::Empty,
            inner ? inner : System::String::Empty,
            nested ? nested : System::String::Empty
            );
        return result;
    }

    virtual void GetObjectData(SerializationInfo^ info, StreamingContext context) override
    {
        base::GetObjectData(info, context);
        info->AddValue("NestedException", NestedException, System::Exception::typeid);
    }

protected:
    ModuleLoadExceptionHandlerException(SerializationInfo^ info, StreamingContext context)
        : base(info, context)
    {
        NestedException = (System::Exception^)info->GetValue("NestedException", System::Exception::typeid);
    }

};

#ifdef _PARTIAL_TRUST_OBJ
inline void ThrowNestedModuleLoadException(System::Exception^ innerException, System::Exception^ nestedException)
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP void __cdecl ThrowNestedModuleLoadException(System::Exception^ innerException, System::Exception^ nestedException)
#endif  /* _PARTIAL_TRUST_OBJ */
{
    throw gcnew ModuleLoadExceptionHandlerException(ModuleLoadException::Nested, innerException, nestedException);
}

#ifdef _PARTIAL_TRUST_OBJ
inline void ThrowModuleLoadException(String^ errorMessage)
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP void __cdecl ThrowModuleLoadException(String^ errorMessage)
#endif  /* _PARTIAL_TRUST_OBJ */
{
    throw gcnew ModuleLoadException(errorMessage);
}

#ifdef _PARTIAL_TRUST_OBJ
inline void ThrowModuleLoadException(String^ errorMessage, System::Exception^ innerException)
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP void __cdecl ThrowModuleLoadException(String^ errorMessage, System::Exception^ innerException)
#endif  /* _PARTIAL_TRUST_OBJ */
{
    throw gcnew ModuleLoadException(errorMessage, innerException);
}

///////////////////////////////////////////////////////////////////////////////
//
// UnInitialize
//

/*
// A single instance of this class is stored in each AppDomain
// It registers a handler for the AppDomain::DomainUnload and AppDomain::ProcessExit events
// and maintains a list of managed C++ modules loaded in that domain. When an unload
// event occurs, it calls back on the event handler registered by each of the modules
// in the reverse order to which they were added to the list.
*/
ref class ModuleUninitializer : public Stack
{
private:
    static Object^ lock = gcnew Object();

internal:
        // Static members are AppDomain specific.
        // Instance for a new AppDomain is created when msvcm's .cctor tries to add its DomainUnload handler
    static ModuleUninitializer^ _ModuleUninitializer = gcnew ModuleUninitializer();
    void AddHandler(EventHandler^ handler)
    {
#ifndef _PARTIAL_TRUST_OBJ
        bool mustReleaseLock = false;
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
        try
        {
            System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
            try { } finally
            {
                System::Threading::Monitor::Enter(lock);
                mustReleaseLock = true;
            }
#endif  /* _PARTIAL_TRUST_OBJ */
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareDelegate(handler);
        Push(handler);
#ifndef _PARTIAL_TRUST_OBJ
        }
        finally
        {
            if (mustReleaseLock)
            {
                System::Threading::Monitor::Exit(lock);
            }
        }
#endif  /* _PARTIAL_TRUST_OBJ */
    }

private:
    ModuleUninitializer()
    {
        // Protected by lock in Initialize
        // singletonHandler will be Prepared as a CER call when it's added to the DomainUnload event:
        // this makes it a CER root
        EventHandler^ singletonHandler = gcnew EventHandler(this, &ModuleUninitializer::SingletonDomainUnload);
        AppDomain::CurrentDomain->DomainUnload += singletonHandler;
        AppDomain::CurrentDomain->ProcessExit  += singletonHandler;
    }

    [System::Runtime::ConstrainedExecution::PrePrepareMethod]
    void SingletonDomainUnload(Object^ source, EventArgs^ arguments)
    {
#ifndef _PARTIAL_TRUST_OBJ
        bool mustReleaseLock = false;
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
        try
        {
            System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
            try { } finally
            {
                System::Threading::Monitor::Enter(lock);
                mustReleaseLock = true;
            }
#endif  /* _PARTIAL_TRUST_OBJ */
        // Stack iterator starts at top and moves down through stack
        for each (EventHandler^ handler in this)
        {
            handler(source, arguments);
        }
#ifndef _PARTIAL_TRUST_OBJ
        }
        finally
        {
            if (mustReleaseLock)
            {
                System::Threading::Monitor::Exit(lock);
            }
        }
#endif  /* _PARTIAL_TRUST_OBJ */
    }
};

#ifdef _PARTIAL_TRUST_OBJ
inline void RegisterModuleUninitializer(EventHandler^ handler)
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP void __cdecl RegisterModuleUninitializer(EventHandler^ handler)
#endif  /* _PARTIAL_TRUST_OBJ */
{
    ModuleUninitializer::_ModuleUninitializer->AddHandler(handler);
}

}   // namespace __identifier("<CrtImplementationDetails>")

#if defined (_M_CEE_MIXED)

#ifdef _PARTIAL_TRUST_OBJ
inline HRESULT __get_default_appdomain(IUnknown **ppUnk)
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP HRESULT __cdecl __get_default_appdomain(IUnknown **ppUnk)
#endif  /* _PARTIAL_TRUST_OBJ */

{
    /*
     * Don't do anything in case we are already in default appdomain.
     */
    HRESULT hresult = 0;
    IUnknown *pUnk1 = NULL;
    ICorRuntimeHost *pHost = NULL;

    __try {
        /*
         * Note: We don't initialize COM as COM is already initialized as CLR is already
         * initialized.
         *
         * Initialize CLR, rather get CLSID_CorRuntimeHost Interface pointer.
         */
        if (   !FAILED(hresult = CoCreateInstance(__uuidof(CorRuntimeHost), NULL, CLSCTX_INPROC_SERVER, __uuidof(IUnknown), (void **)&pUnk1))
            && !FAILED(hresult = pUnk1->QueryInterface(__uuidof(ICorRuntimeHost), (void **)&pHost)))
            hresult = pHost->GetDefaultDomain(ppUnk);
    } __finally {
        if (pUnk1) pUnk1->Release();
        if (pHost) pHost->Release();
    }

    return hresult;
}

#ifdef _PARTIAL_TRUST_OBJ
inline void __release_appdomain(IUnknown *ppUnk)
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP void __cdecl __release_appdomain(IUnknown *ppUnk)
#endif  /* _PARTIAL_TRUST_OBJ */
{
    ppUnk->Release();
}

namespace __identifier("<CrtImplementationDetails>")
{

inline AppDomain^ GetDefaultDomain()
{
    using System::Runtime::InteropServices::Marshal;
    IUnknown* pUnk = NULL;
    HRESULT hresult = __get_default_appdomain(&pUnk);
    if (SUCCEEDED(hresult))
    {
        try
        {
            Object^ pObject = Marshal::GetObjectForIUnknown(System::IntPtr(pUnk));

            AppDomain^ pDomain = (AppDomain^)pObject;

            MANAGED_ASSERT(pDomain->IsDefaultAppDomain(), "Expecting default appdomain");

            return pDomain;
        }
        finally
        {
            __release_appdomain(pUnk);
        }
    }
    else
    {
        Marshal::ThrowExceptionForHR(hresult);
    }

    return nullptr;
}

#ifdef _PARTIAL_TRUST_OBJ

///////////////////////////////////////////////////////////////////////////////
//
// building ptmstartup.obj
//

inline void DoCallBackInDefaultDomain(MixedFunctionType function, void* cookie)

#else  /* _PARTIAL_TRUST_OBJ */

///////////////////////////////////////////////////////////////////////////////
//
// building msvcm
//

_MRTIMP void __cdecl DoCallBackInDefaultDomain(MixedFunctionType function, void* cookie)

#endif  /* _PARTIAL_TRUST_OBJ */
{
    using System::Runtime::InteropServices::Marshal;
    ICLRRuntimeHost* pClrHost = nullptr;
    try
    {
        HRESULT hr = CorBindToRuntimeEx(
                NULL,                                 // version of the runtime to request
                NULL,                                 // flavor of the runtime to request
                0,                                    // runtime startup flags
                __uuidof(CLRRuntimeHost),                 // clsid of ICLRRuntimeHost
                __uuidof(ICLRRuntimeHost),                  // IID of ICLRRuntimeHost
                reinterpret_cast<void**>(&pClrHost)); // a pointer to our punk that we get back
        if (FAILED(hr))
        {
            Marshal::ThrowExceptionForHR(hr);
        }
        AppDomain^ defaultDomain = GetDefaultDomain();

        hr = pClrHost->ExecuteInAppDomain(defaultDomain->Id, function, cookie);
        if (FAILED(hr))
        {
            Marshal::ThrowExceptionForHR(hr);
        }
    }
    finally
    {
        if (pClrHost != nullptr)
        {
            pClrHost->Release();
        }
    }
}

[System::SerializableAttribute]
ref class OpenMPWithMultipleAppdomainsException
    : public System::Exception
{
public:
    OpenMPWithMultipleAppdomainsException() { }
protected:
    OpenMPWithMultipleAppdomainsException(SerializationInfo^ info, StreamingContext context)
        : System::Exception(info, context)
    {
    }
};

// Returns true if the current application is using OpenMP
inline bool IsUsingOpenMP()
{
    HINSTANCE hMod = GetModuleHandleW(L"vcomp90.dll");

    if ( hMod )
    {
        void * fnp = GetProcAddress(hMod, "_vcomp_fork");
        if ( fnp )
        {
            return true;
        }
    }

    hMod = GetModuleHandleW(L"vcomp90d.dll");
    if ( hMod )
    {
        void * fnp = GetProcAddress(hMod, "_vcomp_fork");
        if ( fnp )
        {
            return true;
        }
    }

    return false;
}

#ifdef _PARTIAL_TRUST_OBJ
inline void __cdecl DoDllLanguageSupportValidation()
#else  /* _PARTIAL_TRUST_OBJ */
_MRTIMP void __cdecl DoDllLanguageSupportValidation()
#endif  /* _PARTIAL_TRUST_OBJ */
{
    if (!AppDomain::CurrentDomain->IsDefaultAppDomain() && IsUsingOpenMP())
    {
        throw gcnew OpenMPWithMultipleAppdomainsException();
    }
}

}   // namespace __identifier("<CrtImplementationDetails>")

#endif  /* defined (_M_CEE_MIXED) */

#endif  /* defined (_PARTIAL_TRUST_OBJ) || !defined (_CPP_MSTARTUP) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mktime64.c ===
/***
*mktime64.c - Convert struct tm value to __time64_t value.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _mktime64() and _mkgmtime64(), routines to converts a time
*       value in a tm structure (possibly incomplete) into a __time64_t value,
*       then update (all) the structure fields with "normalized" values.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <ctime.h>
#include <time.h>
#include <internal.h>


/*
 * Core function for both _mktime64() and _mkgmtime64()
 */
static __time64_t __cdecl _make__time64_t( struct tm *, int);


/***
*__time64_t _mktime64(tb) - Normalize user time block structure
*
*Purpose:
*       _mktime64 converts a time structure, passed in as an argument, into a
*       64-bit calendar time value in internal format (__time64_t). It also
*       completes and updates the fields the of the passed in structure with
*       'normalized' values. There are three practical uses for this routine:
*
*       (1) Convert broken-down time to internal time format (__time64_t).
*       (2) To have _mktime64 fill in the tm_wday, tm_yday, or tm_isdst fields.
*       (3) To pass in a time structure with 'out of range' values for some
*           fields and have _mktime64 "normalize" them (e.g., pass in 1/35/87 and
*           get back 2/4/87).
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mktime64 returns the specified calender time encoded as
*       a __time64_t value. Otherwise, (__time64_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

_CRTIMP __time64_t __cdecl _mktime64 (
        struct tm *tb
        )
{
        return( _make__time64_t(tb, 1) );
}


/***
*__time64_t _mkgmtime64(tb) - Convert broken down UTC time to __time64_t
*
*Purpose:
*       Convert a tm structure, passed in as an argument, containing a UTC
*       time value to 64-bit internal format (__time64_t). It also completes
*       and updates the fields the of the passed in structure with 'normalized'
*       values.
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mkgmtime64 returns the calender time encoded as a
*       __time64_t value.
*       Otherwise, (__time64_t)(-1) is returned to indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

_CRTIMP __time64_t __cdecl _mkgmtime64 (
        struct tm *tb
        )
{
        return( _make__time64_t(tb, 0) );
}


/***
*static __time64_t _make__time64_t(tb, ultflag) -
*
*Purpose:
*       Converts a struct tm value to a __time64_t value, then updates the
*       struct tm value. Either local time or UTC is supported, based on
*       ultflag. This is the routine that actually does the work for both
*       _mktime64() and _mkgmtime64().
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*       int ultflag   - use local time flag. the tb structure is assumed
*                       to represent a local date/time if ultflag > 0.
*                       otherwise, UTC is assumed.
*
*Exit:
*       If successful, _mktime64 returns the specified calender time encoded
*       as a __time64_t value. Otherwise, (__time64_t)(-1) is returned to
*       indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

static __time64_t __cdecl _make__time64_t (
        struct tm *tb,
        int ultflag
        )
{
        __time64_t tmptm1, tmptm2, tmptm3;
        struct tm tbtemp;
        long dstbias = 0;
        long timezone = 0;

        _VALIDATE_RETURN( ( tb != NULL ), EINVAL, ( ( __time64_t )( -1 ) ) )

        /*
         * First, make sure tm_year is reasonably close to being in range.
         */
        if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR64
          + 1) )
            goto err_mktime;


        /*
         * Adjust month value so it is in the range 0 - 11.  This is because
         * we don't know how many days are in months 12, 13, 14, etc.
         */

        if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) {

            tmptm1 += (tb->tm_mon / 12);

            if ( (tb->tm_mon %= 12) < 0 ) {
                tb->tm_mon += 12;
                tmptm1--;
            }

            /*
             * Make sure year count is still in range.
             */
            if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR64 + 1) )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed years *****/

        /*
         * Calculate days elapsed minus one, in the given year, to the given
         * month. Check for leap year and adjust if necessary.
         */
        tmptm2 = _days[tb->tm_mon];
        if ( _IS_LEAP_YEAR(tmptm1) && (tb->tm_mon > 1) )
                tmptm2++;

        /*
         * Calculate elapsed days since base date (midnight, 1/1/70, UTC)
         *
         *
         * 365 days for each elapsed year since 1970, plus one more day for
         * each elapsed leap year. no danger of overflow because of the range
         * check (above) on tmptm1.
         */
        tmptm3 = (tmptm1 - _BASE_YEAR) * 365 + _ELAPSED_LEAP_YEARS(tmptm1);

        /*
         * elapsed days to current month (still no possible overflow)
         */
        tmptm3 += tmptm2;

        /*
         * elapsed days to current date.
         */
        tmptm1 = tmptm3 + (tmptm2 = (__time64_t)(tb->tm_mday));

        /***** HERE: tmptm1 holds number of elapsed days *****/

        /*
         * Calculate elapsed hours since base date
         */
        tmptm2 = tmptm1 * 24;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_hour);

        /***** HERE: tmptm1 holds number of elapsed hours *****/

        /*
         * Calculate elapsed minutes since base date
         */

        tmptm2 = tmptm1 * 60;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_min);

        /***** HERE: tmptm1 holds number of elapsed minutes *****/

        /*
         * Calculate elapsed seconds since base date
         */

        tmptm2 = tmptm1 * 60;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_sec);

        /***** HERE: tmptm1 holds number of elapsed seconds *****/

        if  ( ultflag ) {

            /*
             * Adjust for timezone. No need to check for overflow since
             * localtime() will check its arg value
             */

            __tzset();

            _ERRCHECK(_get_dstbias(&dstbias));
            _ERRCHECK(_get_timezone(&timezone));

            tmptm1 += timezone;

            /*
             * Convert this second count back into a time block structure.
             * If localtime returns NULL, return an error.
             */
            if ( _localtime64_s(&tbtemp, &tmptm1) != 0 )
                goto err_mktime;

            /*
             * Now must compensate for DST. The ANSI rules are to use the
             * passed-in tm_isdst flag if it is non-negative. Otherwise,
             * compute if DST applies. Recall that tbtemp has the time without
             * DST compensation, but has set tm_isdst correctly.
             */
            if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) &&
              (tbtemp.tm_isdst > 0)) ) {
                tmptm1 += dstbias;
                if ( _localtime64_s(&tbtemp, &tmptm1) != 0 )
                    goto err_mktime;
            }

        }
        else {
            if ( _gmtime64_s(&tbtemp, &tmptm1) != 0)
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed seconds, adjusted *****/
        /*****       for local time if requested                      *****/

        *tb = tbtemp;
        return tmptm1;

err_mktime:
        /*
         * All errors come to here
         */

        errno = EINVAL;
        return (__time64_t)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memcpy.c ===
/***
*memcpy.c - contains memcpy routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are not treated specially, so propogation may occur.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef _MSC_VER
#pragma function(memcpy)
#endif  /* _MSC_VER */

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if defined (_M_IA64)

        {


        __declspec(dllimport)


        void RtlCopyMemory( void *, const void *, size_t count );

        RtlCopyMemory( dst, src, count );

        }

#else  /* defined (_M_IA64) */
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif  /* defined (_M_IA64) */

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mlsearch.cpp ===
/***
*mlsearch.cpp - do a binary search
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _lsearch() - do a binary search an an array
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#if defined (_M_CEE)
#include "lsearch.c"

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "lsearch.c"
#endif  /* defined (_M_CEE) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mm3dnow.h ===
/**
*** Copyright (C) 1999 Advanced Micro Devices Inc.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Advanced Micro Devices and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * mm3dnow.h
 *
 */

#pragma once
#ifndef __midl
#ifndef _MM3DNOW_H_INCLUDED
#define _MM3DNOW_H_INCLUDED

#include <crtdefs.h>
#include <mmintrin.h>
#include <xmmintrin.h>

#if defined __cplusplus
extern "C" { /* Intrinsics use C name-mangling.  */
#endif  /* defined __cplusplus */

/* 3DNOW intrinsics */

void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);

/* Athlon DSP intrinsics */

__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);

#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* _MM3DNOW_H_INCLUDED */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mlock.c ===
/***
*mlock.c - Multi-thread locking routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/


#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <rterr.h>
#include <stddef.h>
#include <malloc.h>
#include <limits.h>
#include <stdio.h>
#include <dbgint.h>
#include <errno.h>
#include <winheap.h>


/*
 * Local routines
 */
void __cdecl _lockerr_exit(char *);


/*
 * Global Data
 */

/*
 * Statically allocated critical section structures for all preallocated locks.
 * These are most of the named locks before _STREAM_LOCKS, along with the locks
 * for stdin/stdout/stderr.  These must be preallocated so we do not hit fatal
 * memory conditions on failing to initialize a critical section, except at
 * runtime startup, since these locks may be taken where we have no good way
 * to return a non-fatal error.
 */
#define NUM_STD_FILE_LOCKS     3

/*
 *  _DEBUG_LOCK is preallocated in _DEBUG & not in Retail
 */

#ifdef _DEBUG
#define NUM_NON_PREALLOC_LOCKS 4
#else  /* _DEBUG */
#define NUM_NON_PREALLOC_LOCKS 5
#endif  /* _DEBUG */

#define NUM_PREALLOC_LOCKS \
        ( _STREAM_LOCKS + NUM_STD_FILE_LOCKS - NUM_NON_PREALLOC_LOCKS )
static CRITICAL_SECTION lclcritsects[NUM_PREALLOC_LOCKS];

/*
 * Lock Table
 * This table contains a pointer to the critical section management structure
 * for each lock.
 *
 * Locks marked lkPrealloc have their critical sections statically allocated
 * and initialized at startup in _mtinitlocks.  Locks marked lkNormal must
 * be allocated when first used, via a call to _mtinitlocknum.
 */
static struct {
        PCRITICAL_SECTION lock;
        enum { lkNormal = 0, lkPrealloc, lkDeleted } kind;
} _locktable[_TOTAL_LOCKS] = {
        { NULL, lkPrealloc }, /* 0  == _SIGNAL_LOCK      */
        { NULL, lkPrealloc }, /* 1  == _IOB_SCAN_LOCK    */
        { NULL, lkNormal   }, /* 2  == _TMPNAM_LOCK      - not preallocated */
        { NULL, lkPrealloc }, /* 3  == _CONIO_LOCK       */
        { NULL, lkPrealloc }, /* 4  == _HEAP_LOCK        */
        { NULL, lkNormal   }, /* 5  == _UNDNAME_LOCK     - not preallocated */
        { NULL, lkPrealloc }, /* 6  == _TIME_LOCK        */
        { NULL, lkPrealloc }, /* 7  == _ENV_LOCK         */
        { NULL, lkPrealloc }, /* 8  == _EXIT_LOCK1       */
        { NULL, lkNormal   }, /* 9  == _POPEN_LOCK       - not preallocated */
        { NULL, lkPrealloc }, /* 10 == _LOCKTAB_LOCK     */
        { NULL, lkNormal   }, /* 11 == _OSFHND_LOCK      - not preallocated */
        { NULL, lkPrealloc }, /* 12 == _SETLOCALE_LOCK   */
        { NULL, lkPrealloc }, /* 13 == _MB_CP_LOCK       */
        { NULL, lkPrealloc }, /* 14 == _TYPEINFO_LOCK    */
#ifdef _DEBUG
        { NULL, lkPrealloc }, /* 15 == _DEBUG_LOCK       */
#else  /* _DEBUG */
        { NULL, lkNormal },   /* 15 == _DEBUG_LOCK       */
#endif  /* _DEBUG */

        { NULL, lkPrealloc }, /* 16 == _STREAM_LOCKS+0 - stdin  */
        { NULL, lkPrealloc }, /* 17 == _STREAM_LOCKS+1 - stdout */
        { NULL, lkPrealloc }, /* 18 == _STREAM_LOCKS+2 - stderr */
/*      { NULL, lkNormal   }, /* ... */
};

#ifdef _M_IX86
#pragma optimize("y",off)
#endif  /* _M_IX86 */

/***
*_mtinitlocks() - Initialize multi-thread lock scheme
*
*Purpose:
*       Perform whatever initialization is required for the multi-thread
*       locking (synchronization) scheme. This routine should be called
*       exactly once, during startup, and this must be before any requests
*       are made to assert locks.
*
*       NOTES: In Win32, the multi-thread locks are created individually,
*       each upon its first use. That is when any particular lock is asserted
*       for the first time, the underlying critical section is then allocated,
*       initialized and (finally) entered. This allocation and initialization
*       is protected under _LOCKTAB_LOCK. It is _mtinitlocks' job to set up
*       _LOCKTAB_LOCK.
*
*       All other named (non-FILE) locks are also preallocated in _mtinitlocks.
*       That is because a failure to allocate a lock on its first use in _lock
*       triggers a fatal error, which cannot be permitted since that can bring
*       down a long-lived app without warning.
*
*Entry:
*       <none>
*
*Exit:
*       returns FALSE on failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocks (
        void
        )
{
        int locknum;
        int idxPrealloc = 0;

        /*
         * Scan _locktable[] and allocate all entries marked lkPrealloc.
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].kind == lkPrealloc ) {
                _locktable[locknum].lock = &lclcritsects[idxPrealloc++];
                if ( !__crtInitCritSecAndSpinCount( _locktable[locknum].lock,
                                                    _CRT_SPINCOUNT ))
                {
                    _locktable[locknum].lock = NULL;
                    return FALSE;
                }
            }
        }


        return TRUE;
}


/***
*_mtdeletelocks() - Delete all initialized locks
*
*Purpose:
*       Walks _locktable[] and _lockmap, and deletes every 'lock' (i.e.,
*       critical section) which has been initialized.
*
*       This function is intended for use in DLLs containing the C runtime
*       (i.e., crtdll.dll and user DLLs built using libcmt.lib and the
*       special startup objects). It is to be called from within the DLL's
*       entrypoint function when that function is called with
*       DLL_PROCESS_DETACH.
*
*Entry:
*       <none>
*
*Exit:
*
*Exceptions:
*       behavior undefined/unknown if a lock is being held when this routine
*       is called.
*
*******************************************************************************/

void __cdecl _mtdeletelocks(
        void
        )
{
        int locknum;

        /*
         * Delete and free all normal locks that have been created.
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].lock != NULL &&
                 _locktable[locknum].kind != lkPrealloc )
            {
                PCRITICAL_SECTION pcs = _locktable[locknum].lock;

                DeleteCriticalSection(pcs);

                /*
                 * Free the memory for the CritSect after deleting it.
                 */

                _free_crt(pcs);
                _locktable[locknum].lock = NULL;
            }
        }

        /*
         * Delete all preallocated locks after all normal ones are
         * freed (so preallocated _HEAP_LOCK outlives all heap usages).
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].lock != NULL &&
                 _locktable[locknum].kind == lkPrealloc )
            {
                PCRITICAL_SECTION pcs = _locktable[locknum].lock;

                DeleteCriticalSection(pcs);
            }
        }
}

/***
* _mtinitlocknum - Allocate a non-preallocated multi-thread lock
*
*Purpose:
*       Allocate a new, non-preallocated multi-thread lock.  This should be
*       used whenever a new lock is known to be needed, so that failure to
*       allocate can return an error, instead of allowing _lock() to issue
*       a fatal _RT_LOCK instead.
*
*       It is not an error to call this on a normal lock which has already
*       been allocated.  It is used to ensure that certain named locks which
*       are not preallocated are available.
*
*       It is also called by _lock, in case any other paths exist which call
*       _lock without calling _mtinitlocknum first.  This is not expected,
*       and can allow fatal _RT_LOCK errors to be issued.
*
*       Since a failure sets errno to ENOMEM, this should only be called
*       after the per-thread data has been set up (after _mtinit).
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*       Returns FALSE on failure, and sets errno to ENOMEM.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocknum (
        int locknum
        )
{
        PCRITICAL_SECTION pcs;
        int retval=TRUE;

        /*
         * Check if CRT is initialized. The check if _crtheap is initialized
         * will do the job. More over we had to add this test in initlocks because
         * in debug version we don't endup calling lock before calling malloc_base,
         * where we check for crtheap.
         */
        if (_crtheap == 0) {
            _FF_MSGBANNER();    /* write run-time error banner */
            _NMSG_WRITE(_RT_CRT_NOTINIT);  /* write message */
            __crtExitProcess(255);  /* normally _exit(255) */
        }


        if ( _locktable[locknum].lock != NULL )
            return TRUE;

        if ( (pcs = _malloc_crt(sizeof(CRITICAL_SECTION))) == NULL ) {
            errno = ENOMEM;
            return FALSE;
        }

        _mlock(_LOCKTAB_LOCK);
        __TRY

            if ( _locktable[locknum].lock == NULL ) {
                if ( !__crtInitCritSecAndSpinCount(pcs, _CRT_SPINCOUNT) ) {
                    _free_crt(pcs);
                    errno = ENOMEM;
                    retval=FALSE;
                } else {
                    _locktable[locknum].lock = pcs;
                }
            }
            else {
                _free_crt(pcs);
            }

        __FINALLY
            _munlock(_LOCKTAB_LOCK);
        __END_TRY_FINALLY

        return retval;
}


/***
* _lock - Acquire a multi-thread lock
*
*Purpose:
*       Acquire a multi-thread lock.  If the lock has not already been
*       allocated, do so, but that is an internal CRT error, since all locks
*       should be allocated before first being acquired, either in
*       _mtinitlocks or individually in _mtinitlocknum.
*
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*
*Exceptions:
*       A failure to allocate a new lock results in a fatal _RT_LOCK error.
*
*******************************************************************************/

void __cdecl _lock (
        int locknum
        )
{

        /*
         * Create/open the lock, if necessary
         */
        if ( _locktable[locknum].lock == NULL ) {

            if ( !_mtinitlocknum(locknum) )
                _amsg_exit( _RT_LOCK );
        }

        /*
         * Enter the critical section.
         */

        EnterCriticalSection( _locktable[locknum].lock );
}


/***
* _unlock - Release multi-thread lock
*
*Purpose:
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to release
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock (
        int locknum
        )
{
        /*
         * leave the critical section.
         */
        LeaveCriticalSection( _locktable[locknum].lock );
}


#ifdef _M_IX86
#pragma optimize("y",on)
#endif  /* _M_IX86 */

/***
*_lockerr_exit() - Write error message and die
*
*Purpose:
*       Attempt to write out the unexpected lock error message, then terminate
*       the program by a direct API call.  This function is used in place of
*       amsg_exit(_RT_LOCK) when it is judged unsafe to allow further lock
*       or unlock calls.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lockerr_exit (
        char *msg
        )
{
        FatalAppExit(0, msg);       /* Die with message box */
        __crtExitProcess(255);      /* Just die */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mmatherr.cpp ===
/***
*matherr.c - floating point exception handling
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <math.h>
#include <stddef.h>
#include <internal.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention

int _matherr_flag = 9876;


/*
 * Pointer to user-supplied _matherr routine if one has been supplied.
 */
typedef int (__clrcall * _HANDLE_MATH_ERROR_M)(struct _exception *);

_HANDLE_MATH_ERROR_M pusermatherr = (_HANDLE_MATH_ERROR_M) _encoded_null();

extern "C" _CRTIMP void __cdecl __setusermatherr( int (__cdecl *pf)(struct _exception *) );

/***
*int _matherr(struct _exception *except) - handle math errors
*
*Purpose:
*   Permits the user customize fp error handling by redefining this function.
*
*   The default matherr does nothing and returns 0
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
extern "C" int __cdecl _matherr(struct _exception *pexcept)
{

    /*
     * If user has supplied a _matherr implementation, pass control to
     * it and let it handle the error.
     */
    _HANDLE_MATH_ERROR_M pmatherr = (_HANDLE_MATH_ERROR_M) _decode_pointer(pusermatherr);
    if ( pmatherr != NULL )
            return pmatherr(pexcept);

    return 0;
}

/***
*void __setusermatherr ( int (__cdecl *pf)(struct exception *) )
*
*Purpose:
*       Copy pointer to user-supplied matherr routine into pusermatherr
*
*Entry:
*       pf  - pointer to an implementation of _matherr supplied by the user
*Exit:
*
*Exceptions:
*******************************************************************************/

extern "C" _MRTIMP void __cdecl __setusermatherr_m( _HANDLE_MATH_ERROR_M pf)
{
        pusermatherr = (_HANDLE_MATH_ERROR_M) _encode_pointer(pf);
        if (pf != 0) {
            __setusermatherr(_matherr);
        }
        _matherr_flag = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mktime.c ===
/***
*mktime.c - Convert struct tm value to __time32_t value.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _mktime32() and _mkgmtime32(), routines to converts a time value
*       in a tm structure (possibly incomplete) into a __time32_t value, then
*       update (all) the structure fields with "normalized" values.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <ctime.h>
#include <time.h>
#include <internal.h>

/*
 * ChkAdd evaluates to TRUE if dest = src1 + src2 has overflowed
 */
#define ChkAdd(dest, src1, src2)   ( ((src1 >= 0L) && (src2 >= 0L) \
    && (dest < 0L)) || ((src1 < 0L) && (src2 < 0L) && (dest >= 0L)) )

/*
 * ChkMul evaluates to TRUE if dest = src1 * src2 has overflowed
 */
#define ChkMul(dest, src1, src2)   ( src1 ? (dest/src1 != src2) : 0 )


/*
 * Core function for both _mktime32() and _mkgmtime32()
 */
static __time32_t __cdecl _make__time32_t( struct tm *, int);


/***
*__time32_t _mktime32(tb) - Normalize user time block structure
*
*Purpose:
*       _mktime32 converts a time structure, passed in as an argument, into a
*       calendar time value in internal format (__time32_t). It also completes
*       and updates the fields the of the passed in structure with 'normalized'
*       values. There are three practical uses for this routine:
*
*       (1) Convert broken-down time to internal time format (__time32_t).
*       (2) To have _mktime32 fill in the tm_wday, tm_yday, or tm_isdst fields.
*       (3) To pass in a time structure with 'out of range' values for some
*           fields and have _mktime32 "normalize" them (e.g., pass in 1/35/87 and
*           get back 2/4/87).
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mktime32 returns the specified calender time encoded as
*       a __time32_t value. Otherwise, (__time32_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

_CRTIMP __time32_t __cdecl _mktime32 (
        struct tm *tb
        )
{
        return( _make__time32_t(tb, 1) );
}


/***
*__time32_t _mkgmtime32(tb) - Convert broken down UTC time to __time32_t
*
*Purpose:
*       Convert a tm structure, passed in as an argument, containing a UTC
*       time value to internal format (__time32_t). It also completes and updates
*       the fields the of the passed in structure with 'normalized' values.

*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mkgmtime returns the calender time encoded as __time32_t
*       Otherwise, (__time32_t)(-1) is returned to indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

_CRTIMP __time32_t __cdecl _mkgmtime32 (
        struct tm *tb
        )
{
        return( _make__time32_t(tb, 0) );
}


/***
*static __time32_t _make__time32_t(tb, ultflag) -
*
*Purpose:
*       Converts a struct tm value to a __time32_t value, then updates the struct
*       tm value. Either local time or UTC is supported, based on ultflag.
*       This is the routine that actually does the work for both _mktime32() and
*       _mkgmtime32().
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*       int ultflag   - use local time flag. the tb structure is assumed
*                       to represent a local date/time if ultflag > 0.
*                       otherwise, UTC is assumed.
*
*Exit:
*       If successful, _mktime32 returns the specified calender time encoded as
*       a __time32_t value. Otherwise, (__time32_t)(-1) is returned to
*       indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

static __time32_t __cdecl _make__time32_t (
        struct tm *tb,
        int ultflag
        )
{
        __time32_t tmptm1, tmptm2, tmptm3;
        struct tm tbtemp;
        long dstbias = 0;
        long timezone = 0;

        _VALIDATE_RETURN( ( tb != NULL ), EINVAL, ( ( __time32_t )( -1 ) ) )

        /*
         * First, make sure tm_year is reasonably close to being in range.
         */
        if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR
          + 1) )
            goto err_mktime;


        /*
         * Adjust month value so it is in the range 0 - 11.  This is because
         * we don't know how many days are in months 12, 13, 14, etc.
         */

        if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) {

            /*
             * no danger of overflow because the range check above.
             */
            tmptm1 += (tb->tm_mon / 12);

            if ( (tb->tm_mon %= 12) < 0 ) {
                tb->tm_mon += 12;
                tmptm1--;
            }

            /*
             * Make sure year count is still in range.
             */
            if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR + 1) )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed years *****/

        /*
         * Calculate days elapsed minus one, in the given year, to the given
         * month. Check for leap year and adjust if necessary.
         */
        tmptm2 = _days[tb->tm_mon];
        if ( !(tmptm1 & 3) && (tb->tm_mon > 1) )
                tmptm2++;

        /*
         * Calculate elapsed days since base date (midnight, 1/1/70, UTC)
         *
         *
         * 365 days for each elapsed year since 1970, plus one more day for
         * each elapsed leap year. no danger of overflow because of the range
         * check (above) on tmptm1.
         */
        tmptm3 = (tmptm1 - _BASE_YEAR) * 365L + ((tmptm1 - 1L) >> 2)
          - _LEAP_YEAR_ADJUST;

        /*
         * elapsed days to current month (still no possible overflow)
         */
        tmptm3 += tmptm2;

        /*
         * elapsed days to current date. overflow is now possible.
         */
        tmptm1 = tmptm3 + (tmptm2 = (__time32_t)(tb->tm_mday));
        if ( ChkAdd(tmptm1, tmptm3, tmptm2) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed days *****/

        /*
         * Calculate elapsed hours since base date
         */
        tmptm2 = tmptm1 * 24L;
        if ( ChkMul(tmptm2, tmptm1, 24L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (__time32_t)tb->tm_hour);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed hours *****/

        /*
         * Calculate elapsed minutes since base date
         */

        tmptm2 = tmptm1 * 60L;
        if ( ChkMul(tmptm2, tmptm1, 60L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (__time32_t)tb->tm_min);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed minutes *****/

        /*
         * Calculate elapsed seconds since base date
         */

        tmptm2 = tmptm1 * 60L;
        if ( ChkMul(tmptm2, tmptm1, 60L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (__time32_t)tb->tm_sec);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed seconds *****/

        if  ( ultflag ) {

            /*
             * Adjust for timezone. No need to check for overflow since
             * localtime() will check its arg value
             */

            __tzset();

            _ERRCHECK(_get_dstbias(&dstbias));
            _ERRCHECK(_get_timezone(&timezone));

            tmptm1 += timezone;

            /*
             * Convert this second count back into a time block structure.
             * If localtime returns NULL, return an error.
             */
            if ( _localtime32_s(&tbtemp, &tmptm1) != 0 )
                goto err_mktime;

            /*
             * Now must compensate for DST. The ANSI rules are to use the
             * passed-in tm_isdst flag if it is non-negative. Otherwise,
             * compute if DST applies. Recall that tbtemp has the time without
             * DST compensation, but has set tm_isdst correctly.
             */
            if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) &&
              (tbtemp.tm_isdst > 0)) ) {
                tmptm1 += dstbias;
                if ( _localtime32_s(&tbtemp, &tmptm1) != 0 )
                    goto err_mktime;
            }

        }
        else {
            if ( _gmtime32_s(&tbtemp, &tmptm1) != 0 )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed seconds, adjusted *****/
        /*****       for local time if requested                      *****/

        *tb = tbtemp;
        return (__time32_t)tmptm1;

err_mktime:
        /*
         * All errors come to here
         */

        errno = EINVAL;
        return (__time32_t)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mpiostream.cpp ===
#ifdef MRTDLL
#undef MRTDLL
#endif

// This file is built into msvcurt.lib
#if !defined(_M_CEE_PURE)
#error This file must be built with /clr:pure.
#endif

#include <iostream>
#include <xiosbase>
#include <xlocale>

namespace std
{
extern _MRTIMP2 istream& __cdecl _Cin_func();
extern _MRTIMP2 ostream& __cdecl _Cout_func();
extern _MRTIMP2 ostream& __cdecl _Cerr_func();
extern _MRTIMP2 ostream& __cdecl _Clog_func();

extern _MRTIMP2 wistream& __cdecl _Wcin_func();
extern _MRTIMP2 wostream& __cdecl _Wcout_func();
extern _MRTIMP2 wostream& __cdecl _Wcerr_func();
extern _MRTIMP2 wostream& __cdecl _Wclog_func();

extern _MRTIMP2 const streamoff& __cdecl _BADOFF_func();
extern _MRTIMP2 fpos_t& __cdecl _Fpz_func();
}

#pragma warning(push)
#pragma warning(disable:4074) // warning C4074: initializers put in compiler reserved initialization area
#pragma init_seg(compiler)
#pragma warning(pop)

namespace std
{
    // Definitions
extern istream& cin  = _Cin_func();
extern ostream& cout = _Cout_func();
extern ostream& clog = _Clog_func();
extern ostream& cerr = _Cerr_func();

extern wistream& wcin  = _Wcin_func();
extern wostream& wcout = _Wcout_func();
extern wostream& wclog = _Wclog_func();
extern wostream& wcerr = _Wcerr_func();

extern const streamoff& _BADOFF = _BADOFF_func();
extern fpos_t& _Fpz = _Fpz_func();
}

int& std::locale::id::_Id_cnt =
    std::locale::id::_Id_cnt_func();
std::locale::id& std::ctype<char>::id =
    std::ctype<char>::_Id_func();
std::locale::id& std::ctype<wchar_t>::id =
    std::ctype<wchar_t>::_Id_func();
std::locale::id& std::ctype<unsigned short>::id =
    std::ctype<unsigned short>::_Id_func();
std::locale::id& std::codecvt<wchar_t, char, mbstate_t>::id =
    std::codecvt<wchar_t, char, mbstate_t>::_Id_func();
std::locale::id& std::codecvt<unsigned short, char, mbstate_t>::id =
    std::codecvt<unsigned short, char, mbstate_t>::_Id_func();
int &std::ios_base::Init::_Init_cnt =
    std::ios_base::Init::_Init_cnt_func();
int& std::ios_base::_Index =
    std::ios_base::_Index_func();
bool& std::ios_base::_Sync =
    std::ios_base::_Sync_func();
std::locale::_Locimp *&std::locale::_Locimp::_Clocptr =
    std::locale::_Locimp::_Clocptr_func();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MEMORY
#define _INC_MEMORY

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _CONST_RETURN
#ifdef __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else  /* __cplusplus */
#define _CONST_RETURN
#endif  /* __cplusplus */
#endif  /* _CONST_RETURN */

/* For backwards compatibility */
#define _WConst_return _CONST_RETURN

/* Function prototypes */
#ifndef _CRT_MEMORY_DEFINED
#define _CRT_MEMORY_DEFINED
_CRTIMP void *  __cdecl _memccpy( _Out_opt_bytecap_(_MaxCount) void * _Dst, _In_ const void * _Src, _In_ int _Val, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP _CONST_RETURN void *  __cdecl memchr( _In_opt_bytecount_(_MaxCount) const void * _Buf , _In_ int _Val, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int     __cdecl _memicmp(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size);
_Check_return_ _CRTIMP int     __cdecl _memicmp_l(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size, _In_opt_ _locale_t _Locale);
        _Check_return_ int     __cdecl memcmp(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size);
        _CRT_INSECURE_DEPRECATE_MEMORY(memcpy_s) void *  __cdecl memcpy(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#if __STDC_WANT_SECURE_LIB__
_CRTIMP errno_t  __cdecl memcpy_s(_Out_opt_bytecap_post_bytecount_(_DstSize, _MaxCount) void * _Dst, _In_ rsize_t _DstSize, _In_opt_bytecount_(_MaxCount) const void * _Src, _In_ rsize_t _MaxCount);
#endif  /* __STDC_WANT_SECURE_LIB__ */
        void *  __cdecl memset(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_ int _Val, _In_ size_t _Size);

#if !__STDC__
/* Non-ANSI names for compatibility */
_CRT_NONSTDC_DEPRECATE(_memccpy) _CRTIMP void * __cdecl memccpy(_Out_opt_bytecap_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ int _Val, _In_ size_t _Size);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_memicmp) _CRTIMP int __cdecl memicmp(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size);
#endif  /* !__STDC__ */

#endif  /* _CRT_MEMORY_DEFINED */

#ifdef __cplusplus
#ifndef _CPP_MEMCHR_DEFINED
#define _CPP_MEMCHR_DEFINED
extern "C++" _Check_return_ inline void * __CRTDECL memchr( _In_opt_bytecount_(_N) void * _Pv , _In_ int _C, _In_ size_t _N)
        { return (void*)memchr((const void*)_Pv, _C, _N); }
#endif  /* _CPP_MEMCHR_DEFINED */
#endif  /* __cplusplus */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mqsort.cpp ===
/***
*mqsort.cpp - do a binary search
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines qsort() - do a binary search an an array
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#if defined (_M_CEE)
#include <internal.h>
#include "qsort.c"

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "qsort.c"
#endif  /* defined (_M_CEE) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * Definitions and declarations for use with compiler intrinsics.
 */

#ifndef _MMINTRIN_H_INCLUDED
#define _MMINTRIN_H_INCLUDED
#ifndef __midl

#include <crtdefs.h>

#if defined (_M_CEE_PURE)
        #error ERROR: MM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#if defined __cplusplus
extern "C" { /* Begin "C" */
/* Intrinsics use C name-mangling.
 */
#endif  /* defined __cplusplus */

typedef union __declspec(intrin_type) _CRT_ALIGN(8) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;

/* General support intrinsics */
void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);

/* Packed arithmetic intrinsics */
__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);

/* Shift intrinsics */
__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);

/* Logical intrinsics */
__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);

/* Comparison intrinsics */
__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);

/* Utility intrinsics */
__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);

/* Alternate intrinsic name definitions */
#define _mm_empty         _m_empty
#define _mm_cvtsi32_si64  _m_from_int
#define _mm_cvtsi64_si32  _m_to_int
#define _mm_packs_pi16    _m_packsswb
#define _mm_packs_pi32    _m_packssdw
#define _mm_packs_pu16    _m_packuswb
#define _mm_unpackhi_pi8  _m_punpckhbw
#define _mm_unpackhi_pi16 _m_punpckhwd
#define _mm_unpackhi_pi32 _m_punpckhdq
#define _mm_unpacklo_pi8  _m_punpcklbw
#define _mm_unpacklo_pi16 _m_punpcklwd
#define _mm_unpacklo_pi32 _m_punpckldq
#define _mm_add_pi8       _m_paddb
#define _mm_add_pi16      _m_paddw
#define _mm_add_pi32      _m_paddd
#define _mm_adds_pi8      _m_paddsb
#define _mm_adds_pi16     _m_paddsw
#define _mm_adds_pu8      _m_paddusb
#define _mm_adds_pu16     _m_paddusw
#define _mm_sub_pi8       _m_psubb
#define _mm_sub_pi16      _m_psubw
#define _mm_sub_pi32      _m_psubd
#define _mm_subs_pi8      _m_psubsb
#define _mm_subs_pi16     _m_psubsw
#define _mm_subs_pu8      _m_psubusb
#define _mm_subs_pu16     _m_psubusw
#define _mm_madd_pi16     _m_pmaddwd
#define _mm_mulhi_pi16    _m_pmulhw
#define _mm_mullo_pi16    _m_pmullw
#define _mm_sll_pi16      _m_psllw
#define _mm_slli_pi16     _m_psllwi
#define _mm_sll_pi32      _m_pslld
#define _mm_slli_pi32     _m_pslldi
#define _mm_sll_si64      _m_psllq
#define _mm_slli_si64     _m_psllqi
#define _mm_sra_pi16      _m_psraw
#define _mm_srai_pi16     _m_psrawi
#define _mm_sra_pi32      _m_psrad
#define _mm_srai_pi32     _m_psradi
#define _mm_srl_pi16      _m_psrlw
#define _mm_srli_pi16     _m_psrlwi
#define _mm_srl_pi32      _m_psrld
#define _mm_srli_pi32     _m_psrldi
#define _mm_srl_si64      _m_psrlq
#define _mm_srli_si64     _m_psrlqi
#define _mm_and_si64      _m_pand
#define _mm_andnot_si64   _m_pandn
#define _mm_or_si64       _m_por
#define _mm_xor_si64      _m_pxor
#define _mm_cmpeq_pi8     _m_pcmpeqb
#define _mm_cmpeq_pi16    _m_pcmpeqw
#define _mm_cmpeq_pi32    _m_pcmpeqd
#define _mm_cmpgt_pi8     _m_pcmpgtb
#define _mm_cmpgt_pi16    _m_pcmpgtw
#define _mm_cmpgt_pi32    _m_pcmpgtd


#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */
#endif  /* __midl */
#endif  /* _MMINTRIN_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;       Copyright (c) Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       This file contains definitions of a number of macros which
;       make the writing of memory model dependent code for the
;       386 a little easier and more portable.
;
;*******************************************************************************

; general code & data size constants & macros

DAT_ADDR_SZ =   4
BDAT_ADDR_SZ =  2

TXT_ADDR_SZ =   4

; Big/Little Endian Definitions for Long Integers

ifdef   bigend                  ; Big Endian (hi word at low address)
LOWORD  equ     [4]
HIWORD  equ     [0]
else                            ; Little Endian (low word at low address)
LOWORD  equ     [0]
HIWORD  equ     [4]
endif


; All Model Definitions

BPARGBAS equ    TXT_ADDR_SZ+4   ; offset from BP to first argument
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mpushiostream.cpp ===
#ifdef MRTDLL
#undef MRTDLL
#endif

// This file is built into msvcurt.lib
#if !defined(_M_CEE_PURE)
#error This file must be built with /clr:pure.
#endif

 #ifdef _NATIVE_WCHAR_T_DEFINED
  #include <fstream>

  #ifndef wistream

  #define wistream    ushistream
  #define wostream    ushostream
  #define wfilebuf    ushfilebuf
  #define _Init_wcerr _Init_ushcerr
  #define _Init_wcout _Init_ushcout
  #define _Init_wclog _Init_ushclog
  #define _Init_wcin  _Init_ushcin
  #define _Winit      _UShinit
  #define init_wcerr  init_ushcerr
  #define init_wcout  init_ushcout
  #define init_wclog  init_ushclog
  #define init_wcin   init_ushcin 
  #endif

  #include <iostream>

namespace std
{
  extern _MRTIMP2 wistream& __cdecl _Wcin_func();
  extern _MRTIMP2 wostream& __cdecl _Wcout_func();
  extern _MRTIMP2 wostream& __cdecl _Wcerr_func();
  extern _MRTIMP2 wostream& __cdecl _Wclog_func();
}

#pragma warning(push)
#pragma warning(disable:4074) // warning C4074: initializers put in compiler reserved initialization area
#pragma init_seg(compiler)
#pragma warning(pop)

std::ushistream &std::wcin  = std::_Wcin_func();
std::ushostream &std::wcout = std::_Wcout_func();
std::ushostream &std::wclog = std::_Wclog_func();
std::ushostream &std::wcerr = std::_Wcerr_func();

 #endif
#include <fstream>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mwcrtexe.cpp ===
/***
*wcrtexe.c - Initialization for console EXE using CRT DLL, wchar_t version
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for console apps using wide
*       characters.  It calls the user's main routine wmain() after
*       performing C Run-Time Library initialization.
*
*******************************************************************************/

#define WPRFLAG 1

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#undef _MBCS /* UNICODE not _MBCS */

#include "mcrtexe.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mtdll.h ===
/***
*mtdll.h - DLL/Multi-thread include
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MTDLL
#define _INC_MTDLL

#include <crtdefs.h>
#include <limits.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#include <windows.h>


/*
 * Define the number of supported handles and streams. The definitions
 * here must exactly match those in internal.h (for _NHANDLE_) and stdio.h
 * (for _NSTREAM_).
 */

#define _IOB_ENTRIES    20

/* Lock symbols */

#define _SIGNAL_LOCK    0       /* lock for signal()                */
#define _IOB_SCAN_LOCK  1       /* _iob[] table lock                */
#define _TMPNAM_LOCK    2       /* lock global tempnam variables    */
#define _CONIO_LOCK     3       /* lock for conio routines          */
#define _HEAP_LOCK      4       /* lock for heap allocator routines */
#define _UNDNAME_LOCK   5       /* lock for unDName() routine       */
#define _TIME_LOCK      6       /* lock for time functions          */
#define _ENV_LOCK       7       /* lock for environment variables   */
#define _EXIT_LOCK1     8       /* lock #1 for exit code            */
#define _POPEN_LOCK     9       /* lock for _popen/_pclose database */
#define _LOCKTAB_LOCK   10      /* lock to protect semaphore lock table */
#define _OSFHND_LOCK    11      /* lock to protect _osfhnd array    */
#define _SETLOCALE_LOCK 12      /* lock for locale handles, etc.    */
#define _MB_CP_LOCK     13      /* lock for multibyte code page     */
#define _TYPEINFO_LOCK  14      /* lock for type_info access        */
#define _DEBUG_LOCK     15      /* lock for debug global structs    */

#define _STREAM_LOCKS   16      /* Table of stream locks            */

#define _LAST_STREAM_LOCK  (_STREAM_LOCKS+_IOB_ENTRIES-1) /* Last stream lock */

#define _TOTAL_LOCKS        (_LAST_STREAM_LOCK+1)

#define _LOCK_BIT_INTS     (_TOTAL_LOCKS/(sizeof(unsigned)*8))+1   /* # of ints to hold lock bits */

#ifndef __assembler

/* Multi-thread macros and prototypes */


#define __TRY __try{
#define __FINALLY   }__finally{
#define __END_TRY_FINALLY }


#ifndef _THREADMBCINFO
typedef struct threadmbcinfostruct threadmbcinfo;
#endif  /* _THREADMBCINFO */

#ifndef _TAGLC_ID_DEFINED
typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED
#endif  /* _TAGLC_ID_DEFINED */

#define MAX_LANG_LEN        64  /* max language name length */
#define MAX_CTRY_LEN        64  /* max country name length */
#define MAX_MODIFIER_LEN    0   /* max modifier name length - n/a */
#define MAX_LC_LEN          (MAX_LANG_LEN+MAX_CTRY_LEN+MAX_MODIFIER_LEN+3)
                                /* max entire locale string length */
#define MAX_CP_LEN          16  /* max code page name length */
#define CATNAMES_LEN        57  /* "LC_COLLATE=;LC_CTYPE=;..." length */

#define LC_INT_TYPE         0
#define LC_STR_TYPE         1

#ifndef _SETLOC_STRUCT_DEFINED
struct _is_ctype_compatible {
        unsigned long id;
        int is_clike;
};
typedef struct setloc_struct {
    /* getqloc static variables */
    char *pchLanguage;
    char *pchCountry;
    int iLcidState;
    int iPrimaryLen;
    BOOL bAbbrevLanguage;
    BOOL bAbbrevCountry;
    LCID lcidLanguage;
    LCID lcidCountry;
    /* expand_locale static variables */
    LC_ID       _cacheid;
    UINT        _cachecp;
    char        _cachein[MAX_LC_LEN];
    char        _cacheout[MAX_LC_LEN];
    /* _setlocale_set_cat (LC_CTYPE) static variable */
    struct _is_ctype_compatible _Lcid_c[5];
} _setloc_struct, *_psetloc_struct;
#define _SETLOC_STRUCT_DEFINED
#endif  /* _SETLOC_STRUCT_DEFINED */

_CRTIMP extern unsigned long __cdecl __threadid(void);
#define _threadid   (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#define _threadhandle   (__threadhandle())

/* Structure for each thread's data */

struct _tiddata {
    unsigned long   _tid;       /* thread ID */


    uintptr_t _thandle;         /* thread handle */

    int     _terrno;            /* errno value */
    unsigned long   _tdoserrno; /* _doserrno value */
    unsigned int    _fpds;      /* Floating Point data segment */
    unsigned long   _holdrand;  /* rand() seed value */
    char *      _token;         /* ptr to strtok() token */
    wchar_t *   _wtoken;        /* ptr to wcstok() token */
    unsigned char * _mtoken;    /* ptr to _mbstok() token */

    /* following pointers get malloc'd at runtime */
    char *      _errmsg;        /* ptr to strerror()/_strerror() buff */
    wchar_t *   _werrmsg;       /* ptr to _wcserror()/__wcserror() buff */
    char *      _namebuf0;      /* ptr to tmpnam() buffer */
    wchar_t *   _wnamebuf0;     /* ptr to _wtmpnam() buffer */
    char *      _namebuf1;      /* ptr to tmpfile() buffer */
    wchar_t *   _wnamebuf1;     /* ptr to _wtmpfile() buffer */
    char *      _asctimebuf;    /* ptr to asctime() buffer */
    wchar_t *   _wasctimebuf;   /* ptr to _wasctime() buffer */
    void *      _gmtimebuf;     /* ptr to gmtime() structure */
    char *      _cvtbuf;        /* ptr to ecvt()/fcvt buffer */
    unsigned char _con_ch_buf[MB_LEN_MAX];
                                /* ptr to putch() buffer */
    unsigned short _ch_buf_used;   /* if the _con_ch_buf is used */

    /* following fields are needed by _beginthread code */
    void *      _initaddr;      /* initial user thread address */
    void *      _initarg;       /* initial user thread argument */

    /* following three fields are needed to support signal handling and
     * runtime errors */
    void *      _pxcptacttab;   /* ptr to exception-action table */
    void *      _tpxcptinfoptrs; /* ptr to exception info pointers */
    int         _tfpecode;      /* float point exception code */

    /* pointer to the copy of the multibyte character information used by
     * the thread */
    pthreadmbcinfo  ptmbcinfo;

    /* pointer to the copy of the locale informaton used by the thead */
    pthreadlocinfo  ptlocinfo;
    int         _ownlocale;     /* if 1, this thread owns its own locale */

    /* following field is needed by NLG routines */
    unsigned long   _NLG_dwCode;

    /*
     * Per-Thread data needed by C++ Exception Handling
     */
    void *      _terminate;     /* terminate() routine */
    void *      _unexpected;    /* unexpected() routine */
    void *      _translator;    /* S.E. translator */
    void *      _purecall;      /* called when pure virtual happens */
    void *      _curexception;  /* current exception */
    void *      _curcontext;    /* current exception context */
    int         _ProcessingThrow; /* for uncaught_exception */
    void *              _curexcspec;    /* for handling exceptions thrown from std::unexpected */
#if defined (_M_IA64) || defined (_M_AMD64)
    void *      _pExitContext;
    void *      _pUnwindContext;
    void *      _pFrameInfoChain;
    unsigned __int64    _ImageBase;
#if defined (_M_IA64)
    unsigned __int64    _TargetGp;
#endif  /* defined (_M_IA64) */
    unsigned __int64    _ThrowImageBase;
    void *      _pForeignException;
#elif defined (_M_IX86)
    void *      _pFrameInfoChain;
#endif  /* defined (_M_IX86) */
    _setloc_struct _setloc_data;

#ifdef _M_IX86
    void *      _encode_ptr;    /* EncodePointer() routine */
    void *      _decode_ptr;    /* DecodePointer() routine */
#endif  /* _M_IX86 */

    void *      _reserved1;     /* nothing */
    void *      _reserved2;     /* nothing */
    void *      _reserved3;     /* nothing */

    int _cxxReThrow;        /* Set to True if it's a rethrown C++ Exception */

    unsigned long __initDomain;     /* initial domain used by _beginthread[ex] for managed function */
};

typedef struct _tiddata * _ptiddata;

/*
 * Declaration of TLS index used in storing pointers to per-thread data
 * structures.
 */
extern unsigned long __flsindex;
#ifdef _M_IX86
extern unsigned long __getvalueindex;
#endif  /* _M_IX86 */

/* macros */

#define _lock_fh(fh)            __lock_fhandle(fh)
#define _lock_str(s)            _lock_file(s)
#define _lock_str2(i,s)         _lock_file2(i,s)
#define _mlock(l)               _lock(l)
#define _munlock(l)             _unlock(l)
#define _unlock_fh(fh)          _unlock_fhandle(fh)
#define _unlock_str(s)          _unlock_file(s)
#define _unlock_str2(i,s)       _unlock_file2(i,s)

/* multi-thread routines */

#ifdef _M_CEE
#ifndef _CRT_MSVCR_CURRENT
#ifdef _DEBUG
   #define _CRT_MSVCR_CURRENT "MSVCR90D.dll"
#else  /* _DEBUG */
   #define _CRT_MSVCR_CURRENT "MSVCR90.dll"
#endif  /* _DEBUG */
#endif  /* _CRT_MSVCR_CURRENT */
 #define _INTEROPSERVICES_DLLIMPORT(_DllName , _EntryPoint , _CallingConvention) \
    [System::Runtime::InteropServices::DllImport(_DllName , EntryPoint = _EntryPoint, CallingConvention = _CallingConvention)]
 #define _SUPPRESS_UNMANAGED_CODE_SECURITY [System::Security::SuppressUnmanagedCodeSecurity]
 #define _CALLING_CONVENTION_CDECL System::Runtime::InteropServices::CallingConvention::Cdecl
 #define _RELIABILITY_CONTRACT \
    [System::Runtime::ConstrainedExecution::ReliabilityContract( \
        System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState, \
        System::Runtime::ConstrainedExecution::Cer::Success)]
#else  /* _M_CEE */
 #define _INTEROPSERVICES_DLLIMPORT(_DllName , _EntryPoint , _CallingConvention)
 #define _SUPPRESS_UNMANAGED_CODE_SECURITY
 #define _CALLING_CONVENTION_CDECL
 #define _RELIABILITY_CONTRACT
#endif  /* _M_CEE */

_SUPPRESS_UNMANAGED_CODE_SECURITY
_RELIABILITY_CONTRACT
_INTEROPSERVICES_DLLIMPORT(_CRT_MSVCR_CURRENT, "_lock", _CALLING_CONVENTION_CDECL)
void __cdecl _lock(_In_ int _File);
void __cdecl _lock_file2(_In_ int _Index, _Inout_ void * _File);
void __cdecl _lockexit(void);
_SUPPRESS_UNMANAGED_CODE_SECURITY
_RELIABILITY_CONTRACT
_INTEROPSERVICES_DLLIMPORT(_CRT_MSVCR_CURRENT, "_unlock", _CALLING_CONVENTION_CDECL)
void __cdecl _unlock(_Inout_ int _File);
void __cdecl _unlock_file2(_In_ int _Index, _Inout_ void * _File);
void __cdecl _unlockexit(void);
int  __cdecl _mtinitlocknum(_In_ int _LockNum);

_ptiddata __cdecl _getptd(void);  /* return address of per-thread CRT data */
_ptiddata __cdecl _getptd_noexit(void);  /* return address of per-thread CRT data - doesn't exit on malloc failure */
_CRTIMP void WINAPI _freefls(_Inout_opt_ void * _PerFiberData);         /* free up per-fiber CRT data block */
void __cdecl _freeptd(_Inout_opt_ _ptiddata _Ptd); /* free up a per-thread CRT data block */
_CRTIMP void __cdecl _initptd(_Inout_ _ptiddata _Ptd,_In_opt_ pthreadlocinfo _Locale); /* initialize a per-thread CRT data block */

/*
Define Fiber Local Storage function prototypes and access macros.
*/

typedef
VOID
(WINAPI *PFLS_CALLBACK_FUNCTION) (
    IN PVOID lpFlsData
    );

typedef
DWORD
(WINAPI *PFLS_ALLOC_FUNCTION) (
    IN PFLS_CALLBACK_FUNCTION lpCallback OPTIONAL
    );

typedef
PVOID
(WINAPI *PFLS_GETVALUE_FUNCTION) (
    IN DWORD dwFlsIndex
    );

typedef
BOOL
(WINAPI *PFLS_SETVALUE_FUNCTION) (
    IN DWORD dwFlsIndex,
    IN PVOID lpFlsData
    );

typedef
BOOL
(WINAPI *PFLS_FREE_FUNCTION) (
    IN DWORD dwFlsIndex
    );

_CRTIMP PVOID WINAPI __fls_getvalue ( IN DWORD dwFlsIndex);
_CRTIMP BOOL WINAPI __fls_setvalue ( IN DWORD dwFlsIndex, IN PVOID lpFlsData);
_CRTIMP unsigned long __cdecl __get_flsindex(void);
_CRTIMP PFLS_GETVALUE_FUNCTION __cdecl __set_flsgetvalue(void);

#ifdef _M_IX86

extern PFLS_ALLOC_FUNCTION gpFlsAlloc;
extern PFLS_GETVALUE_FUNCTION gpFlsGetValue;
extern PFLS_SETVALUE_FUNCTION gpFlsSetValue;
extern PFLS_FREE_FUNCTION gpFlsFree;

#define FLS_ALLOC(callback)  (((PFLS_ALLOC_FUNCTION)_decode_pointer(gpFlsAlloc))(callback))
#define FLS_GETVALUE    ((PFLS_GETVALUE_FUNCTION)TlsGetValue(__getvalueindex))
#define FLS_SETVALUE(index, value) (((PFLS_SETVALUE_FUNCTION)_decode_pointer(gpFlsSetValue))(index, value))
#define FLS_FREE(index) (((PFLS_FREE_FUNCTION)_decode_pointer(gpFlsFree))(index))

#else  /* _M_IX86 */

#define FLS_ALLOC(callback) FlsAlloc(callback)
#define FLS_GETVALUE(index) FlsGetValue(index)
#define FLS_SETVALUE(index, value) FlsSetValue(index, value)
#define FLS_FREE(index)     FlsFree(index)

#endif  /* _M_IX86 */


#endif  /* __assembler */


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\msdos.h ===
/***
*msdos.h - MS-DOS definitions for C runtime
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The file contains the MS-DOS definitions (function request numbers,
*       flags, etc.) used by the C runtime.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_MSDOS
#define _INC_MSDOS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/* Stack slop for o.s. system call overhead */

#define _STACKSLOP      1024

/* __osfile flag values for DOS file handles */

#define FOPEN           0x01    /* file handle open */
#define FEOFLAG         0x02    /* end of file has been encountered */
#define FCRLF           0x04    /* CR-LF across read buffer (in text mode) */
#define FPIPE           0x08    /* file handle refers to a pipe */
#define FNOINHERIT      0x10    /* file handle opened _O_NOINHERIT */
#define FAPPEND         0x20    /* file handle opened O_APPEND */
#define FDEV            0x40    /* file handle refers to device */
#define FTEXT           0x80    /* file handle is in text mode */

/* DOS errno values for setting __doserrno in C routines */

#define E_ifunc         1       /* invalid function code */
#define E_nofile        2       /* file not found */
#define E_nopath        3       /* path not found */
#define E_toomany       4       /* too many open files */
#define E_access        5       /* access denied */
#define E_ihandle       6       /* invalid handle */
#define E_arena         7       /* arena trashed */
#define E_nomem         8       /* not enough memory */
#define E_iblock        9       /* invalid block */
#define E_badenv        10      /* bad environment */
#define E_badfmt        11      /* bad format */
#define E_iaccess       12      /* invalid access code */
#define E_idata         13      /* invalid data */
#define E_unknown       14      /* ??? unknown error ??? */
#define E_idrive        15      /* invalid drive */
#define E_curdir        16      /* current directory */
#define E_difdev        17      /* not same device */
#define E_nomore        18      /* no more files */
#define E_maxerr2       19      /* unknown error - Version 2.0 */
#define E_sharerr       32      /* sharing violation */
#define E_lockerr       33      /* locking violation */
#define E_maxerr3       34      /* unknown error - Version 3.0 */

/* DOS file attributes */

#define A_RO            0x1     /* read only */
#define A_H             0x2     /* hidden */
#define A_S             0x4     /* system */
#define A_V             0x8     /* volume id */
#define A_D             0x10    /* directory */
#define A_A             0x20    /* archive */

#define A_MOD   (A_RO+A_H+A_S+A_A)      /* changeable attributes */

#endif  /* _INC_MSDOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\msize.c ===
/***
*msize.c - calculate the size of a memory block in the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the following function:
*           _msize()    - calculate the size of a block in the heap
*
*******************************************************************************/


#ifdef WINHEAP


#include <cruntime.h>
#include <malloc.h>
#include <mtdll.h>
#include <winheap.h>
#include <windows.h>
#include <dbgint.h>
#include <internal.h>

/***
*size_t _msize(pblock) - calculate the size of specified block in the heap
*
*Purpose:
*       Calculates the size of memory block (in the heap) pointed to by
*       pblock.
*
*Entry:
*       void *pblock - pointer to a memory block in the heap
*
*Return:
*       size of the block
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

size_t __cdecl _msize_base (void * pblock)
{
        size_t      retval;

        /* validation section */
        _VALIDATE_RETURN(pblock != NULL, EINVAL, -1);


#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            PHEADER     pHeader;

            _mlock( _HEAP_LOCK );
            __try {
            if ((pHeader = __sbh_find_block(pblock)) != NULL)
                retval = (size_t)
                         (((PENTRY)((char *)pblock - sizeof(int)))->sizeFront - 0x9);
            }
            __finally {
                _munlock( _HEAP_LOCK );
            }
            if ( pHeader == NULL )
                retval = (size_t)HeapSize(_crtheap, 0, pblock);
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            __old_sbh_region_t *preg;
            __old_sbh_page_t *  ppage;
            __old_page_map_t *  pmap;
            _mlock(_HEAP_LOCK);
            __try {
            if ( (pmap = __old_sbh_find_block(pblock, &preg, &ppage)) != NULL )
                retval = ((size_t)(*pmap)) << _OLD_PARASHIFT;
            }
            __finally {
                _munlock( _HEAP_LOCK );
            }
            if ( pmap == NULL )
                retval = (size_t) HeapSize( _crtheap, 0, pblock );
        }
#endif  /* CRTDLL */
        else    /* __active_heap == __SYSTEM_HEAP */
#endif  /* _WIN64 */
        {
            retval = (size_t)HeapSize(_crtheap, 0, pblock);
        }

        return retval;

}

#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <dbgint.h>

/***
*size_t _msize(pblock) - calculate the size of specified block in the heap
*
*Purpose:
*       Calculates the size of memory block (in the heap) pointed to by
*       pblock.
*
*Entry:
*       void *pblock - pointer to a memory block in the heap
*
*Return:
*       size of the block
*
*******************************************************************************/


size_t __cdecl _msize_base (
        void *pblock
        )
{
        size_t  retval;

        /* lock the heap
         */
        _mlock(_HEAP_LOCK);

        retval = _msize_nolock(pblock);

        /* release the heap lock
         */
        _munlock(_HEAP_LOCK);

        return retval;
}

size_t __cdecl _msize_nolock (


        void *pblock
        )
{


        return( (size_t) ((char *)_ADDRESS(_BACKPTR(pblock)->pnextdesc) -
        (char *)pblock) );
}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\natstart.c ===
/***
*natstart.c - native startup tracking variable.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains native startup tracking variable.
*
*******************************************************************************/

#include <crtdefs.h>
#include <internal.h>

/*
 * __native_startup_state :
 * 0 - No initialization code executed yet.
 * 1 - In process of initialization.
 * 2 - Native initialization done.
 */
_PGLOBAL
#if defined (__cplusplus)
extern "C"
{
#endif  /* defined (__cplusplus) */
volatile unsigned int __native_dllmain_reason = __NO_REASON;
volatile unsigned int __native_vcclrit_reason = __NO_REASON;
volatile __enative_startup_state __native_startup_state; /* process-wide state of native init */
void * volatile __native_startup_lock; /* fiber ID currently doing native init */
#if defined (__cplusplus)
}
#endif  /* defined (__cplusplus) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mstartup.cpp ===
/***
*crtexe.c - Initialization for console EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps linking to the CRT DLL.
*       It calls the user's main routine [w]main() or [w]WinMain after
*       performing C Run-Time Library initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrtexe.c   the startup routine for console apps with wide chars
*       crtexew.c   the startup routine for Windows apps
*       wcrtexew.c  the startup routine for Windows apps with wide chars
*
*******************************************************************************/

#define _CPP_MSTARTUP

#using <mscorlib.dll>
#if defined (_DEBUG)
#using <system.dll>
#endif  /* defined (_DEBUG) */
/*
 * SPECIAL BUILD MACROS! Note that crtexe.c (and crtexew.c) is linked in with
 * the client's code. It does not go into crtdll.dll! Therefore, it must be
 * built under the _DLL switch (like user code) and CRTDLL must be undefined.
 * The symbol SPECIAL_CRTEXE is turned on to suppress the normal CRT DLL
 * definition of _fmode and _commode using __declspec(dllexport).  Otherwise
 * this module would not be able to refer to both the local and DLL versions
 * of these two variables.
 */

#undef MRTDLL

#define SPECIAL_CRTEXE

#include <crtdefs.h>
#include <cruntime.h>

#if defined (_M_CEE_MIXED)

/* Some inline functions (like NtCurrentTeb) need to be unmanaged */
#pragma managed(push, off)
#include <oscalls.h>
#pragma managed(pop)

#else  /* defined (_M_CEE_MIXED) */

#include <oscalls.h>

#endif  /* defined (_M_CEE_MIXED) */

#include <internal.h>
#include <process.h>
#include <math.h>
#include <sect_attribs.h>
#include <rterr.h>
#include <conio.h>
#include <gcroot.h>
#include <vcclr.h>
#include <eh.h>
#include <time.h>

#pragma warning(disable:4483)   // disable warning/error about __identifier(<string>)

extern "C" {

// Note that managed items held in these arrays are really metadata tokens
// not clrcall function pointers so it's OK for these to be _PGLOBAL.

#if defined (_M_CEE_MIXED)

#pragma const_seg(".CRTMP$XCA")
_PGLOBAL const _CRTALLOC(".CRTMP$XCA") _PVFVM __xc_mp_a[1] = { NULL };

#pragma const_seg(".CRTMP$XCZ")
_PGLOBAL const _CRTALLOC(".CRTMP$XCZ") _PVFVM __xc_mp_z[1] = { NULL };

#endif  /* defined (_M_CEE_MIXED) */

#pragma const_seg(".CRTMA$XCA")
_PGLOBAL const _CRTALLOC(".CRTMA$XCA") _PVFVM __xc_ma_a[1] = { NULL };

#pragma const_seg(".CRTMA$XCZ")
_PGLOBAL const _CRTALLOC(".CRTMA$XCZ") _PVFVM __xc_ma_z[1] = { NULL };

#pragma const_seg(".CRTVT$XCA")
_PGLOBAL const _CRTALLOC(".CRTVT$XCA") _PVFVM __xi_vt_a[1] = { NULL };

#pragma const_seg(".CRTVT$XCZ")
_PGLOBAL const _CRTALLOC(".CRTVT$XCZ") _PVFVM __xi_vt_z[1] = { NULL };

#pragma const_seg()  /* reset */

#pragma comment(linker, "/merge:.CRTMP=.rdata")
#pragma comment(linker, "/merge:.CRTMA=.rdata")
#pragma comment(linker, "/merge:.CRTVT=.rdata")

#pragma comment(linker, "/defaultlib:kernel32.lib")

#if defined (_M_CEE_MIXED)
extern "C" _PGLOBAL _CRTALLOC(".CRT$XIA") _PIFV __xi_a[];
extern "C" _PGLOBAL _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[];    /* C initializers */
extern "C" _PGLOBAL _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern "C" _PGLOBAL _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */
#endif  /* defined (_M_CEE_MIXED) */
}

#if defined (_M_CEE_MIXED)
extern "C" int __clrcall _initatexit_m();
extern "C" void __clrcall _exit_callback(void);
#endif  /* defined (_M_CEE_MIXED) */
extern "C" int __clrcall _initatexit_app_domain();
extern "C" void __clrcall _app_exit_callback();

int __clrcall _initterm_e ( _PIFV *, _PIFV *);
void __clrcall _initterm ( _PVFV *, _PVFV *);
void __clrcall _initterm_m ( const _PVFVM *, const _PVFVM *);

#if defined (_M_CEE_MIXED)
#pragma managed(push, off)
[System::Diagnostics::DebuggerStepThroughAttribute]
void * __cdecl _getFiberPtrId()
{
    return ((PNT_TIB)NtCurrentTeb())->StackBase;
}

extern "C"
void __cdecl __security_init_cookie(void);
#pragma managed(pop)
#endif  /* defined (_M_CEE_MIXED) */


#include <minternal.h>

namespace __identifier("<CrtImplementationDetails>")
{

class TriBool
{
public:
    enum State { False = 0, True = -1, Unknown = 2 };
private:
    TriBool();
    ~TriBool();
};

class Progress
{
public:
    enum State { NotStarted = 0, Started, Finished };
private:
    Progress();
    ~Progress();
};

#if defined (_M_CEE_MIXED)

class AllDomains
{
public:
    // The number of domains in which the module is loaded
    _PGLOBAL static int Count;
};
_PGLOBAL int AllDomains::Count = 0;

class DefaultDomain
{
private:
    _PGLOBAL static TriBool::State hasPerProcess;
    _PGLOBAL static TriBool::State hasNative;
    /*static void __cdecl DoNothing()
    {
    }*/
    static HRESULT __stdcall DoNothing(void* cookie)
    {
        cookie;
        // Execute simple managed code
        System::GC::KeepAlive(System::Int32::MaxValue);
        return S_OK;
    }

public:
    _PGLOBAL static bool Entered;
    _PGLOBAL static bool InitializedNative;
    _PGLOBAL static bool InitializedNativeFromCCTOR;
    _PGLOBAL static bool InitializedPerProcess;

    inline static bool HasPerProcess()
    {
        if (hasPerProcess == TriBool::Unknown)
        {
            void **pBeg = (void **)(void *)__xc_mp_a;
            void **pEnd = (void **)(void *)__xc_mp_z;
            while (pBeg < pEnd)
            {
                if (*pBeg != 0)
                {
                    hasPerProcess = TriBool::True;
                    return true;
                }
                pBeg++;
            }

            hasPerProcess = TriBool::False;
            return false;
        }
        return hasPerProcess == TriBool::True;
    }

    inline static bool HasNative()
    {
        if (hasNative == TriBool::Unknown)
        {
            void **pBeg = (void **)(void *)__xi_a;
            void **pEnd = (void **)(void *)__xi_z;

            while (pBeg < pEnd)
            {
                if (*pBeg != 0)
                {
                    hasNative = TriBool::True;
                    return true;
                }
                pBeg++;
            }

            pBeg = (void **)(void *)__xc_a;
            pEnd = (void **)(void *)__xc_z;
            while (pBeg < pEnd)
            {
                if (*pBeg != 0)
                {
                    hasNative = TriBool::True;
                    return true;
                }
                pBeg++;
            }

            hasNative = TriBool::False;
            return false;
        }
        return hasNative == TriBool::True;
    }

    inline static bool NeedsInitialization()
    {
        return ((HasPerProcess() && !InitializedPerProcess) || (HasNative() && !InitializedNative && (__native_startup_state == __uninitialized)));
    }

    inline static bool NeedsUninitialization()
    {
        // If the default domain has been entered then there's a chance that
        // atexit has been called and we need to transition into it to uninitialize it.
        return Entered;
    }

    inline static void Initialize()
    {
        // Trigger call to the module constructor
        DoCallBackInDefaultDomain(&DoNothing, nullptr);
    }

private:
    DefaultDomain();
    ~DefaultDomain();
};

_PGLOBAL bool DefaultDomain::Entered = false;
_PGLOBAL bool DefaultDomain::InitializedNative = false;
_PGLOBAL bool DefaultDomain::InitializedNativeFromCCTOR = false;
_PGLOBAL bool DefaultDomain::InitializedPerProcess = false;
_PGLOBAL TriBool::State DefaultDomain::hasPerProcess = TriBool::Unknown;
_PGLOBAL TriBool::State DefaultDomain::hasNative = TriBool::Unknown;

#endif  /* defined (_M_CEE_MIXED) */

class CurrentDomain
{
public:
    _AGLOBAL static int Initialized;
    _AGLOBAL static int Uninitialized;
    _AGLOBAL static bool IsDefaultDomain;
    _AGLOBAL static Progress::State InitializedVtables;
    _AGLOBAL static Progress::State InitializedNative;
    _AGLOBAL static Progress::State InitializedPerProcess;
    _AGLOBAL static Progress::State InitializedPerAppDomain;
private:
    CurrentDomain();  // Not instantiable
    ~CurrentDomain(); // Not instantiable
};

_AGLOBAL int CurrentDomain::Initialized = 0;
_AGLOBAL int CurrentDomain::Uninitialized = 0;
_AGLOBAL bool CurrentDomain::IsDefaultDomain = false;
_AGLOBAL Progress::State CurrentDomain::InitializedVtables = Progress::NotStarted;
_AGLOBAL Progress::State CurrentDomain::InitializedNative = Progress::NotStarted;
_AGLOBAL Progress::State CurrentDomain::InitializedPerProcess = Progress::NotStarted;
_AGLOBAL Progress::State CurrentDomain::InitializedPerAppDomain = Progress::NotStarted;

#ifdef GetTempFileName
#undef GetTempFileName
#endif  /* GetTempFileName */

class ActivationContext
{
    HANDLE ActivationCtxHandle;
    ULONG_PTR ActivationCtxCookie;
    gcroot<String^> ErrorMessage;

    ActivationContext( const ActivationContext& );
public :
    ActivationContext() :
        ActivationCtxHandle( INVALID_HANDLE_VALUE ),
        ActivationCtxCookie( 0 )
    {
    }

    ~ActivationContext()
    {
        Release();
    }

    void Create()
    {
        if ( ActivationCtxHandle != INVALID_HANDLE_VALUE )
        {
            return ;
        }

        HMODULE hKernel = GetModuleHandleW( L"KERNEL32" );
        if ( GetProcAddress( hKernel, "CreateActCtxW" ) == NULL )
        {
            // Pre XP OS
            return;
        }

        bool ManifestInFile = false;

        System::Reflection::Assembly^ CurrentAssembly = System::Reflection::Assembly::GetCallingAssembly();
        String^ AssemblyPath = CurrentAssembly->Location;
        try
        {
                if ( AssemblyPath == "" )
                {
                    String^ TempPath = System::IO::Path::GetTempFileName();
                    System::IO::StreamWriter^ sw = System::IO::File::CreateText(TempPath);
                    sw->Write (
                        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n"
                        "<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\n"
                        "   <dependency>\n"
                        "       <dependentAssembly>\n"
                        "           <assemblyIdentity\n"
                        "               type='win32'\n"
#ifdef _DEBUG
                        "               name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".DebugCRT'\n"
#else  /* _DEBUG */
                        "               name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".CRT'\n"
#endif  /* _DEBUG */
                        "               version='" _CRT_ASSEMBLY_VERSION "'\n"
#ifdef _M_IX86
                        "               processorArchitecture='x86'\n"
#endif  /* _M_IX86 */
#ifdef _M_AMD64
                        "               processorArchitecture='amd64'\n"
#endif  /* _M_AMD64 */
#ifdef _M_IA64
                        "               processorArchitecture='ia64'\n"
#endif  /* _M_IA64 */
                        "               publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'/>\n"
                        "       </dependentAssembly>\n"
                        "   </dependency>\n"
                        "</assembly>\n"
                    );
                    sw->Close();
                    ManifestInFile = true;
                    AssemblyPath = TempPath;
                }

                cli::pin_ptr<const System::Char> pAssemblyPath = PtrToStringChars(AssemblyPath);

                ACTCTXW actctx;
                // Don't call memset. memset results in a call to msvcr*.dll which can be loaded from WinSXS
                // only after the activation context is activated.
                actctx.wProcessorArchitecture = 0;
                actctx.wLangId = 0;
                actctx.lpAssemblyDirectory = NULL;
                actctx.lpApplicationName = NULL;
                actctx.hModule = NULL;

                actctx.cbSize = sizeof( actctx );
                actctx.lpSource = pAssemblyPath;
                if (ManifestInFile)
                {
                    actctx.lpResourceName = 0;
                    actctx.dwFlags = 0;
                }
                else
                {
                    actctx.lpResourceName = MAKEINTRESOURCEW( 2 );
                    actctx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
                }

                ActivationCtxHandle = CreateActCtxW( &actctx );
                if ( ActivationCtxHandle == INVALID_HANDLE_VALUE )
                {
                    if (!ManifestInFile)
                    {
                        actctx.lpResourceName = MAKEINTRESOURCEW( 1 );
                        ActivationCtxHandle = CreateActCtxW( &actctx );
                    }
                    if ( ActivationCtxHandle == INVALID_HANDLE_VALUE )
                    {
                    }
                }
            }
            finally
            {
                if (ManifestInFile)
                {
                    System::IO::File::Delete(AssemblyPath);
                }
            }
    }

    void Activate()
    {
        if ( ActivationCtxHandle == INVALID_HANDLE_VALUE )
        {
            // Could not create activation context
            // Pre XP OS or no manifest
            return ;
        }
        if ( ActivateActCtx( ActivationCtxHandle, &ActivationCtxCookie ) != TRUE )
        {
            return ;
        }
    }

    void DeActivate()
    {
        if ( ActivationCtxHandle == INVALID_HANDLE_VALUE )
        {
            return ;
        }

        if ( ActivationCtxCookie == 0 )
        {
            // Already Deactivated
            return ;
        }
        ULONG_PTR cookie = ActivationCtxCookie;
        ActivationCtxCookie = 0;
        if ( DeactivateActCtx( 0, cookie ) == FALSE )
        {
            ErrorMessage = L"The C++ module failed to Deactivate WinSXS Activation Context.\n";
            ThrowModuleLoadException(ErrorMessage);
        }
    }

    void Release()
    {
        if ( ActivationCtxHandle == INVALID_HANDLE_VALUE )
        {
            return ;
        }
        DeActivate();
        ReleaseActCtx( ActivationCtxHandle );
        ActivationCtxHandle = INVALID_HANDLE_VALUE;
    }
};

class LanguageSupport
{
private:
    // If a non-CRT exception is thrown, this member
    // holds a constant describing the current activity
    gcroot<String^> ErrorMessage;

    // Initializes vtables (which are per-appdomain)
    [System::Diagnostics::DebuggerStepThroughAttribute]
    inline void InitializeVtables()
    {
        ErrorMessage = L"The C++ module failed to load during vtable initialization.\n";
        CurrentDomain::InitializedVtables = Progress::Started;
        _initterm_m((const _PVFVM *)__xi_vt_a, (const _PVFVM *)__xi_vt_z);
        CurrentDomain::InitializedVtables = Progress::Finished;
    }

#if defined (_M_CEE_MIXED)

    // This is a blocking call which won't return until the default app domain is initialized
    inline void InitializeDefaultAppDomain()
    {
        ErrorMessage = L"The C++ module failed to load while attempting to initialize the default appdomain.\n";
        DefaultDomain::Initialize();
    }

    // Initializes native globals
    [System::Diagnostics::DebuggerStepThroughAttribute]
    inline void InitializeNative()
    {
        MANAGED_ASSERT(CurrentDomain::IsDefaultDomain, "Native globals must be initialized in the default domain");

        ErrorMessage = L"The C++ module failed to load during native initialization.\n";

        __security_init_cookie();

        DefaultDomain::InitializedNative = true;

        using namespace _NATIVE_STARTUP_NAMESPACE;
        if (!NativeDll::IsSafeForManagedCode())
        {
            _amsg_exit( _RT_CRT_INIT_MANAGED_CONFLICT);
        }

        /*
        * In mixed code we make sure to initialize native globals as well.
        */
        if (__native_startup_state == __initializing)
        {
            _amsg_exit( _RT_CRT_INIT_MANAGED_CONFLICT);
        }
        else if (__native_startup_state == __uninitialized)
        {
            CurrentDomain::InitializedNative = Progress::Started;
            __native_startup_state = __initializing;
            if (_initterm_e(__xi_a, __xi_z) != 0)
            {
                ThrowModuleLoadException(ErrorMessage);
            }
            _initterm(__xc_a, __xc_z);
            __native_startup_state = __initialized;
            DefaultDomain::InitializedNativeFromCCTOR = true;
            CurrentDomain::InitializedNative = Progress::Finished;
        }
    }

    // Initializes per-process managed globals
    [System::Diagnostics::DebuggerStepThroughAttribute]
    inline void InitializePerProcess()
    {
        MANAGED_ASSERT(CurrentDomain::IsDefaultDomain, "Per-process globals must be initialized in the default domain");

        ErrorMessage = L"The C++ module failed to load during process initialization.\n";

        CurrentDomain::InitializedPerProcess = Progress::Started;

        _initatexit_m();

        _initterm_m((const _PVFVM *) __xc_mp_a, (const _PVFVM *)__xc_mp_z );

        CurrentDomain::InitializedPerProcess = Progress::Finished;

        DefaultDomain::InitializedPerProcess = true;
    }

#endif  /* defined (_M_CEE_MIXED) */

    // Initializes per-appdomain managed globals
    [System::Diagnostics::DebuggerStepThroughAttribute]
    inline void InitializePerAppDomain()
    {
        ErrorMessage = L"The C++ module failed to load during appdomain initialization.\n";

        CurrentDomain::InitializedPerAppDomain = Progress::Started;

        _initatexit_app_domain();

        _initterm_m( __xc_ma_a, __xc_ma_z );

        CurrentDomain::InitializedPerAppDomain = Progress::Finished;
    }

    // Registers for appdomain unload event
    [System::Diagnostics::DebuggerStepThroughAttribute]
    inline void InitializeUninitializer()
    {
        ErrorMessage = L"The C++ module failed to load during registration for the unload events.\n";
        EventHandler^ handler = gcnew EventHandler(&DomainUnload);
        RegisterModuleUninitializer(handler);
    }

    // Initializes vtables and globals required for C++ language
    [System::Diagnostics::DebuggerStepThroughAttribute]
    [System::Runtime::ConstrainedExecution::ReliabilityContract(
        System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState,
        System::Runtime::ConstrainedExecution::Cer::Success)]
    inline void _Initialize()
    {
#if !defined (_M_CEE_MIXED)
        ActivationContext ActivationCtx;
        ActivationCtx.Create();
        ActivationCtx.Activate();
        // Load MsvcrXX*.dll when the activation context is active.
        clock();
#endif  /* !defined (_M_CEE_MIXED) */

        CurrentDomain::IsDefaultDomain = AppDomain::CurrentDomain->IsDefaultAppDomain();
#if defined (_M_CEE_MIXED)
        if (CurrentDomain::IsDefaultDomain)
        {
            DefaultDomain::Entered = true;
        }
#endif  /* defined (_M_CEE_MIXED) */

#if !defined (_PARTIAL_TRUST_OBJ)
        DoDllLanguageSupportValidation();
#endif  /* !defined (_PARTIAL_TRUST_OBJ) */

#if defined (_M_CEE_MIXED)
        void *lock_free=0;
        void *fiberid=_getFiberPtrId();
        int nested=false;
        int done=false;
        int doInitializeDefaultAppDomain=false;
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
        // this make sure that __native_startup_lock is released no matter what, in line with the
        // ReliabilityContract asserted above
        try
        {
            while (!done)
            {
                try { }
                finally
                {
#if defined (_WIN64)
                    lock_free = (void*)Interlocked::CompareExchange((System::Int64&)__native_startup_lock, (System::Int64)fiberid, (System::Int64)0);
#else  /* defined (_WIN64) */
                    lock_free = (void*)Interlocked::CompareExchange((System::IntPtr&)__native_startup_lock, (System::IntPtr)fiberid, (System::IntPtr)0);
#endif  /* defined (_WIN64) */
                    if (lock_free == 0)
                    {
                        done = true;
                    }
                    else if(lock_free == fiberid)
                    {
                        nested = true;
                        done = true;
                    }
                }
                if (!done)
                {
                    // Some other thread is running native startup/shutdown during a cctor/domain unload.
                    // Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h.
                    // Wait for the other thread to complete init before we return
                    Sleep(1000);
                }
            }

            InitializeVtables();

            if (CurrentDomain::IsDefaultDomain)
            {
                    InitializeNative();
                    InitializePerProcess();
            }
            else if(DefaultDomain::NeedsInitialization())
            {
                // Do not InitializeDefaultAppDomain() when holding __native_startup_lock.
                // Essentially InitializeDefaulAppDomain() is a callback to the
                // default appdomain.  If we do the call back while holding the lock, it can
                // result in a deadlock.
                //
                // For example:
                // 1. thread1: .cctor() of a non-default appdomain calls _Initialize() and
                //    grabs the _native_startup_lock
                // 2. thread2: .cctor() of default appdomain starts to execute and tries to grab the
                //             __native_startup_lock, but fails.  Hence, busy waiting for lock.
                // 3. thread1: (still holding the lock) and do a callback to default appdomain.
                //             The CLR detects that .cctor of default appdomain has started, but
                //             not finish.  Hence block until .cctor of default app domain finishes.
                // 4. deadlock.
                doInitializeDefaultAppDomain = true;
            }
        }
        finally
        {
            if(!nested)
            {
#if defined (_WIN64)
                Interlocked::Exchange((System::Int64&)__native_startup_lock, (System::Int64)0);
#else  /* defined (_WIN64) */
                Interlocked::Exchange((System::IntPtr&)__native_startup_lock, (System::IntPtr)0);
#endif  /* defined (_WIN64) */
            }
        }

        /*
         * Note: Since this out of the lock, it is possible that we are
         * doing extra calls to InitializeDefaultAppDomain().
         * Since InitializeDefaultAppDomain()is just a dummy callback to force the
         * .cctor() of the default appdomain to run, it is save to call
         * InitalizeDefaultAppDomain() more than once
         * (although we will suffer a domain transition performance penalty.)
         */
        if (doInitializeDefaultAppDomain)
        {
            InitializeDefaultAppDomain();
        }
#else  /* defined (_M_CEE_MIXED) */
        InitializeVtables();

        ActivationCtx.DeActivate();
        ActivationCtx.Release();
#endif  /* defined (_M_CEE_MIXED) */

        InitializePerAppDomain();

        CurrentDomain::Initialized = 1;

        InitializeUninitializer();
    }

    // Uninitializes per-appdomain managed globals
    inline static void UninitializeAppDomain()
    {
        _app_exit_callback();
    }

#if defined (_M_CEE_MIXED)
    //static void __cdecl _UninitializeDefaultDomain()
    static HRESULT __stdcall _UninitializeDefaultDomain(void* cookie)
    {
        cookie;
        MANAGED_ASSERT(AppDomain::CurrentDomain->IsDefaultAppDomain(), "This function must be called in the default domain");

        // Uninitialize per-process
        _exit_callback();

        DefaultDomain::InitializedPerProcess = false;

        if(DefaultDomain::InitializedNativeFromCCTOR)
        {
            // Uninitialize native
            _cexit();
            __native_startup_state = __uninitialized;

            DefaultDomain::InitializedNativeFromCCTOR = false;
        }

        DefaultDomain::InitializedNative = false;

        return S_OK;
    }

    static void UninitializeDefaultDomain()
    {
        if (DefaultDomain::NeedsUninitialization())
        {
            if (AppDomain::CurrentDomain->IsDefaultAppDomain())
            {
                _UninitializeDefaultDomain(nullptr);
            }
            else
            {
                DoCallBackInDefaultDomain(&_UninitializeDefaultDomain, nullptr);
            }
        }
    }
#endif  /* defined (_M_CEE_MIXED) */

    // Called when the domain unloads
    // Compare with code in Cleanup
    [System::Runtime::ConstrainedExecution::PrePrepareMethod]
    [System::Runtime::ConstrainedExecution::ReliabilityContract(
        System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState,
        System::Runtime::ConstrainedExecution::Cer::Success)]
    static void DomainUnload(Object^ source, EventArgs^ arguments)
    {
        if (CurrentDomain::Initialized && !Interlocked::Exchange(CurrentDomain::Uninitialized, (int)1))
        {
#if defined (_M_CEE_MIXED)
            bool lastDomain = (Interlocked::Decrement(AllDomains::Count) == 0);
#endif  /* defined (_M_CEE_MIXED) */

            UninitializeAppDomain();

#if defined (_M_CEE_MIXED)
            if (lastDomain)
            {
                UninitializeDefaultDomain();
            }
#endif  /* defined (_M_CEE_MIXED) */
        }
    }

    // Cleans up initialization in the event of an error
    // Compare with code in DomainUnload
    [System::Diagnostics::DebuggerStepThroughAttribute]
    [System::Runtime::ConstrainedExecution::ReliabilityContract(
        System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState,
        System::Runtime::ConstrainedExecution::Cer::Success)]
    void Cleanup(System::Exception^ innerException)
    {
        try
        {
#if defined (_M_CEE_MIXED)
            // If we end up here, DomainUnload will not be called
            bool lastDomain = (Interlocked::Decrement(AllDomains::Count) == 0);
#endif  /* defined (_M_CEE_MIXED) */

            /*
             * Even though the current AppDomain might not be fully initialized,
             * we still want to call whatever that got registered in the on exit
             * list.
             */
            UninitializeAppDomain();

#if defined (_M_CEE_MIXED)
            if (lastDomain)
            {
                UninitializeDefaultDomain();
            }
#endif  /* defined (_M_CEE_MIXED) */
        }
        catch (System::Exception^ exception)
        {
            ThrowNestedModuleLoadException(innerException, exception);
        }
        catch (System::Object^ exception)
        {
            exception;
            ThrowNestedModuleLoadException(innerException, nullptr);
        }
    }

public:
    [System::Diagnostics::DebuggerStepThroughAttribute]
    [System::Runtime::ConstrainedExecution::ReliabilityContract(
        System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState,
        System::Runtime::ConstrainedExecution::Cer::Success)]
    void Initialize()
    {
#if defined (_M_CEE_MIXED)
        bool allDomainsCountIncremented = false;

        // this make sure that AllDomains::Count reflects the actual count no matter what,
        // in line with the ReliabilityContract asserted above
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
#endif  /* defined (_M_CEE_MIXED) */
        try
        {
            ErrorMessage = L"The C++ module failed to load.\n";
#if defined (_M_CEE_MIXED)
            System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();
            try { } finally
            {
                Interlocked::Increment(AllDomains::Count);
                allDomainsCountIncremented = true;
            }
#endif  /* defined (_M_CEE_MIXED) */
            _Initialize();
        }
        catch (System::Exception^ exception)
        {
#if defined (_M_CEE_MIXED)
            if (allDomainsCountIncremented)
#endif  /* defined (_M_CEE_MIXED) */
            {
                Cleanup(exception);
            }
            ThrowModuleLoadException(ErrorMessage, exception);
        }
        catch (System::Object^ exception)
        {
            exception;
#if defined (_M_CEE_MIXED)
            if (allDomainsCountIncremented)
#endif  /* defined (_M_CEE_MIXED) */
            {
                Cleanup(nullptr);
            }
            ThrowModuleLoadException(ErrorMessage, nullptr);
        }
    }

};

} // namespace __identifier("<CrtImplementationDetails>")

/***
* .cctor - This is global constructor for user module.
*
* Purpose:
*       This function is called during appdomain creation. Here is we
*       initialize all the vtables, and native/process/appdomain variables.
*
* Exit:
*
* Entry:
*
*******************************************************************************/
[System::Diagnostics::DebuggerStepThroughAttribute]
void __clrcall __identifier(".cctor")()
{
    using namespace __identifier("<CrtImplementationDetails>");

    LanguageSupport languageSupport;
    languageSupport.Initialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_NEW
#define _INC_NEW

#ifdef __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif  /* _MSC_EXTENSIONS */

#include <crtdefs.h>

/* Protect against #define of new */
#pragma push_macro("new")
#undef  new

#ifndef _USE_OLD_STDCPP
/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined (CRTDLL2)
#define _CRTIMP2 __declspec(dllexport)
#else  /* defined (CRTDLL2) */
#if defined (_DLL) && !defined (_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else  /* defined (_DLL) && !defined (_STATIC_CPPLIB) */
#define _CRTIMP2
#endif  /* defined (_DLL) && !defined (_STATIC_CPPLIB) */
#endif  /* defined (CRTDLL2) */
#endif  /* _CRTIMP2 */
#endif  /* _USE_OLD_STDCPP */

/* Define __cdecl for non-Microsoft compilers */

#if (!defined (_MSC_VER) && !defined (__cdecl))
#define __cdecl
#endif  /* (!defined (_MSC_VER) && !defined (__cdecl)) */

#ifdef _MSC_EXTENSIONS
#ifdef _USE_OLD_STDCPP
typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(_In_opt_ new_handler _NewHandler);
#else  /* _USE_OLD_STDCPP */

namespace std {

#ifdef _M_CEE_PURE
typedef void (__clrcall * new_handler) ();
#else  /* _M_CEE_PURE */
typedef void (__cdecl * new_handler) ();
#endif  /* _M_CEE_PURE */
#ifdef _M_CEE
typedef void (__clrcall * _new_handler_m) ();
#endif  /* _M_CEE */
_CRTIMP2 new_handler __cdecl set_new_handler(_In_opt_ new_handler _NewHandler) throw();
#ifdef _M_CEE_MIXED
extern "C++" _MRTIMP _new_handler_m __cdecl set_new_handler(_In_opt_ _new_handler_m _NewHandler) throw();
extern "C++" _CRTIMP2 new_handler __cdecl set_new_handler(int) throw();
#endif  /* _M_CEE_MIXED */

};

#ifdef _M_CEE
using std::_new_handler_m;
#endif  /* _M_CEE */
using std::new_handler;
using std::set_new_handler;
#endif  /* _USE_OLD_STDCPP */
#endif  /* _MSC_EXTENSIONS */

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
namespace std {
        /* placement new tag type to suppress exceptions */
        struct nothrow_t {};

        /* constant for placement new tag */
        extern const nothrow_t nothrow;
};

_Ret_opt_bytecap_(_Size) void *__CRTDECL operator new(size_t _Size, const std::nothrow_t&) throw();
_Ret_opt_bytecap_(_Size) void *__CRTDECL operator new[](size_t _Size, const std::nothrow_t&) throw();
void __CRTDECL operator delete(void *, const std::nothrow_t&) throw();
void __CRTDECL operator delete[](void *, const std::nothrow_t&) throw();
#endif  /* __NOTHROW_T_DEFINED */

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__CRTDECL operator new(size_t, void *_Where)
        {return (_Where); }
#if _MSC_VER >= 1200
inline void __CRTDECL operator delete(void *, void *)
        {return; }
#endif  /* _MSC_VER >= 1200 */
#endif  /* __PLACEMENT_NEW_INLINE */


/*
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( _In_ int _NewMode);

#ifndef _PNH_DEFINED
#ifdef _M_CEE_PURE
typedef int (__clrcall * _PNH)( size_t );
#else  /* _M_CEE_PURE */
typedef int (__cdecl * _PNH)( size_t );
#endif  /* _M_CEE_PURE */
#define _PNH_DEFINED
#endif  /* _PNH_DEFINED */

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _In_opt_ _PNH _NewHandler);

#if _MSC_VER >= 1400 && defined(_M_CEE)
#ifndef __MPNH_DEFINED
typedef int (__clrcall * __MPNH)( size_t );
#define __MPNH_DEFINED
#endif  /* __MPNH_DEFINED */

_MRTIMP __MPNH __cdecl __query_new_handler_m( void );
#ifdef _M_CEE_MIXED
/* _set_new_handler(int) is used to disambiguate NULL/0 */
_CRTIMP _PNH __cdecl _set_new_handler( _In_ int _NewHandler);
extern "C++" _MRTIMP __MPNH __cdecl _set_new_handler(_In_opt_ __MPNH _NewHandler);
#endif  /* _M_CEE_MIXED */
#endif  /* _MSC_VER >= 1400 && defined(_M_CEE) */

/*
 * Microsoft extension:
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NEW_HANDLER_M  ((_new_handler_m)-1)
#define _NO_ANSI_NH_DEFINED
#endif  /* _NO_ANSI_NH_DEFINED */

#pragma pop_macro("new")

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\msilexit.cpp ===
/***
*msilexit.cpp - Exit routines for mixdll.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file provides at_exit support for clrcall functions. Here you will
*       find implementation for both managed process exit and appdomain exit.
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <internal.h>
#include <windows.h>
#include <malloc.h>
#include <mtdll.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <gcroot.h>

#using <mscorlib.dll>
#if defined (_DEBUG)
#using <system.dll>
#endif  /* defined (_DEBUG) */

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention
#pragma warning(disable:4483)   // disable warning/error about __identifier(<string>)

using System::AppDomain;

#if defined (_DEBUG)
    #define MANAGED_ASSERT( test, message) System::Diagnostics::Debug::Assert(test, message)
#else  /* defined (_DEBUG) */
    #define MANAGED_ASSERT( test, message )
#endif  /* defined (_DEBUG) */

/*
 * match these macros with the ones in onexit.c
 */
#define MAXINCR     512
#define MININCR     4

extern "C" {
    typedef void (__clrcall *_CPVFV)(void);
}

#if defined (_M_CEE_MIXED)
static _CPVFV *__onexitbegin_m  = NULL;
static _CPVFV *__onexitend_m = NULL;
static size_t __exit_list_size = 0;
#endif  /* defined (_M_CEE_MIXED) */

namespace __identifier("<CrtImplementationDetails>")
{
using System::Threading::Monitor;
using System::Object;
using System::Runtime::InteropServices::GCHandle;
using System::IntPtr;

class AtExitLock
{
private:
    _AGLOBAL static void* _lock;
    _AGLOBAL static int _ref_count;

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static GCHandle^ _handle()
    {
        if (_lock != nullptr)
        {
            return GCHandle::FromIntPtr(IntPtr(_lock));
        }

        return nullptr;
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void _lock_Construct()
    {
        _lock = 0;
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void _lock_Construct(Object^ value)
    {
        _lock = 0;
        _lock_Set(value);
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void _lock_Set(Object^ value)
    {
        GCHandle^ handle = _handle();
        if (handle == nullptr)
        {
            handle = GCHandle::Alloc(value);
            _lock = GCHandle::ToIntPtr(*handle).ToPointer();
        }
        else
        {
            handle->Target = value;
        }
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static Object^ _lock_Get()
    {
        GCHandle^ handle = _handle();
        if (handle != nullptr)
        {
            return (Object^)handle->Target;
        }
        return nullptr;
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void _lock_Destruct()
    {
        GCHandle^ handle = _handle();
        if (handle != nullptr)
        {
            handle->Free();
            _lock = 0;
        }
    }

public:
    [System::Diagnostics::DebuggerStepThroughAttribute]
    static bool IsInitialized()
    {
        return (_lock_Get() != nullptr);
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void AddRef()
    {
        if (!IsInitialized())
        {
            _lock_Construct(gcnew Object());
            _ref_count = 0;
        }
        ++_ref_count;
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void RemoveRef()
    {
        MANAGED_ASSERT(_ref_count > 0, "Reference count must be greater than zero");
        if (--_ref_count == 0)
        {
            MANAGED_ASSERT(IsInitialized(), "Lock must be initialized");
            _lock_Destruct();
        }
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void Enter()
    {
        Monitor::Enter(_lock_Get());
    }

    [System::Diagnostics::DebuggerStepThroughAttribute]
    static void Exit()
    {
        Monitor::Exit(_lock_Get());
    }
};
_AGLOBAL void * AtExitLock::_lock; /* Do NOT initialize */
_AGLOBAL int AtExitLock::_ref_count /*= 0*/; /* Do NOT initialize */
}

/***
* __global_lock() - lock access for __global_lock_object
*
* Purpose:
*       This funciton is used by atexit funcitons to avoid parllel
*       access to critical data.
*
* Entry:
*
* Exit:
*       returns true if sucessful.
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
static bool __global_lock()
{
    using namespace __identifier("<CrtImplementationDetails>");

    bool retval = false;
    if (AtExitLock::IsInitialized())
    {
        AtExitLock::Enter();
        retval = true;
    }
    return retval;
}

/***
* __global_unlock() - releases the lock held by calling __global_lock
*
* Purpose:
*       Release the lock held by calling __global_lock.
*
* Entry:
*
* Exit:
*       returns true if sucessful.
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
static bool __global_unlock()
{
    using namespace __identifier("<CrtImplementationDetails>");

    bool retval = false;
    if (AtExitLock::IsInitialized())
    {
        AtExitLock::Exit();
        retval = true;
    }
    return retval;
}

/***
* __alloc_global_lock() - allocates CLR lock for access to lockClass::__global_lock_object
*
* Purpose:
*       This lock object is used by atexit routines to have single threaded
*       access to critical data.
*
* Entry:
*
* Exit:
*       return true if sucessful.
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
static bool __alloc_global_lock()
{
    using namespace __identifier("<CrtImplementationDetails>");

    AtExitLock::AddRef();
    return AtExitLock::IsInitialized();
}

/***
* __dealloc_global_lock() - deallocates the lock used for access to lockClass::__global_lock_object
*
* Purpose:
*       Remove the reference to the lock object
*
* Entry:
*
* Exit:
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
static void __dealloc_global_lock()
{
    using namespace __identifier("<CrtImplementationDetails>");

    AtExitLock::RemoveRef();
}

/***
* _atexit_helper(). registers function to be called during process exit.
*
* Purpose:
*       This function registers __clrcall function to be called at processexit.
*       The callback are in LIFO, i.e. last call registered will be first one
*       to be called at the time of exit.
*
* Entry:
*       _CPVFV,
*       size_t *,
*       _CPVFV **,
*       _CPVFV **;
*
* Exit:
*       return -1 if the the function was not registered. Else returns 0.
*
* Notes:
*       This routine assumes that _initatexit_m was called before this function
*       is called.
*
*******************************************************************************/

extern "C" int __clrcall _atexit_helper( _CPVFV func,
        size_t *__pexit_list_size,
        _CPVFV **__ponexitend_e,
        _CPVFV **__ponexitbegin_e)
{
    _CPVFV retval = NULL;

    /*
     * Get the lock for CRT exit function calls.
     */
    if (func == NULL) return -1;
    if (__global_lock() == true) {
        try {
            _CPVFV * __onexitbegin = (_CPVFV *) _decode_pointer(*__ponexitbegin_e);
            _CPVFV * __onexitend = (_CPVFV *) _decode_pointer(*__ponexitend_e);

            /*
             * check if we have space of one more entry.
             */
            if ( (*__pexit_list_size) - 1<
                    ((size_t)((char *)__onexitend - (char *)__onexitbegin))/sizeof(_CPVFV))
            {
                /*
                 * Try to increment by max increment or twice the current size, if fails,
                 * then try to increment by min increment. If that too fails then return NULL.
                 */
                try {
                    System::IntPtr tmp_ptr =
                        System::Runtime::InteropServices::Marshal::ReAllocHGlobal(
                            System::IntPtr(__onexitbegin),
                            System::IntPtr((long)((*__pexit_list_size)*sizeof(_CPVFV)+
                                __min((*__pexit_list_size)*sizeof(_CPVFV),
                                    (MAXINCR*sizeof(_CPVFV))))));

                    __onexitend = (_CPVFV *)((char *)tmp_ptr.ToPointer()+
                            (size_t)__onexitend-
                            (size_t)__onexitbegin);
                    __onexitbegin = (_CPVFV *)tmp_ptr.ToPointer();
                    (*__pexit_list_size) += __min(MAXINCR, (*__pexit_list_size));

                } catch (System::OutOfMemoryException ^) {

                    System::IntPtr tmp_ptr =
                        System::Runtime::InteropServices::Marshal::ReAllocHGlobal(
                            System::IntPtr(__onexitbegin),
                            System::IntPtr((long)((*__pexit_list_size)*sizeof(_CPVFV)+
                                MININCR+sizeof(_CPVFV))));

                    __onexitend = (_CPVFV *)((char *)tmp_ptr.ToPointer()+
                            (size_t)__onexitend-
                            (size_t)__onexitbegin);
                    __onexitbegin = (_CPVFV *)tmp_ptr.ToPointer();
                    (*__pexit_list_size) += MININCR;
                }
            }
            *(__onexitend++) = (_CPVFV)func;
            retval = func;

            (*__ponexitbegin_e) = (_CPVFV *) _encode_pointer(__onexitbegin);
            (*__ponexitend_e) = (_CPVFV *) _encode_pointer(__onexitend);

        } catch(System::OutOfMemoryException ^) {
        } __finally{
            __global_unlock();
        }
    }
    return retval==NULL?-1:0;
}

#if defined (_M_CEE_MIXED)
/***
* _exit_callback() - this function is called by msvcrt at exit.
*
* Purpose:
*       This function is called from msvcrt dll at process exit. This
*       functio then calls all the registered __clrcall function. This
*       function acts as layer between __cdecl atexit callback and __clrcal
*       atexit callback.
*
* Entry:
*
* Exit:
*
*******************************************************************************/

extern "C" void __clrcall _exit_callback(void)
{
    MANAGED_ASSERT(AppDomain::CurrentDomain->IsDefaultAppDomain(), "This function must be called in the default domain");
    /*
     * Note: this function is not supposed to be called from more then one
     * thread at a time. Infact this is called when the program is terminating
     * or the dll is being unloaded.
     *
     * Thus we don't need to lock anything here.
     */

    /*
     * Note that this function is called during appdomain unload.
     * Thus there should be only one thread calling this function per
     * appdomain. Thus this function does not need to be under lock.
     *
     * Note: verify that when domainUnload event is generated, there
     * are no threads executing in this appdomain. If this is not the
     * case then we will need to have lock around this function.
     */

    if (__exit_list_size == 0)
    {
        /*
         * _initatexit_m() hasn't been called yet
         * Nothing to do
         */
        return;
    }

    _CPVFV * onexitbegin_m = (_CPVFV *) _decode_pointer(__onexitbegin_m);
    _CPVFV * onexitend_m = (_CPVFV *) _decode_pointer(__onexitend_m);

    if ((onexitbegin_m != (_CPVFV *)-1) && (onexitbegin_m != NULL) && (onexitend_m != NULL)) {
        _CPVFV function_to_call_m = NULL;

        /* save the start and end for later comparison */
        _CPVFV * onexitbegin_m_saved = onexitbegin_m;
        _CPVFV * onexitend_m_saved = onexitend_m;

        while (1)
        {
            _CPVFV * onexitbegin_m_new = NULL;
            _CPVFV * onexitend_m_new = NULL;

            /* find the last valid function pointer to call. */
            while (--onexitend_m >= onexitbegin_m && *onexitend_m == _encoded_null())
            {
                /* keep going backwards. */
            }

            if (onexitend_m < onexitbegin_m)
            {
                /* there are no more valid entries in the list, we are done. */
                break;
            }

            /* cache the function to call. */
            function_to_call_m = (_CPVFV)_decode_pointer(*onexitend_m);

            /* mark the function pointer as visited. */
            *onexitend_m = (_CPVFV)_encoded_null();

            /* call the function, which can eventually change __onexitbegin_m and __obexitend_m */
            (*function_to_call_m)();

            /* save the start and end for later comparison */
            onexitbegin_m_new = (_CPVFV *) _decode_pointer(__onexitbegin_m);
            onexitend_m_new = (_CPVFV *) _decode_pointer(__onexitend_m);

            if ( ( onexitbegin_m_saved != onexitbegin_m_new ) || ( onexitend_m_saved != onexitend_m_new ) )
            {
                /* reset only if either start or end has changed */
                onexitbegin_m = onexitbegin_m_saved = onexitbegin_m_new;
                onexitend_m = onexitend_m_saved = onexitend_m_new;
            }
        }
        /*
         * There is no real need to free memory here as the process is anyway
         * going down and CRT will free it's heap and this memory will anyway
         * be freed. But just so that user doesn't see the memory leak if he
         * wants to detect leak using CRT functionality, we free this memory.
         */
        System::Runtime::InteropServices::Marshal::FreeHGlobal(
                System::IntPtr((void *)onexitbegin_m));
    }
    __dealloc_global_lock();
}


/***
*_initatexit_m(). Initializes the managed process exit variables.
*
* Purpose:
*       The _initatexit_m function is called from cctor of mixdll. This function
*       is responsible for initializing managed process exit variables. The
*       initialization includes allocating memory.
*
* Entry:
*
* Exit:
*       1 if initialization was sucessful 0 otherwise.
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
extern "C" int __clrcall _initatexit_m()
{
    MANAGED_ASSERT(AppDomain::CurrentDomain->IsDefaultAppDomain(), "This function must be called in the default domain");

    int retval = 0;

    /*
     * Note: This function is called only once just during cctor call.
     */
    if (__alloc_global_lock() == true) {
        System::IntPtr tmp_int_ptr =
            System::Runtime::InteropServices::Marshal::AllocHGlobal(
                    32*sizeof(*__onexitbegin_m));

        __onexitend_m = __onexitbegin_m = (_CPVFV *)_encode_pointer(tmp_int_ptr.ToPointer());
        __exit_list_size = 32;
        retval = 1;
    }
    return retval;
}

/***
* _atexit_m(_CPVFV). registers function to be called during process exit.
*
* Purpose:
*       This function registers __clrcall function to be called at processexit.
*       The callback are in LIFO, i.e. last call registered will be first one
*       to be called at the time of exit.
*
* Entry:
*       void (__clrcall *func)(void);
*
* Exit:
*       return -1 if the the function was not registered. Else returns 0.
*
* Notes:
*       This routine assumes that _initatexit_m was called before this function
*       is called.
*
*******************************************************************************/

extern "C" _onexit_m_t __clrcall _onexit_m( _onexit_m_t _Function)
{
    MANAGED_ASSERT(AppDomain::CurrentDomain->IsDefaultAppDomain(), "This function must be called in the default domain");

    return _atexit_m((_CPVFV)_Function) == -1 ? NULL : _Function;
}

extern "C" int __clrcall _atexit_m( _CPVFV func)
{
    MANAGED_ASSERT(AppDomain::CurrentDomain->IsDefaultAppDomain(), "This function must be called in the default domain");

    int retval = _atexit_helper((_CPVFV)_encode_pointer(func), &__exit_list_size, &__onexitend_m, &__onexitbegin_m);

    return retval;

}
#endif  /* defined (_M_CEE_MIXED) */

/***
*
* AppDomain Exit stuff.
*
*******************************************************************************/

/*
 * Note that the initialization values are commented out.
 * The reason here is that these variables are appdomain specific. And if
 * we try to initialize them, unlike process variables, they will be
 * dynamically initialized. This means they will be initialized by our
 * initialization routine BUT we need to initialize them before we run
 * our initialization code.
 *
 * Not initializating them here is also OK just because we can always
 * intialize them in _initatexit_app_domain function
 */

_AGLOBAL _CPVFV *__onexitbegin_app_domain /*= NULL*/;
_AGLOBAL _CPVFV *__onexitend_app_domain /*= NULL*/;
_AGLOBAL size_t __exit_list_size_app_domain /*= 0*/;


/***
*_initatexit_app_domain(). Initializes the managed per appdomain exit variables.
*
* Purpose:
*       The _initatexit_app_domain function is called from cctor of mixdll. This
*       function is responsible for initializing managed per appdomain exit
*       variables. The initialization includes allocating memory.
*
* Entry:
*
* Exit:
*       1 if initialization was sucessful 0 otherwise.
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
extern "C" int __clrcall _initatexit_app_domain()
{
    if (__alloc_global_lock() == true) {
        /*
         * Note that this function is called from the cctor during the
         * appdomain initialization. Thus there is going to be only one thread
         * per process accessing this function.
         *
         * Thus this function does not need to be under the lock.
         */

        System::IntPtr tmp_int_ptr =
            System::Runtime::InteropServices::Marshal::AllocHGlobal(
                    32*sizeof(*__onexitbegin_app_domain));

        __onexitend_app_domain = __onexitbegin_app_domain = (_CPVFV *)_encode_pointer(tmp_int_ptr.ToPointer());
        __exit_list_size_app_domain = 32;
#if defined (_M_CEE_PURE)
        extern void __clrcall __clean_type_info_names();

        _atexit_m_appdomain(__clean_type_info_names);
#endif  /* defined (_M_CEE_PURE) */
    }
    return 1;
}

/***
* _app_exit_callback() - this function is called by cctor during appdomain exit.
*
* Purpose:
*       This function is called from cctor during appdomain exit. This
*       function then calls all the registered __clrcall function. This
*       function acts as appdomain version of _exit_callback.
*
* Entry:
*
* Exit:
*
*******************************************************************************/

extern "C" void __clrcall _app_exit_callback(void)
{
    /*
     * Note that this function is called during appdomain unload.
     * Thus there should be only one thread calling this function per
     * appdomain. Thus this function does not need to be under lock.
     *
     * Note: verify that when domainUnload event is generated, there
     * are no threads executing in this appdomain. If this is not the
     * case then we will need to have lock around this function.
     */

    if (__exit_list_size_app_domain == 0 )
    {
        /*
         * _initatexit_appdomain() hasn't been called yet
         * Nothing to do
         */
        return;
    }

    _CPVFV * onexitbegin_app_domain = (_CPVFV *) _decode_pointer(__onexitbegin_app_domain);
    _CPVFV * onexitend_app_domain = (_CPVFV *) _decode_pointer(__onexitend_app_domain);

    __try
    {
        if ((onexitbegin_app_domain != (_CPVFV *)-1) && (onexitbegin_app_domain != NULL) && (onexitend_app_domain != NULL)) {
            _CPVFV function_to_call_app_domain = NULL;

            _CPVFV * onexitbegin_app_domain_saved = onexitbegin_app_domain;
            _CPVFV * onexitend_app_domain_saved = onexitend_app_domain;

            while (1)
            {
                _CPVFV * onexitbegin_app_domain_new = NULL;
                _CPVFV * onexitend_app_domain_new = NULL;

                /* find the last valid function pointer to call. */
                while (--onexitend_app_domain >= onexitbegin_app_domain && *onexitend_app_domain == _encoded_null())
                {
                    /* keep going backwards. */
                }

                if (onexitend_app_domain < onexitbegin_app_domain)
                {
                    /* there are no more valid entries in the list, we are done. */
                    break;
                }

                /* cache the function to call. */
                function_to_call_app_domain = (_CPVFV)_decode_pointer(*onexitend_app_domain);

                /* mark the function pointer as visited. */
                *onexitend_app_domain = (_CPVFV)_encoded_null();

                /* call the function, which can eventually change __onexitbegin_app_domain and __obexitend_m */
                (*function_to_call_app_domain)();

                onexitbegin_app_domain_new = (_CPVFV *) _decode_pointer(__onexitbegin_app_domain);
                onexitend_app_domain_new = (_CPVFV *) _decode_pointer(__onexitend_app_domain);

                if ( ( onexitbegin_app_domain_saved != onexitbegin_app_domain_new ) ||
                     ( onexitend_app_domain_saved != onexitend_app_domain_new ) )
                {
                    onexitbegin_app_domain = onexitbegin_app_domain_saved = onexitbegin_app_domain_new;
                    onexitend_app_domain = onexitend_app_domain_saved = onexitend_app_domain_new;
                }
            }
        }
    }
    __finally
    {
        System::Runtime::InteropServices::Marshal::FreeHGlobal(
            System::IntPtr((void *)onexitbegin_app_domain));
        __dealloc_global_lock();
    }
}

/***
* _atexit_app_domain(_CPVFV). registers function to be called during appdomain exit.
*
* Purpose:
*       This function registers __clrcall function to be called at appdomain exit.
*       The callback are in LIFO, i.e. last call registered will be first one
*       to be called at the time of exit. This is appdomain version of _atexit_m()
*
* Entry:
*       void (__clrcall *func)(void);
*
* Exit:
*       return -1 if the the function was not registered. Else returns 0.
*
* Notes:
*       This routine assumes that _initatexit_app_domain was called before this
*       function is called.
*
*******************************************************************************/

extern "C" _onexit_m_t __clrcall _onexit_m_appdomain(_onexit_m_t _Function)
{
    return _atexit_m_appdomain((_CPVFV)_Function) == -1 ? NULL : _Function;
}

[System::Diagnostics::DebuggerStepThroughAttribute]
_Check_return_ extern "C" int __clrcall _atexit_m_appdomain(_CPVFV func)
{
    int retval = _atexit_helper((_CPVFV)_encode_pointer(func), &__exit_list_size_app_domain, &__onexitend_app_domain, &__onexitbegin_app_domain);

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\new2.cpp ===
/***
*new2.cpp - defines C++ new routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ new routine.
*
*******************************************************************************/


#include <cruntime.h>
#include <malloc.h>
#include <new.h>
#include <stdlib.h>
#ifdef WINHEAP
#include <winheap.h>
#include <rtcsup.h>
#else  /* WINHEAP */
#include <heap.h>
#endif  /* WINHEAP */

void *__CRTDECL operator new(size_t) /*_THROW1(std::bad_alloc)*/;

void * operator new[]( size_t cb )
{
    void *res = operator new(cb);

    RTCCALLBACK(_RTC_Allocate_hook, (res, cb, 0));

    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mterrno.c ===
/***
*mterrno.c - provide function versions of errno & _doserrno for LIBC.LIB
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sometimes users want to compile code (such as for use in a library)
*       for both single-thread and multi-thread applications.  Currently the
*       one major stumbling block to doing this is the fact that errno &
*       _doserrno are defined in different ways in LIBC.LIB and LIBCMT.LIB.
*       Code that should otherwise be usable with both LIBC.LIB and LIBCMT.LIB
*       but which accesses errno and/or _doserrno is not usable with both.
*       By providing the function versions of errno & _doserrno in LIBC.LIB,
*       users can compile their code for both LIBCMT.LIB and LIBC.LIB.
*       Note that this does not magically make single-thread code safe in a
*       multi-threaded environment, it merely makes it easier to use the
*       same code with LIBC.LIB and LIBCMT.LIB.
*
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newaop_s.cpp ===
/***
*newaop_s.cpp - version of newaop.cpp for DLL library
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Version of newaop.cpp for DLL library
*
*******************************************************************************/

#undef	CRTDLL2

#include "newaop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\mwcrtexew.cpp ===
/***
*crtexew.c - Initialization for Windows EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps.  It calls the
*       user's main routine WinMain() after performing C Run-Time Library
*       initialization.
*
*******************************************************************************/

#ifdef MRTDLL

#define _WINMAIN_
#include "mwcrtexe.cpp"

#endif  /* MRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ncommode.c ===
/***
*ncommode.c - set global file commit mode flag to nocommit
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to nocommit.  This is the default.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>

/* set default file commit mode to nocommit */
int _commode = 0;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\muser.cpp ===
/***
*muser.cpp - user handlers for managed scenarios
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Handling functions only called by the client programs,
*       not by the C/C++ runtime itself.
*
*******************************************************************************/

#include <stddef.h>
#include <windows.h>
#include <mtdll.h>
#include <stdlib.h>
#include <eh.h>
#include <internal.h>
#include <crtdbg.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention
#pragma warning(disable:4483)   // disable warning/error about __identifier(<string>)

// Global for storing the __clrcall invalid parameter handler
volatile __declspec(appdomain) _invalid_parameter_handler_m __pParameter_m = (_invalid_parameter_handler_m) _encoded_null();

/***
*__invalid_parameter_handler_thunk
*
*Purpose:
*       This function is a __cdecl function that is called by the
*       CRT when an invalid parameter is encountered. It , in turn, calls
*       the __clrcall handler registered by the user.
*
*******************************************************************************/
void __cdecl __invalid_parameter_handler_thunk(
    const wchar_t* pszExpression,
    const wchar_t* pszFunction,
    const wchar_t* pszFile,
    unsigned int nLine,
    uintptr_t pReserved
)
{
    // Put the value in a local variable to avoid MT synchronization
    // problems using the global.
    _invalid_parameter_handler_m function = (_invalid_parameter_handler_m) _decode_pointer(__pParameter_m);

    if (function)
    {
        function(pszExpression, pszFunction, pszFile, nLine, pReserved);
    }
}

static void __clrcall __invalid_parameter_handler_cleanup(void)
{
    _invalid_parameter_handler handler=_get_invalid_parameter_handler();
    if(handler==__invalid_parameter_handler_thunk && __pParameter_m!=NULL)
    {
        _set_invalid_parameter_handler((_invalid_parameter_handler)NULL);
    }
    __pParameter_m=NULL;
}

/***
*_set_invalid_parameter_handler
*
*Purpose:
*       Overload of _set_invalid_parameter_handler to be used when caller
*       wants to register a __clrcall invalid parameter handler.
*
*******************************************************************************/
_MRTIMP _invalid_parameter_handler_m __cdecl
_set_invalid_parameter_handler( _invalid_parameter_handler_m pNew )
{
    if(_atexit_m_appdomain(__invalid_parameter_handler_cleanup)!=0)
    {
        return NULL;
    }

    _invalid_parameter_handler_m pOld = (_invalid_parameter_handler_m) _decode_pointer(__pParameter_m);

    _set_invalid_parameter_handler(pNew != NULL ? __invalid_parameter_handler_thunk : static_cast<_invalid_parameter_handler>(NULL));

    __pParameter_m = (_invalid_parameter_handler_m) _encode_pointer(pNew);

    return pOld;
}

namespace __identifier("<CrtImplementationDetails>")
{

class Handlers
{
public:
        [System::ThreadStaticAttribute] __declspec(appdomain) static __terminate_function_m __pTerminate_m;
        [System::ThreadStaticAttribute] __declspec(appdomain) static __unexpected_function_m __pUnexpected_m;
        [System::ThreadStaticAttribute] __declspec(appdomain) static _purecall_handler_m __pPurecall_m;
};

__declspec(appdomain) __terminate_function_m Handlers::__pTerminate_m = (__terminate_function_m) _encoded_null();
__declspec(appdomain) __unexpected_function_m Handlers::__pUnexpected_m = (__unexpected_function_m) _encoded_null();
__declspec(appdomain) _purecall_handler_m Handlers::__pPurecall_m = (_purecall_handler_m) _encoded_null();
}

using namespace __identifier("<CrtImplementationDetails>");

#pragma warning(disable:4535)
/***
*__terminate_thunk - calls __clrcall terminate handler
*
*Purpose:
*       Act as a thunk between __cdecl terminate handler and __clrcall
*       terminate handler.
*
*******************************************************************************/
void __cdecl __terminate_thunk()
{
        __terminate_function_m function= (__terminate_function_m) _decode_pointer(Handlers::__pTerminate_m);
    if (function)
    {
        (*Handlers::__pTerminate_m)();
    }
}

static void __clrcall __terminate_cleanup()
{
    terminate_function handler=_get_terminate();
    __terminate_function_m enull = (__terminate_function_m) _encoded_null();
    if(handler==__terminate_thunk && Handlers::__pTerminate_m!=enull)
    {
        set_terminate((terminate_function)NULL);
    }
    Handlers::__pTerminate_m=enull;
}


/***
*__set_terminate_m - sets __clrcall terminate handler
*
*Purpose:
*       Call the appropriate new handler.
*
*Entry:
*       None
*
*Return:
*
*******************************************************************************/
_MRTIMP __terminate_function_m __cdecl
set_terminate( __terminate_function_m pNew )
{
    if(_atexit_m_appdomain(__terminate_cleanup)!=0)
    {
        return NULL;
    }

    __terminate_function_m pOld = (__terminate_function_m) _encoded_null();

#if defined (_DEBUG)
#pragma warning(push)
#pragma warning(disable:4191)

    if ( (pNew != NULL) )

#pragma warning(pop)
#endif  /* defined (_DEBUG) */
    {
        pOld = (__terminate_function_m) _decode_pointer(Handlers::__pTerminate_m);
        Handlers::__pTerminate_m = (__terminate_function_m) _encode_pointer(pNew);
        set_terminate(pNew==NULL ? (terminate_function)NULL : __terminate_thunk);
    }

    return pOld;
}

/***
*__purecall_thunk - calls __clrcall purecall handler
*
*Purpose:
*       Act as a thunk between __cdecl purecall handler and __clrcall
*       purecall handler.
*
*******************************************************************************/
static void __cdecl __purecall_thunk()
{
    _purecall_handler_m handler= (_purecall_handler_m) _decode_pointer(Handlers::__pPurecall_m);

    if (handler)
    {
        (*handler)();
    }
}

static void __clrcall __purecall_cleanup()
{
    _purecall_handler handler=_get_purecall_handler();
    _purecall_handler_m enull = (_purecall_handler_m) _encoded_null();
    if(handler==__purecall_thunk && Handlers::__pPurecall_m!=enull)
    {
        _set_purecall_handler((_purecall_handler)NULL);
    }
    Handlers::__pPurecall_m= enull;
}

/***
*_set_purecall_handler_m - sets __clrcall purecall handler
*
*Purpose:
*       set the appropriate purecall handler.
*
*Entry:
*       None
*
*Return:
*
*******************************************************************************/
_MRTIMP _purecall_handler_m __cdecl
_set_purecall_handler( _purecall_handler_m pNew )
{
    if(_atexit_m_appdomain(__purecall_cleanup)!=0)
    {
        return NULL;
    }

    _purecall_handler_m pOld = (_purecall_handler_m) _encoded_null();

#if defined (_DEBUG)
#pragma warning(push)
#pragma warning(disable:4191)

    if ( (pNew != NULL) )

#pragma warning(pop)
#endif  /* defined (_DEBUG) */
    {
        pOld = (_purecall_handler_m) _decode_pointer(Handlers::__pPurecall_m);
        Handlers::__pPurecall_m = (_purecall_handler_m) _encode_pointer(pNew);
        _set_purecall_handler(pNew==NULL ? (_purecall_handler)NULL : __purecall_thunk);
    }

    return pOld;
}


/***
*__unexpected_thunk - calls __clrcall terminate handler
*
*Purpose:
*       Act as a thunk between __cdecl terminate handler and __clrcall
*       terminate handler.
*
*******************************************************************************/
void __cdecl __unexpected_thunk()
{
    __unexpected_function_m function= (__unexpected_function_m) _decode_pointer(Handlers::__pUnexpected_m);
    if (function)
    {
        (*function)();
    }
}

static void __clrcall __unexpected_cleanup()
{
    unexpected_function handler=_get_unexpected();
    __unexpected_function_m enull = (__unexpected_function_m) _encoded_null();
    if(handler==__unexpected_thunk && Handlers::__pUnexpected_m!=NULL)
    {
        set_unexpected((unexpected_function)NULL);
    }
    Handlers::__pUnexpected_m=enull;
}

/***
*__set_unexpected_m - sets __clrcall terminate handler
*
*Purpose:
*       __clrcall version of set_unexpected
*
*Entry:
*       None
*
*Return:
*       Previous registered Handler.
*
*******************************************************************************/
_MRTIMP __unexpected_function_m __cdecl
set_unexpected( __unexpected_function_m pNew )
{
    if(_atexit_m_appdomain(__unexpected_cleanup)!=0)
    {
        return NULL;
    }

    __unexpected_function_m pOld = (__unexpected_function_m) _encoded_null();

#if defined (_DEBUG)
#pragma warning(push)
#pragma warning(disable:4191)

    if ( (pNew != NULL) )

#pragma warning(pop)
#endif  /* defined (_DEBUG) */
    {
        pOld = (__unexpected_function_m) _decode_pointer(Handlers::__pUnexpected_m);
        Handlers::__pUnexpected_m = (__unexpected_function_m) _encode_pointer(pNew);
        set_unexpected(pNew==NULL ? (unexpected_function)NULL : __unexpected_thunk);
    }

    return pOld;
}

/***
*_set_invalid_parameter_handler
*
*Purpose:
*       Overload of _set_invalid_parameter_handler to be used when caller
*       wants to pass NULL or 0.
*
*******************************************************************************/
_MRTIMP _invalid_parameter_handler __cdecl
_set_invalid_parameter_handler( int pNew )
{
    _VALIDATE_RETURN(pNew == NULL, EINVAL, NULL);

    return _set_invalid_parameter_handler(static_cast<_invalid_parameter_handler>(0));
}

/***
*void _set_purecall_handler(void) -
*
*Purpose:
*       Establish a handler to be called when a pure virtual is called
*       Note that if you link to the crt statically, and replace
*       _purecall, then none of this will happen.
*
*       This function is not thread-safe
*
*Entry:
*       New handler
*
*Exit:
*       Old handler
*
*Exceptions:
*
*******************************************************************************/

_MRTIMP _purecall_handler __cdecl
_set_purecall_handler( int pNew )
{
    _VALIDATE_RETURN(pNew == NULL, EINVAL, NULL);

    return _set_purecall_handler(static_cast<_purecall_handler>(NULL));
}


using namespace System::Reflection;

[assembly: AssemblyTitle("msvcm90")];
[assembly: AssemblyDescription("Microsoft Visual C++ Managed Runtime 9.0")];
[assembly: AssemblyConfiguration("")];
[assembly: AssemblyCompany("Microsoft")];
[assembly: AssemblyProduct("Visual Studio 9.0")];
[assembly: AssemblyCopyright("Microsoft Corporation")];
[assembly: AssemblyTrademark("")];
[assembly: AssemblyCulture("")];

[assembly: AssemblyVersion(_CRT_ASSEMBLY_VERSION)];

[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyName("")];
// the AssemblyKeyFile is added in the linking phase
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newmode.c ===
/***
*newmode.c - set new() handler mode to handle malloc failures
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global flag which controls whether the new() handler
*       is called on malloc failures.  The default behavior in Visual
*       C++ v2.0 and later is not to, that malloc failures return NULL
*       without calling the new handler.  Linking with this object changes
*       the start-up behavior to call the new handler on malloc failures.
*
*******************************************************************************/


#include <internal.h>

/* enable new handler calls upon malloc failures */

int _newmode = 1;       /* Malloc New Handler MODE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newop.cpp ===
// newop operator new(size_t) for Microsoft C++
#include <cstdlib>
#include <new>

_C_LIB_DECL
int __cdecl _callnewh(size_t count) _THROW1(_STD bad_alloc);
_END_C_LIB_DECL

void *__CRTDECL operator new(size_t count) _THROW1(_STD bad_alloc)
	{	// try to allocate size bytes
	void *p;
	while ((p = malloc(count)) == 0)
		if (_callnewh(count) == 0)
			{	// report no memory
			static const std::bad_alloc nomem;
			_RAISE(nomem);
			}
	return (p);
	}

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newop_s.cpp ===
/***
*newop_s.cpp - version of newop.cpp for DLL library
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Version of newop.cpp for DLL library
*
*******************************************************************************/

#undef	CRTDLL2

#include "newop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nlsdata2.c ===
/***
*nlsdata2.c - globals for international library - locale handles and code page
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module defines the locale handles and code page.  The handles are
*       required by almost all locale dependent functions.  This module is
*       separated from nlsdatax.c for granularity.
*
*******************************************************************************/

#include <locale.h>
#include <setlocal.h>
#include <mbctype.h>

char __clocalestr[] = "C";
extern struct __lc_time_data __lc_time_c;       /* defined in strftime.c */

/*
 * initial locale information struct, set to the C locale. Used only until the
 * first call to setlocale()
 */
threadlocinfo __initiallocinfo = {
    1,                                        /* refcount                 */
    _CLOCALECP,                               /* lc_codepage              */
    _CLOCALECP,                               /* lc_collate_cp            */
    {   _CLOCALEHANDLE,                       /* lc_handle[_ALL]          */
        _CLOCALEHANDLE,                       /* lc_handle[_COLLATE]      */
        _CLOCALEHANDLE,                       /* lc_handle[_CTYPE]        */
        _CLOCALEHANDLE,                       /* lc_handle[_MONETARY]     */
        _CLOCALEHANDLE,                       /* lc_handle[_NUMERIC]      */
        _CLOCALEHANDLE                        /* lc_handle[_TIME]         */
    },
    {   {0, 0, 0},                            /* lc_id[LC_ALL]            */
        {0, 0, 0},                            /* lc_id[LC_COLLATE]        */
        {0, 0, 0},                            /* lc_id[LC_CTYPE]          */
        {0, 0, 0},                            /* lc_id[LC_MONETARY]       */
        {0, 0, 0},                            /* lc_id[LC_NUMERIC]        */
        {0, 0, 0}                             /* lc_id[LC_TIME]           */
    },
    {   {NULL, NULL, NULL, NULL},             /* lc_category[LC_ALL]      */
        {__clocalestr, NULL, NULL, NULL},     /* lc_category[LC_COLLATE]  */
        {__clocalestr, NULL, NULL, NULL},     /* lc_category[LC_CTYPE]    */
        {__clocalestr, NULL, NULL, NULL},     /* lc_category[LC_MONETARY] */
        {__clocalestr, NULL, NULL, NULL},     /* lc_category[LC_NUMERIC]  */
        {__clocalestr, NULL, NULL, NULL}      /* lc_category[LC_TIME]     */
    },
    1,                                        /* lc_clike                 */
    1,                                        /* mb_cur_max               */
    NULL,                                     /* lconv_intl_refcount      */
    NULL,                                     /* lconv_num_refcount       */
    NULL,                                     /* lconv_mon_refcount       */
    &__lconv_c,                               /* lconv                    */
    NULL,                                     /* ctype1_refcount          */
    NULL,                                     /* ctype1                   */
    __newctype + 128,                         /* pctype                   */
    __newclmap + 128,                         /* pclmap                   */
    __newcumap + 128,                         /* pcumap                   */
    &__lc_time_c,                             /* lc_time_curr             */
};

/*
 * global pointer to the current per-thread locale information structure.
 */
pthreadlocinfo __ptlocinfo = &__initiallocinfo;

/*
 *  Locale handles.
 */
LCID __lc_handle[] =
    {   _CLOCALEHANDLE,                       /* lc_handle[_ALL]          */
        _CLOCALEHANDLE,                       /* lc_handle[_COLLATE]      */
        _CLOCALEHANDLE,                       /* lc_handle[_CTYPE]        */
        _CLOCALEHANDLE,                       /* lc_handle[_MONETARY]     */
        _CLOCALEHANDLE,                       /* lc_handle[_NUMERIC]      */
        _CLOCALEHANDLE                        /* lc_handle[_TIME]         */
    };

/*
 *  Code page.
 */
UINT __lc_codepage = _CLOCALECP;                /* CP_ACP */

/*
 * Code page for LC_COLLATE
 */
UINT __lc_collate_cp = _CLOCALECP;

/* if this locale has first 127 character set same as CLOCALE.
 */
int __lc_clike = 1;

_locale_tstruct __initiallocalestructinfo =
{
    &__initiallocinfo,
    &__initialmbcinfo
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nlsdata3.c ===
/***
*nlsdata3.c - globals for international library - locale id's
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the definition of locale id's.  These id's and
*       this file should only be visible to the _init_(locale category)
*       functions.  This module is separated from nlsdatax.c for granularity.
*
*******************************************************************************/

#include <locale.h>
#include <setlocal.h>

/*
 *  Locale id's.
 */
LC_ID __lc_id[LC_MAX-LC_MIN+1] = {
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 },
        { 0, 0, 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\new.cpp ===
/***
*new.cxx - defines C++ new routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ new routine.
*
*******************************************************************************/


#ifdef _SYSCRT
#include <cruntime.h>
#include <crtdbg.h>
#include <malloc.h>
#include <new.h>
#include <stdlib.h>
#include <winheap.h>
#include <rtcsup.h>
#include <internal.h>

void * operator new( size_t cb )
{
    void *res;

    for (;;) {

        //  allocate memory block
        res = _heap_alloc(cb);

        //  if successful allocation, return pointer to memory

        if (res)
            break;

        //  call installed new handler
        if (!_callnewh(cb))
            break;

        //  new handler was successful -- try to allocate again
    }

    RTCCALLBACK(_RTC_Allocate_hook, (res, cb, 0));

    return res;
}
#else  /* _SYSCRT */

#include <cstdlib>
#include <new>

_C_LIB_DECL
int __cdecl _callnewh(size_t size) _THROW1(_STD bad_alloc);
_END_C_LIB_DECL

void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)
        {       // try to allocate size bytes
        void *p;
        while ((p = malloc(size)) == 0)
                if (_callnewh(size) == 0)
                {       // report no memory
                static const std::bad_alloc nomem;
                _RAISE(nomem);
                }

        return (p);
        }

/*
 * Copyright (c) 1992-2002 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.13:0009 */
#endif  /* _SYSCRT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nlsint.h ===
/***
*nlsint.h - national language support internal defintions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains internal definitions/declarations for international functions,
*       shared between run-time and math libraries, in particular,
*       the localized decimal point.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_NLSINT
#define _INC_NLSINT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#if !defined (_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else  /* !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 */
#define _W64
#endif  /* !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 */
#endif  /* !defined (_W64) */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef _W64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_NLSINT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newaop.cpp ===
// newaop -- operator new[](size_t) REPLACEABLE
#include <new>

 #if !_VC6SP2 || _DLL
void *__CRTDECL operator new[](size_t count) _THROW1(std::bad_alloc)
	{	// try to allocate count bytes for an array
	return (operator new(count));
	}
 #endif /* !_VC6SP2 || _DLL */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\noarg.c ===
/***
*noarg.c - stub out CRT's processing of command line arguments
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Stub out the processing of the command line into argv[], normally
*       carried out at during startup. Note, the argc and argv arguments to
*       main are not meaningful if this object is used. Nor are __argc and
*       __argv.
*
*******************************************************************************/

#include <tchar.h>

#ifdef _M_CEE_PURE
#define _CALLING __clrcall
#else  /* _M_CEE_PURE */
#define _CALLING __cdecl
#endif  /* _M_CEE_PURE */

int _CALLING _setargv() { return 0; }

int _CALLING _wsetargv() { return 0; }

_TUCHAR * _CALLING _wincmdln() { return NULL; }

_TUCHAR * _CALLING _wwincmdln() { return NULL; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newaopnt.cpp ===
// newaopnt -- operator new[](size_t, const nothrow_t&) REPLACEABLE
#ifdef CRTDLL
#undef CRTDLL
#endif

#ifdef MRTDLL
#undef MRTDLL
#endif

#define _USE_ANSI_CPP // suppress defaultlib directive for Std C++ Lib
#include <new>
void * __CRTDECL operator new[](::size_t count, const std::nothrow_t& x)
	_THROW0()
	{	// try to allocate count bytes for an array
	return (operator new(count, x));
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nochkclr.c ===
/***
* nochkclr.c - Dummy non-version-checking CLR call
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef _M_IX86

/***
*_check_commonlanguageruntime_version
*
*Purpose:
*       If you don't link to the CRT, you use this obj to fill the compiler's need for this symbol
*
*Entry:
*       Never.
*
*Exit:
*       None
*
*Exceptions:
*       None.
*
*******************************************************************************/

void _check_commonlanguageruntime_version()
{
}

#endif  /* _M_IX86 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\newopnt.cpp ===
// newopnt operator new(size_t, const nothrow_t&) for Microsoft C++
#ifdef CRTDLL
#undef CRTDLL
#endif

#ifdef MRTDLL
#undef MRTDLL
#endif

#define _USE_ANSI_CPP // suppress defaultlib directive for Std C++ Lib
#include <new>

void * __CRTDECL operator new(size_t count, const std::nothrow_t&)
	_THROW0()
	{	// try to allocate count bytes
	void *p;
	_TRY_BEGIN
	p = operator new(count);
	_CATCH_ALL
	p = 0;
	_CATCH_END
	return (p);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\noenv.c ===
/***
*noenv.c - stub out CRT's environment string processing
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Stub out the environment string processing normally carried out at
*       during startup. Note, getenv, _putenv and _environ are not supported
*       if this object is used. Nor is the third argument to main.
*
*******************************************************************************/

#include <stdlib.h>


#ifdef _M_CEE_PURE
#define _CALLING __clrcall
#else  /* _M_CEE_PURE */
#define _CALLING __cdecl
#endif  /* _M_CEE_PURE */

int _CALLING _setenvp(void) { return 0; }

void * _CALLING __crtGetEnvironmentStringsA(void) { return NULL; }

int _CALLING _wsetenvp(void) { return 0; }

void * _CALLING __crtGetEnvironmentStringsW(void) { return NULL; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\new_mode.cpp ===
/***
*newmode.cxx - defines C++ setHandler mode
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines routines to set and to query the C++ new handler mode.
*
*       The new handler mode flag determines whether malloc() failures will
*       call the new() failure handler, or whether malloc will return NULL.
*
*******************************************************************************/

#include <cruntime.h>
#include <new.h>
#include <internal.h>

int __cdecl _set_new_mode( int nhm )
{
    int nhmOld;

    /* validation section */
    _VALIDATE_RETURN(nhm == 0 || nhm == 1, EINVAL, -1);

    /*
     * Set the new mode and return the old
     */
    nhmOld = _newmode;
    _newmode = nhm;

    return nhmOld;
}

int __cdecl _query_new_mode ( void )
{
    return _newmode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nlsdata1.c ===
/***
*nlsdata1.c - globals for international library - small globals
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the globals:  __mb_cur_max, _decimal_point,
*       _decimal_point_length.  This module is always required.
*       This module is separated from nlsdatax.c for granularity.
*
*******************************************************************************/

#include <stdlib.h>
#include <nlsint.h>

/*
 *  Value of MB_CUR_MAX macro.
 */
int __mb_cur_max = 1;

/*
 *  Localized decimal point string.
 */
char __decimal_point[] = ".";

/*
 *  Decimal point length, not including terminating null.
 */
size_t __decimal_point_length = 1;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nomemoryh.cpp ===
// nomemory -- report out of memory
#include <new>
_STD_BEGIN

_CRTIMP void __cdecl _Nomemory()
        {       // report out of memory
        static const _XSTD bad_alloc nomem;
        _RAISE(nomem);
        }
_STD_END

/*
 * Copyright (c) 1992-2002 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.13:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nothrownew.cpp ===
/***
*new.cxx - defines C++ new routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ new routine.
*
*******************************************************************************/


#include <cruntime.h>
#include <crtdbg.h>
#include <malloc.h>
#include <new.h>
#include <stdlib.h>
#include <winheap.h>
#include <rtcsup.h>
#include <internal.h>

void * operator new( size_t cb )
{
    void *res;

    for (;;) {

        //  allocate memory block
        res = malloc(cb);

        //  if successful allocation, return pointer to memory

        if (res)
            break;

        //  call installed new handler
        if (!_callnewh(cb))
            break;

        //  new handler was successful -- try to allocate again
    }

    RTCCALLBACK(_RTC_Allocate_hook, (res, cb, 0));

    return res;
}

void * operator new[]( size_t cb )
{
    void *res = operator new(cb);

    RTCCALLBACK(_RTC_Allocate_hook, (res, cb, 0));

    return res;
}

/* debug operator new and new[] which do not throw */
void * operator new( size_t cb, int nBlockUse, const char * szFileName, int nLine)
{
    (nBlockUse);
    (szFileName);
    (nLine);
    return operator new(cb);
}

void * operator new[]( size_t cb, int nBlockUse, const char * szFileName, int nLine)
{
    (nBlockUse);
    (szFileName);
    (nLine);
    return operator new[](cb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\openo.cpp ===
/***
*openo.cpp - C++ Version of open which takes a default pmode parameter
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/


#include <io.h>
#include <share.h>
#include <internal.h>

_CRTIMP int __cdecl _open(const char * path, int oflag, int pmode /* = 0 */)
{
    int fh;
    /* Last parameter passed as 0 because we don't want to validate pmode from _open */
    errno_t e = _sopen_helper(path, oflag, _SH_DENYNO, pmode, &fh, 0);
    return e ? -1 : fh;
}

_CRTIMP int __cdecl _sopen(const char * path, int oflag, int shflag, int pmode /* = 0 */)
{
    int fh;
    /* Last parameter passed as 0 because we don't want to validate pmode from _sopen */
    errno_t e = _sopen_helper(path, oflag, shflag, pmode, &fh, 0);
    return e ? -1 : fh;
}

_CRTIMP int __cdecl _wopen(const wchar_t * path, int oflag, int pmode /* = 0 */)
{
    int fh;
    /* Last parameter passed as 0 because we don't want to validate pmode from _wopen */
    errno_t e = _wsopen_helper(path, oflag, _SH_DENYNO, pmode, &fh, 0);
    return e ? -1 : fh;
}

_CRTIMP int __cdecl _wsopen(const wchar_t * path, int oflag, int shflag, int pmode /* = 0 */)
{
    int fh;
    /* Last parameter passed as 0 because we don't want to validate pmode from _wsopen */
    errno_t e = _wsopen_helper(path, oflag, shflag, pmode, &fh, 0);
    return e ? -1 : fh;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\oscalls.h ===
/***
*oscalls.h - contains declarations of Operating System types and constants.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares types and constants that are defined by the target OS.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_OSCALLS
#define _INC_OSCALLS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef _WIN32

#ifdef NULL
#undef  NULL
#endif  /* NULL */

#if defined (_DEBUG) && defined (_WIN32)

void DbgBreakPoint(void);
int DbgPrint(_In_z_ __format_string char *_Format, ...);

#endif  /* defined (_DEBUG) && defined (_WIN32) */

#define NOMINMAX

#define _WIN32_FUSION 0x0100
#include <windows.h>

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

/* File time and date types */

typedef struct _FTIME {         /* ftime */
    unsigned short twosecs : 5;
    unsigned short minutes : 6;
    unsigned short hours   : 5;
} FTIME;
typedef FTIME   *PFTIME;

typedef struct _FDATE {         /* fdate */
    unsigned short day     : 5;
    unsigned short month   : 4;
    unsigned short year    : 7;
} FDATE;
typedef FDATE   *PFDATE;

#else  /* _WIN32 */


#error ERROR - ONLY WIN32 OR POSIX TARGETS SUPPORTED!


#endif  /* _WIN32 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_OSCALLS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nothrow.cpp ===
// nothrow -- define nothrow object
#ifdef MRTDLL
#undef MRTDLL
#endif

#include <new>
#include <yvals.h>
_STD_BEGIN

const nothrow_t nothrow = nothrow_t();	// define nothrow
_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nomemory.cpp ===
// nomemory -- report out of memory
#include <new>
#include <yvals.h>
_STD_BEGIN

_MRTIMP2 void __cdecl _Nomemory()
	{	// report out of memory
	static const _XSTD bad_alloc nomem;
	_RAISE(nomem);
	}
_STD_END

/*
 * Copyright (c) 1992-2002 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.13:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nmmintrin.h ===
/**
*** Copyright (C) 1985-2007 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * nmmintrin.h
 *
 * Principal header file for Intel(R) Core(TM) 2 Duo processor
 * SSE4.2 intrinsics.
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_NMM
#define _INCLUDED_NMM

#if defined (_M_CEE_PURE)
        #error ERROR: EMM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <smmintrin.h>


#if __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * These defines are used to determine the kind of units to be compared
 */
#define SIDD_UBYTE_OPS                0x00
#define SIDD_UWORD_OPS                0x01
#define SIDD_SBYTE_OPS                0x02
#define SIDD_SWORD_OPS                0x03


/*
 * These defines are used to determine the comparison operation
 */
#define SIDD_CMP_EQUAL_ANY            0x00
#define SIDD_CMP_RANGES               0x04
#define SIDD_CMP_EQUAL_EACH           0x08
#define SIDD_CMP_EQUAL_ORDERED        0x0C


/*
 * These defines are used to determine the polarity
 */
#define SIDD_POSITIVE_POLARITY        0x00
#define SIDD_NEGATIVE_POLARITY        0x10
#define SIDD_MASKED_POSITIVE_POLARITY 0x20
#define SIDD_MASKED_NEGATIVE_POLARITY 0x30


/*
 * These defines are used in _mm_cmpXstri()
 */
#define SIDD_LEAST_SIGNIFICANT        0x00
#define SIDD_MOST_SIGNIFICANT         0x40

/*
 * These defines are used _mm_cmpXstrm()
 */
#define SIDD_BIT_MASK                 0x00
#define SIDD_UNIT_MASK                0x40


/*
 * Intrinsics for text/string processing.
 */

    extern __m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistri (__m128i a, __m128i b, const int mode);

    extern __m128i _mm_cmpestrm (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestri (__m128i a, int la, __m128i b, int lb, const int mode);

/*
 * Intrinsics for text/string processing and reading values of EFlags.
 */

    extern int     _mm_cmpistrz (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistrc (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistrs (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistro (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistra (__m128i a, __m128i b, const int mode);

    extern int     _mm_cmpestrz (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestrc (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestrs (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestro (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestra (__m128i a, int la, __m128i b, int lb, const int mode);

/*
 * Packed integer 64-bit comparison, zeroing or filling with ones
 * corresponding parts of result
 */

    extern __m128i _mm_cmpgt_epi64(__m128i val1, __m128i val2);

/*
 * Calculate a number of bits set to 1
 */

    extern int _mm_popcnt_u32(unsigned int v);

#if defined (_M_X64)
    extern __int64 _mm_popcnt_u64(unsigned __int64 v);
#endif  /* defined (_M_X64) */

/*
 * Accumulate CRC32 (polynomial 0x11EDC6F41) value
 */

    extern unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v);
    extern unsigned int _mm_crc32_u16(unsigned int crc, unsigned short v);
    extern unsigned int _mm_crc32_u32(unsigned int crc, unsigned int v);

#if defined (_M_X64)
    extern unsigned __int64 _mm_crc32_u64(unsigned __int64 crc, unsigned __int64 v);
#endif  /* defined (_M_X64) */

#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INCLUDED_NMM */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nmktobat.c ===
/***
*NMKtoBAT.C - convert NMAKE.EXE output into a Windows 9x batch file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The makefiles provided with the Microsoft Visual C++ (C/C++) Run-Time
*	Library Sources generate commands with multiple commands per line,
*	separated by ampersands (&).  This program will convert such a
*	text file into a batch file which can be executed by the Windows 9x
*	command interpreter (COMMAND.COM) which does not recognize multiple
*	commands on a single line.
*
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(int argc, char **argv);


#define MAXLINE	4096

char InBuf [ MAXLINE ] ;


int main(int argc, char **argv)
{
	/*
	 * If any arguments are given, print a usage message and exit
	 */

	if ( argc != 1 || argv [ 1 ] )
	{
		fprintf ( stderr , "Usage: nmk2bat < input > output\n"
			"This program takes no arguments\n" ) ;
		exit ( 1 ) ;
	}

	/*
	 * Batch file should be terse
	 */

	printf ( "@echo off\n" ) ;

	/*
	 * Process each input line
	 */

	while ( fgets ( InBuf , sizeof ( InBuf ) , stdin ) )
	{
		char * pStart ;
		char * pFinish ;
		char * pNextPart ;

		pStart = InBuf ;
	
		pFinish = pStart + strlen ( pStart ) ;

		/*
		 * Remove the trailing newline character from the
		 * input buffer.  This simplifies the line processing.
		 */

		if ( pFinish > pStart && pFinish [ -1 ] == '\n' )
			pFinish [ -1 ] = '\0' ;

		/*
		 * Process each part of the line.  Parts are delimited
		 * by ampersand characters with optional whitespace.
		 */

		do
		{
			/*
			 * Skip initial whitespace
			 */

			while ( * pStart == ' ' || * pStart == '\t' )
				++ pStart ;

			/*
			 * Find the next command separator or
			 * the end of line, whichever comes first
			 */

			pNextPart = strchr ( pStart , '&' ) ;

			if ( ! pNextPart )
				pNextPart = pStart + strlen ( pStart ) ;
		
			pFinish = pNextPart ;

			/*
			 * Skip blank lines and blank parts of lines
			 */

			if ( pStart == pNextPart )
				break ;
			/*
			 * Skip the trailing whitespace
			 */

			while ( pFinish > pStart
			&& ( pFinish [ -1 ] == ' ' || pFinish [ -1 ] == '\t' ) )
				-- pFinish ;

			/*
			 * Copy to stdout the characters between
			 * the skipped initial whitespace and
			 * the skipped trailing whitespace
			 */

			while ( pStart < pFinish )
				putchar ( * pStart ++ ) ;

			putchar ( '\n' ) ;

			/*
			 * We are done with this line when pNextPart
			 * points to a null character (rather than a '&').
			 */

			pStart = pNextPart ;

		} while ( * pStart ++ ) ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\outputp.c ===
/***
*outputp.c - Positional version of printf & the printf family
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This has format validations & positional parameters as compared to printf
*
*******************************************************************************/


#define POSITIONAL_PARAMETERS 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\outputs.c ===
/***
*outputs.c - Secure version of printf & the printf family
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This has format validations & positional parameters as compared to printf
*
*******************************************************************************/


#define FORMAT_VALIDATIONS 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\onexit.c ===
/***
*onexit.c - save function for execution on exit
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _onexit(), atexit() - save function for execution at exit
*
*       In order to save space, the table is allocated via malloc/realloc,
*       and only consumes as much space as needed.  __onexittable is
*       set to point to the table if onexit() is ever called.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <mtdll.h>
#include <stdlib.h>
#include <internal.h>
#include <malloc.h>
#include <rterr.h>
#include <windows.h>
#include <dbgint.h>


int __cdecl __onexitinit(void);

#ifdef _MSC_VER

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __onexitinit;

#endif  /* _MSC_VER */

/*
 * Define pointers to beginning and end of the table of function pointers
 * manipulated by _onexit()/atexit().
 * NOTE - the pointers are stored encoded.
 */
extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;

/*
 * Define increments (in entries) for growing the _onexit/atexit table
 */
#define MININCR     4
#define MAXINCR     512

static _onexit_t __cdecl _onexit_nolock(_onexit_t);
static _onexit_t __cdecl _dllonexit_nolock(_onexit_t, _PVFV **, _PVFV **);

/***
*_onexit(func), atexit(func) - add function to be executed upon exit
*
*Purpose:
*       The _onexit/atexit functions are passed a pointer to a function
*       to be called when the program terminate normally.  Successive
*       calls create a register of functions that are executed last in,
*       first out.
*
*Entry:
*       void (*func)() - pointer to function to be executed upon exit
*
*Exit:
*       onexit:
*           Success - return pointer to user's function.
*           Error - return NULL pointer.
*       atexit:
*           Success - return 0.
*           Error - return non-zero value.
*
*Notes:
*       This routine depends on the behavior of _initterm() in CRT0DAT.C.
*       Specifically, _initterm() must not skip the address pointed to by
*       its first parameter, and must also stop before the address pointed
*       to by its second parameter.  This is because _onexitbegin will point
*       to a valid address, and _onexitend will point at an invalid address.
*
*Exceptions:
*
*******************************************************************************/

_onexit_t __cdecl _onexit (
        _onexit_t func
        )
{
        _onexit_t retval;

        _lockexit();

        __try {
            retval = _onexit_nolock(func);
        }
        __finally {
            _unlockexit();
        }

        return retval;
}


static _onexit_t __cdecl _onexit_nolock (
        _onexit_t func
        )
{
        _PVFV * p;
        size_t  oldsize;
        _PVFV * onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin);
        _PVFV * onexitend = (_PVFV *)_decode_pointer(__onexitend);

        /* overflow check */
        if (onexitend < onexitbegin ||
            ((char *)onexitend - (char *)onexitbegin) + sizeof(_PVFV) < sizeof(_PVFV))
        {
            return NULL;
        }

        /*
         * First, make sure the table has room for a new entry
         */
        if ( (oldsize = _msize_crt(onexitbegin))
                < ((size_t)((char *)onexitend -
            (char *)onexitbegin) + sizeof(_PVFV)) )
        {
            /*
             * not enough room, try to grow the table. first, try to double it.
             */
            size_t newsize = oldsize + __min(oldsize, (MAXINCR * sizeof(_PVFV)));
            if ( newsize < oldsize ||
                 (p = (_PVFV *)_realloc_crt(onexitbegin, newsize)) == NULL )
            {
                /*
                 * failed, try to grow by MININCR
                 */
                newsize = oldsize + MININCR * sizeof(_PVFV);
                if ( newsize < oldsize ||
                     (p = (_PVFV *)_realloc_crt(onexitbegin, newsize)) == NULL )
                    /*
                     * failed again. don't do anything rash, just fail
                     */
                    return NULL;
            }

            /*
             * update __onexitend and __onexitbegin
             */
#pragma warning(suppress: 22008) /* prefast is confused */
            onexitend = p + (onexitend - onexitbegin);
            onexitbegin = p;
            __onexitbegin = (_PVFV *)_encode_pointer(onexitbegin);
        }

        /*
         * Put the new entry into the table and update the end-of-table
         * pointer.
         */
         *(onexitend++) = (_PVFV)_encode_pointer(func);
        __onexitend = (_PVFV *)_encode_pointer(onexitend);

        return func;
}

int __cdecl atexit (
        _PVFV func
        )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}


/***
* void __onexitinit(void) - initialization routine for the function table
*       used by _onexit() and atexit().
*
*Purpose:
*       Allocate the table with room for 32 entries (minimum required by
*       ANSI). Also, initialize the pointers to the beginning and end of
*       the table.
*
*Entry:
*       None.
*
*Exit:
*       Returns _RT_ONEXIT if the table cannot be allocated.
*
*Notes:
*       This routine depends on the behavior of doexit() in CRT0DAT.C.
*       Specifically, doexit() must not skip the address pointed to by
*       __onexitbegin, and it must also stop before the address pointed
*       to by __onexitend.  This is because _onexitbegin will point
*       to a valid address, and _onexitend will point at an invalid address.
*
*       Since the table of onexit routines is built in forward order, it
*       must be traversed by doexit() in CRT0DAT.C in reverse order.  This
*       is because these routines must be called in last-in, first-out order.
*
*       If __onexitbegin == __onexitend, then the onexit table is empty!
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __onexitinit (
        void
        )
{
        _PVFV * onexitbegin;

        onexitbegin = (_PVFV *)_calloc_crt(32, sizeof(_PVFV));
        __onexitend = __onexitbegin = (_PVFV *)_encode_pointer(onexitbegin);

        if ( onexitbegin == NULL )
            /*
             * cannot allocate minimal required size. return
             * fatal runtime error.
             */
            return _RT_ONEXIT;

        *onexitbegin = (_PVFV) NULL;

        return 0;
}


#ifdef CRTDLL

/***
*__dllonexit(func, pbegin, pend) - add function to be executed upon DLL detach
*
*Purpose:
*       The _onexit/atexit functions in a DLL linked with MSVCRT.LIB
*       must maintain their own atexit/_onexit list.  This routine is
*       the worker that gets called by such DLLs.  It is analogous to
*       the regular _onexit above except that the __onexitbegin and
*       __onexitend variables are not global variables visible to this
*       routine but rather must be passed as parameters.
*
*Entry:
*       void (*func)() - pointer to function to be executed upon exit
*       void (***pbegin)() - pointer to variable pointing to the beginning
*                   of list of functions to execute on detach
*       void (***pend)() - pointer to variable pointing to the end of list
*                   of functions to execute on detach
*
*Exit:
*       Success - return pointer to user's function.
*       Error - return NULL pointer.
*
*Notes:
*       This routine depends on the behavior of _initterm() in CRT0DAT.C.
*       Specifically, _initterm() must not skip the address pointed to by
*       its first parameter, and must also stop before the address pointed
*       to by its second parameter.  This is because *pbegin will point
*       to a valid address, and *pend will point at an invalid address.
*
*       Note also that we do not decode/encode *pbegin/*pend.  That should
*       be done in the caller, which will be the onexit in atexit.c.
*
*Exceptions:
*
*******************************************************************************/

_onexit_t __cdecl __dllonexit (
        _onexit_t func,
        _PVFV ** pbegin,
        _PVFV ** pend
        )
{
        _onexit_t retval;

        _lockexit();

        __try {
            retval = _dllonexit_nolock(func, pbegin, pend);
        }
        __finally {
            _unlockexit();
        }

        return retval;
}

static _onexit_t __cdecl _dllonexit_nolock (
        _onexit_t func,
        _PVFV ** pbegin,
        _PVFV ** pend
        )
{
        _PVFV   *p=NULL;
        size_t oldsize;

        /*
         * First, make sure the table has room for a new entry
         */
        if ( (oldsize = _msize_crt(*pbegin)) <= (size_t)((char *)(*pend) -
            (char *)(*pbegin)) )
        {
            /*
             * not enough room, try to grow the table
             */
            size_t grow=__min(oldsize, MAXINCR * sizeof(_PVFV));
            if((_HEAP_MAXREQ-grow<oldsize) ||
                ((p = (_PVFV *)_realloc_crt((*pbegin), oldsize + grow)) == NULL))
            {
                /*
                 * failed, try to grow by ONEXITTBLINCR
                 */
                grow=MININCR * sizeof(_PVFV);
                if ( (_HEAP_MAXREQ-grow<oldsize) ||
                    ((p = (_PVFV *)_realloc_crt((*pbegin), oldsize + grow)) == NULL ))
                {
                    /*
                     * failed again. don't do anything rash, just fail
                     */
                    return NULL;
                }
            }

            /*
             * update (*pend) and (*pbegin)
             */
            (*pend) = p + ((*pend) - (*pbegin));
            (*pbegin) = p;
        }

        /*
         * Put the new entry into the table and update the end-of-table
         * pointer.
         */
         *((*pend)++) = (_PVFV)func;

        return func;

}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\pesect.c ===
/***
*pesect.c - PE image header routines
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines routines that query info from a PE image header.  Because
*       one of these queries the current PE image, via the linker-defined
*       variable __ImageBase, this object must be a static-link component
*       of any C Runtime library.
*
*******************************************************************************/

#include <windows.h>

#if defined (_WIN64) && defined (_M_IA64)
#pragma section(".base", long, read)
__declspec(allocate(".base"))
extern IMAGE_DOS_HEADER __ImageBase;
#else  /* defined (_WIN64) && defined (_M_IA64) */
extern IMAGE_DOS_HEADER __ImageBase;
#endif  /* defined (_WIN64) && defined (_M_IA64) */

#pragma optimize("t", on)   // optimize for speed, not space

/***
*BOOL _ValidateImageBase
*
*Purpose:
*       Check if a PE image is located at a potential image base address.
*
*Entry:
*       pImageBase - pointer to potential PE image in memory
*
*Return:
*       TRUE    PE image validated at pImageBase
*       FALSE   PE image not found
*
*******************************************************************************/

BOOL __cdecl _ValidateImageBase(
    PBYTE pImageBase
    )
{
    PIMAGE_DOS_HEADER      pDOSHeader;
    PIMAGE_NT_HEADERS      pNTHeader;
    PIMAGE_OPTIONAL_HEADER pOptHeader;

    pDOSHeader = (PIMAGE_DOS_HEADER)pImageBase;
    if (pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        return FALSE;
    }

    pNTHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDOSHeader + pDOSHeader->e_lfanew);
    if (pNTHeader->Signature != IMAGE_NT_SIGNATURE)
    {
        return FALSE;
    }

    pOptHeader = (PIMAGE_OPTIONAL_HEADER)&pNTHeader->OptionalHeader;
    if (pOptHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)
    {
        return FALSE;
    }

    return TRUE;
}

/***
*PIMAGE_SECTION_HEADER _FindPESection
*
*Purpose:
*       Given an RVA (Relative Virtual Address, the offset from the Image Base
*       for a PE image), determine which PE section, if any, includes that RVA.
*
*Entry:
*       pImageBase - pointer to PE image in memory
*       rva - RVA whose enclosing section is to be found
*
*Return:
*       NULL     RVA is not part by any section in the PE image
*       non-NULL Pointer to IMAGE_SECTION_HEADER describing the section holding
*                the RVA
*
*******************************************************************************/

PIMAGE_SECTION_HEADER __cdecl _FindPESection(
    PBYTE     pImageBase,
    DWORD_PTR rva
    )
{
    PIMAGE_NT_HEADERS     pNTHeader;
    PIMAGE_SECTION_HEADER pSection;
    unsigned int          iSection;

    pNTHeader =
        (PIMAGE_NT_HEADERS)
            (pImageBase + ((PIMAGE_DOS_HEADER)pImageBase)->e_lfanew);

    //
    // Find the section holding the desired address.  We make no assumptions
    // here about the sort order of the section descriptors (though they
    // always appear to be sorted by ascending section RVA).
    //
    for (iSection = 0, pSection = IMAGE_FIRST_SECTION(pNTHeader);
         iSection < pNTHeader->FileHeader.NumberOfSections;
         ++iSection, ++pSection)
    {
        if (rva >= pSection->VirtualAddress &&
            rva <  pSection->VirtualAddress + pSection->Misc.VirtualSize)
        {
            //
            // Section found
            //
            return pSection;
        }
    }

    //
    // Section not found
    //
    return NULL;
}

/***
*BOOL _IsNonwritableInCurrentImage
*
*Purpose:
*       Check if an address is located within the current PE image (the one
*       starting at __ImageBase), that it is in a proper section of the image,
*       and that section is not marked writable.  This routine must be
*       statically linked, not imported from the CRT DLL, so the correct
*       __ImageBase is found.
*
*Entry:
*       pTarget - address to check
*
*Return:
*       0        Address is either not in current image, not in a section, or
*                in a writable section.
*       non-0    Address is in a non-writable section of the current image.
*
*******************************************************************************/

BOOL __cdecl _IsNonwritableInCurrentImage(
    PBYTE pTarget
    )
{
    PBYTE                 pImageBase;
    DWORD_PTR             rvaTarget;
    PIMAGE_SECTION_HEADER pSection;

    pImageBase = (PBYTE)&__ImageBase;

    __try {
        //
        // Make sure __ImageBase does address a PE image.  This is likely an
        // unnecessary check, since we should be running from a normal image,
        // but it is fast, this routine is rarely called, and the normal call
        // is for security purposes.  If we don't have a PE image, return
        // failure.
        //
        if (!_ValidateImageBase(pImageBase))
        {
            return FALSE;
        }

        //
        // Convert the targetaddress to a Relative Virtual Address (RVA) within
        // the image, and find the corresponding PE section.  Return failure if
        // the target address is not found within the current image.
        //
        rvaTarget = pTarget - pImageBase;
        pSection = _FindPESection(pImageBase, rvaTarget);
        if (pSection == NULL)
        {
            return FALSE;
        }

        //
        // Check the section characteristics to see if the target address is
        // located within a writable section, returning a failure if yes.
        //
        return (pSection->Characteristics & IMAGE_SCN_MEM_WRITE) == 0;
    }
    __except (GetExceptionCode() == STATUS_ACCESS_VIOLATION)
    {
        //
        // Just return failure if the PE image is corrupted in any way that
        // triggers an AV.
        //
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\nothrow0.cpp ===
/***
*nothrow0.cpp - defines object std::nothrow_t for placement new
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*       Derived from code Copyright (c) 1992-2001 by P.J. Plauger.
*
*Purpose:
*       Defines the object std::nothrow which can be used as a placement
*       new tag to call the form of operator new which is guaranteed to
*       return NULL on an allocation failure instead of raising an
*       exception of std::bad_alloc.
*
*******************************************************************************/

#ifdef CRTDLL
#undef CRTDLL
#endif  /* CRTDLL */

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <new.h>

namespace std {

    const nothrow_t nothrow = nothrow_t();

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\pipe.c ===
/***
*pipe.c - create a pipe
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _pipe() - creates a pipe (i.e., an I/O channel for interprocess
*                         communication)
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <io.h>
#include <internal.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <fcntl.h>

/***
*int _pipe(phandles, psize, textmode) - open a pipe
*
*Purpose:
*       Checks if the given handle is associated with a character device
*       (terminal, console, printer, serial port)
*
*       Multi-thread notes: No locking is performed or deemed necessary. The
*       handles returned by DOSCREATEPIPE are newly opened and, therefore,
*       should not be referenced by any thread until after the _pipe call is
*       complete. The function is not protected from some thread of the caller
*       doing, say, output to a previously invalid handle that becomes one of
*       the pipe handles. However, any such program is doomed anyway and
*       protecting the _pipe function such a case would be of little value.
*
*Entry:
*       int phandle[2] - array to hold returned read (phandle[0]) and write
*                        (phandle[1]) handles
*
*       unsigned psize - amount of memory, in bytes, to ask o.s. to reserve
*                        for the pipe
*
*       int textmode   - _O_TEXT, _O_BINARY, _O_NOINHERIT, or 0 (use default)
*
*Exit:
*       returns 0 if successful
*       returns -1 if an error occurs in which case, errno is set to:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _pipe (
        int phandles[2],
        unsigned psize,
        int textmode
        )
{
        ULONG dosretval;                    /* o.s. return value */
        int handle0, handle1;
        int toomanyfiles = 0;

        HANDLE ReadHandle, WriteHandle;
        SECURITY_ATTRIBUTES SecurityAttributes;

        _VALIDATE_CLEAR_OSSERR_RETURN( (phandles != NULL), EINVAL, -1 );
        phandles[0] = phandles[1] = -1;

        _VALIDATE_CLEAR_OSSERR_RETURN(((textmode & ~(_O_NOINHERIT | _O_BINARY | _O_TEXT)) == 0), EINVAL, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((textmode & (_O_BINARY | _O_TEXT)) != (_O_BINARY | _O_TEXT), EINVAL, -1);

        SecurityAttributes.nLength = sizeof(SecurityAttributes);
        SecurityAttributes.lpSecurityDescriptor = NULL;

        if (textmode & _O_NOINHERIT) {
            SecurityAttributes.bInheritHandle = FALSE;
        }
        else {
            SecurityAttributes.bInheritHandle = TRUE;
        }

        if (!CreatePipe(&ReadHandle, &WriteHandle, &SecurityAttributes, psize)) {
            /* o.s. error */
            dosretval = GetLastError();
            _dosmaperr(dosretval);
            return -1;
        }

        /* now we must allocate C Runtime handles for Read and Write handles */

        if ((handle0 = _alloc_osfhnd()) != -1) {

            __try {

            _osfile(handle0) = (char)(FOPEN | FPIPE | FTEXT);
            _textmode(handle0) = 0;
            _tm_unicode(handle0) = 0;

            }
            __finally {
                _unlock_fh( handle0 );
            }

            if ((handle1 = _alloc_osfhnd()) != -1) {
                int fmode = 0;
                __try {

                _osfile(handle1) = (char)(FOPEN | FPIPE | FTEXT);
                _textmode(handle1) = 0;
                _tm_unicode(handle1) = 0;

                }
                __finally {
                    if ( handle1 != -1 )
                        _unlock_fh( handle1 );
                }

                _ERRCHECK(_get_fmode(&fmode));
                if ( (textmode & _O_BINARY) ||
                     (((textmode & _O_TEXT) == 0) &&
                      (fmode == _O_BINARY)) ) {
                    /* binary mode */
                    _osfile(handle0) &= ~FTEXT;
                    _osfile(handle1) &= ~FTEXT;
                }

                if ( textmode & _O_NOINHERIT ) {
                    _osfile(handle0) |= FNOINHERIT;
                    _osfile(handle1) |= FNOINHERIT;
                }

                _set_osfhnd(handle0, (intptr_t)ReadHandle);
                _set_osfhnd(handle1, (intptr_t)WriteHandle);
            }
            else {
                _osfile(handle0) = 0;
                toomanyfiles = 1;
            }
        }
        else {
            toomanyfiles = 1;
        }

        /* If error occurred, close Win32 handles and return -1 */
        if (toomanyfiles) {
            errno = EMFILE;
            CloseHandle(ReadHandle);
            CloseHandle(WriteHandle);
            _doserrno = 0;      /* not an o.s. error */
            return -1;
        }

        phandles[0] = handle0;
        phandles[1] = handle1;

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\pmmintrin.h ===
/**
***
*** Copyright (C) 1985-2005 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part except as expressly provided
*** by the accompanying LICENSE AGREEMENT
***
*** cvs_id[] = "$Id: pmmintrin.h,v 1.5 2005/01/03 22:55:01 hhle Exp $";
***
**/
/*
 * pmmintrin.h
 *
 * Principal header file for Intel(R) Pentium(R) 4 processor SSE3 intrinsics
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_PMM
#define _INCLUDED_PMM

#if defined (_M_CEE_PURE)
        #error ERROR: EMM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

/*
 * We need xmmintrin.h, emmintrin.h for the basic type declarations.
 */
#include <xmmintrin.h>
#include <emmintrin.h>

/*****************************************************/
/*     MACROS FOR USE WITH INTRINSICS                */
/*****************************************************/

/*
 * MACRO functions for setting and reading the DAZ bit in the MXCSR
 */
#define _MM_DENORMALS_ZERO_MASK   0x0040
#define _MM_DENORMALS_ZERO_ON     0x0040
#define _MM_DENORMALS_ZERO_OFF    0x0000

#define _MM_SET_DENORMALS_ZERO_MODE(mode)                                   \
            _mm_setcsr((_mm_getcsr() & ~_MM_DENORMALS_ZERO_MASK) | (mode))
#define _MM_GET_DENORMALS_ZERO_MODE()                                       \
            (_mm_getcsr() & _MM_DENORMALS_ZERO_MASK)


/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif  /* defined __cplusplus */

/*
 * New Single precision vector instructions.
 */

extern __m128 _mm_addsub_ps(__m128 a, __m128 b);
extern __m128 _mm_hadd_ps(__m128 a, __m128 b);
extern __m128 _mm_hsub_ps(__m128 a, __m128 b);
extern __m128 _mm_movehdup_ps(__m128 a);
extern __m128 _mm_moveldup_ps(__m128 a);

/*
 * New double precision vector instructions.
 */

extern __m128d _mm_addsub_pd(__m128d a, __m128d b);
extern __m128d _mm_hadd_pd(__m128d a, __m128d b);
extern __m128d _mm_hsub_pd(__m128d a, __m128d b);
extern __m128d _mm_loaddup_pd(double const * dp);
extern __m128d _mm_movedup_pd(__m128d a);

/*
 * New unaligned integer vector load instruction.
 */
extern __m128i _mm_lddqu_si128(__m128i const *p);

/*
 * Miscellaneous new instructions.
 */
/*
 * For _mm_monitor p goes in eax, extensions goes in ecx, hints goes in edx.
 */
extern void _mm_monitor(void const *p, unsigned extensions, unsigned hints);

/*
 * For _mm_mwait, extensions goes in ecx, hints goes in eax.
 */
extern void _mm_mwait(unsigned extensions, unsigned hints);

#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INCLUDED_PMM */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\open.c ===
/***
*open.c - file open
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _open() and _sopen() - open or create a file
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <oscalls.h>
#include <msdos.h>
#include <errno.h>
#include <fcntl.h>
#include <internal.h>
#include <io.h>
#include <share.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <mtdll.h>
#include <stdarg.h>
#include <tchar.h>

#define UTF16LE_BOM     0xFEFF      /* UTF16 Little Endian Byte Order Mark */
#define UTF16BE_BOM     0xFFFE      /* UTF16 Big Endian Byte Order Mark */
#define BOM_MASK                0xFFFF      /* Mask for testing Byte Order Mark */
#define UTF8_BOM        0xBFBBEF    /* UTF8 Byte Order Mark */
#define UTF16_BOMLEN    2           /* No of Bytes in a UTF16 BOM */
#define UTF8_BOMLEN     3           /* No of Bytes in a UTF8 BOM */

static errno_t __cdecl _tsopen_nolock ( int *,
                                int *,
                                const _TSCHAR *,
                                int,
                                int,
                                int,
                                int );

/***
*int _open(path, flag, pmode) - open or create a file
*
*Purpose:
*       Opens the file and prepares for subsequent reading or writing.
*       the flag argument specifies how to open the file:
*         _O_APPEND -   reposition file ptr to end before every write
*         _O_BINARY -   open in binary mode
*         _O_CREAT -    create a new file* no effect if file already exists
*         _O_EXCL -     return error if file exists, only use with O_CREAT
*         _O_RDONLY -   open for reading only
*         _O_RDWR -     open for reading and writing
*         _O_TEXT -     open in text mode
*         _O_TRUNC -    open and truncate to 0 length (must have write permission)
*         _O_WRONLY -   open for writing only
*         _O_NOINHERIT -handle will not be inherited by child processes.
*       exactly one of _O_RDONLY, _O_WRONLY, _O_RDWR must be given
*
*       The pmode argument is only required when _O_CREAT is specified.  Its
*       flag settings:
*         _S_IWRITE -   writing permitted
*         _S_IREAD -    reading permitted
*         _S_IREAD | _S_IWRITE - both reading and writing permitted
*       The current file-permission maks is applied to pmode before
*       setting the permission (see umask).
*
*       The oflag and mode parameter have different meanings under DOS. See
*       the A_xxx attributes in msdos.inc
*
*       The file mode is opened in _SH_DENYNO share mode
*
*       Note, the _creat() function also uses this function but setting up the
*       correct arguments and calling _open(). _creat() sets the __creat_flag
*       to 1 prior to calling _open() so _open() can return correctly. _open()
*       returns the file handle in eax in this case.
*
*Entry:
*       _TSCHAR *path - file name
*       int flag - flags for _open()
*       int pmode - permission mode for new files
*
*Exit:
*       returns file handle of open file if successful
*       returns -1 (and sets errno) if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _topen (
        const _TSCHAR *path,
        int oflag,
        ...
        )
{
        va_list ap;
        int pmode = 0;
        int fh = -1;
        errno_t retval;
        int unlock_flag = 0;

        _VALIDATE_RETURN( (path != NULL), EINVAL, -1);

        va_start(ap, oflag);
        pmode = va_arg(ap, int);
        va_end(ap);


        __try {
/* Last parameter passed as 0 because we don't want to
validate pmode from open */
            retval = _tsopen_nolock( &unlock_flag,
                                 &fh,
                                 path,
                                 oflag,
                                 _SH_DENYNO,
                                 pmode,
                                 0 );
        }
        __finally {
            if ( unlock_flag )
            {
                if (retval)
                {
                    _osfile(fh) &= ~FOPEN;
                }
                _unlock_fh(fh);
            }
        }

        if (retval)
        {
            errno = retval;
            return -1;
        }

        return fh;

}

errno_t __cdecl _tsopen_helper (
        const _TSCHAR *path,
        int oflag,
        int shflag,
        int pmode,
        int * pfh,
        int bSecure
        )
{

        errno_t retval;
        int unlock_flag = 0;

        _VALIDATE_RETURN_ERRCODE( (pfh != NULL), EINVAL);
        *pfh = -1;
        _VALIDATE_RETURN_ERRCODE( (path != NULL), EINVAL);

        if(bSecure)
            _VALIDATE_RETURN_ERRCODE(((pmode & (~(_S_IREAD | _S_IWRITE))) == 0), EINVAL);

        __try {
            retval = _tsopen_nolock( &unlock_flag,
                                 pfh,
                                 path,
                                 oflag,
                                 shflag,
                                 pmode,
                                 bSecure );
        }
        __finally {
            if ( unlock_flag )
            {
                if (retval)
                {
                    _osfile(*pfh) &= ~FOPEN;
                }
                _unlock_fh(*pfh);
            }
        }

        /* in error case, ensure *pfh is -1 */
        if (retval != 0)
        {
            *pfh = -1;
        }

        return retval;
}

static errno_t __cdecl _tsopen_nolock (
        int *punlock_flag,
        int *pfh,
        const _TSCHAR *path,
        int oflag,
        int shflag,
        int pmode,
        int bSecure
        )
{


        int filepos;                    /* length of file - 1 */
        _TSCHAR ch;                     /* character at end of file */
        char fileflags;                 /* _osfile flags */
        int fmode = 0;

        HANDLE osfh;                    /* OS handle of opened file */
        DWORD fileaccess;               /* OS file access (requested) */
        DWORD fileshare;                /* OS file sharing mode */
        DWORD filecreate;               /* OS method of opening/creating */
        DWORD fileattrib;               /* OS file attribute flags */
        DWORD isdev;                    /* device indicator in low byte */
        SECURITY_ATTRIBUTES SecurityAttributes;
        char tmode = __IOINFO_TM_ANSI;  /* textmode - ANSI/UTF-8/UTF-16 */
        errno_t retvalue = 0;


        SecurityAttributes.nLength = sizeof( SecurityAttributes );
        SecurityAttributes.lpSecurityDescriptor = NULL;

        if (oflag & _O_NOINHERIT) {
            SecurityAttributes.bInheritHandle = FALSE;
            fileflags = FNOINHERIT;
        }
        else {
            SecurityAttributes.bInheritHandle = TRUE;
            fileflags = 0;
        }

        _ERRCHECK(_get_fmode(&fmode));

        /* figure out binary/text mode */
        if ((oflag & _O_BINARY) == 0)
            if (oflag & (_O_TEXT | _O_WTEXT | _O_U16TEXT | _O_U8TEXT))
                fileflags |= FTEXT;
            else if (fmode != _O_BINARY)   /* check default mode */
                fileflags |= FTEXT;

        /*
         * decode the access flags
         */
        switch( oflag & (_O_RDONLY | _O_WRONLY | _O_RDWR) ) {

            case _O_RDONLY:         /* read access */
                    fileaccess = GENERIC_READ;
                    break;
            case _O_WRONLY:         /* write access */
                    /* giving it read access as well
                     * because in append (a, not a+), we need
                     * to read the BOM to determine the encoding
                     * (ie. ANSI, UTF8, UTF16)
                     */
                    if ((oflag & _O_APPEND)
                            && (oflag & (_O_WTEXT | _O_U16TEXT | _O_U8TEXT)) != 0)
                    {
                        fileaccess = GENERIC_READ | GENERIC_WRITE;
                    }
                    else
                    {
                        fileaccess = GENERIC_WRITE;
                    }
                    break;
            case _O_RDWR:           /* read and write access */
                    fileaccess = GENERIC_READ | GENERIC_WRITE;
                    break;
            default:                /* error, bad oflag */
                    _doserrno = 0L; /* not an OS error */
                    *pfh = -1;
                    _VALIDATE_RETURN_ERRCODE(( "Invalid open flag" , 0 ), EINVAL);

        }

        /*
         * decode sharing flags
         */
        switch ( shflag ) {

            case _SH_DENYRW:        /* exclusive access */
                fileshare = 0L;
                break;

            case _SH_DENYWR:        /* share read access */
                fileshare = FILE_SHARE_READ;
                break;

            case _SH_DENYRD:        /* share write access */
                fileshare = FILE_SHARE_WRITE;
                break;

            case _SH_DENYNO:        /* share read and write access */
                fileshare = FILE_SHARE_READ | FILE_SHARE_WRITE;
                break;

            case _SH_SECURE:       /* share read access only if read-only */
                if (fileaccess == GENERIC_READ)
                    fileshare = FILE_SHARE_READ;
                else
                    fileshare = 0L;
                break;

            default:                /* error, bad shflag */
                _doserrno = 0L; /* not an OS error */
                *pfh = -1;
                _VALIDATE_RETURN_ERRCODE(( "Invalid sharing flag" , 0 ), EINVAL);
        }

        /*
         * decode open/create method flags
         */
        switch ( oflag & (_O_CREAT | _O_EXCL | _O_TRUNC) ) {
            case 0:
            case _O_EXCL:                   // ignore EXCL w/o CREAT
                filecreate = OPEN_EXISTING;
                break;

            case _O_CREAT:
                filecreate = OPEN_ALWAYS;
                break;

            case _O_CREAT | _O_EXCL:
            case _O_CREAT | _O_TRUNC | _O_EXCL:
                filecreate = CREATE_NEW;
                break;

            case _O_TRUNC:
            case _O_TRUNC | _O_EXCL:        // ignore EXCL w/o CREAT
                filecreate = TRUNCATE_EXISTING;
                break;

            case _O_CREAT | _O_TRUNC:
                filecreate = CREATE_ALWAYS;
                break;

            default:
                // this can't happen ... all cases are covered
                _doserrno = 0L;
                *pfh = -1;
                _VALIDATE_RETURN_ERRCODE(( "Invalid open flag" , 0 ), EINVAL);
        }

        /*
         * decode file attribute flags if _O_CREAT was specified
         */
        fileattrib = FILE_ATTRIBUTE_NORMAL;     /* default */

        if ( oflag & _O_CREAT ) {

            if ( !((pmode & ~_umaskval) & _S_IWRITE) )
                fileattrib = FILE_ATTRIBUTE_READONLY;
        }

        /*
         * Set temporary file (delete-on-close) attribute if requested.
         */
        if ( oflag & _O_TEMPORARY ) {
            fileattrib |= FILE_FLAG_DELETE_ON_CLOSE;
            fileaccess |= DELETE;
            fileshare |= FILE_SHARE_DELETE;
        }

        /*
         * Set temporary file (delay-flush-to-disk) attribute if requested.
         */
        if ( oflag & _O_SHORT_LIVED )
            fileattrib |= FILE_ATTRIBUTE_TEMPORARY;

        /*
         * Set sequential or random access attribute if requested.
         */
        if ( oflag & _O_SEQUENTIAL )
            fileattrib |= FILE_FLAG_SEQUENTIAL_SCAN;
        else if ( oflag & _O_RANDOM )
            fileattrib |= FILE_FLAG_RANDOM_ACCESS;

        /*
         * get an available handle.
         *
         * multi-thread note: the returned handle is locked!
         */
        if ( (*pfh = _alloc_osfhnd()) == -1 ) {
            _doserrno = 0L;         /* not an OS error */
            *pfh = -1;
            errno = EMFILE;
            return errno;          /* return error to caller */
        }

        /* Beyond this do not set *pfh = -1 on errors for MT.
            Because the caller needs to release the lock on the
            handle */

        *punlock_flag = 1;

        /*
         * try to open/create the file
         */
        if ( (osfh = CreateFile( (LPTSTR)path,
                                 fileaccess,
                                 fileshare,
                                 &SecurityAttributes,
                                 filecreate,
                                 fileattrib,
                                 NULL ))
             == (HANDLE)(-1) )
        {
            if ((fileaccess & (GENERIC_READ | GENERIC_WRITE)) == (GENERIC_READ | GENERIC_WRITE) &&
                    (oflag & _O_WRONLY))
            {
                /*
                 * We just failed on CreateFile(), because we might be trying
                 * open something for read while it cannot be read (eg. pipes or devices).
                 * So try again with GENERIC_WRITE and we will have to use the default
                 * encoding.  We won't be able to determine the encoding from reading
                 * the BOM.
                 */
                fileaccess &= ~GENERIC_READ;
                if ( (osfh = CreateFile( (LPTSTR)path,
                                         fileaccess,
                                         fileshare,
                                         &SecurityAttributes,
                                         filecreate,
                                         fileattrib,
                                         NULL ))
                     == (HANDLE)(-1) )
                {
                    /*
                     * OS call to open/create file failed! map the error, release
                     * the lock, and return -1. note that it's not necessary to
                     * call _free_osfhnd (it hasn't been used yet), but we do need
                     * to clear the FOPEN that was set by _alloc_osfhnd.
                     */
                    _osfile(*pfh) &= ~FOPEN;
                    _dosmaperr(GetLastError());
                    retvalue = errno;
                    goto exit;
                }
            }
            else
            {
                /*
                 * OS call to open/create file failed! map the error, release
                 * the lock, and return -1. note that it's not necessary to
                 * call _free_osfhnd (it hasn't been used yet), but we do need
                 * to clear the FOPEN that was set by _alloc_osfhnd.
                 */
                _osfile(*pfh) &= ~FOPEN;
                _dosmaperr(GetLastError());
                retvalue = errno;
                goto exit;
            }
        }

        /* find out what type of file (file/device/pipe) */
        if ( (isdev = GetFileType(osfh)) == FILE_TYPE_UNKNOWN) {
            DWORD dwLastError = 0;
            _osfile(*pfh) &= ~FOPEN;
            dwLastError = GetLastError();
            _dosmaperr(dwLastError);
            CloseHandle(osfh);
            if (dwLastError == ERROR_SUCCESS)
            {
               /*
                * If GetFileType returns FILE_TYPE_UNKNOWN but doesn't fail,
                * GetLastError returns ERROR_SUCCESS.
                * This function is not designed to deal with unknown types of files
                * and must return an error.
               */
               errno = EACCES;
            }
            retvalue = errno;
            goto exit;
        }

        /* use isdev value to set flags */
        if (isdev == FILE_TYPE_CHAR)
            fileflags |= FDEV;
        else if (isdev == FILE_TYPE_PIPE) {
            fileflags |= FPIPE;
        }

        /*
         * the file is open. now, set the info in _osfhnd array
         */
        _set_osfhnd(*pfh, (intptr_t)osfh);

        /*
         * mark the handle as open. store flags gathered so far in _osfile
         * array.
         */
        fileflags |= FOPEN;
        _osfile(*pfh) = fileflags;

        /* TextMode set to ANSI by default, if we find a BOM, then
        we reset it to the appropriate type below */
        _textmode(*pfh) = __IOINFO_TM_ANSI;

        if ( !(fileflags & (FDEV|FPIPE)) && (fileflags & FTEXT) &&
             (oflag & _O_RDWR) )
        {
            /* We have a text mode file.  If it ends in CTRL-Z, we wish to
               remove the CTRL-Z character, so that appending will work.
               We do this by seeking to the end of file, reading the last
               byte, and shortening the file if it is a CTRL-Z. */

            if ((filepos = _lseek_nolock(*pfh, -1, SEEK_END)) == -1) {
                /* OS error -- should ignore negative seek error,
                   since that means we had a zero-length file. */
                if (_doserrno != ERROR_NEGATIVE_SEEK) {
                    _close_nolock(*pfh);
                    retvalue = errno;
                    goto exit;
                }
            }
            else {
                /* Seek was OK, read the last char in file. The last
                   char is a CTRL-Z if and only if _read returns 0
                   and ch ends up with a CTRL-Z. */
                ch = 0;
                if (_read_nolock(*pfh, &ch, 1) == 0 && ch == 26) {
                    /* read was OK and we got CTRL-Z! Wipe it
                       out! */
                    if (_chsize_nolock(*pfh,filepos) == -1)
                    {
                        _close_nolock(*pfh);
                        retvalue = errno;
                        goto exit;
                    }
                }

                /* now rewind the file to the beginning */
                if ((filepos = _lseek_nolock(*pfh, 0, SEEK_SET)) == -1) {
                    _close_nolock(*pfh);
                    retvalue = errno;
                    goto exit;
                }
            }
        }

        if ( fileflags & FTEXT) {

            int count;

            /* Set default tmode per oflag. BOM will change the defualt. */
            /* If oflag does not specify file type get type from _fmode  */
            if ( (oflag & (_O_TEXT | _O_WTEXT | _O_U16TEXT | _O_U8TEXT) ) == 0 )
            {
                /* Type specified in default mode? */
                if ( (fmode & (_O_TEXT | _O_WTEXT | _O_U16TEXT | _O_U8TEXT) ) == 0)
                    oflag |= _O_TEXT; /* default to ANSI */
                else
                    oflag |= fmode & (_O_TEXT | _O_WTEXT | _O_U16TEXT | _O_U8TEXT);
            }

            /* Now oflags should be set to one of the text modes */
            _ASSERTE( (oflag & (_O_TEXT | _O_WTEXT | _O_U16TEXT | _O_U8TEXT) ) != 0 );

            switch ( oflag & (_O_TEXT | _O_WTEXT | _O_U16TEXT | _O_U8TEXT) )
            {
            case _O_TEXT :
                tmode = __IOINFO_TM_ANSI;
                break;
            case _O_WTEXT :
            case _O_WTEXT | _O_TEXT :
                if ( (oflag & (_O_WRONLY | _O_CREAT | _O_TRUNC)) ==
                    (_O_WRONLY | _O_CREAT | _O_TRUNC) )
                    tmode = __IOINFO_TM_UTF16LE;
                break;
            case _O_U16TEXT :
            case _O_U16TEXT | _O_TEXT :
                tmode = __IOINFO_TM_UTF16LE;
                break;

            case _O_U8TEXT :
            case _O_U8TEXT | _O_TEXT :
                tmode = __IOINFO_TM_UTF8;
                break;
            }

            /* If the file hasn't been opened with the UNICODE flags then we
            have nothing to do - textmode's already set to default specified in oflag */
            if((oflag & (_O_WTEXT | _O_U16TEXT | _O_U8TEXT)) != 0) {

                int bom = 0;
                int bWriteBom = 0;
                int bCheckBom = 0;

                if ( !(fileflags & FDEV) ) {
                        switch ( fileaccess & (GENERIC_READ | GENERIC_WRITE) ) {

                        case GENERIC_READ :
                                {
                                        bCheckBom = 1;
                                        break;
                                }

                        case GENERIC_WRITE :
                                {
                                        switch ( filecreate ) {
                                            /* Write BOM if empty file */
                                        case OPEN_EXISTING :
                                        case OPEN_ALWAYS :
                                        {
                                            /* Check if the file contains at least one byte */
                                            /* Fall through otherwise */
                                            if( _lseeki64_nolock(*pfh, 0, SEEK_END) != 0) {
                                                if(_lseeki64_nolock(*pfh, 0, SEEK_SET) == -1) {
                                                    _close_nolock(*pfh);
                                                    retvalue = errno;
                                                    goto exit;
                                                }
                                                break;
                                            }
                                        }

                                        /* New or truncated file. Always write BOM */
                                        case CREATE_NEW :
                                        case CREATE_ALWAYS :
                                        case TRUNCATE_EXISTING :
                                        {
                                            bWriteBom = 1;
                                            break;
                                        }
                                        }
                                        break;
                                }

                        case GENERIC_READ | GENERIC_WRITE :
                                {
                                        switch ( filecreate ) {
                                            /* Check for existing BOM, Write BOM if empty file */
                                        case OPEN_EXISTING :
                                        case OPEN_ALWAYS :
                                        {
                                            /* Check if the file contains at least one byte */
                                            /* Fall through otherwise */
                                            if( _lseeki64_nolock(*pfh, 0, SEEK_END) != 0) {
                                                if(_lseeki64_nolock(*pfh, 0, SEEK_SET) == -1) {
                                                    _close_nolock(*pfh);
                                                    retvalue = errno;
                                                    goto exit;
                                                }
                                                bCheckBom = 1;
                                            }
                                            else {
                                                bWriteBom = 1; /* reset if file is not zero size */
                                            }
                                            break;
                                        }

                                        /* New or truncated file. Always write BOM */
                                        case CREATE_NEW :
                                        case TRUNCATE_EXISTING :
                                        case CREATE_ALWAYS :
                                        {
                                            bWriteBom = 1;
                                            break;
                                        }
                                        }
                                        break;
                                }
                        }
                }

                if ( bCheckBom ) {
                    count = _read_nolock(*pfh, &bom, UTF8_BOMLEN);

                    /*
                       Internal Validation.
                       This branch should never be taken if bWriteBom is 1 and count > 0
                    */
                    if (count > 0 && bWriteBom == 1) {
                        _ASSERTE(0 && "Internal Error");
                        bWriteBom = 0;
                    }

                    switch(count) {

                        case -1 :
                            _close_nolock(*pfh);
                            retvalue = errno;
                            goto exit;

                        case UTF8_BOMLEN:
                            if(bom == UTF8_BOM) {
                                tmode = __IOINFO_TM_UTF8;
                                break;
                            }

                        case UTF16_BOMLEN:
                            if((bom & BOM_MASK) == UTF16BE_BOM) {
                                _close_nolock(*pfh);
                                _ASSERTE(0 && "Only UTF-16 little endian & UTF-8 is supported for reads");
                                retvalue = errno = EINVAL;
                                goto exit;
                            }

                            if((bom & BOM_MASK) == UTF16LE_BOM) {
                                /* We have read 3 bytes, so we should seek back
                                1 byte */
                                if((filepos = _lseek_nolock(*pfh, UTF16_BOMLEN, SEEK_SET)) == -1) {
                                    _close_nolock(*pfh);
                                    retvalue = errno;
                                    goto exit;
                                }
                                tmode = __IOINFO_TM_UTF16LE;
                                break;
                            }

                            /* Fall through to default case to lseek to
                            beginning of file */

                        default:
                            if((filepos = _lseek_nolock(*pfh, 0, SEEK_SET)) == -1) {
                                /* No BOM, so we should seek back to the beginning
                                of the file */
                                _close_nolock(*pfh);
                                retvalue = errno;
                                goto exit;
                            }
                            break;
                    }
                }
                if( bWriteBom ) {
                    int written = 0;
                    int bomlen = 0;
                    bom = 0;

                    /* If we are creating a new file, we write a UTF-16LE or UTF8 BOM */
                    switch (tmode)
                    {
                    case __IOINFO_TM_UTF16LE :
                        {
                            bom = UTF16LE_BOM;
                            bomlen = UTF16_BOMLEN;
                            break;
                        }
                    case __IOINFO_TM_UTF8 :
                        {
                            bom = UTF8_BOM;
                            bomlen = UTF8_BOMLEN;
                            break;
                        }
                    }

                    while (bomlen > written) {
                        int tmp = 0;
                        /*
                         * Note that write may write less than bomlen characters, but not really fail.
                         * Retry till write fails or till we wrote all the characters.
                         */
                        if ((tmp = _write(*pfh, ((char *)(&bom)) + written, bomlen - written)) == -1) {
                            _close_nolock(*pfh);
                            retvalue = errno;
                            goto exit;
                        }
                        written += tmp;
                    }
                }
            }
        }

        _textmode(*pfh) = tmode;
        _tm_unicode(*pfh) = ((oflag & _O_WTEXT) == 0) ? 0 : 1;


        /*
         * Set FAPPEND flag if appropriate. Don't do this for devices or pipes.
         */
        if ( !(fileflags & (FDEV|FPIPE)) && (oflag & _O_APPEND) )
            _osfile(*pfh) |= FAPPEND;

        /*
         * re-open the file with write access only if we opened the file
         * with read access to read the BOM before
         */
        if ((fileaccess & (GENERIC_READ | GENERIC_WRITE)) == (GENERIC_READ|GENERIC_WRITE) &&
                (oflag & _O_WRONLY))
        {
            // we will have to reopen the file again with the write access (but not read)
            CloseHandle(osfh);
            fileaccess &= ~GENERIC_READ;
            // we want to use OPEN_EXISTING here, because the user can open the an non-existing
            // file for append with _O_EXCL flag
            filecreate = OPEN_EXISTING;
            if ( (osfh = CreateFile( (LPTSTR)path,
                            fileaccess,
                            fileshare,
                            &SecurityAttributes,
                            filecreate,
                            fileattrib,
                            NULL ))
                    == (HANDLE)(-1) )
            {
                /*
                 * OS call to open/create file failed! map the error, release
                 * the lock, and return -1. Note that it's *necessary* to
                 * call _free_osfhnd (unlike the situation before), because we have
                 * already set the file handle in the _ioinfo structure
                 */
                _dosmaperr(GetLastError());
                _osfile(*pfh) &= ~FOPEN;
                _free_osfhnd(*pfh);
                retvalue = errno;
                goto exit;
            }
            else
            {
                // We were able to open the file successfully, set the file
                // handle in the _ioinfo structure, then we are done.  All
                // the fileflags should have been set properly already.
                _osfhnd(*pfh) = (intptr_t)osfh;
            }
        }

exit:
        return retvalue;
}

/***
*int _sopen(path, oflag, shflag, pmode) - opne a file with sharing
*
*Purpose:
*       Opens the file with possible file sharing.
*       shflag defines the sharing flags:
*         _SH_COMPAT -  set compatability mode
*         _SH_DENYRW -  deny read and write access to the file
*         _SH_DENYWR -  deny write access to the file
*         _SH_DENYRD -  deny read access to the file
*         _SH_DENYNO -  permit read and write access
*
*       Other flags are the same as _open().
*
*       SOPEN is the routine used when file sharing is desired.
*
*Entry:
*       _TSCHAR *path - file to open
*       int oflag -     open flag
*       int shflag -    sharing flag
*       int pmode -     permission mode (needed only when creating file)
*
*Exit:
*       returns file handle for the opened file
*       returns -1 and sets errno if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tsopen (
        const _TSCHAR *path,
        int oflag,
        int shflag,
        ...
        )
{
        va_list ap;
        int pmode = 0;
        int fh = -1;
        errno_t e;

        va_start(ap, shflag);
        pmode = va_arg(ap, int);
        va_end(ap);

        /* Last parameter passed as 0 because we don't want to
        validate pmode from open */

        e = _tsopen_helper(path, oflag, shflag, pmode, &fh, 0);

        return e ? -1 : fh;
}

/***
*int _sopen_s(pfh, path, oflag, shflag, pmode) - open a file with sharing
*
*Purpose:
*       Check comments for _sopen. This works similiar to _sopen except
*       it validates the pmode.
*
*Entry:
*       _TSCHAR *path - file to open
*       int oflag -     open flag
*       int shflag -    sharing flag
*       int pmode -     permission mode (needed only when creating file)
*       int * pfh -     pointer to write the file handle to.
*
*Exit:
*       returns 0 on success & sets pfile
*       returns errno_t on failure.
*       On success, the file handle is written to the pfh parameter.
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tsopen_s (
        int * pfh,
        const _TSCHAR *path,
        int oflag,
        int shflag,
        int pmode
        )
{
    /* Last parameter passed as 1 because we want to validate
     * pmode from the secure open_s */
    return _tsopen_helper(path, oflag, shflag, pmode, pfh, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\osfinfo.c ===
/***
*osfinfo.c - Win32 _osfhnd[] support routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the internally used routine _alloc_osfhnd()
*       and the user visible routine _get_osfhandle().
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <internal.h>
#include <fcntl.h>
#include <malloc.h>
#include <msdos.h>
#include <mtdll.h>
#include <stdlib.h>
#include <dbgint.h>
#include <io.h>


/***
*int _alloc_osfhnd() - get free _ioinfo struct
*
*Purpose:
*       Finds the first free entry in the arrays of ioinfo structs and
*       returns the index of that entry (which is the CRT file handle to the
*       caller) to the caller.  The FOPEN flag is turned on in the new entry,
*       to prevent multithreaded race conditions/deadlocks.
*
*Entry:
*       none
*
*Exit:
*       returns index of the entry, if successful
*       return -1, if no free entry is available or out of memory
*
*       MULTITHREAD NOTE: IF SUCCESSFUL, THE HANDLE IS LOCKED WHEN IT IS
*       RETURNED TO THE CALLER!  ALSO, FOPEN HAS BEEN TURNED ON, SO IF THE
*       CALLER ABANDONS THE HANDLE, FOPEN MUST BE CLEARED!
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _alloc_osfhnd(
        void
        )
{
        int fh = -1;    /* file handle */
        int i;
        ioinfo *pio;
        int failed=FALSE;

        if (!_mtinitlocknum(_OSFHND_LOCK))
            return -1;

        _mlock(_OSFHND_LOCK);   /* lock the __pioinfo[] array */
        __TRY

            /*
             * Search the arrays of ioinfo structs, in order, looking for the
             * first free entry. The compound index of this free entry is the
             * return value. Here, the compound index of the ioinfo struct
             * *(__pioinfo[i] + j) is k = i * IOINFO_ARRAY_ELTS + j, and k = 0,
             * 1, 2,... is the order of the search.
             */
            for ( i = 0 ; i < IOINFO_ARRAYS ; i++ ) {
                /*
                 * If __pioinfo[i] is non-empty array, search it looking for
                 * the first free entry. Otherwise, allocate a new array and use
                 * its first entry.
                 */
                if ( __pioinfo[i] != NULL ) {
                    /*
                     * Search for an available entry.
                     */
                    for ( pio = __pioinfo[i] ;
                          pio < __pioinfo[i] + IOINFO_ARRAY_ELTS ;
                          pio++ )
                    {
                        if ( (pio->osfile & FOPEN) == 0 ) {
                            /*
                             * Make sure the lock is initialized.
                             */
                            if ( pio->lockinitflag == 0 ) {
                                _mlock( _LOCKTAB_LOCK );
                                __TRY
                                    if ( pio->lockinitflag == 0 ) {
                                        if ( !__crtInitCritSecAndSpinCount( &(pio->lock), _CRT_SPINCOUNT ))
                                        {
                                            /*
                                             * Lock initialization failed.  Release
                                             * held locks and return failure.
                                            */
                                            failed=TRUE;
                                        }
                                        else
                                        {
                                            pio->lockinitflag++;
                                        }
                                    }
                                __FINALLY
                                    _munlock( _LOCKTAB_LOCK );
                                __END_TRY_FINALLY
                            }

                            if(!failed)
                            {
                                EnterCriticalSection( &(pio->lock) );

                                /*
                                * Check for the case where another thread has
                                * managed to grab the handle out from under us.
                                */
                                if ( (pio->osfile & FOPEN) != 0 ) {
                                        LeaveCriticalSection( &(pio->lock) );
                                        continue;
                                }
                            }
                            if(!failed)
                            {
                                pio->osfile = FOPEN;
                                pio->osfhnd = (intptr_t)INVALID_HANDLE_VALUE;
                                fh = i * IOINFO_ARRAY_ELTS + (int)(pio - __pioinfo[i]);
                                break;
                            }
                        }
                    }

                    /*
                     * Check if a free entry has been found.
                     */
                    if ( fh != -1 )
                        break;
                }
                else {
                    /*
                     * Allocate and initialize another array of ioinfo structs.
                     */
                    if ( (pio = _calloc_crt( IOINFO_ARRAY_ELTS, sizeof(ioinfo) ))
                        != NULL )
                    {

                        /*
                         * Update __pioinfo[] and _nhandle
                         */
                        __pioinfo[i] = pio;
                        _nhandle += IOINFO_ARRAY_ELTS;

                        for ( ; pio < __pioinfo[i] + IOINFO_ARRAY_ELTS ; pio++ ) {
                            pio->osfile = 0;
                            pio->osfhnd = (intptr_t)INVALID_HANDLE_VALUE;
                            pio->pipech = 10;
                            pio->lockinitflag = 0;
                        }

                        /*
                         * The first element of the newly allocated array of ioinfo
                         * structs, *(__pioinfo[i]), is our first free entry.
                         */
                        fh = i * IOINFO_ARRAY_ELTS;
                        _osfile(fh) = FOPEN;
                        if ( !__lock_fhandle( fh ) ) {
                            /*
                             * The lock initialization failed, return the failure
                             */
                            fh = -1;
                        }
                    }

                    break;
                }
            }
        __FINALLY
            _munlock(_OSFHND_LOCK); /* unlock the __pioinfo[] table */
        __END_TRY_FINALLY

        /*
         * return the index of the previously free table entry, if one was
         * found. return -1 otherwise.
         */
        return( fh );
}


/***
*int _set_osfhnd(int fh, long value) - set Win32 HANDLE value
*
*Purpose:
*       If fh is in range and if _osfhnd(fh) is marked with
*       INVALID_HANDLE_VALUE then set _osfhnd(fh) to the passed value.
*
*Entry:
*       int fh      - CRT file handle
*       long value  - new Win32 HANDLE value for this handle
*
*Exit:
*       Returns zero if successful.
*       Returns -1 and sets errno to EBADF otherwise.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _set_osfhnd (
        int fh,
        intptr_t value
        )
{
        if ( fh >= 0 && ((unsigned)fh < (unsigned)_nhandle) &&
             (_osfhnd(fh) == (intptr_t)INVALID_HANDLE_VALUE)
           ) {
            if ( __app_type == _CONSOLE_APP ) {
                switch (fh) {
                case 0:
                    SetStdHandle( STD_INPUT_HANDLE, (HANDLE)value );
                    break;
                case 1:
                    SetStdHandle( STD_OUTPUT_HANDLE, (HANDLE)value );
                    break;
                case 2:
                    SetStdHandle( STD_ERROR_HANDLE, (HANDLE)value );
                    break;
                }
            }

            _osfhnd(fh) = value;
            return(0);
        } else {
            errno = EBADF;      /* bad handle */
            _doserrno = 0L;     /* not an OS error */
            return -1;
        }
}


/***
*int _free_osfhnd(int fh) - mark osfhnd field of ioinfo struct as free
*
*Purpose:
*       If fh is in range, the corrsponding ioinfo struct is marked as
*       being open, and the osfhnd field is NOT set to INVALID_HANDLE_VALUE,
*       then mark it with INVALID_HANDLE_VALUE.
*
*Entry:
*       int fh -    CRT file handle
*
*Exit:
*       Returns zero if successful.
*       Returns -1 and sets errno to EBADF otherwise.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _free_osfhnd (
        int fh      /* user's file handle */
        )
{
        if ( (fh >= 0 && (unsigned)fh < (unsigned)_nhandle) &&
             (_osfile(fh) & FOPEN) &&
             (_osfhnd(fh) != (intptr_t)INVALID_HANDLE_VALUE) )
        {
            if ( __app_type == _CONSOLE_APP ) {
                switch (fh) {
                case 0:
                    SetStdHandle( STD_INPUT_HANDLE, NULL );
                    break;
                case 1:
                    SetStdHandle( STD_OUTPUT_HANDLE, NULL );
                    break;
                case 2:
                    SetStdHandle( STD_ERROR_HANDLE, NULL );
                    break;
                }
            }

            _osfhnd(fh) = (intptr_t)INVALID_HANDLE_VALUE;
            return(0);
        } else {
            errno = EBADF;      /* bad handle */
            _doserrno = 0L;     /* not an OS error */
            return -1;
        }
}


/***
*long _get_osfhandle(int fh) - get Win32 HANDLE value
*
*Purpose:
*       If fh is in range and marked open, return _osfhnd(fh).
*
*Entry:
*       int fh  - CRT file handle
*
*Exit:
*       Returns the Win32 HANDLE successful.
*       Returns -1 and sets errno to EBADF otherwise.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _get_osfhandle (
        int fh      /* user's file handle */
        )
{
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        return( _osfhnd(fh) );
}

/***
*int _open_osfhandle(long osfhandle, int flags) - open C Runtime file handle
*
*Purpose:
*       This function allocates a free C Runtime file handle and associates
*       it with the Win32 HANDLE specified by the first parameter.
*
*Entry:
*       long osfhandle - Win32 HANDLE to associate with C Runtime file handle.
*       int flags      - flags to associate with C Runtime file handle.
*
*Exit:
*       returns index of entry in fh, if successful
*       return -1, if no free entry is found
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _open_osfhandle(
        intptr_t osfhandle,
        int flags
        )
{
        int fh;
        char fileflags;         /* _osfile flags */
        DWORD isdev;            /* device indicator in low byte */
        int success = FALSE;

        /* copy relevant flags from second parameter */

        fileflags = 0;

        if ( flags & _O_APPEND )
            fileflags |= FAPPEND;

        if ( flags & _O_TEXT )
            fileflags |= FTEXT;

        if ( flags & _O_NOINHERIT )
            fileflags |= FNOINHERIT;

        /* find out what type of file (file/device/pipe) */

        isdev = GetFileType((HANDLE)osfhandle);
        if (isdev == FILE_TYPE_UNKNOWN) {
            /* OS error */
            _dosmaperr( GetLastError() );   /* map error */
            return -1;
        }

        /* is isdev value to set flags */
        if (isdev == FILE_TYPE_CHAR)
            fileflags |= FDEV;
        else if (isdev == FILE_TYPE_PIPE)
            fileflags |= FPIPE;


        /* attempt to allocate a C Runtime file handle */

        if ( (fh = _alloc_osfhnd()) == -1 ) {
            errno = EMFILE;         /* too many open files */
            _doserrno = 0L;         /* not an OS error */
            return -1;              /* return error to caller */
        }
        __TRY

            /*
             * the file is open. now, set the info in _osfhnd array
             */

            _set_osfhnd(fh, osfhandle);

            fileflags |= FOPEN;     /* mark as open */

            _osfile(fh) = fileflags;    /* set osfile entry */
            _textmode(fh) = 0;
            _tm_unicode(fh) = 0;

            success = TRUE;

        __FINALLY
            if (!success)
            {
                _osfile(fh) &= ~FOPEN;
            }
            _unlock_fh(fh);         /* unlock handle */
        __END_TRY_FINALLY

            return success ? fh : -1;   /* return handle */
}



/***
*void __lock_fhandle(int fh) - lock file handle
*
*Purpose:
*       Assert the lock associated with the passed file handle.
*
*Entry:
*       int fh  - CRT file handle
*
*Exit:
*       Returns FALSE if the attempt to initialize the lock fails.  This can
*       only happen the first time the lock is taken, so the return status only
*       needs to be checked on the first such attempt, which is always in
*       _alloc_osfhnd (except for inherited or standard handles, and the lock
*       is allocated manually in _ioinit for those).
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __lock_fhandle (
        int fh
        )
{
        ioinfo *pio = _pioinfo(fh);
        int retval=TRUE;

        /*
         * Make sure the lock has been initialized.
         */
        if ( pio->lockinitflag == 0 ) {

            _mlock( _LOCKTAB_LOCK );
            __TRY
                if ( pio->lockinitflag == 0 ) {
                    if ( !__crtInitCritSecAndSpinCount( &(pio->lock), _CRT_SPINCOUNT )) {
                        /*
                         * Failed to initialize the lock, so return failure code.
                         */
                        retval=FALSE;
                    }
                    pio->lockinitflag++;
                }
            __FINALLY
                _munlock( _LOCKTAB_LOCK);
            __END_TRY_FINALLY
        }

        if(retval)
        {
            EnterCriticalSection( &(_pioinfo(fh)->lock) );
        }

        return retval;
}


/***
*void _unlock_fhandle(int fh) - unlock file handle
*
*Purpose:
*       Release the lock associated with passed file handle.
*
*Entry:
*       int fh  - CRT file handle
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_fhandle (
        int fh
        )
{
        LeaveCriticalSection( &(_pioinfo(fh)->lock) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\printf.c ===
/***
*printf.c - print formatted
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines printf() - print formatted data
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <stddef.h>
#include <process.h>

/***
*int printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on stdout using the format string to
*       format data and getting as many arguments as called for
*       Uses temporary buffering to improve efficiency.
*       _output does the real work here
*
*Entry:
*       char *format - format string to control data format/number of arguments
*       followed by list of arguments, number and type controlled by
*       format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl printf (
        const char *format,
        ...
        )
/*
 * stdout 'PRINT', 'F'ormatted
 */
{
        va_list arglist;
        int buffing;
        int retval;

        _VALIDATE_RETURN( (format != NULL), EINVAL, -1);

        va_start(arglist, format);

        _lock_str2(1, stdout);
        __try {

        buffing = _stbuf(stdout);

        retval = _output_l(stdout,format,NULL,arglist);

        _ftbuf(buffing, stdout);

        }
        __finally {
            _unlock_str2(1, stdout);
        }

        return(retval);
}

int __cdecl _printf_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vprintf_l(format, plocinfo, arglist);
}


int __cdecl _printf_s_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vprintf_s_l(format, plocinfo, arglist);
}

int __cdecl printf_s (
        const char *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vprintf_s_l(format, NULL, arglist);
}

int __cdecl _printf_p_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vprintf_p_l(format, plocinfo, arglist);
}

int __cdecl _printf_p (
        const char *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vprintf_p_l(format, NULL, arglist);
}

static UINT_PTR __enable_percent_n = 0;

/***
 *int _set_printf_count_output(int)
 *
 *Purpose:
 *   Enables or disables %n format specifier for printf family functions
 *
 *Internals:
 *   __enable_percent_n is set to (__security_cookie|1) for security reasons;
 *   if set to a static value, an attacker could first modify __enable_percent_n
 *   and then provide a malicious %n specifier.  The cookie is ORed with 1
 *   because a zero cookie is a possibility.
 ******************************************************************************/
int __cdecl _set_printf_count_output(int value)
{
    int old = (__enable_percent_n == (__security_cookie | 1));
    __enable_percent_n = (value ? (__security_cookie | 1) : 0);
    return old;
}

/***
 *int _get_printf_count_output()
 *
 *Purpose:
 *   Checks whether %n format specifier for printf family functions is enabled
 ******************************************************************************/
int __cdecl _get_printf_count_output()
{
    return ( __enable_percent_n == (__security_cookie | 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ptrust.cpp ===
/***
*ptrust.cpp - Generate startup code for use in partial trust scenario
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#define _PARTIAL_TRUST_OBJ

#include "mstartup.cpp"

#if defined (_M_CEE_MIXED)
#ifdef _DEBUG
#pragma comment(linker, "/nodefaultlib:msvcmrtd.lib")
#pragma comment(lib, "msvcrtd.lib")
#else  /* _DEBUG */
#pragma comment(linker, "/nodefaultlib:msvcmrt.lib")
#pragma comment(lib, "msvcrt.lib")
#endif  /* _DEBUG */
#else  /* defined (_M_CEE_MIXED) */
#ifdef _DEBUG
#pragma comment(linker, "/nodefaultlib:msvcurtd.lib")
#pragma comment(lib, "msvcrtd.lib")
#else  /* _DEBUG */
#pragma comment(linker, "/nodefaultlib:msvcurt.lib")
#pragma comment(lib, "msvcrt.lib")
#endif  /* _DEBUG */
#endif  /* defined (_M_CEE_MIXED) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\pureMSILcode.cpp ===
/***
*msilexit.cpp - Exit routines for mixdll.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file provides at_exit support for clrcall functions. Here you will
*       find implementation for both managed process exit and appdomain exit.
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <internal.h>
#include <mtdll.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention
#pragma warning(disable:4483)   // disable warning/error about __identifier(<string>)

#if defined (_M_CEE_MIXED)
/***
* static void _initterm(_PIFV * pfbegin, _PIFV * pfend) - call entries in
*       function pointer table
*
*Purpose:
*       Walk a table of function pointers, calling each entry, as follows:
*
*           1. walk from beginning to end, pfunctbl is assumed to point
*              to the beginning of the table, which is currently a null entry,
*              as is the end entry.
*           2. skip NULL entries
*           3. stop walking when the end of the table is encountered
*
*Entry:
*       _PVFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PVFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       Returns 0 if passed, 1 if falied.
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it to initialize their C++ constructors.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
int __clrcall _initterm_e (
        _PIFV * pfbegin,
        _PIFV * pfend
        )
{
        int ret = 0;
        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend && ret == 0)
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                ret = (**pfbegin)();
            ++pfbegin;
        }

        return ret;
}

/***
* static void _initterm(_PVFV * pfbegin, _PVFV * pfend) - call entries in
*       function pointer table
*
*Purpose:
*       Walk a table of function pointers, calling each entry, as follows:
*
*           1. walk from beginning to end, pfunctbl is assumed to point
*              to the beginning of the table, which is currently a null entry,
*              as is the end entry.
*           2. skip NULL entries
*           3. stop walking when the end of the table is encountered
*
*Entry:
*       _PVFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PVFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it to initialize their C++ constructors.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
void __clrcall _initterm (
        _PVFV * pfbegin,
        _PVFV * pfend
        )
{
        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend )
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                (**pfbegin)();
            ++pfbegin;
        }
}
#endif  /* defined (_M_CEE_MIXED) */

namespace __identifier("<CrtImplementationDetails>")
{
        class ThisModule
        {
        private:
                [System::Diagnostics::DebuggerStepThroughAttribute]
                static System::ModuleHandle Handle()
                {
                        return ThisModule::typeid->Module->ModuleHandle;
                }

        public:
                template <class T>
                [System::Diagnostics::DebuggerStepThroughAttribute]
                static T* ResolveMethod(T* methodToken)
                {
                        return (T*)Handle().ResolveMethodHandle((int)(size_t)methodToken).GetFunctionPointer().ToPointer();
                }
        };
}

/***
* void _initterm_m(_PVFVM * pfbegin, _PVFVM * pfend) - call entries in
*       function pointer table
*
*Purpose:
*       Walk a table of function pointers, calling each entry, as follows:
*
*           1. walk from beginning to end, pfunctbl is assumed to point
*              to the beginning of the table, which is currently a null entry,
*              as is the end entry.
*           2. skip NULL entries
*           3. stop walking when the end of the table is encountered
*
*Entry:
*       _PVFVM *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PVFVM *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

[System::Diagnostics::DebuggerStepThroughAttribute]
void __clrcall _initterm_m (
        const _PVFVM * pfbegin,
        const _PVFVM * pfend
        )
{
    using namespace __identifier("<CrtImplementationDetails>");

    /*
     * walk the table of function pointers from the bottom up, until
     * the end is encountered.  Do not skip the first entry.  The initial
     * value of pfbegin points to the first valid entry.  Do not try to
     * execute what pfend points to.  Only entries before pfend are valid.
     */
    while ( pfbegin < pfend )
    {
        /*
         * if current table entry is non-NULL, call thru it.
         */

        /*
         * GetRuntimeMethodHandleFromMetadataToken call needs to be changed to
         * call ResolveMethodHandle once that method becomes available in the
         * VBL CLR.  Disabling the warning for now.
         */
        if ( *pfbegin != NULL )
        {
            _PVFVM pfn = ThisModule::ResolveMethod(*pfbegin);
            (pfn)();
        }
        ++pfbegin;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\output.c ===
/***
*output.c - printf style output to a FILE
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the code that does all the work for the
*       printf family of functions.  It should not be called directly, only
*       by the *printf functions.  We don't make any assumtions about the
*       sizes of ints, longs, shorts, or long doubles, but if types do overlap,
*       we also try to be efficient.  We do assume that pointers are the same
*       size as either ints or longs.
*       If CPRFLAG is defined, defines _cprintf instead.
*       **** DOESN'T CURRENTLY DO MTHREAD LOCKING ****
*
*Note:
*       this file is included in safecrt.lib build directly, plese refer
*       to safecrt_[w]output_s.c
*
*******************************************************************************/

/* temporary work-around for compiler without 64-bit support */
#ifndef _SAFECRT_IMPL
extern "C"
{
#endif  /* _SAFECRT_IMPL */

#ifdef POSITIONAL_PARAMETERS
#define FORMAT_VALIDATIONS
#endif  /* POSITIONAL_PARAMETERS */

#include <mtdll.h>
#include <cruntime.h>
#include <limits.h>
#include <string.h>
#include <stddef.h>
#include <crtdefs.h>
#include <stdio.h>
#include <stdarg.h>
#include <cvt.h>
#include <conio.h>
#include <internal.h>
#include <fltintrn.h>
#include <stdlib.h>
#include <ctype.h>
#include <dbgint.h>
#include <setlocal.h>

#ifndef _MBTOWC
#define _MBTOWC mbtowc
#endif  /* _MBTOWC */

#ifndef _WCTOMB_S
#define _WCTOMB_S wctomb_s
#endif  /* _WCTOMB_S */

#ifdef _SAFECRT_IMPL

#undef _malloc_crt
#define _malloc_crt malloc

#undef _free_crt
#define _free_crt free

/* we assume that safecrt implements only sprintf, and not the stream printf */
#undef _putwc_nolock
#define _putwc_nolock(_c, _stream)   ((_stream->_cnt -= sizeof(wchar_t)) >= 0 ? (wint_t) (0xffff & (*((wchar_t *)(_stream->_ptr))++ = (wchar_t)_c)) : WEOF)

/* Wrapper for _output_s so that we do not expose FILE in the _output_s signature.
 * Always ensure null-termination. Returns the number of written chars, not including the terminating null.
 * Returns -1 if something went wrong during the formatting (in _output_s), e.g. mbcs conversions.
 * Returns -2 if the string has been truncated.
 * _output_s calls _invalid_parameter (and returns -1, possibly) if the format string is malformed.
 */
#ifndef _UNICODE
int __cdecl _soutput_s(char *_Dst, size_t _Size, const char *_Format, va_list _ArgList)
#else  /* _UNICODE */
int __cdecl _swoutput_s(wchar_t *_Dst, size_t _Size, const wchar_t *_Format, va_list _ArgList)
#endif  /* _UNICODE */
{
    FILE stream;
    FILE *outfile = &stream;
    int written = -1;

    /* validation section */
#ifndef _UNICODE
    if(_Size==SIZE_MAX)
    {
        /* user is attempting to make us unbounded, but we don't fit that much */
        outfile->_cnt = INT_MAX;
    }
    else
    {
        _VALIDATE_RETURN(_Size <= INT_MAX, EINVAL, -1);
        outfile->_cnt = (int)_Size;
    }
    outfile->_ptr = outfile->_base = _Dst;
#else  /* _UNICODE */
    if(_Size==SIZE_MAX)
    {
        /* user is attempting to make us unbounded, but we don't fit that much */
        outfile->_cnt = INT_MAX;
    }
    else if(_Size>(INT_MAX/sizeof(wchar_t)))
    {
        /* we can't represent the amount of output the user asked for */
        _VALIDATE_RETURN( FALSE, EINVAL, -1 );
    }
    else
    {
        outfile->_cnt = (int)(_Size*sizeof(wchar_t));
    }
    outfile->_ptr = outfile->_base = (char*)_Dst;
#endif  /* _UNICODE */
    outfile->_flag = _IOWRT | _IOSTRG;

#ifndef _UNICODE
    written = _output_s(outfile, _Format, _ArgList);
#else  /* _UNICODE */
    written = _woutput_s(outfile, _Format, _ArgList);
#endif  /* _UNICODE */
    _Dst[_Size - 1] = 0;
    if (written < 0)
    {
        if (outfile->_cnt < 0)
        {
            /* the buffer was too small; we return -2 to indicate truncation */
            return -2;
        }
        /* otherwise, something else failed: we reset the string and we return */
        if (_Dst != NULL && _Size > 0)
        {
            *_Dst = 0;
        }
        return written;
    }

#ifndef _UNICODE
    if ((_putc_nolock('\0', outfile) != EOF))
#else  /* _UNICODE */
    if ((_putc_nolock('\0', outfile) != EOF) && (_putc_nolock('\0', outfile) != EOF))
#endif  /* _UNICODE */
    {
        return written;
    }
    /* the last putc failed, so it means there is not enough space in the buffer */
    return -2;
}

#endif  /* _SAFECRT_IMPL */

#ifndef _CFLTCVT
#define _CFLTCVT _cfltcvt
#endif  /* _CFLTCVT */

#ifndef _CLDCVT
#define _CLDCVT _cldcvt
#endif  /* _CLDCVT */

/* inline keyword is non-ANSI C7 extension */
#if !defined (_MSC_VER) || defined (__STDC__)
#define __inline static
#endif  /* !defined (_MSC_VER) || defined (__STDC__) */

#ifdef _MBCS
#undef  _MBCS
#endif  /* _MBCS */
#include <tchar.h>

/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type> near. */
#define LOCAL(x) static x __cdecl

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
#define LONG_IS_INT      1      /* 1 means long is same size as int */
#define SHORT_IS_INT     0      /* 1 means short is same size as int */
#define LONGDOUBLE_IS_DOUBLE 1  /* 1 means long double is same as double */
#define LONGLONG_IS_INT64 1     /* 1 means long long is same as int64 */
#if defined (_WIN64)
#define PTR_IS_INT       0      /* 1 means ptr is same size as int */
#define PTR_IS_LONG      0      /* 1 means ptr is same size as long */
#define PTR_IS_INT64     1      /* 1 means ptr is same size as int64 */
#else  /* defined (_WIN64) */
#define PTR_IS_INT       1      /* 1 means ptr is same size as int */
#define PTR_IS_LONG      1      /* 1 means ptr is same size as long */
#define PTR_IS_INT64     0      /* 1 means ptr is same size as int64 */
#endif  /* defined (_WIN64) */

#if LONGLONG_IS_INT64
    #define get_long_long_arg(x) (long long)get_int64_arg(x)
#endif  /* LONGLONG_IS_INT64 */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif  /* LONG_IS_INT */

#ifndef _UNICODE
#if SHORT_IS_INT
    #define get_short_arg(x) (short)get_int_arg(x)
#endif  /* SHORT_IS_INT */
#endif  /* _UNICODE */

#if PTR_IS_INT
    #define get_ptr_arg(x) (void *)(intptr_t)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)(intptr_t)get_long_arg(x)
#elif PTR_IS_INT64
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#else  /* PTR_IS_INT64 */
    #error Size of pointer must be same as size of int or long
#endif  /* PTR_IS_INT64 */



/* CONSTANTS */

/* size of conversion buffer (ANSI-specified minimum is 509) */

#define BUFFERSIZE    512
#define MAXPRECISION  BUFFERSIZE

#if BUFFERSIZE < _CVTBUFSIZE + 6
/*
 * Buffer needs to be big enough for default minimum precision
 * when converting floating point needs bigger buffer, and malloc
 * fails
 */
#error Conversion buffer too small for max double.
#endif  /* BUFFERSIZE < _CVTBUFSIZE + 6 */

/* flag definitions */
#define FL_SIGN       0x00001   /* put plus or minus in front */
#define FL_SIGNSP     0x00002   /* put space or minus in front */
#define FL_LEFT       0x00004   /* left justify */
#define FL_LEADZERO   0x00008   /* pad with leading zeros */
#define FL_LONG       0x00010   /* long value given */
#define FL_SHORT      0x00020   /* short value given */
#define FL_SIGNED     0x00040   /* signed data given */
#define FL_ALTERNATE  0x00080   /* alternate form requested */
#define FL_NEGATIVE   0x00100   /* value is negative */
#define FL_FORCEOCTAL 0x00200   /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x00400   /* long double value given */
#define FL_WIDECHAR   0x00800   /* wide characters */
#define FL_LONGLONG   0x01000   /* long long value given */
#define FL_I64        0x08000   /* __int64 value given */
#ifdef POSITIONAL_PARAMETERS
/* We set this flag if %I is passed without I32 or I64 */
#define FL_PTRSIZE 0x10000   /* platform dependent number */
#endif  /* POSITIONAL_PARAMETERS */

/* state definitions */
enum STATE {
    ST_NORMAL,          /* normal state; outputting literal chars */
    ST_PERCENT,         /* just read '%' */
    ST_FLAG,            /* just read flag character */
    ST_WIDTH,           /* just read width specifier */
    ST_DOT,             /* just read '.' */
    ST_PRECIS,          /* just read precision specifier */
    ST_SIZE,            /* just read size specifier */
    ST_TYPE             /* just read type specifier */
#ifdef FORMAT_VALIDATIONS
    ,ST_INVALID           /* Invalid format */
#endif  /* FORMAT_VALIDATIONS */

};

#ifdef FORMAT_VALIDATIONS
#define NUMSTATES (ST_INVALID + 1)
#else  /* FORMAT_VALIDATIONS */
#define NUMSTATES (ST_TYPE + 1)
#endif  /* FORMAT_VALIDATIONS */

/* character type values */
enum CHARTYPE {
    CH_OTHER,           /* character with no special meaning */
    CH_PERCENT,         /* '%' */
    CH_DOT,             /* '.' */
    CH_STAR,            /* '*' */
    CH_ZERO,            /* '0' */
    CH_DIGIT,           /* '1'..'9' */
    CH_FLAG,            /* ' ', '+', '-', '#' */
    CH_SIZE,            /* 'h', 'l', 'L', 'N', 'F', 'w' */
    CH_TYPE             /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
#if defined (_UNICODE) || defined (CPRFLAG) || defined (FORMAT_VALIDATIONS)
extern char *__nullstring;  /* string to print on null ptr */
extern wchar_t *__wnullstring;  /* string to print on null ptr */
#else  /* defined (_UNICODE) || defined (CPRFLAG) || defined (FORMAT_VALIDATIONS) */
char *__nullstring = "(null)";  /* string to print on null ptr */
wchar_t *__wnullstring = L"(null)";/* string to print on null ptr */
#endif  /* defined (_UNICODE) || defined (CPRFLAG) || defined (FORMAT_VALIDATIONS) */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketabc.c -- use this program to make       */
/* changes.                                                               */

#ifndef FORMAT_VALIDATIONS

#if defined (_UNICODE) || defined (CPRFLAG)
extern const char __lookuptable[];
#else  /* defined (_UNICODE) || defined (CPRFLAG) */
extern const char __lookuptable[] = {
 /* ' ' */  0x06,
 /* '!' */  0x00,
 /* '"' */  0x00,
 /* '#' */  0x06,
 /* '$' */  0x00,
 /* '%' */  0x01,
 /* '&' */  0x00,
 /* ''' */  0x00,
 /* '(' */  0x10,
 /* ')' */  0x00,
 /* '*' */  0x03,
 /* '+' */  0x06,
 /* ',' */  0x00,
 /* '-' */  0x06,
 /* '.' */  0x02,
 /* '/' */  0x10,
 /* '0' */  0x04,
 /* '1' */  0x45,
 /* '2' */  0x45,
 /* '3' */  0x45,
 /* '4' */  0x05,
 /* '5' */  0x05,
 /* '6' */  0x05,
 /* '7' */  0x05,
 /* '8' */  0x05,
 /* '9' */  0x35,
 /* ':' */  0x30,
 /* ';' */  0x00,
 /* '<' */  0x50,
 /* '=' */  0x00,
 /* '>' */  0x00,
 /* '?' */  0x00,
 /* '@' */  0x00,
#if defined (_SAFECRT_IMPL)
 /* 'A' */  0x20,       // Disable %A format
#else  /* defined (_SAFECRT_IMPL) */
 /* 'A' */  0x28,
#endif  /* defined (_SAFECRT_IMPL) */
 /* 'B' */  0x20,
 /* 'C' */  0x38,
 /* 'D' */  0x50,
 /* 'E' */  0x58,
 /* 'F' */  0x07,
 /* 'G' */  0x08,
 /* 'H' */  0x00,
 /* 'I' */  0x37,
 /* 'J' */  0x30,
 /* 'K' */  0x30,
 /* 'L' */  0x57,
 /* 'M' */  0x50,
 /* 'N' */  0x07,
 /* 'O' */  0x00,
 /* 'P' */  0x00,
 /* 'Q' */  0x20,
 /* 'R' */  0x20,
 /* 'S' */  0x08,
 /* 'T' */  0x00,
 /* 'U' */  0x00,
 /* 'V' */  0x00,
 /* 'W' */  0x00,
 /* 'X' */  0x08,
 /* 'Y' */  0x60,
 /* 'Z' */  0x68,
 /* '[' */  0x60,
 /* '\' */  0x60,
 /* ']' */  0x60,
 /* '^' */  0x60,
 /* '_' */  0x00,
 /* '`' */  0x00,
#if defined (_SAFECRT_IMPL)
 /* 'a' */  0x70,       // Disable %a format
#else  /* defined (_SAFECRT_IMPL) */
 /* 'a' */  0x78,
#endif  /* defined (_SAFECRT_IMPL) */
 /* 'b' */  0x70,
 /* 'c' */  0x78,
 /* 'd' */  0x78,
 /* 'e' */  0x78,
 /* 'f' */  0x78,
 /* 'g' */  0x08,
 /* 'h' */  0x07,
 /* 'i' */  0x08,
 /* 'j' */  0x00,
 /* 'k' */  0x00,
 /* 'l' */  0x07,
 /* 'm' */  0x00,
#if defined (_SAFECRT_IMPL)
 /* 'n' */  0x00,       // Disable %n format
#else  /* defined (_SAFECRT_IMPL) */
 /* 'n' */  0x08,
#endif  /* defined (_SAFECRT_IMPL) */
 /* 'o' */  0x08,
 /* 'p' */  0x08,
 /* 'q' */  0x00,
 /* 'r' */  0x00,
 /* 's' */  0x08,
 /* 't' */  0x00,
 /* 'u' */  0x08,
 /* 'v' */  0x00,
 /* 'w' */  0x07,
 /* 'x' */  0x08
};

#endif  /* defined (_UNICODE) || defined (CPRFLAG) */

#else  /* FORMAT_VALIDATIONS */

#if defined (_UNICODE) || defined (CPRFLAG) || defined (POSITIONAL_PARAMETERS)
extern const unsigned char __lookuptable_s[];
#else  /* defined (_UNICODE) || defined (CPRFLAG) || defined (POSITIONAL_PARAMETERS) */
extern const unsigned char __lookuptable_s[] = {
 /* ' ' */  0x06,
 /* '!' */  0x80,
 /* '"' */  0x80,
 /* '#' */  0x86,
 /* '$' */  0x80,
 /* '%' */  0x81,
 /* '&' */  0x80,
 /* ''' */  0x00,
 /* '(' */  0x00,
 /* ')' */  0x10,
 /* '*' */  0x03,
 /* '+' */  0x86,
 /* ',' */  0x80,
 /* '-' */  0x86,
 /* '.' */  0x82,
 /* '/' */  0x80,
 /* '0' */  0x14,
 /* '1' */  0x05,
 /* '2' */  0x05,
 /* '3' */  0x45,
 /* '4' */  0x45,
 /* '5' */  0x45,
 /* '6' */  0x85,
 /* '7' */  0x85,
 /* '8' */  0x85,
 /* '9' */  0x05,
 /* ':' */  0x00,
 /* ';' */  0x00,
 /* '<' */  0x30,
 /* '=' */  0x30,
 /* '>' */  0x80,
 /* '?' */  0x50,
 /* '@' */  0x80,
#if defined (_SAFECRT_IMPL)
 /* 'A' */  0x80,       // Disable %A format
#else  /* defined (_SAFECRT_IMPL) */
 /* 'A' */  0x88,
#endif  /* defined (_SAFECRT_IMPL) */
 /* 'B' */  0x00,
 /* 'C' */  0x08,
 /* 'D' */  0x00,
 /* 'E' */  0x28,
 /* 'F' */  0x27,
 /* 'G' */  0x38,
 /* 'H' */  0x50,
 /* 'I' */  0x57,
 /* 'J' */  0x80,
 /* 'K' */  0x00,
 /* 'L' */  0x07,
 /* 'M' */  0x00,
 /* 'N' */  0x37,
 /* 'O' */  0x30,
 /* 'P' */  0x30,
 /* 'Q' */  0x50,
 /* 'R' */  0x50,
 /* 'S' */  0x88,
 /* 'T' */  0x00,
 /* 'U' */  0x00,
 /* 'V' */  0x00,
 /* 'W' */  0x20,
 /* 'X' */  0x28,
 /* 'Y' */  0x80,
 /* 'Z' */  0x88,
 /* '[' */  0x80,
 /* '\' */  0x80,
 /* ']' */  0x00,
 /* '^' */  0x00,
 /* '_' */  0x00,
 /* '`' */  0x60,
#if defined (_SAFECRT_IMPL)
 /* 'a' */  0x60,       // Disable %a format
#else  /* defined (_SAFECRT_IMPL) */
 /* 'a' */  0x68,
#endif  /* defined (_SAFECRT_IMPL) */
 /* 'b' */  0x60,
 /* 'c' */  0x68,
 /* 'd' */  0x68,
 /* 'e' */  0x68,
 /* 'f' */  0x08,
 /* 'g' */  0x08,
 /* 'h' */  0x07,
 /* 'i' */  0x78,
 /* 'j' */  0x70,
 /* 'k' */  0x70,
 /* 'l' */  0x77,
 /* 'm' */  0x70,
 /* 'n' */  0x70,
 /* 'o' */  0x08,
 /* 'p' */  0x08,
 /* 'q' */  0x00,
 /* 'r' */  0x00,
 /* 's' */  0x08,
 /* 't' */  0x00,
 /* 'u' */  0x08,
 /* 'v' */  0x00,
 /* 'w' */  0x07,
 /* 'x' */  0x08
};
#endif  /* defined (_UNICODE) || defined (CPRFLAG) || defined (POSITIONAL_PARAMETERS) */

#endif  /* FORMAT_VALIDATIONS */

#ifdef POSITIONAL_PARAMETERS

#define POSITION_CHAR _T('$')

#define FORMAT_POSSCAN_PASS 0
#define FORMAT_OUTPUT_PASS 1

#define FMT_TYPE_NOTSET -1
#define FMT_TYPE_NONPOSITIONAL 0
#define FMT_TYPE_POSITIONAL 1

enum ARG_TYPE{
eblank,
e_int_arg,
#ifndef _UNICODE
e_short_arg,
#endif  /* _UNICODE */
e_ptr_arg,
e_int64_arg,
e_long_long_arg,
e_long_arg,
e_longdouble_arg,
e_double_arg
};

struct positional_param
{
    enum ARG_TYPE arg_type;
    va_list arg_ptr;
    TCHAR type;
    int flags;
};



#ifndef _UNICODE
#define _IS_FMTTYPE_WIDE(fl) ((fl & (FL_LONG|FL_WIDECHAR)) != 0)
#else  /* _UNICODE */
#define _IS_FMTTYPE_WIDE(fl) ((fl & FL_SHORT) == 0)
#endif  /* _UNICODE */

#define _IS_FMTTYPE_PTRSIZE(fl) ((fl & FL_PTRSIZE) != 0)
#define _IS_FMTTYPE_SHORT(fl) ((fl & FL_SHORT) != 0)

#define _IS_FMTTYPE_POINTER(type) (type == _T('p'))
#define _IS_FMTTYPE_STRING(type) ( (type == _T('s')) || (type == _T('S')) )
#define _IS_FMTTYPE_NUMERIC(type) ( (type == _T('d')) || (type == _T('i')) || (type == _T('o')) || \
                              (type == _T('u')) || (type == _T('x')) || (type == _T('X')) )

#ifdef _UNICODE
#define _tvalidate_param_reuse _validate_param_reuseW
#else  /* _UNICODE */
#define _tvalidate_param_reuse _validate_param_reuseA
#endif  /* _UNICODE */


/***
*int _tvalidate_param_reuse(struct positional_param * pos, enum ARG_TYPE get_fn_type, TCHAR cur_type, int cur_flags)
*
*Purpose:
*   Validates if the reused positional parameter is doesn't breaking any rules.
*   a) %p - shouldn't be mixed with other format types.
*   b) Wide & Ansi strings shouldn't be mixed
*   c) Numeric types shouldn't mix if their sizes are different
*   d) %I (without I32 or I64) shouldn't mix with other numeric types
*
*Entry:
*   struct positional_param * pos
*   enum ARG_TYPE get_fn_type
*   TCHAR cur_type
*   int cur_flags
*
*Exit:
*   Returns 0 if any non-allowed reuse is happening otherwise 1
*
*******************************************************************************/

#ifndef CPRFLAG
int _tvalidate_param_reuse(struct positional_param * pos, enum ARG_TYPE get_fn_type, TCHAR cur_type, int cur_flags)
{
    int stored_value = 0 ;
    int new_value = 0 ;

    if(_IS_FMTTYPE_POINTER(pos->type) || _IS_FMTTYPE_POINTER(cur_type))
    {
        /* %p param shouldn't be mixed with other types. If both are %p,
        then we don't need to do any more validations */
        return (pos->type == cur_type) ;
    }

    stored_value = _IS_FMTTYPE_STRING(pos->type);
    new_value = _IS_FMTTYPE_STRING(cur_type);

    if(stored_value || new_value)
    {
        /* If one type is a string, then the other also should be a string. Also
           Wide & Ansi String parameters shouldn't be interchangebly used.
           If these conditions are met, we don't need to do any more validations.
        */
        return ( (stored_value == new_value) && (_IS_FMTTYPE_WIDE(pos->flags) == _IS_FMTTYPE_WIDE(cur_flags)) );
    }

    if( _IS_FMTTYPE_NUMERIC(pos->type) || _IS_FMTTYPE_NUMERIC(cur_type))
    {
        /* If one type is numeric, then the other should also be numeric. */
        if (_IS_FMTTYPE_NUMERIC(pos->type) != _IS_FMTTYPE_NUMERIC(cur_type))
            return 0;

        /* For Numeric Types, we should allow mixing only if the size is the
        same. Also, we shouldn't allow %I (without 32/64) which is platform
        dependent to mix with other fixed numeric types */
        if( (_IS_FMTTYPE_PTRSIZE(pos->flags) != _IS_FMTTYPE_PTRSIZE(cur_flags)) ||
            (_IS_FMTTYPE_SHORT(pos->flags) != _IS_FMTTYPE_SHORT(cur_flags)) )
        {
            return 0;
        }
    }

    return (pos->arg_type == get_fn_type);
}
#else  /* CPRFLAG */
int _tvalidate_param_reuse(struct positional_param * pos, enum ARG_TYPE get_fn_type, TCHAR cur_type, int cur_flags);
#endif  /* CPRFLAG */

#define STORE_ARGPTR(pos_struct, get_fn_type, pos, cur_type, cur_flags) \
        if(pos_struct[pos].arg_type == eblank) \
        { \
            pos_struct[pos].arg_type = get_fn_type; \
            pos_struct[pos].type = cur_type; \
            pos_struct[pos].flags = cur_flags; \
        } \
        else \
        { \
            _VALIDATE_RETURN(_tvalidate_param_reuse(&pos_struct[pos], get_fn_type, cur_type, cur_flags), EINVAL, -1); \
        }


#define GET_ARG(get_fn_type, arg_ptr, lhs, type) { va_list lst = arg_ptr ;lhs = type get_fn_type(&lst);}

#endif  /* POSITIONAL_PARAMETERS */

#define FIND_CHAR_CLASS(lookuptbl, c)      \
        ((c) < _T(' ') || (c) > _T('x') ? \
            CH_OTHER            \
            :               \
        (enum CHARTYPE)(lookuptbl[(c)-_T(' ')] & 0xF))

#define FIND_NEXT_STATE(lookuptbl, class, state)   \
        (enum STATE)(lookuptbl[(class) * NUMSTATES + (state)] >> 4)

/*
 * Note: CPRFLAG and _UNICODE cases are currently mutually exclusive.
 */

/* prototypes */

#ifdef CPRFLAG

#define WRITE_CHAR(ch, pnw)         write_char(ch, pnw)
#define WRITE_MULTI_CHAR(ch, num, pnw)  write_multi_char(ch, num, pnw)
#define WRITE_STRING(s, len, pnw)   write_string(s, len, pnw)
#define WRITE_WSTRING(s, len, pnw)  write_wstring(s, len, pnw)

LOCAL(void) write_char(_TCHAR ch, int *pnumwritten);
LOCAL(void) write_multi_char(_TCHAR ch, int num, int *pnumwritten);
LOCAL(void) write_string(_TCHAR *string, int len, int *numwritten);
LOCAL(void) write_wstring(wchar_t *string, int len, int *numwritten);

#else  /* CPRFLAG */

#define WRITE_CHAR(ch, pnw)         write_char(ch, stream, pnw)
#define WRITE_MULTI_CHAR(ch, num, pnw)  write_multi_char(ch, num, stream, pnw)
#define WRITE_STRING(s, len, pnw)   write_string(s, len, stream, pnw)
#define WRITE_WSTRING(s, len, pnw)  write_wstring(s, len, stream, pnw)

LOCAL(void) write_char(_TCHAR ch, FILE *f, int *pnumwritten);
LOCAL(void) write_multi_char(_TCHAR ch, int num, FILE *f, int *pnumwritten);
LOCAL(void) write_string(_TCHAR *string, int len, FILE *f, int *numwritten);
LOCAL(void) write_wstring(wchar_t *string, int len, FILE *f, int *numwritten);

#endif  /* CPRFLAG */

__inline int __cdecl get_int_arg(va_list *pargptr);

#ifndef _UNICODE
#if !SHORT_IS_INT
__inline short __cdecl get_short_arg(va_list *pargptr);
#endif  /* !SHORT_IS_INT */
#endif  /* _UNICODE */

#if !LONG_IS_INT
__inline long __cdecl get_long_arg(va_list *pargptr);
#endif  /* !LONG_IS_INT */

#if !LONGLONG_IS_INT64
__inline long long __cdecl get_long_long_arg(va_list *pargptr);
#endif  /* !LONGLONG_IS_INT64 */

__inline __int64 __cdecl get_int64_arg(va_list *pargptr);

#ifdef POSITIONAL_PARAMETERS
#if !LONGDOUBLE_IS_DOUBLE
__inline _LONGDOUBLE __cdecl get_longdouble_arg(va_list *pargptr);
#else  /* !LONGDOUBLE_IS_DOUBLE */
__inline _CRT_DOUBLE __cdecl get_crtdouble_arg(va_list *pargptr);
#endif  /* !LONGDOUBLE_IS_DOUBLE */
#endif  /* POSITIONAL_PARAMETERS */

#ifdef CPRFLAG
LOCAL(int) output(const _TCHAR *, _locale_t , va_list);
_CRTIMP int __cdecl _vtcprintf_l (const _TCHAR *, _locale_t, va_list);
_CRTIMP int __cdecl _vtcprintf_s_l (const _TCHAR *, _locale_t, va_list);
_CRTIMP int __cdecl _vtcprintf_p_l (const _TCHAR *, _locale_t, va_list);


/***
*int _cprintf(format, arglist) - write formatted output directly to console
*
*Purpose:
*   Writes formatted data like printf, but uses console I/O functions.
*
*Entry:
*   char *format - format string to determine data formats
*   arglist - list of POINTERS to where to put data
*
*Exit:
*   returns number of characters written
*
*Exceptions:
*
*******************************************************************************/
#ifndef FORMAT_VALIDATIONS
_CRTIMP int __cdecl _tcprintf_l (
        const _TCHAR * format,
        _locale_t plocinfo,
        ...
        )
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
_CRTIMP int __cdecl _tcprintf_p_l (
        const _TCHAR * format,
        _locale_t plocinfo,
        ...
        )
#else  /* POSITIONAL_PARAMETERS */
_CRTIMP int __cdecl _tcprintf_s_l (
        const _TCHAR * format,
        _locale_t plocinfo,
        ...
        )
#endif  /* POSITIONAL_PARAMETERS */
#endif  /* FORMAT_VALIDATIONS */

{
        va_list arglist;
        va_start(arglist, plocinfo);

#ifndef FORMAT_VALIDATIONS
        return _vtcprintf_l(format, plocinfo, arglist);
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
        return _vtcprintf_p_l(format, plocinfo, arglist);
#else  /* POSITIONAL_PARAMETERS */
        return _vtcprintf_s_l(format, plocinfo, arglist);
#endif  /* POSITIONAL_PARAMETERS */

#endif  /* FORMAT_VALIDATIONS */

}

#ifndef FORMAT_VALIDATIONS
_CRTIMP int __cdecl _tcprintf (
        const _TCHAR * format,
        ...
        )
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
_CRTIMP int __cdecl _tcprintf_p (
        const _TCHAR * format,
        ...
        )
#else  /* POSITIONAL_PARAMETERS */
_CRTIMP int __cdecl _tcprintf_s (
        const _TCHAR * format,
        ...
        )
#endif  /* POSITIONAL_PARAMETERS */
#endif  /* FORMAT_VALIDATIONS */

{
        va_list arglist;

        va_start(arglist, format);

#ifndef FORMAT_VALIDATIONS
        return _vtcprintf_l(format, NULL, arglist);
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
        return _vtcprintf_p_l(format, NULL, arglist);
#else  /* POSITIONAL_PARAMETERS */
        return _vtcprintf_s_l(format, NULL, arglist);
#endif  /* POSITIONAL_PARAMETERS */

#endif  /* FORMAT_VALIDATIONS */

}

#endif  /* CPRFLAG */


/***
*int _output(stream, format, argptr), static int output(format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, _output assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   FILE *stream   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*ifdef _UNICODE
*   The wide-character flavour returns the number of wide-characters written.
*endif
*
*Exceptions:
*
*******************************************************************************/
#ifdef CPRFLAG
#ifndef FORMAT_VALIDATIONS
_CRTIMP int __cdecl _vtcprintf (
    const _TCHAR *format,
    va_list argptr
    )
{
    return _vtcprintf_l(format, NULL, argptr);
}

#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
_CRTIMP int __cdecl _vtcprintf_p (
    const _TCHAR *format,
    va_list argptr
    )
{
    return _vtcprintf_p_l(format, NULL, argptr);
}

#else  /* POSITIONAL_PARAMETERS */
_CRTIMP int __cdecl _vtcprintf_s (
    const _TCHAR *format,
    va_list argptr
    )
{
    return _vtcprintf_s_l(format, NULL, argptr);
}

#endif  /* POSITIONAL_PARAMETERS */
#endif  /* FORMAT_VALIDATIONS */
#endif  /* CPRFLAG */

#ifdef CPRFLAG
#ifndef FORMAT_VALIDATIONS
_CRTIMP int __cdecl _vtcprintf_l (
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
_CRTIMP int __cdecl _vtcprintf_p_l (
#else  /* POSITIONAL_PARAMETERS */
_CRTIMP int __cdecl _vtcprintf_s_l (
#endif  /* POSITIONAL_PARAMETERS */
#endif  /* FORMAT_VALIDATIONS */
#else  /* CPRFLAG */

#ifdef _UNICODE
#ifndef FORMAT_VALIDATIONS
#ifdef _SAFECRT_IMPL
int __cdecl _woutput (
#else  /* _SAFECRT_IMPL */
int __cdecl _woutput_l (
#endif  /* _SAFECRT_IMPL */
    FILE *stream,
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
#ifdef _SAFECRT_IMPL
int __cdecl _woutput_p (
#else  /* _SAFECRT_IMPL */
int __cdecl _woutput_p_l (
#endif  /* _SAFECRT_IMPL */
    FILE *stream,
#else  /* POSITIONAL_PARAMETERS */
#ifdef _SAFECRT_IMPL
int __cdecl _woutput_s (
#else  /* _SAFECRT_IMPL */
int __cdecl _woutput_s_l (
#endif  /* _SAFECRT_IMPL */
    FILE *stream,
#endif  /* POSITIONAL_PARAMETERS */
#endif  /* FORMAT_VALIDATIONS */
#else  /* _UNICODE */
#ifndef FORMAT_VALIDATIONS
#ifdef _SAFECRT_IMPL
int __cdecl _output (
#else  /* _SAFECRT_IMPL */
int __cdecl _output_l (
#endif  /* _SAFECRT_IMPL */
    FILE *stream,
#else  /* FORMAT_VALIDATIONS */
#ifdef POSITIONAL_PARAMETERS
#ifdef _SAFECRT_IMPL
    int __cdecl _output_p (
#else  /* _SAFECRT_IMPL */
    int __cdecl _output_p_l (
#endif  /* _SAFECRT_IMPL */
    FILE *stream,
#else  /* POSITIONAL_PARAMETERS */
#ifdef _SAFECRT_IMPL
    int __cdecl _output_s (
#else  /* _SAFECRT_IMPL */
    int __cdecl _output_s_l (
#endif  /* _SAFECRT_IMPL */
    FILE *stream,
#endif  /* POSITIONAL_PARAMETERS */

#endif  /* FORMAT_VALIDATIONS */
#endif  /* _UNICODE */

#endif  /* CPRFLAG */
    const _TCHAR *format,
#ifndef _SAFECRT_IMPL
    _locale_t plocinfo,
#endif  /* _SAFECRT_IMPL */
    va_list argptr
    )
{
    int hexadd=0;     /* offset to add to number to get 'a'..'f' */
    TCHAR ch;       /* character just read */
    int flags=0;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;      /* current conversion radix */
    int charsout;   /* characters currently written so far, -1 = IO error */
    int fldwidth = 0;   /* selected field width -- 0 means default */
    int precision = 0;  /* selected precision  -- -1 means default */
    TCHAR prefix[2];    /* numeric prefix -- up to two characters */
    int prefixlen=0;  /* length of prefix -- 0 means no prefix */
    int capexp;     /* non-zero = 'E' exponent signifient, zero = 'e' */
    int no_output=0;  /* non-zero = prodcue no output for this specifier */
    union {
        char *sz;   /* pointer text to be printed, not zero terminated */
        wchar_t *wz;
        } text;

    int textlen;    /* length of the text in bytes/wchars to be printed.
                       textlen is in multibyte or wide chars if _UNICODE */
    union {
        char sz[BUFFERSIZE];
#ifdef _UNICODE
        wchar_t wz[BUFFERSIZE];
#endif  /* _UNICODE */
        } buffer;
    wchar_t wchar;                      /* temp wchar_t */
    int buffersize;                     /* size of text.sz (used only for the call to _cfltcvt) */
    int bufferiswide=0;         /* non-zero = buffer contains wide chars already */

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */

#ifdef POSITIONAL_PARAMETERS
    /* Used for parsing the format */
    const _TCHAR * saved_format = NULL;
    _TCHAR * end_pos = NULL;

    /* This is the structure which stores the values corresponding to
    each positional param */
    struct positional_param pos_value[_ARGMAX];

    int pass = 0;        /* Ctr for scanning the format string in diff passes */
    int noofpasses = 0;  /* Set to 2 for positional formats, otherwise 1      */
    int max_pos = -1;    /* Keeping track of the current max positional arg   */
    int type_pos = -1;   /* position of an arg denoting a type                */
    int width_pos = -1;  /* position of an arg denoting width                 */
    int precis_pos = -1; /* position of an arg denoting precision             */
    int format_type = FMT_TYPE_NOTSET; /* type of format string               */
#endif  /* POSITIONAL_PARAMETERS */

    char *heapbuf = NULL; /* non-zero = test.sz using heap buffer to be freed */

#ifndef CPRFLAG
    _VALIDATE_RETURN( (stream != NULL), EINVAL, -1);
#ifndef _UNICODE
    _VALIDATE_STREAM_ANSI_RETURN(stream, EINVAL, EOF);
#endif  /* _UNICODE */
#endif  /* CPRFLAG */
    _VALIDATE_RETURN( (format != NULL), EINVAL, -1);

    charsout = 0;       /* no characters written yet */
#ifdef POSITIONAL_PARAMETERS

    saved_format = format;

    for(pass = 0 ; pass < 2; ++pass)
    {

        if((pass == FORMAT_OUTPUT_PASS) && (format_type == FMT_TYPE_NONPOSITIONAL))
        {
            /* If in pass2, we still have format_type isn't positional, it means
            that we do not need a 2nd pass */
            break;
        }
#endif  /* POSITIONAL_PARAMETERS */
    textlen = 0;        /* no text yet */
    state = ST_NORMAL;  /* starting state */
    heapbuf = NULL;     /* not using heap-allocated buffer */
    buffersize = 0;
#ifdef POSITIONAL_PARAMETERS
    max_pos = -1;
    fldwidth = 0;
    precision = 0;
    format = saved_format;
    type_pos = -1;
    width_pos = -1;
    precis_pos = -1;

    /* All chars before the first format specifier get output in the first
    pass itself. Hence we have to reset format_type to FMT_TYPE_NOTSET to ensure
    that they do not get output again in the 2nd pass */
    format_type = FMT_TYPE_NOTSET;
#endif  /* POSITIONAL_PARAMETERS */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != _T('\0') && charsout >= 0) {
#ifndef FORMAT_VALIDATIONS
        chclass = FIND_CHAR_CLASS(__lookuptable, ch);  /* find character class */
        state = FIND_NEXT_STATE(__lookuptable, chclass, state); /* find next state */
#else  /* FORMAT_VALIDATIONS */
        chclass = FIND_CHAR_CLASS(__lookuptable_s, ch);  /* find character class */
        state = FIND_NEXT_STATE(__lookuptable_s, chclass, state); /* find next state */

#ifdef POSITIONAL_PARAMETERS
        if((state == ST_PERCENT) && (*format != _T('%')))
        {
            if(format_type == FMT_TYPE_NOTSET)
            {
                /* We set the value of format_type when we hit the first type specifier */
                if(_tcstol(format, &end_pos, 10) > 0 && (*end_pos == POSITION_CHAR))
                {
                    if(pass == FORMAT_POSSCAN_PASS)
                    {
                        memset(pos_value,0,sizeof(pos_value));
                    }
                    format_type = FMT_TYPE_POSITIONAL;
                }
                else
                {
                    format_type = FMT_TYPE_NONPOSITIONAL;
                }
            }

            if(format_type == FMT_TYPE_POSITIONAL)
            {
                type_pos = _tcstol(format, &end_pos, 10) - 1;
                format = end_pos + 1;

                if(pass == FORMAT_POSSCAN_PASS)
                {
                    /* We don't redo the validations in the 2nd pass */
                    _VALIDATE_RETURN(((type_pos >= 0) && (*end_pos == POSITION_CHAR) && (type_pos < _ARGMAX)), EINVAL, -1);

                    /* Update max_pos with the current maximum pos argument */
                    max_pos = type_pos > max_pos ? type_pos : max_pos;
                }
            }

        }
        else
        {
            /* If state is ST_INVALID, that means an invalid format specifier */
                        if (state == ST_INVALID)
                                _VALIDATE_RETURN(("Incorrect format specifier", 0), EINVAL, -1);
        }
#else  /* POSITIONAL_PARAMETERS */
                if (state == ST_INVALID)
                _VALIDATE_RETURN(("Incorrect format specifier", 0), EINVAL, -1);
#endif  /* POSITIONAL_PARAMETERS */

#endif  /* FORMAT_VALIDATIONS */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:

#ifdef POSITIONAL_PARAMETERS
            if(((pass == FORMAT_POSSCAN_PASS) && (format_type == FMT_TYPE_POSITIONAL))
            || ((pass == FORMAT_OUTPUT_PASS) && (format_type == FMT_TYPE_NOTSET)))
            {

                /* Do not output in the 1st pass, if we have already come across
                a positional format specifier. All chars before the first format
                specifier get output in the first pass itself. Hence we need to
                check the format_type to make sure that they don't get output
                again in the 2nd pass */
                    break;
            }
#endif  /* POSITIONAL_PARAMETERS */
        NORMAL_STATE:

            /* normal state -- just write character */
#ifdef _UNICODE
            bufferiswide = 1;
#else  /* _UNICODE */
            bufferiswide = 0;
#ifdef _SAFECRT_IMPL
            if (isleadbyte((unsigned char)ch)) {
#else  /* _SAFECRT_IMPL */
            if (_isleadbyte_l((unsigned char)ch, _loc_update.GetLocaleT())) {
#endif  /* _SAFECRT_IMPL */
                WRITE_CHAR(ch, &charsout);
                ch = *format++;
                /* don't fall off format string */
                _VALIDATE_RETURN( (ch != _T('\0')), EINVAL, -1);
            }
#endif  /* _UNICODE */
            WRITE_CHAR(ch, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            bufferiswide = 0;   /* default */
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case _T('-'):
                flags |= FL_LEFT;   /* '-' => left justify */
                break;
            case _T('+'):
                flags |= FL_SIGN;   /* '+' => force sign indicator */
                break;
            case _T(' '):
                flags |= FL_SIGNSP; /* ' ' => force sign or space */
                break;
            case _T('#'):
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case _T('0'):
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == _T('*')) {
                /* get width from arg list */
#ifdef POSITIONAL_PARAMETERS
                if(format_type == FMT_TYPE_NONPOSITIONAL)
                {
#endif  /* POSITIONAL_PARAMETERS */
                fldwidth = get_int_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                }
                else
                {
                    width_pos = _tcstol(format, &end_pos, 10) - 1;
                    format = end_pos + 1;

                    if(pass == FORMAT_POSSCAN_PASS)
                    {
                        _VALIDATE_RETURN(((width_pos >= 0) && (*end_pos == POSITION_CHAR) && (type_pos < _ARGMAX)), EINVAL, -1);

                        /* Update max_pos with the current maximum pos argument */
                        max_pos = width_pos > max_pos ? width_pos : max_pos;

                        STORE_ARGPTR(pos_value, e_int_arg, width_pos, ch, flags)
                        break;

                    }
                    else
                    {
                        /* get width from arg list */
                        GET_ARG(get_int_arg,pos_value[width_pos].arg_ptr, fldwidth, )
                    }

                }
#endif  /* POSITIONAL_PARAMETERS */
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - _T('0'));
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == _T('*')) {
                /* get precision from arg list */
#ifdef POSITIONAL_PARAMETERS
                if(format_type == FMT_TYPE_NONPOSITIONAL)
                {
#endif  /* POSITIONAL_PARAMETERS */
                precision = get_int_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                }
                else
                {
                    precis_pos = _tcstol(format, &end_pos, 10) - 1;
                    format = end_pos + 1;

                    if(pass == FORMAT_POSSCAN_PASS)
                    {
                        _VALIDATE_RETURN(((precis_pos >= 0) && (*end_pos == POSITION_CHAR) && (type_pos < _ARGMAX)), EINVAL, -1);

                        /* Update max_pos with the current maximum pos argument */
                        max_pos = precis_pos > max_pos ? precis_pos : max_pos;

                        STORE_ARGPTR(pos_value, e_int_arg, precis_pos, ch, flags)
                        break;
                    }
                    else
                    {
                        /* get width from arg list */
                        GET_ARG(get_int_arg,pos_value[precis_pos].arg_ptr, precision, )
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */
                if (precision < 0)
                    precision = -1; /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - _T('0'));
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
            case _T('l'):
                /*
                 * In order to handle the ll case, we depart from the
                 * simple deterministic state machine.
                 */
                if (*format == _T('l'))
                {
                    ++format;
                    flags |= FL_LONGLONG;   /* 'll' => long long */
                }
                else
                {
                    flags |= FL_LONG;   /* 'l' => long int or wchar_t */
                }
                break;

            case _T('I'):
                /*
                 * In order to handle the I, I32, and I64 size modifiers, we
                 * depart from the simple deterministic state machine. The
                 * code below scans for characters following the 'I',
                 * and defaults to 64 bit on WIN64 and 32 bit on WIN32
                 */
#if PTR_IS_INT64
                flags |= FL_I64;    /* 'I' => __int64 on WIN64 systems */
#endif  /* PTR_IS_INT64 */
                if ( (*format == _T('6')) && (*(format + 1) == _T('4')) )
                {
                    format += 2;
                    flags |= FL_I64;    /* I64 => __int64 */
                }
                else if ( (*format == _T('3')) && (*(format + 1) == _T('2')) )
                {
                    format += 2;
                    flags &= ~FL_I64;   /* I32 => __int32 */
                }
                else if ( (*format == _T('d')) ||
                          (*format == _T('i')) ||
                          (*format == _T('o')) ||
                          (*format == _T('u')) ||
                          (*format == _T('x')) ||
                          (*format == _T('X')) )
                {
#ifdef POSITIONAL_PARAMETERS
    /* %I without 32/64 is platform dependent. We set FL_PTRSIZE to indicate
    this - this is used in the positional parameter reuse validation */
                    flags |= FL_PTRSIZE;
#else  /* POSITIONAL_PARAMETERS */
                   /*
                    * Nothing further needed.  %Id (et al) is
                    * handled just like %d, except that it defaults to 64 bits
                    * on WIN64.  Fall through to the next iteration.
                    */
#endif  /* POSITIONAL_PARAMETERS */
                }
                else {
                    state = ST_NORMAL;
                    goto NORMAL_STATE;
                }
                break;

            case _T('h'):
                flags |= FL_SHORT;  /* 'h' => short int or char */
                break;

            case _T('w'):
                flags |= FL_WIDECHAR;  /* 'w' => wide character */
                break;

            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is done in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case _T('C'):   /* ISO wide character */
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
#ifdef _UNICODE
                    flags |= FL_SHORT;
#else  /* _UNICODE */
                    flags |= FL_WIDECHAR;   /* ISO std. */
#endif  /* _UNICODE */
                /* fall into 'c' case */

            case _T('c'): {
                /* print a single character specified by int argument */
#ifdef _UNICODE
                bufferiswide = 1;
#ifdef POSITIONAL_PARAMETERS
                if(format_type == FMT_TYPE_NONPOSITIONAL)
                {
#endif  /* POSITIONAL_PARAMETERS */
                        wchar = (wchar_t) get_int_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                }
                else
                {
                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                        if (pass == FORMAT_POSSCAN_PASS)
                        {
                                STORE_ARGPTR(pos_value, e_int_arg, type_pos, ch, flags)
                                break;
                        }
                        else
                        {
                                GET_ARG(get_int_arg,pos_value[type_pos].arg_ptr, wchar, (wchar_t))
                        }
                }
#endif  /* POSITIONAL_PARAMETERS */
                if (flags & FL_SHORT) {
                    /* format multibyte character */
                    /* this is an extension of ANSI */
                    char tempchar[2];
                    {
                        tempchar[0] = (char)(wchar & 0x00ff);
                        tempchar[1] = '\0';
                    }

#ifdef _SAFECRT_IMPL
                    if (_MBTOWC(buffer.wz,tempchar, MB_CUR_MAX) < 0)
#else  /* _SAFECRT_IMPL */
                    if (_mbtowc_l(buffer.wz,
                                  tempchar,
                                  _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                  _loc_update.GetLocaleT()) < 0)
#endif  /* _SAFECRT_IMPL */
                    {
                        /* ignore if conversion was unsuccessful */
                        no_output = 1;
                    }
                } else {
                    buffer.wz[0] = wchar;
                }
                text.wz = buffer.wz;
                textlen = 1;    /* print just a single character */
#else  /* _UNICODE */
                if (flags & (FL_LONG|FL_WIDECHAR)) {
                    errno_t e = 0;
#ifdef POSITIONAL_PARAMETERS
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    wchar = (wchar_t) get_short_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                        if (pass == FORMAT_POSSCAN_PASS)
                        {
                            STORE_ARGPTR(pos_value, e_short_arg, type_pos, ch, flags)
                            break;
                        }
                        else
                        {
                            GET_ARG(get_short_arg,pos_value[type_pos].arg_ptr, wchar, (wchar_t))
                        }
                    }
#endif  /* POSITIONAL_PARAMETERS */
                    /* convert to multibyte character */
                    e = _WCTOMB_S(&textlen, buffer.sz, _countof(buffer.sz), wchar);

                    /* check that conversion was successful */
                    if (e != 0)
                        no_output = 1;
                } else {
                    /* format multibyte character */
                    /* this is an extension of ANSI */
                    unsigned short temp;
#ifdef POSITIONAL_PARAMETERS
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    temp = (unsigned short) get_int_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                        if (pass == FORMAT_POSSCAN_PASS)
                        {
                            STORE_ARGPTR(pos_value, e_int_arg, type_pos, ch, flags)
                            break;
                        }
                        else
                        {
                            GET_ARG(get_int_arg,pos_value[type_pos].arg_ptr, temp, (unsigned short))
                        }
                    }
#endif  /* POSITIONAL_PARAMETERS */
                    {
                        buffer.sz[0] = (char) temp;
                        textlen = 1;
                    }
                }
                text.sz = buffer.sz;
#endif  /* _UNICODE */
            }
            break;

            case _T('Z'): {
                /* print a Counted String

                int i;
                char *p;       /* temps */
                struct _count_string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

#ifdef POSITIONAL_PARAMETERS
                if(format_type == FMT_TYPE_NONPOSITIONAL)
                {
#endif  /* POSITIONAL_PARAMETERS */
                pstr = (struct _count_string *)get_ptr_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                }
                else
                {
                    _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                    if (pass == FORMAT_POSSCAN_PASS)
                    {
                        STORE_ARGPTR(pos_value, e_ptr_arg, type_pos, ch, flags)
                        break;
                    }
                    else
                    {
                        GET_ARG(get_ptr_arg,pos_value[type_pos].arg_ptr, pstr, (struct _count_string *) )
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text.sz = __nullstring;
                    textlen = (int)strlen(text.sz);
                } else {
                    if (flags & FL_WIDECHAR) {
                        text.wz = (wchar_t *)pstr->Buffer;
                        textlen = pstr->Length / (int)sizeof(wchar_t);
                        bufferiswide = 1;
                    } else {
                        bufferiswide = 0;
                        text.sz = pstr->Buffer;
                        textlen = pstr->Length;
                    }
                }
            }
            break;

            case _T('S'):   /* ISO wide character string */
#ifndef _UNICODE
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
                    flags |= FL_WIDECHAR;
#else  /* _UNICODE */
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
                    flags |= FL_SHORT;
#endif  /* _UNICODE */

            case _T('s'): {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */
                wchar_t *pwch;

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;
#ifdef POSITIONAL_PARAMETERS
                if(format_type == FMT_TYPE_NONPOSITIONAL)
                {
#endif  /* POSITIONAL_PARAMETERS */
                text.sz = (char *)get_ptr_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                }
                else
                {
                    _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                    if (pass == FORMAT_POSSCAN_PASS)
                    {
                        STORE_ARGPTR(pos_value, e_ptr_arg, type_pos, ch, flags)
                        break;
                    }
                    else
                    {
                        GET_ARG(get_ptr_arg,pos_value[type_pos].arg_ptr, text.sz,(char *))
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */

                /* scan for null upto i characters */
#ifdef _UNICODE
                if (flags & FL_SHORT) {
                    if (text.sz == NULL) /* NULL passed, use special string */
                        text.sz = __nullstring;
                    p = text.sz;
                    for (textlen=0; textlen<i && *p; textlen++) {
#ifdef _SAFECRT_IMPL
                        if (isleadbyte((unsigned char)(*p)))
#else  /* _SAFECRT_IMPL */
                        if (_isleadbyte_l((unsigned char)(*p), _loc_update.GetLocaleT()))
#endif  /* _SAFECRT_IMPL */
                            ++p;
                        ++p;
                    }
                    /* textlen now contains length in multibyte chars */
                } else {
                    if (text.wz == NULL) /* NULL passed, use special string */
                        text.wz = __wnullstring;
                    bufferiswide = 1;
                    pwch = text.wz;
                    while (i-- && *pwch)
                        ++pwch;
                    textlen = (int)(pwch - text.wz);       /* in wchar_ts */
                    /* textlen now contains length in wide chars */
                }
#else  /* _UNICODE */
                if (flags & (FL_LONG|FL_WIDECHAR)) {
                    if (text.wz == NULL) /* NULL passed, use special string */
                        text.wz = __wnullstring;
                    bufferiswide = 1;
                    pwch = text.wz;
                    while ( i-- && *pwch )
                        ++pwch;
                    textlen = (int)(pwch - text.wz);
                    /* textlen now contains length in wide chars */
                } else {
                    if (text.sz == NULL) /* NULL passed, use special string */
                        text.sz = __nullstring;
                    p = text.sz;
                    while (i-- && *p)
                        ++p;
                    textlen = (int)(p - text.sz);    /* length of the string */
                }

#endif  /* _UNICODE */
            }
            break;


            case _T('n'): {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;        /* temp */

#ifdef POSITIONAL_PARAMETERS
                if(format_type == FMT_TYPE_NONPOSITIONAL)
                {
#endif  /* POSITIONAL_PARAMETERS */
                p = get_ptr_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                }
                else
                {
                    _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                    if (pass == FORMAT_POSSCAN_PASS)
                    {
                        STORE_ARGPTR(pos_value, e_ptr_arg, type_pos, ch, flags)
                        break;
                    }
                    else
                    {
                        GET_ARG(get_ptr_arg,pos_value[type_pos].arg_ptr,p,)
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */

                /* if %n is disabled, we skip an arg and print 'n' */
                if ( !_get_printf_count_output() )
                {
                    _VALIDATE_RETURN(("'n' format specifier disabled", 0), EINVAL, -1);
                    break;
                }

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif  /* !LONG_IS_INT */

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif  /* !SHORT_IS_INT */
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;

            case _T('E'):
            case _T('G'):
            case _T('A'):
                capexp = 1;                 /* capitalize exponent */
                ch += _T('a') - _T('A');    /* convert format char to lower */
                /* DROP THROUGH */
            case _T('e'):
            case _T('f'):
            case _T('g'):
            case _T('a'): {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
#ifdef POSITIONAL_PARAMETERS
                if((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
                {
                    _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

#if !LONGDOUBLE_IS_DOUBLE

                    if (flags & FL_LONGDOUBLE)
                    {
                        STORE_ARGPTR(pos_value, e_longdouble_arg, type_pos, ch, flags)
                    }
                    else
#endif  /* !LONGDOUBLE_IS_DOUBLE */
                    {
                        STORE_ARGPTR(pos_value, e_double_arg, type_pos, ch, flags)
                    }

                    break;
                }
#endif  /* POSITIONAL_PARAMETERS */
                text.sz = buffer.sz;        /* put result in buffer */
                buffersize = BUFFERSIZE;

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;          /* default precision: 6 */
                else if (precision == 0 && ch == _T('g'))
                    precision = 1;          /* ANSI specified */
                else if (precision > MAXPRECISION)
                    precision = MAXPRECISION;

                if (precision > BUFFERSIZE - _CVTBUFSIZE) {
                    /* conversion will potentially overflow local buffer */
                    /* so we need to use a heap-allocated buffer.        */
                    heapbuf = (char *)_malloc_crt(_CVTBUFSIZE + precision);
                    if (heapbuf != NULL)
                    {
                        text.sz = heapbuf;
                        buffersize = _CVTBUFSIZE + precision;
                    }
                    else
                        /* malloc failed, cap precision further */
                        precision = BUFFERSIZE - _CVTBUFSIZE;
                }

#ifdef _SAFECRT_IMPL
                /* for safecrt, we pass along the FL_ALTERNATE flag to _safecrt_cfltcvt */
                if (flags & FL_ALTERNATE)
                {
                    capexp |= FL_ALTERNATE;
                }
#endif  /* _SAFECRT_IMPL */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _LONGDOUBLE tmp;
#ifdef POSITIONAL_PARAMETERS
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    tmp=va_arg(argptr, _LONGDOUBLE);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        /* Will get here only for pass == FORMAT_OUTPUT_PASS because
                        pass == FORMAT_POSSCAN_PASS has a break Above */
                        va_list tmp_arg;
                        _ASSERTE(pass == FORMAT_OUTPUT_PASS);
                        tmp_arg = pos_value[type_pos].arg_ptr;
                        tmp=va_arg(tmp_arg, _LONGDOUBLE);
                    }
#endif  /* POSITIONAL_PARAMETERS */
                    /* Note: assumes ch is in ASCII range */
                    _CLDCVT(&tmp, text.sz, buffersize, (char)ch, precision, capexp);
                } else
#endif  /* !LONGDOUBLE_IS_DOUBLE */
                {
                    _CRT_DOUBLE tmp;
#ifdef POSITIONAL_PARAMETERS
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    tmp=va_arg(argptr, _CRT_DOUBLE);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        /* Will get here only for pass == FORMAT_OUTPUT_PASS because
                        pass == FORMAT_POSSCAN_PASS has a break Above */
                        va_list tmp_arg;

                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                                                _ASSERTE(pass == FORMAT_OUTPUT_PASS);
                        tmp_arg = pos_value[type_pos].arg_ptr;
                        tmp=va_arg(tmp_arg, _CRT_DOUBLE);
                    }
#endif  /* POSITIONAL_PARAMETERS */
                    /* Note: assumes ch is in ASCII range */
                    /* In safecrt, we provide a special version of _cfltcvt which internally calls printf (see safecrt_output_s.c) */
#ifndef _SAFECRT_IMPL
                    _cfltcvt_l(&tmp.x, text.sz, buffersize, (char)ch, precision, capexp, _loc_update.GetLocaleT());
#else  /* _SAFECRT_IMPL */
                    _CFLTCVT(&tmp, text.sz, buffersize, (char)ch, precision, capexp);
#endif  /* _SAFECRT_IMPL */
                }

#ifndef _SAFECRT_IMPL
                /* For safecrt, this is done already in _safecrt_cfltcvt */

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                {
                    _forcdecpt_l(text.sz, _loc_update.GetLocaleT());
                }

                /* 'g' format means crop zero unless '#' given */
                if (ch == _T('g') && !(flags & FL_ALTERNATE))
                {
                    _cropzeros_l(text.sz, _loc_update.GetLocaleT());
                }
#endif  /* _SAFECRT_IMPL */

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text.sz == '-') {
                    flags |= FL_NEGATIVE;
                    ++text.sz;
                }

                textlen = (int)strlen(text.sz);     /* compute length of text */
            }
            break;

            case _T('d'):
            case _T('i'):
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case _T('u'):
                radix = 10;
                goto COMMON_INT;

            case _T('p'):
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if PTR_IS_INT64
                flags |= FL_I64;                    /* assume we're converting an int64 */
#elif !PTR_IS_INT
                flags |= FL_LONG;                   /* assume we're converting a long */
#endif  /* !PTR_IS_INT */
                /* DROP THROUGH to hex formatting */

            case _T('X'):
                /* unsigned upper hex output */
                hexadd = _T('A') - _T('9') - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case _T('x'):
                /* unsigned lower hex output */
                hexadd = _T('a') - _T('9') - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = _T('0');
                    prefix[1] = (TCHAR)(_T('x') - _T('a') + _T('9') + 1 + hexadd);  /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case _T('o'):
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned __int64 number;    /* number to convert */
                int digit;              /* ascii value of digit */
                __int64 l;              /* temp long value */

                /* 1. read argument into l, sign extend as needed */
                if (flags & FL_I64)
#ifdef POSITIONAL_PARAMETERS
                {
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    l = get_int64_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                        if (pass == FORMAT_POSSCAN_PASS)
                        {
                            STORE_ARGPTR(pos_value, e_int64_arg, type_pos, ch, flags)
                            break;
                        }
                        else
                        {
                            GET_ARG(get_int64_arg,pos_value[type_pos].arg_ptr,l,)
                        }
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */
                else if (flags & FL_LONGLONG)
#ifdef POSITIONAL_PARAMETERS
                {
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    l = get_long_long_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                        if (pass == FORMAT_POSSCAN_PASS)
                        {
                            STORE_ARGPTR(pos_value, e_long_long_arg, type_pos, ch, flags)
                            break;
                        }
                        else
                        {
                            GET_ARG(get_long_long_arg,pos_value[type_pos].arg_ptr,l,)
                        }
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */

                else

#if !LONG_IS_INT
                if (flags & FL_LONG)
#ifdef POSITIONAL_PARAMETERS
                {
                    if(format_type == FMT_TYPE_NONPOSITIONAL)
                    {
#endif  /* POSITIONAL_PARAMETERS */
                    l = get_long_arg(&argptr);
#ifdef POSITIONAL_PARAMETERS
                    }
                    else
                    {
                        _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                        if (pass == FORMAT_POSSCAN_PASS)
                        {
                            STORE_ARGPTR(pos_value, e_long_arg, type_pos, ch, flags)
                            break;
                        }
                        else
                        {
                            l = GETARG(get_long_arg,pos_value[type_pos].arg_ptr);
                        }
                    }
                }
#endif  /* POSITIONAL_PARAMETERS */
                else
#endif  /* !LONG_IS_INT */

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
#ifdef POSITIONAL_PARAMETERS
                    {
                        if(format_type == FMT_TYPE_NONPOSITIONAL)
                        {
#endif  /* POSITIONAL_PARAMETERS */
                        l = (short) get_int_arg(&argptr); /* sign extend */
#ifdef POSITIONAL_PARAMETERS
                        }
                        else
                        {
                            _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                            if (pass == FORMAT_POSSCAN_PASS)
                            {
                                STORE_ARGPTR(pos_value, e_int_arg, type_pos, ch, flags)
                                break;
                            }
                            else
                            {
                                GET_ARG(get_int_arg,pos_value[type_pos].arg_ptr,l, (short)) /* sign extend */
                            }
                        }
                    }
#endif  /* POSITIONAL_PARAMETERS */
                    else
#ifdef POSITIONAL_PARAMETERS
                    {
                        if(format_type == FMT_TYPE_NONPOSITIONAL)
                        {
#endif  /* POSITIONAL_PARAMETERS */
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
#ifdef POSITIONAL_PARAMETERS
                        }
                        else
                        {
                            _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                            if (pass == FORMAT_POSSCAN_PASS)
                            {
                                STORE_ARGPTR(pos_value, e_int_arg, type_pos, ch, flags)
                                break;
                            }
                            else
                            {
                                GET_ARG(get_int_arg,pos_value[type_pos].arg_ptr,l, (unsigned short)) /* zero-extend*/
                            }
                        }
                    }
#endif  /* POSITIONAL_PARAMETERS */

                } else
#endif  /* !SHORT_IS_INT */
                {
                    if (flags & FL_SIGNED)
#ifdef POSITIONAL_PARAMETERS
                    {
                        if(format_type == FMT_TYPE_NONPOSITIONAL)
                        {
#endif  /* POSITIONAL_PARAMETERS */
                        l = get_int_arg(&argptr); /* sign extend */
#ifdef POSITIONAL_PARAMETERS
                        }
                        else
                        {
                            _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                            if (pass == FORMAT_POSSCAN_PASS)
                            {
                                STORE_ARGPTR(pos_value, e_int_arg, type_pos, ch, flags)
                                break;
                            }
                            else
                            {
                                GET_ARG(get_int_arg,pos_value[type_pos].arg_ptr, l, ) /* sign extend */
                            }
                        }
                    }
#endif  /* POSITIONAL_PARAMETERS */
                    else
#ifdef POSITIONAL_PARAMETERS
                    {
                        if(format_type == FMT_TYPE_NONPOSITIONAL)
                        {
#endif  /* POSITIONAL_PARAMETERS */
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
#ifdef POSITIONAL_PARAMETERS
                        }
                        else
                        {
                            _VALIDATE_RETURN(((type_pos>=0) && (type_pos<_ARGMAX)), EINVAL, -1);

                            if (pass == FORMAT_POSSCAN_PASS)
                            {
                                STORE_ARGPTR(pos_value, e_int_arg, type_pos, ch, flags)
                                break;
                            }
                            else
                            {
                                GET_ARG(get_int_arg,pos_value[type_pos].arg_ptr, l, (unsigned int)) /* zero-extend*/
                            }
                        }
                    }
#endif  /* POSITIONAL_PARAMETERS */

                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                } else {
                    number = l;
                }

                if ( (flags & FL_I64) == 0 && (flags & FL_LONGLONG) == 0 ) {
                    /*
                     * Unless printing a full 64-bit value, insure values
                     * here are not in cananical longword format to prevent
                     * the sign extended upper 32-bits from being printed.
                     */
                    number &= 0xffffffff;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;  /* default precision */
                else {
                    flags &= ~FL_LEADZERO;
                    if (precision > MAXPRECISION)
                        precision = MAXPRECISION;
                }

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text.sz = &buffer.sz[BUFFERSIZE-1];    /* last digit at end of buffer */

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;                /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text.sz-- = (char)digit;       /* store the digit */
                }

                textlen = (int)((char *)&buffer.sz[BUFFERSIZE-1] - text.sz); /* compute length of number */
                ++text.sz;          /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (textlen == 0 || text.sz[0] != '0')) {
                    *--text.sz = '0';
                    ++textlen;      /* add a zero */
                }
            }
            break;
            }

#ifdef POSITIONAL_PARAMETERS
            if((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
            {
                break;
            }
#endif  /* POSITIONAL_PARAMETERS */


            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = _T('-');
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = _T('+');
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = _T(' ');
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    WRITE_MULTI_CHAR(_T(' '), padding, &charsout);
                }

                /* write prefix */
                WRITE_STRING(prefix, prefixlen, &charsout);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    WRITE_MULTI_CHAR(_T('0'), padding, &charsout);
                }

                /* write text */
#ifndef _UNICODE
                if (bufferiswide && (textlen > 0)) {
                    wchar_t *p;
                    int retval, count;
                    errno_t e = 0;
                    char L_buffer[MB_LEN_MAX+1];

                    p = text.wz;
                    count = textlen;
                    while (count--) {
                        e = _WCTOMB_S(&retval, L_buffer, _countof(L_buffer), *p++);
                        if (e != 0 || retval == 0) {
                            charsout = -1;
                            break;
                        }
                        WRITE_STRING(L_buffer, retval, &charsout);
                    }
                } else {
                    WRITE_STRING(text.sz, textlen, &charsout);
                }
#else  /* _UNICODE */
                if (!bufferiswide && textlen > 0) {
                    char *p;
                    int retval, count;

                    p = text.sz;
                    count = textlen;
                    while (count-- > 0) {
#ifdef _SAFECRT_IMPL
                        retval = _MBTOWC(&wchar, p, MB_CUR_MAX);
#else  /* _SAFECRT_IMPL */
                        retval = _mbtowc_l(&wchar,
                                           p,
                                           _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                           _loc_update.GetLocaleT());
#endif  /* _SAFECRT_IMPL */
                        if (retval <= 0) {
                            charsout = -1;
                            break;
                        }
                        WRITE_CHAR(wchar, &charsout);
                        p += retval;
                    }
                } else {
                    WRITE_STRING(text.wz, textlen, &charsout);
                }
#endif  /* _UNICODE */

                if (charsout >= 0 && (flags & FL_LEFT)) {
                    /* pad on right with blanks */
                    WRITE_MULTI_CHAR(_T(' '), padding, &charsout);
                }

                /* we're done! */
            }
            if (heapbuf) {
                _free_crt(heapbuf);
                heapbuf = NULL;
            }
            break;
        }
    }

#ifdef FORMAT_VALIDATIONS
    /* The format string shouldn't be incomplete - i.e. when we are finished
        with the format string, the last thing we should have encountered
        should have been a regular char to be output or a type specifier. Else
        the format string was incomplete */
    _VALIDATE_RETURN(((state == ST_NORMAL) || (state == ST_TYPE)), EINVAL, -1);
#endif  /* FORMAT_VALIDATIONS */

#ifdef POSITIONAL_PARAMETERS
    if((format_type == FMT_TYPE_POSITIONAL) && (pass == FORMAT_POSSCAN_PASS))
    {
        /* At the end of the 1st pass, we have the types filled into the
        arg_type member of the struct. We now need to get argument pointer on
        the stack & store it into the arg_ptr member */
        for(type_pos = 0; type_pos <= max_pos; ++type_pos)
        {
            switch(pos_value[type_pos].arg_type)
            {
                case e_int_arg :
                    pos_value[type_pos].arg_ptr = argptr;
                    get_int_arg(&argptr);
                    break;
#ifndef _UNICODE
                case e_short_arg:
                    pos_value[type_pos].arg_ptr = argptr;
                    get_short_arg(&argptr);
                    break;
#endif  /* _UNICODE */
                case e_ptr_arg:
                    pos_value[type_pos].arg_ptr = argptr;
                    get_ptr_arg(&argptr);
                    break;

                case e_int64_arg:
                    pos_value[type_pos].arg_ptr = argptr;
                    get_int64_arg(&argptr);
                    break;

                case e_long_long_arg:
                    pos_value[type_pos].arg_ptr = argptr;
                    get_long_long_arg(&argptr);
                    break;

                case e_long_arg:
                    pos_value[type_pos].arg_ptr = argptr;
                    get_long_arg(&argptr);
                    break;

#if !LONGDOUBLE_IS_DOUBLE
                case e_longdouble_arg:
                    pos_value[type_pos].arg_ptr = argptr;
                    get_longdouble_arg(&argptr);
                    break;
#else  /* !LONGDOUBLE_IS_DOUBLE */
                case e_double_arg :
                    pos_value[type_pos].arg_ptr = argptr;
                    get_crtdouble_arg(&argptr);
                    break;
#endif  /* !LONGDOUBLE_IS_DOUBLE */
                default:
                    /* Should never get here */
                    _VALIDATE_RETURN(("Missing position in the format string", 0), EINVAL, -1);
                    break;
            }
        }
    }


    }
#endif  /* POSITIONAL_PARAMETERS */

    return charsout;        /* return value = number of characters written */
}

/*
 *  Future Optimizations for swprintf:
 *  - Don't free the memory used for converting the buffer to wide chars.
 *    Use realloc if the memory is not sufficient.  Free it at the end.
 */

/***
*void write_char(char ch, int *pnumwritten)
*ifdef _UNICODE
*void write_char(wchar_t ch, FILE *f, int *pnumwritten)
*endif
*void write_char(char ch, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes a single character to the given file/console.  If no error occurs,
*   then *pnumwritten is incremented; otherwise, *pnumwritten is set
*   to -1.
*
*Entry:
*   _TCHAR ch        - character to write
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef CPRFLAG

LOCAL(void) write_char (
    _TCHAR ch,
    int *pnumwritten
    )
{
#ifdef _UNICODE
    if (_putwch_nolock(ch) == WEOF)
#else  /* _UNICODE */
    if (_putch_nolock(ch) == EOF)
#endif  /* _UNICODE */
        *pnumwritten = -1;
    else
        ++(*pnumwritten);
}

#else  /* CPRFLAG */

LOCAL(void) write_char (
    _TCHAR ch,
    FILE *f,
    int *pnumwritten
    )
{
    if ( (f->_flag & _IOSTRG) && f->_base == NULL)
    {
        ++(*pnumwritten);
        return;
    }
#ifdef _UNICODE
    if (_putwc_nolock(ch, f) == WEOF)
#else  /* _UNICODE */
    if (_putc_nolock(ch, f) == EOF)
#endif  /* _UNICODE */
        *pnumwritten = -1;
    else
        ++(*pnumwritten);
}

#endif  /* CPRFLAG */

/***
*void write_multi_char(char ch, int num, int *pnumwritten)
*ifdef _UNICODE
*void write_multi_char(wchar_t ch, int num, FILE *f, int *pnumwritten)
*endif
*void write_multi_char(char ch, int num, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes num copies of a character to the given file/console.  If no error occurs,
*   then *pnumwritten is incremented by num; otherwise, *pnumwritten is set
*   to -1.  If num is negative, it is treated as zero.
*
*Entry:
*   _TCHAR ch        - character to write
*   int num          - number of times to write the characters
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef CPRFLAG
LOCAL(void) write_multi_char (
    _TCHAR ch,
    int num,
    int *pnumwritten
    )
{
    while (num-- > 0) {
        write_char(ch, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#else  /* CPRFLAG */

LOCAL(void) write_multi_char (
    _TCHAR ch,
    int num,
    FILE *f,
    int *pnumwritten
    )
{
    while (num-- > 0) {
        write_char(ch, f, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#endif  /* CPRFLAG */

/***
*void write_string(char *string, int len, int *pnumwritten)
*void write_string(char *string, int len, FILE *f, int *pnumwritten)
*ifdef _UNICODE
*void write_string(wchar_t *string, int len, FILE *f, int *pnumwritten)
*endif
*void write_wstring(wchar_t *string, int len, int *pnumwritten)
*void write_wstring(wchar_t *string, int len, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pnumwritten is incremented by len; otherwise, *pnumwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   _TCHAR *string   - string to write (NOT null-terminated)
*   int len          - length of string
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef CPRFLAG

LOCAL(void) write_string (
    _TCHAR *string,
    int len,
    int *pnumwritten
    )
{
    while (len-- > 0) {
        write_char(*string++, pnumwritten);
        if (*pnumwritten == -1)
        {
            if (errno == EILSEQ)
                write_char(_T('?'), pnumwritten);
            else
                break;
        }
    }
}

#else  /* CPRFLAG */

LOCAL(void) write_string (
    _TCHAR *string,
    int len,
    FILE *f,
    int *pnumwritten
    )
{
    if ( (f->_flag & _IOSTRG) && f->_base == NULL)
    {
        (*pnumwritten) += len;
        return;
    }
    while (len-- > 0) {
        write_char(*string++, f, pnumwritten);
        if (*pnumwritten == -1)
        {
            if (errno == EILSEQ)
                write_char(_T('?'), f, pnumwritten);
            else
                break;
        }
    }
}
#endif  /* CPRFLAG */


/***
*int get_int_arg(va_list *pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

__inline int __cdecl get_int_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list *pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

#if !LONG_IS_INT
__inline long __cdecl get_long_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, long);
}
#endif  /* !LONG_IS_INT */

#if !LONGLONG_IS_INT64
__inline long long __cdecl get_long_long_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, long long);
}
#endif  /* !LONGLONG_IS_INT64 */

__inline __int64 __cdecl get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}

#ifndef _UNICODE
/***
*short get_short_arg(va_list *pargptr)
*
*Purpose:
*   Gets a short argument off the given argument list and updates *pargptr.
*   *** CURRENTLY ONLY USED TO GET A WCHAR_T, IFDEF _INTL ***
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the short argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

#if !SHORT_IS_INT
__inline short __cdecl get_short_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, short);
}
#endif  /* !SHORT_IS_INT */

#ifdef POSITIONAL_PARAMETERS
#if !LONGDOUBLE_IS_DOUBLE
__inline _LONGDOUBLE __cdecl get_longdouble_arg(va_list *pargptr)
{
    return va_arg(*pargptr, _LONGDOUBLE);
}
#else  /* !LONGDOUBLE_IS_DOUBLE */
__inline _CRT_DOUBLE __cdecl get_crtdouble_arg(va_list *pargptr)
{
    return va_arg(*pargptr, _CRT_DOUBLE);
}
#endif  /* !LONGDOUBLE_IS_DOUBLE */
#endif  /* POSITIONAL_PARAMETERS */
#endif  /* _UNICODE */
#ifndef _SAFECRT_IMPL
}
#endif  /* _SAFECRT_IMPL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\perror.c ===
/***
*perror.c - print system error message
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines perror() - print system error message
*       System error message are indexed by errno; conforms to XENIX
*       standard, with much compatability with 1983 uniforum draft standard.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syserr.h>
#include <mtdll.h>
#include <io.h>
#include <internal.h>

/***
*void perror(message) - print system error message
*
*Purpose:
*       prints user's error message, then follows it with ": ", then the system
*       error message, then a newline.  All output goes to stderr.  If user's
*       message is NULL or a null string, only the system error message is
*       printer.  If errno is weird, prints "Unknown error".
*
*Entry:
*       const char *message - users message to prefix system error message
*
*Exit:
*       Prints message; no return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl perror (
        REG1 const char *message
        )
{

        REG2 int fh = 2;

        _lock_fh( fh );         /* acquire file handle lock */
        __try {


        if (message && *message)
        {

            _write_nolock(fh,(char *)message,(unsigned int)strlen(message));
            _write_nolock(fh,": ",2);
        }

        message = _get_sys_err_msg( errno );

        _write_nolock(fh,(char *)message,(unsigned int)strlen(message));
        _write_nolock(fh,"\n",1);

        }
        __finally {
            _unlock_fh( fh );   /* release file handle lock */
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\puts.c ===
/***
*puts.c - put a string to stdout
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines puts() and _putws() - put a string to stdout
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*int puts(string) - put a string to stdout with newline
*
*Purpose:
*       Write a string to stdout; don't include '\0' but append '\n'.  Uses
*       temporary buffering for efficiency on stdout if unbuffered.
*
*Entry:
*       char *string - string to output
*
*Exit:
*       Good return = 0
*       Error return = EOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _putts (
        const _TCHAR *string
        )
{
        int buffing;
#ifndef _UNICODE
        size_t length;
        size_t ndone;
#endif  /* _UNICODE */
        int retval = _TEOF; /* error */

        _VALIDATE_RETURN( (string != NULL), EINVAL, _TEOF );
#ifndef _UNICODE
        _VALIDATE_STREAM_ANSI_RETURN(stdout, EINVAL, EOF);
#endif  /* _UNICODE */

        _lock_str2(1, stdout);
        __try {

        buffing = _stbuf(stdout);

#ifdef _UNICODE
        while (*string) {
            if (_putwchar_nolock(*string++) == WEOF)
                goto done;
        }
        if (_putwchar_nolock(L'\n') != WEOF)
            retval = 0;     /* success */
#else  /* _UNICODE */
        length = strlen(string);
        ndone = _fwrite_nolock(string,1,length,stdout);

        if (ndone == length) {
            _putc_nolock('\n',stdout);
            retval = 0;     /* success */
        }
#endif  /* _UNICODE */

#ifdef _UNICODE
done:
#endif  /* _UNICODE */
        _ftbuf(buffing, stdout);

        }
        __finally {
            _unlock_str2(1, stdout);
        }

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\outputformat.c ===
/***
*outputformat.c - formatting options used by output functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Option flags used by output functions (like printf).
*       As an example, the user can set the _TWO_DIGIT_EXPONENT flag
*       to force the output of floating point numbers to have a
*       two digits exponent (if possible).
*
*******************************************************************************/

#include <stdio.h>
#include <internal.h>

unsigned int _outputformat = 0;

/***
*unsigned int _set_output_format(unsigned int options) - Set the output format option flags.
*
*Purpose:
*       Set the output format option flags. The only valid value for now is _TWO_DIGIT_EXPONENT.
*
*Entry:
*       unsigned int options    option flags to be set
*
*Exit:
*       Returns the old value of the output format.
*       If the given set of options is invalid, the output format will not be set
*       and errno will contain EINVAL.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
_CRTIMP unsigned int _set_output_format(unsigned int options)
{
    unsigned int old = _outputformat;

    /* validation section */
    _VALIDATE_RETURN((options & ~_TWO_DIGIT_EXPONENT) == 0, EINVAL, old);

    _outputformat = options;
    return old;
}

/***
*unsigned int _get_output_format() - Get the current output format option flags.
*
*Purpose:
*       Get the current output format option flags.
*
*Entry:
*
*Exit:
*       Returns the current value of the output format.
*
*Exceptions:
*
*******************************************************************************/
_CRTIMP unsigned int _get_output_format()
{
    return _outputformat;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\putch.c ===
/***
*putch.c - contains the _putch() routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The routine "_putch()" writes a single character to the console.
*
*       NOTE: In real-mode MS-DOS the character is actually written to standard
*       output, and is therefore redirected when standard output is redirected.
*       However, under Win32 console mode, the character is ALWAYS written
*       to the console, even when standard output has been redirected.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <conio.h>
#include <internal.h>
#include <mtdll.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

/*
 * declaration for console handle
 */
extern intptr_t _confh;

/***
*int _putch(c) - write a character to the console
*
*Purpose:
*       Calls WriteConsole to output the character
*       Note: in Win32 console mode always writes to console even
*       when stdout redirected
*
*Entry:
*       c - Character to be output
*
*Exit:
*       If an error is returned from WriteConsole
*           Then returns EOF
*       Otherwise
*           returns character that was output
*
*Exceptions:
*
*******************************************************************************/

/* normal version lock and unlock the console, and then call the _lk version
   which directly accesses the console without locking. */

int __cdecl _putch (
        int c
        )
{
        int ch;

        _mlock(_CONIO_LOCK);            /* secure the console lock */
        __TRY
            ch = _putch_nolock(c);              /* output the character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* release the console lock */
        __END_TRY_FINALLY

        return ch;
}

/* define version which accesses the console directly - normal version in
   non-_MT situations, special _lk version in _MT */

int __cdecl _putch_nolock (
        int c
        )
{
        _ptiddata ptd = _getptd();
        unsigned char *ch_buf = ptd->_con_ch_buf;
        unsigned short *pch_buf_used = &(ptd->_ch_buf_used);

        /* can't use ch directly unless sure we have a big-endian machine */
        unsigned char ch = (unsigned char)c;
        wchar_t wchar;

        /*
         * Why are we using putwch to write to Console when we could have
         * written straight away to Console? The problem we have in writing to
         * Console is that CRT codepage is different from Console codepage and
         * thus to write to console, we will need to convert the codepage. Here
         * we can use unicode version of these routines and this way we will
         * only have to do one conversion and rest will be handled by putwch.
         */

        /*
         * The usual way people call putch is character by character. Also
         * there is noway we can convert partial MBCS to unicode character. To
         * address this issue, we buffer all the lead bytes and combine them
         * with trail bytes and then do the conversion.
         */
        if (*pch_buf_used == 1)
        {
            _ASSERTE(isleadbyte(ch_buf[0]) != 0);

            ch_buf[1] = ch;
        }
        else
        {
            ch_buf[0] = ch;
        }

        if (*pch_buf_used == 0 && isleadbyte(ch_buf[0]))
        {
            /*
             * We still need trail byte, wait for it.
             */
            *pch_buf_used = 1;
        }
        else
        {
            if (mbtowc(&wchar, ch_buf, (*pch_buf_used)+1) == -1 ||
                    _putwch_nolock(wchar) == WEOF)
            {
                ch = EOF;
            }
            /*
             * Since we have processed full MBCS character, we should reset ch_buf_used.
             */
            (*pch_buf_used) = 0;
        }

        return ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\popen.c ===
/***
*popen.c - initiate a pipe and a child command
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _popen() and _pclose().
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <process.h>
#include <io.h>
#include <fcntl.h>
#include <internal.h>
#include <errno.h>
#include <msdos.h>
#include <mtdll.h>
#include <oscalls.h>
#include <tchar.h>
#include <dbgint.h>

/* size for pipe buffer
 */
#define PSIZE     1024

#define STDIN     0
#define STDOUT    1

#define SLASH _T("\\")
#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')
#define DELIMITER _T(";")



/* definitions for table of stream pointer - process handle pairs. the table
 * is created, maintained and accessed by the idtab function. _popen and
 * _pclose gain access to table entries only by calling idtab. Note that the
 * table is expanded as necessary (by idtab) and free table entries are reused
 * (an entry is free if its stream field is NULL), but the table is never
 * contracted.
 */

typedef struct {
        FILE *stream;
        intptr_t prochnd;
} IDpair;

/* number of entries in idpairs table
 */
#ifndef _UNICODE
unsigned __idtabsiz = 0;
#else  /* _UNICODE */
extern unsigned __idtabsiz;
#endif  /* _UNICODE */

/* pointer to first table entry
 */
#ifndef _UNICODE
IDpair *__idpairs = NULL;
#else  /* _UNICODE */
extern IDpair *__idpairs;
#endif  /* _UNICODE */

/* function to find specified table entries. also, creates and maintains
 * the table.
 */
static IDpair * __cdecl idtab(FILE *);


/***
*FILE *_popen(cmdstring,type) - initiate a pipe and a child command
*
*Purpose:
*       Creates a pipe and asynchronously executes a child copy of the command
*       processor with cmdstring (see system()). If the type string contains
*       an 'r', the calling process can read child command's standard output
*       via the returned stream. If the type string contains a 'w', the calling
*       process can write to the child command's standard input via the
*       returned stream.
*
*Entry:
*       _TSCHAR *cmdstring - command to be executed
*       _TSCHAR *type   - string of the form "r|w[b|t]", determines the mode
*                         of the returned stream (i.e., read-only vs write-only,
*                         binary vs text mode)
*
*Exit:
*       If successful, returns a stream associated with one end of the created
*       pipe (the other end of the pipe is associated with either the child
*       command's standard input or standard output).
*
*       If an error occurs, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tpopen (
        const _TSCHAR *cmdstring,
        const _TSCHAR *type
        )
{

        int phdls[2];             /* I/O handles for pipe */
        int ph_open[2];           /* flags, set if correspond phdls is open */
        int i1;                   /* index into phdls[] */
        int i2;                   /* index into phdls[] */

        int tm = 0;               /* flag indicating text or binary mode */

        int stdhdl;               /* either STDIN or STDOUT */

        HANDLE newhnd;            /* ...in calls to DuplicateHandle API */

        FILE *pstream = NULL;     /* stream to be associated with pipe */

        HANDLE prochnd;           /* handle for current process */

        _TSCHAR *cmdexe;          /* pathname for the command processor */
        _TSCHAR *envbuf = NULL;   /* buffer for the env variable */
        intptr_t childhnd;        /* handle for child process (cmd.exe) */

        IDpair *locidpair;        /* pointer to IDpair table entry */
        _TSCHAR *buf = NULL, *pfin, *env;
        _TSCHAR *CommandLine;
        size_t CommandLineSize = 0;
        _TSCHAR _type[3] = {0, 0, 0};

        /* Info for spawning the child. */
        STARTUPINFO StartupInfo;  /* Info for spawning a child */
        BOOL childstatus = 0;
        PROCESS_INFORMATION ProcessInfo; /* child process information */

        errno_t save_errno;

        int fh_lock_held = 0;
        int popen_lock_held = 0;

        /* first check for errors in the arguments
         */
        _VALIDATE_RETURN((cmdstring != NULL), EINVAL,NULL);
        _VALIDATE_RETURN((type != NULL), EINVAL,NULL);

        while (*type == _T(' '))
        {
            type++;
        }
        _VALIDATE_RETURN(((*type == _T('w')) || (*type == _T('r'))), EINVAL,NULL);
        _type[0] = *type;
        ++type;
        while (*type == _T(' '))
        {
            ++type;
        }
        _VALIDATE_RETURN(((*type == 0) || (*type == _T('t')) || (*type == _T('b'))), EINVAL, NULL);
        _type[1] = *type;

        /* do the _pipe(). note that neither of the resulting handles will
         * be inheritable.
         */

        if ( _type[1] == _T('t') )
                tm = _O_TEXT;
        else if ( _type[1] == _T('b') )
                tm = _O_BINARY;

        tm |= _O_NOINHERIT;

        if ( _pipe( phdls, PSIZE, tm ) == -1 )
                goto error1;

        /* test _type[0] and set stdhdl, i1 and i2 accordingly.
         */
        if ( _type[0] == _T('w') ) {
                stdhdl = STDIN;
                i1 = 0;
                i2 = 1;
        }
        else {
                stdhdl = STDOUT;
                i1 = 1;
                i2 = 0;
        }

        /* ASSERT LOCK FOR IDPAIRS HERE!!!!
         */
        if ( !_mtinitlocknum( _POPEN_LOCK )) {
            _close( phdls[0] );
            _close( phdls[1] );
            return NULL;
        }
        _mlock( _POPEN_LOCK );
        __try
        {

        /* set flags to indicate pipe handles are open. note, these are only
         * used for error recovery.
         */
        ph_open[ 0 ] = ph_open[ 1 ] = 1;


        /* get the process handle, it will be needed in some API calls
         */
        prochnd = GetCurrentProcess();



        if ( !DuplicateHandle( prochnd,
                               (HANDLE)_osfhnd( phdls[i1] ),
                               prochnd,
                               &newhnd,
                               0L,
                               TRUE,                    /* inheritable */
                               DUPLICATE_SAME_ACCESS )
        ) {
                goto error2;
        }
        (void)_close( phdls[i1] );
        ph_open[ i1 ] = 0;

        /* associate a stream with phdls[i2]. note that if there are no
         * errors, pstream is the return value to the caller.
         */
        if ( (pstream = _tfdopen( phdls[i2], _type )) == NULL )
                goto error2;

        /* next, set locidpair to a free entry in the idpairs table.
         */
        if ( (locidpair = idtab( NULL )) == NULL )
                goto error3;


        /* Find what to use. command.com or cmd.exe */
        if ( (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envbuf, NULL, _T("COMSPEC"))) != 0) || (envbuf == NULL) )
        {
            cmdexe = _T("cmd.exe");
        }
        else
        {
            cmdexe = envbuf;
        }

        /*
         * Initialise the variable for passing to CreateProcess
         */

        memset(&StartupInfo, 0, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        /* Used by os for duplicating the Handles. */

        StartupInfo.dwFlags = STARTF_USESTDHANDLES;
        StartupInfo.hStdInput = stdhdl == STDIN ? (HANDLE) newhnd
                                                : (HANDLE) _osfhnd(0);
        StartupInfo.hStdOutput = stdhdl == STDOUT ? (HANDLE) newhnd
                                                  : (HANDLE) _osfhnd(1);
        StartupInfo.hStdError = (HANDLE) _osfhnd(2);


        CommandLineSize = _tcslen(cmdexe) + _tcslen(_T(" /c ")) + (_tcslen(cmdstring)) +1;
        if ((CommandLine = _calloc_crt( CommandLineSize, sizeof(_TSCHAR))) == NULL)
            goto error3;
        _ERRCHECK(_tcscpy_s(CommandLine, CommandLineSize, cmdexe));
        _ERRCHECK(_tcscat_s(CommandLine, CommandLineSize, _T(" /c ")));
        _ERRCHECK(_tcscat_s(CommandLine, CommandLineSize, cmdstring));

        /* Check if cmdexe can be accessed. If yes CreateProcess else try
         * searching path.
         */
        save_errno = errno;
        if (_taccess_s(cmdexe, 0) == 0) {
            childstatus = CreateProcess( (LPTSTR) cmdexe,
                                         (LPTSTR) CommandLine,
                                         NULL,
                                         NULL,
                                         TRUE,
                                         0,
                                         NULL,
                                         NULL,
                                         &StartupInfo,
                                         &ProcessInfo
                                         );
        }
        else {
            TCHAR* envPath = NULL;
            size_t envPathSize = 0;
            if ((buf = _calloc_crt(_MAX_PATH, sizeof(_TSCHAR))) == NULL)
            {
                _free_crt(buf);
                _free_crt(CommandLine);
                _free_crt(envbuf);
                cmdexe = NULL;
                errno = save_errno;
                goto error3;
            }
            if (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envPath, NULL, _T("PATH"))) != 0)
            {
                _free_crt(envPath);
                _free_crt(buf);
                _free_crt(CommandLine);
                _free_crt(envbuf);
                cmdexe = NULL;
                errno = save_errno;
                goto error3;
            }
            env = envPath;

#ifdef WPRFLAG
            while ( (env = _wgetpath(env, buf, _MAX_PATH -1)) && (*buf) ) {
#else  /* WPRFLAG */
            while ( (env = _getpath(env, buf, _MAX_PATH -1)) && (*buf) ) {
#endif  /* WPRFLAG */
                pfin = buf + _tcslen(buf) -1;

#ifdef _MBCS
                if (*pfin == SLASHCHAR) {
                    if (pfin != _mbsrchr(buf, SLASHCHAR))
                        _ERRCHECK(strcat_s(buf, _MAX_PATH, SLASH));
                }
                else if (*pfin != XSLASHCHAR)
                    _ERRCHECK(strcat_s(buf, _MAX_PATH, SLASH));

#else  /* _MBCS */
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                    _ERRCHECK(_tcscat_s(buf, _MAX_PATH, SLASH));
#endif  /* _MBCS */
                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _spawnve()).
                 */
                if ( (_tcslen(buf) + _tcslen(cmdexe)) < _MAX_PATH )
                    _ERRCHECK(_tcscat_s(buf, _MAX_PATH, cmdexe));
                else
                    break;

                /* Check if buf can be accessed. If yes CreateProcess else try
                 * again.
                 */
                if (_taccess_s(buf, 0) == 0) {
                    childstatus = CreateProcess( (LPTSTR) buf,
                                                 CommandLine,
                                                 NULL,
                                                 NULL,
                                                 TRUE,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 &StartupInfo,
                                                 &ProcessInfo
                                                 );
                    break;
                }
            }
            _free_crt(envPath);
            _free_crt(buf);
        }
        _free_crt(CommandLine);
        _free_crt(envbuf);
        cmdexe = NULL;
        CloseHandle((HANDLE)newhnd);
        CloseHandle((HANDLE)ProcessInfo.hThread);
                errno = save_errno;

        /* check if the CreateProcess was sucessful.
         */
        if ( childstatus)
            childhnd = (intptr_t)ProcessInfo.hProcess;
        else
            goto error4;
        locidpair->prochnd = childhnd;
        locidpair->stream = pstream;

        /* success, return the stream to the caller
         */
        goto done;

        /**
         * error handling code. all detected errors end up here, entering
         * via a goto one of the labels. note that the logic is currently
         * a straight fall-thru scheme (e.g., if entered at error4, the
         * code for error4, error3,...,error1 is all executed).
         **********************************************************************/

error4:         /* make sure locidpair is reusable
                 */
                locidpair->stream = NULL;

error3:         /* close pstream (also, clear ph_open[i2] since the stream
                 * close will also close the pipe handle)
                 */
                (void)fclose( pstream );
                ph_open[ i2 ] = 0;
                pstream = NULL;

error2:         /* close handles on pipe (if they are still open)
                 */

                if ( ph_open[i1] )
                        _close( phdls[i1] );
                if ( ph_open[i2] )
                        _close( phdls[i2] );
done:

        ;}
        __finally {
            _munlock(_POPEN_LOCK);
        }


error1:
        return pstream;
}

#ifndef _UNICODE

/***
*int _pclose(pstream) - wait on a child command and close the stream on the
*   associated pipe
*
*Purpose:
*       Closes pstream then waits on the associated child command. The
*       argument, pstream, must be the return value from a previous call to
*       _popen. _pclose first looks up the process handle of child command
*       started by that _popen and does a cwait on it. Then, it closes pstream
*       and returns the exit status of the child command to the caller.
*
*Entry:
*       FILE *pstream - file stream returned by a previous call to _popen
*
*Exit:
*       If successful, _pclose returns the exit status of the child command.
*       The format of the return value is that same as for cwait, except that
*       the low order and high order bytes are swapped.
*
*       If an error occurs, -1 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _pclose (
        FILE *pstream
        )
{
        IDpair *locidpair;        /* pointer to entry in idpairs table */
        int termstat;             /* termination status word */
        int retval = -1;          /* return value (to caller) */
        errno_t save_errno;

        _VALIDATE_RETURN((pstream != NULL), EINVAL, -1);

        if (!_mtinitlocknum(_POPEN_LOCK))
            return -1;
        _mlock(_POPEN_LOCK);
        __try {

        if ((locidpair = idtab(pstream)) == NULL)
        {
                /* invalid pstream, exit with retval == -1
                 */
                errno = EBADF;
                goto done;
        }

        /* close pstream
         */
        (void)fclose(pstream);

        /* wait on the child (copy of the command processor) and all of its
         * children.
         */
        save_errno = errno;
        errno = 0;
        if ( (_cwait(&termstat, locidpair->prochnd, _WAIT_GRANDCHILD) != -1) ||
             (errno == EINTR) )
                retval = termstat;
        errno = save_errno;

        /* Mark the IDpairtable entry as free (note: prochnd was closed by the
         * preceding call to _cwait).
         */
        locidpair->stream = NULL;
        locidpair->prochnd = 0;

        /* only return path!
         */
        done:

        ; }
        __finally {
            _munlock(_POPEN_LOCK);
        }
        return(retval);
}

#endif  /* _UNICODE */

/***
* static IDpair * idtab(FILE *pstream) - find an idpairs table entry
*
*Purpose:
*   Find an entry in the idpairs table.  This function finds the entry the
*   idpairs table entry corresponding to pstream. In the case where pstream
*   is NULL, the entry being searched for is any free entry. In this case,
*   idtab will create the idpairs table if it doesn't exist, or expand it (by
*   exactly one entry) if there are no free entries.
*
*   [MTHREAD NOTE:  This routine assumes that the caller has acquired the
*   idpairs table lock.]
*
*Entry:
*   FILE *pstream - stream corresponding to table entry to be found (if NULL
*                   then find any free table entry)
*
*Exit:
*   if successful, returns a pointer to the idpairs table entry. otherwise,
*   returns NULL.
*
*Exceptions:
*
*******************************************************************************/

static IDpair * __cdecl idtab (
        FILE *pstream
        )
{

        IDpair * pairptr;       /* ptr to entry */
        IDpair * newptr;        /* ptr to newly malloc'd memory */


        /* search the table. if table is empty, appropriate action should
         * fall out automatically.
         */
        for ( pairptr = __idpairs ; pairptr < (__idpairs+__idtabsiz) ; pairptr++ )
                if ( pairptr->stream == pstream )
                        break;

        /* if we found an entry, return it.
         */
        if ( pairptr < (__idpairs + __idtabsiz) )
                return(pairptr);

        /* did not find an entry in the table.  if pstream was NULL, then try
         * creating/expanding the table. otherwise, return NULL. note that
         * when the table is created or expanded, exactly one new entry is
         * produced. this must not be changed unless code is added to mark
         * the extra entries as being free (i.e., set their stream fields to
         * to NULL).
         */
        if ( (pstream != NULL) ||
             ((__idtabsiz + 1) < __idtabsiz) ||
             ((__idtabsiz + 1) >= (SIZE_MAX / sizeof(IDpair))) ||
             ((newptr = (IDpair *)_recalloc_crt((void *)__idpairs, (__idtabsiz + 1),sizeof(IDpair))) == NULL))
                /* either pstream was non-NULL or the attempt to create/expand
                 * the table failed. in either case, return a NULL to indicate
                 * failure.
                 */
                return( NULL );

        __idpairs = newptr;             /* new table ptr */
        pairptr = newptr + __idtabsiz;  /* first new entry */
        __idtabsiz++;                   /* new table size */

        return( pairptr );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_PROCESS
#define _INC_PROCESS

#include <crtdefs.h>


#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#define _P_OVERLAY      2

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

_CRTIMP uintptr_t __cdecl _beginthread (_In_ void (__cdecl * _StartAddress) (void *),
        _In_ unsigned _StackSize, _In_opt_ void * _ArgList);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(_In_opt_ void * _Security, _In_ unsigned _StackSize,
        _In_ unsigned (__stdcall * _StartAddress) (void *), _In_opt_ void * _ArgList,
        _In_ unsigned _InitFlag, _In_opt_ unsigned * _ThrdAddr);
_CRTIMP void __cdecl _endthreadex(_In_ unsigned _Retval);

#if defined (__cplusplus) && defined (_M_CEE)
extern "C++"
{
_MCRTIMP uintptr_t __cdecl _beginthread (_In_ void (__clrcall * _StartAddress) (void *),
         _In_ unsigned _StackSize, _In_opt_ void * _ArgList);
_MCRTIMP uintptr_t __cdecl _beginthreadex(_In_opt_ void * _Security, _In_ unsigned _StackSize,
        _In_ unsigned (__clrcall * _StartAddress) (void *), _In_opt_ void * _ArgList,
        _In_ unsigned _InitFlag, _Out_opt_ unsigned * _ThrdAddr);
}
#endif  /* defined (__cplusplus) && defined (_M_CEE) */


#ifndef _CRT_TERMINATE_DEFINED
#define _CRT_TERMINATE_DEFINED
_CRTIMP __declspec(noreturn) void __cdecl exit(_In_ int _Code);
_CRTIMP __declspec(noreturn) void __cdecl _exit(_In_ int _Code);
_CRTIMP void __cdecl abort(void);
#endif  /* _CRT_TERMINATE_DEFINED */

_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(_Out_opt_ int * _TermStat, _In_ intptr_t _ProcHandle, _In_ int _Action);
_CRTIMP intptr_t __cdecl _execl(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _execle(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _execlp(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _execlpe(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _execv(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRTIMP intptr_t __cdecl _execve(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList, _In_opt_z_ const char * const * _Env);
_CRTIMP intptr_t __cdecl _execvp(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRTIMP intptr_t __cdecl _execvpe(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList, _In_opt_z_ const char * const * _Env);
_CRTIMP intptr_t __cdecl _spawnl(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _spawnle(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _spawnlp(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRTIMP intptr_t __cdecl _spawnv(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRTIMP intptr_t __cdecl _spawnve(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList,
        _In_opt_z_ const char * const * _Env);
_CRTIMP intptr_t __cdecl _spawnvp(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRTIMP intptr_t __cdecl _spawnvpe(_In_ int _Mode, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList,
        _In_opt_z_ const char * const * _Env);

#ifndef _CRT_SYSTEM_DEFINED
#define _CRT_SYSTEM_DEFINED
_CRTIMP int __cdecl system(_In_opt_z_ const char * _Command);
#endif  /* _CRT_SYSTEM_DEFINED */

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexecle(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexeclp(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexecv(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wexecve(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
_CRTIMP intptr_t __cdecl _wexecvp(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wexecvpe(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
_CRTIMP intptr_t __cdecl _wspawnl(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnle(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnv(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wspawnve(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
_CRTIMP intptr_t __cdecl _wspawnvp(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wspawnvpe(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
#ifndef _CRT_WSYSTEM_DEFINED
#define _CRT_WSYSTEM_DEFINED
_CRTIMP int __cdecl _wsystem(_In_opt_z_ const wchar_t * _Command);
#endif  /* _CRT_WSYSTEM_DEFINED */

#define _WPROCESS_DEFINED
#endif  /* _WPROCESS_DEFINED */

/*
 * Security check initialization and failure reporting used by /GS security
 * checks.
 */
#if !defined (_M_CEE)
void __cdecl __security_init_cookie(void);
#ifdef _M_IX86
void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
__declspec(noreturn) void __cdecl __report_gsfailure(void);
#else  /* _M_IX86 */
void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
__declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
#endif  /* _M_IX86 */
#endif  /* !defined (_M_CEE) */
extern uintptr_t __security_cookie;

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */

_CRT_OBSOLETE(LoadLibrary) intptr_t __cdecl _loaddll(_In_z_ char * _Filename);
_CRT_OBSOLETE(FreeLibrary) int __cdecl _unloaddll(_In_ intptr_t _Handle);
_CRT_OBSOLETE(GetProcAddress) int (__cdecl * __cdecl _getdllprocaddr(_In_ intptr_t _Handle, _In_opt_z_ char * _ProcedureName, _In_ intptr_t _Ordinal))(void);

/* --------- The preceding functions are OBSOLETE --------- */


#ifdef _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef _WINDOWS_
#if defined (MRTDLL)
BOOL __clrcall DllMain(_In_ HANDLE _HDllHandle, _In_ DWORD _Reason, _In_opt_ LPVOID _Reserved);
#else  /* defined (MRTDLL) */
BOOL WINAPI DllMain(_In_ HANDLE _HDllHandle, _In_ DWORD _Reason, _In_opt_ LPVOID _Reserved);
#endif  /* defined (MRTDLL) */
#if defined (MRTDLL)
BOOL _CRT_INIT(_In_ HANDLE _HDllHandle, _In_ DWORD _Reason, _In_opt_ LPVOID _Reserved);
#else  /* defined (MRTDLL) */
BOOL WINAPI _CRT_INIT(_In_ HANDLE _HDllHandle, _In_ DWORD _Reason, _In_opt_ LPVOID _Reserved);
#endif  /* defined (MRTDLL) */
BOOL WINAPI _wCRT_INIT(_In_ HANDLE _HDllHandle, _In_ DWORD _Reason, _In_opt_ LPVOID _Reserved);
extern BOOL (WINAPI * const _pRawDllMain)(HANDLE, DWORD, LPVOID);
#else  /* _WINDOWS_ */
int __stdcall DllMain(_In_ void * _HDllHandle, _In_ unsigned _Reason, _In_opt_ void * _Reserved);
int __stdcall _CRT_INIT(_In_ void * _HDllHandle, _In_ unsigned _Reason, _In_opt_ void * _Reserved);
int __stdcall _wCRT_INIT(_In_ void * _HDllHandle, _In_ unsigned _Reason, _In_opt_ void * _Reserved);
extern int (__stdcall * const _pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif  /* _DECL_DLLMAIN */

#if !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRT_NONSTDC_DEPRECATE(_cwait) _CRTIMP intptr_t __cdecl cwait(_Out_opt_ int * _TermStat, _In_ intptr_t _ProcHandle, _In_ int _Action);
_CRT_NONSTDC_DEPRECATE(_execl) _CRTIMP intptr_t __cdecl execl(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_execle) _CRTIMP intptr_t __cdecl execle(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_execlp) _CRTIMP intptr_t __cdecl execlp(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_execlpe) _CRTIMP intptr_t __cdecl execlpe(_In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_execv) _CRTIMP intptr_t __cdecl execv(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRT_NONSTDC_DEPRECATE(_execve) _CRTIMP intptr_t __cdecl execve(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList, _In_opt_z_ const char * const * _Env);
_CRT_NONSTDC_DEPRECATE(_execvp) _CRTIMP intptr_t __cdecl execvp(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRT_NONSTDC_DEPRECATE(_execvpe) _CRTIMP intptr_t __cdecl execvpe(_In_z_ const char * _Filename, _In_z_ const char * const * _ArgList, _In_opt_z_ const char * const * _Env);
_CRT_NONSTDC_DEPRECATE(_spawnl) _CRTIMP intptr_t __cdecl spawnl(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_spawnle) _CRTIMP intptr_t __cdecl spawnle(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_spawnlp) _CRTIMP intptr_t __cdecl spawnlp(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_spawnlpe) _CRTIMP intptr_t __cdecl spawnlpe(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * _ArgList, ...);
_CRT_NONSTDC_DEPRECATE(_spawnv) _CRTIMP intptr_t __cdecl spawnv(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRT_NONSTDC_DEPRECATE(_spawnve) _CRTIMP intptr_t __cdecl spawnve(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList,
        _In_opt_z_ const char * const * _Env);
_CRT_NONSTDC_DEPRECATE(_spawnvp) _CRTIMP intptr_t __cdecl spawnvp(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList);
_CRT_NONSTDC_DEPRECATE(_spawnvpe) _CRTIMP intptr_t __cdecl spawnvpe(_In_ int, _In_z_ const char * _Filename, _In_z_ const char * const * _ArgList,
        _In_opt_z_ const char * const * _Env);

_CRT_NONSTDC_DEPRECATE(_getpid) _CRTIMP int __cdecl getpid(void);

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\putenv.c ===
/***
*putenv.c - put an environment variable into the environment
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putenv() - adds a new variable to environment; does not
*       change global environment, only the process' environment.
*
*******************************************************************************/


#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef CRTDLL

/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
extern int __env_initialized;

#endif  /* CRTDLL */

int __cdecl _wputenv_helper(const wchar_t *, const wchar_t *);
int __cdecl _putenv_helper(const char *, const char *);

#ifdef WPRFLAG
#define _tputenv_helper _wputenv_helper
#else  /* WPRFLAG */
#define _tputenv_helper _putenv_helper
#endif  /* WPRFLAG */

/***
*int _putenv(option) - add/replace/remove variable in environment
*
*Purpose:
*       option should be of the form "option=value".  If a string with the
*       given option part already exists, it is replaced with the given
*       string; otherwise the given string is added to the environment.
*       If the string is of the form "option=", then the string is
*       removed from the environment, if it exists.  If the string has
*       no equals sign, error is returned.
*
*Entry:
*       char *option - option string to set in the environment list.
*           should be of the form "option=value".
*
*Exit:
*       returns 0 if OK, -1 if fails.
*
*Exceptions:
*
*Warning:
*       This code will not work if variables are removed from the
*       environment by deleting them from environ[].  Use _putenv("option=")
*       to remove a variable.
*
*******************************************************************************/


int __cdecl _tputenv (
        const _TSCHAR *option
        )
{
        int retval;

        _mlock( _ENV_LOCK );

        __try {
            retval = _tputenv_helper(option, NULL);
        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return retval;
}



errno_t _tputenv_s (
        const _TSCHAR *name,
        const _TSCHAR *value
        )
{
        int retval;

        /* validation section */
        _VALIDATE_RETURN_ERRCODE(value != NULL, EINVAL);

        _mlock( _ENV_LOCK );

        __try {
            retval = ((_tputenv_helper(name, value) == 0) ? 0 : errno);
        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return retval;
}


static int __cdecl _tputenv_helper (
        const _TSCHAR *name,
        const _TSCHAR *value
        )
{
        int size;
        _TSCHAR * newoption = NULL;
        size_t newoption_size = 0;

#ifndef CRTDLL
        /*
         * Make sure the environment is initialized.
         */
        if  ( !__env_initialized )
            return -1;
#endif  /* CRTDLL */

        /*
         * At startup, we obtain the 'native' flavor of environment strings
         * from the OS. So a "main" program has _environ and a "wmain" has
         * _wenviron loaded at startup. Only when the user gets or puts the
         * 'other' flavor do we convert it.
         */

        _VALIDATE_RETURN(name != NULL, EINVAL, -1);

        /* copy the new environent string */
        if (value == NULL)
        {
            const _TSCHAR *equal = _tcschr(name, _T('='));

            if (equal != NULL)
            {
                /* validate the length of both name and value */
                _VALIDATE_RETURN(equal - name < _MAX_ENV, EINVAL, -1);
                _VALIDATE_RETURN(_tcsnlen(equal + 1, _MAX_ENV) < _MAX_ENV, EINVAL, -1);
            }

            /* the string is already complete in name */
            newoption_size = _tcslen(name) + 1;
            if ((newoption = (_TSCHAR *)_calloc_crt(newoption_size, sizeof(_TSCHAR))) == NULL)
            {
                return -1;
            }

            _tcscpy_s(newoption, newoption_size, name);
        }
        else
        {
            size_t namelen = _tcsnlen(name, _MAX_ENV);
            size_t valuelen = _tcsnlen(value, _MAX_ENV);

            /* validate the length of both name and value */
            _VALIDATE_RETURN(namelen < _MAX_ENV, EINVAL, -1);
            _VALIDATE_RETURN(valuelen < _MAX_ENV, EINVAL, -1);

            /* we assemble the string from name and value (we assume _tcslen("=") == 1) */
            newoption_size = namelen + 1 + valuelen + 1;
            if ((newoption = (_TSCHAR *)_calloc_crt(newoption_size, sizeof(_TSCHAR))) == NULL)
            {
                return -1;
            }

            _tcscpy_s(newoption, newoption_size, name);
            newoption[namelen++] = _T('=');
            _tcscpy_s(newoption + namelen, newoption_size - namelen, value);
        }

#ifdef WPRFLAG
        if ( __crtwsetenv(&newoption, 1) != 0 )
        {
            /* if the set failed, we will free the option only if it was not consumed */
            if(newoption)
            {
                _free_crt(newoption);
                newoption=NULL;
            }
            return -1;
        }

        /* If other environment type exists, set it */
        if (_environ)
        {
            char *mboption = NULL;
            int temp_size = 0;

            /* find out how much space is needed */
            if ( (size = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL,
                 0, NULL, NULL)) == 0 )
            {
                errno = EILSEQ;
                return -1;
            }

            if (value != NULL)
            {
                /* account for the '=' */
                size += 1;

                if ( (temp_size = WideCharToMultiByte(CP_ACP, 0, value, -1, NULL,
                    0, NULL, NULL)) == 0 )
                {
                    errno = EILSEQ;
                    return -1;
                }
                size += temp_size;
            }

            /* allocate space for variable */
            if ((mboption = (char *) _calloc_crt(size, sizeof(char))) == NULL)
                return -1;

            /* convert it */
            if ( WideCharToMultiByte(CP_ACP, 0, name, -1, mboption, size,
                 NULL, NULL) == 0 )
            {
                _free_crt(mboption);
                errno = EILSEQ;
                return -1;
            }

            if (value != NULL)
            {
                size_t len = strlen(mboption);
                mboption[len++] = '=';

                if ( WideCharToMultiByte(
                        CP_ACP,
                        0,
                        value,
                        -1,
                        mboption + len,
                        size - (int)len,
                        NULL,
                        NULL) == 0 )
                {
                    _free_crt(mboption);
                    errno = EILSEQ;
                    return -1;
                }
            }

            /* set it - this is not primary call, so set primary == 0 */
            if ( __crtsetenv(&mboption, 0) != 0 )
            {
                /* if the set failed, we will free the option only if it was not consumed */
                if(mboption)
                {
                    _free_crt(mboption);
                    mboption=NULL;
                }
                return -1;
            }
        }
#else  /* WPRFLAG */
        /* Set requested environment type, primary call */
        if ( __crtsetenv(&newoption, 1) != 0 )
        {
            /* if the set failed, we will free the option only if it was not consumed */
            if(newoption)
            {
                _free_crt(newoption);
                newoption=NULL;
            }
            return -1;
        }

        /* If other environment type exists, set it */
        if (_wenviron)
        {
            wchar_t *woption = NULL;
            int temp_size = 0;

            /* find out how much space is needed */
            if ( (size = MultiByteToWideChar(CP_ACP, 0, name, -1, NULL, 0))
                 == 0 )
            {
                errno = EILSEQ;
                return -1;
            }

            if (value != NULL)
            {
                /* account for the '=' */
                size += 1;

                if ( (temp_size = MultiByteToWideChar(CP_ACP, 0, value, -1, NULL, 0))
                    == 0 )
                {
                    errno = EILSEQ;
                    return -1;
                }
                size += temp_size;
            }

            /* allocate space for variable */
            if ( (woption = (wchar_t *) _calloc_crt(size, sizeof(wchar_t)))
                 == NULL )
                return -1;

            /* convert it */
            if ( MultiByteToWideChar(CP_ACP, 0, name, -1, woption, size)
                 == 0 )
            {
                _free_crt(woption);
                errno = EILSEQ;
                return -1;
            }

            if (value != NULL)
            {
                size_t len = wcslen(woption);
                woption[len++] = L'=';

                if ( MultiByteToWideChar(
                        CP_ACP,
                        0,
                        value,
                        -1,
                        woption + len,
                        size - (int)len) == 0 )
                {
                    _free_crt(woption);
                    errno = EILSEQ;
                    return -1;
                }
            }

            /* set it - this is not primary call, so set primary == 0 */
            if ( __crtwsetenv(&woption, 0) != 0 )
            {
                /* if the set failed, we will free the option only if it was not consumed */
                if(woption)
                {
                    _free_crt(woption);
                    woption = NULL;
                }
                return -1;
            }
        }
#endif  /* WPRFLAG */

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\qsort_s.c ===
/***
*qsort_s.c - implementation of the quicksort algorithm
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   To implement the qsort_s() routine for sorting arrays.
*
*******************************************************************************/

/***
*qsort_s(base, num, wid, comp, context) - quicksort function for sorting arrays
*
*Purpose:
*   quicksort the array of elements
*   side effects:  sorts in place
*   maximum array size is number of elements times size of elements,
*   but is limited by the virtual address space of the processor
*
*Entry:
*   char *base = pointer to base of array
*   size_t num  = number of elements in the array
*   size_t width = width in bytes of each array element
*   int (*comp)() = pointer to function returning analog of strcmp for
*           strings, but supplied by user for comparing the array elements.
*           it accepts 2 pointers to elements, together with a pointer to a context.
*           Returns neg if 1<2, 0 if 1=2, pos if 1>2.
*   void *context - pointer to the context in which the function is
*           called. This context is passed to the comparison function.
*
*Exit:
*   returns void
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "qsort.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\putws.c ===
/***
*putws.c - put a string to stdout (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putws() - put a string to stdout
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "puts.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\purevirt.c ===
/***
*purevirt.c - stub to trap pure virtual function calls
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _purecall() -
*
*******************************************************************************/


#include <cruntime.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>

/////////////////////////////////////////////////////////////////////////////
//
// The global variable:
//

extern _purecall_handler __pPurecall;

/***
*void _purecall(void) -
*
*Purpose:
*       The compiler calls this if a pure virtual happens
*
*Entry:
*       No arguments
*
*Exit:
*       Never returns
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _purecall(
        void
        )
{
    _purecall_handler purecall = (_purecall_handler) _decode_pointer(__pPurecall);
    if(purecall != NULL)
    {
        purecall();

        /*  shouldn't return, but if it does, we drop back to
            default behaviour
        */
    }

    _NMSG_WRITE(_RT_PUREVIRT);
    /* do not write the abort message */
    _set_abort_behavior(0, _WRITE_ABORT_MSG);
    abort();
}

/***
*void _set_purecall_handler(void) -
*
*Purpose:
*       Establish a handler to be called when a pure virtual is called
*       Note that if you link to the crt statically, and replace
*       _purecall, then none of this will happen.
*
*       This function is not thread-safe
*
*Entry:
*       New handler
*
*Exit:
*       Old handler
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP _purecall_handler __cdecl
_set_purecall_handler( _purecall_handler pNew )
{
    _purecall_handler pOld = NULL;

    pOld = (_purecall_handler) _decode_pointer(__pPurecall);
    __pPurecall = (_purecall_handler) _encode_pointer(pNew);

    return pOld;
}

_CRTIMP _purecall_handler __cdecl _get_purecall_handler(void)
{
    return (_purecall_handler) _decode_pointer(__pPurecall);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rand_s.c ===
/***
*rand_s.c - random number generator
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines rand_s() - random number generator
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>
#include <internal.h>

/***
*errno_t rand_s(unsigned int *_RandomValue) - returns a random number
*
*Purpose:
*       returns a random number.
*
*Entry:
*       Non NULL out parameter.
*
*Exit:
*   errno_t - 0 if sucessful
*             error value on failure
*
*       Out parameter -
*             set to random value on success
*             set to 0 on error
*
*Exceptions:
*   Works only in Win2k and above. Will call invalid parameter if RtlGenRandom is not
*   available.
*
*******************************************************************************/

/* Review : Remove following after the define is added to SDK header */
#ifndef RtlGenRandom
#define RtlGenRandom    SystemFunction036
#else  /* RtlGenRandom */
#pragma message ( __FILE__ " : Review comments in this file" )
#endif  /* RtlGenRandom */

#define __TO_STR(x) #x
#define _TO_STR(x)  __TO_STR(x)



typedef BOOL (APIENTRY *PGENRANDOM)( PVOID, ULONG );

static PGENRANDOM g_pfnRtlGenRandom;

void __cdecl _initp_misc_rand_s(void* enull)
{
    g_pfnRtlGenRandom = (PGENRANDOM) enull;
}

errno_t __cdecl rand_s
(
    unsigned int *_RandomValue
)
{
    PGENRANDOM pfnRtlGenRandom = _decode_pointer(g_pfnRtlGenRandom);
    _VALIDATE_RETURN_ERRCODE( _RandomValue != NULL, EINVAL );
    *_RandomValue = 0; // Review : better value to initialize it to?

    if ( pfnRtlGenRandom == NULL )
    {
        PGENRANDOM encoded;
        void* enull;

        // Advapi32.dll is unloaded when the App exits.
        HMODULE hAdvApi32=LoadLibrary("ADVAPI32.DLL");
                if (!hAdvApi32)
                {
            _VALIDATE_RETURN_ERRCODE(("rand_s is not available on this platform", 0), EINVAL);
                }

        pfnRtlGenRandom = ( PGENRANDOM ) GetProcAddress( hAdvApi32, _TO_STR( RtlGenRandom ) );
        if ( pfnRtlGenRandom == NULL )
        {
            _VALIDATE_RETURN_ERRCODE(("rand_s is not available on this platform", 0), _get_errno_from_oserr(GetLastError()));
        }
        encoded = (PGENRANDOM) _encode_pointer(pfnRtlGenRandom);
        enull = _encoded_null();
#ifdef _M_IX86
        if ( (void*)(LONG_PTR)InterlockedExchange(
                ( LONG* )&g_pfnRtlGenRandom,
                ( LONG )( LONG_PTR )encoded)
            != enull )
#else  /* _M_IX86 */
        if ( InterlockedExchangePointer(
                ( void** )&g_pfnRtlGenRandom,
                ( void* )encoded)
            != enull )
#endif  /* _M_IX86 */
        {
            /* A different thread has already loaded advapi32.dll. */
            FreeLibrary( hAdvApi32 );
        }
    }

    if ( !(*pfnRtlGenRandom)( _RandomValue, ( ULONG )sizeof( unsigned int ) ) )
    {
        errno = ENOMEM;
        return errno;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\recalloc.c ===
/***
*recalloc.c - implementation of _recalloc
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _recalloc()
*
*******************************************************************************/

#ifdef WINHEAP

#include <cruntime.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

void * __cdecl _realloc_base (void * pBlock, size_t newsize);

#else  /* WINHEAP */

#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <string.h>
#include <dbgint.h>

void * __cdecl _realloc_base (
        REG1 void *pblock,
        size_t newsize
        );

#endif  /* WINHEAP */

/***
*void *_recalloc_base(pblock, count, newsize) - reallocate a block of memory in the heap
*
*Purpose:
*       Reallocates a block in the heap to count*newsize bytes. newsize may be
*       either greater or less than the original size of the block. The
*       reallocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*Entry:
*       void *pblock    - pointer to block in the heap previously allocated
*                         by a call to malloc(), realloc() or _expand().
*
*       size_t count    - count of items
*       size_t newsize  - requested size for the re-allocated items
*
*Exit:
*       Success:  Pointer to the re-allocated memory block
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*       If pblock does not point to a valid allocation block in the heap,
*       realloc() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _recalloc_base(void * memblock, size_t count, size_t size)
{
    void * retp = NULL;
    size_t  size_orig = 0, old_size = 0;

    /* ensure that (size * count) does not overflow */
    if (count > 0)
    {
        _VALIDATE_RETURN((_HEAP_MAXREQ / count) >= size, ENOMEM, NULL);
    }
    size_orig = size * count;
    if (memblock != NULL)
        old_size = _msize(memblock);
    retp = _realloc_base(memblock, size_orig);
    if (retp != NULL && old_size < size_orig)
    {
        memset ((char*)retp + old_size, 0, size_orig - old_size);
    }
    return retp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\putw.c ===
/***
*putw.c - put a binary int to output stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putw() - puts a binary int to an output stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _putw(word, stream) - write a binary int to an output stream
*
*Purpose:
*       Writes sizeof(int) bytes to the output stream, high byte first.
*       This routine should be machine independent.
*
*Entry:
*       int word - integer to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the word put to the stream
*       returns EOF if error, but this is a legit int value, so should
*       test with feof() or ferror().
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _putw (
        int word,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG3 int bytecount = sizeof(int);
        REG2 char *byteptr = (char *)&word;
        int retval;

        _VALIDATE_RETURN((str != NULL), EINVAL, EOF);

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

        while (bytecount--)
        {
            _putc_nolock(*byteptr,stream);
            ++byteptr;
        }
        retval = (ferror(stream) ? EOF : word);

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\putwch.c ===
/***
*putwch.c - write a wide character to console
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putwch() - writes a wide character to a console
*
*******************************************************************************/


#include <stdlib.h>
#include <conio.h>
#include <io.h>
#include <errno.h>
#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <limits.h>

/*
 * declaration for console handle
 */
extern intptr_t _confh;

/***
*wint_t _putwch(ch) - write a wide character to a console
*
*Purpose:
*       Writes a wide character to a console.
*
*Entry:
*       wchar_t ch - wide character to write
*
*Exit:
*       returns the wide character if successful
*       returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t _CRTIMP __cdecl _putwch (
        wchar_t ch
        )
{
        REG2 wint_t retval;

        _mlock(_CONIO_LOCK);
        __try {

        retval = _putwch_nolock(ch);

        }
        __finally {
                _munlock(_CONIO_LOCK);
        }

        return(retval);
}

/***
*_putwch_nolock() -  _putwch() core routine (locked version)
*
*Purpose:
*       Core _putwch() routine; assumes stream is already locked.
*
*       [See _putwch() above for more info.]
*
*Entry: [See _putwch()]
*
*Exit:  [See _putwch()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _putwch_nolock (
        wchar_t ch
        )
{

    int size, num_written;
    static int use_w = 2;
    char mbc[MB_LEN_MAX +1];
    if ( use_w)
    {
        if (_confh == -2)
            __initconout();

        /* write character to console file handle */

        if (_confh == -1)
            return WEOF;
        else if ( !WriteConsoleW( (HANDLE)_confh,
                                  (LPVOID)&ch,
                                  1,
                                  &num_written,
                                  NULL )
                  )
        {
            if ( use_w == 2 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                use_w = 0;
            else
                return WEOF;
        } else
                use_w = 1;
    }

    if ( use_w == 0)
    {
        size = WideCharToMultiByte(
                                   GetConsoleOutputCP(),
                                   0,
                                   (LPWSTR)&ch, 1,
                                   mbc,
                                   MB_LEN_MAX,
                                   NULL,
                                   NULL
                                   );
        if ( (_confh == -1) || !WriteConsole( (HANDLE)_confh,
                                              (LPVOID)mbc,
                                              size,
                                              &num_written,
                                              NULL )
           )
                /* return error indicator */
                return WEOF;
    }
    return ch;
}

/***
*  _cputws() - _cputws() writes a wide char string to console.
*
*  Purpose:
*       Writes a wide char string to console.
*
*  Entry:
*       str:    pointer to string
*  Exit:
*       returns 0 if sucessful. Nonzero if unsucessful
*
*******************************************************************************/
int _CRTIMP __cdecl _cputws(
        const wchar_t *str
        )
{
    size_t len;
    int retval = 0;

    _VALIDATE_CLEAR_OSSERR_RETURN((str != NULL), EINVAL, -1);

    len = wcslen(str);
    _mlock(_CONIO_LOCK);
    __try {
    while(len--)
    {
        if ( _putwch_nolock(*str++) == WEOF)
        {
            retval = -1;
            break;
        }
    }
    }
    __finally {
            _munlock(_CONIO_LOCK);
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rename.c ===
/***
*rename.c - rename file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines rename() - rename a file
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <io.h>
#include <tchar.h>

/***
*int rename(oldname, newname) - rename a file
*
*Purpose:
*       Renames a file to a new name -- no file with new name must
*       currently exist.
*
*Entry:
*       _TSCHAR *oldname -      name of file to rename
*       _TSCHAR *newname -      new name for file
*
*Exit:
*       returns 0 if successful
*       returns not 0 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _trename (
        const _TSCHAR *oldname,
        const _TSCHAR *newname
        )
{
        ULONG dosretval;

        /* ask OS to move file */

        if (!MoveFile((LPTSTR)oldname, (LPTSTR)newname))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\resetstk.c ===
/***
*resetstk.c - Recover from Stack overflow.
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _resetstkoflw() function.
*
*******************************************************************************/

#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <internal.h>
#if defined (_M_IA64)

#include <intrin.h>

//
// IA-64 has a large context record and needs an extra page
// to do the unwind of a stack overflow exception.
// The BSP may also need to be reset.
//

#define MIN_STACK_REQ_WINNT 3
#define MIN_BSP_REQ_WINNT 2
#else  /* defined (_M_IA64) */
#define MIN_STACK_REQ_WINNT 2
#endif  /* defined (_M_IA64) */

/***
* void _resetstkoflw(void) - Recovers from Stack Overflow
*
* Purpose:
*       Sets the guard page to its position before the stack overflow.
*
* Exit:
*       Returns nonzero on success, zero on failure
*
*******************************************************************************/

int __cdecl _resetstkoflw(void)
{
    LPBYTE pStack, pStackBase, pMaxGuard, pMinGuard;
#if defined (_M_IA64)
    LPBYTE pBspBase;
    DWORD BspRegionSize;
#endif  /* defined (_M_IA64) */
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_INFO si;
    DWORD PageSize;
    DWORD RegionSize;
    DWORD flNewProtect;
    DWORD flOldProtect;
    ULONG StackSizeInBytes;
    HMODULE ModuleHandle;
    BOOL
    (*SetThreadStackGuaranteePointer) (
        ULONG *StackSizeInBytes
    );

    // Use _alloca() to get the current stack pointer
#pragma warning(push)
#pragma warning(disable:6255)
    // prefast(6255): This alloca is safe and we do not want a __try here
    pStack = (LPBYTE)_alloca(1);
#pragma warning(pop)

    // Find the base of the stack.

    if (VirtualQuery(pStack, &mbi, sizeof mbi) == 0) {
        return 0;
    }

    pStackBase = (LPBYTE)mbi.AllocationBase;

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;
    RegionSize = 0;

    //
    // Note: if the GuaranteedStackBytes TEB field is 0
    // (on older OS versions or if SetThreadStackGuarantee is
    // not being used) we will use the default value of
    // RegionSize (2 pages for ia64, 1 page for other platforms).
    //

    //
    // Don't call SetThreadStackGuarantee directly as older kernel32.dll
    // versions do not have this export.
    //

    ModuleHandle = GetModuleHandleW (L"kernel32.dll");

    if (ModuleHandle != NULL) {

        SetThreadStackGuaranteePointer = (PVOID) GetProcAddress (ModuleHandle, "SetThreadStackGuarantee");

        if (SetThreadStackGuaranteePointer != NULL) {
            StackSizeInBytes = 0;       // Indicate just querying
            if (SetThreadStackGuaranteePointer (&StackSizeInBytes) == TRUE &&
                StackSizeInBytes > 0) {
                    RegionSize = StackSizeInBytes;
            }
        }
    }

    flNewProtect = PAGE_READWRITE | PAGE_GUARD;
    CRT_WARNING_DISABLE_PUSH(22011, "Silence prefast about overflow/underflow");
    RegionSize = (RegionSize + PageSize - 1) & ~(PageSize - 1);
    CRT_WARNING_POP;

    //
    // If there is a stack guarantee (RegionSize nonzero), then increase
    // our guard page size by 1 so that even a subsequent fault that occurs
    // midway (instead of at the beginning) through the first guard page
    // will have the extra page to preserve the guarantee.
    //

    if (RegionSize != 0) {
        RegionSize += PageSize;
    }

#if defined (_M_IA64)

    //
    // Reset the backstore stack pages.
    //

    //
    // Calculate the top of the BSP stack, by getting the size of the normal
    // stack and adding it to the StackBase.
    //

    pBspBase = (LPBYTE)(((ULONG_PTR)(((PNT_TIB)NtCurrentTeb())->StackBase) - (ULONG_PTR) mbi.AllocationBase) +
        (ULONG_PTR)(((PNT_TIB)NtCurrentTeb())->StackBase));

    //
    // Get the current BSP and round up since the BSP grows up.
    //

    pMinGuard = (LPBYTE) ((__getReg(__REG_IA64_RsBSP) + PageSize) & ~(ULONG_PTR)(PageSize - 1));

    //
    // The highest BSP address is the top of the BSP stack less one page for
    // the guard.
    //

    pMaxGuard = pBspBase - PageSize;

    BspRegionSize = RegionSize;

    if (BspRegionSize < MIN_BSP_REQ_WINNT * PageSize) {
        BspRegionSize = MIN_BSP_REQ_WINNT * PageSize;
    }

    if (((ULONG_PTR)pMaxGuard < BspRegionSize) ||
        (pMaxGuard - BspRegionSize) < pMinGuard) {

        //
        // The current BSP is already in the highest guard region.
        //

        return 0;
    }

    if (VirtualAlloc (pMinGuard, BspRegionSize, MEM_COMMIT, PAGE_READWRITE) == NULL ||
        VirtualProtect (pMinGuard, BspRegionSize, flNewProtect, &flOldProtect) == 0) {
        return 0;
    }

#endif  /* defined (_M_IA64) */

    if (RegionSize < MIN_STACK_REQ_WINNT * PageSize) {
        RegionSize = MIN_STACK_REQ_WINNT * PageSize;
    }

    //
    // Find the page(s) just below where the stack pointer currently points.
    // This is the highest potential guard page.
    //

    pMaxGuard = (LPBYTE) (((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize - 1))
                       - RegionSize);

    //
    // If the potential guard page is too close to the start of the stack
    // region, abandon the reset effort for lack of space.  Win9x has a
    // larger reserved stack requirement.
    //

    pMinGuard = pStackBase + PageSize;

    if (pMaxGuard < pMinGuard) {
        return 0;
    }

    // Set the new guard page just below the current stack page.

    if (VirtualAlloc (pMaxGuard, RegionSize, MEM_COMMIT, PAGE_READWRITE) == NULL ||
        VirtualProtect (pMaxGuard, RegionSize, flNewProtect, &flOldProtect) == 0) {
        return 0;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\raisehan.cpp ===
// raisehan -- pointer to raise handler
#define _HAS_EXCEPTIONS 0
#include <exception>
_X_STD_BEGIN

_Prhand _Raise_handler = 0;	// define raise handler pointer

_X_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rmtmp.c ===
/***
*rmtmp.c - remove temporary files created by tmpfile.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

_CRTALLOC(".CRT$XPX") static _PVFV pterm = _rmtmp;

/*
 * Definitions for _tmpoff, _tempoff and _old_pfxlen. These will cause this
 * module to be linked in whenever the termination code needs it.
 */
#ifndef CRTDLL
unsigned _tmpoff = 1;
#endif  /* CRTDLL */

unsigned _tempoff = 1;
unsigned _old_pfxlen = 0;


/***
*int _rmtmp() - closes and removes temp files created by tmpfile
*
*Purpose:
*       closes and deletes all open files that were created by tmpfile.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _rmtmp (
        void
        )
{
        REG2 int count = 0;
        REG1 int i;

        _mlock(_IOB_SCAN_LOCK);
        __try {

        for ( i = 0 ; i < _nstream ; i++)

                if ( __piob[i] != NULL && inuse( (FILE *)__piob[i] )) {

                        /*
                         * lock the stream. this is not done until testing
                         * the stream is in use to avoid unnecessarily creating
                         * a lock for every stream. the price is having to
                         * retest the stream after the lock has been asserted.
                         */
                        _lock_str2(i, __piob[i]);
                        __try {
                                /*
                                 * if the stream is STILL in use (it may have
                                 * been closed before the lock was asserted),
                                 * see about flushing it.
                                 */
                                if ( inuse( (FILE *)__piob[i] )) {

                        if ( ((FILE *)__piob[i])->_tmpfname != NULL )
                        {
                                _fclose_nolock( __piob[i] );
                                count++;
                        }

                                }
                        }
                        __finally {
                                _unlock_str2(i, __piob[i]);
                        }
                }

        }
        __finally {
                _munlock(_IOB_SCAN_LOCK);
        }

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rotl.c ===
/***
*rotl.c - rotate an unsigned integer left
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines _rotl() - performs a rotate left on an unsigned integer.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

#ifdef _MSC_VER
#pragma function(_lrotl,_rotl, _rotl64)
#endif  /* _MSC_VER */

#if UINT_MAX != 0xffffffff
#error This module assumes 32-bit integers
#endif  /* UINT_MAX != 0xffffffff */

#if UINT_MAX != ULONG_MAX
#error This module assumes sizeof(int) == sizeof(long)
#endif  /* UINT_MAX != ULONG_MAX */

/***
*unsigned _rotl(val, shift) - int rotate left
*
*Purpose:
*   Performs a rotate left on an unsigned integer.
*
*   [Note:  The _lrotl entry is based on the assumption
*   that sizeof(int) == sizeof(long).]
*Entry:
*   unsigned val:   value to rotate
*   int    shift:   number of bits to shift by
*
*Exit:
*   returns rotated value
*
*Exceptions:
*   None.
*
*******************************************************************************/

unsigned long __cdecl _lrotl (
    unsigned long val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val>>(0x20 - shift)) | (val << shift);
    return val;
}

unsigned __cdecl _rotl (
    unsigned val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val>>(0x20 - shift)) | (val << shift);
    return val;
}

unsigned __int64 __cdecl _rotl64 (
    unsigned __int64 val,
    int shift
    )
{
    shift &= 0x3f;
    val = (val>>(0x40 - shift)) | (val << shift);
    return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\qsort.c ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   To implement the qsort() routine for sorting arrays.
*
*******************************************************************************/

#include <stdlib.h>
#include <search.h>
#include <internal.h>

/* Always compile this module for speed, not size */
#pragma optimize("t", on)

#if defined (_M_CEE)
#define __fileDECL  __clrcall
#else  /* defined (_M_CEE) */
#define __fileDECL  __cdecl
#endif  /* defined (_M_CEE) */

/* when building Managed Run time dll, we should be defining __cdecl
 * to __clrcall. Also note that when compiling for MRT, we are compiling
 * as C++ file.
 */

/* prototypes for local routines */
#ifdef __USE_CONTEXT
static void __fileDECL shortsort_s(char *lo, char *hi, size_t width,
                int (__fileDECL *comp)(void *, const void *, const void *), void *);
#define swap swap_c
#else  /* __USE_CONTEXT */
static void __fileDECL shortsort(char *lo, char *hi, size_t width,
                int (__fileDECL *comp)(const void *, const void *));
#endif  /* __USE_CONTEXT */

static void __fileDECL swap(char *p, char *q, size_t width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */

/* Note: the theoretical number of stack entries required is
   no more than 1 + log2(num).  But we switch to insertion
   sort for CUTOFF elements or less, so we really only need
   1 + log2(num) - log2(CUTOFF) stack entries.  For a CUTOFF
   of 8, that means we need no more than 30 stack entries for
   32 bit platforms, and 62 for 64-bit platforms. */
#define STKSIZ (8*sizeof(void*) - 2)

/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*   quicksort the array of elements
*   side effects:  sorts in place
*   maximum array size is number of elements times size of elements,
*   but is limited by the virtual address space of the processor
*
*Entry:
*   char *base = pointer to base of array
*   size_t num  = number of elements in the array
*   size_t width = width in bytes of each array element
*   int (*comp)() = pointer to function returning analog of strcmp for
*           strings, but supplied by user for comparing the array elements.
*           it accepts 2 pointers to elements.
*           Returns neg if 1<2, 0 if 1=2, pos if 1>2.
*
*Exit:
*   returns void
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#define __COMPARE(context, p1, p2) comp(context, p1, p2)
#define __SHORTSORT(lo, hi, width, comp, context) shortsort_s(lo, hi, width, comp, context);
#else  /* __USE_CONTEXT */
#define __COMPARE(context, p1, p2) comp(p1, p2)
#define __SHORTSORT(lo, hi, width, comp, context) shortsort(lo, hi, width, comp);
#endif  /* __USE_CONTEXT */

#ifdef __USE_CONTEXT
void __fileDECL qsort_s (
    void *base,
    size_t num,
    size_t width,
    int (__fileDECL *comp)(void *, const void *, const void *),
    void *context
    )
#else  /* __USE_CONTEXT */
void __fileDECL qsort (
    void *base,
    size_t num,
    size_t width,
    int (__fileDECL *comp)(const void *, const void *)
    )
#endif  /* __USE_CONTEXT */
{
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    size_t size;                /* size of the sub-array */
    char *lostk[STKSIZ], *histk[STKSIZ];
    int stkptr;                 /* stack for saving sub-array to be processed */

    /* validation section */
    _VALIDATE_RETURN_VOID(base != NULL || num == 0, EINVAL);
    _VALIDATE_RETURN_VOID(width > 0, EINVAL);
    _VALIDATE_RETURN_VOID(comp != NULL, EINVAL);

    if (num < 2)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       preserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
        __SHORTSORT(lo, hi, width, comp, context);
    }
    else {
        /* First we pick a partitioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the median
           of the values, but also that we select one fast.  We choose the
           median of the first, middle, and last elements, to avoid bad
           performance in the face of already sorted data, or data that is made
           up of multiple sorted runs appended together.  Testing shows that a
           median-of-three algorithm provides better performance than simply
           picking the middle element for the latter case. */

        mid = lo + (size / 2) * width;      /* find middle element */

        /* Sort the first, middle, last elements into order */
        if (__COMPARE(context, lo, mid) > 0) {
            swap(lo, mid, width);
        }
        if (__COMPARE(context, lo, hi) > 0) {
            swap(lo, hi, width);
        }
        if (__COMPARE(context, mid, hi) > 0) {
            swap(mid, hi, width);
        }

        /* We now wish to partition the array into three pieces, one consisting
           of elements <= partition element, one of elements equal to the
           partition element, and one of elements > than it.  This is done
           below; comments indicate conditions established at every step. */

        loguy = lo;
        higuy = hi;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi,
               A[i] <= A[mid] for lo <= i <= loguy,
               A[i] > A[mid] for higuy <= i < hi,
               A[hi] >= A[mid] */

            /* The doubled loop is to avoid calling comp(mid,mid), since some
               existing comparison funcs don't work when passed the same
               value for both pointers. */

            if (mid > loguy) {
                do  {
                    loguy += width;
                } while (loguy < mid && __COMPARE(context, loguy, mid) <= 0);
            }
            if (mid <= loguy) {
                do  {
                    loguy += width;
                } while (loguy <= hi && __COMPARE(context, loguy, mid) <= 0);
            }

            /* lo < loguy <= hi+1, A[i] <= A[mid] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[mid] */

            do  {
                higuy -= width;
            } while (higuy > mid && __COMPARE(context, higuy, mid) > 0);

            /* lo <= higuy < hi, A[i] > A[mid] for higuy < i < hi,
               either higuy == lo or A[higuy] <= A[mid] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy == lo, then we would have exited, so
               A[loguy] > A[mid], A[higuy] <= A[mid],
               loguy <= hi, higuy > lo */

            swap(loguy, higuy, width);

            /* If the partition element was moved, follow it.  Only need
               to check for mid == higuy, since before the swap,
               A[loguy] > A[mid] implies loguy != mid. */

            if (mid == higuy)
                mid = loguy;

            /* A[loguy] <= A[mid], A[higuy] > A[mid]; so condition at top
               of loop is re-established */
        }

        /*     A[i] <= A[mid] for lo <= i < loguy,
               A[i] > A[mid] for higuy < i < hi,
               A[hi] >= A[mid]
               higuy < loguy
           implying:
               higuy == loguy-1
               or higuy == hi - 1, loguy == hi + 1, A[hi] == A[mid] */

        /* Find adjacent elements equal to the partition element.  The
           doubled loop is to avoid calling comp(mid,mid), since some
           existing comparison funcs don't work when passed the same value
           for both pointers. */

        higuy += width;
        if (mid < higuy) {
            do  {
                higuy -= width;
            } while (higuy > mid && __COMPARE(context, higuy, mid) == 0);
        }
        if (mid >= higuy) {
            do  {
                higuy -= width;
            } while (higuy > lo && __COMPARE(context, higuy, mid) == 0);
        }

        /* OK, now we have the following:
              higuy < loguy
              lo <= higuy <= hi
              A[i]  <= A[mid] for lo <= i <= higuy
              A[i]  == A[mid] for higuy < i < loguy
              A[i]  >  A[mid] for loguy <= i < hi
              A[hi] >= A[mid] */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - lo >= hi - loguy ) {
            if (lo < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo < higuy) {
                hi = higuy;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*shortsort_s(hi, lo, width, comp, context) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements, together with a pointer to a context
*               (if present). Returns neg if 1<2, 0 if 1=2, pos if 1>2.
*       void *context - pointer to the context in which the function is
*               called. This context is passed to the comparison function.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

#ifdef __USE_CONTEXT
static void __fileDECL shortsort_s (
    char *lo,
    char *hi,
    size_t width,
    int (__fileDECL *comp)(void *, const void *, const void *),
    void * context
    )
#else  /* __USE_CONTEXT */
static void __fileDECL shortsort (
    char *lo,
    char *hi,
    size_t width,
    int (__fileDECL *comp)(const void *, const void *)
    )
#endif  /* __USE_CONTEXT */
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (__COMPARE(context, p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}

/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       size_t width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __fileDECL swap (
    char *a,
    char *b,
    size_t width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}

#undef __fileDECL
#undef __COMPARE
#undef __SHORTSORT
#undef swap
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rotr.c ===
/***
*rotr.c - rotate an unsigned integer right
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines _rotr() - performs a rotate right on an unsigned integer.
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

#ifdef _MSC_VER
#pragma function(_lrotr,_rotr, _rotr64)
#endif  /* _MSC_VER */

#if UINT_MAX != 0xffffffff
#error This module assumes 32-bit integers
#endif  /* UINT_MAX != 0xffffffff */

#if UINT_MAX != ULONG_MAX
#error This module assumes sizeof(int) == sizeof(long)
#endif  /* UINT_MAX != ULONG_MAX */

/***
*unsigned _rotr(val, shift) - int rotate right
*
*Purpose:
*   Performs a rotate right on an unsigned integer.
*
*   [Note:  The _lrotl entry is based on the assumption
*   that sizeof(int) == sizeof(long).]
*Entry:
*   unsigned val:   value to rotate
*   int    shift:   number of bits to shift by
*
*Exit:
*   returns rotated value
*
*Exceptions:
*   None.
*
*******************************************************************************/

unsigned long __cdecl _lrotr (
    unsigned long val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val<<(0x20 - shift)) | (val >> shift);
    return val;
}

unsigned __cdecl _rotr (
    unsigned val,
    int shift
    )
{
    shift &= 0x1f;
    val = (val<<(0x20 - shift)) | (val >> shift);
    return val;
}

unsigned __int64 __cdecl _rotr64 (
    unsigned __int64 val,
    int shift
    )
{
    shift &= 0x3f;
    val = (val<<(0x40 - shift)) | (val >> shift);
    return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI

#ifdef _RTC

#include <crtdefs.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/*
Previous versions of this header included declarations of functions used by RTC but
not intended for use by end-users. These functions are now declared deprecated by default
and may be removed in a future version.
*/
#ifndef _CRT_ENABLE_RTC_INTERNALS
#define _RTCINTERNAL_DEPRECATED _CRT_DEPRECATE_TEXT("These internal RTC functions are obsolete and should not be used")
#else  /* _CRT_ENABLE_RTC_INTERNALS */
#define _RTCINTERNAL_DEPRECATED
#endif  /* _CRT_ENABLE_RTC_INTERNALS */



#ifdef __cplusplus

extern "C" {

#endif  /* __cplusplus */

    /* General User API */

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_CORRUPTED_ALLOCA,
    _RTC_ILLEGAL
} _RTC_ErrorNumber;

#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);
    typedef int (__cdecl *_RTC_error_fnW)(int, const wchar_t *, int, const wchar_t *, const wchar_t *, ...);

    /* User API */
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber  _Errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber  _Errnum, int _ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);
    _RTC_error_fnW __cdecl _RTC_SetErrorFuncW(_RTC_error_fnW);

    /* Power User/library API */


    /* Init functions */

    /* These functions all call _CRT_RTC_INIT */
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    /*
     * If you're not using the CRT, you have to implement _CRT_RTC_INIT
     * Just return either null, or your error reporting function
     * *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
     */
    _RTC_error_fn __cdecl _CRT_RTC_INIT(void *_Res0, void **_Res1, int _Res2, int _Res3, int _Res4);
    _RTC_error_fnW __cdecl _CRT_RTC_INITW(void *_Res0, void **_Res1, int _Res2, int _Res3, int _Res4);

    /* Compiler generated calls (unlikely to be used, even by power users) */
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* NOTE:
        Changing this structure requires a matching compiler backend
        update, because the offsets are hardcoded inside there.
    */
#pragma pack(push, 1)
    /*  Structure padded under 32-bit x86, to get consistent
        execution between 32/64 targets.
    */
    typedef struct _RTC_ALLOCA_NODE {
        __int32 guard1;
        struct _RTC_ALLOCA_NODE *next;
#if defined (_M_IX86)
        __int32 dummypad;
#endif  /* defined (_M_IX86) */
        size_t allocaSize;
#if defined (_M_IX86)
        __int32 dummypad2;
#endif  /* defined (_M_IX86) */
        __int32 guard2[3];
    } _RTC_ALLOCA_NODE;
#pragma pack(pop)

#if !defined (_M_CEE) && !defined (_M_CEE_PURE)
    /* These unsupported functions are deprecated in native mode and not supported at all in /clr mode */

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    _RTCINTERNAL_DEPRECATED char   __fastcall _RTC_Check_2_to_1(short _Src);
    _RTCINTERNAL_DEPRECATED char   __fastcall _RTC_Check_4_to_1(int _Src);
    _RTCINTERNAL_DEPRECATED char   __fastcall _RTC_Check_8_to_1(__int64 _Src);
    _RTCINTERNAL_DEPRECATED short  __fastcall _RTC_Check_4_to_2(int _Src);
    _RTCINTERNAL_DEPRECATED short  __fastcall _RTC_Check_8_to_2(__int64 _Src);
    _RTCINTERNAL_DEPRECATED int    __fastcall _RTC_Check_8_to_4(__int64 _Src);
#endif  /* !defined (_M_CEE) && !defined (_M_CEE_PURE) */


    /* Stack Checking Calls */
#if defined (_M_IX86)
    void   __cdecl     _RTC_CheckEsp();
#endif  /* defined (_M_IX86) */

#if !defined (_M_CEE) && !defined (_M_CEE_PURE)
    /* These unsupported functions are deprecated in native mode and not supported at all in /clr mode */

    _RTCINTERNAL_DEPRECATED  void   __fastcall _RTC_CheckStackVars(void *_Esp, _RTC_framedesc *_Fd);
    _RTCINTERNAL_DEPRECATED  void   __fastcall _RTC_CheckStackVars2(void *_Esp, _RTC_framedesc *_Fd, _RTC_ALLOCA_NODE *_AllocaList);
    _RTCINTERNAL_DEPRECATED  void   __fastcall _RTC_AllocaHelper(_RTC_ALLOCA_NODE *_PAllocaBase, size_t _CbSize, _RTC_ALLOCA_NODE **_PAllocaInfoList);
#endif  /* !defined (_M_CEE) && !defined (_M_CEE_PURE) */
    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *_Varname);

#if !defined (_M_CEE) && !defined (_M_CEE_PURE)
    /* These unsupported functions are deprecated in native mode and not supported at all in /clr mode */

#endif  /* !defined (_M_CEE) && !defined (_M_CEE_PURE) */

    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);


#ifdef __cplusplus

    void* _ReturnAddress();
}

#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _RTC */

#endif  /* _INC_RTCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\read.c ===
/***
*read.c - read from a file handle
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _read() - read from a file handle
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <io.h>
#include <internal.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <dbgint.h>

/*
    This lookup table returns
    1 for pattern 110xxxxx - 1 trailbyte
    2 for pattern 1110xxxx - 2 trailbytes
    3 for pattern 11110xxx - 3 trailbytes
    0 for everything else (including invalid patterns)
    We return 0 for invalid patterns also because we
    rely on MultiByteToWideChar to do the validations
*/

char _lookuptrailbytes[256] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0
};

/***
*int _read(fh, buf, cnt) - read bytes from a file handle
*
*Purpose:
*       Attempts to read cnt bytes from fh into a buffer.
*       If the file is in text mode, CR-LF's are mapped to LF's, thus
*       affecting the number of characters read.  This does not
*       affect the file pointer.
*
*       NOTE:  The stdio _IOCTRLZ flag is tied to the use of FEOFLAG.
*       Cross-reference the two symbols before changing FEOFLAG's use.
*
*Entry:
*       int fh - file handle to read from
*       char *buf - buffer to read into
*       int cnt - number of bytes to read
*
*Exit:
*       Returns number of bytes read (may be less than the number requested
*       if the EOF was reached or the file is in text mode).
*       returns -1 (and sets errno) if fails.
*
*Exceptions:
*
*******************************************************************************/


/* define normal version that locks/unlocks, validates fh */
int __cdecl _read (
        int fh,
        void *buf,
        unsigned cnt
        )
{
        int r;                          /* return value */

        /* validate handle */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((cnt <= INT_MAX), EINVAL, -1);

        _lock_fh(fh);                   /* lock file */

        __try {
            if ( _osfile(fh) & FOPEN )
                r = _read_nolock(fh, buf, cnt); /* read bytes */
            else {
                errno = EBADF;
                _doserrno = 0;
                r = -1;
                _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
            }
        }
        __finally {
            _unlock_fh(fh);             /* unlock file */
        }

        return r;
}

/* now define version that doesn't lock/unlock, validate fh */
int __cdecl _read_nolock (
        int fh,
        void *inputbuf,
        unsigned cnt
        )
{

        int bytes_read;                 /* number of bytes read */
        char *buffer;                   /* buffer to read to */
        int os_read;                    /* bytes read on OS call */
        char *p, *q;                    /* pointers into buffer */
        wchar_t *pu, *qu;               /* wchar_t pointers into buffer for UTF16 */
        char peekchr;                   /* peek-ahead character */
        wchar_t wpeekchr;               /* peek-ahead wchar_t */
        __int64 filepos;                /* file position after seek */
        ULONG dosretval;                /* o.s. return value */
        char tmode;                         /* textmode - ANSI/UTF-8/UTF-16 */
        void *buf;                          /* buffer to read to */
        int retval = -2;                    /* return value */
        unsigned inputsize = cnt;

        /* validate fh */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((cnt <= INT_MAX), EINVAL, -1);


        bytes_read = 0;                 /* nothing read yet */

        if (cnt == 0 || (_osfile(fh) & FEOFLAG)) {
            /* nothing to read or at EOF, so return 0 read */
            return 0;
        }

        _VALIDATE_CLEAR_OSSERR_RETURN( (inputbuf != NULL), EINVAL, -1 );

        tmode = _textmode(fh);

        switch(tmode) {
            case __IOINFO_TM_UTF8 :
                /* For a UTF-8 file, we need 2 buffers, because after reading we
                   need to convert it into UNICODE - MultiByteToWideChar doesn't do
                   in-place conversions. */

                /* MultiByte To WideChar conversion may double the size of the
                   buffer required & hence we divide cnt by 2 */

                /*
                 * Since we are reading UTF8 stream, cnt bytes read may vary
                 * from cnt wchar_t characters to cnt/4 wchar_t characters. For
                 * this reason if we need to read cnt characters, we will
                 * allocate MBCS buffer of cnt. In case cnt is 0, we will
                 * have 4 as minimum value. This will make sure we don't
                 * overflow for reading from pipe case.
                 *
                 *
                 * In this case the numbers of wchar_t characters that we can
                 * read is cnt/2. This means that the buffer size that we will
                 * require is cnt/2.
                 */

                /* For UTF8 we want the count to be an even number */
                _VALIDATE_CLEAR_OSSERR_RETURN(((cnt & 1) == 0), EINVAL, -1);

                cnt = (cnt/2) < 4 ? 4 : (cnt/2);

                buf = _malloc_crt(cnt);

                if(!buf) {
                    errno = ENOMEM;
                    _doserrno = E_nomem;
                    return -1;
                }
                _startpos(fh) = _lseeki64_nolock(fh, 0, FILE_CURRENT);
                break;

            case __IOINFO_TM_UTF16LE :
                /* For UTF16 the count always needs to be an even number */
                _VALIDATE_CLEAR_OSSERR_RETURN(((cnt & 1) == 0), EINVAL, -1);

                cnt &= (~1);

                /* Fall Through to default */

            default :
                /* For non-UTF8 files, we need only 1 buffer - make buf point to
                   the users input buffer */
                buf = inputbuf;
        }


        buffer = buf;

        if ((_osfile(fh) & (FPIPE|FDEV)) && _pipech(fh) != LF && cnt != 0) {
            /* a pipe/device and pipe lookahead non-empty: read the lookahead
             * char */
            *buffer++ = _pipech(fh);
            ++bytes_read;
            --cnt;
            _pipech(fh) = LF;           /* mark as empty */

            /* For UTF16, there maybe one more look ahead char. For UTF8,
               there maybe 2 more look ahead chars */
            if((tmode != __IOINFO_TM_ANSI) && (_pipech2(fh)[0] != LF) && cnt != 0) {
                *buffer++ = _pipech2(fh)[0];
                ++bytes_read;
                --cnt;
                _pipech2(fh)[0] = LF;   /* mark as empty */

                if((tmode == __IOINFO_TM_UTF8) && (_pipech2(fh)[1] != LF) && cnt != 0) {
                    *buffer++ = _pipech2(fh)[1];
                    ++bytes_read;
                    --cnt;
                    _pipech2(fh)[1] = LF;   /* mark as empty */
                }

            }

        }

        /* read the data */

        if ( !ReadFile( (HANDLE)_osfhnd(fh), buffer, cnt, (LPDWORD)&os_read,
                    NULL ) || os_read < 0 || (size_t)os_read > cnt)
        {
            /* ReadFile has reported an error. recognize two special cases.
             *
             *      1. map ERROR_ACCESS_DENIED to EBADF
             *
             *      2. just return 0 if ERROR_BROKEN_PIPE has occurred. it
             *         means the handle is a read-handle on a pipe for which
             *         all write-handles have been closed and all data has been
             *         read. */

            if ( (dosretval = GetLastError()) == ERROR_ACCESS_DENIED ) {
                /* wrong read/write mode should return EBADF, not EACCES */
                errno = EBADF;
                _doserrno = dosretval;
                retval = -1;
                goto error_return;

            }
            else if ( dosretval == ERROR_BROKEN_PIPE ) {
                retval = 0;
                goto error_return;
            }
            else {
                _dosmaperr(dosretval);
                retval = -1;
                goto error_return;
            }
        }

        bytes_read += os_read;          /* update bytes read */

        if (_osfile(fh) & FTEXT) {
            /* now must translate CR-LFs to LFs in the buffer */

            /* For ANSI & UTF8, we read byte by byte.
               For UTF16, we need to read 2 bytes (wchar_t's) at a time */
            if(tmode != __IOINFO_TM_UTF16LE) {
                /* set CRLF flag to indicate LF at beginning of buffer */
                if ( (os_read != 0) && (*(char *)buf == LF) )
                    _osfile(fh) |= FCRLF;
                else
                    _osfile(fh) &= ~FCRLF;

                /* convert chars in the buffer: p is src, q is dest */
                p = q = buf;
                while (p < (char *)buf + bytes_read) {
                    if (*p == CTRLZ) {
                        /* if fh is not a device, set ctrl-z flag */
                        if ( !(_osfile(fh) & FDEV) )
                            _osfile(fh) |= FEOFLAG;
                        else
                            *q++ = *p++;
                        break;              /* stop translating */
                    }
                    else if (*p != CR)
                        *q++ = *p++;
                    else {
                        /* *p is CR, so must check next char for LF */
                        if (p < (char *)buf + bytes_read - 1) {
                            if (*(p+1) == LF) {
                                p += 2;
                                *q++ = LF;  /* convert CR-LF to LF */
                            }
                            else
                                *q++ = *p++;    /* store char normally */
                        }
                        else {
                            /* This is the hard part.  We found a CR at end of
                               buffer.  We must peek ahead to see if next char
                               is an LF. */
                            ++p;

                            dosretval = 0;
                            if ( !ReadFile( (HANDLE)_osfhnd(fh), &peekchr, 1,
                                        (LPDWORD)&os_read, NULL ) )
                                dosretval = GetLastError();

                            if (dosretval != 0 || os_read == 0) {
                                /* couldn't read ahead, store CR */
                                *q++ = CR;
                            }
                            else {
                                /*
                                 * peekchr now has the extra character -- we now
                                 * have several possibilities:
                                 *
                                 * 1. disk file and char is not LF; just seek
                                 *    back and copy CR
                                 * 2. disk file and char is LF; seek back and
                                 *    discard CR
                                 * 3. disk file, char is LF but this is a
                                 *    one-byte read: store LF, don't seek back
                                 * 4. pipe/device and char is LF; store LF.
                                 * 5. pipe/device and char isn't LF, store CR
                                 *    and put char in pipe lookahead buffer.
                                 */
                                if (_osfile(fh) & (FDEV|FPIPE)) {
                                    /* non-seekable device */
                                    if (peekchr == LF)
                                        *q++ = LF;
                                    else {
                                        *q++ = CR;
                                        _pipech(fh) = peekchr;
                                    }
                                }
                                else {
                                    /* disk file */
                                    if (q == buf && peekchr == LF) {
                                        /* nothing read yet; must make some
                                           progress */
                                        *q++ = LF;
                                    }
                                    else {
                                        /* seek back */
                                        filepos = _lseeki64_nolock(fh, -1i64, FILE_CURRENT);
                                        if (peekchr != LF)
                                            *q++ = CR;
                                    }
                                }
                            }
                        }
                    }
                }


                /* we now change bytes_read to reflect the true number of chars
                   in the buffer */
                bytes_read = (int)(q - (char *)buf);

                if((tmode == __IOINFO_TM_UTF8) && (bytes_read != 0)) {
                    /* UTF8 reads need to be converted into UTF16 */

                    --q; /* q has gone beyond the last char */

                    /*
                     * If the last byte is a standalone UTF-8 char. We then
                     * take the whole buffer. Otherwise we skip back till we
                     * come to a lead byte. If the leadbyte forms a complete
                     * UTF-8 character will the remaining part of the buffer,
                     * then again we take the whole buffer. If not, we skip to
                     * one byte which should be the final trail byte of the
                     * previous UTF-8 char or a standalone UTF-8 character
                     */

                    if(_utf8_is_independent(*q)) {
                        ++q;
                        /*
                         * Final byte is standalone, we reset q, because we
                         * will now consider the full buffer which we have read
                         */
                    }
                    else {
                        int ctr = 1;
                        int cnt_trailbytes;

                        while(!_utf8_is_leadbyte(*q) && ctr <= 4 && q >= (char *)buf) {
                            --q;
                            ++ctr;
                        }

                        cnt_trailbytes = _utf8_no_of_trailbytes(*q);

                        if(cnt_trailbytes == 0) {
                            /*
                             * Should have exited the while by finding a lead
                             * byte else, the file has incorrect UTF-8 chars
                             */
                                errno = EILSEQ;
                                retval = -1;
                                goto error_return;
                            }

                        if(cnt_trailbytes + 1 == ctr) {
                            /*
                             * The leadbyte + the remaining bytes form a full
                             * set
                             */
                            q += ctr;
                        }
                        else {
                            /* Seek back */

                            if (_osfile(fh) & (FDEV|FPIPE)) {
                                /*
                                 * non-seekable device. Put the extra chars in
                                 * _pipech & _pipech2. We would have a maximum
                                 * of 3 extra chars
                                 */
                                _pipech(fh) = *q;
                                ++q;

                                if(ctr >= 2) {
                                    _pipech2(fh)[0] = *q;
                                    ++q;
                                }
                                if(ctr == 3) {
                                    _pipech2(fh)[1] = *q;
                                    ++q;
                                }

                                /*
                                 * We need to point q back to beyond whatever
                                 * we actually took in.
                                 */
                                q -= ctr;

                            }
                            else {
                                /* We have read extra chars, so we seek back */
                                filepos = _lseeki64_nolock(fh, -ctr, FILE_CURRENT);

                        }

                        }
                    }

                    bytes_read = (int)(q - (char *)buf);
                    bytes_read = MultiByteToWideChar(
                            CP_UTF8,
                            0,
                            buf,
                            bytes_read,
                            inputbuf,
                            inputsize/2);

                    if(!bytes_read) {
                        _dosmaperr(GetLastError());
                        retval = -1;
                        goto error_return;
                    }

                    _utf8translations(fh) = (bytes_read != (int)(q - (char *)buf));

                    /* MultiByteToWideChar returns no of wchar_t's. Double it */
                    bytes_read = bytes_read*2;
                }
            }
            else {
                /* set CRLF flag to indicate LF at beginning of buffer */
                if ( (os_read != 0) && (*(wchar_t *)buf == LF) )
                    _osfile(fh) |= FCRLF;
                else
                    _osfile(fh) &= ~FCRLF;

                /* convert chars in the buffer: pu is src, qu is dest */
                pu = qu = (wchar_t *)buf;
                while ((char *)pu < (char *)buf + bytes_read) {
                    if (*pu == CTRLZ) {
                        /* if fh is not a device, set ctrl-z flag */
                        if ( !(_osfile(fh) & FDEV) )
                            _osfile(fh) |= FEOFLAG;
                        else
                            *qu++ = *pu++;
                        break;              /* stop translating */
                    }
                    else if (*pu != CR)
                        *qu++ = *pu++;
                    else {
                        /* *pu is CR, so must check next wchar_t for LF */
                        if ((char *)pu < (char *)buf + bytes_read - 2) {
                            if (*(pu+1) == LF) {
                                pu += 2;
                                *qu++ = LF;  /* convert CR-LF to LF */
                            }
                            else
                                *qu++ = *pu++;    /* store char normally */
                        }
                        else {
                            /* This is the hard part.  We found a CR at end of
                               buffer.  We must peek ahead to see if next
                               wchar_t is an LF. */
                            ++pu;

                            dosretval = 0;
                            if ( !ReadFile( (HANDLE)_osfhnd(fh), &wpeekchr, 2,
                                        (LPDWORD)&os_read, NULL ) )
                                dosretval = GetLastError();

                            if (dosretval != 0 || os_read == 0) {
                                /* couldn't read ahead, store CR */
                                *qu++ = CR;
                            }
                            else {
                                /*
                                 * peekchr now has the extra character -- we
                                 * now have several possibilities:
                                 * 1. wchar_t is not LF; just seek back and
                                 * copy CR
                                 * 2. wchar_t is LF; seek back and discard CR
                                 * 3. disk file, wchar_t is LF but this is a
                                 * one-byte read: store LF, don't seek back.
                                 */

                                if (_osfile(fh) & (FDEV|FPIPE)) {
                                    /* non-seekable device */
                                    if (wpeekchr == LF)
                                        *qu++ = LF;
                                    else {
                                        char * pwpeekchr = (char *)&wpeekchr;
                                        *qu++ = CR;
                                        _pipech(fh) = *pwpeekchr;
                                        ++pwpeekchr;
                                        _pipech2(fh)[0] = *pwpeekchr;
                                        _pipech2(fh)[1] = LF; /* Mark as empty */
                                    }
                                }
                                else {
                                    if ((char *)qu == buf && wpeekchr == LF) {
                                        /* nothing read yet; must make some
                                           progress */
                                        *qu++ = LF;
                                    }
                                    else {
                                        /* seek back */
                                        filepos = _lseeki64_nolock(fh, -2, FILE_CURRENT);
                                        if (wpeekchr != LF)
                                            *qu++ = CR;
                                    }
                                }
                            }
                        }
                    }
                }

                /* we now change bytes_read to reflect the true number of chars
                   in the buffer */
                bytes_read = (int)((char *)qu - (char *)buf);

            }

        }

error_return:
        if(buf != inputbuf) {
            free(buf);
        }

        return (retval == -2) ? bytes_read : retval ;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rtcsup.h ===
/***
*rtcsup.h - declarations and definitions for RTC support (import lib support)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for all 'hook' function used from
*       within an external library to support RTC checks.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_RTCSUP
#define _INC_RTCSUP

#ifdef _RTC

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#include <rtcapi.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

# define RTCCALLBACK(a, b)

extern void *_RTC_api_change_mutex;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#else  /* _RTC */

#define RTCCALLBACK(a, b)

#endif  /* _RTC */

#endif  /* _INC_RTCSUP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rand.c ===
/***
*rand.c - random number generator
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines rand(), srand() - random number generator
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>


/***
*void srand(seed) - seed the random number generator
*
*Purpose:
*       Seeds the random number generator with the int given.  Adapted from the
*       BASIC random number generator.
*
*Entry:
*       unsigned seed - seed to seed rand # generator with
*
*Exit:
*       None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl srand (
        unsigned int seed
        )
{

        _getptd()->_holdrand = (unsigned long)seed;

}


/***
*int rand() - returns a random number
*
*Purpose:
*       returns a pseudo-random number 0 through 32767.
*
*Entry:
*       None.
*
*Exit:
*       Returns a pseudo-random number 0 through 32767.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl rand (
        void
        )
{

        _ptiddata ptd = _getptd();

        return( ((ptd->_holdrand = ptd->_holdrand * 214013L
            + 2531011L) >> 16) & 0x7fff );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rterr.h ===
/***
*rterr.h - runtime errors
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the C runtime errors
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_RTERR
#define _INC_RTERR

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _RT_STACK                               0               /* stack overflow */
#define _RT_NULLPTR                             1               /* null pointer assignment */
#define _RT_FLOAT                               2               /* floating point not loaded */
#define _RT_INTDIV                              3               /* integer divide by 0 */

/*
 * the following three errors must be in the given order!
 */
#define _RT_EXECMEM                             5               /* not enough memory on exec */
#define _RT_EXECFORM                    6               /* bad format on exec */
#define _RT_EXECENV                             7               /* bad environment on exec */

#define _RT_SPACEARG                    8               /* not enough space for arguments */
#define _RT_SPACEENV                    9               /* not enough space for environment */
#define _RT_ABORT                               10              /* Abnormal program termination */

#define _RT_NPTR                                12              /* illegal near pointer use */
#define _RT_FPTR                                13              /* illegal far pointer use */
#define _RT_BREAK                               14              /* control-BREAK encountered */
#define _RT_INT                                 15              /* unexpected interrupt */
#define _RT_THREAD                              16              /* not enough space for thread data */
#define _RT_LOCK                                17              /* unexpected multi-thread lock error */
#define _RT_HEAP                                18              /* unexpected heap error */
#define _RT_OPENCON                             19              /* unable to open console device */

/*
 * _RT_QWIN and _RT_NOMAIN are used in 16-bit Windows support
 */
#define _RT_QWIN                                20              /* unexpected QuickWin error */
#define _RT_NOMAIN                              21              /* no main procedure */


#define _RT_NONCONT                             22              /* non-continuable exception */
#define _RT_INVALDISP                   23              /* invalid disposition of exception */


/*
 * _RT_ONEXIT is specific to Win32 and Dosx32 platforms
 */
#define _RT_ONEXIT                              24              /* insufficient heap to allocate
                                             * initial table of funct. ptrs
                                             * used by _onexit()/atexit(). */

#define _RT_PUREVIRT                    25              /* pure virtual function call attempted
                                             * (C++ error) */

#define _RT_STDIOINIT                   26              /* not enough space for stdio initial-
                                             * ization */
#define _RT_LOWIOINIT                   27              /* not enough space for lowio initial-
                                             * ization */
#define _RT_HEAPINIT                    28              /* heap failed to initialize */
#define _RT_BADCLRVERSION               29              /* Application appdomain setting incompatible with CLR */

#define _RT_CRT_NOTINIT                 30              /* CRT is not initialized */

#define _RT_CRT_INIT_CONFLICT   31              /* global initialization order conflict */

#define _RT_LOCALE                              32              /* lack of space for locale */

#define _RT_CRT_INIT_MANAGED_CONFLICT     33      /* global initialization order conflict */

#define _RT_CHECKMANIFEST           34              /* manifest check failed */

/*
 * _RT_COOKIE_INIT is not valid for _NMSG_WRITE, _RT_COOKIE_INIT_TXT is passed
 * directly to FatalAppExit in __security_init_cookie.
 */
#define _RT_COOKIE_INIT         35              /* __security_init_cookie called too late */

/*
 * _RT_DOMAIN, _RT_SING and _RT_TLOSS are generated by the floating point
 * library.
 */
#define _RT_DOMAIN                              120
#define _RT_SING                                121
#define _RT_TLOSS                               122

#define _RT_CRNL                                252
#define _RT_BANNER                              255

#endif  /* _INC_RTERR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\realloc.c ===
/***
*realloc.c - Reallocate a block of memory in the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the realloc() and _expand() functions.
*
*******************************************************************************/

#ifdef WINHEAP

#include <cruntime.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>


/***
*void *realloc(pblock, newsize) - reallocate a block of memory in the heap
*
*Purpose:
*       Reallocates a block in the heap to newsize bytes. newsize may be
*       either greater or less than the original size of the block. The
*       reallocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*       Special ANSI Requirements:
*
*       (1) realloc(NULL, newsize) is equivalent to malloc(newsize)
*
*       (2) realloc(pblock, 0) is equivalent to free(pblock) (except that
*           NULL is returned)
*
*       (3) if the realloc() fails, the object pointed to by pblock is left
*           unchanged
*
*Entry:
*       void *pblock    - pointer to block in the heap previously allocated
*                         by a call to malloc(), realloc() or _expand().
*
*       size_t newsize  - requested size for the re-allocated block
*
*Exit:
*       Success:  Pointer to the re-allocated memory block
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*       If pblock does not point to a valid allocation block in the heap,
*       realloc() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _realloc_base (void * pBlock, size_t newsize)
{
        void *      pvReturn;
        size_t      origSize = newsize;

        //  if ptr is NULL, call malloc
        if (pBlock == NULL)
            return(_malloc_base(newsize));

        //  if ptr is nonNULL and size is zero, call free and return NULL
        if (newsize == 0)
        {
            _free_base(pBlock);
            return(NULL);
        }


#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            PHEADER     pHeader;
            size_t      oldsize;

            for (;;)
            {
                pvReturn = NULL;
                if (newsize <= _HEAP_MAXREQ)
                {
                    _mlock( _HEAP_LOCK );
                    __try
                    {

                    //  test if current block is in the small-block heap
                    if ((pHeader = __sbh_find_block(pBlock)) != NULL)
                    {
                        //  if the new size is not over __sbh_threshold, attempt
                        //  to reallocate within the small-block heap
                        if (newsize <= __sbh_threshold)
                        {
                            if (__sbh_resize_block(pHeader, pBlock, (int)newsize))
                                pvReturn = pBlock;
                            else if ((pvReturn = __sbh_alloc_block((int)newsize)) != NULL)
                            {
                                oldsize = ((PENTRY)((char *)pBlock -
                                                    sizeof(int)))->sizeFront - 1;
                                memcpy(pvReturn, pBlock, __min(oldsize, newsize));
                                // headers may have moved, get pHeader again
                                pHeader = __sbh_find_block(pBlock);
                                __sbh_free_block(pHeader, pBlock);
                            }
                        }

                        //  If the reallocation has not been (successfully)
                        //  performed in the small-block heap, try to allocate
                        //  a new block with HeapAlloc.
                        if (pvReturn == NULL)
                        {
                            if (newsize == 0)
                                newsize = 1;
                            newsize = (newsize + BYTES_PER_PARA - 1) &
                                      ~(BYTES_PER_PARA - 1);
                            if ((pvReturn = HeapAlloc(_crtheap, 0, newsize)) != NULL)
                            {
                                oldsize = ((PENTRY)((char *)pBlock -
                                                    sizeof(int)))->sizeFront - 1;
                                memcpy(pvReturn, pBlock, __min(oldsize, newsize));
                                __sbh_free_block(pHeader, pBlock);
                            }
                        }
                    }

                    }
                    __finally
                    {
                        _munlock( _HEAP_LOCK );
                    }

                    //  the current block is NOT in the small block heap iff pHeader
                    //  is NULL
                    if ( pHeader == NULL )
                    {
                        if (newsize == 0)
                            newsize = 1;
                        newsize = (newsize + BYTES_PER_PARA - 1) &
                                  ~(BYTES_PER_PARA - 1);
                        pvReturn = HeapReAlloc(_crtheap, 0, pBlock, newsize);
                    }
                }
                else    /* newsize > _HEAP_MAXREQ */
                {
                    _callnewh(newsize);
                    errno = ENOMEM;
                    return NULL;
                }

                if ( pvReturn || _newmode == 0)
                {
                    if (pvReturn)
                    {
                        RTCCALLBACK(_RTC_Free_hook, (pBlock, 0));
                        RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, newsize, 0));
                    }
                    else
                    {
                        if (pHeader == NULL)
                        {
                            /* we called HeapReAlloc, so we can use GetLastError */
                            errno = _get_errno_from_oserr(GetLastError());
                        }
                        else
                        {
                            errno = ENOMEM;
                        }
                    }
                    return pvReturn;
                }

                /*  call installed new handler */
                if (!_callnewh(newsize))
                {
                    if (pHeader == NULL)
                    {
                        /* we called HeapReAlloc, so we can use GetLastError */
                        errno = _get_errno_from_oserr(GetLastError());
                    }
                    else
                    {
                        errno = ENOMEM;
                    }
                    return NULL;
                }

                /*  new handler was successful -- try to allocate again */
            }
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            __old_sbh_region_t *preg;
            __old_sbh_page_t *  ppage;
            __old_page_map_t *  pmap;
            size_t              oldsize;

            //  round up to the nearest paragrap
            if ( newsize <= _HEAP_MAXREQ )
                if ( newsize > 0 )
                    newsize = (newsize + _OLD_PARASIZE - 1) & ~(_OLD_PARASIZE - 1);
                else
                    newsize = _OLD_PARASIZE;

            for (;;)
            {
                pvReturn = NULL;
                if ( newsize <= _HEAP_MAXREQ )
                {
                    _mlock( _HEAP_LOCK );
                    __try
                    {
                    if ( (pmap = __old_sbh_find_block(pBlock, &preg, &ppage)) != NULL )
                    {
                        //  If the new size falls below __sbh_threshold, try to
                        //  carry out the reallocation within the small-block
                        //  heap.
                        if ( newsize < __old_sbh_threshold )
                        {
                            if ( __old_sbh_resize_block(preg, ppage, pmap,
                                 newsize >> _OLD_PARASHIFT) )
                            {
                                pvReturn = pBlock;
                            }
                            else if ( (pvReturn = __old_sbh_alloc_block(newsize >>
                                       _OLD_PARASHIFT)) != NULL )
                            {
                                oldsize = ((size_t)(*pmap)) << _OLD_PARASHIFT ;
                                memcpy(pvReturn, pBlock, __min(oldsize, newsize));
                                __old_sbh_free_block(preg, ppage, pmap);
                            }
                        }

                        //  If the reallocation has not been (successfully)
                        //  performed in the small-block heap, try to allocate a
                        //  new block with HeapAlloc.
                        if ( (pvReturn == NULL) &&
                             ((pvReturn = HeapAlloc(_crtheap, 0, newsize)) != NULL) )
                        {
                            oldsize = ((size_t)(*pmap)) << _OLD_PARASHIFT;
                            memcpy(pvReturn, pBlock, __min(oldsize, newsize));
                            __old_sbh_free_block(preg, ppage, pmap);
                        }
                    }
                    else
                    {
                        pvReturn = HeapReAlloc(_crtheap, 0, pBlock, newsize);
                    }

                    }
                    __finally
                    {
                        _munlock(_HEAP_LOCK);
                    }
                }
                else    /* newsize > _HEAP_MAXREQ */
                {
                    _callnewh(newsize);
                    errno = ENOMEM;
                    return NULL;
                }

                if ( pvReturn || _newmode == 0)
                {
                    if (pvReturn)
                    {
                        RTCCALLBACK(_RTC_Free_hook, (pBlock, 0));
                        RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, newsize, 0));
                    }
                    else
                    {
                        if (pmap == NULL)
                        {
                            /* we called HeapReAlloc, so we can use GetLastError */
                            errno = _get_errno_from_oserr(GetLastError());
                        }
                        else
                        {
                            errno = ENOMEM;
                        }
                    }
                    return pvReturn;
                }

                //  call installed new handler
                if (!_callnewh(newsize))
                {
                    if (pmap == NULL)
                    {
                        /* we called HeapReAlloc, so we can use GetLastError */
                        errno = _get_errno_from_oserr(GetLastError());
                    }
                    else
                    {
                        errno = ENOMEM;
                    }

                    return NULL;
                }

                //  new handler was successful -- try to allocate again
            }
        }
#endif  /* CRTDLL */
        else    //  __active_heap == __SYSTEM_HEAP )
#endif  /* _WIN64 */
        {
            for (;;) {

                pvReturn = NULL;
                if (newsize <= _HEAP_MAXREQ)
                {
                    if (newsize == 0)
                        newsize = 1;
                    pvReturn = HeapReAlloc(_crtheap, 0, pBlock, newsize);
                }
                else
                {
                    _callnewh(newsize);
                    errno = ENOMEM;
                    return NULL;
                }

                if ( pvReturn || _newmode == 0)
                {
                    if (pvReturn)
                    {
                        RTCCALLBACK(_RTC_Free_hook, (pBlock, 0));
                        RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, newsize, 0));
                    }
                    else
                    {
                        errno = _get_errno_from_oserr(GetLastError());
                    }
                    return pvReturn;
                }

                //  call installed new handler
                if (!_callnewh(newsize))
                {
                    errno = _get_errno_from_oserr(GetLastError());
                    return NULL;
                }

                //  new handler was successful -- try to allocate again
            }
        }
}

#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <string.h>
#include <dbgint.h>

/* useful macro to compute the size of an allocation block given both a
 * pointer to the descriptor and a pointer to the user area of the block
 * (more efficient variant of _BLKSIZE macro, given the extra information)
 */
#define BLKSZ(pdesc_m,pblock_m)   ((unsigned)_ADDRESS((pdesc_m)->pnextdesc) - \
                    (unsigned)(pblock_m))

/* expand an allocation block, in place, up to or beyond a specified size
 * by coalescing it with subsequent free blocks (if possible)
 */
static int __cdecl _heap_expand_block(_PBLKDESC, size_t *, size_t);

/***
*void *realloc(void *pblock, size_t newsize) - reallocate a block of memory in
*       the heap
*
*Purpose:
*       Re-allocates a block in the heap to newsize bytes. newsize may be
*       either greater or less than the original size of the block. The
*       re-allocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*       Special ANSI Requirements:
*
*       (1) realloc(NULL, newsize) is equivalent to malloc(newsize)
*
*       (2) realloc(pblock, 0) is equivalent to free(pblock) (except that
*           NULL is returned)
*
*       (3) if the realloc() fails, the object pointed to by pblock is left
*           unchanged
*
*       Special Notes For Multi-thread: The heap is locked immediately prior
*       to assigning pdesc. This is after special cases (1) and (2), listed
*       above, are taken care of. The lock is released immediately prior to
*       the final return statement.
*
*Entry:
*       void *pblock - pointer to block in the heap previously allocated
*                 by a call to malloc(), realloc() or _expand().
*
*       size_t newsize  - requested size for the re-allocated block
*
*Exit:
*       Success:  Pointer to the re-allocated memory block
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*       If pblock does not point to a valid allocation block in the heap,
*       realloc() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _realloc_base (
        REG1 void *pblock,
        size_t newsize
        )
{
        REG2 _PBLKDESC pdesc;
        _PBLKDESC pdesc2;
        void *retp;
        size_t oldsize;
        size_t currsize;

        /* special cases, handling mandated by ANSI
         */
        if ( pblock == NULL )
            /* just do a malloc of newsize bytes and return a pointer to
             * the new block
              */
            return( _malloc_base(newsize) );

        if ( newsize == 0 ) {
            /* free the block and return NULL
             */
            _free_base(pblock);
            return( NULL );
        }

        /* make newsize a valid allocation block size (i.e., round up to the
         * nearest whole number of dwords)
         */
        newsize = _ROUND2(newsize, _GRANULARITY);


        /* if multi-thread support enabled, lock the heap here
         */
        _mlock(_HEAP_LOCK);

        /* set pdesc to point to the descriptor for *pblock
         */
        pdesc = _BACKPTR(pblock);

        if ( _ADDRESS(pdesc) != ((char *)pblock - _HDRSIZE) )
            _heap_abort();

        /* see if pblock is big enough already, or can be expanded (in place)
         * to be big enough.
         */
        if ( ((oldsize = currsize = BLKSZ(pdesc, pblock)) > newsize) ||
             (_heap_expand_block(pdesc, &currsize, newsize) == 0) ) {

            /* if necessary, mark pdesc as inuse
             */
            if ( _IS_FREE(pdesc) ) {
                _SET_INUSE(pdesc);
            }

            /* trim pdesc down to be exactly newsize bytes, if necessary
             */
            if ( (currsize > newsize) &&
                 ((pdesc2 = _heap_split_block(pdesc, newsize)) != NULL) )
            {
                _SET_FREE(pdesc2);
            }

            retp = pblock;
            goto realloc_done;
        }

        /* try malloc-ing a new block of the requested size. if successful,
         * copy over the data from the original block and free it.
         */
        if ( (retp = _malloc_base(newsize)) != NULL ) {
            memcpy(retp, pblock, oldsize);
            _free_base_nolock(pblock);
        }
        /* else if unsuccessful, return retp (== NULL) */

realloc_done:
        /* if multi-thread support is enabled, unlock the heap here
         */
        _munlock(_HEAP_LOCK);

        return(retp);
}


/***
*void *_expand(void *pblock, size_t newsize) - expand/contract a block of memory
*       in the heap
*
*Purpose:
*       Resizes a block in the heap to newsize bytes. newsize may be either
*       greater (expansion) or less (contraction) than the original size of
*       the block. The block is NOT moved. In the case of expansion, if the
*       block cannot be expanded to newsize bytes, it is expanded as much as
*       possible.
*
*       Special Notes For Multi-thread: The heap is locked just before pdesc
*       is assigned and unlocked immediately prior to the return statement.
*
*Entry:
*       void *pblock - pointer to block in the heap previously allocated
*                 by a call to malloc(), realloc() or _expand().
*
*       size_t newsize  - requested size for the resized block
*
*Exit:
*       Success:  Pointer to the resized memory block (i.e., pblock)
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*       If pblock does not point to a valid allocation block in the heap,
*       _expand() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _expand_base (
        REG1 void *pblock,
        size_t newsize
        )
{
        REG2 _PBLKDESC pdesc;
        _PBLKDESC pdesc2;
        void *retp;
        size_t oldsize;
        size_t currsize;
        int index;

        /* make newsize a valid allocation block size (i.e., round up to the
         * nearest whole number of dwords)
         */
        newsize = _ROUND2(newsize, _GRANULARITY);


        retp = pblock;

        /* validate size */
        if ( newsize > _HEAP_MAXREQ )
            newsize = _HEAP_MAXREQ;

        /* if multi-thread support enabled, lock the heap here
         */
        _mlock(_HEAP_LOCK);

        /* set pdesc to point to the descriptor for *pblock
         */
        pdesc = _BACKPTR(pblock);

        /* see if pblock is big enough already, or can be expanded (in place)
         * to be big enough.
         */
        if ( ((oldsize = currsize = BLKSZ(pdesc, pblock)) >= newsize) ||
             (_heap_expand_block(pdesc, &currsize, newsize) == 0) ) {
            /* pblock is (now) big enough. trim it down, if necessary
             */
            if ( (currsize > newsize) &&
                 ((pdesc2 = _heap_split_block(pdesc, newsize)) != NULL) )
            {
                _SET_FREE(pdesc2);
                currsize = newsize;
            }
            goto expand_done;
        }

        /* if the heap block is at the end of a region, attempt to grow the
         * region
         */
        if ( (pdesc->pnextdesc == &_heap_desc.sentinel) ||
             _IS_DUMMY(pdesc->pnextdesc) ) {

            /* look up the region index
             */
            for ( index = 0 ; index < _HEAP_REGIONMAX ; index++ )
                if ( (_heap_regions[index]._regbase < pblock) &&
                     (((char *)(_heap_regions[index]._regbase) +
                       _heap_regions[index]._currsize) >=
                     (char *)pblock) )
                    break;

            /* make sure a valid region index was obtained (pblock could
             * lie in a portion of heap memory donated by a user call to
             * _heapadd(), which therefore would not appear in the region
             * table)
             */
            if ( index == _HEAP_REGIONMAX ) {
                retp = NULL;
                goto expand_done;
            }

            /* try growing the region. the difference between newsize and
             * the current size of the block, rounded up to the nearest
             * whole number of pages, is the amount the region needs to
             * be grown. if successful, try expanding the block again
             */
            if ( (_heap_grow_region(index, _ROUND2(newsize - currsize,
                  _PAGESIZE_)) == 0) &&
                 (_heap_expand_block(pdesc, &currsize, newsize) == 0) )
            {
                /* pblock is (now) big enough. trim it down to be
                 * exactly size bytes, if necessary
                 */
                if ( (currsize > newsize) && ((pdesc2 =
                       _heap_split_block(pdesc, newsize)) != NULL) )
                {
                    _SET_FREE(pdesc2);
                    currsize = newsize;
                }
            }
            else
                retp = NULL;
        }
        else
            retp = NULL;

expand_done:
        /* if multi-thread support is enabled, unlock the heap here
         */
        _munlock(_HEAP_LOCK);

        return(retp);
}


/***
*int _heap_expand_block(pdesc, pcurrsize, newsize) - expand an allocation block
*       in place (without trying to 'grow' the heap)
*
*Purpose:
*
*Entry:
*       _PBLKDESC pdesc   - pointer to the allocation block descriptor
*       size_t *pcurrsize - pointer to size of the allocation block (i.e.,
*                   *pcurrsize == _BLKSIZE(pdesc), on entry)
*       size_t newsize    - requested minimum size for the expanded allocation
*                   block (i.e., newsize >= _BLKSIZE(pdesc), on exit)
*
*Exit:
*       Success:  0
*       Failure: -1
*       In either case, *pcurrsize is updated with the new size of the block
*
*Exceptions:
*       It is assumed that pdesc points to a valid allocation block descriptor.
*       It is also assumed that _BLKSIZE(pdesc) == *pcurrsize on entry. If
*       either of these assumptions is violated, _heap_expand_block will almost
*       certainly trash the heap.
*
*******************************************************************************/

static int __cdecl _heap_expand_block (
        REG1 _PBLKDESC pdesc,
        REG3 size_t *pcurrsize,
        size_t newsize
        )
{
        REG2 _PBLKDESC pdesc2;

        _ASSERTE(("_heap_expand_block: bad pdesc arg", _CHECK_PDESC(pdesc)));
        _ASSERTE(("_heap_expand_block: bad pcurrsize arg", *pcurrsize == _BLKSIZE(pdesc)));

        for ( pdesc2 = pdesc->pnextdesc ; _IS_FREE(pdesc2) ;
              pdesc2 = pdesc->pnextdesc ) {

            /* coalesce with pdesc. check for special case of pdesc2
             * being proverdesc.
             */
            pdesc->pnextdesc = pdesc2->pnextdesc;

            if ( pdesc2 == _heap_desc.proverdesc )
                _heap_desc.proverdesc = pdesc;

            /* update *pcurrsize, place *pdesc2 on the empty descriptor
             * list and see if the coalesced block is now big enough
             */
            *pcurrsize += _MEMSIZE(pdesc2);

            _PUTEMPTY(pdesc2)
        }

        if ( *pcurrsize >= newsize )
            return(0);
        else
            return(-1);
}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\scanf.c ===
/***
*scanf.c - read formatted data from stdin
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines scanf() - reads formatted data from stdin
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vscanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       This is a helper function to be called from fscanf & fscanf_s
*
*Entry:
*       INPUTFN inputfn - scanf & scanf_s pass either _input_l or _input_s_l
*                   which is then used to do the real work.
*       char *format - format string
*       va_list arglist - arglist of output pointers
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vscanf (
        INPUTFN inputfn,
        const char *format,
        _locale_t plocinfo,
        va_list arglist
        )
/*
 * stdin 'SCAN', 'F'ormatted
 */
{
        int retval;

        _VALIDATE_RETURN( (format != NULL), EINVAL, EOF);

        _lock_str2(0, stdin);
        __try {

        retval = (inputfn(stdin, format, plocinfo, arglist));

        }
        __finally {
            _unlock_str2(0, stdin);
        }

        return(retval);
}

/***
*int scanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       Reads formatted data from stdin into arguments.  _input_l does the real
*       work here.
*
*Entry:
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
int __cdecl scanf (
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vscanf(_input_l, format, NULL, arglist);
}

int __cdecl _scanf_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vscanf(_input_l, format, plocinfo, arglist);
}

/***
*int scanf_s(format, ...) - read formatted data from stdin
*
*   Same as scanf above except that it calls _input_s_l to do the real work.
*   _input_s_l has a size check for array parameters.
*
*******************************************************************************/
int __cdecl scanf_s (
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vscanf(_input_s_l, format, NULL, arglist);
}

int __cdecl _scanf_s_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vscanf(_input_s_l, format, plocinfo, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_SEARCH
#define _INC_SEARCH

#include <crtdefs.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Function prototypes */

#ifndef _CRT_ALGO_DEFINED
#define _CRT_ALGO_DEFINED
#if __STDC_WANT_SECURE_LIB__
_Check_return_ _CRTIMP void * __cdecl bsearch_s(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements * _SizeOfElements) const void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ _CRTIMP void * __cdecl bsearch(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements * _SizeOfElements) const void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));

#if __STDC_WANT_SECURE_LIB__
_CRTIMP void __cdecl qsort_s(_Inout_bytecap_x_(_NumOfElements* _SizeOfElements) void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_CRTIMP void __cdecl qsort(_Inout_bytecap_x_(_NumOfElements * _SizeOfElements) void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));
#endif  /* _CRT_ALGO_DEFINED */

_Check_return_ _CRTIMP void * __cdecl _lfind_s(_In_ const void * _Key, _In_bytecount_x_((*_NumOfElements) * _SizeOfElements) const void * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
_Check_return_ _CRTIMP void * __cdecl _lfind(_In_ const void * _Key, _In_bytecount_x_((*_NumOfElements) * _SizeOfElements) const void * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ unsigned int _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));

_Check_return_ _CRTIMP void * __cdecl _lsearch_s(_In_ const void * _Key, _Inout_bytecap_x_((*_NumOfElements ) * _SizeOfElements) void  * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
_Check_return_ _CRTIMP void * __cdecl _lsearch(_In_ const void * _Key, _Inout_bytecap_x_((*_NumOfElements ) * _SizeOfElements) void  * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ unsigned int _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));

#if _MSC_VER >= 1400 && defined(__cplusplus) && defined(_M_CEE)
/*
 * Managed search routines. Note __cplusplus, this is because we only support
 * managed C++.
 */
extern "C++"
{

#if __STDC_WANT_SECURE_LIB__
_Check_return_ void * __clrcall bsearch_s(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements*_SizeOfElements) const void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ void * __clrcall bsearch(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements*_SizeOfElements) const void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(const void *, const void *));

_Check_return_ void * __clrcall _lfind_s(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements*_SizeOfElements) const void * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
_Check_return_ void * __clrcall _lfind(_In_ const void * _Key, _In_bytecount_x_((*_NumOfElements)*_SizeOfElements) const void * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ unsigned int _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(const void *, const void *));

_Check_return_ void * __clrcall _lsearch_s(_In_ const void * _Key, _In_bytecount_x_((*_NumOfElements)*_SizeOfElements) void * _Base,
        _In_ unsigned int * _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
_Check_return_ void * __clrcall _lsearch(_In_ const void * _Key, _Inout_bytecap_x_((*_NumOfElements)*_SizeOfElements) void * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ unsigned int _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(const void *, const void *));

#if __STDC_WANT_SECURE_LIB__
void __clrcall qsort_s(_Inout_bytecap_x_(_NumOfElements*_SizeOfElements) _Post_bytecount_x_(_NumOfElements*_SizeOfElements) void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElment,
        _In_ int (__clrcall * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
void __clrcall qsort(_Inout_bytecap_x_(_NumOfElements*_SizeOfElements) _Post_bytecount_x_(_NumOfElements*_SizeOfElements) void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(const void *, const void *));

}
#endif  /* _MSC_VER >= 1400 && defined(__cplusplus) && defined(_M_CEE) */


#if !__STDC__
/* Non-ANSI names for compatibility */

_Check_return_ _CRTIMP _CRT_NONSTDC_DEPRECATE(_lfind) void * __cdecl lfind(_In_ const void * _Key, _In_bytecount_x_((*_NumOfElements) * _SizeOfElements) const void * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ unsigned int _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));
_Check_return_ _CRTIMP _CRT_NONSTDC_DEPRECATE(_lsearch) void * __cdecl lsearch(_In_ const void * _Key, _Inout_bytecap_x_((*_NumOfElements) * _SizeOfElements) void  * _Base,
        _Inout_ unsigned int * _NumOfElements, _In_ unsigned int _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));

#endif  /* !__STDC__ */


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\searchen.c ===
/***
*searchenv.c - find a file using paths from an environment variable
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       to search a set a directories specified by an environment variable
*       for a specified file name.  If found the full path name is returned.
*
*******************************************************************************/

#include <cruntime.h>
#include <direct.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*_searchenv_s - search for file along paths from environment variable
*
*Purpose:
*       to search for a specified file in the directory(ies) specified by
*       a given environment variable, and, if found, to return the full
*       path name of the file.  The file is first looked for in the current
*       working directory, prior to looking in the paths specified by env_var.
*
*Entry:
*       const _TSCHAR * fname - name of file to search for
*       const _TSCHAR * env_var - name of environment variable to use for paths
*       _TSCHAR * path - pointer to storage for the constructed path name
*       size_t sz - the size of the path buffer
*
*Exit:
*       returns 0 on success & sets pfile
*       returns errno_t on failure.
*       The path parameter is filled with the fullpath of found file on success
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tsearchenv_s (
        const _TSCHAR *fname,
        const _TSCHAR *env_var,
        _TSCHAR *path,
        size_t sz
        )
{
        register _TSCHAR *p;
        register int c;
        _TSCHAR *envbuf = NULL;
        _TSCHAR *env_p, *save_env_p;
        size_t len;
        _TSCHAR pathbuf[_MAX_PATH + 4];
        _TSCHAR * pbuf = NULL;
        size_t fnamelen, buflen;
        errno_t save_errno;
        int ret;
        errno_t retvalue = 0;

        _VALIDATE_RETURN_ERRCODE( (path != NULL), EINVAL);
        _VALIDATE_RETURN_ERRCODE( (sz > 0), EINVAL);
        if (fname == NULL)
        {
            *path = _T('\0');
            _VALIDATE_RETURN_ERRCODE( (fname != NULL), EINVAL);
        }

        /* special case: fname is an empty string: just return an empty path, errno is set to ENOENT */
        if (fname[0] == 0)
        {
            *path = _T('\0');
            errno = ENOENT;
            retvalue = errno;
            goto cleanup;
        }

        save_errno = errno;
        ret = _taccess_s(fname, 0);
        errno = save_errno;

        if (ret == 0 ) {

            /* exists, convert it to a fully qualified pathname and
               return */
            if ( _tfullpath(path, fname, sz) == NULL )
            {
                *path = _T('\0'); /* fullpath will set errno in this case */
                retvalue = errno;
                goto cleanup;
            }

            retvalue = 0;
            goto cleanup;
        }

        if (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envbuf, NULL, env_var)) != 0 || envbuf == NULL) {
            /* no such environment var. and not in cwd, so return empty
               string, set errno to ENOENT */
            *path = _T('\0');
            errno = ENOENT;
            retvalue = errno;
            goto cleanup;
        }

        env_p = envbuf;
        fnamelen = _tcslen(fname);
        pbuf = pathbuf;
        buflen = _countof(pathbuf);

        if(fnamelen >= buflen)
        {
            /* +2 for the trailing '\' we may need to add & the '\0' */
            buflen = _tcslen(env_p) + fnamelen + 2;
            pbuf = (_TSCHAR *)_calloc_crt( buflen, sizeof(_TSCHAR));
            if(!pbuf)
            {
                 *path = _T('\0');
                 errno = ENOMEM;
                 retvalue = errno;
                 goto cleanup;
            }
        }

        save_errno = errno;

        while(env_p)
        {
            save_env_p = env_p;
            env_p = _tgetpath(env_p, pbuf, buflen - fnamelen - 1);

            if( env_p == NULL && pbuf == pathbuf && errno == ERANGE)
            {
                buflen = _tcslen(save_env_p) + fnamelen + 2;
                pbuf = (_TSCHAR *)_calloc_crt( buflen, sizeof(_TSCHAR));
                if(!pbuf)
                {
                     *path = _T('\0');
                     errno = ENOMEM;
                     retvalue = errno;
                     goto cleanup;
                }
                env_p = _tgetpath(save_env_p, pbuf, buflen - fnamelen);
            }

            if(env_p == NULL || *pbuf == _T('\0'))
                break;

            /* path now holds nonempty pathname from env_p, concatenate
               the file name and go */
            /* If we reached here, we know that buflen is enough to hold
            the concatenation. If not, the getpath would have failed */

            len = _tcslen(pbuf);
            p = pbuf + len;
            if ( ((c = *(p - 1)) != _T('/')) && (c != _T('\\')) &&
                 (c != _T(':')) )
            {
                /* add a trailing '\' */
                *p++ = _T('\\');
                len++;
            }
            /* p now points to character following trailing '/', '\'
               or ':' */

            _ERRCHECK(_tcscpy_s(p, buflen - (p - pbuf), fname));

            if ( _taccess_s(pbuf, 0) == 0 ) {
                /* found a match, copy the full pathname into the caller's
                   buffer */
                if(len + fnamelen >= sz) {
                    *path = _T('\0');

                    if(pbuf != pathbuf)
                        _free_crt(pbuf);

                    errno = ERANGE;
                    retvalue = errno;
                    goto cleanup;
                }

                errno = save_errno;

                _ERRCHECK(_tcscpy_s(path, sz, pbuf));

                if(pbuf != pathbuf)
                    _free_crt(pbuf);

                retvalue = 0;
                goto cleanup;
            }

        }
        /* if we get here, we never found it, return empty string */
        *path = _T('\0');
        errno = ENOENT;
        retvalue = errno;

cleanup:
        if(pbuf != pathbuf)
            _free_crt(pbuf);

        _free_crt(envbuf);

        return retvalue;
}

/***
*_searchenv() - search for file along paths from environment variable
*
*Purpose:
*       to search for a specified file in the directory(ies) specified by
*       a given environment variable, and, if found, to return the full
*       path name of the file.  The file is first looked for in the current
*       working directory, prior to looking in the paths specified by env_var.
*
*Entry:
*       fname - name of file to search for
*       env_var - name of environment variable to use for paths
*       path - pointer to storage for the constructed path name
*
*Exit:
*       path - pointer to constructed path name, if the file is found, otherwise
*              it points to the empty string.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _tsearchenv (
        const _TSCHAR *fname,
        const _TSCHAR *env_var,
        _TSCHAR *path
        )
{
    _tsearchenv_s(fname, env_var, path, _MAX_PATH);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\sect_attribs.h ===
/***
*sect_attribs.h - section attributes for IA64 CRTs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
****/

#pragma section(".CRTMP$XCA",long,read)
#pragma section(".CRTMP$XCZ",long,read)
#pragma section(".CRTMP$XIA",long,read)
#pragma section(".CRTMP$XIZ",long,read)

#pragma section(".CRTMA$XCA",long,read)
#pragma section(".CRTMA$XCZ",long,read)
#pragma section(".CRTMA$XIA",long,read)
#pragma section(".CRTMA$XIZ",long,read)

#pragma section(".CRTVT$XCA",long,read)
#pragma section(".CRTVT$XCZ",long,read)

#pragma section(".CRT$XCA",long,read)
#pragma section(".CRT$XCAA",long,read)
#pragma section(".CRT$XCC",long,read)
#pragma section(".CRT$XCZ",long,read)
#pragma section(".CRT$XDA",long,read)
#pragma section(".CRT$XDC",long,read)
#pragma section(".CRT$XDZ",long,read)
#pragma section(".CRT$XIA",long,read)
#pragma section(".CRT$XIAA",long,read)
#pragma section(".CRT$XIC",long,read)
#pragma section(".CRT$XID",long,read)
#pragma section(".CRT$XIY",long,read)
#pragma section(".CRT$XIZ",long,read)
#pragma section(".CRT$XLA",long,read)
#pragma section(".CRT$XLC",long,read)
#pragma section(".CRT$XLD",long,read)
#pragma section(".CRT$XLZ",long,read)
#pragma section(".CRT$XPA",long,read)
#pragma section(".CRT$XPX",long,read)
#pragma section(".CRT$XPXA",long,read)
#pragma section(".CRT$XPZ",long,read)
#pragma section(".CRT$XTA",long,read)
#pragma section(".CRT$XTB",long,read)
#pragma section(".CRT$XTX",long,read)
#pragma section(".CRT$XTZ",long,read)

#pragma section(".rdata$T",long,read)
#pragma section(".rtc$IAA",long,read)
#pragma section(".rtc$IZZ",long,read)
#pragma section(".rtc$TAA",long,read)
#pragma section(".rtc$TZZ",long,read)

#define _CRTALLOC(x) __declspec(allocate(x))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setargv.c ===
/***
*setargv.c - generic _setargv routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Linking in this module replaces the normal setargv with the
*       wildcard setargv.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>

/***
*_setargv - sets argv by calling __setargv
*
*Purpose:
*       Routine directly transfers to __setargv (defined in stdargv.asm).
*
*Entry:
*       See __setargv.
*
*Exit:
*       See __setargv.
*
*Exceptions:
*       See __setargv.
*
*******************************************************************************/

int __CRTDECL _setargv (
        void
        )
{
        return __setargv();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setbuf.c ===
/***
*setbuf.c - give new file buffer
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines setbuf() - given a buffer to a stream or make it unbuffered
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>

/***
*void setbuf(stream, buffer) - give a buffer to a stream
*
*Purpose:
*       Allow user to assign his/her own buffer to a stream.
*               if buffer is not NULL, it must be BUFSIZ in length.
*               if buffer is NULL, stream will be unbuffered.
*
*       Since setbuf()'s functionality is a subset of setvbuf(), simply
*       call the latter routine to do the actual work.
*
*       NOTE: For compatibility reasons, setbuf() uses BUFSIZ as the
*       buffer size rather than _INTERNAL_BUFSIZ. The reason for this,
*       and for the two BUFSIZ constants, is to allow stdio to use larger
*       buffers without breaking (already) compiled code.
*
*Entry:
*       FILE *stream - stream to be buffered or unbuffered
*       char *buffer - buffer of size BUFSIZ or NULL
*
*Exit:
*       None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl setbuf (
        FILE *stream,
        char *buffer
        )
{
        _ASSERTE(stream != NULL);

        if (buffer == NULL)
                setvbuf(stream, NULL, _IONBF, 0);
        else
                setvbuf(stream, buffer, _IOFBF, BUFSIZ);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_SETJMP
#define _INC_SETJMP

#include <crtdefs.h>

#if defined (_M_CEE)
/*
 * The reason why simple setjmp won't work here is that there may
 * be case when CLR stubs are on the stack e.g. function call just
 * after jitting, and not unwinding CLR will result in bad state of
 * CLR which then can AV or do something very bad.
 */
#include <setjmpex.h>
#endif  /* defined (_M_CEE) */

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * Definitions specific to particular setjmp implementations.
 */

#if defined (_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif  /* _INC_SETJMPEX */

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;

#ifndef _INTERNAL_IFSTRIP_
#ifdef __cplusplus
extern "C"
#endif  /* __cplusplus */
void __stdcall _NLG_Notify(unsigned long);

#ifdef __cplusplus
extern "C"
#endif  /* __cplusplus */
void __stdcall _NLG_Return();
#endif  /* _INTERNAL_IFSTRIP_ */

#elif defined (_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

/* Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name. */
typedef _CRT_ALIGN(16) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;

#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif  /* _INC_SETJMPEX */
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    /*
     * x86 reserved.
     */

    unsigned long iAReserved[6];

    /*
     * x86 C9.0 compatibility
     */

    unsigned long Registration;  /* point to the UnwindData field. */
    unsigned long TryLevel;      /* ignored by setjmp */
    unsigned long Cookie;        /* set to "VC20" by setjmp */
    unsigned long UnwindFunc;    /* set to EM longjmp() by setjmp */

    /*
     * First dword is zero to indicate it's an exception registration
     * record prepared by EM setjmp function.
     * Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
     * EM setjmp.
     * Third dword is set to the setjmp site memory stack frame pointer.
     * Fourth dword is set to the setjmp site backing store frame pointer.
     */

    unsigned long UnwindData[6];

    /*
     * floating point status register,
     * and preserved floating point registers fs0 - fs19
     */

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    /*
     * return link and preserved branch registers bs0 - bs4
     */

    __int64 StIIP;     /* continuation address */
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    /*
     * preserved general registers s0 - s3, sp, nats
     */

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    /*
     * bsp, pfs, unat, lc
     */

    __int64 RsBSP;
    __int64 RsPFS;     /* previous frame marker (cfm of setjmp's caller) */
    __int64 ApUNAT;    /* User Nat collection register (preserved) */
    __int64 ApLC;      /* loop counter */

    __int64 IntSp;     /* memory stack pointer */
    __int64 IntNats;   /* Nat bits of preserved integer regs s0 - s3 */
    __int64 Preds;     /* predicates */

} _JUMP_BUFFER;
#elif defined (_M_AMD64)

typedef _CRT_ALIGN(16) struct _SETJMP_FLOAT128 {
    unsigned __int64 Part[2];
} SETJMP_FLOAT128;

#define _JBLEN  16
typedef SETJMP_FLOAT128 _JBTYPE;

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif  /* _INC_SETJMPEX */

typedef struct _JUMP_BUFFER {
    unsigned __int64 Frame;
    unsigned __int64 Rbx;
    unsigned __int64 Rsp;
    unsigned __int64 Rbp;
    unsigned __int64 Rsi;
    unsigned __int64 Rdi;
    unsigned __int64 R12;
    unsigned __int64 R13;
    unsigned __int64 R14;
    unsigned __int64 R15;
    unsigned __int64 Rip;
    unsigned __int64 Spare;

    SETJMP_FLOAT128 Xmm6;
    SETJMP_FLOAT128 Xmm7;
    SETJMP_FLOAT128 Xmm8;
    SETJMP_FLOAT128 Xmm9;
    SETJMP_FLOAT128 Xmm10;
    SETJMP_FLOAT128 Xmm11;
    SETJMP_FLOAT128 Xmm12;
    SETJMP_FLOAT128 Xmm13;
    SETJMP_FLOAT128 Xmm14;
    SETJMP_FLOAT128 Xmm15;
} _JUMP_BUFFER;

#endif  /* defined (_M_AMD64) */


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif  /* _JMP_BUF_DEFINED */


/* Function prototypes */

int __cdecl setjmp(_Out_ jmp_buf _Buf);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef __cplusplus
extern "C"
{
_CRTIMP __declspec(noreturn) void __cdecl longjmp(_In_ jmp_buf _Buf, _In_ int _Value) throw(...);
}
#else  /* __cplusplus */
_CRTIMP __declspec(noreturn) void __cdecl longjmp(_In_ jmp_buf _Buf, _In_ int _Value);
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\seterrm.c ===
/***
*seterrm.c - Set mode for handling critical errors
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines signal() and raise().
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>

/***
*void _seterrormode(mode) - set the critical error mode
*
*Purpose:
*
*Entry:
*   int mode - error mode:
*
*               0 means system displays a prompt asking user how to
*               respond to the error. Choices differ depending on the
*               error but may include Abort, Retry, Ignore, and Fail.
*
*               1 means the call system call causing the error will fail
*               and return an error indicating the cause.
*
*Exit:
*   none
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _seterrormode(int mode)
{
        SetErrorMode(mode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rmdir.c ===
/***
*rmdir.c - remove directory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _rmdir() - remove a directory
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>

/***
*int _rmdir(path) - remove a directory
*
*Purpose:
*       deletes the directory speicifed by path.  The directory must
*       be empty, and it must not be the current working directory or
*       the root directory.
*
*Entry:
*       _TSCHAR *path - directory to remove
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _trmdir (
        const _TSCHAR *path
        )
{
        ULONG dosretval;

        /* ask OS to remove directory */

        if (!RemoveDirectory((LPTSTR)path))
            dosretval = GetLastError();
        else
            dosretval = 0;

        if (dosretval) {
            /* error occured -- map error code and return */
            _dosmaperr(dosretval);
            return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\rewind.c ===
/***
*rewind.c - rewind a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines rewind() - rewinds a stream to the beginning.
*
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <io.h>
#include <mtdll.h>
#include <msdos.h>
#include <internal.h>

/***
*void rewind(stream) - rewind a string
*
*Purpose:
*       Back up a stream to the beginning (if not terminal).  First flush it.
*       If read/write, allow next i/o operation to set mode.
*
*Entry:
*       FILE *stream - file to rewind
*
*Exceptions:
*
*******************************************************************************/

void __cdecl rewind (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int fd;

        _VALIDATE_RETURN_VOID( (str != NULL), EINVAL);

        /* Init stream pointer */
        stream = str;

        fd = _fileno(stream);

        /* Lock the file */
        _lock_str(stream);
        __try {

        /* Flush the stream */
        _flush(stream);

        /* Clear errors */
        stream->_flag &= ~(_IOERR|_IOEOF);
        _osfile_safe(fd) &= ~(FEOFLAG);

        /* Set flags */
        /* [note: _flush set _cnt=0 and _ptr=_base] */
        if (stream->_flag & _IORW)
            stream->_flag &= ~(_IOREAD|_IOWRT);

        /* Position to beginning of file */
        if(_lseek(fd,0L,0)==-1)
                {
                        stream->_flag |= _IOERR;
                }

        }
        __finally {
            /* unlock stream */
            _unlock_str(stream);
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setmode.c ===
/***
*setmode.c - set file translation mode
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defined _setmode() - set file translation mode of a file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <errno.h>
#include <msdos.h>
#include <mtdll.h>
#include <stddef.h>
#include <internal.h>
#include <stdlib.h>

/***
*int _setmode(fh, mode) - set file translation mode
*
*Purpose:
*       changes file mode to text/binary, depending on mode arg. this affects
*       whether read's and write's on the file translate between CRLF and LF
*       or is untranslated
*
*Entry:
*       int fh - file handle to change mode on
*       int mode - file translation mode (one of O_TEXT and O_BINARY)
*
*Exit:
*       returns old file translation mode
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/


int __cdecl _setmode (
        int fh,
        int mode
        )
{
        int retval;

        _VALIDATE_RETURN(((mode == _O_TEXT) ||
                          (mode == _O_BINARY) ||
                          (mode == _O_WTEXT) ||
                          (mode == _O_U8TEXT) ||
                          (mode == _O_U16TEXT)),
                         EINVAL, -1);
        _CHECK_FH_RETURN( fh, EBADF, -1 );
        _VALIDATE_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        /* lock the file */
        _lock_fh(fh);

        __try {
                if ( _osfile(fh) & FOPEN )
                        /* set the text/binary mode */
                        retval = _setmode_nolock(fh, mode);
                else {
                        errno = EBADF;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                        retval = -1;
                }
        }
        __finally {
                /* unlock the file */
                _unlock_fh(fh);
        }

        /* Return to user (_setmode_nolock sets errno, if needed) */
        return(retval);
}

/***
*_setmode_nolock() - Perform core setmode operation
*
*Purpose:
*       Core setmode code.  Assumes:
*       (1) Caller has validated fh to make sure it's in range.
*       (2) Caller has locked the file handle.
*
*       [See _setmode() description above.]
*
*Entry: [Same as _setmode()]
*
*Exit:  [Same as _setmode()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _setmode_nolock (
        REG1 int fh,
        int mode
        )
{
        int oldmode;
        int oldtextmode;


        oldmode = _osfile(fh) & FTEXT;
        oldtextmode = _textmode(fh);

        switch(mode) {
            case _O_BINARY :
                _osfile(fh) &= ~FTEXT;
                break;

            case _O_TEXT :
                _osfile(fh) |= FTEXT;
                _textmode(fh) = __IOINFO_TM_ANSI;
                break;

            case _O_U8TEXT :
                _osfile(fh) |= FTEXT;
                _textmode(fh) = __IOINFO_TM_UTF8;
                break;

            case _O_U16TEXT:
            case _O_WTEXT :
                _osfile(fh) |= FTEXT;
                _textmode(fh) = __IOINFO_TM_UTF16LE;
                break;
        }

        if(oldmode == 0) {
            return _O_BINARY;
        }

        if(oldtextmode == __IOINFO_TM_ANSI) {
            return _O_TEXT;
        }
        else {
            return _O_WTEXT;
        }
}

errno_t __cdecl _set_fmode(int mode)
{
    _VALIDATE_RETURN_ERRCODE(((mode == _O_TEXT) || (mode == _O_BINARY) || (mode == _O_WTEXT)), EINVAL);

    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    InterlockedExchange(&_fmode, mode);
    _END_SECURE_CRT_DEPRECATION_DISABLE

    return 0;

}

errno_t __cdecl _get_fmode(int * pMode)
{
    _VALIDATE_RETURN_ERRCODE((pMode != NULL), EINVAL);

    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    *pMode = _fmode;
    _END_SECURE_CRT_DEPRECATION_DISABLE

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\sal.h ===
/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/

#pragma once
/*==========================================================================

   The macros are defined in 3 layers:

   _In_\_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_\_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_\_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ\Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

#define __ATTR_SAL

// choose attribute or __declspec implementation
#ifndef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL 0
#endif  /* _USE_DECLSPECS_FOR_SAL */

#if _USE_DECLSPECS_FOR_SAL
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#elif !defined (_USE_ATTRIBUTES_FOR_SAL)
#if _MSC_VER >= 1400 
#define _USE_ATTRIBUTES_FOR_SAL 1
#else  /* _MSC_VER >= 1400  */
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif  /* _MSC_VER >= 1400  */
#endif  /* !defined (_USE_ATTRIBUTES_FOR_SAL) */

#ifdef _PREFAST_

#if !_USE_DECLSPECS_FOR_SAL
#if !_USE_ATTRIBUTES_FOR_SAL
#if _MSC_VER >= 1400 
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 1
#else  /* _MSC_VER >= 1400  */
#undef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL  1
#endif  /* _MSC_VER >= 1400  */
#endif  /* !_USE_ATTRIBUTES_FOR_SAL */
#endif  /* !_USE_DECLSPECS_FOR_SAL */

#endif  /* _PREFAST_ */

// safeguard for MIDL and RC builds
#if _USE_DECLSPECS_FOR_SAL && (defined (MIDL_PASS) || defined (__midl) || defined (RC_INVOKED) || !defined (_PREFAST_))
#undef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL 0
#endif  /* _USE_DECLSPECS_FOR_SAL && (defined (MIDL_PASS) || defined (__midl) || defined (RC_INVOKED) || !defined (_PREFAST_)) */
#if _USE_ATTRIBUTES_FOR_SAL && (!defined (_MSC_EXTENSIONS) || defined (MIDL_PASS) || defined (__midl) || defined (RC_INVOKED))
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif  /* _USE_ATTRIBUTES_FOR_SAL && (!defined (_MSC_EXTENSIONS) || defined (MIDL_PASS) || defined (__midl) || defined (RC_INVOKED)) */

//============================================================================
//   _In_\_Out_ Layer:
//============================================================================

// 'in' parameters --------------------------

// input pointer parameter
// e.g. void SetPoint( _In_ const POINT* pPT );
#define _In_                           _Pre1_impl_(_$notnull) _Deref_pre2_impl_(_$valid, _$readaccess)
#define _In_opt_                       _Pre_opt_valid_ _Deref_pre_readonly_

// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _In_z_                         _Pre_z_      _Deref_pre_readonly_
#define _In_opt_z_                     _Pre_opt_z_  _Deref_pre_readonly_

// 'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter
#define _In_count_(size)              _Pre_count_(size)         _Deref_pre_readonly_
#define _In_opt_count_(size)          _Pre_opt_count_(size)     _Deref_pre_readonly_
#define _In_bytecount_(size)          _Pre_bytecount_(size)     _Deref_pre_readonly_
#define _In_opt_bytecount_(size)      _Pre_opt_bytecount_(size) _Deref_pre_readonly_

// valid buffer extent described by a constant extression
#define _In_count_c_(size)            _Pre_count_c_(size)         _Deref_pre_readonly_
#define _In_opt_count_c_(size)        _Pre_opt_count_c_(size)     _Deref_pre_readonly_
#define _In_bytecount_c_(size)        _Pre_bytecount_c_(size)     _Deref_pre_readonly_
#define _In_opt_bytecount_c_(size)    _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_

// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter
#define _In_z_count_(size)              _Pre_z_ _Pre_count_(size)         _Deref_pre_readonly_
#define _In_opt_z_count_(size)          _Pre_opt_z_ _Pre_opt_count_(size)     _Deref_pre_readonly_
#define _In_z_bytecount_(size)          _Pre_z_ _Pre_bytecount_(size)     _Deref_pre_readonly_
#define _In_opt_z_bytecount_(size)      _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_

// nullterminated valid buffer extent described by a constant extression
#define _In_z_count_c_(size)            _Pre_z_ _Pre_count_c_(size)         _Deref_pre_readonly_
#define _In_opt_z_count_c_(size)        _Pre_opt_z_ _Pre_opt_count_c_(size)     _Deref_pre_readonly_
#define _In_z_bytecount_c_(size)        _Pre_z_ _Pre_bytecount_c_(size)     _Deref_pre_readonly_
#define _In_opt_z_bytecount_c_(size)    _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_

// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _In_ptrdiff_count_(size)      _Pre_ptrdiff_count_(size)     _Deref_pre_readonly_
#define _In_opt_ptrdiff_count_(size)  _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_

// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );
#define _In_count_x_(size)            _Pre_count_x_(size)         _Deref_pre_readonly_
#define _In_opt_count_x_(size)        _Pre_opt_count_x_(size)     _Deref_pre_readonly_
#define _In_bytecount_x_(size)        _Pre_bytecount_x_(size)     _Deref_pre_readonly_
#define _In_opt_bytecount_x_(size)    _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_

// 'out' parameters --------------------------

// output pointer parameter
// e.g. void GetPoint( _Out_ POINT* pPT );
#define _Out_                            _Pre_cap_c_(1)            _Pre_invalid_
#define _Out_opt_                        _Pre_opt_cap_c_(1)        _Pre_invalid_

// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter
#define _Out_cap_(size)                  _Pre_cap_(size)           _Pre_invalid_
#define _Out_opt_cap_(size)              _Pre_opt_cap_(size)       _Pre_invalid_
#define _Out_bytecap_(size)              _Pre_bytecap_(size)       _Pre_invalid_
#define _Out_opt_bytecap_(size)          _Pre_opt_bytecap_(size)   _Pre_invalid_

// buffer capacity is described by a constant expression
#define _Out_cap_c_(size)                _Pre_cap_c_(size)         _Pre_invalid_
#define _Out_opt_cap_c_(size)            _Pre_opt_cap_c_(size)     _Pre_invalid_
#define _Out_bytecap_c_(size)            _Pre_bytecap_c_(size)     _Pre_invalid_
#define _Out_opt_bytecap_c_(size)        _Pre_opt_bytecap_c_(size) _Pre_invalid_

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Out_cap_m_(mult,size)           _Pre_cap_m_(mult,size)     _Pre_invalid_
#define _Out_opt_cap_m_(mult,size)       _Pre_opt_cap_m_(mult,size) _Pre_invalid_
#define _Out_z_cap_m_(mult,size)         _Pre_cap_m_(mult,size)     _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_m_(mult,size)     _Pre_opt_cap_m_(mult,size) _Pre_invalid_ _Post_z_

// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _Out_ptrdiff_cap_(size)          _Pre_ptrdiff_cap_(size)     _Pre_invalid_
#define _Out_opt_ptrdiff_cap_(size)      _Pre_opt_ptrdiff_cap_(size) _Pre_invalid_

// buffer capacity is described by a complex expression
#define _Out_cap_x_(size)                _Pre_cap_x_(size)         _Pre_invalid_
#define _Out_opt_cap_x_(size)            _Pre_opt_cap_x_(size)     _Pre_invalid_
#define _Out_bytecap_x_(size)            _Pre_bytecap_x_(size)     _Pre_invalid_
#define _Out_opt_bytecap_x_(size)        _Pre_opt_bytecap_x_(size) _Pre_invalid_

// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter
#define _Out_z_cap_(size)                _Pre_cap_(size)           _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_(size)            _Pre_opt_cap_(size)       _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_(size)            _Pre_bytecap_(size)       _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_(size)        _Pre_opt_bytecap_(size)   _Pre_invalid_ _Post_z_

// buffer capacity is described by a constant expression
#define _Out_z_cap_c_(size)              _Pre_cap_c_(size)         _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_c_(size)          _Pre_opt_cap_c_(size)     _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_c_(size)          _Pre_bytecap_c_(size)     _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_c_(size)      _Pre_opt_bytecap_c_(size) _Pre_invalid_ _Post_z_

// buffer capacity is described by a complex expression
#define _Out_z_cap_x_(size)              _Pre_cap_x_(size)         _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_x_(size)          _Pre_opt_cap_x_(size)     _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_x_(size)          _Pre_bytecap_x_(size)     _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_x_(size)      _Pre_opt_bytecap_x_(size) _Pre_invalid_ _Post_z_

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );
#define _Out_cap_post_count_(cap,count)               _Pre_cap_(cap)         _Pre_invalid_ _Post_count_(count)
#define _Out_opt_cap_post_count_(cap,count)           _Pre_opt_cap_(cap)     _Pre_invalid_ _Post_count_(count)
#define _Out_bytecap_post_bytecount_(cap,count)       _Pre_bytecap_(cap)     _Pre_invalid_ _Post_bytecount_(count)
#define _Out_opt_bytecap_post_bytecount_(cap,count)   _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_bytecount_(count)

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );
#define _Out_z_cap_post_count_(cap,count)              _Pre_cap_(cap)         _Pre_invalid_ _Post_z_count_(count)
#define _Out_opt_z_cap_post_count_(cap,count)          _Pre_opt_cap_(cap)     _Pre_invalid_ _Post_z_count_(count)
#define _Out_z_bytecap_post_bytecount_(cap,count)      _Pre_bytecap_(cap)     _Pre_invalid_ _Post_z_bytecount_(count)
#define _Out_opt_z_bytecap_post_bytecount_(cap,count)  _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_z_bytecount_(count)

// only use with dereferenced arguments e.g. '*pcch'
#define _Out_capcount_(capcount)            _Pre_cap_(capcount)         _Pre_invalid_ _Post_count_(capcount)
#define _Out_opt_capcount_(capcount)        _Pre_opt_cap_(capcount)     _Pre_invalid_ _Post_count_(capcount)
#define _Out_bytecapcount_(capcount)        _Pre_bytecap_(capcount)     _Pre_invalid_ _Post_bytecount_(capcount)
#define _Out_opt_bytecapcount_(capcount)    _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_bytecount_(capcount)

#define _Out_capcount_x_(capcount)          _Pre_cap_x_(capcount)         _Pre_invalid_ _Post_count_x_(capcount)
#define _Out_opt_capcount_x_(capcount)      _Pre_opt_cap_x_(capcount)     _Pre_invalid_ _Post_count_x_(capcount)
#define _Out_bytecapcount_x_(capcount)      _Pre_bytecap_x_(capcount)     _Pre_invalid_ _Post_bytecount_x_(capcount)
#define _Out_opt_bytecapcount_x_(capcount)  _Pre_opt_bytecap_x_(capcount) _Pre_invalid_ _Post_bytecount_x_(capcount)

// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );
#define _Out_z_capcount_(capcount)          _Pre_cap_(capcount)         _Pre_invalid_ _Post_z_count_(capcount)
#define _Out_opt_z_capcount_(capcount)      _Pre_opt_cap_(capcount)     _Pre_invalid_ _Post_z_count_(capcount)
#define _Out_z_bytecapcount_(capcount)      _Pre_bytecap_(capcount)     _Pre_invalid_ _Post_z_bytecount_(capcount)
#define _Out_opt_z_bytecapcount_(capcount)  _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_z_bytecount_(capcount)

// inout parameters ----------------------------

// inout pointer parameter
// e.g. void ModifyPoint( _Inout_ POINT* pPT );
#define _Inout_                          _Prepost_valid_
#define _Inout_opt_                      _Prepost_opt_valid_

// string buffers
// e.g. void toupper( _Inout_z_ char* sz );
#define _Inout_z_                        _Prepost_z_
#define _Inout_opt_z_                    _Prepost_opt_z_

// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_count_(size)              _Prepost_count_(size)
#define _Inout_opt_count_(size)          _Prepost_opt_count_(size)
#define _Inout_bytecount_(size)          _Prepost_bytecount_(size)
#define _Inout_opt_bytecount_(size)      _Prepost_opt_bytecount_(size)

#define _Inout_count_c_(size)            _Prepost_count_c_(size)
#define _Inout_opt_count_c_(size)        _Prepost_opt_count_c_(size)
#define _Inout_bytecount_c_(size)        _Prepost_bytecount_c_(size)
#define _Inout_opt_bytecount_c_(size)    _Prepost_opt_bytecount_c_(size)

// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_z_count_(size)              _Prepost_z_ _Prepost_count_(size)
#define _Inout_opt_z_count_(size)          _Prepost_z_ _Prepost_opt_count_(size)
#define _Inout_z_bytecount_(size)          _Prepost_z_ _Prepost_bytecount_(size)
#define _Inout_opt_z_bytecount_(size)      _Prepost_z_ _Prepost_opt_bytecount_(size)

#define _Inout_z_count_c_(size)            _Prepost_z_ _Prepost_count_c_(size)
#define _Inout_opt_z_count_c_(size)        _Prepost_z_ _Prepost_opt_count_c_(size)
#define _Inout_z_bytecount_c_(size)        _Prepost_z_ _Prepost_bytecount_c_(size)
#define _Inout_opt_z_bytecount_c_(size)    _Prepost_z_ _Prepost_opt_bytecount_c_(size)

#define _Inout_ptrdiff_count_(size)      _Pre_ptrdiff_count_(size)
#define _Inout_opt_ptrdiff_count_(size)  _Pre_opt_ptrdiff_count_(size)

#define _Inout_count_x_(size)            _Prepost_count_x_(size)
#define _Inout_opt_count_x_(size)        _Prepost_opt_count_x_(size)
#define _Inout_bytecount_x_(size)        _Prepost_bytecount_x_(size)
#define _Inout_opt_bytecount_x_(size)    _Prepost_opt_bytecount_x_(size)

// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );
#define _Inout_cap_(size)                _Pre_valid_cap_(size)           _Post_valid_
#define _Inout_opt_cap_(size)            _Pre_opt_valid_cap_(size)       _Post_valid_
#define _Inout_bytecap_(size)            _Pre_valid_bytecap_(size)       _Post_valid_
#define _Inout_opt_bytecap_(size)        _Pre_opt_valid_bytecap_(size)   _Post_valid_

#define _Inout_cap_c_(size)              _Pre_valid_cap_c_(size)         _Post_valid_
#define _Inout_opt_cap_c_(size)          _Pre_opt_valid_cap_c_(size)     _Post_valid_
#define _Inout_bytecap_c_(size)          _Pre_valid_bytecap_c_(size)     _Post_valid_
#define _Inout_opt_bytecap_c_(size)      _Pre_opt_valid_bytecap_c_(size) _Post_valid_

#define _Inout_cap_x_(size)              _Pre_valid_cap_x_(size)         _Post_valid_
#define _Inout_opt_cap_x_(size)          _Pre_opt_valid_cap_x_(size)     _Post_valid_
#define _Inout_bytecap_x_(size)          _Pre_valid_bytecap_x_(size)     _Post_valid_
#define _Inout_opt_bytecap_x_(size)      _Pre_opt_valid_bytecap_x_(size) _Post_valid_

// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _Inout_z_cap_(size)                 _Pre_z_cap_(size)            _Post_z_
#define _Inout_opt_z_cap_(size)             _Pre_opt_z_cap_(size)        _Post_z_
#define _Inout_z_bytecap_(size)             _Pre_z_bytecap_(size)        _Post_z_
#define _Inout_opt_z_bytecap_(size)         _Pre_opt_z_bytecap_(size)    _Post_z_

#define _Inout_z_cap_c_(size)               _Pre_z_cap_c_(size)          _Post_z_
#define _Inout_opt_z_cap_c_(size)           _Pre_opt_z_cap_c_(size)      _Post_z_
#define _Inout_z_bytecap_c_(size)           _Pre_z_bytecap_c_(size)      _Post_z_
#define _Inout_opt_z_bytecap_c_(size)       _Pre_opt_z_bytecap_c_(size)  _Post_z_

#define _Inout_z_cap_x_(size)               _Pre_z_cap_x_(size)          _Post_z_
#define _Inout_opt_z_cap_x_(size)           _Pre_opt_z_cap_x_(size)      _Post_z_
#define _Inout_z_bytecap_x_(size)           _Pre_z_bytecap_x_(size)      _Post_z_
#define _Inout_opt_z_bytecap_x_(size)       _Pre_opt_z_bytecap_x_(size)  _Post_z_

// return values -------------------------------

// returning pointers to valid objects
#define _Ret_                  _Ret_valid_
#define _Ret_opt_              _Ret_opt_valid_

// More _Ret_ annotations are defined below

// Pointer to pointers -------------------------

// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );
#define _Deref_out_            _Out_ _Deref_pre_invalid_ _Deref_post_valid_
#define _Deref_out_opt_        _Out_ _Deref_pre_invalid_ _Deref_post_opt_valid_
#define _Deref_opt_out_        _Out_opt_ _Deref_pre_invalid_ _Deref_post_valid_
#define _Deref_opt_out_opt_    _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_valid_

// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );
#define _Deref_out_z_          _Out_ _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_out_opt_z_      _Out_ _Deref_pre_invalid_ _Deref_post_opt_z_
#define _Deref_opt_out_z_      _Out_opt_ _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_opt_out_opt_z_  _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_z_

// More _Deref_ annotations are defined below

// Other annotations

// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();
#define _Check_return_          _Check_return_impl_

// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );
#define _Printf_format_string_ _Printf_format_string_impl_
#define _Scanf_format_string_  _Scanf_format_string_impl_
#define _Scanf_s_format_string_ _Scanf_s_format_string_impl_

// <expr> indicates whether post conditions apply
#define _Success_(expr)     _Success_impl_(expr)

// annotations to express 'boundedness' of integral value parameter
#define _In_bound_          _In_bound_impl_
#define _Out_bound_         _Out_bound_impl_
#define _Ret_bound_         _Ret_bound_impl_
#define _Deref_in_bound_    _Deref_in_bound_impl_
#define _Deref_out_bound_   _Deref_out_bound_impl_
#define _Deref_inout_bound_ _Deref_in_bound_ _Deref_out_bound_
#define _Deref_ret_bound_   _Deref_ret_bound_impl_

// annotations to express upper and lower bounds of integral value parameter
#define _In_range_(lb,ub)          _In_range_impl_(lb,ub)
#define _Out_range_(lb,ub)         _Out_range_impl_(lb,ub)
#define _Ret_range_(lb,ub)         _Ret_range_impl_(lb,ub)
#define _Deref_in_range_(lb,ub)    _Deref_in_range_impl_(lb,ub)
#define _Deref_out_range_(lb,ub)   _Deref_out_range_impl_(lb,ub)
#define _Deref_ret_range_(lb,ub)   _Deref_ret_range_impl_(lb,ub)

//============================================================================
//   _Pre_\_Post_ Layer:
//============================================================================

//
// _Pre_ annotation ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string
#define _Pre_z_                          _Pre2_impl_(_$notnull,  _$zterm) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_                      _Pre2_impl_(_$maybenull,_$zterm) _Deref_pre1_impl_(_$valid)

// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter
#define _Pre_cap_(size)                  _Pre2_impl_(_$notnull,  _$cap(size))
#define _Pre_opt_cap_(size)              _Pre2_impl_(_$maybenull,_$cap(size))
#define _Pre_bytecap_(size)              _Pre2_impl_(_$notnull,  _$bytecap(size))
#define _Pre_opt_bytecap_(size)          _Pre2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity described by a constant expression
#define _Pre_cap_c_(size)                _Pre2_impl_(_$notnull,  _$cap_c(size))
#define _Pre_opt_cap_c_(size)            _Pre2_impl_(_$maybenull,_$cap_c(size))
#define _Pre_bytecap_c_(size)            _Pre2_impl_(_$notnull,  _$bytecap_c(size))
#define _Pre_opt_bytecap_c_(size)        _Pre2_impl_(_$maybenull,_$bytecap_c(size))

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Pre_cap_m_(mult,size)           _Pre2_impl_(_$notnull,  _$mult(mult,size))
#define _Pre_opt_cap_m_(mult,size)       _Pre2_impl_(_$maybenull,_$mult(mult,size))

// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);
#define _Pre_cap_for_(param)             _Pre2_impl_(_$notnull,  _$cap_for(param))
#define _Pre_opt_cap_for_(param)         _Pre2_impl_(_$maybenull,_$cap_for(param))

// buffer capacity described by a complex condition
#define _Pre_cap_x_(size)                _Pre2_impl_(_$notnull,  _$cap_x(size))
#define _Pre_opt_cap_x_(size)            _Pre2_impl_(_$maybenull,_$cap_x(size))
#define _Pre_bytecap_x_(size)            _Pre2_impl_(_$notnull,  _$bytecap_x(size))
#define _Pre_opt_bytecap_x_(size)        _Pre2_impl_(_$maybenull,_$bytecap_x(size))

// buffer capacity described by the difference to another pointer parameter
#define _Pre_ptrdiff_cap_(ptr)           _Pre2_impl_(_$notnull,  _$cap_x(__ptrdiff(ptr)))
#define _Pre_opt_ptrdiff_cap_(ptr)       _Pre2_impl_(_$maybenull,_$cap_x(__ptrdiff(ptr)))

// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );
#define _Pre_z_cap_(size)                _Pre3_impl_(_$notnull,  _$zterm,_$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_(size)            _Pre3_impl_(_$maybenull,_$zterm,_$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_(size)            _Pre3_impl_(_$notnull,  _$zterm,_$bytecap(size))   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_(size)        _Pre3_impl_(_$maybenull,_$zterm,_$bytecap(size))   _Deref_pre1_impl_(_$valid)

#define _Pre_z_cap_c_(size)              _Pre3_impl_(_$notnull,  _$zterm,_$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_c_(size)          _Pre3_impl_(_$maybenull,_$zterm,_$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_c_(size)          _Pre3_impl_(_$notnull,  _$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_c_(size)      _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_z_cap_x_(size)              _Pre3_impl_(_$notnull,  _$zterm,_$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_x_(size)          _Pre3_impl_(_$maybenull,_$zterm,_$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_x_(size)          _Pre3_impl_(_$notnull,  _$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_x_(size)      _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Pre_valid_cap_(size)            _Pre2_impl_(_$notnull,  _$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_(size)        _Pre2_impl_(_$maybenull,_$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_(size)        _Pre2_impl_(_$notnull,  _$bytecap(size))   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_(size)    _Pre2_impl_(_$maybenull,_$bytecap(size))   _Deref_pre1_impl_(_$valid)

#define _Pre_valid_cap_c_(size)          _Pre2_impl_(_$notnull,  _$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_c_(size)      _Pre2_impl_(_$maybenull,_$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_c_(size)      _Pre2_impl_(_$notnull,  _$bytecap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_c_(size)  _Pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_valid_cap_x_(size)          _Pre2_impl_(_$notnull,  _$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_x_(size)      _Pre2_impl_(_$maybenull,_$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_x_(size)      _Pre2_impl_(_$notnull,  _$bytecap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_x_(size)  _Pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)

// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter
#define _Pre_count_(size)                _Pre2_impl_(_$notnull,  _$count(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_(size)            _Pre2_impl_(_$maybenull,_$count(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_(size)            _Pre2_impl_(_$notnull,  _$bytecount(size))   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_(size)        _Pre2_impl_(_$maybenull,_$bytecount(size))   _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by a constant expression
#define _Pre_count_c_(size)              _Pre2_impl_(_$notnull,  _$count_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_c_(size)          _Pre2_impl_(_$maybenull,_$count_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_c_(size)          _Pre2_impl_(_$notnull,  _$bytecount_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_c_(size)      _Pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by a complex expression
#define _Pre_count_x_(size)              _Pre2_impl_(_$notnull,  _$count_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_x_(size)          _Pre2_impl_(_$maybenull,_$count_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_x_(size)          _Pre2_impl_(_$notnull,  _$bytecount_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_x_(size)      _Pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by the difference to another pointer parameter
#define _Pre_ptrdiff_count_(ptr)         _Pre2_impl_(_$notnull,  _$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_ptrdiff_count_(ptr)     _Pre2_impl_(_$maybenull,_$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid)

// valid size unknown or indicated by type (e.g.:LPSTR)
#define _Pre_valid_                      _Pre1_impl_(_$notnull)   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_                  _Pre1_impl_(_$maybenull) _Deref_pre1_impl_(_$valid)

#define _Pre_invalid_                    _Deref_pre1_impl_(_$notvalid)

// used with allocated but not yet initialized objects
#define _Pre_notnull_                    _Pre1_impl_(_$notnull)
#define _Pre_maybenull_                  _Pre1_impl_(_$maybenull)
#define _Pre_null_                       _Pre1_impl_(_$null)

// restrict access rights
#define _Pre_readonly_                   _Pre1_impl_(_$readaccess)
#define _Pre_writeonly_                  _Pre1_impl_(_$writeaccess)
//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call
#define _Post_z_                        _Post1_impl_(_$zterm) _Deref_post1_impl_(_$valid)

// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call
#define _Post_maybez_                   _Post1_impl_(_$maybezterm)

// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );
#define _Post_cap_(size)                _Post1_impl_(_$cap(size))
#define _Post_bytecap_(size)            _Post1_impl_(_$bytecap(size))

// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );
#define _Post_count_(size)              _Post1_impl_(_$count(size))       _Deref_post1_impl_(_$valid)
#define _Post_bytecount_(size)          _Post1_impl_(_$bytecount(size))   _Deref_post1_impl_(_$valid)
#define _Post_count_c_(size)            _Post1_impl_(_$count_c(size))     _Deref_post1_impl_(_$valid)
#define _Post_bytecount_c_(size)        _Post1_impl_(_$bytecount_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_count_x_(size)            _Post1_impl_(_$count_x(size))     _Deref_post1_impl_(_$valid)
#define _Post_bytecount_x_(size)        _Post1_impl_(_$bytecount_x(size)) _Deref_post1_impl_(_$valid)

// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );
#define _Post_z_count_(size)            _Post2_impl_(_$zterm,_$count(size))       _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_(size)        _Post2_impl_(_$zterm,_$bytecount(size))   _Deref_post1_impl_(_$valid)
#define _Post_z_count_c_(size)          _Post2_impl_(_$zterm,_$count_c(size))     _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_c_(size)      _Post2_impl_(_$zterm,_$bytecount_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_count_x_(size)          _Post2_impl_(_$zterm,_$count_x(size))     _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_x_(size)      _Post2_impl_(_$zterm,_$bytecount_x(size)) _Deref_post1_impl_(_$valid)

// e.g. void free( _Post_invalid_ void* pv );
#define _Post_valid_                    _Deref_post1_impl_(_$valid)
#define _Post_invalid_                  _Deref_post1_impl_(_$notvalid)

// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );
#define _Post_notnull_                  _Post1_impl_(_$notnull)

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const throw();
#define _Ret_z_                          _Ret2_impl_(_$notnull,  _$zterm) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_                      _Ret2_impl_(_$maybenull,_$zterm) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter
#define _Ret_cap_(size)                  _Ret2_impl_(_$notnull,  _$cap(size))
#define _Ret_opt_cap_(size)              _Ret2_impl_(_$maybenull,_$cap(size))
#define _Ret_bytecap_(size)              _Ret2_impl_(_$notnull,  _$bytecap(size))
#define _Ret_opt_bytecap_(size)          _Ret2_impl_(_$maybenull,_$bytecap(size))

// Buffer capacity is described by a constant expression
#define _Ret_cap_c_(size)                _Ret2_impl_(_$notnull,  _$cap_c(size))
#define _Ret_opt_cap_c_(size)            _Ret2_impl_(_$maybenull,_$cap_c(size))
#define _Ret_bytecap_c_(size)            _Ret2_impl_(_$notnull,  _$bytecap_c(size))
#define _Ret_opt_bytecap_c_(size)        _Ret2_impl_(_$maybenull,_$bytecap_c(size))

// Buffer capacity is described by a complex condition
#define _Ret_cap_x_(size)                _Ret2_impl_(_$notnull,  _$cap_x(size))
#define _Ret_opt_cap_x_(size)            _Ret2_impl_(_$maybenull,_$cap_x(size))
#define _Ret_bytecap_x_(size)            _Ret2_impl_(_$notnull,  _$bytecap_x(size))
#define _Ret_opt_bytecap_x_(size)        _Ret2_impl_(_$maybenull,_$bytecap_x(size))

// return value is nullterminated and capacity is given by another parameter
#define _Ret_z_cap_(size)                _Ret3_impl_(_$notnull,  _$zterm,_$cap(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_cap_(size)            _Ret3_impl_(_$maybenull,_$zterm,_$cap(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_z_bytecap_(size)            _Ret3_impl_(_$notnull,  _$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_bytecap_(size)        _Ret3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter
#define _Ret_count_(size)                _Ret2_impl_(_$notnull,  _$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_(size)            _Ret2_impl_(_$maybenull,_$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_(size)            _Ret2_impl_(_$notnull,  _$bytecount(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_(size)        _Ret2_impl_(_$maybenull,_$bytecount(size)) _Deref_ret1_impl_(_$valid)

// Valid Buffer extent is described by a constant expression
#define _Ret_count_c_(size)              _Ret2_impl_(_$notnull,  _$count_c(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_c_(size)          _Ret2_impl_(_$maybenull,_$count_c(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_c_(size)          _Ret2_impl_(_$notnull,  _$bytecount_c(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_c_(size)      _Ret2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_ret1_impl_(_$valid)

// Valid Buffer extent is described by a complex expression
#define _Ret_count_x_(size)              _Ret2_impl_(_$notnull,  _$count_x(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_x_(size)          _Ret2_impl_(_$maybenull,_$count_x(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_x_(size)          _Ret2_impl_(_$notnull,  _$bytecount_x(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_x_(size)      _Ret2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_ret1_impl_(_$valid)

// return value is nullterminated and length is given by another parameter
#define _Ret_z_count_(size)              _Ret3_impl_(_$notnull,  _$zterm,_$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_count_(size)          _Ret3_impl_(_$maybenull,_$zterm,_$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_z_bytecount_(size)          _Ret3_impl_(_$notnull,  _$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_bytecount_(size)      _Ret3_impl_(_$maybenull,_$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );
#define _Ret_valid_                      _Ret1_impl_(_$notnull)   _Deref_ret1_impl_(_$valid)
#define _Ret_opt_valid_                  _Ret1_impl_(_$maybenull) _Deref_ret1_impl_(_$valid)

// used with allocated but not yet initialized objects
#define _Ret_notnull_                    _Ret1_impl_(_$notnull)
#define _Ret_maybenull_                  _Ret1_impl_(_$maybenull)
#define _Ret_null_                       _Ret1_impl_(_$null)

//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );
#define _Deref_pre_z_                          _Deref_pre2_impl_(_$notnull,  _$zterm) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_                      _Deref_pre2_impl_(_$maybenull,_$zterm) _Deref2_pre1_impl_(_$valid)

// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter
#define _Deref_pre_cap_(size)                  _Deref_pre2_impl_(_$notnull,  _$cap(size))
#define _Deref_pre_opt_cap_(size)              _Deref_pre2_impl_(_$maybenull,_$cap(size))
#define _Deref_pre_bytecap_(size)              _Deref_pre2_impl_(_$notnull,  _$bytecap(size))
#define _Deref_pre_opt_bytecap_(size)          _Deref_pre2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity is described by a constant expression
#define _Deref_pre_cap_c_(size)                _Deref_pre2_impl_(_$notnull,  _$cap_c(size))
#define _Deref_pre_opt_cap_c_(size)            _Deref_pre2_impl_(_$maybenull,_$cap_c(size))
#define _Deref_pre_bytecap_c_(size)            _Deref_pre2_impl_(_$notnull,  _$bytecap_c(size))
#define _Deref_pre_opt_bytecap_c_(size)        _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size))

// buffer capacity is described by a complex condition
#define _Deref_pre_cap_x_(size)                _Deref_pre2_impl_(_$notnull,  _$cap_x(size))
#define _Deref_pre_opt_cap_x_(size)            _Deref_pre2_impl_(_$maybenull,_$cap_x(size))
#define _Deref_pre_bytecap_x_(size)            _Deref_pre2_impl_(_$notnull,  _$bytecap_x(size))
#define _Deref_pre_opt_bytecap_x_(size)        _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_pre_z_cap_(size)                _Deref_pre3_impl_(_$notnull,  _$zterm,_$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_(size)            _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_(size)            _Deref_pre3_impl_(_$notnull,  _$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_(size)        _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_z_cap_c_(size)              _Deref_pre3_impl_(_$notnull,  _$zterm,_$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_c_(size)          _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_c_(size)          _Deref_pre3_impl_(_$notnull,  _$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_c_(size)      _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_z_cap_x_(size)              _Deref_pre3_impl_(_$notnull,  _$zterm,_$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_x_(size)          _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_x_(size)          _Deref_pre3_impl_(_$notnull,  _$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_x_(size)      _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Deref_pre_valid_cap_(size)            _Deref_pre2_impl_(_$notnull,  _$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_(size)        _Deref_pre2_impl_(_$maybenull,_$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_(size)        _Deref_pre2_impl_(_$notnull,  _$bytecap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_(size)    _Deref_pre2_impl_(_$maybenull,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_valid_cap_c_(size)          _Deref_pre2_impl_(_$notnull,  _$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_c_(size)      _Deref_pre2_impl_(_$maybenull,_$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_c_(size)      _Deref_pre2_impl_(_$notnull,  _$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_c_(size)  _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_valid_cap_x_(size)          _Deref_pre2_impl_(_$notnull,  _$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_x_(size)      _Deref_pre2_impl_(_$maybenull,_$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_x_(size)      _Deref_pre2_impl_(_$notnull,  _$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_x_(size)  _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)

// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter
#define _Deref_pre_count_(size)                _Deref_pre2_impl_(_$notnull,  _$count(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_(size)            _Deref_pre2_impl_(_$maybenull,_$count(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_(size)            _Deref_pre2_impl_(_$notnull,  _$bytecount(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_(size)        _Deref_pre2_impl_(_$maybenull,_$bytecount(size)) _Deref2_pre1_impl_(_$valid)

// valid buffer extent is described by a constant expression
#define _Deref_pre_count_c_(size)              _Deref_pre2_impl_(_$notnull,  _$count_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_c_(size)          _Deref_pre2_impl_(_$maybenull,_$count_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_c_(size)          _Deref_pre2_impl_(_$notnull,  _$bytecount_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_c_(size)      _Deref_pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_pre1_impl_(_$valid)

// valid buffer extent is described by a complex expression
#define _Deref_pre_count_x_(size)              _Deref_pre2_impl_(_$notnull,  _$count_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_x_(size)          _Deref_pre2_impl_(_$maybenull,_$count_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_x_(size)          _Deref_pre2_impl_(_$notnull,  _$bytecount_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_x_(size)      _Deref_pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_pre1_impl_(_$valid)

// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );
#define _Deref_pre_valid_                      _Deref_pre1_impl_(_$notnull)   _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_                  _Deref_pre1_impl_(_$maybenull) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_invalid_                    _Deref2_pre1_impl_(_$notvalid)

#define _Deref_pre_notnull_                    _Deref_pre1_impl_(_$notnull)
#define _Deref_pre_maybenull_                  _Deref_pre1_impl_(_$maybenull)
#define _Deref_pre_null_                       _Deref_pre1_impl_(_$null)

// restrict access rights
#define _Deref_pre_readonly_                   _Deref_pre1_impl_(_$readaccess)
#define _Deref_pre_writeonly_                  _Deref_pre1_impl_(_$writeaccess)

//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );
#define _Deref_post_z_                          _Deref_post2_impl_(_$notnull,  _$zterm) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_                      _Deref_post2_impl_(_$maybenull,_$zterm) _Deref2_post1_impl_(_$valid)

// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter
#define _Deref_post_cap_(size)                  _Deref_post2_impl_(_$notnull,  _$cap(size))
#define _Deref_post_opt_cap_(size)              _Deref_post2_impl_(_$maybenull,_$cap(size))
#define _Deref_post_bytecap_(size)              _Deref_post2_impl_(_$notnull,  _$bytecap(size))
#define _Deref_post_opt_bytecap_(size)          _Deref_post2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity is described by a constant expression
#define _Deref_post_cap_c_(size)                _Deref_post2_impl_(_$notnull,  _$cap_z(size))
#define _Deref_post_opt_cap_c_(size)            _Deref_post2_impl_(_$maybenull,_$cap_z(size))
#define _Deref_post_bytecap_c_(size)            _Deref_post2_impl_(_$notnull,  _$bytecap_z(size))
#define _Deref_post_opt_bytecap_c_(size)        _Deref_post2_impl_(_$maybenull,_$bytecap_z(size))

// buffer capacity is described by a complex expression
#define _Deref_post_cap_x_(size)                _Deref_post2_impl_(_$notnull,  _$cap_x(size))
#define _Deref_post_opt_cap_x_(size)            _Deref_post2_impl_(_$maybenull,_$cap_x(size))
#define _Deref_post_bytecap_x_(size)            _Deref_post2_impl_(_$notnull,  _$bytecap_x(size))
#define _Deref_post_opt_bytecap_x_(size)        _Deref_post2_impl_(_$maybenull,_$bytecap_x(size))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_post_z_cap_(size)                _Deref_post3_impl_(_$notnull,  _$zterm,_$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_(size)            _Deref_post3_impl_(_$maybenull,_$zterm,_$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_(size)            _Deref_post3_impl_(_$notnull,  _$zterm,_$bytecap(size))   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_(size)        _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap(size))   _Deref2_post1_impl_(_$valid)

#define _Deref_post_z_cap_c_(size)              _Deref_post3_impl_(_$notnull,  _$zterm,_$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_c_(size)          _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_c_(size)          _Deref_post3_impl_(_$notnull,  _$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_c_(size)      _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_z_cap_x_(size)              _Deref_post3_impl_(_$notnull,  _$zterm,_$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_x_(size)          _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_x_(size)          _Deref_post3_impl_(_$notnull,  _$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_x_(size)      _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Deref_post_valid_cap_(size)            _Deref_post2_impl_(_$notnull,  _$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_(size)        _Deref_post2_impl_(_$maybenull,_$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_(size)        _Deref_post2_impl_(_$notnull,  _$bytecap(size))   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_(size)    _Deref_post2_impl_(_$maybenull,_$bytecap(size))   _Deref2_post1_impl_(_$valid)

#define _Deref_post_valid_cap_c_(size)          _Deref_post2_impl_(_$notnull,  _$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_c_(size)      _Deref_post2_impl_(_$maybenull,_$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_c_(size)      _Deref_post2_impl_(_$notnull,  _$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_c_(size)  _Deref_post2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_valid_cap_x_(size)          _Deref_post2_impl_(_$notnull,  _$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_x_(size)      _Deref_post2_impl_(_$maybenull,_$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_x_(size)      _Deref_post2_impl_(_$notnull,  _$bytecap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_x_(size)  _Deref_post2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)

// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter
#define _Deref_post_count_(size)                _Deref_post2_impl_(_$notnull,  _$count(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_(size)            _Deref_post2_impl_(_$maybenull,_$count(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_(size)            _Deref_post2_impl_(_$notnull,  _$bytecount(size))   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_(size)        _Deref_post2_impl_(_$maybenull,_$bytecount(size))   _Deref2_post1_impl_(_$valid)

// buffer capacity is described by a constant expression
#define _Deref_post_count_c_(size)              _Deref_post2_impl_(_$notnull,  _$count_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_c_(size)          _Deref_post2_impl_(_$maybenull,_$count_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_c_(size)          _Deref_post2_impl_(_$notnull,  _$bytecount_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_c_(size)      _Deref_post2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_post1_impl_(_$valid)

// buffer capacity is described by a complex expression
#define _Deref_post_count_x_(size)              _Deref_post2_impl_(_$notnull,  _$count_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_x_(size)          _Deref_post2_impl_(_$maybenull,_$count_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_x_(size)          _Deref_post2_impl_(_$notnull,  _$bytecount_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_x_(size)      _Deref_post2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_post1_impl_(_$valid)

// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );
#define _Deref_post_valid_                      _Deref_post1_impl_(_$notnull)   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_                  _Deref_post1_impl_(_$maybenull) _Deref2_post1_impl_(_$valid)

#define _Deref_post_notnull_                    _Deref_post1_impl_(_$notnull)
#define _Deref_post_maybenull_                  _Deref_post1_impl_(_$maybenull)
#define _Deref_post_null_                       _Deref_post1_impl_(_$null)

//
// _Deref_ret_ ---
//

#define _Deref_ret_z_                           _Deref_ret2_impl_(_$notnull,  _$zterm)
#define _Deref_ret_opt_z_                       _Deref_ret2_impl_(_$maybenull,_$zterm)

//
// special _Deref_ ---
//
#define _Deref2_pre_readonly_                   _Deref2_pre1_impl_(_$readaccess)

// Convenience macros for more concise annotations

//
// _Pre_post ---
//
// describing conditions that hold before and after the function call

#define _Prepost_z_                      _Pre_z_      _Post_z_
#define _Prepost_opt_z_                  _Pre_opt_z_  _Post_z_

#define _Prepost_count_(size)           _Pre_count_(size)           _Post_count_(size)
#define _Prepost_opt_count_(size)       _Pre_opt_count_(size)       _Post_count_(size)
#define _Prepost_bytecount_(size)       _Pre_bytecount_(size)       _Post_bytecount_(size)
#define _Prepost_opt_bytecount_(size)   _Pre_opt_bytecount_(size)   _Post_bytecount_(size)
#define _Prepost_count_c_(size)         _Pre_count_c_(size)         _Post_count_c_(size)
#define _Prepost_opt_count_c_(size)     _Pre_opt_count_c_(size)     _Post_count_c_(size)
#define _Prepost_bytecount_c_(size)     _Pre_bytecount_c_(size)     _Post_bytecount_c_(size)
#define _Prepost_opt_bytecount_c_(size) _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size)
#define _Prepost_count_x_(size)         _Pre_count_x_(size)         _Post_count_x_(size)
#define _Prepost_opt_count_x_(size)     _Pre_opt_count_x_(size)     _Post_count_x_(size)
#define _Prepost_bytecount_x_(size)     _Pre_bytecount_x_(size)     _Post_bytecount_x_(size)
#define _Prepost_opt_bytecount_x_(size) _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size)

#define _Prepost_valid_                  _Pre_valid_     _Post_valid_
#define _Prepost_opt_valid_              _Pre_opt_valid_ _Post_valid_

//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call

#define _Deref_prepost_z_                        _Deref_pre_z_      _Deref_post_z_
#define _Deref_prepost_opt_z_                    _Deref_pre_opt_z_  _Deref_post_opt_z_

#define _Deref_prepost_cap_(size)                _Deref_pre_cap_(size)                _Deref_post_cap_(size)
#define _Deref_prepost_opt_cap_(size)            _Deref_pre_opt_cap_(size)            _Deref_post_opt_cap_(size)
#define _Deref_prepost_bytecap_(size)            _Deref_pre_bytecap_(size)            _Deref_post_bytecap_(size)
#define _Deref_prepost_opt_bytecap_(size)        _Deref_pre_opt_bytecap_(size)        _Deref_post_opt_bytecap_(size)

#define _Deref_prepost_cap_x_(size)              _Deref_pre_cap_x_(size)              _Deref_post_cap_x_(size)
#define _Deref_prepost_opt_cap_x_(size)          _Deref_pre_opt_cap_x_(size)          _Deref_post_opt_cap_x_(size)
#define _Deref_prepost_bytecap_x_(size)          _Deref_pre_bytecap_x_(size)          _Deref_post_bytecap_x_(size)
#define _Deref_prepost_opt_bytecap_x_(size)      _Deref_pre_opt_bytecap_x_(size)      _Deref_post_opt_bytecap_x_(size)

#define _Deref_prepost_z_cap_(size)              _Deref_pre_z_cap_(size)              _Deref_post_z_cap_(size)
#define _Deref_prepost_opt_z_cap_(size)          _Deref_pre_opt_z_cap_(size)          _Deref_post_opt_z_cap_(size)
#define _Deref_prepost_z_bytecap_(size)          _Deref_pre_z_bytecap_(size)          _Deref_post_z_bytecap_(size)
#define _Deref_prepost_opt_z_bytecap_(size)      _Deref_pre_opt_z_bytecap_(size)      _Deref_post_opt_z_bytecap_(size)

#define _Deref_prepost_valid_cap_(size)          _Deref_pre_valid_cap_(size)          _Deref_post_valid_cap_(size)
#define _Deref_prepost_opt_valid_cap_(size)      _Deref_pre_opt_valid_cap_(size)      _Deref_post_opt_valid_cap_(size)
#define _Deref_prepost_valid_bytecap_(size)      _Deref_pre_valid_bytecap_(size)      _Deref_post_valid_bytecap_(size)
#define _Deref_prepost_opt_valid_bytecap_(size)  _Deref_pre_opt_valid_bytecap_(size)  _Deref_post_opt_valid_bytecap_(size)

#define _Deref_prepost_valid_cap_x_(size)          _Deref_pre_valid_cap_x_(size)          _Deref_post_valid_cap_x_(size)
#define _Deref_prepost_opt_valid_cap_x_(size)      _Deref_pre_opt_valid_cap_x_(size)      _Deref_post_opt_valid_cap_x_(size)
#define _Deref_prepost_valid_bytecap_x_(size)      _Deref_pre_valid_bytecap_x_(size)      _Deref_post_valid_bytecap_x_(size)
#define _Deref_prepost_opt_valid_bytecap_x_(size)  _Deref_pre_opt_valid_bytecap_x_(size)  _Deref_post_opt_valid_bytecap_x_(size)

#define _Deref_prepost_count_(size)            _Deref_pre_count_(size)            _Deref_post_count_(size)
#define _Deref_prepost_opt_count_(size)        _Deref_pre_opt_count_(size)        _Deref_post_opt_count_(size)
#define _Deref_prepost_bytecount_(size)        _Deref_pre_bytecount_(size)        _Deref_post_bytecount_(size)
#define _Deref_prepost_opt_bytecount_(size)    _Deref_pre_opt_bytecount_(size)    _Deref_post_opt_bytecount_(size)

#define _Deref_prepost_count_x_(size)          _Deref_pre_count_x_(size)          _Deref_post_count_x_(size)
#define _Deref_prepost_opt_count_x_(size)      _Deref_pre_opt_count_x_(size)      _Deref_post_opt_count_x_(size)
#define _Deref_prepost_bytecount_x_(size)      _Deref_pre_bytecount_x_(size)      _Deref_post_bytecount_x_(size)
#define _Deref_prepost_opt_bytecount_x_(size)  _Deref_pre_opt_bytecount_x_(size)  _Deref_post_opt_bytecount_x_(size)

#define _Deref_prepost_valid_                   _Deref_pre_valid_     _Deref_post_valid_
#define _Deref_prepost_opt_valid_               _Deref_pre_opt_valid_ _Deref_post_opt_valid_

//
// _Deref_<miscellaneous>
//
// used with references to arrays

#define _Deref_out_z_cap_c_(size) _Deref_pre_cap_c_(size) _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_inout_z_cap_c_(size) _Deref_pre_z_cap_c_(size) _Deref_post_z_
#define _Deref_out_z_bytecap_c_(size) _Deref_pre_bytecap_c_(size) _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_inout_z_bytecap_c_(size) _Deref_pre_z_bytecap_c_(size) _Deref_post_z_
#define _Deref_inout_z_ _Deref_prepost_z_

//============================================================================
//   Implementation Layer:
//============================================================================

#if _USE_ATTRIBUTES_FOR_SAL

#include "codeanalysis\sourceannotations.h"

#define _Check_return_impl_ [returnvalue:SA_Post(MustCheck=SA_Yes)]

#define _Success_impl_(expr) [SA_Success(Condition=#expr)]

#define _Printf_format_string_impl_   [SA_FormatString(Style="printf")]
#define _Scanf_format_string_impl_    [SA_FormatString(Style="scanf")]
#define _Scanf_s_format_string_impl_  [SA_FormatString(Style="scanf_s")]

#define _In_bound_impl_           [SA_PreBound(Deref=0)]
#define _Out_bound_impl_          [SA_PostBound(Deref=0)]
#define _Ret_bound_impl_          [returnvalue:SA_PostBound(Deref=0)]
#define _Deref_in_bound_impl_     [SA_PreBound(Deref=1)]
#define _Deref_out_bound_impl_    [SA_PostBound(Deref=1)]
#define _Deref_ret_bound_impl_    [returnvalue:SA_PostBound(Deref=1)]

#define _In_range_impl_(min,max)        [SA_PreRange(MinVal=#min,MaxVal=#max)]
#define _Out_range_impl_(min,max)       [SA_PostRange(MinVal=#min,MaxVal=#max)]
#define _Ret_range_impl_(min,max)       [returnvalue:SA_PostRange(MinVal=#min,MaxVal=#max)]
#define _Deref_in_range_impl_(min,max)  [SA_PreRange(Deref=1,MinVal=#min,MaxVal=#max)]
#define _Deref_out_range_impl_(min,max) [SA_PostRange(Deref=1,MinVal=#min,MaxVal=#max)]
#define _Deref_ret_range_impl_(min,max) [returnvalue:SA_PostRange(Deref=1,MinVal=#min,MaxVal=#max)]

#define _$valid       Valid=SA_Yes
#define _$maybevalid  Valid=SA_Maybe
#define _$notvalid    Valid=SA_No

#define _$null        Null=SA_Yes
#define _$maybenull   Null=SA_Maybe
#define _$notnull     Null=SA_No

#define _$zterm       NullTerminated=SA_Yes
#define _$maybezterm  NullTerminated=SA_Maybe
#define _$notzterm    NullTerminated=SA_No

#define _$readaccess  Access=SA_Read
#define _$writeaccess Access=SA_Write

#define _$cap(size)      WritableElements=#size
#define _$cap_c(size)    WritableElementsConst=size
#define _$cap_for(param) WritableElementsLength=#param
#define _$cap_x(size)    WritableElements="\n@"#size

#define _$bytecap(size)   WritableBytes=#size
#define _$bytecap_c(size) WritableBytesConst=size
#define _$bytecap_x(size) WritableBytes="\n@"#size

#define _$mult(mult,size) ElementSizeConst=mult,_$cap(size)

#define _$count(size)   ValidElements=#size
#define _$count_c(size) ValidElementsConst=size
#define _$count_x(size) ValidElements="\n@"#size

#define _$bytecount(size)   ValidBytes=#size
#define _$bytecount_c(size) ValidBytesConst=size
#define _$bytecount_x(size) ValidBytes="\n@"#size

#define _Pre1_impl_(p1)                    [SA_Pre(p1)]
#define _Pre2_impl_(p1,p2)                 [SA_Pre(p1,p2)]
#define _Pre3_impl_(p1,p2,p3)              [SA_Pre(p1,p2,p3)]

#define _Post1_impl_(p1)                   [SA_Post(p1)]
#define _Post2_impl_(p1,p2)                [SA_Post(p1,p2)]
#define _Post3_impl_(p1,p2,p3)             [SA_Post(p1,p2,p3)]

#define _Ret1_impl_(p1)                    [returnvalue:SA_Post(p1)]
#define _Ret2_impl_(p1,p2)                 [returnvalue:SA_Post(p1,p2)]
#define _Ret3_impl_(p1,p2,p3)              [returnvalue:SA_Post(p1,p2,p3)]

#define _Deref_pre1_impl_(p1)              [SA_Pre(Deref=1,p1)]
#define _Deref_pre2_impl_(p1,p2)           [SA_Pre(Deref=1,p1,p2)]
#define _Deref_pre3_impl_(p1,p2,p3)        [SA_Pre(Deref=1,p1,p2,p3)]

#define _Deref_post1_impl_(p1)             [SA_Post(Deref=1,p1)]
#define _Deref_post2_impl_(p1,p2)          [SA_Post(Deref=1,p1,p2)]
#define _Deref_post3_impl_(p1,p2,p3)       [SA_Post(Deref=1,p1,p2,p3)]

#define _Deref_ret1_impl_(p1)              [returnvalue:SA_Post(Deref=1,p1)]
#define _Deref_ret2_impl_(p1,p2)           [returnvalue:SA_Post(Deref=1,p1,p2)]
#define _Deref_ret3_impl_(p1,p2,p3)        [returnvalue:SA_Post(Deref=1,p1,p2,p3)]

#define _Deref2_pre1_impl_(p1)             [SA_Pre(Deref=2,p1)]
#define _Deref2_post1_impl_(p1)            [SA_Post(Deref=2,p1)]
#define _Deref2_ret1_impl_(p1)             [returnvalue:SA_Post(Deref=2,p1)]

#elif _USE_DECLSPECS_FOR_SAL

#define _$SPECSTRIZE( x ) #x

#define _Check_return_impl_ __declspec("SAL_checkReturn")

#define _Success_impl_(expr) __declspec("SAL_success("_$SPECSTRIZE(expr)")")

#define _Printf_format_string_impl_
#define _Scanf_format_string_impl_
#define _Scanf_s_format_string_impl_

#define _In_bound_impl_           _$pre _$bound
#define _Out_bound_impl_          _$post _$bound
#define _Ret_bound_impl_          _$post _$bound
#define _Deref_in_bound_impl_     _$derefpre _$bound
#define _Deref_out_bound_impl_    _$derefpost _$bound
#define _Deref_ret_bound_impl_    _$derefpost bound

#define _In_range_impl_(min,max)        _$pre _$range(min,max)
#define _Out_range_impl_(min,max)       _$post _$range(min,max)
#define _Ret_range_impl_(min,max)       _$post _$range(min,max)
#define _Deref_in_range_impl_(min,max)  _$derefpre _$range(min,max)
#define _Deref_out_range_impl_(min,max) _$derefpost _$range(min,max)
#define _Deref_ret_range_impl_(min,max) _$derefpost _$range(min,max)

#define _$valid             __declspec("SAL_valid")
#define _$maybevalid        __declspec("SAL_maybevalid")
#define _$notvalid          __declspec("SAL_notvalid")

#define _$null              __declspec("SAL_null")
#define _$maybenull         __declspec("SAL_maybenull")
#define _$notnull           __declspec("SAL_notnull")

#define _$zterm             __declspec("SAL_readableTo(sentinel(0))")
#define _$maybezterm
#define _$notzterm

#define _$readaccess        __declspec("SAL_readonly")
#define _$writeaccess       __declspec("SAL_notreadonly")

#define _$cap(size)         __declspec("SAL_writableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$cap_c(size)       __declspec("SAL_writableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$cap_for(param)    __declspec("SAL_writableTo(needsCountFor("_$SPECSTRIZE(param)"))")
#define _$cap_x(size)       __declspec("SAL_writableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$bytecap(size)     __declspec("SAL_writableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecap_c(size)   __declspec("SAL_writableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecap_x(size)   __declspec("SAL_writableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$mult(mult,size)   __declspec("SAL_writableTo(inexpressibleCount("_$SPECSTRIZE(mult)"*"_$SPECSTRIZE(size)"))")

#define _$count(size)       __declspec("SAL_readableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$count_c(size)     __declspec("SAL_readableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$count_x(size)     __declspec("SAL_readableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$bytecount(size)   __declspec("SAL_readableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecount_c(size) __declspec("SAL_readableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecount_x(size) __declspec("SAL_readableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$pre        __declspec("SAL_pre")
#define _$post       __declspec("SAL_post")
#define _$deref_pre  __declspec("SAL_pre")  __declspec("SAL_deref")
#define _$deref_post __declspec("SAL_post") __declspec("SAL_deref")

#define _$bound          __declspec("SAL_bound")
#define _$range(min,max) __declspec("SAL_range("_$SPECSTRIZE(min)","_$SPECSTRIZE(max)")")

#define _Pre1_impl_(p1)                    _$pre p1
#define _Pre2_impl_(p1,p2)                 _$pre p1 _$pre p2
#define _Pre3_impl_(p1,p2,p3)              _$pre p1 _$pre p2 _$pre p3

#define _Post1_impl_(p1)                   _$post p1
#define _Post2_impl_(p1,p2)                _$post p1 _$post p2
#define _Post3_impl_(p1,p2,p3)             _$post p1 _$post p2 _$post p3

#define _Ret1_impl_(p1)                    _$post p1
#define _Ret2_impl_(p1,p2)                 _$post p1 _$post p2
#define _Ret3_impl_(p1,p2,p3)              _$post p1 _$post p2 _$post p3

#define _Deref_pre1_impl_(p1)              _$deref_pre p1
#define _Deref_pre2_impl_(p1,p2)           _$deref_pre p1 _$deref_pre p2
#define _Deref_pre3_impl_(p1,p2,p3)        _$deref_pre p1 _$deref_pre p2 _$deref_pre p3

#define _Deref_post1_impl_(p1)             _$deref_post p1
#define _Deref_post2_impl_(p1,p2)          _$deref_post p1 _$deref_post p2
#define _Deref_post3_impl_(p1,p2,p3)       _$deref_post p1 _$deref_post p2 _$deref_post p3

#define _Deref_ret1_impl_(p1)              _$deref_post p1
#define _Deref_ret2_impl_(p1,p2)           _$deref_post p1 _$deref_post p2
#define _Deref_ret3_impl_(p1,p2,p3)        _$deref_post p1 _$deref_post p2 _$deref_post p3

#define _Deref2_pre1_impl_(p1)             _$deref_pre __declspec("SAL_deref") p1
#define _Deref2_post1_impl_(p1)            _$deref_post __declspec("SAL_deref") p1
#define _Deref2_ret1_impl_(p1)             _$deref_post __declspec("SAL_deref") p1

#elif defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) && _MSC_VER >= 1400 

// minimum attribute expansion for foreground build

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  /* __cplusplus */
#define SA( id ) SA_##id
#define REPEATABLE
#endif  /* __cplusplus */

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct _$P
{
#ifdef __cplusplus
        _$P();
#endif  /* __cplusplus */
   int _$d;
};
typedef struct _$P _$P;

REPEATABLE
[source_annotation_attribute( SA( ReturnValue ) )]
struct _$R
{
#ifdef __cplusplus
        _$R();
#endif  /* __cplusplus */
   int _$d;
};
typedef struct _$R _$R;

[source_annotation_attribute( SA( Method ) )]
struct _$M
{
#ifdef __cplusplus
        _$M();
#endif  /* __cplusplus */
   int _$d;
};
typedef struct _$M _$M;

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

#define _Check_return_impl_ [returnvalue:_$R(_$d=0)]

#define _Success_impl_(expr) [_$M(_$d=0)]

#define _Printf_format_string_impl_   [_$P(_$d=0)]
#define _Scanf_format_string_impl_    [_$P(_$d=0)]
#define _Scanf_s_format_string_impl_  [_$P(_$d=0)]

#define _In_bound_impl_           [_$P(_$d=0)]
#define _Out_bound_impl_          [_$P(_$d=0)]
#define _Ret_bound_impl_          [returnvalue:_$R(_$d=0)]
#define _Deref_in_bound_impl_     [_$P(_$d=0)]
#define _Deref_out_bound_impl_    [_$P(_$d=0)]
#define _Deref_ret_bound_impl_    [returnvalue:_$R(_$d=0)]

#define _In_range_impl_(min,max)        [_$P(_$d=0)]
#define _Out_range_impl_(min,max)       [_$P(_$d=0)]
#define _Ret_range_impl_(min,max)       [returnvalue:_$R(_$d=0)]
#define _Deref_in_range_impl_(min,max)  [_$P(_$d=0)]
#define _Deref_out_range_impl_(min,max) [_$P(_$d=0)]
#define _Deref_ret_range_impl_(min,max) [returnvalue:_$R(_$d=0)]

#define _Pre1_impl_(p1)          [_$P(_$d=0)]
#define _Pre2_impl_(p1,p2)       [_$P(_$d=0)]
#define _Pre3_impl_(p1,p2,p3)    [_$P(_$d=0)]

#define _Post1_impl_(p1)         [_$P(_$d=0)]
#define _Post2_impl_(p1,p2)      [_$P(_$d=0)]
#define _Post3_impl_(p1,p2,p3)   [_$P(_$d=0)]

#define _Ret1_impl_(p1)          [returnvalue:_$R(_$d=0)]
#define _Ret2_impl_(p1,p2)       [returnvalue:_$R(_$d=0)]
#define _Ret3_impl_(p1,p2,p3)    [returnvalue:_$R(_$d=0)]

#define _Deref_pre1_impl_(p1)        [_$P(_$d=0)]
#define _Deref_pre2_impl_(p1,p2)     [_$P(_$d=0)]
#define _Deref_pre3_impl_(p1,p2,p3)  [_$P(_$d=0)]

#define _Deref_post1_impl_(p1)       [_$P(_$d=0)]
#define _Deref_post2_impl_(p1,p2)    [_$P(_$d=0)]
#define _Deref_post3_impl_(p1,p2,p3) [_$P(_$d=0)]

#define _Deref_ret1_impl_(p1)        [returnvalue:_$R(_$d=0)]
#define _Deref_ret2_impl_(p1,p2)     [returnvalue:_$R(_$d=0)]
#define _Deref_ret3_impl_(p1,p2,p3)  [returnvalue:_$R(_$d=0)]

#define _Deref2_pre1_impl_(p1)       //[_$P(_$d=0)]
#define _Deref2_post1_impl_(p1)      //[_$P(_$d=0)]
#define _Deref2_ret1_impl_(p1)       //[_$P(_$d=0)]

#else  /* defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) && _MSC_VER >= 1400  */

#define _Check_return_impl_

#define _Success_impl_(expr)

#define _Printf_format_string_impl_
#define _Scanf_format_string_impl_
#define _Scanf_s_format_string_impl_

#define _In_bound_impl_
#define _Out_bound_impl_
#define _Ret_bound_impl_
#define _Deref_in_bound_impl_
#define _Deref_out_bound_impl_
#define _Deref_ret_bound_impl_

#define _In_range_impl_(min,max)
#define _Out_range_impl_(min,max)
#define _Ret_range_impl_(min,max)
#define _Deref_in_range_impl_(min,max)
#define _Deref_out_range_impl_(min,max)
#define _Deref_ret_range_impl_(min,max)

#define _Pre1_impl_(p1)
#define _Pre2_impl_(p1,p2)
#define _Pre3_impl_(p1,p2,p3)

#define _Post1_impl_(p1)
#define _Post2_impl_(p1,p2)
#define _Post3_impl_(p1,p2,p3)

#define _Ret1_impl_(p1)
#define _Ret2_impl_(p1,p2)
#define _Ret3_impl_(p1,p2,p3)

#define _Deref_pre1_impl_(p1)
#define _Deref_pre2_impl_(p1,p2)
#define _Deref_pre3_impl_(p1,p2,p3)

#define _Deref_post1_impl_(p1)
#define _Deref_post2_impl_(p1,p2)
#define _Deref_post3_impl_(p1,p2,p3)

#define _Deref_ret1_impl_(p1)
#define _Deref_ret2_impl_(p1,p2)
#define _Deref_ret3_impl_(p1,p2,p3)

#define _Deref2_pre1_impl_(p1)
#define _Deref2_post1_impl_(p1)
#define _Deref2_ret1_impl_(p1)

#endif  /* defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) && _MSC_VER >= 1400  */

// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     LPCSTR pszString,                    -- No annotation required, const implies __in.
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     LPCSTR pszSrc,                       -- No annotation required, const implies __in.
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return == TRUE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/

#define __specstrings

#ifdef __cplusplus
#ifndef __nothrow
# define __nothrow __declspec(nothrow)
#endif  /* __nothrow */
extern "C" {
#else  /* __cplusplus */
#ifndef __nothrow
# define __nothrow
#endif  /* __nothrow */
#endif  /* __cplusplus */


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
The helper annotations are only understood by the compiler version used by various
defect detection tools. When the regular compiler is running, they are defined into
nothing, and do not affect the compiled code.
*/

#if !defined (__midl) && defined (_PREFAST_)

    /*
     In the primitive __declspec("SAL_*") annotations "SAL" stands for Standard
     Annotation Language.  These __declspec("SAL_*") annotations are the
     primitives the compiler understands and all high-level SpecString MACROs
     will decompose into these primivates.
    */

    #define SPECSTRINGIZE( x ) #x

    /*
     __null p
     __notnull p
     __maybenull p

     Annotates a pointer p. States that pointer p is null. Commonly used
     in the negated form __notnull or the possibly null form __maybenull.
    */

    #define __null                  __declspec("SAL_null")
    #define __notnull               __declspec("SAL_notnull")
    #define __maybenull             __declspec("SAL_maybenull")

    /*
     __readonly l
     __notreadonly l
     __mabyereadonly l

     Annotates a location l. States that location l is not modified after
     this point.  If the annotation is placed on the precondition state of
     a function, the restriction only applies until the postcondition state
     of the function.  __maybereadonly states that the annotated location
     may be modified, whereas __notreadonly states that a location must be
     modified.
    */

    #define __readonly              __declspec("SAL_readonly")
    #define __notreadonly           __declspec("SAL_notreadonly")
    #define __maybereadonly         __declspec("SAL_maybereadonly")

    /*
     __valid v
     __notvalid v
     __maybevalid v

     Annotates any value v. States that the value satisfies all properties of
     valid values of its type. For example, for a string buffer, valid means
     that the buffer pointer is either NULL or points to a NULL-terminated string.
    */

    #define __valid                 __declspec("SAL_valid")
    #define __notvalid              __declspec("SAL_notvalid")
    #define __maybevalid            __declspec("SAL_maybevalid")

    /*
     __readableTo(extent) p

     Annotates a buffer pointer p.  If the buffer can be read, extent describes
     how much of the buffer is readable. For a reader of the buffer, this is
     an explicit permission to read up to that amount, rather than a restriction to
     read only up to it.
    */

    #define __readableTo(extent)    __declspec("SAL_readableTo("SPECSTRINGIZE(extent)")")

    /*

     __elem_readableTo(size)

     Annotates a buffer pointer p as being readable to size elements.
    */

    #define __elem_readableTo(size)   __declspec("SAL_readableTo(elementCount("SPECSTRINGIZE(size)"))")

    /*
     __byte_readableTo(size)

     Annotates a buffer pointer p as being readable to size bytes.
    */
    #define __byte_readableTo(size)   __declspec("SAL_readableTo(byteCount("SPECSTRINGIZE(size)"))")

    /*
     __writableTo(extent) p

     Annotates a buffer pointer p. If the buffer can be modified, extent
     describes how much of the buffer is writable (usually the allocation
     size). For a writer of the buffer, this is an explicit permission to
     write up to that amount, rather than a restriction to write only up to it.
    */
    #define __writableTo(size)   __declspec("SAL_writableTo("SPECSTRINGIZE(size)")")

    /*
     __elem_writableTo(size)

     Annotates a buffer pointer p as being writable to size elements.
    */
    #define __elem_writableTo(size)   __declspec("SAL_writableTo(elementCount("SPECSTRINGIZE(size)"))")

    /*
     __byte_writableTo(size)

     Annotates a buffer pointer p as being writable to size bytes.
    */
    #define __byte_writableTo(size)   __declspec("SAL_writableTo(byteCount("SPECSTRINGIZE(size)"))")

    /*
     __deref p

     Annotates a pointer p. The next annotation applies one dereference down
     in the type. If readableTo(p, size) then the next annotation applies to
     all elements *(p+i) for which i satisfies the size. If p is a pointer
     to a struct, the next annotation applies to all fields of the struct.
    */
    #define __deref                 __declspec("SAL_deref")

    /*
     __pre __next_annotation

     The next annotation applies in the precondition state
    */
    #define __pre                   __declspec("SAL_pre")

    /*
     __post __next_annotation

     The next annotation applies in the postcondition state
    */
    #define __post                  __declspec("SAL_post")

    /*
     __precond(<expr>)

     When <expr> is true, the next annotation applies in the precondition state
     (currently not enabled)
    */
    #define __precond(expr)         __pre

    /*
     __postcond(<expr>)

     When <expr> is true, the next annotation applies in the postcondition state
     (currently not enabled)
    */
    #define __postcond(expr)        __post

    /*
     __exceptthat

     Given a set of annotations Q containing __exceptthat maybeP, the effect of
     the except clause is to erase any P or notP annotations (explicit or
     implied) within Q at the same level of dereferencing that the except
     clause appears, and to replace it with maybeP.

      Example 1: __valid __exceptthat __maybenull on a pointer p means that the
                 pointer may be null, and is otherwise valid, thus overriding
                 the implicit notnull annotation implied by __valid on
                 pointers.

      Example 2: __valid __deref __exceptthat __maybenull on an int **p means
                 that p is not null (implied by valid), but the elements
                 pointed to by p could be null, and are otherwise valid.
    */
    #define __exceptthat                __declspec("SAL_except")
    #define __execeptthat               __exceptthat

    /*
     _refparam

     Added to all out parameter macros to indicate that they are all reference
     parameters.
    */
    #define __refparam                  __deref __notreadonly

    /*
     __inner_*

     Helper macros that directly correspond to certain high-level annotations.

    */

    /*
     Macros to classify the entrypoints and indicate their category.

     Pre-defined control point categories include: RPC, LPC, DeviceDriver, UserToKernel, ISAPI, COM.

    */
    #define __inner_control_entrypoint(category) __declspec("SAL_entrypoint(controlEntry, "SPECSTRINGIZE(category)")")

    /*
     Pre-defined data entry point categories include: Registry, File, Network.
    */
    #define __inner_data_entrypoint(category)    __declspec("SAL_entrypoint(dataEntry, "SPECSTRINGIZE(category)")")

    #define __inner_success(expr)               __declspec("SAL_success("SPECSTRINGIZE(expr)")")
    #define __inner_checkReturn                 __declspec("SAL_checkReturn")
    #define __inner_typefix(ctype)              __declspec("SAL_typefix("SPECSTRINGIZE(ctype)")")
    #define __inner_override                    __declspec("__override")
    #define __inner_callback                    __declspec("__callback")
    #define __inner_blocksOn(resource)          __declspec("SAL_blocksOn("SPECSTRINGIZE(resource)")")
    #define __inner_fallthrough_dec             __inline __nothrow void __FallThrough() {}
    #define __inner_fallthrough                 __FallThrough();

#else  /* !defined (__midl) && defined (_PREFAST_) */
    #define __null
    #define __notnull
    #define __maybenull
    #define __readonly
    #define __notreadonly
    #define __maybereadonly
    #define __valid
    #define __notvalid
    #define __maybevalid
    #define __readableTo(extent)
    #define __elem_readableTo(size)
    #define __byte_readableTo(size)
    #define __writableTo(size)
    #define __elem_writableTo(size)
    #define __byte_writableTo(size)
    #define __deref
    #define __pre
    #define __post
    #define __precond(expr)
    #define __postcond(expr)
    #define __exceptthat
    #define __execeptthat
    #define __inner_success(expr)
    #define __inner_checkReturn
    #define __inner_typefix(ctype)
    #define __inner_override
    #define __inner_callback
    #define __inner_blocksOn(resource)
    #define __inner_fallthrough_dec
    #define __inner_fallthrough
    #define __refparam
    #define __inner_control_entrypoint(category)
    #define __inner_data_entrypoint(category)
#endif  /* !defined (__midl) && defined (_PREFAST_) */

/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/

#define __ecount(size)                                          __notnull __elem_writableTo(size)
#define __bcount(size)                                          __notnull __byte_writableTo(size)
#define __in                                                    __pre __valid __pre __deref __readonly
#define __in_ecount(size)                                       __in __pre __elem_readableTo(size)
#define __in_bcount(size)                                       __in __pre __byte_readableTo(size)
#define __in_z                                                  __in __pre __nullterminated
#define __in_ecount_z(size)                                     __in_ecount(size) __pre __nullterminated
#define __in_bcount_z(size)                                     __in_bcount(size) __pre __nullterminated
#define __in_nz                                                 __in
#define __in_ecount_nz(size)                                    __in_ecount(size)
#define __in_bcount_nz(size)                                    __in_bcount(size)
#define __out                                                   __ecount(1) __post __valid __refparam
#define __out_ecount(size)                                      __ecount(size) __post __valid __refparam
#define __out_bcount(size)                                      __bcount(size) __post __valid __refparam
#define __out_ecount_part(size,length)                          __out_ecount(size) __post __elem_readableTo(length)
#define __out_bcount_part(size,length)                          __out_bcount(size) __post __byte_readableTo(length)
#define __out_ecount_full(size)                                 __out_ecount_part(size,size)
#define __out_bcount_full(size)                                 __out_bcount_part(size,size)
#define __out_z                                                 __post __valid __refparam __post __nullterminated
#define __out_z_opt                                             __post __valid __refparam __post __nullterminated __exceptthat __maybenull
#define __out_ecount_z(size)                                    __ecount(size) __post __valid __refparam __post __nullterminated
#define __out_bcount_z(size)                                    __bcount(size) __post __valid __refparam __post __nullterminated
#define __out_ecount_part_z(size,length)                        __out_ecount_part(size,length) __post __nullterminated
#define __out_bcount_part_z(size,length)                        __out_bcount_part(size,length) __post __nullterminated
#define __out_ecount_full_z(size)                               __out_ecount_full(size) __post __nullterminated
#define __out_bcount_full_z(size)                               __out_bcount_full(size) __post __nullterminated
#define __out_nz                                                __post __valid __refparam __post
#define __out_nz_opt                                            __post __valid __refparam __post __exceptthat __maybenull
#define __out_ecount_nz(size)                                   __ecount(size) __post __valid __refparam
#define __out_bcount_nz(size)                                   __bcount(size) __post __valid __refparam
#define __inout                                                 __pre __valid __post __valid __refparam
#define __inout_ecount(size)                                    __out_ecount(size) __pre __valid
#define __inout_bcount(size)                                    __out_bcount(size) __pre __valid
#define __inout_ecount_part(size,length)                        __out_ecount_part(size,length) __pre __valid __pre __elem_readableTo(length)
#define __inout_bcount_part(size,length)                        __out_bcount_part(size,length) __pre __valid __pre __byte_readableTo(length)
#define __inout_ecount_full(size)                               __inout_ecount_part(size,size)
#define __inout_bcount_full(size)                               __inout_bcount_part(size,size)
#define __inout_z                                               __inout __pre __nullterminated __post __nullterminated
#define __inout_ecount_z(size)                                  __inout_ecount(size) __pre __nullterminated __post __nullterminated
#define __inout_bcount_z(size)                                  __inout_bcount(size) __pre __nullterminated __post __nullterminated
#define __inout_nz                                              __inout
#define __inout_ecount_nz(size)                                 __inout_ecount(size)
#define __inout_bcount_nz(size)                                 __inout_bcount(size)
#define __ecount_opt(size)                                      __ecount(size)                              __exceptthat __maybenull
#define __bcount_opt(size)                                      __bcount(size)                              __exceptthat __maybenull
#define __in_opt                                                __in                                        __exceptthat __maybenull
#define __in_ecount_opt(size)                                   __in_ecount(size)                           __exceptthat __maybenull
#define __in_bcount_opt(size)                                   __in_bcount(size)                           __exceptthat __maybenull
#define __in_z_opt                                              __in_opt __pre __nullterminated
#define __in_ecount_z_opt(size)                                 __in_ecount_opt(size) __pre __nullterminated
#define __in_bcount_z_opt(size)                                 __in_bcount_opt(size) __pre __nullterminated
#define __in_nz_opt                                             __in_opt
#define __in_ecount_nz_opt(size)                                __in_ecount_opt(size)
#define __in_bcount_nz_opt(size)                                __in_bcount_opt(size)
#define __out_opt                                               __out                                       __exceptthat __maybenull
#define __out_ecount_opt(size)                                  __out_ecount(size)                          __exceptthat __maybenull
#define __out_bcount_opt(size)                                  __out_bcount(size)                          __exceptthat __maybenull
#define __out_ecount_part_opt(size,length)                      __out_ecount_part(size,length)              __exceptthat __maybenull
#define __out_bcount_part_opt(size,length)                      __out_bcount_part(size,length)              __exceptthat __maybenull
#define __out_ecount_full_opt(size)                             __out_ecount_full(size)                     __exceptthat __maybenull
#define __out_bcount_full_opt(size)                             __out_bcount_full(size)                     __exceptthat __maybenull
#define __out_ecount_z_opt(size)                                __out_ecount_opt(size) __post __nullterminated
#define __out_bcount_z_opt(size)                                __out_bcount_opt(size) __post __nullterminated
#define __out_ecount_part_z_opt(size,length)                    __out_ecount_part_opt(size,length) __post __nullterminated
#define __out_bcount_part_z_opt(size,length)                    __out_bcount_part_opt(size,length) __post __nullterminated
#define __out_ecount_full_z_opt(size)                           __out_ecount_full_opt(size) __post __nullterminated
#define __out_bcount_full_z_opt(size)                           __out_bcount_full_opt(size) __post __nullterminated
#define __out_ecount_nz_opt(size)                               __out_ecount_opt(size) __post __nullterminated
#define __out_bcount_nz_opt(size)                               __out_bcount_opt(size) __post __nullterminated
#define __inout_opt                                             __inout                                     __exceptthat __maybenull
#define __inout_ecount_opt(size)                                __inout_ecount(size)                        __exceptthat __maybenull
#define __inout_bcount_opt(size)                                __inout_bcount(size)                        __exceptthat __maybenull
#define __inout_ecount_part_opt(size,length)                    __inout_ecount_part(size,length)            __exceptthat __maybenull
#define __inout_bcount_part_opt(size,length)                    __inout_bcount_part(size,length)            __exceptthat __maybenull
#define __inout_ecount_full_opt(size)                           __inout_ecount_full(size)                   __exceptthat __maybenull
#define __inout_bcount_full_opt(size)                           __inout_bcount_full(size)                   __exceptthat __maybenull
#define __inout_z_opt                                           __inout_opt __pre __nullterminated __post __nullterminated
#define __inout_ecount_z_opt(size)                              __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated
#define __inout_ecount_z_opt(size)                              __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated
#define __inout_bcount_z_opt(size)                              __inout_bcount_opt(size)
#define __inout_nz_opt                                          __inout_opt
#define __inout_ecount_nz_opt(size)                             __inout_ecount_opt(size)
#define __inout_bcount_nz_opt(size)                             __inout_bcount_opt(size)
#define __deref_ecount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __elem_writableTo(size)
#define __deref_bcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __byte_writableTo(size)
#define __deref_out                                             __deref_ecount(1) __post __deref __valid __refparam
#define __deref_out_ecount(size)                                __deref_ecount(size) __post __deref __valid __refparam
#define __deref_out_bcount(size)                                __deref_bcount(size) __post __deref __valid __refparam
#define __deref_out_ecount_part(size,length)                    __deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __deref_out_bcount_part(size,length)                    __deref_out_bcount(size) __post __deref __byte_readableTo(length)
#define __deref_out_ecount_full(size)                           __deref_out_ecount_part(size,size)
#define __deref_out_bcount_full(size)                           __deref_out_bcount_part(size,size)
#define __deref_out_z                                           __post __deref __valid __refparam __post __deref __nullterminated
#define __deref_out_ecount_z(size)                              __deref_out_ecount(size) __post __deref __nullterminated
#define __deref_out_bcount_z(size)                              __deref_out_ecount(size) __post __deref __nullterminated
#define __deref_out_nz                                          __deref_out
#define __deref_out_ecount_nz(size)                             __deref_out_ecount(size)
#define __deref_out_bcount_nz(size)                             __deref_out_ecount(size)
#define __deref_inout                                           __notnull __elem_readableTo(1) __pre __deref __valid __post __deref __valid __refparam
#define __deref_inout_z                                         __deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount(size)                              __deref_inout __pre __deref __elem_writableTo(size) __post __deref __elem_writableTo(size)
#define __deref_inout_bcount(size)                              __deref_inout __pre __deref __byte_writableTo(size) __post __deref __byte_writableTo(size)
#define __deref_inout_ecount_part(size,length)                  __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length)
#define __deref_inout_bcount_part(size,length)                  __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length)
#define __deref_inout_ecount_full(size)                         __deref_inout_ecount_part(size,size)
#define __deref_inout_bcount_full(size)                         __deref_inout_bcount_part(size,size)
#define __deref_inout_z                                         __deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount_z(size)                            __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_bcount_z(size)                            __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_nz                                        __deref_inout
#define __deref_inout_ecount_nz(size)                           __deref_inout_ecount(size)
#define __deref_inout_bcount_nz(size)                           __deref_inout_ecount(size)
#define __deref_ecount_opt(size)                                __deref_ecount(size)                        __post __deref __exceptthat __maybenull
#define __deref_bcount_opt(size)                                __deref_bcount(size)                        __post __deref __exceptthat __maybenull
#define __deref_out_opt                                         __deref_out                                 __post __deref __exceptthat __maybenull
#define __deref_out_ecount_opt(size)                            __deref_out_ecount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_bcount_opt(size)                            __deref_out_bcount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_ecount_part_opt(size,length)                __deref_out_ecount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_bcount_part_opt(size,length)                __deref_out_bcount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_ecount_full_opt(size)                       __deref_out_ecount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_out_bcount_full_opt(size)                       __deref_out_bcount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_out_z_opt                                       __post __deref __valid __refparam __execeptthat __maybenull __post __deref __nullterminated
#define __deref_out_ecount_z_opt(size)                          __deref_out_ecount_opt(size) __post __deref __nullterminated
#define __deref_out_bcount_z_opt(size)                          __deref_out_bcount_opt(size) __post __deref __nullterminated
#define __deref_out_nz_opt                                      __deref_out_opt
#define __deref_out_ecount_nz_opt(size)                         __deref_out_ecount_opt(size)
#define __deref_out_bcount_nz_opt(size)                         __deref_out_bcount_opt(size)
#define __deref_inout_opt                                       __deref_inout                               __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_opt(size)                          __deref_inout_ecount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_opt(size)                          __deref_inout_bcount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_part_opt(size,length)              __deref_inout_ecount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_part_opt(size,length)              __deref_inout_bcount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_full_opt(size)                     __deref_inout_ecount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_full_opt(size)                     __deref_inout_bcount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_z_opt                                     __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount_z_opt(size)                        __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_bcount_z_opt(size)                        __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_nz_opt                                    __deref_inout_opt
#define __deref_inout_ecount_nz_opt(size)                       __deref_inout_ecount_opt(size)
#define __deref_inout_bcount_nz_opt(size)                       __deref_inout_bcount_opt(size)
#define __deref_opt_ecount(size)                                __deref_ecount(size)                        __exceptthat __maybenull
#define __deref_opt_bcount(size)                                __deref_bcount(size)                        __exceptthat __maybenull
#define __deref_opt_out                                         __deref_out                                 __exceptthat __maybenull
#define __deref_opt_out_z                                       __deref_opt_out __post __deref __nullterminated
#define __deref_opt_out_ecount(size)                            __deref_out_ecount(size)                    __exceptthat __maybenull
#define __deref_opt_out_bcount(size)                            __deref_out_bcount(size)                    __exceptthat __maybenull
#define __deref_opt_out_ecount_part(size,length)                __deref_out_ecount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_bcount_part(size,length)                __deref_out_bcount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_ecount_full(size)                       __deref_out_ecount_full(size)               __exceptthat __maybenull
#define __deref_opt_out_bcount_full(size)                       __deref_out_bcount_full(size)               __exceptthat __maybenull
#define __deref_opt_inout                                       __deref_inout                               __exceptthat __maybenull
#define __deref_opt_inout_ecount(size)                          __deref_inout_ecount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_bcount(size)                          __deref_inout_bcount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_ecount_part(size,length)              __deref_inout_ecount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_bcount_part(size,length)              __deref_inout_bcount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_ecount_full(size)                     __deref_inout_ecount_full(size)             __exceptthat __maybenull
#define __deref_opt_inout_bcount_full(size)                     __deref_inout_bcount_full(size)             __exceptthat __maybenull
#define __deref_opt_inout_z                                     __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_ecount_z(size)                        __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_bcount_z(size)                        __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_nz                                    __deref_opt_inout
#define __deref_opt_inout_ecount_nz(size)                       __deref_opt_inout_ecount(size)
#define __deref_opt_inout_bcount_nz(size)                       __deref_opt_inout_bcount(size)
#define __deref_opt_ecount_opt(size)                            __deref_ecount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_bcount_opt(size)                            __deref_bcount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_out_opt                                     __deref_out_opt                             __exceptthat __maybenull
#define __deref_opt_out_ecount_opt(size)                        __deref_out_ecount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_bcount_opt(size)                        __deref_out_bcount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_ecount_part_opt(size,length)            __deref_out_ecount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_bcount_part_opt(size,length)            __deref_out_bcount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_ecount_full_opt(size)                   __deref_out_ecount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_out_bcount_full_opt(size)                   __deref_out_bcount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_out_z_opt                                   __post __deref __valid __refparam __exceptthat __maybenull __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull __post __deref __nullterminated
#define __deref_opt_out_ecount_z_opt(size)                      __deref_opt_out_ecount_opt(size) __post __deref __nullterminated
#define __deref_opt_out_bcount_z_opt(size)                      __deref_opt_out_bcount_opt(size) __post __deref __nullterminated
#define __deref_opt_out_nz_opt                                  __deref_opt_out_opt
#define __deref_opt_out_ecount_nz_opt(size)                     __deref_opt_out_ecount_opt(size)
#define __deref_opt_out_bcount_nz_opt(size)                     __deref_opt_out_bcount_opt(size)
#define __deref_opt_inout_opt                                   __deref_inout_opt                           __exceptthat __maybenull
#define __deref_opt_inout_ecount_opt(size)                      __deref_inout_ecount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_bcount_opt(size)                      __deref_inout_bcount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_ecount_part_opt(size,length)          __deref_inout_ecount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_bcount_part_opt(size,length)          __deref_inout_bcount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_ecount_full_opt(size)                 __deref_inout_ecount_full_opt(size)         __exceptthat __maybenull
#define __deref_opt_inout_bcount_full_opt(size)                 __deref_inout_bcount_full_opt(size)         __exceptthat __maybenull
#define __deref_opt_inout_z_opt                                 __deref_opt_inout_opt  __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_ecount_z_opt(size)                    __deref_opt_inout_ecount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_bcount_z_opt(size)                    __deref_opt_inout_bcount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_nz_opt                                __deref_opt_inout_opt
#define __deref_opt_inout_ecount_nz_opt(size)                   __deref_opt_inout_ecount_opt(size)
#define __deref_opt_inout_bcount_nz_opt(size)                   __deref_opt_inout_bcount_opt(size)

/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/

#define __success(expr)                     __inner_success(expr)
#define __nullterminated                    __readableTo(sentinel(0))
#define __nullnullterminated
#define __reserved                          __pre __null
#define __checkReturn                       __inner_checkReturn
#define __typefix(ctype)                    __inner_typefix(ctype)
#define __override                          __inner_override
#define __callback                          __inner_callback
#define __format_string
#define __blocksOn(resource)                __inner_blocksOn(resource)
#define __control_entrypoint(category)      __inner_control_entrypoint(category)
#define __data_entrypoint(category)         __inner_data_entrypoint(category)

#ifndef __fallthrough
    __inner_fallthrough_dec
    #define __fallthrough __inner_fallthrough
#endif  /* __fallthrough */

#ifndef __analysis_assume
#ifdef _PREFAST_
#define __analysis_assume(expr) __assume(expr)
#else  /* _PREFAST_ */
#define __analysis_assume(expr)
#endif  /* _PREFAST_ */
#endif  /* __analysis_assume */

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setvbuf.c ===
/***
*setvbuf.c - set buffer size for a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines setvbuf() - set the buffering mode and size for a stream.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <malloc.h>
#include <internal.h>
#include <mtdll.h>
#include <limits.h>
#include <dbgint.h>

/***
*int setvbuf(stream, buffer, type, size) - set buffering for a file
*
*Purpose:
*       Controls buffering and buffer size for the specified stream.  The
*       array pointed to by buf is used as a buffer, unless NULL, in which
*       case we'll allocate a buffer automatically. type specifies the type
*       of buffering: _IONBF = no buffer, _IOFBF = buffered, _IOLBF = same
*       as _IOFBF.
*
*Entry:
*       FILE *stream - stream to control buffer on
*       char *buffer - pointer to buffer to use (NULL means auto allocate)
*       int type     - type of buffering (_IONBF, _IOFBF or _IOLBF)
*       size_t size  - size of buffer
*
*Exit:
*       return 0 if successful
*       returns non-zero if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl setvbuf (
        FILE *str,
        char *buffer,
        int type,
        size_t size
        )
{
        REG1 FILE *stream;
        int retval=0;   /* assume good return */

        _VALIDATE_RETURN( (str != NULL), EINVAL, -1 );

        /*
         * (1) Make sure type is one of the three legal values.
         * (2) If we are buffering, make sure size is between 2 and INT_MAX.
         */
        _VALIDATE_RETURN( (type == _IONBF) || (type == _IOFBF) || (type == _IOLBF), EINVAL, -1 );

        if ((type == _IOFBF) || (type == _IOLBF))
        {
            _VALIDATE_RETURN( ((2 <= size) && (size <= INT_MAX)), EINVAL, -1 );
        }

        /*
         * force size to be even by masking down to the nearest multiple
         * of 2
         */
        size &= (size_t)~1;

        /*
         * Init stream pointers
         */
        stream = str;

        /*
         * Lock the file
         */
        _lock_str(stream);
        __try {

        /*
         * Flush the current buffer and free it, if it is ours.
         */
        _flush(stream);
        _freebuf(stream);

        /*
         * Clear a bunch of bits in stream->_flag (all bits related to
         * buffering and those which used to be in stream2->_flag2). Most
         * of these should never be set when setvbuf() is called, but it
         * doesn't cost anything to be safe.
         */
        stream->_flag &= ~(_IOMYBUF | _IOYOURBUF | _IONBF |
                           _IOSETVBUF | _IOFEOF | _IOFLRTN | _IOCTRLZ);

        /*
         * CASE 1: No Buffering.
         */
        if (type & _IONBF) {
                stream->_flag |= _IONBF;
                buffer = (char *)&(stream->_charbuf);
                size = 2;
        }

        /*
         * NOTE: Cases 2 and 3 (below) cover type == _IOFBF or type == _IOLBF
         * Line buffering is treated as the same as full buffering, so the
         * _IOLBF bit in stream->_flag is never set. Finally, since _IOFBF is
         * defined to be 0, full buffering is simply assumed whenever _IONBF
         * is not set.
         */

        /*
         * CASE 2: Default Buffering -- Allocate a buffer for the user.
         */
        else if ( buffer == NULL ) {
                if ( (buffer = _malloc_crt(size)) == NULL ) {
#ifndef CRTDLL
                        /*
                         * force library pre-termination procedure (placed here
                         * because the code path should almost never be hit)
                         */
                        _cflush++;
#endif  /* CRTDLL */
                        retval = -1;
                        goto done;
                }
                stream->_flag |= _IOMYBUF | _IOSETVBUF;
        }

        /*
         * CASE 3: User Buffering -- Use the buffer supplied by the user.
         */
        else {
                stream->_flag |= _IOYOURBUF | _IOSETVBUF;
        }

        /*
         * Common return for all cases.
         */
        stream->_bufsiz = (int)size;
        stream->_ptr = stream->_base = buffer;
        stream->_cnt = 0;
done:

        ; }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\sbheap.c ===
/***
*sbheap.c -  Small-block heap code
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Core code for small-block heap.
*
*******************************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <malloc.h>
#include <limits.h>

#ifndef _WIN64

/* Current (VC++ 6.0) small-block heap code and data */

size_t      __sbh_threshold;
int         __sbh_initialized;

PHEADER     __sbh_pHeaderList;     //  pointer to list start
PHEADER     __sbh_pHeaderScan;     //  pointer to list rover
int         __sbh_sizeHeaderList;       //  allocated size of list
int         __sbh_cntHeaderList;        //  count of entries defined

PHEADER     __sbh_pHeaderDefer=NULL;
int         __sbh_indGroupDefer;

/* Prototypes for user functions */

size_t __cdecl _get_sbh_threshold(void);
int    __cdecl _set_sbh_threshold(size_t);

void DumpEntry(char *, int *);

#endif  /* _WIN64 */

/***
*size_t _get_sbh_threshold() - return small-block threshold
*
*Purpose:
*       Return the current value of __sbh_threshold
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _get_sbh_threshold (void)
{
    /* Ensure already initialised */
    _ASSERTE(_crtheap);
    if(!_crtheap)
    {
        return 0;
    }
#ifndef _WIN64
    if ( __active_heap == __V6_HEAP )
    {
        return __sbh_threshold;
    }
#ifdef CRTDLL
    if ( __active_heap == __V5_HEAP )
    {
        return __old_sbh_threshold;
    }
#endif  /* CRTDLL */
#endif  /* _WIN64 */
    return 0;
}

/***
*int _set_sbh_threshold(threshold) - set small-block heap threshold
*
*Purpose:
*       Set the upper limit for the size of an allocation which will be
*       supported from the small-block heap.
*
*Entry:
*       size_t threshold - proposed new value for __sbh_theshold
*
*Exit:
*       Returns 1 if successful. Returns 0 if threshold was invalid.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

int __cdecl _set_sbh_threshold (size_t threshold)
{
        _ASSERTE(_crtheap);
        if(!_crtheap)
        {
            return 0;
        }
#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            //  test against maximum value - if too large, return error
            _VALIDATE_RETURN(threshold <= MAX_ALLOC_DATA_SIZE, EINVAL, 0);
            __sbh_threshold = threshold;
            return 1;
        }

#ifdef CRTDLL
        if ( __active_heap == __V5_HEAP )
        {
            //  Round up the proposed new value to the nearest paragraph
            threshold = (threshold + _OLD_PARASIZE - 1) & ~(_OLD_PARASIZE - 1);

            //  Require that at least two allocations be can be made within a
            //  page.
            _VALIDATE_RETURN(
                threshold <= (_OLD_PARASIZE * (_OLD_PARAS_PER_PAGE / 2)),
                EINVAL,
                0);
            __old_sbh_threshold = threshold;
            return 1;
        }

        //  if threshold is 0, we just return
        if (threshold == 0)
        {
            return 1;
        }

        //  if necessary, initialize a small-block heap
        if (__active_heap == __SYSTEM_HEAP)
        {
            LinkerVersion lv;

            _GetLinkerVersion(&lv);
            if (lv.bverMajor >= 6)
            {
                //  Initialize the VC++ 6.0 small-block heap
                _VALIDATE_RETURN(
                    (threshold <= MAX_ALLOC_DATA_SIZE) && __sbh_heap_init(threshold),
                    EINVAL,
                    0);
                __sbh_threshold = threshold;
                __active_heap = __V6_HEAP;
                return 1;
            }
            else
            {
                //  Initialize the old (VC++ 5.0) small-block heap
                threshold = (threshold + _OLD_PARASIZE - 1) &
                            ~(_OLD_PARASIZE - 1);
                _VALIDATE_RETURN(
                    (threshold <= (_OLD_PARASIZE * (_OLD_PARAS_PER_PAGE / 2))) &&
                        (__old_sbh_new_region() != NULL),
                    EINVAL,
                    0);
                __old_sbh_threshold = threshold;
                __active_heap = __V5_HEAP;
                return 1;
            }
        }
#else  /* CRTDLL */
        //  if threshold is 0, we just return
        if (threshold == 0)
        {
            return 1;
        }

        //  if necessary, initialize a small-block heap
        if (__active_heap == __SYSTEM_HEAP)
        {
            //  Initialize the VC++ 6.0 small-block heap
            _VALIDATE_RETURN(
                (threshold <= MAX_ALLOC_DATA_SIZE) && __sbh_heap_init(threshold),
                EINVAL,
                0);
            __sbh_threshold = threshold;
            __active_heap = __V6_HEAP;
            return 1;
        }
#endif  /* CRTDLL */
#endif  /* _WIN64 */

        errno = EINVAL;
        return 0;
}

/***
*_set_amblksiz(size) - Set the value of _amblksiz
*
*Purpose:
*       Set the value of _amblksiz
*
*Entry:
*       size_t size, needs to be > 0
*Exit:
*       Returns 0 if everything is ok, else return the errno_t
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

errno_t __cdecl _set_amblksiz(size_t size)
{
    /* validation section */
    _VALIDATE_RETURN_ERRCODE(0 < size && size <= UINT_MAX, EINVAL);
    _VALIDATE_RETURN_ERRCODE(_crtheap, EINVAL);

    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    _amblksiz = (unsigned int)size;
    _END_SECURE_CRT_DEPRECATION_DISABLE

    return 0;
}

/***
*_get_amblksiz(pSize) - Get the value of _amblksiz
*
*Purpose:
*       Get the value of _amblksiz
*
*Entry:
*       size_t *pSize
*Exit:
*       Returns 0 if everything is ok, else return the errno_t
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

errno_t __cdecl _get_amblksiz(size_t *pSize)
{
    /* validation section */
    _VALIDATE_RETURN_ERRCODE(pSize != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(_crtheap, EINVAL);

    _BEGIN_SECURE_CRT_DEPRECATION_DISABLE
    *pSize = _amblksiz;
    _END_SECURE_CRT_DEPRECATION_DISABLE

    return 0;
}

#ifndef _WIN64

/***
*int __sbh_heap_init() - set small-block heap threshold
*
*Purpose:
*       Allocate space for initial header list and init variables.
*
*Entry:
*       None.
*
*Exit:
*       Returns 1 if successful. Returns 0 if initialization failed.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_heap_init (size_t threshold)
{
        if (!(__sbh_pHeaderList = HeapAlloc(_crtheap, 0, 16 * sizeof(HEADER))))
            return FALSE;

        __sbh_threshold = threshold;
        __sbh_pHeaderScan = __sbh_pHeaderList;
        __sbh_pHeaderDefer = NULL;
        __sbh_cntHeaderList = 0;
        __sbh_sizeHeaderList = 16;

        return TRUE;
}

/***
*PHEADER *__sbh_find_block(pvAlloc) - find block in small-block heap
*
*Purpose:
*       Determine if the specified allocation block lies in the small-block
*       heap and, if so, return the header to be used for the block.
*
*Entry:
*       void * pvBlock - pointer to block to be freed
*
*Exit:
*       If successful, a pointer to the header to use is returned.
*       If unsuccessful, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

PHEADER __cdecl __sbh_find_block (void * pvAlloc)
{
        PHEADER         pHeaderLast = __sbh_pHeaderList + __sbh_cntHeaderList;
        PHEADER         pHeader;
        unsigned int    offRegion;

        //  scan through the header list to determine if entry
        //  is in the region heap data reserved address space
        pHeader = __sbh_pHeaderList;
        while (pHeader < pHeaderLast)
        {
            offRegion = (unsigned int)((uintptr_t)pvAlloc - (uintptr_t)pHeader->pHeapData);
            if (offRegion < BYTES_PER_REGION)
                return pHeader;
            pHeader++;
        }
        return NULL;
}

#ifdef _DEBUG

/***
*int __sbh_verify_block(pHeader, pvAlloc) - verify pointer in sbh
*
*Purpose:
*       Test if pointer is valid within the heap header given.
*
*Entry:
*       pHeader - pointer to HEADER where entry should be
*       pvAlloc - pointer to test validity of
*
*Exit:
*       Returns 1 if pointer is valid, else 0.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_verify_block (PHEADER pHeader, void * pvAlloc)
{
        unsigned int    indGroup;
        unsigned int    offRegion;

        //  calculate region offset to determine the group index
        offRegion = (unsigned int)((uintptr_t)pvAlloc - (uintptr_t)pHeader->pHeapData);
        indGroup = offRegion / BYTES_PER_GROUP;

        //  return TRUE if:
        //      group is committed (bit in vector cleared) AND
        //      pointer is at paragraph boundary AND
        //      pointer is not at start of page
        return (!(pHeader->bitvCommit & (0x80000000UL >> indGroup))) &&
                (!(offRegion & 0xf)) &&
                (offRegion & (BYTES_PER_PAGE - 1));
}

#endif  /* _DEBUG */

/***
*void __sbh_free_block(preg, ppage, pmap) - free block
*
*Purpose:
*       Free the specified block from the small-block heap.
*
*Entry:
*       pHeader - pointer to HEADER of region to free memory
*       pvAlloc - pointer to memory to free
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_free_block (PHEADER pHeader, void * pvAlloc)
{
    PREGION         pRegion;
    PGROUP          pGroup;
    PENTRY          pHead;
    PENTRY          pEntry;
    PENTRY          pNext;
    PENTRY          pPrev;
    void *          pHeapDecommit;
    int             sizeEntry;
    int             sizeNext;
    int             sizePrev;
    unsigned int    indGroup;
    unsigned int    indEntry;
    unsigned int    indNext;
    unsigned int    indPrev;
    unsigned int    offRegion;

    //  region is determined by the header
    pRegion = pHeader->pRegion;

    //  use the region offset to determine the group index
    offRegion = (unsigned int)(((uintptr_t)pvAlloc - (uintptr_t)pHeader->pHeapData));
    indGroup = offRegion / BYTES_PER_GROUP;
    pGroup = &pRegion->grpHeadList[indGroup];

    //  get size of entry - decrement value since entry is allocated
    pEntry = (PENTRY)((char *)pvAlloc - sizeof(int));
    sizeEntry = pEntry->sizeFront - 1;

    //  check if the entry is already free. note the size has already been
    // decremented
    if ( (sizeEntry & 1 ) != 0 )
        return;

    //  point to next entry to get its size
    pNext = (PENTRY)((char *)pEntry + sizeEntry);
    sizeNext = pNext->sizeFront;

    //  get size from end of previous entry
    sizePrev = ((PENTRYEND)((char *)pEntry - sizeof(int)))->sizeBack;

    //  test if next entry is free by an even size value

    if ((sizeNext & 1) == 0)
    {
        //  free next entry - disconnect and add its size to sizeEntry

        //  determine index of next entry
        indNext = (sizeNext >> 4) - 1;
        if (indNext > 63)
            indNext = 63;

        //  test entry is sole member of bucket (next == prev),
        if (pNext->pEntryNext == pNext->pEntryPrev)
        {
            //  clear bit in group vector, decrement region count
            //  if region count is now zero, clear bit in header
            //  entry vector
            if (indNext < 32)
            {
                pRegion->bitvGroupHi[indGroup] &= ~(0x80000000L >> indNext);
                if (--pRegion->cntRegionSize[indNext] == 0)
                    pHeader->bitvEntryHi &= ~(0x80000000L >> indNext);
            }
            else
            {
                pRegion->bitvGroupLo[indGroup] &=
                                            ~(0x80000000L >> (indNext - 32));
                if (--pRegion->cntRegionSize[indNext] == 0)
                    pHeader->bitvEntryLo &= ~(0x80000000L >> (indNext - 32));
            }
        }

        //  unlink entry from list
        pNext->pEntryPrev->pEntryNext = pNext->pEntryNext;
        pNext->pEntryNext->pEntryPrev = pNext->pEntryPrev;

        //  add next entry size to freed entry size
        sizeEntry += sizeNext;
    }

    //  compute index of free entry (plus next entry if it was free)
    indEntry = (sizeEntry >> 4) - 1;
    if (indEntry > 63)
        indEntry = 63;

    //  test if previous entry is free by an even size value
    if ((sizePrev & 1) == 0)
    {
        //  free previous entry - add size to sizeEntry and
        //  disconnect if index changes

        //  get pointer to previous entry
        pPrev = (PENTRY)((char *)pEntry - sizePrev);

        //  determine index of previous entry
        indPrev = (sizePrev >> 4) - 1;
        if (indPrev > 63)
            indPrev = 63;

        //  add previous entry size to sizeEntry and determine
        //  its new index
        sizeEntry += sizePrev;
        indEntry = (sizeEntry >> 4) - 1;
        if (indEntry > 63)
            indEntry = 63;

        //  if index changed due to coalesing, reconnect to new size
        if (indPrev != indEntry)
        {
            //  disconnect entry from indPrev
            //  test entry is sole member of bucket (next == prev),
            if (pPrev->pEntryNext == pPrev->pEntryPrev)
            {
                //  clear bit in group vector, decrement region count
                //  if region count is now zero, clear bit in header
                //  entry vector
                if (indPrev < 32)
                {
                    pRegion->bitvGroupHi[indGroup] &=
                                                ~(0x80000000L >> indPrev);
                    if (--pRegion->cntRegionSize[indPrev] == 0)
                        pHeader->bitvEntryHi &= ~(0x80000000L >> indPrev);
                }
                else
                {
                    pRegion->bitvGroupLo[indGroup] &=
                                            ~(0x80000000L >> (indPrev - 32));
                    if (--pRegion->cntRegionSize[indPrev] == 0)
                        pHeader->bitvEntryLo &=
                                            ~(0x80000000L >> (indPrev - 32));
                }
            }

            //  unlink entry from list
            pPrev->pEntryPrev->pEntryNext = pPrev->pEntryNext;
            pPrev->pEntryNext->pEntryPrev = pPrev->pEntryPrev;
        }
        //  set pointer to connect it instead of the free entry
        pEntry = pPrev;
    }

    //  test if previous entry was free with an index change or allocated
    if (!((sizePrev & 1) == 0 && indPrev == indEntry))
    {
        //  connect pEntry entry to indEntry
        //  add entry to the start of the bucket list
        pHead = (PENTRY)((char *)&pGroup->listHead[indEntry] - sizeof(int));
        pEntry->pEntryNext = pHead->pEntryNext;
        pEntry->pEntryPrev = pHead;
        pHead->pEntryNext = pEntry;
        pEntry->pEntryNext->pEntryPrev = pEntry;

        //  test entry is sole member of bucket (next == prev),
        if (pEntry->pEntryNext == pEntry->pEntryPrev)
        {
            //  if region count was zero, set bit in region vector
            //  set bit in header entry vector, increment region count
            if (indEntry < 32)
            {
                if (pRegion->cntRegionSize[indEntry]++ == 0)
                    pHeader->bitvEntryHi |= 0x80000000L >> indEntry;
                pRegion->bitvGroupHi[indGroup] |= 0x80000000L >> indEntry;
            }
            else
            {
                if (pRegion->cntRegionSize[indEntry]++ == 0)
                    pHeader->bitvEntryLo |= 0x80000000L >> (indEntry - 32);
                pRegion->bitvGroupLo[indGroup] |= 0x80000000L >>
                                                           (indEntry - 32);
            }
        }
    }

    //  adjust the entry size front and back
    pEntry->sizeFront = sizeEntry;
    ((PENTRYEND)((char *)pEntry + sizeEntry -
                        sizeof(ENTRYEND)))->sizeBack = sizeEntry;

        //  one less allocation in group - test if empty
    if (--pGroup->cntEntries == 0)
    {
        //  if a group has been deferred, free that group
        if (__sbh_pHeaderDefer)
        {
            //  if now zero, decommit the group data heap
            pHeapDecommit = (void *)((char *)__sbh_pHeaderDefer->pHeapData +
                                    __sbh_indGroupDefer * BYTES_PER_GROUP);
            VirtualFree(pHeapDecommit, BYTES_PER_GROUP, MEM_DECOMMIT);

            //  set bit in commit vector
            __sbh_pHeaderDefer->bitvCommit |=
                                          0x80000000 >> __sbh_indGroupDefer;

            //  clear entry vector for the group and header vector bit
            //  if needed
            __sbh_pHeaderDefer->pRegion->bitvGroupLo[__sbh_indGroupDefer] = 0;
            if (--__sbh_pHeaderDefer->pRegion->cntRegionSize[63] == 0)
                __sbh_pHeaderDefer->bitvEntryLo &= ~0x00000001L;

            //  if commit vector is the initial value,
            //  remove the region if it is not the last
            if (__sbh_pHeaderDefer->bitvCommit == BITV_COMMIT_INIT)
            {
                //  release the address space for heap data
                VirtualFree(__sbh_pHeaderDefer->pHeapData, 0, MEM_RELEASE);

                //  free the region memory area
                HeapFree(_crtheap, 0, __sbh_pHeaderDefer->pRegion);

                //  remove entry from header list by copying over
                memmove((void *)__sbh_pHeaderDefer,
                            (void *)(__sbh_pHeaderDefer + 1),
                            (int)((intptr_t)(__sbh_pHeaderList + __sbh_cntHeaderList) -
                            (intptr_t)(__sbh_pHeaderDefer + 1)));
                __sbh_cntHeaderList--;

                //  if pHeader was after the one just removed, adjust it
                if (pHeader > __sbh_pHeaderDefer)
                    pHeader--;

                //  initialize scan pointer to start of list
                __sbh_pHeaderScan = __sbh_pHeaderList;
            }
        }

        //  defer the group just freed
        __sbh_pHeaderDefer = pHeader;
        __sbh_indGroupDefer = indGroup;
    }
}

/***
*void * __sbh_alloc_block(intSize) - allocate a block
*
*Purpose:
*       Allocate a block from the small-block heap, the specified number of
*       bytes in size.
*
*Entry:
*       intSize - size of the allocation request in bytes
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, if failure.
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl __sbh_alloc_block (int intSize)
{
    PHEADER     pHeaderLast = __sbh_pHeaderList + __sbh_cntHeaderList;
    PHEADER     pHeader;
    PREGION     pRegion;
    PGROUP      pGroup;
    PENTRY      pEntry;
    PENTRY      pHead;
    BITVEC      bitvEntryLo;
    BITVEC      bitvEntryHi;
    BITVEC      bitvTest;
    int         sizeEntry;
    int         indEntry;
    int         indGroupUse;
    int         sizeNewFree;
    int         indNewFree;

    //  add 8 bytes entry overhead and round up to next para size
    sizeEntry = (intSize + 2 * (int)sizeof(int) + (BYTES_PER_PARA - 1))
                & ~(BYTES_PER_PARA - 1);

#ifdef _WIN64
    if (sizeEntry < 32)
        sizeEntry = 32;
#endif  /* _WIN64 */

    //  determine index and mask from entry size
    //  Hi MSB: bit 0      size: 1 paragraph
    //          bit 1            2 paragraphs
    //          ...              ...
    //          bit 30           31 paragraphs
    //          bit 31           32 paragraphs
    //  Lo MSB: bit 0      size: 33 paragraph
    //          bit 1            34 paragraphs
    //          ...              ...
    //          bit 30           63 paragraphs
    //          bit 31           64+ paragraphs
    indEntry = (sizeEntry >> 4) - 1;
    if (indEntry < 32)
    {
        bitvEntryHi = 0xffffffffUL >> indEntry;
        bitvEntryLo = 0xffffffffUL;
    }
    else
    {
        bitvEntryHi = 0;
        bitvEntryLo = 0xffffffffUL >> (indEntry - 32);
    }

    //  scan header list from rover to end for region with a free
    //  entry with an adequate size
    pHeader = __sbh_pHeaderScan;
    while (pHeader < pHeaderLast)
    {
        if ((bitvEntryHi & pHeader->bitvEntryHi) |
            (bitvEntryLo & pHeader->bitvEntryLo))
            break;
        pHeader++;
    }

    //  if no entry, scan from list start up to the rover
    if (pHeader == pHeaderLast)
    {
        pHeader = __sbh_pHeaderList;
        while (pHeader < __sbh_pHeaderScan)
        {
            if ((bitvEntryHi & pHeader->bitvEntryHi) |
                (bitvEntryLo & pHeader->bitvEntryLo))
                break;
            pHeader++;
        }

        //  no free entry exists, scan list from rover to end
        //  for available groups to commit
        if (pHeader == __sbh_pHeaderScan)
        {
            while (pHeader < pHeaderLast)
            {
                if (pHeader->bitvCommit)
                    break;
                pHeader++;
            }

            //  if no available groups, scan from start to rover
            if (pHeader == pHeaderLast)
            {
                pHeader = __sbh_pHeaderList;
                while (pHeader < __sbh_pHeaderScan)
                {
                    if (pHeader->bitvCommit)
                        break;
                    pHeader++;
                }

                //  if no available groups, create a new region
                if (pHeader == __sbh_pHeaderScan)
                    if (!(pHeader = __sbh_alloc_new_region()))
                        return NULL;
            }

            //  commit a new group in region associated with pHeader
            if ((pHeader->pRegion->indGroupUse =
                                    __sbh_alloc_new_group(pHeader)) == -1)
                return NULL;
        }
    }
    __sbh_pHeaderScan = pHeader;

    pRegion = pHeader->pRegion;
    indGroupUse = pRegion->indGroupUse;

    //  determine the group to allocate from
    if (indGroupUse == -1 ||
                    !((bitvEntryHi & pRegion->bitvGroupHi[indGroupUse]) |
                      (bitvEntryLo & pRegion->bitvGroupLo[indGroupUse])))
    {
        //  preferred group could not allocate entry, so
        //  scan through all defined vectors
        indGroupUse = 0;
        while (!((bitvEntryHi & pRegion->bitvGroupHi[indGroupUse]) |
                 (bitvEntryLo & pRegion->bitvGroupLo[indGroupUse])))
            indGroupUse++;
    }
    pGroup = &pRegion->grpHeadList[indGroupUse];

    //  determine bucket index
    indEntry = 0;

    //  get high entry intersection - if zero, use the lower one
    if (!(bitvTest = bitvEntryHi & pRegion->bitvGroupHi[indGroupUse]))
    {
        indEntry = 32;
        bitvTest = bitvEntryLo & pRegion->bitvGroupLo[indGroupUse];
    }
       while ((int)bitvTest >= 0)
    {
           bitvTest <<= 1;
           indEntry++;
    }
    pEntry = pGroup->listHead[indEntry].pEntryNext;

    //  compute size and bucket index of new free entry

    //  for zero-sized entry, the index is -1
    sizeNewFree = pEntry->sizeFront - sizeEntry;
    indNewFree = (sizeNewFree >> 4) - 1;
    if (indNewFree > 63)
        indNewFree = 63;

    //  only modify entry pointers if bucket index changed
    if (indNewFree != indEntry)
    {
        //  test entry is sole member of bucket (next == prev),
        if (pEntry->pEntryNext == pEntry->pEntryPrev)
        {
            //  clear bit in group vector, decrement region count
            //  if region count is now zero, clear bit in region vector
            if (indEntry < 32)
            {
                pRegion->bitvGroupHi[indGroupUse] &=
                                            ~(0x80000000L >> indEntry);
                if (--pRegion->cntRegionSize[indEntry] == 0)
                    pHeader->bitvEntryHi &= ~(0x80000000L >> indEntry);
            }
            else
            {
                pRegion->bitvGroupLo[indGroupUse] &=
                                            ~(0x80000000L >> (indEntry - 32));
                if (--pRegion->cntRegionSize[indEntry] == 0)
                    pHeader->bitvEntryLo &= ~(0x80000000L >> (indEntry - 32));
            }
        }

        //  unlink entry from list
        pEntry->pEntryPrev->pEntryNext = pEntry->pEntryNext;
        pEntry->pEntryNext->pEntryPrev = pEntry->pEntryPrev;

        //  if free entry size is still nonzero, reconnect it
        if (sizeNewFree != 0)
        {
            //  add entry to the start of the bucket list
            pHead = (PENTRY)((char *)&pGroup->listHead[indNewFree] -
                                                           sizeof(int));
            pEntry->pEntryNext = pHead->pEntryNext;
            pEntry->pEntryPrev = pHead;
            pHead->pEntryNext = pEntry;
            pEntry->pEntryNext->pEntryPrev = pEntry;

            //  test entry is sole member of bucket (next == prev),
            if (pEntry->pEntryNext == pEntry->pEntryPrev)
            {
                //  if region count was zero, set bit in region vector
                //  set bit in group vector, increment region count
                if (indNewFree < 32)
                {
                    if (pRegion->cntRegionSize[indNewFree]++ == 0)
                        pHeader->bitvEntryHi |= 0x80000000L >> indNewFree;
                    pRegion->bitvGroupHi[indGroupUse] |=
                                                0x80000000L >> indNewFree;
                }
                else
                {
                    if (pRegion->cntRegionSize[indNewFree]++ == 0)
                        pHeader->bitvEntryLo |=
                                        0x80000000L >> (indNewFree - 32);
                    pRegion->bitvGroupLo[indGroupUse] |=
                                        0x80000000L >> (indNewFree - 32);
                }
            }
        }
    }

    //  change size of free entry (front and back)
    if (sizeNewFree != 0)
    {
        pEntry->sizeFront = sizeNewFree;
        ((PENTRYEND)((char *)pEntry + sizeNewFree -
                    sizeof(ENTRYEND)))->sizeBack = sizeNewFree;
    }

    //  mark the allocated entry
    pEntry = (PENTRY)((char *)pEntry + sizeNewFree);
    pEntry->sizeFront = sizeEntry + 1;
    ((PENTRYEND)((char *)pEntry + sizeEntry -
                    sizeof(ENTRYEND)))->sizeBack = sizeEntry + 1;

    //  one more allocation in group - test if group was empty
    if (pGroup->cntEntries++ == 0)
    {
        //  if allocating into deferred group, cancel deferral
        if (pHeader == __sbh_pHeaderDefer &&
                                  indGroupUse == __sbh_indGroupDefer)
            __sbh_pHeaderDefer = NULL;
    }

    pRegion->indGroupUse = indGroupUse;

    return (void *)((char *)pEntry + sizeof(int));
}

/***
*PHEADER __sbh_alloc_new_region()
*
*Purpose:
*       Add a new HEADER structure in the header list.  Allocate a new
*       REGION structure and initialize.  Reserve memory for future
*       group commitments.
*
*Entry:
*       None.
*
*Exit:
*       Returns a pointer to newly created HEADER entry, if successful.
*       Returns NULL, if failure.
*
*Exceptions:
*
*******************************************************************************/

PHEADER __cdecl __sbh_alloc_new_region (void)
{
    PHEADER     pHeader;

    //  create a new entry in the header list

    //  if list if full, realloc to extend its size
    if (__sbh_cntHeaderList == __sbh_sizeHeaderList)
    {
        if (!(pHeader = (PHEADER)HeapReAlloc(_crtheap, 0, __sbh_pHeaderList,
                            (__sbh_sizeHeaderList + 16) * sizeof(HEADER))))
            return NULL;

        //  update pointer and counter values
        __sbh_pHeaderList = pHeader;
        __sbh_sizeHeaderList += 16;
    }

    //  point to new header in list
    pHeader = __sbh_pHeaderList + __sbh_cntHeaderList;

    //  allocate a new region associated with the new header
    if (!(pHeader->pRegion = (PREGION)HeapAlloc(_crtheap, HEAP_ZERO_MEMORY,
                                    sizeof(REGION))))
        return NULL;

    //  reserve address space for heap data in the region
    if ((pHeader->pHeapData = VirtualAlloc(0, BYTES_PER_REGION,
                                     MEM_RESERVE, PAGE_READWRITE)) == NULL)
    {
        HeapFree(_crtheap, 0, pHeader->pRegion);
        return NULL;
    }

    //  initialize alloc and commit group vectors
    pHeader->bitvEntryHi = 0;
    pHeader->bitvEntryLo = 0;
    pHeader->bitvCommit = BITV_COMMIT_INIT;

    //  complete entry by incrementing list count
    __sbh_cntHeaderList++;

    //  initialize index of group to try first (none defined yet)
    pHeader->pRegion->indGroupUse = -1;

    return pHeader;
}

/***
*int __sbh_alloc_new_group(pHeader)
*
*Purpose:
*       Initializes a GROUP structure within HEADER pointed by pHeader.
*       Commits and initializes the memory in the memory reserved by the
*       REGION.
*
*Entry:
*       pHeader - pointer to HEADER from which the GROUP is defined.
*
*Exit:
*       Returns an index to newly created GROUP, if successful.
*       Returns -1, if failure.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_alloc_new_group (PHEADER pHeader)
{
    PREGION     pRegion = pHeader->pRegion;
    PGROUP      pGroup;
    PENTRY      pEntry;
    PENTRY      pHead;
    PENTRYEND   pEntryEnd;
    BITVEC      bitvCommit;
    int         indCommit;
    int         index;
    void *      pHeapPage;
    void *      pHeapStartPage;
    void *      pHeapEndPage;

    //  determine next group to use by first bit set in commit vector
    bitvCommit = pHeader->bitvCommit;
    indCommit = 0;
    while ((int)bitvCommit >= 0)
    {
        bitvCommit <<= 1;
        indCommit++;
    }

    //  allocate and initialize a new group
    pGroup = &pRegion->grpHeadList[indCommit];

    for (index = 0; index < 63; index++)
    {
        pEntry = (PENTRY)((char *)&pGroup->listHead[index] - sizeof(int));
        pEntry->pEntryNext = pEntry->pEntryPrev = pEntry;
    }

    //  commit heap memory for new group
    pHeapStartPage = (void *)((char *)pHeader->pHeapData +
                                       indCommit * BYTES_PER_GROUP);
    if ((VirtualAlloc(pHeapStartPage, BYTES_PER_GROUP, MEM_COMMIT,
                                      PAGE_READWRITE)) == NULL)
        return -1;

    //  initialize heap data with empty page entries
    pHeapEndPage = (void *)((char *)pHeapStartPage +
                        (PAGES_PER_GROUP - 1) * BYTES_PER_PAGE);

    for (pHeapPage = pHeapStartPage; pHeapPage <= pHeapEndPage;
            pHeapPage = (void *)((char *)pHeapPage + BYTES_PER_PAGE))
    {
        //  set sentinel values at start and end of the page
        *(int *)((char *)pHeapPage + 8) = -1;
        *(int *)((char *)pHeapPage + BYTES_PER_PAGE - 4) = -1;

        //  set size and pointer info for one empty entry
        pEntry = (PENTRY)((char *)pHeapPage + ENTRY_OFFSET);
        pEntry->sizeFront = MAX_FREE_ENTRY_SIZE;
        pEntry->pEntryNext = (PENTRY)((char *)pEntry +
                                            BYTES_PER_PAGE);
        pEntry->pEntryPrev = (PENTRY)((char *)pEntry -
                                            BYTES_PER_PAGE);
        pEntryEnd = (PENTRYEND)((char *)pEntry + MAX_FREE_ENTRY_SIZE -
                                            sizeof(ENTRYEND));
        pEntryEnd->sizeBack = MAX_FREE_ENTRY_SIZE;
    }

    //  initialize group entry pointer for maximum size
    //  and set terminate list entries
    pHead = (PENTRY)((char *)&pGroup->listHead[63] - sizeof(int));
    pEntry = pHead->pEntryNext =
                        (PENTRY)((char *)pHeapStartPage + ENTRY_OFFSET);
    pEntry->pEntryPrev = pHead;

    pEntry = pHead->pEntryPrev =
                        (PENTRY)((char *)pHeapEndPage + ENTRY_OFFSET);
    pEntry->pEntryNext = pHead;

    pRegion->bitvGroupHi[indCommit] = 0x00000000L;
    pRegion->bitvGroupLo[indCommit] = 0x00000001L;
    if (pRegion->cntRegionSize[63]++ == 0)
        pHeader->bitvEntryLo |= 0x00000001L;

    //  clear bit in commit vector
    pHeader->bitvCommit &= ~(0x80000000L >> indCommit);

    return indCommit;
}

/***
*int __sbh_resize_block(pHeader, pvAlloc, intNew) - resize block
*
*Purpose:
*       Resize the specified block from the small-block heap.
*       The allocation block is not moved.
*
*Entry:
*       pHeader - pointer to HEADER containing block
*       pvAlloc - pointer to block to resize
*       intNew  - new size of block in bytes
*
*Exit:
*       Returns 1, if successful. Otherwise, 0 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_resize_block (PHEADER pHeader, void * pvAlloc, int intNew)
{
    PREGION         pRegion;
    PGROUP          pGroup;
    PENTRY          pHead;
    PENTRY          pEntry;
    PENTRY          pNext;
    int             sizeEntry;
    int             sizeNext;
    int             sizeNew;
    unsigned int    indGroup;
    unsigned int    indEntry;
    unsigned int    indNext;
    unsigned int    offRegion;

    //  add 8 bytes entry overhead and round up to next para size
    sizeNew = (intNew + 2 * (int)sizeof(int) + (BYTES_PER_PARA - 1))
              & ~(BYTES_PER_PARA - 1);

    //  region is determined by the header
    pRegion = pHeader->pRegion;

    //  use the region offset to determine the group index
    offRegion = (unsigned int)((uintptr_t)pvAlloc - (uintptr_t)pHeader->pHeapData);
    indGroup = offRegion / BYTES_PER_GROUP;
    pGroup = &pRegion->grpHeadList[indGroup];

    //  get size of entry - decrement value since entry is allocated
    pEntry = (PENTRY)((char *)pvAlloc - sizeof(int));
    sizeEntry = pEntry->sizeFront - 1;

    //  point to next entry to get its size
    pNext = (PENTRY)((char *)pEntry + sizeEntry);
    sizeNext = pNext->sizeFront;

    //  test if new size is larger than the current one
    if (sizeNew > sizeEntry)
    {
        //  if next entry not free, or not large enough, fail
        if ((sizeNext & 1) || (sizeNew > sizeEntry + sizeNext))
            return FALSE;

        //  disconnect next entry

        //  determine index of next entry
        indNext = (sizeNext >> 4) - 1;
        if (indNext > 63)
            indNext = 63;

        //  test entry is sole member of bucket (next == prev),
        if (pNext->pEntryNext == pNext->pEntryPrev)
        {
            //  clear bit in group vector, decrement region count
            //  if region count is now zero, clear bit in header
            //  entry vector
            if (indNext < 32)
            {
                pRegion->bitvGroupHi[indGroup] &= ~(0x80000000L >> indNext);
                if (--pRegion->cntRegionSize[indNext] == 0)
                    pHeader->bitvEntryHi &= ~(0x80000000L >> indNext);
            }
            else
            {
                pRegion->bitvGroupLo[indGroup] &=
                                            ~(0x80000000L >> (indNext - 32));
                if (--pRegion->cntRegionSize[indNext] == 0)
                    pHeader->bitvEntryLo &= ~(0x80000000L >> (indNext - 32));
            }
        }

        //  unlink entry from list
        pNext->pEntryPrev->pEntryNext = pNext->pEntryNext;
        pNext->pEntryNext->pEntryPrev = pNext->pEntryPrev;

        //  compute new size of the next entry, test if nonzero
        if ((sizeNext = sizeEntry + sizeNext - sizeNew) > 0)
        {
            //  compute start of next entry and connect it
            pNext = (PENTRY)((char *)pEntry + sizeNew);

            //  determine index of next entry
            indNext = (sizeNext >> 4) - 1;
            if (indNext > 63)
                indNext = 63;

            //  add next entry to the start of the bucket list
            pHead = (PENTRY)((char *)&pGroup->listHead[indNext] -
                                                           sizeof(int));
            pNext->pEntryNext = pHead->pEntryNext;
            pNext->pEntryPrev = pHead;
            pHead->pEntryNext = pNext;
            pNext->pEntryNext->pEntryPrev = pNext;

            //  test entry is sole member of bucket (next == prev),
            if (pNext->pEntryNext == pNext->pEntryPrev)
            {
                //  if region count was zero, set bit in region vector
                //  set bit in header entry vector, increment region count
                if (indNext < 32)
                {
                    if (pRegion->cntRegionSize[indNext]++ == 0)
                        pHeader->bitvEntryHi |= 0x80000000L >> indNext;
                    pRegion->bitvGroupHi[indGroup] |= 0x80000000L >> indNext;
                }
                else
                {
                    if (pRegion->cntRegionSize[indNext]++ == 0)
                        pHeader->bitvEntryLo |= 0x80000000L >> (indNext - 32);
                    pRegion->bitvGroupLo[indGroup] |=
                                                0x80000000L >> (indNext - 32);
                }
            }

            //  adjust size fields of next entry
            pNext->sizeFront = sizeNext;
            ((PENTRYEND)((char *)pNext + sizeNext -
                                sizeof(ENTRYEND)))->sizeBack = sizeNext;
        }

        //  adjust pEntry to its new size (plus one since allocated)
        pEntry->sizeFront = sizeNew + 1;
        ((PENTRYEND)((char *)pEntry + sizeNew -
                            sizeof(ENTRYEND)))->sizeBack = sizeNew + 1;
    }

    //  not larger, test if smaller
    else if (sizeNew < sizeEntry)
    {
        //  adjust pEntry to new smaller size
        pEntry->sizeFront = sizeNew + 1;
        ((PENTRYEND)((char *)pEntry + sizeNew -
                            sizeof(ENTRYEND)))->sizeBack = sizeNew + 1;

        //  set pEntry and sizeEntry to leftover space
        pEntry = (PENTRY)((char *)pEntry + sizeNew);
        sizeEntry -= sizeNew;

        //  determine index of entry
        indEntry = (sizeEntry >> 4) - 1;
        if (indEntry > 63)
            indEntry = 63;

        //  test if next entry is free
        if ((sizeNext & 1) == 0)
        {
            //  if so, disconnect it

            //  determine index of next entry
            indNext = (sizeNext >> 4) - 1;
            if (indNext > 63)
                indNext = 63;

            //  test entry is sole member of bucket (next == prev),
            if (pNext->pEntryNext == pNext->pEntryPrev)
            {
                //  clear bit in group vector, decrement region count
                //  if region count is now zero, clear bit in header
                //  entry vector
                if (indNext < 32)
                {
                    pRegion->bitvGroupHi[indGroup] &=
                                                ~(0x80000000L >> indNext);
                    if (--pRegion->cntRegionSize[indNext] == 0)
                        pHeader->bitvEntryHi &= ~(0x80000000L >> indNext);
                }
                else
                {
                    pRegion->bitvGroupLo[indGroup] &=
                                            ~(0x80000000L >> (indNext - 32));
                    if (--pRegion->cntRegionSize[indNext] == 0)
                        pHeader->bitvEntryLo &=
                                            ~(0x80000000L >> (indNext - 32));
                }
            }

            //  unlink entry from list
            pNext->pEntryPrev->pEntryNext = pNext->pEntryNext;
            pNext->pEntryNext->pEntryPrev = pNext->pEntryPrev;

            //  add next entry size to present
            sizeEntry += sizeNext;
            indEntry = (sizeEntry >> 4) - 1;
            if (indEntry > 63)
                indEntry = 63;
        }

        //  connect leftover space with any free next entry

        //  add next entry to the start of the bucket list
        pHead = (PENTRY)((char *)&pGroup->listHead[indEntry] - sizeof(int));
        pEntry->pEntryNext = pHead->pEntryNext;
        pEntry->pEntryPrev = pHead;
        pHead->pEntryNext = pEntry;
        pEntry->pEntryNext->pEntryPrev = pEntry;

        //  test entry is sole member of bucket (next == prev),
        if (pEntry->pEntryNext == pEntry->pEntryPrev)
        {
            //  if region count was zero, set bit in region vector
            //  set bit in header entry vector, increment region count
            if (indEntry < 32)
            {
                if (pRegion->cntRegionSize[indEntry]++ == 0)
                    pHeader->bitvEntryHi |= 0x80000000L >> indEntry;
                pRegion->bitvGroupHi[indGroup] |= 0x80000000L >> indEntry;
            }
            else
            {
                if (pRegion->cntRegionSize[indEntry]++ == 0)
                    pHeader->bitvEntryLo |= 0x80000000L >> (indEntry - 32);
                pRegion->bitvGroupLo[indGroup] |= 0x80000000L >>
                                                           (indEntry - 32);
            }
        }

        //  adjust size fields of entry
        pEntry->sizeFront = sizeEntry;
        ((PENTRYEND)((char *)pEntry + sizeEntry -
                            sizeof(ENTRYEND)))->sizeBack = sizeEntry;
    }

    return TRUE;
}

/***
*int __sbh_heapmin() - minimize heap
*
*Purpose:
*       Minimize the heap by freeing any deferred group.
*
*Entry:
*       __sbh_pHeaderDefer  - pointer to HEADER of deferred group
*       __sbh_indGroupDefer - index of GROUP to defer
*
*Exit:
*       None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __sbh_heapmin (void)
{
    void *      pHeapDecommit;

    //  if a group has been deferred, free that group
    if (__sbh_pHeaderDefer)
    {
        //  if now zero, decommit the group data heap
        pHeapDecommit = (void *)((char *)__sbh_pHeaderDefer->pHeapData +
                                    __sbh_indGroupDefer * BYTES_PER_GROUP);
        VirtualFree(pHeapDecommit, BYTES_PER_GROUP, MEM_DECOMMIT);

        //  set bit in commit vector
        __sbh_pHeaderDefer->bitvCommit |= 0x80000000 >> __sbh_indGroupDefer;

        //  clear entry vector for the group and header vector bit
        //  if needed
        __sbh_pHeaderDefer->pRegion->bitvGroupLo[__sbh_indGroupDefer] = 0;
        if (--__sbh_pHeaderDefer->pRegion->cntRegionSize[63] == 0)
            __sbh_pHeaderDefer->bitvEntryLo &= ~0x00000001L;

        //  if commit vector is the initial value,
        //  remove the region if it is not the last
        if (__sbh_pHeaderDefer->bitvCommit == BITV_COMMIT_INIT &&
                                                __sbh_cntHeaderList > 1)
        {
            //  free the region memory area
            HeapFree(_crtheap, 0, __sbh_pHeaderDefer->pRegion);

            //  remove entry from header list by copying over
            memmove((void *)__sbh_pHeaderDefer, (void *)(__sbh_pHeaderDefer + 1),
                            (int)((intptr_t)(__sbh_pHeaderList + __sbh_cntHeaderList) -
                            (intptr_t)(__sbh_pHeaderDefer + 1)));
            __sbh_cntHeaderList--;
        }

        //  clear deferred condition
        __sbh_pHeaderDefer = NULL;
    }
}

/***
*int __sbh_heap_check() - check small-block heap
*
*Purpose:
*       Perform validity checks on the small-block heap.
*
*Entry:
*       There are no arguments.
*
*Exit:
*       Returns 0 if the small-block is okay.
*       Returns < 0 if the small-block heap has an error. The exact value
*       identifies where, in the source code below, the error was detected.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __sbh_heap_check (void)
{
    PHEADER     pHeader;
    PREGION     pRegion;
    PGROUP      pGroup;
    PENTRY      pEntry;
    PENTRY      pNext;
    PENTRY      pEntryLast;
    PENTRY      pEntryHead;
    PENTRY      pEntryPage;
    PENTRY      pEntryPageLast;
    int         indHeader;
    int         indGroup;
    int         indPage;
    int         indEntry;
    int         indHead;
    int         sizeEntry;
    int         sizeTrue;
    int         cntAllocated;
    int         cntFree[64];
    int         cntEntries;
    void *      pHeapGroup;
    void *      pHeapPage;
    void *      pPageStart;
    BITVEC      bitvCommit;
    BITVEC      bitvGroupHi;
    BITVEC      bitvGroupLo;
    BITVEC      bitvEntryHi;
    BITVEC      bitvEntryLo;

    //  check validity of header list
    if (__sbh_pHeaderList == NULL)
    {
        return -1;
    }

    //  scan for all headers in list
    pHeader = __sbh_pHeaderList;
    for (indHeader = 0; indHeader < __sbh_cntHeaderList; indHeader++)
    {
        //  define region and test if valid
        pRegion = pHeader->pRegion;
        if (pRegion == NULL)
            return -2;

        //  scan for all groups in region
        pHeapGroup = pHeader->pHeapData;
        pGroup = &pRegion->grpHeadList[0];
        bitvCommit = pHeader->bitvCommit;
        bitvEntryHi = 0;
        bitvEntryLo = 0;
        for (indGroup = 0; indGroup < GROUPS_PER_REGION; indGroup++)
        {
            //  initialize entry vector and entry counts for group
            bitvGroupHi = 0;
            bitvGroupLo = 0;
            cntAllocated = 0;
            for (indEntry = 0; indEntry < 64; indEntry++)
                cntFree[indEntry] = 0;

            //  test if group is committed
            if ((int)bitvCommit >= 0)
            {
                //  committed, ensure addresses are accessable
                if (pHeapGroup == NULL)
                    return -4;

                //  for each page in group, check validity of entries
                pHeapPage = pHeapGroup;
                for (indPage = 0; indPage < PAGES_PER_GROUP; indPage++)
                {
                    //  define pointers to first and past last entry
                    pEntry = (PENTRY)((char *)pHeapPage + ENTRY_OFFSET);
                    pEntryLast = (PENTRY)((char *)pEntry
                                                 + MAX_FREE_ENTRY_SIZE);

                    //  check front and back page sentinel values
                    if (*(int *)((char *)pEntry - sizeof(int)) != -1 ||
                                 *(int *)pEntryLast != -1)
                        return -5;

                    //  loop through each entry in page
                    do
                    {
                        //  get entry size and test if allocated
                        sizeEntry = sizeTrue = pEntry->sizeFront;
                        if (sizeEntry & 1)
                        {
                            //  allocated entry - set true size
                            sizeTrue--;

                            //  test against maximum allocated entry size
                            if (sizeTrue > MAX_ALLOC_ENTRY_SIZE)
                                return -6;

                            //  increment allocated count for group
                            cntAllocated++;
                        }
                        else
                        {
                            //  free entry - determine index and increment
                            //  count for list head checking
                            indEntry = (sizeTrue >> 4) - 1;
                            if (indEntry > 63)
                                indEntry = 63;
                            cntFree[indEntry]++;
                        }

                        //  check size validity
                        if (sizeTrue < 0x10 || sizeTrue & 0xf
                                        || sizeTrue > MAX_FREE_ENTRY_SIZE)
                            return -7;

                        //  check if back entry size same as front
                        if (((PENTRYEND)((char *)pEntry + sizeTrue
                                    - sizeof(int)))->sizeBack != sizeEntry)
                            return -8;

                        //  move to next entry in page
                        pEntry = (PENTRY)((char *)pEntry + sizeTrue);
                    }
                    while (pEntry < pEntryLast);

                    //  test if last entry did not overrun page end
                    if (pEntry != pEntryLast)
                        return -8;

                    //  point to next page in data heap
                    pHeapPage = (void *)((char *)pHeapPage + BYTES_PER_PAGE);
                }

                //  check if allocated entry count is correct
                if (pGroup->cntEntries != cntAllocated)
                    return -9;

                //  check validity of linked-lists of free entries
                pEntryHead = (PENTRY)((char *)&pGroup->listHead[0] -
                                                           sizeof(int));
                for (indHead = 0; indHead < 64; indHead++)
                {
                    //  scan through list until head is reached or expected
                    //  number of entries traversed
                    cntEntries = 0;
                    pEntry = pEntryHead;
                    while ((pNext = pEntry->pEntryNext) != pEntryHead &&
                                        cntEntries != cntFree[indHead])
                    {
                        //  test if next pointer is in group data area
                        if ((void *)pNext < pHeapGroup || (void *)pNext >=
                            (void *)((char *)pHeapGroup + BYTES_PER_GROUP))
                            return -10;

                        //  determine page address of next entry
                        pPageStart = (void *)((uintptr_t)pNext &
                                        ~(uintptr_t)(BYTES_PER_PAGE - 1));

                        //  point to first entry and past last in the page
                        pEntryPage = (PENTRY)((char *)pPageStart +
                                                        ENTRY_OFFSET);
                        pEntryPageLast = (PENTRY)((char *)pEntryPage +
                                                        MAX_FREE_ENTRY_SIZE);

                        //  do scan from start of page
                        //  no error checking since it was already scanned
                        while (pEntryPage != pEntryPageLast)
                        {
                            //  if entry matches, exit loop
                            if (pEntryPage == pNext)
                                break;

                            //  point to next entry
                            pEntryPage = (PENTRY)((char *)pEntryPage +
                                            (pEntryPage->sizeFront & ~1));
                        }

                        //  if page end reached, pNext was not valid
                        if (pEntryPage == pEntryPageLast)
                            return -11;

                        //  entry valid, but check if entry index matches
                        //  the header
                        indEntry = (pNext->sizeFront >> 4) - 1;
                        if (indEntry > 63)
                            indEntry = 63;
                        if (indEntry != indHead)
                            return -12;

                        //  check if previous pointer in pNext points
                        //  back to pEntry
                        if (pNext->pEntryPrev != pEntry)
                            return -13;

                        //  update scan pointer and counter
                        pEntry = pNext;
                        cntEntries++;
                    }

                    //  if nonzero number of entries, set bit in group
                    //  and region vectors
                    if (cntEntries)
                    {
                        if (indHead < 32)
                        {
                            bitvGroupHi |= 0x80000000L >> indHead;
                            bitvEntryHi |= 0x80000000L >> indHead;
                        }
                        else
                        {
                            bitvGroupLo |= 0x80000000L >> (indHead - 32);
                            bitvEntryLo |= 0x80000000L >> (indHead - 32);
                        }
                    }

                    //  check if list is exactly the expected size
                    if (pEntry->pEntryNext != pEntryHead ||
                                        cntEntries != cntFree[indHead])
                        return -14;

                    //  check if previous pointer in header points to
                    //  last entry processed
                    if (pEntryHead->pEntryPrev != pEntry)
                        return -15;

                    //  point to next linked-list header - note size
                    pEntryHead = (PENTRY)((char *)pEntryHead +
                                                      sizeof(LISTHEAD));
                }
            }

            //  test if group vector is valid
            if (bitvGroupHi != pRegion->bitvGroupHi[indGroup] ||
                bitvGroupLo != pRegion->bitvGroupLo[indGroup])
                return -16;

            //  adjust for next group in region
            pHeapGroup = (void *)((char *)pHeapGroup + BYTES_PER_GROUP);
            pGroup++;
            bitvCommit <<= 1;
        }

        //  test if group vector is valid
        if (bitvEntryHi != pHeader->bitvEntryHi ||
            bitvEntryLo != pHeader->bitvEntryLo)
            return -17;

        //  adjust for next header in list
        pHeader++;
    }
    return 0;
}



#ifdef CRTDLL

/* Old (VC++ 5.0) small-block heap data and code */

__old_sbh_region_t __old_small_block_heap = {
        &__old_small_block_heap,                        /* p_next_region */
        &__old_small_block_heap,                        /* p_prev_region */
        &__old_small_block_heap.region_map[0],          /* p_starting_region_map */
        &__old_small_block_heap.region_map[0],          /* p_first_uncommitted */
        (__old_sbh_page_t *)_OLD_NO_PAGES,              /* p_pages_begin */
        (__old_sbh_page_t *)_OLD_NO_PAGES,              /* p_pages_end */
        { _OLD_PARAS_PER_PAGE, _OLD_NO_FAILED_ALLOC }   /* region_map[] */
};

static __old_sbh_region_t *__old_sbh_p_starting_region = &__old_small_block_heap;

static int __old_sbh_decommitable_pages = 0;

size_t __old_sbh_threshold = _OLD_PARASIZE * (_OLD_PARAS_PER_PAGE / 8);

/* Prototypes for user functions */

size_t __cdecl _get_old_sbh_threshold(void);
int    __cdecl _set_old_sbh_threshold(size_t);


/***
*size_t _get_old_sbh_threshold() - return small-block threshold
*
*Purpose:
*       Return the current value of __old_sbh_threshold
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _get_old_sbh_threshold (
        void
        )
{
    _VALIDATE_RETURN(_crtheap, EINVAL, 0);

    return __old_sbh_threshold;
}


/***
*int _set_old_sbh_threshold(size_t threshold) - set small-block heap threshold
*
*Purpose:
*       Set the upper limit for the size of an allocation which will be
*       supported from the small-block heap. It is required that at least two
*       allocations can come from a page. This imposes an upper limit on how
*       big the new threshold can  be.
*
*Entry:
*       size_t  threshold   - proposed new value for __sbh_theshold
*
*Exit:
*       Returns 1 if successful. Returns 0 if threshold was too big.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _set_old_sbh_threshold (
        size_t threshold
        )
{
        _VALIDATE_RETURN(_crtheap!=NULL, EINVAL, 0);

        /*
         * Round up the proposed new value to the nearest paragraph
         */
        threshold = (threshold + _OLD_PARASIZE - 1) & ~(_OLD_PARASIZE - 1);

        /*
         * Require that at least two allocations be can be made within a
         * page.
         */
        if ( threshold <= (_OLD_PARASIZE * (_OLD_PARAS_PER_PAGE / 2)) )
        {
            __old_sbh_threshold = threshold;
            return 1;
        }
        else
        {
            _VALIDATE_RETURN(FALSE, EINVAL, 0);
            return 0;
        }
}


/***
*__old_sbh_region_t * __old_sbh_new_region() - get a region for the small-block heap
*
*Purpose:
*       Creates and adds a new region for the small-block heap. First, a
*       descriptor (__old_sbh_region_t) is obtained for the new region. Next,
*       VirtualAlloc() is used to reserved an address space of size
*       _OLD_PAGES_PER_REGION * _OLD_PAGESIZE, and the first _PAGES_PER_COMMITTMENT
*       pages are committed.
*
*       Note that if __old_small_block_heap is available (i.e., the p_pages_begin
*       field is _OLD_NO_PAGES), it becomes the descriptor for the new regions. This is
*       basically the small-block heap initialization.
*
*Entry:
*       No arguments.
*
*Exit:
*       If successful, a pointer to the descriptor for the new region is
*       returned. Otherwise, NULL is returned.
*
*******************************************************************************/

__old_sbh_region_t * __cdecl __old_sbh_new_region(
        void
        )
{
        __old_sbh_region_t * pregnew;
        __old_sbh_page_t *   ppage;
        int                  i;

        /*
         * Get a region descriptor (__old_sbh_region_t). If __old_small_block_heap is
         * available, always use it.
         */
        if ( __old_small_block_heap.p_pages_begin == _OLD_NO_PAGES ) {
            pregnew = &__old_small_block_heap;
        }
        else {
            /*
             * Allocate space for the new __old_sbh_region_t structure. Note that
             * this allocation comes out of the 'big block heap.
             */
            if ( (pregnew = HeapAlloc( _crtheap, 0, sizeof(__old_sbh_region_t) ))
                 == NULL )
                return NULL;
        }

        /*
         * Reserve a new contiguous address range (i.e., a region).
         */
        if ( (ppage = VirtualAlloc( NULL,
                                    _OLD_PAGESIZE * _OLD_PAGES_PER_REGION,
                                    MEM_RESERVE,
                                    PAGE_READWRITE )) != NULL )
        {
            /*
             * Commit the first _OLD_PAGES_PER_COMMITMENT of the new region.
             */
            if ( VirtualAlloc( ppage,
                               _OLD_PAGESIZE * _OLD_PAGES_PER_COMMITMENT,
                               MEM_COMMIT,
                               PAGE_READWRITE ) != NULL )
            {
                /*
                 * Insert *pregnew into the linked list of regions (just
                 * before __old_small_block_heap)
                 */
                if ( pregnew == &__old_small_block_heap ) {
                    if ( __old_small_block_heap.p_next_region == NULL )
                        __old_small_block_heap.p_next_region =
                            &__old_small_block_heap;
                    if ( __old_small_block_heap.p_prev_region == NULL )
                        __old_small_block_heap.p_prev_region =
                            &__old_small_block_heap;
                }
                else {
                    pregnew->p_next_region = &__old_small_block_heap;
                    pregnew->p_prev_region = __old_small_block_heap.p_prev_region;
                    __old_small_block_heap.p_prev_region = pregnew;
                    pregnew->p_prev_region->p_next_region = pregnew;
                }

                /*
                 * Fill in the rest of *pregnew
                 */
                pregnew->p_pages_begin = ppage;
                pregnew->p_pages_end = ppage + _OLD_PAGES_PER_REGION;
                pregnew->p_starting_region_map = &(pregnew->region_map[0]);
                pregnew->p_first_uncommitted =
                    &(pregnew->region_map[_OLD_PAGES_PER_COMMITMENT]);

                /*
                 * Initialize pregnew->region_map[].
                 */
                for ( i = 0 ; i < _OLD_PAGES_PER_REGION ; i++ ) {

                    if ( i < _OLD_PAGES_PER_COMMITMENT )
                        pregnew->region_map[i].free_paras_in_page =
                            _OLD_PARAS_PER_PAGE;
                    else
                        pregnew->region_map[i].free_paras_in_page =
                            _OLD_UNCOMMITTED_PAGE;

                    pregnew->region_map[i].last_failed_alloc =
                        _OLD_NO_FAILED_ALLOC;
                }

                /*
                 * Initialize pages
                 */
                memset( ppage, 0, _OLD_PAGESIZE * _OLD_PAGES_PER_COMMITMENT );
                while ( ppage < pregnew->p_pages_begin +
                        _OLD_PAGES_PER_COMMITMENT )
                {
                    ppage->p_starting_alloc_map = &(ppage->alloc_map[0]);
                    ppage->free_paras_at_start = _OLD_PARAS_PER_PAGE;
                    (ppage++)->alloc_map[_OLD_PARAS_PER_PAGE] = (__old_page_map_t)-1;
                }

                /*
                 * Return success
                 */
                return pregnew;
            }
            else {
                /*
                 * Couldn't commit the pages. Release the address space .
                 */
                VirtualFree( ppage, 0, MEM_RELEASE );
            }
        }

        /*
         * Unable to create the new region. Free the region descriptor, if necessary.
         */
        if ( pregnew != &__old_small_block_heap )
            HeapFree(_crtheap, 0, pregnew);

        /*
         * Return failure.
         */
        return NULL;
}


/***
*void __old_sbh_release_region(preg) - release region
*
*Purpose:
*       Release the address space associated with the specified region
*       descriptor. Also, free the specified region descriptor and update
*       the linked list of region descriptors if appropriate.
*
*Entry:
*       __old_sbh_region_t *    preg    - pointer to descriptor for the region to
*                                     be released.
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __old_sbh_release_region(
        __old_sbh_region_t * preg
        )
{
        /*
         * Release the passed region
         */
        VirtualFree( preg->p_pages_begin, 0, MEM_RELEASE);

        /*
         * Update __old_sbh_p_starting_region, if necessary
         */
        if ( __old_sbh_p_starting_region == preg )
            __old_sbh_p_starting_region = preg->p_prev_region;

        if ( preg != &__old_small_block_heap ) {
            /*
             * Update linked list of region descriptors.
             */
            preg->p_prev_region->p_next_region = preg->p_next_region;
            preg->p_next_region->p_prev_region = preg->p_prev_region;

            /*
             * Free the region desciptor
             */
            HeapFree(_crtheap, 0, preg);
        }
        else {
            /*
             * Mark p_pages_begin as _OLD_NO_PAGES to indicate __old_small_block_heap
             * is not associated with any region (and can be reused). This the
             * only region descriptor for which this is supported.
             */
            __old_small_block_heap.p_pages_begin = _OLD_NO_PAGES;
        }
}


/***
*void __old_sbh_decommit_pages(count) - decommit specified number of pages
*
*Purpose:
*       Decommit count pages, if possible, in reverse (i.e., last to
*       first) order. If this results in all the pages in any region being
*       uncommitted, the region is released.
*
*Entry:
*       int count   -  number of pages to decommit
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __old_sbh_decommit_pages(
        int count
        )
{
        __old_sbh_region_t * preg1;
        __old_sbh_region_t * preg2;
        __old_region_map_t * pregmap;
        int                  page_decommitted_flag;
        int                  i;

        /*
         * Scan the regions of the small-block heap, in reverse order. looking
         * for pages which can be decommitted.
         */
        preg1 = __old_small_block_heap.p_prev_region;
        do {
            if ( preg1->p_pages_begin != _OLD_NO_PAGES ) {
                /*
                 * Scan the pages in *preg1, in reverse order, looking for
                 * pages which can be decommitted.
                 */
                for ( i = _OLD_PAGES_PER_REGION - 1, page_decommitted_flag = 0,
                        pregmap = &(preg1->region_map[i]) ;
                      i >= 0 ; i--, pregmap-- )
                {
                    /*
                     * Check if the pool page is unused and, if so, decommit it.
                     */
                    if ( pregmap->free_paras_in_page == _OLD_PARAS_PER_PAGE ) {
                        if ( VirtualFree((preg1->p_pages_begin) + i, _OLD_PAGESIZE,
                                         MEM_DECOMMIT) )
                        {
                            /*
                             * Mark the page as uncommitted, update the count
                             * (global) decommitable pages, update the
                             * first_uncommitted_index field of the region
                             * descriptor, set the flag indicating at least
                             * one page has been decommitted in the region,
                             * and decrement count.
                             */
                            pregmap->free_paras_in_page = _OLD_UNCOMMITTED_PAGE;

                            __old_sbh_decommitable_pages--;

                            if ( (preg1->p_first_uncommitted == NULL)
                                 || (preg1->p_first_uncommitted > pregmap) )
                                preg1->p_first_uncommitted = pregmap;

                            page_decommitted_flag++;
                            if ( --count == 0 )
                                break;
                        }
                    }
                }

                /*
                 * 'Decrement' the preg1 pointer, but save a copy in preg2 in
                 * case the region needs to be released.
                 */
                preg2 = preg1;
                preg1 = preg1->p_prev_region;

                /*
                 * If appropriate, determine if all the pages in the region
                 * are uncommitted so that the region can be released.
                 */
                if ( page_decommitted_flag &&
                    (preg2->region_map[0].free_paras_in_page ==
                    _OLD_UNCOMMITTED_PAGE) )
                {

                    for ( i = 1, pregmap = &(preg2->region_map[1]) ;
                          (i < _OLD_PAGES_PER_REGION) &&
                            (pregmap->free_paras_in_page ==
                            _OLD_UNCOMMITTED_PAGE) ;
                          i++, pregmap++ );

                    if ( i == _OLD_PAGES_PER_REGION )
                        __old_sbh_release_region(preg2);
                }
            }
        }
        while ( (preg1 != __old_small_block_heap.p_prev_region) && (count > 0) );
}


/***
*__old_page_map_t *__old_sbh_find_block(pblck, ppreg, pppage) - find block in
*       small-block heap
*
*Purpose:
*       Determine if the specified allocation block lies in the small-block
*       heap and, if so, return the region, page and starting paragraph index
*       of the block.
*
*Entry:
*       void *                  pblck   - pointer to block to be freed
*       __old_sbh_region_t **   ppreg   - pointer to a pointer to the region
*                                         holding *pblck, if found
*       __old_sbh_page_t **     pppage  - pointer to a pointer to the page holding
*                                         *pblck, if found
*
*Exit:
*       If successful, a pointer to the starting alloc_map[] entry for the
*       allocation block is returned.
*       If unsuccessful, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

__old_page_map_t * __cdecl __old_sbh_find_block (
        void *                pblck,
        __old_sbh_region_t ** ppreg,
        __old_sbh_page_t **   pppage
        )
{
        __old_sbh_region_t *  preg;
        __old_sbh_page_t *    ppage;
        if(ppreg)
        {
            *ppreg=NULL;
        }
        if(pppage)
        {
            *pppage=NULL;
        }

        preg = &__old_small_block_heap;
        do
        {
            /*
             * Does the block lie within this small heap region?
             */
            if ( (pblck > (void *)preg->p_pages_begin) &&
                 (pblck < (void *)preg->p_pages_end) )
            {
                /*
                 * pblck lies within the region! Carry out a couple of
                 * important validity checks.
                 */
                if ( (((uintptr_t)pblck & (_OLD_PARASIZE - 1)) == 0) &&
                     (((uintptr_t)pblck & (_OLD_PAGESIZE - 1)) >=
                        offsetof(struct __old_sbh_page_struct, alloc_blocks[0])) )
                {
                    /*
                     * Copy region and page pointers back through the passed
                     * pointers.
                     */
                    *ppreg = preg;
                    *pppage = ppage = (__old_sbh_page_t *)((uintptr_t)pblck &
                                      ~(_OLD_PAGESIZE - 1));

                    /*
                     * Return pointer to the alloc_map[] entry of the block.
                     */
                    return ( &(ppage->alloc_map[0]) + ((__old_para_t *)pblck -
                                &(ppage->alloc_blocks[0])) );
                }

                return NULL;
            }
        }
        while ( (preg = preg->p_next_region) != &__old_small_block_heap );

        return NULL;
}


/***
*void __old_sbh_free_block(preg, ppage, pmap) - free block
*
*Purpose:
*       Free the specified block from the small-block heap.
*
*Entry:
*       __old_sbh_region_t *preg    - pointer to the descriptor for the
*                                     region containing the block
*       __old_sbh_page_t *  ppage   - pointer to the page containing the
*                                     block
*       __old_page_map_t *   pmap   - pointer to the initial alloc_map[]
*                                     entry for the allocation block
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __old_sbh_free_block (
        __old_sbh_region_t * preg,
        __old_sbh_page_t *   ppage,
        __old_page_map_t *   pmap
        )
{
        __old_region_map_t * pregmap;

        pregmap = &(preg->region_map[0]) + (ppage - preg->p_pages_begin);

        /*
         * Update the region_map[] entry.
         */
        pregmap->free_paras_in_page += (int)*pmap;

        /*
         * Mark the alloc_map[] entry as free
         */
        *pmap = _OLD_FREE_PARA;

        /*
         * Clear the last_failed_alloc[] entry for the page.
         */
        pregmap->last_failed_alloc = _OLD_NO_FAILED_ALLOC;

        /*
         * Check if the count of decommitable pages needs to be updated, and
         * if some pages need to be decommited.
         */
        if ( pregmap->free_paras_in_page == _OLD_PARAS_PER_PAGE )
            if ( ++__old_sbh_decommitable_pages == (2 * _OLD_PAGES_PER_COMMITMENT) )
                __old_sbh_decommit_pages(_OLD_PAGES_PER_COMMITMENT);
}


/***
*void * __old_sbh_alloc_block(para_req) - allocate a block
*
*Purpose:
*       Allocate a block from the small-block heap, the specified number of
*       paragraphs in size.
*
*Entry:
*       size_t  para_req    - size of the allocation request in paragraphs.
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, if failure.
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl __old_sbh_alloc_block (
        size_t               para_req
        )
{
        __old_sbh_region_t * preg;
        __old_sbh_page_t *   ppage;
        __old_sbh_page_t *   ppage2;
        __old_region_map_t * pregmap;
        __old_region_map_t * pregmap2;
        void *               retp;
        int                  i, j;

        /*
         * First pass through the small-block heap. Try to satisfy the current
         * request from already committed pages.
         */
        preg = __old_sbh_p_starting_region;

        do {
            if ( preg->p_pages_begin != _OLD_NO_PAGES ) {
                /*
                 * Search from *p_starting_region_map to the end of the
                 * region_map[] array.
                 */
                for ( pregmap = preg->p_starting_region_map,
                        pregmap2 = &(preg->region_map[_OLD_PAGES_PER_REGION]),
                        ppage = preg->p_pages_begin +
                                (int)(pregmap - &(preg->region_map[0])) ;
                      pregmap < pregmap2 ;
                      pregmap++, ppage++ )
                {
                    /*
                     * If the page has at least para_req free paragraphs, try
                     * to satisfy the request in this page.
                     */
                    if ( (pregmap->free_paras_in_page >= (int)para_req) &&
                         (pregmap->last_failed_alloc > para_req) )
                    {
                        if ( (retp = __old_sbh_alloc_block_from_page(
                                        ppage,
                                        pregmap->free_paras_in_page,
                                        para_req)) != NULL )
                        {
                            /*
                             * Success.
                             *  Update __old_sbh_p_starting_region.
                             *  Update free_paras_in_page field for the page.
                             *  Update the p_starting_region_map field in the
                             *  region.
                             *  Return a pointer to the allocated block.
                             */
                            __old_sbh_p_starting_region = preg;
                            pregmap->free_paras_in_page -= (int)para_req;
                            preg->p_starting_region_map = pregmap;
                            return retp;
                        }
                        else {
                            /*
                             * Update last_failed_alloc field.
                             */
                            pregmap->last_failed_alloc = para_req;
                        }
                    }
                }

                /*
                 * If necessary, search from 0 page to search_start_index.
                 */
                for ( pregmap = &(preg->region_map[0]),
                        pregmap2 = preg->p_starting_region_map,
                        ppage = preg->p_pages_begin ;
                      pregmap < pregmap2 ;
                      pregmap++, ppage++ )
                {
                    /*
                     * If the page has at least para_req free paragraphs, try
                     * to satisfy the request in this page.
                     */
                    if ( (pregmap->free_paras_in_page >= (int)para_req) &&
                         (pregmap->last_failed_alloc > para_req) )
                    {
                        if ( (retp = __old_sbh_alloc_block_from_page(
                                        ppage,
                                        pregmap->free_paras_in_page,
                                        para_req)) != NULL )
                        {
                            /*
                             * Success.
                             *  Update __old_sbh_p_starting_region.
                             *  Update free_paras_in_page field for the page.
                             *  Update the p_starting_region_map field in the
                             *  region.
                             *  Return a pointer to the allocated block.
                             */
                            __old_sbh_p_starting_region = preg;
                            pregmap->free_paras_in_page -= (int)para_req;
                            preg->p_starting_region_map = pregmap;
                            return retp;
                        }
                        else {
                            /*
                             * Update last_failed_alloc field.
                             */
                            pregmap->last_failed_alloc = para_req;
                        }
                    }
                }
            }
        }
        while ( (preg = preg->p_next_region) != __old_sbh_p_starting_region );

        /*
         * Second pass through the small-block heap. This time, look for an
         * uncommitted page. Also, start at __old_small_block_heap rather than at
         * *__old_sbh_p_starting_region.
         */
        preg = &__old_small_block_heap;

        do
        {
            if ( (preg->p_pages_begin != _OLD_NO_PAGES) &&
                 (preg->p_first_uncommitted != NULL) )
            {
                pregmap = preg->p_first_uncommitted;

                ppage = preg->p_pages_begin +
                        (pregmap - &(preg->region_map[0]));

                /*
                 * Determine how many adjacent pages, up to
                 * _OLD_PAGES_PER_COMMITMENT, are uncommitted (and can now be
                 * committed)
                 */
                for ( i = 0, pregmap2 = pregmap ;
                      (pregmap2->free_paras_in_page == _OLD_UNCOMMITTED_PAGE) &&
                        (i < _OLD_PAGES_PER_COMMITMENT) ;
                      pregmap2++, i++ ) ;

                /*
                 * Commit the pages.
                 */
                if ( VirtualAlloc( (void *)ppage,
                                   i * _OLD_PAGESIZE,
                                   MEM_COMMIT,
                                   PAGE_READWRITE ) == ppage )
                {
                    /*
                     * Initialize the committed pages.
                     */
                    memset(ppage, 0, i * _OLD_PAGESIZE);

                    for ( j = 0, ppage2 = ppage, pregmap2 = pregmap ;
                          j < i ;
                          j++, ppage2++, pregmap2++ )
                    {
                        /*
                         * Initialize fields in the page header
                         */
                        ppage2->p_starting_alloc_map = &(ppage2->alloc_map[0]);
                        ppage2->free_paras_at_start = _OLD_PARAS_PER_PAGE;
                        ppage2->alloc_map[_OLD_PARAS_PER_PAGE] = (__old_page_map_t)(-1);

                        /*
                         * Initialize region_map[] entry for the page.
                         */
                        pregmap2->free_paras_in_page = _OLD_PARAS_PER_PAGE;
                        pregmap2->last_failed_alloc = _OLD_NO_FAILED_ALLOC;
                    }

                    /*
                     * Update __old_sbh_p_starting_region
                     */
                    __old_sbh_p_starting_region = preg;

                    /*
                     * Update the p_first_uncommitted for the region.
                     */
                    while ( (pregmap2 < &(preg->region_map[_OLD_PAGES_PER_REGION]))
                            && (pregmap2->free_paras_in_page
                                != _OLD_UNCOMMITTED_PAGE) )
                        pregmap2++;

                    preg->p_first_uncommitted = (pregmap2 <
                        &(preg->region_map[_OLD_PAGES_PER_REGION])) ? pregmap2 :
                        NULL;

                    /*
                     * Fulfill the allocation request using the first of the
                     * newly committed pages.
                     */
                    ppage->alloc_map[0] = (__old_page_map_t)para_req;

                    /*
                     * Update the p_starting_region_map field in the region
                     * descriptor and region_map[] entry for the page.
                     */
                    preg->p_starting_region_map = pregmap;
                    pregmap->free_paras_in_page -= (int)para_req;

                    /*
                     * Update the p_starting_alloc_map and free_paras_at_start
                     * fields of the page.
                     */
                    ppage->p_starting_alloc_map = &(ppage->alloc_map[para_req]);
                    ppage->free_paras_at_start -= para_req;

                    /*
                     * Return pointer to allocated paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[0]);
                }
                else {
                    /*
                     * Attempt to commit the pages failed. Return failure, the
                     * allocation will be attempted in the Win32 heap manager.
                     */
                    return NULL;
                }
            }
        }
        while ( (preg = preg->p_next_region) != &__old_small_block_heap );

        /*
         * Failure so far. None of the pages have a big enough free area to
         * fulfill the pending request. All of the pages in all of the current
         * regions are committed. Therefore, try to create a new region.
         */
        if ( (preg = __old_sbh_new_region()) != NULL ) {
            /*
             * Success! A new region has been created and the first few pages
             * (_OLD_PAGES_PER_COMMITMENT to be exact) have been committed.
             * satisfy the request out of the first page of the new region.
             */
            ppage = preg->p_pages_begin;
            ppage->alloc_map[0] = (__old_page_map_t)para_req;

            __old_sbh_p_starting_region = preg;
            ppage->p_starting_alloc_map = &(ppage->alloc_map[para_req]);
            ppage->free_paras_at_start = _OLD_PARAS_PER_PAGE - para_req;
            (preg->region_map[0]).free_paras_in_page -= (__old_page_map_t)para_req;
            return (void *)&(ppage->alloc_blocks[0]);
        }

        /*
         * Everything has failed, return NULL
         */
        return NULL;
}


/***
*void * __old_sbh_alloc_block_from_page(ppage, free_para_count, para_req) -
*       allocate a block from the given page.
*
*Purpose:
*       Allocate a block from the specified page of the small-block heap, of
*       the specified number of paragraphs in size.
*
*Entry:
*       __old_sbh_page_t *  ppage       - pointer to a page in the small-block
*                                         heap
*       int             free_para_count - number of free paragraphs in *ppage
*       size_t          para_req        - size of the allocation request in
*                                         paragraphs.
*
*Exit:
*       Returns a pointer to the newly allocated block, if successful.
*       Returns NULL, otherwise.
*
*Exceptions:
*       It is assumed that free_para_count >= para_req on entry. This must be
*       guaranteed by the caller. The behavior is undefined if this condition
*       is violated.
*
*******************************************************************************/

void * __cdecl __old_sbh_alloc_block_from_page (
        __old_sbh_page_t * ppage,
        size_t             free_para_count,
        size_t             para_req
        )
{
        __old_page_map_t * pmap1;
        __old_page_map_t * pmap2;
        __old_page_map_t * pstartmap;
        __old_page_map_t * pendmap;
        size_t             contiguous_free;

        pmap1 = pstartmap = ppage->p_starting_alloc_map;
        pendmap = &(ppage->alloc_map[_OLD_PARAS_PER_PAGE]);

        /*
         * Start at start_para_index and walk towards the end of alloc_map[],
         * looking for a string of free paragraphs big enough to satisfy the
         * the current request.
         *
         * Check if there are enough free paragraphs are p_starting_alloc_map
         * to satisfy the pending allocation request.
         */
        if ( ppage->free_paras_at_start >= para_req ) {
            /*
             * Success right off!
             * Mark the alloc_map entry with the size of the allocation
             * request.
             */
            *pmap1 = (__old_page_map_t)para_req;

            /*
             * Update the p_starting_alloc_map and free_paras_at_start fields
             * in the page.
             */
            if ( (pmap1 + para_req) < pendmap ) {
                ppage->p_starting_alloc_map += para_req;
                ppage->free_paras_at_start -= para_req;
            }
            else {
                ppage->p_starting_alloc_map = &(ppage->alloc_map[0]);
                ppage->free_paras_at_start = 0;
            }

            /*
             * Derive and return a pointer to the newly allocated
             * paragraphs.
             */
            return (void *)&(ppage->alloc_blocks[pmap1 -
                &(ppage->alloc_map[0])]);
        }

        /*
         * See if the search loop can be started just beyond the paragraphs
         * examined above. Note, this test assumes alloc_map[_OLD_PARAS_PER_PAGE]
         * != _OLD_FREE_PARA!
         */
        if ( *(pmap1 + ppage->free_paras_at_start) != _OLD_FREE_PARA )
            pmap1 += ppage->free_paras_at_start;

        while ( pmap1 + para_req < pendmap ) {

            if ( *pmap1 == _OLD_FREE_PARA ) {
                /*
                 * pmap1 refers to a free paragraph. Determine if there are
                 * enough free paragraphs contiguous with it to satisfy the
                 * allocation request. Note that the loop below requires that
                 * alloc_map[_OLD_PARAS_PER_PAGE] != _OLD_FREE_PARA to guarantee
                 * termination.
                 */
                for ( pmap2 = pmap1 + 1, contiguous_free = 1 ;
                      *pmap2 == _OLD_FREE_PARA ;
                      pmap2++, contiguous_free++ );

                if ( contiguous_free < para_req ) {
                    /*
                     * There were not enough contiguous free paragraphs. Do
                     * a little bookkeeping before going on to the next
                     * interation.
                     */

                    /* If pmap1 != pstartmap then these free paragraphs
                     * cannot be revisited.
                     */
                    if ( pmap1 == pstartmap ) {
                        /*
                         * Make sure free_paras_at_start is up-to-date.
                         */
                         ppage->free_paras_at_start = contiguous_free;
                    }
                    else {
                        /*
                         * These free paragraphs will not be revisited!
                         */
                        if ( (free_para_count -= contiguous_free) < para_req )
                            /*
                             * There are not enough unvisited free paragraphs
                             * to satisfy the current request. Return failure
                             * to the caller.
                             */
                            return NULL;
                    }

                    /*
                     * Update pmap1 for the next iteration of the loop.
                     */
                    pmap1 = pmap2;
                }
                else {
                    /*
                     * Success!
                     *
                     * Update the p_starting_alloc_map and free_paras_at_start
                     * fields in the page.
                     */
                    if ( (pmap1 + para_req) < pendmap ) {
                        ppage->p_starting_alloc_map = pmap1 + para_req;
                        ppage->free_paras_at_start = contiguous_free -
                                                     para_req;
                    }
                    else {
                        ppage->p_starting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = 0;
                    }

                    /*
                     * Mark the alloc_map entry with the size of the
                     * allocation request.
                     */
                    *pmap1 = (__old_page_map_t)para_req;

                    /*
                     * Derive and return a pointer to the newly allocated
                     * paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[pmap1 -
                        &(ppage->alloc_map[0])]);
                }
            }
            else {
                /*
                 * pmap1 points to start of an allocated block in alloc_map[].
                 * Skip over it.
                 */
                pmap1 = pmap1 + *pmap1;
            }
        }

        /*
         * Now start at index 0 in alloc_map[] and walk towards, but not past,
         * index starting_para_index, looking for a string of free paragraphs
         * big enough to satisfy the allocation request.
         */
        pmap1 = &(ppage->alloc_map[0]);

        while ( (pmap1 < pstartmap) &&
                (pmap1 + para_req < pendmap) )
        {
            if ( *pmap1 == _OLD_FREE_PARA ) {
                /*
                 * pmap1 refers to a free paragraph. Determine if there are
                 * enough free paragraphs contiguous with it to satisfy the
                 * allocation request.
                 */
                for ( pmap2 = pmap1 + 1, contiguous_free = 1 ;
                      *pmap2 == _OLD_FREE_PARA ;
                      pmap2++, contiguous_free++ );

                if ( contiguous_free < para_req ) {
                    /*
                     * There were not enough contiguous free paragraphs.
                     *
                     * Update the count of unvisited free paragraphs.
                     */
                    if ( (free_para_count -= contiguous_free) < para_req )
                        /*
                         * There are not enough unvisited free paragraphs
                         * to satisfy the current request. Return failure
                         * to the caller.
                         */
                        return NULL;

                    /*
                     * Update pmap1 for the next iteration of the loop.
                     */
                    pmap1 = pmap2;
                }
                else {
                    /*
                     * Success!
                     *
                     * Update the p_starting_alloc_map and free_paras_at_start
                     * fields in the page..
                     */
                    if ( (pmap1 + para_req) < pendmap ) {
                        ppage->p_starting_alloc_map = pmap1 + para_req;
                        ppage->free_paras_at_start = contiguous_free -
                                                     para_req;
                    }
                    else {
                        ppage->p_starting_alloc_map = &(ppage->alloc_map[0]);
                        ppage->free_paras_at_start = 0;
                    }

                    /*
                     * Mark the alloc_map entry with the size of the
                     * allocation request.
                     */
                    *pmap1 = (__old_page_map_t)para_req;

                    /*
                     * Derive and return a pointer to the newly allocated
                     * paragraphs.
                     */
                    return (void *)&(ppage->alloc_blocks[pmap1 -
                        &(ppage->alloc_map[0])]);
                }
            }
            else {
                /*
                 * pmap1 points to start of an allocated block in alloc_map[].
                 * Skip over it.
                 */
                pmap1 = pmap1 + *pmap1;
            }
        }

        /*
         * Return failure.
         */
        return NULL;
}


/***
*size_t __old_sbh_resize_block(preg, ppage, pmap, new_para_sz) -
*       resize block
*
*Purpose:
*       Resize the specified block from the small-block heap. The allocation
*       block is not moved.
*
*Entry:
*       __old_sbh_region_t *preg        - pointer to the descriptor for the
*                                         region containing the block
*       __old_sbh_page_t *  ppage       - pointer to the page containing the
*                                         block
*       __old_page_map_t *  pmap        - pointer to the initial alloc_map[]
*                                         entry for the allocation block
*       size_t              new_para_sz - requested new size for the allocation
*                                         block, in paragraphs.
*
*Exit:
*       Returns 1, if successful. Otherwise, 0 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __old_sbh_resize_block (
        __old_sbh_region_t * preg,
        __old_sbh_page_t *   ppage,
        __old_page_map_t *   pmap,
        size_t               new_para_sz
        )
{
        __old_page_map_t *   pmap2;
        __old_page_map_t *   pmap3;
        __old_region_map_t * pregmap;
        size_t               old_para_sz;
        size_t               free_para_count;
        int                  retval = 0;

        pregmap = &(preg->region_map[ppage - preg->p_pages_begin]);

        if ( (old_para_sz = *pmap) > new_para_sz ) {
            /*
             *  The allocation block is to be shrunk.
             */
            *pmap = (__old_page_map_t)new_para_sz;

            pregmap->free_paras_in_page += (int)(old_para_sz - new_para_sz);

            pregmap->last_failed_alloc = _OLD_NO_FAILED_ALLOC;

            retval++;
        }
        else if ( old_para_sz < new_para_sz ) {
            /*
             * The allocation block is to be grown to new_para_sz paragraphs
             * (if possible).
             */
            if ( (pmap + new_para_sz) <= &(ppage->alloc_map[_OLD_PARAS_PER_PAGE]) )
            {
                /*
                 * Determine if there are sufficient free paragraphs to
                 * expand the block to the desired new size.
                 */
                for ( pmap2 = pmap + old_para_sz,
                        pmap3 = pmap + new_para_sz ;
                      (pmap2 < pmap3) && (*pmap2 == _OLD_FREE_PARA) ;
                      pmap2++ ) ;

                if ( pmap2 == pmap3 ) {
                    /*
                     * Success, mark the resized allocation
                     */
                    *pmap = (__old_page_map_t)new_para_sz;

                    /*
                     * Check whether the p_starting_alloc_map and the
                     * free_paras_at_start fields need to be updated.
                     */
                    if ( (pmap <= ppage->p_starting_alloc_map) &&
                         (pmap3 > ppage->p_starting_alloc_map) )
                    {
                        if ( pmap3 < &(ppage->alloc_map[_OLD_PARAS_PER_PAGE]) ) {
                            ppage->p_starting_alloc_map = pmap3;
                            /*
                             * Determine how many contiguous free paragraphs
                             * there are starting a *pmap3. Note, this assumes
                             * that alloc_map[_OLD_PARAS_PER_PAGE] != _OLD_FREE_PARA.
                             */
                            for ( free_para_count = 0 ; *pmap3 == _OLD_FREE_PARA ;
                                  free_para_count++, pmap3++ ) ;
                            ppage->free_paras_at_start = free_para_count;
                        }
                        else {
                            ppage->p_starting_alloc_map = &(ppage->alloc_map[0]);
                            ppage->free_paras_at_start = 0;
                        }
                    }

                    /*
                     * Update the region_map[] entry.
                     */
                    pregmap->free_paras_in_page += (int)(old_para_sz - new_para_sz);

                    retval++;
                }
            }
        }

        return retval;
}


/***
*void * __old_sbh_heap_check() - check small-block heap
*
*Purpose:
*       Perform validity checks on the small-block heap.
*
*Entry:
*       There are no arguments.
*
*Exit:
*       Returns 0 if the small-block is okay.
*       Returns < 0 if the small-block heap has an error. The exact value
*       identifies where, in the source code below, the error was detected.
*
*Exceptions:
*       There is no protection against memory access error (exceptions).
*
*******************************************************************************/

int __cdecl __old_sbh_heap_check (
        void
        )
{
        __old_sbh_region_t * preg;
        __old_sbh_page_t *   ppage;
        int                  uncommitted_pages;
        int                  free_paras_in_page;
        int                  contiguous_free_paras;
        int                  starting_region_found;
        int                  p_starting_alloc_map_found;
        int                  i, j, k;

        starting_region_found = 0;
        preg = &__old_small_block_heap;
        do {
            if ( __old_sbh_p_starting_region == preg )
                starting_region_found++;

            if ( (ppage = preg->p_pages_begin) != _OLD_NO_PAGES ) {
                /*
                 * Scan the pages of the region looking for
                 * inconsistencies.
                 */
                for ( i = 0, uncommitted_pages = 0,
                        ppage = preg->p_pages_begin ;
                      i < _OLD_PAGES_PER_REGION ;
                      i++, ppage++ )
                {
                    if ( preg->region_map[i].free_paras_in_page ==
                         _OLD_UNCOMMITTED_PAGE )
                    {
                        /*
                         * Verify the first_uncommitted_index field.
                         */
                        if ( (uncommitted_pages == 0) &&
                             (preg->p_first_uncommitted !=
                                &(preg->region_map[i])) )
                            /*
                             * Bad first_uncommitted_index field!
                             */
                            return -1;

                        uncommitted_pages++;
                    }
                    else {

                        if ( ppage->p_starting_alloc_map >=
                             &(ppage->alloc_map[_OLD_PARAS_PER_PAGE]) )
                            /*
                             * Bad p_starting_alloc_map field
                             */
                            return -2;

                        if ( ppage->alloc_map[_OLD_PARAS_PER_PAGE] !=
                             (__old_page_map_t)-1 )
                            /*
                             * Bad alloc_map[_OLD_PARAS_PER_PAGE] field
                             */
                            return -3;

                        /*
                         * Scan alloc_map[].
                         */
                        j  = 0;
                        p_starting_alloc_map_found = 0;
                        free_paras_in_page = 0;
                        contiguous_free_paras = 0;

                        while ( j < _OLD_PARAS_PER_PAGE ) {
                            /*
                             * Look for the *p_starting_alloc_map.
                             */
                            if ( &(ppage->alloc_map[j]) ==
                                 ppage->p_starting_alloc_map )
                                p_starting_alloc_map_found++;

                            if ( ppage->alloc_map[j] == _OLD_FREE_PARA ) {
                                /*
                                 * Free paragraph, increment the count.
                                 */
                                free_paras_in_page++;
                                contiguous_free_paras++;
                                j++;
                            }
                            else {
                                /*
                                 * First paragraph of an allocated block.
                                 */

                                /*
                                 * Make sure the preceding free block, if any,
                                 * was smaller than the last_failed_alloc[]
                                 * entry for the page.
                                 */
                                if ( contiguous_free_paras >=
                                     (int)preg->region_map[i].last_failed_alloc )
                                     /*
                                      * last_failed_alloc[i] was mismarked!
                                      */
                                     return -4;

                                /*
                                 * If this is the end of the string of free
                                 * paragraphs starting at *p_starting_alloc_map,
                                 * verify that free_paras_at_start is
                                 * reasonable.
                                 */
                                if ( p_starting_alloc_map_found == 1 ) {
                                    if ( contiguous_free_paras <
                                         (int)ppage->free_paras_at_start )
                                         return -5;
                                    else
                                        /*
                                         * Set flag to 2 so the check is not
                                         * repeated.
                                         */
                                        p_starting_alloc_map_found++;
                                }

                                contiguous_free_paras = 0;

                                /*
                                 * Scan the remaining paragraphs and make
                                 * sure they are marked properly (they should
                                 * look like free paragraphs).
                                 */
                                for ( k = j + 1 ;
                                      k < j + ppage->alloc_map[j] ; k++ )
                                {
                                    if ( ppage->alloc_map[k] != _OLD_FREE_PARA )
                                        /*
                                         * alloc_map[k] is mismarked!
                                         */
                                        return -6;
                                }

                                j = k;
                            }
                        }

                        if ( free_paras_in_page !=
                             preg->region_map[i].free_paras_in_page )
                            /*
                             * region_map[i] does not match the number of
                             * free paragraphs in the page!
                             */
                             return -7;

                        if ( p_starting_alloc_map_found == 0 )
                            /*
                             * Bad p_starting_alloc_map field!
                             */
                            return -8;

                    }
                }
            }
        }
        while ( (preg = preg->p_next_region) != &__old_small_block_heap );

        if ( starting_region_found == 0 )
            /*
             * Bad __old_sbh_p_starting_region!
             */
            return -9;

        return 0;
}

#endif  /* CRTDLL */

#endif  /* _WIN64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setenv.c ===
/***
*setenv.c -set an environment variable in the environment
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __crtsetenv() - adds a new variable to environment.
*       Internal use only.
*
*******************************************************************************/


#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <tchar.h>
#include <rterr.h>
#include <dbgint.h>
#include <awint.h>
#include <limits.h>

static _TSCHAR **copy_environ(_TSCHAR **);

#ifdef WPRFLAG
static int __cdecl wfindenv(const wchar_t *name, int len);
#define USE_W   1
#define USE_A   0
#else  /* WPRFLAG */
static int __cdecl findenv(const char *name, int len);
#endif  /* WPRFLAG */

/***
*int __crtsetenv(option) - add/replace/remove variable in environment
*
*Purpose:
*       option should be of the form "option=value".  If a string with the
*       given option part already exists, it is replaced with the given
*       string; otherwise the given string is added to the environment.
*       If the string is of the form "option=", then the string is
*       removed from the environment, if it exists.  If the string has
*       no equals sign, error is returned.
*
*Entry:
*       TCHAR **poption - pointer to option string to set in the environment list.
*           should be of the form "option=value".
*           This function takes ownership of this pointer in the success case.
*       int primary - Only the primary call to _crt[w]setenv needs to
*           create new copies or set the OS environment.
*           1 indicates that this is the primary call.
*
*Exit:
*       returns 0 if OK, -1 if fails.
*       If *poption is non-null on exit, we did not free it, and the caller should
*       If *poption is null on exit, we did free it, and the caller should not.
*
*Exceptions:
*
*Warnings:
*       This code will not work if variables are removed from the environment
*       by deleting them from environ[].  Use _putenv("option=") to remove a
*       variable.
*
*       The option argument will be taken ownership of by this code and may be freed!
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl __crtwsetenv (
#else  /* WPRFLAG */
int __cdecl __crtsetenv (
#endif  /* WPRFLAG */
        _TSCHAR **poption,
        const int primary
        )
{
#ifdef WPRFLAG
        static int f_use = USE_W;
#endif  /* WPRFLAG */
        int ix;
        int retval = 0;
        int remove; /* 1 if variable is to be removed */
        _TSCHAR *option=NULL;           /* The option string passed in */
        _TSCHAR **env;
        _TSCHAR *name, *value;
        const _TSCHAR *equal;

        /* Validate poption and dereference it */
        _VALIDATE_RETURN(poption != NULL, EINVAL, -1);

        option=*poption;

        /*
         * check that the option string is valid, find the equal sign
         * and verify '=' is not the first character in string.
         */
        if ( (option == NULL) || ((equal = _tcschr(option, _T('='))) == NULL)
            || option == equal)
        {
            errno = EINVAL;
            return -1;
        }

        /* internal consistency check: the environment string should never use buffers bigger than _MAX_ENV
         * see also SDK function SetEnvironmentVariable
         */
        _ASSERTE(equal - option < _MAX_ENV);
        _ASSERTE(_tcsnlen(equal + 1, _MAX_ENV) < _MAX_ENV);

        /* if the character following '=' is null, we are removing the
         * the environment variable. Otherwise, we are adding or updating
         * an environment variable.
         */
        remove = (*(equal + 1) == _T('\0'));

        /*
         * the first time _[w]putenv() is called, copy the environment
         * block that was passed to [w]main to avoid making a
         * dangling pointer if the block is re-alloced.
         */
#ifdef WPRFLAG
        if (_wenviron == __winitenv)
            _wenviron = copy_environ(_wenviron);
#else  /* WPRFLAG */
        if (_environ == __initenv)
            _environ = copy_environ(_environ);
#endif  /* WPRFLAG */

        /* see if requested environment array exists */
        if (_tenviron == NULL) {

            /*
             * The requested type of environment does not exist.
             * See if other type exists, if so convert it to requested type.
             * The functions that convert the enviroment (__mbtow_environ and
             * __wtomb_environ) will call this function (__crt[w]setenv) once
             * for each of the pre-existing environment variables. To avoid
             * an infinite loop, test the primary flag.
             */

#ifdef WPRFLAG
            if (primary && _environ)
            {
                _wenvptr = __crtGetEnvironmentStringsW();
                if ( _wsetenvp() < 0 )
                    if (__mbtow_environ() != 0)
                    {
                        errno = EINVAL;
                        return -1;
                    }
            }
#else  /* WPRFLAG */
            if (primary && _wenviron)
            {
                if (__wtomb_environ() != 0)
                {
                    errno = EINVAL;
                    return -1;
                }
            }
#endif  /* WPRFLAG */
            else {
                /* nothing to remove, return */
                if ( remove )
                    return 0;
                else {
                    /* create ones that do not exist */

                    if (_environ == NULL)
                    {
                        if ( (_environ = _malloc_crt(sizeof(char *))) == NULL)
                            return -1;
                        *_environ = NULL;
                    }

                    if (_wenviron == NULL)
                    {
                        if ( (_wenviron = _malloc_crt(sizeof(wchar_t *))) == NULL)
                            return -1;
                        *_wenviron = NULL;
                    }
                }
            }
        }

        /*
         * At this point, the two types of environments are in sync (as much
         * as they can be anyway). The only way they can get out of sync
         * (besides users directly modifiying the environment) is if there
         * are conversion problems: If the user sets two Unicode EVs,
         * "foo1" and "foo2" and converting then to multibyte yields "foo?"
         * and "foo?", then the environment blocks will differ.
         */

        /* init env pointers */
        env = _tenviron;
                if(!env)
                {
                        _ASSERTE(("CRT Logic error during setenv",0));
                        return -1;
                }

        /* See if the string is already in the environment */
#ifdef WPRFLAG
        ix = wfindenv(option, (int)(equal - option));
#else  /* WPRFLAG */
        ix = findenv(option, (int)(equal - option));
#endif  /* WPRFLAG */

        if ((ix >= 0) && (*env != NULL)) {
            /*
             * String is already in the environment. Free up the original
             * string. Then, install the new string or shrink the environment,
             * whichever is warranted.
             */
            _free_crt(env[ix]);

            if (remove) {

                /* removing -- move all the later strings up */
                for ( ; env[ix] != NULL; ++ix) {
                    env[ix] = env[ix+1];
                }

                /* shrink the environment memory block
                   (ix now has number of strings, including NULL) --
                   this realloc probably can't fail, since we're
                   shrinking a mem block, but we're careful anyway. */
                if (ix < (SIZE_MAX / sizeof(_TSCHAR *)) &&
                    (env = (_TSCHAR **) _recalloc_crt(_tenviron, ix, sizeof(_TSCHAR *))) != NULL)
                    _tenviron = env;
            }
            else {
                /* replace the option */
                env[ix] = (_TSCHAR *) option;

                /* we now own the pointer, so NULL out the incoming pointer */
                *poption=NULL;
            }
        }
        else {
            /*
             * String is NOT in the environment
             */
            if ( !remove )  {
                /*
                 * Append the string to the environ table. Note that
                 * table must be grown to do this.
                 */
                if (ix < 0)
                    ix = -ix;    /* ix = length of environ table */

                if ((ix + 2) < ix ||
                    (ix + 2) >= (SIZE_MAX / sizeof(_TSCHAR *)) ||
                    (env = (_TSCHAR **)_recalloc_crt(_tenviron, sizeof(_TSCHAR *), (ix + 2))) == NULL)
                    return -1;

                env[ix] = (_TSCHAR *)option;
                env[ix + 1] = NULL;

                /* we now own the pointer, so NULL out the incoming pointer */
                *poption=NULL;

                _tenviron = env;
            }
            else {
                /*
                 * We are asked to remove an environment var that isn't there.
                 * Free the option string and return success.
                 */
                _free_crt(option);

                /* we now freed the pointer, so NULL out the incoming pointer */
                *poption=NULL;

                return 0;
            }
        }

        /*
         * Update the OS environment. Don't give an error if this fails
         * since the failure will not affect the user unless he/she is making
         * direct API calls. Only need to do this for one type, OS converts
         * to other type automatically.
         */
        if ( primary &&
            (name = (_TSCHAR *)_calloc_crt((_tcslen(option) + 2), sizeof(_TSCHAR))) != NULL )
        {
            _ERRCHECK(_tcscpy_s(name, _tcslen(option) + 2, option));
            value = name + (equal - option);
            *value++ = _T('\0');
#ifdef WPRFLAG
            if (f_use == USE_W)
            {
                if ( SetEnvironmentVariableW(name, remove ? NULL : value) == 0)
                {
                    if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                        f_use = USE_A;
                    else
                        retval = -1;
                }
            }
            if (f_use == USE_A)
            {
                int size;
                char *c_name = NULL, *c_value = NULL;
                if ((size = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL)) == 0)
                    retval = -1;

                /* allocate space for variable */
                else if ((c_name = (char *) _calloc_crt(size, sizeof(char))) == NULL)
                    retval = -1;

                /* convert it */
                else if (WideCharToMultiByte(CP_ACP, 0, name, -1, c_name, size, NULL, NULL) == 0)
                    retval = -1;

                else if ( !remove )
                {
                    if ((size = WideCharToMultiByte(CP_ACP, 0, value, -1, NULL, 0, NULL, NULL)) == 0)
                        retval = -1;
                    /* allocate space for variable */
                    else if ((c_value = (char *) _calloc_crt(size, sizeof(char))) == NULL)
                        retval = -1;
                    /* convert it */
                    else if (WideCharToMultiByte(CP_ACP, 0, value, -1, c_value, size, NULL, NULL) == 0)
                        retval = -1;
                }

                if (retval != -1)
                    if (SetEnvironmentVariableA(c_name, remove ? NULL : c_value) == 0)
                        retval = -1;

                _free_crt(c_value);
                _free_crt(c_name);
            }
#else  /* WPRFLAG */
            if (SetEnvironmentVariable(name, remove ? NULL : value) == 0)
                retval = -1;
#endif  /* WPRFLAG */
            if (retval == -1)
            {
                errno = EILSEQ;
            }

            _free_crt(name);
        }

        if (remove) {
            /* free option string since it won't be used anymore */
            _free_crt(option);
            *poption = NULL;
        }

        return retval;
}


/***
*int findenv(name, len) - [STATIC]
*
*Purpose:
*       Scan for the given string within the environment
*
*Entry:
*
*Exit:
*       Returns the offset in "environ[]" of the given variable
*       Returns the negative of the length of environ[] if not found.
*       Returns 0 if the environment is empty.
*
*       [NOTE: That a 0 return can mean that the environment is empty
*       or that the string was found as the first entry in the array.]
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wfindenv (
#else  /* WPRFLAG */
static int __cdecl findenv (
#endif  /* WPRFLAG */
        const _TSCHAR *name,
        int len
        )
{
        _TSCHAR **env;

        for ( env = _tenviron ; *env != NULL ; env++ ) {
            /*
             * See if first len characters match, up to case
             */
            if ( _tcsnicoll(name, *env, len) == 0 )
                /*
                 * the next character of the environment string must
                 * be an '=' or a '\0'
                 */
                if ( (*env)[len] == _T('=') || (*env)[len] == _T('\0') )
                    return(int)(env - _tenviron);
//
// We cannot break here since findenv must report the total number of strings.
//              else
//                  break;
        }

        return(-(int)(env - _tenviron));
}


/***
*copy_environ - copy an environment block
*
*Purpose:
*       Create a copy of an environment block.
*
*Entry:
*       _TSCHAR **oldenviron - pointer to enviroment to be copied.
*
*Exit:
*       Returns a pointer to newly created environment.
*
*Exceptions:
*
*******************************************************************************/

static _TSCHAR **copy_environ(_TSCHAR **oldenviron)
{
        int cvars = 0;
        _TSCHAR **oldenvptr = oldenviron;
        _TSCHAR **newenviron, **newenvptr;

        /* no environment */
        if (oldenviron == NULL)
            return NULL;

        /* count number of environment variables */
        while (*oldenvptr++)
            cvars++;

        /* need pointer for each string, plus one null ptr at end */
        if ( (newenviron = newenvptr = (_TSCHAR **)
            _calloc_crt((cvars+1), sizeof(_TSCHAR *))) == NULL )
            _amsg_exit(_RT_SPACEENV);

        /* duplicate the environment variable strings */
        oldenvptr = oldenviron;
        while (*oldenvptr)
#ifdef _DEBUG
        {
            size_t envptrSize = _tcslen(*oldenvptr) + 1;
            if ( (*newenvptr = _calloc_crt(envptrSize, sizeof(_TSCHAR))) != NULL )
                _ERRCHECK(_tcscpy_s(*newenvptr, envptrSize, *oldenvptr));
            oldenvptr++;
            newenvptr++;
        }
#else  /* _DEBUG */
            *newenvptr++ = _tcsdup(*oldenvptr++);
#endif  /* _DEBUG */

        *newenvptr = NULL;

        return newenviron;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_SHARE
#define _INC_SHARE

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */
#define _SH_SECURE      0x80    /* secure mode */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif  /* !__STDC__ */

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * Definitions specific to particular setjmp implementations.
 */

#if defined (_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#else  /* defined (_M_IX86) */

#ifdef setjmp
#undef setjmp
#endif  /* setjmp */
#define setjmp _setjmpex

#endif  /* defined (_M_IX86) */

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setlocal.h ===
/***
*setlocal.h - internal definitions used by locale-dependent functions.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains internal definitions/declarations for locale-dependent
*       functions, in particular those required by setlocale().
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_SETLOCAL
#define _INC_SETLOCAL

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#include <crtdefs.h>
#include <cruntime.h>
#include <oscalls.h>
#include <limits.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#define ERR_BUFFER_TOO_SMALL    1   /* should be in windef.h */

#define _CLOCALEHANDLE  0       /* "C" locale handle */
#define _CLOCALECP      CP_ACP  /* "C" locale Code page */
#define _COFFSET    127     /* offset to where ctype will point,
                               look in initctype on how it is being
                               used */


#define _COFFSET    127     /* introduced so that pctype can work with unsigned
                               char types and EOF, used only in initctype and
                               setloc.c
                               */
/* Define the max length for each string type including space for a null. */

#define _MAX_WDAY_ABBR  4
#define _MAX_WDAY   10
#define _MAX_MONTH_ABBR 4
#define _MAX_MONTH 10
#define _MAX_AMPM   3

#define _DATE_LENGTH    8       /* mm/dd/yy (null not included) */
#define _TIME_LENGTH    8       /* hh:mm:ss (null not included) */

#define _PER_THREAD_LOCALE_BIT  0x2
#define _GLOBAL_LOCALE_BIT      0x1


/* LC_TIME localization structure */

#ifndef __LC_TIME_DATA
struct __lc_time_data {
        char *wday_abbr[7];
        char *wday[7];
        char *month_abbr[12];
        char *month[12];
        char *ampm[2];
        char *ww_sdatefmt;
        char *ww_ldatefmt;
        char *ww_timefmt;
        LCID ww_lcid;
        int  ww_caltype;
        int  refcount;
};
#define __LC_TIME_DATA
#endif  /* __LC_TIME_DATA */


#define MAX_LANG_LEN        64  /* max language name length */
#define MAX_CTRY_LEN        64  /* max country name length */
#define MAX_MODIFIER_LEN    0   /* max modifier name length - n/a */
#define MAX_LC_LEN          (MAX_LANG_LEN+MAX_CTRY_LEN+MAX_MODIFIER_LEN+3)
                                /* max entire locale string length */
#define MAX_CP_LEN          16  /* max code page name length */
#define CATNAMES_LEN        57  /* "LC_COLLATE=;LC_CTYPE=;..." length */

#define LC_INT_TYPE         0
#define LC_STR_TYPE         1

#ifndef _TAGLC_ID_DEFINED
typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED
#endif  /* _TAGLC_ID_DEFINED */

#ifndef _SETLOC_STRUCT_DEFINED
struct _is_ctype_compatible {
        unsigned long id;
        int is_clike;
};

typedef struct setloc_struct {
    /* getqloc static variables */
    char *pchLanguage;
    char *pchCountry;
    int iLcidState;
    int iPrimaryLen;
    BOOL bAbbrevLanguage;
    BOOL bAbbrevCountry;
    LCID lcidLanguage;
    LCID lcidCountry;
    /* expand_locale static variables */
    LC_ID       _cacheid;
    UINT        _cachecp;
    char        _cachein[MAX_LC_LEN];
    char        _cacheout[MAX_LC_LEN];
    /* _setlocale_set_cat (LC_CTYPE) static variable */
    struct _is_ctype_compatible _Lcid_c[5];
} _setloc_struct, *_psetloc_struct;
#define _SETLOC_STRUCT_DEFINED
#endif  /* _SETLOC_STRUCT_DEFINED */

#ifndef _THREADLOCALEINFO
typedef struct threadlocaleinfostruct {
        int refcount;
        UINT lc_codepage;
        UINT lc_collate_cp;
        LCID lc_handle[6];
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
#define _THREADLOCALEINFO
#endif  /* _THREADLOCALEINFO */

#ifndef _THREADMBCINFO
typedef struct threadmbcinfostruct {
        int refcount;
        int mbcodepage;
        int ismbcodepage;
        int mblcid;
        unsigned short mbulinfo[6];
        unsigned char mbctype[257];
        unsigned char mbcasemap[256];
} threadmbcinfo;
#define _THREADMBCINFO
#endif  /* _THREADMBCINFO */

typedef struct tagLC_STRINGS {
        char szLanguage[MAX_LANG_LEN];
        char szCountry[MAX_CTRY_LEN];
        char szCodePage[MAX_CP_LEN];
} LC_STRINGS, *LPLC_STRINGS;

extern pthreadlocinfo __ptlocinfo;
pthreadlocinfo __cdecl __updatetlocinfo(void);
void __cdecl _setptlocale(int);

/* We have these as globals only for single threaded model. to improve performance */
extern _setloc_struct __setloc_data;
#ifndef _M_CEE_PURE
_CRTIMP extern LCID __lc_handle[];       /* locale "handles" - ignores country info */
_CRTIMP extern UINT __lc_codepage;      /* code page */
_CRTIMP extern UINT __lc_collate_cp;    /* code page for LC_COLLATE */
_CRTIMP extern struct lconv * __lconv;  /* pointer to current lconv structure */
_CRTIMP extern int __lc_clike;          /* if first 127 characters of current locale
                                           are same as first 127 characters of
                                           C_LOCALE */
#endif  /* _M_CEE_PURE */

extern struct __lc_time_data *__lc_time_curr; /* code page for LC_TIME */
#define __LC_HANDLE(ptloci)     (ptloci)->lc_handle
#define __LC_CODEPAGE(ptloci)   (ptloci)->lc_codepage
#define __LC_COLLATE_CP(ptloci) (ptloci)->lc_collate_cp
#define __LC_CLIKE(ptloci)      (ptloci)->lc_clike
#define __LC_TIME_CURR(ptloci)  (ptloci)->lc_time_curr
#define __LCONV(ptloci)         (ptloci)->lconv

/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP LCID* __cdecl ___lc_handle_func(void);
_CRTIMP UINT __cdecl ___lc_codepage_func(void);
_CRTIMP UINT __cdecl ___lc_collate_cp_func(void);

BOOL __cdecl __get_qualified_locale(_In_opt_ const LPLC_STRINGS _LpInStr, _Out_opt_ LPLC_ID _LpOutId, _Out_opt_ LPLC_STRINGS _LpOutStr);

int __cdecl __getlocaleinfo (_In_opt_ _locale_t _Locale, _In_ int _Lc_type, LCID _LocaleId, LCTYPE _FieldType, _Out_ void * _Address);

/* lconv structure for the "C" locale */
extern struct lconv __lconv_c;

/* initial values for lconv structure */
extern char __lconv_static_decimal[];
extern char __lconv_static_null[];

/* Initialization functions for locale categories */

int __cdecl __init_collate(_In_opt_ threadlocinfo *);
int __cdecl __init_ctype(_Inout_ threadlocinfo *_LocInfo);
int __cdecl __init_monetary(_Inout_ threadlocinfo *_LocInfo);
int __cdecl __init_numeric(_Inout_ threadlocinfo *_LocInfo);
int __cdecl __init_time(_Inout_ threadlocinfo *_LocInfo);
int __cdecl __init_dummy(_In_opt_ threadlocinfo *_LocInfo);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef __cplusplus
class _LocaleUpdate
{
    _locale_tstruct localeinfo;
    _ptiddata ptd;
    bool updated;
    public:
    _LocaleUpdate(_locale_t plocinfo)
        : updated(false)
    {
        if (plocinfo == NULL)
        {
            ptd = _getptd();
            localeinfo.locinfo = ptd->ptlocinfo;
            localeinfo.mbcinfo = ptd->ptmbcinfo;

            __UPDATE_LOCALE(ptd, localeinfo.locinfo);
            __UPDATE_MBCP(ptd, localeinfo.mbcinfo);
            if (!(ptd->_ownlocale & _PER_THREAD_LOCALE_BIT))
            {
                ptd->_ownlocale |= _PER_THREAD_LOCALE_BIT;
                updated = true;
            }
        }
        else
        {
            localeinfo=*plocinfo;
        }
    }
    ~_LocaleUpdate()
    {
        if (updated)
            ptd->_ownlocale = ptd->_ownlocale & ~_PER_THREAD_LOCALE_BIT;
    }
    _locale_t GetLocaleT()
    {
        return &localeinfo;
    }
};
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETLOCAL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\slbeep.c ===
/***
*slbeep.c - Sleep and beep
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _sleep() and _beep()
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>

/***
*void _sleep(duration) - Length of sleep
*
*Purpose:
*
*Entry:
*       unsigned long duration - length of sleep in milliseconds or
*       one of the following special values:
*
*           _SLEEP_MINIMUM - Sends a yield message without any delay
*           _SLEEP_FOREVER - Never return
*
*Exit:
*       None
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _sleep(unsigned long dwDuration)
{

    if (dwDuration == 0) {
        dwDuration++;
    }
    Sleep(dwDuration);

}

/***
*void _beep(frequency, duration) - Length of sleep
*
*Purpose:
*
*Entry:
*       unsigned frequency - frequency in hertz
*       unsigned duration - length of beep in milliseconds
*
*Exit:
*       None
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _beep(unsigned dwFrequency, unsigned dwDuration)
{
    Beep(dwFrequency, dwDuration);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setnewh.cpp ===
/***
*setnewh.cpp - defines C++ set_new_handler() routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ set_new_handler() routine.
*
*       OBSOLETE - the conforming std::set_new_handler can be found in
*       stdhndlr.cpp.  This version remains for backwards-compatibility,
*       and can no longer be referenced using headers new or new.h.
*
*******************************************************************************/

#include <stddef.h>
#include <internal.h>
#include <cruntime.h>
#include <mtdll.h>
#include <process.h>
#include <dbgint.h>

#define set_new_handler set_new_handler_ignore
#include <new.h>
#undef set_new_handler

#define _ASSERT_OK
#include <assert.h>


/***
*new_handler set_new_handler - set the ANSI C++ new handler
*
*Purpose:
*       Set the ANSI C++ per-thread new handler.
*
*Entry:
*       Pointer to the new handler to be installed.
*
*       WARNING: set_new_handler is a stub function that is provided to
*       allow compilation of the Standard Template Library (STL).
*
*       Do NOT use it to register a new handler. Use _set_new_handler instead.
*
*       However, it can be called to remove the current handler:
*
*           set_new_handler(NULL); // calls _set_new_handler(NULL)
*
*Return:
*       Previous ANSI C++ new handler
*
*******************************************************************************/

new_handler __cdecl set_new_handler (
        new_handler new_p
        )
{
        // cannot use stub to register a new handler
        assert(new_p == 0);

        // remove current handler
        _set_new_handler(0);

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\smalheap.c ===
/***
*smalheap.c - small, simple heap manager
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*
*******************************************************************************/

#include <malloc.h>
#include <stdlib.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>

HANDLE _crtheap=NULL;

/*
 * Primary heap routines (Initialization, termination, malloc and free).
 */

void __cdecl free (
        void * pblock
        )
{
        if ( pblock == NULL )
            return;

        HeapFree(_crtheap, 0, pblock);
}


int __cdecl _heap_init (
        int mtflag
        )
{
        if ( (_crtheap = HeapCreate( mtflag ? 0 : HEAP_NO_SERIALIZE,
                                     BYTES_PER_PAGE, 0 )) == NULL )
            return 0;

        return 1;
}


void __cdecl _heap_term (
        void
        )
{
        HeapDestroy( _crtheap );
        _crtheap=NULL;
}


void * __cdecl _nh_malloc (
        size_t size,
        int nhFlag
        )
{
        void * retp;

        for (;;) {

            retp = HeapAlloc( _crtheap, 0, size );

            /*
             * if successful allocation, return pointer to memory
             * if new handling turned off altogether, return NULL
             */

            if (retp || nhFlag == 0)
                return retp;

            /* call installed new handler */
            if (!_callnewh(size))
                return NULL;

            /* new handler was successful -- try to allocate again */
        }
}


void * __cdecl malloc (
        size_t size
        )
{
        return _nh_malloc( size, _newmode );
}

/*
 * Secondary heap routines.
 */

void * __cdecl calloc (
        size_t num,
        size_t size
        )
{
        void * retp;

        size *= num;

        for (;;) {

            retp = HeapAlloc( _crtheap, HEAP_ZERO_MEMORY, size );

            if ( retp || _newmode == 0)
                return retp;

            /* call installed new handler */
            if (!_callnewh(size))
                return NULL;

            /* new handler was successful -- try to allocate again */
        }
}


void * __cdecl _expand (
        void * pblock,
        size_t newsize
        )
{
        return HeapReAlloc( _crtheap,
                            HEAP_REALLOC_IN_PLACE_ONLY,
                            pblock,
                            newsize );
}


int __cdecl _heapchk(void)
{
        int retcode = _HEAPOK;

        if ( !HeapValidate( _crtheap, 0, NULL ) &&
             (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED) )
                retcode = _HEAPBADNODE;

        return retcode;
}


int __cdecl _heapmin(void)
{
        if ( (HeapCompact( _crtheap, 0 ) == 0) &&
             (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED) )
            return -1;

        return 0;
}


size_t __cdecl _msize (
        void * pblock
        )
{
        return (size_t)HeapSize( _crtheap, 0, pblock );
}


void * __cdecl realloc (
        void * pblock,
        size_t newsize
        )
{
        void * retp;

        /* if pblock is NULL, call malloc */
        if ( pblock == (void *) NULL )
            return malloc( newsize );

        /* if pblock is !NULL and size is 0, call free and return NULL */
        if ( newsize == 0 ) {
            free( pblock );
            return NULL;
        }

        for (;;) {

            retp = HeapReAlloc( _crtheap, 0, pblock, newsize );

            if ( retp || _newmode == 0)
                return retp;

            /* call installed new handler */
            if (!_callnewh(newsize))
                return NULL;

            /* new handler was successful -- try to allocate again */
        }
}

void * __cdecl _recalloc(void * memblock, size_t count, size_t size)
{
    size_t  size_orig=0;

    /* ensure that (size * num) does not overflow */
    if (count > 0)
    {
        if((_HEAP_MAXREQ / count) >= size)
        {
            return NULL;
        }
    }
    size_orig = size * count;

    return realloc(memblock, size_orig);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\snprintf.c ===
/***
*snprintf.c - "Count" version of sprintf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       The _snprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*
*******************************************************************************/

#define _COUNT_ 1
#include "sprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setmaxf.c ===
/***
*setmaxf.c - Set the maximum number of streams
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _setmaxstdio(), a function which changes the maximum number
*       of streams (stdio-level files) which can be open simultaneously.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <malloc.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>
#include <dbgint.h>

/***
*int _setmaxstdio(maxnum) - sets the maximum number of streams to maxnum
*
*Purpose:
*       Sets the maximum number of streams which may be simultaneously open
*       to maxnum. This is done by resizing the __piob[] array and updating
*       _nstream. Note that maxnum may be either larger or smaller than the
*       current _nstream value.
*
*Entry:
*       maxnum = new maximum number of streams
*
*Exit:
*       Returns maxnum, if successful, and -1 otherwise.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _setmaxstdio (
        int maxnum
        )
{
        void **newpiob;
        int i;
        int retval;

        /*
         * Make sure the request is reasonable.
         */
        _VALIDATE_RETURN(((maxnum >= _IOB_ENTRIES) && (maxnum <= _NHANDLE_)), EINVAL, -1);

        _mlock(_IOB_SCAN_LOCK);
        __try {

        /*
         * Try to reallocate the __piob array.
         */
        if ( maxnum > _nstream ) {
            if ( (newpiob = _recalloc_crt( __piob, maxnum, sizeof(void *) ))
                 != NULL )
            {
                /*
                 * Initialize new __piob entries to NULL
                 */
                for ( i = _nstream ; i < maxnum ; i++ )
                    newpiob[i] = NULL;

                retval = _nstream = maxnum;
                __piob = newpiob;
            }
            else
                retval = -1;
        }
        else if ( maxnum == _nstream )
            retval = _nstream;
        else {  /* maxnum < _nstream */
            retval = maxnum;
            /*
             * Clean up the portion of the __piob[] to be freed.
             */
            for ( i = _nstream - 1 ; i >= maxnum ; i-- )
                /*
                 * If __piob[i] is non-NULL, free up the _FILEX struct it
                 * points to.
                 */
                if ( __piob[i] != NULL )
                    if ( !inuse( (FILE *)__piob[i] ) ) {
                        _free_crt( __piob[i] );
                    }
                    else {
                        /*
                         * _FILEX is still inuse! Don't free any anything and
                         * return failure to the caller.
                         */
                        retval = -1;
                        break;
                    }

            if ( retval != -1 )
                if ( (newpiob = _recalloc_crt( __piob, maxnum, sizeof(void *) ))
                     != NULL )
                {
                    _nstream = maxnum;      /* retval already set to maxnum */
                    __piob = newpiob;
                }
                else
                    retval = -1;
        }

        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }

        return retval;
}


/***
*int _getmaxstdio() - gets the maximum number of stdio files
*
*Purpose:
*       Returns the maximum number of simultaneously open stdio-level files.
*       This is the current value of _nstream.
*
*Entry:
*
*Exit:
*       Returns current value of _nstream.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getmaxstdio (
        void
        )
{
        return _nstream;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\snprnc.c ===
/***
*snprnc.c - Version of _snprintf with the error return fix.
*
*   Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   The _snprintf_c() flavor  returns -1 in case there is no space
*   available for the null terminator & blanks out the buffer
*
*******************************************************************************/


#define _COUNT_ 1
#define _SWPRINTFS_ERROR_RETURN_FIX 1

#include <wchar.h>
#include "sprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\snscanf.c ===
/***
*snscanf.c - read formatted data from string of given length
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines snscanf() - reads formatted data from string of given length
*
*******************************************************************************/
#define _SNSCANF
#include "sscanf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnle.c ===
/***
*spawnle.c - spawn a child process with given environment
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnle() - spawn a child process with given environ
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnle(modeflag, pathname, arglist) - spawn a child process with env.
*
*Purpose:
*       Spawns a child process with given parameters and environment.
*       formats the parameters and calls _spawnve to do the actual work.
*       NOTE - at least one argument must be present.  This argument is always,
*       by convention, the name of the file being spawned.
*
*Entry:
*       int modeflag   - mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT, and OVERLAY currently implemented
*       _TSCHAR *pathname - name of file to spawn
*       _TSCHAR *arglist  - argument list, environment is at the end
*       call as _spawnle(modeflag, path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       returns exit code of spawned process
*       if fails, return -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnle (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        REG1 const _TSCHAR **argp;

        /* validation section */
        _VALIDATE_RETURN(pathname != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*pathname != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        /* walk the arglist until the terminating NULL pointer is found.  The
         * next location holds the environment table pointer.
         */

        argp = &arglist;
        while (*argp++)
                ;

        return(_tspawnve(modeflag,pathname,&arglist,(_TSCHAR **)*argp));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(pathname != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*pathname != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _tspawnve(modeflag,pathname,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnl.c ===
/***
*spawnl.c - spawn a child process
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnl() - spawn a child process
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnl(modeflag, pathname, arglist) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls spawnve to do the actual work. The
*       new process will inherit the parent's environment. NOTE - at least
*       one argument must be present.  This argument is always, by convention,
*       the name of the file being spawned.
*
*Entry:
*       int modeflag   - defines which mode of spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY are currently implemented
*       _TSCHAR *pathname - file to be spawned
*       _TSCHAR *arglist  - list of argument
*       call as _spawnl(modeflag, path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnl (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        /* validation section */
        _VALIDATE_RETURN(pathname != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*pathname != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        return(_tspawnve(modeflag,pathname,&arglist,NULL));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(pathname != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*pathname != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        va_end(vargs);

        result = _tspawnve(modeflag,pathname,argv,NULL);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnlp.c ===
/***
*spawnlp.c - spawn a file; search along PATH
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnlp() - spawn a file with search along PATH
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*_spawnlp(modeflag, filename, arglist) - spawn file and search along PATH
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnvp to do the work of searching
*       the PATH environment variable and calling _spawnve.  The NULL
*       environment pointer indicates that the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT, OVERLAY currently implemented
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR *arglist  - argument list
*       call as _spawnlp(modeflag, path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnlp (
        int modeflag,
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        return(_tspawnvp(modeflag,filename,&arglist));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        va_end(vargs);

        result = _tspawnvp(modeflag,filename,argv);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnv.c ===
/***
*spawnv.c - spawn a child process
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnv() - spawn a child process
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <dbgint.h>
#include <internal.h>

/***
*int _spawnv(modeflag, pathname, argv) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnve to do the actual work.  The
*       NULL environment pointer indicates that the new process will inherit
*       the parents process's environment.  NOTE - at least one argument must
*       be present.  This argument is always, by convention, the name of the
*       file being spawned.
*
*Entry:
*       int modeflag   - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY currently implemented
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR **argv    - vector of arguments
*
*Exit:
*       returns exit code of child process
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnv (
        int modeflag,
        const _TSCHAR *pathname,
        const _TSCHAR * const *argv
        )
{
        /* validation section */
        _VALIDATE_RETURN(pathname != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*pathname != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(argv != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*argv != NULL, EINVAL, -1);
        _VALIDATE_RETURN(**argv != _T('\0'), EINVAL, -1);

        return(_tspawnve(modeflag,pathname,argv,NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\setlocal.c ===
/***
*setlocal.c - Contains the setlocale function
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains the setlocale() function.
*
*******************************************************************************/

#include <locale.h>
#include <internal.h>

#if !defined (_WIN32)

static char _clocalestr[] = "C";

#else  /* !defined (_WIN32) */

#include <cruntime.h>
#include <setlocal.h>
#include <mtdll.h>
#include <malloc.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h> /* for strtol */
#include <dbgint.h>
#include <ctype.h>
#include <awint.h>
#include <mbctype.h>
#include <rterr.h>

/* C locale */
extern char __clocalestr[];


#ifdef _DEBUG
// free as much of memory as possible in debug mode to minimise leaks.
#include <sect_attribs.h>
#include <internal.h>
void __cdecl _locterm(void);

_CRTALLOC(".CRT$XPX") static _PVFV pterm = _locterm;

#endif  /* _DEBUG */


__declspec(selectany) struct {
        const char * catname;
        char * locale;
        int (* init)(threadlocinfo *);
} const __lc_category[LC_MAX-LC_MIN+1] = {
        /* code assumes locale initialization is "__clocalestr" */
        { "LC_ALL",     NULL,           __init_dummy /* never called */ },
        { "LC_COLLATE", __clocalestr,    __init_collate  },
        { "LC_CTYPE",   __clocalestr,    __init_ctype    },
        { "LC_MONETARY",__clocalestr,    __init_monetary },
        { "LC_NUMERIC", __clocalestr,    __init_numeric  },
        { "LC_TIME",    __clocalestr,    __init_time }
};

static const char _first_127char[] = {
        1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17,
        18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
        69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
        86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100,101,102,
        103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
        120,121,122,123,124,125,126,127
};

extern struct __lc_time_data __lc_time_c;
extern threadlocinfo __initiallocinfo;
extern const unsigned short _wctype[];
static const short *_ctype_loc_style = _wctype+2;
int __locale_changed=0;



/*
 * Flag indicating whether or not setlocale() is active. Its value is the
 * number of setlocale() calls currently active.
 *
 * WARNING - This flag and query function are obsolete, and are here only to
 * preserve existing exports for binary compatibility.
 */
_CRTIMP int __setlc_active;
_CRTIMP int __cdecl ___setlc_active_func(void)
{
    return __setlc_active;
}

/*
 * Flag indicating whether or not a function which references the locale
 * without having locked it is active. Its value is the number of such
 * functions.
 *
 * WARNING - This flag and query function are obsolete, and are here only to
 * preserve existing exports for binary compatibility.
 */
_CRTIMP int __unguarded_readlc_active;
_CRTIMP int * __cdecl ___unguarded_readlc_active_add_func(void)
{
    return &__unguarded_readlc_active;
}

/* helper function prototypes */
char * _expandlocale(char *, char *, size_t, LC_ID *, UINT *, int);
void _strcats(char *, size_t, int, ...);
void __lc_lctostr(char *, size_t, const LC_STRINGS *);
int __lc_strtolc(LC_STRINGS *, const char *);
static char * __cdecl _setlocale_set_cat(pthreadlocinfo, int, const char *);
static char * __cdecl _setlocale_get_all(pthreadlocinfo);
static pthreadlocinfo __cdecl _updatetlocinfo_nolock(void);
static char * __cdecl _setlocale_nolock(pthreadlocinfo, int, const char *);
int __cdecl _setmbcp_nolock(int, pthreadmbcinfo);
void __cdecl __free_lconv_mon(struct lconv *);
void __cdecl __free_lconv_num(struct lconv *);
void __cdecl __free_lc_time(struct __lc_time_data *);
#endif  /* !defined (_WIN32) */



/***
*__freetlocinfo() - free threadlocinfo
*
*Purpose:
*       Free up the per-thread locale info structure specified by the passed
*       pointer.
*
*Entry:
*       pthreadlocinfo ptloci
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __freetlocinfo (
        pthreadlocinfo ptloci
        )
{
    int category;
    /*
     * Free up lconv struct
     */
    if ( (ptloci->lconv != NULL) &&
         (ptloci->lconv != &__lconv_c) &&
         ((ptloci->lconv_intl_refcount != NULL) &&
         (*(ptloci->lconv_intl_refcount) == 0)))
    {
        if ( (ptloci->lconv_mon_refcount != NULL) &&
             (*(ptloci->lconv_mon_refcount) == 0))
        {
            _free_crt(ptloci->lconv_mon_refcount);
            __free_lconv_mon(ptloci->lconv);
        }

        if ( (ptloci->lconv_num_refcount != NULL) &&
             (*(ptloci->lconv_num_refcount) == 0))
        {
            _free_crt(ptloci->lconv_num_refcount);
            __free_lconv_num(ptloci->lconv);
        }

        _free_crt(ptloci->lconv_intl_refcount);
        _free_crt(ptloci->lconv);
    }

    /*
     * Free up ctype tables
     */
    if ( (ptloci->ctype1_refcount != NULL) &&
         (*(ptloci->ctype1_refcount) == 0) )
    {
        _free_crt(ptloci->ctype1-_COFFSET);
        _free_crt((char *)(ptloci->pclmap - _COFFSET - 1));
        _free_crt((char *)(ptloci->pcumap - _COFFSET - 1));
        _free_crt(ptloci->ctype1_refcount);
    }

    /*
     * Free up the __lc_time_data struct
     */
    if ( ptloci->lc_time_curr != &__lc_time_c &&
         ((ptloci->lc_time_curr->refcount) == 0) )
    {
        __free_lc_time(ptloci->lc_time_curr);
        _free_crt(ptloci->lc_time_curr);
    }

    for (category = LC_MIN; category <= LC_MAX; ++category) {
        if ((ptloci->lc_category[category].locale != __clocalestr) &&
              (ptloci->lc_category[category].refcount != NULL) &&
              (*ptloci->lc_category[category].refcount == 0) )
        {
            _free_crt(ptloci->lc_category[category].refcount);
        }
        _ASSERTE(((ptloci->lc_category[category].wlocale != NULL) && (ptloci->lc_category[category].wrefcount != NULL)) ||
                 ((ptloci->lc_category[category].wlocale == NULL) && (ptloci->lc_category[category].wrefcount == NULL)));
        if ((ptloci->lc_category[category].wlocale != NULL) &&
              (ptloci->lc_category[category].wrefcount != NULL) &&
              (*ptloci->lc_category[category].wrefcount == 0) )
        {
            _free_crt(ptloci->lc_category[category].wrefcount);
        }
    }

    /*
     * Free up the threadlocinfo struct
     */
    _free_crt(ptloci);
}

/***
* __addlocaleref(pthreadlocinfo ptloci)
*
* Purpose:
*       Increment the refrence count for each element in the localeinfo struct.
*
*******************************************************************************/
void __cdecl __addlocaleref( pthreadlocinfo ptloci)
{
    int category;
    InterlockedIncrement(&(ptloci->refcount));
    if ( ptloci->lconv_intl_refcount != NULL )
        InterlockedIncrement(ptloci->lconv_intl_refcount);

    if ( ptloci->lconv_mon_refcount != NULL )
        InterlockedIncrement(ptloci->lconv_mon_refcount);

    if ( ptloci->lconv_num_refcount != NULL )
        InterlockedIncrement(ptloci->lconv_num_refcount);

    if ( ptloci->ctype1_refcount != NULL )
        InterlockedIncrement(ptloci->ctype1_refcount);

    for (category = LC_MIN; category <= LC_MAX; ++category) {
        if (ptloci->lc_category[category].locale != __clocalestr &&
            ptloci->lc_category[category].refcount != NULL)
            InterlockedIncrement(ptloci->lc_category[category].refcount);
        if (ptloci->lc_category[category].wlocale != NULL &&
            ptloci->lc_category[category].wrefcount != NULL)
            InterlockedIncrement(ptloci->lc_category[category].wrefcount);
    }
    InterlockedIncrement(&(ptloci->lc_time_curr->refcount));
}

/***
* __removelocaleref(pthreadlocinfo ptloci)
*
* Purpose:
*       Decrement the refrence count for each elemnt in the localeinfo struct.
*
******************************************************************************/
void * __cdecl __removelocaleref( pthreadlocinfo ptloci)
{
    int category;
    if ( ptloci != NULL )
    {
        InterlockedDecrement(&(ptloci->refcount));

        if ( ptloci->lconv_intl_refcount != NULL )
            InterlockedDecrement(ptloci->lconv_intl_refcount);

        if ( ptloci->lconv_mon_refcount != NULL )
            InterlockedDecrement(ptloci->lconv_mon_refcount);

        if ( ptloci->lconv_num_refcount != NULL )
            InterlockedDecrement(ptloci->lconv_num_refcount);

        if ( ptloci->ctype1_refcount != NULL )
            InterlockedDecrement(ptloci->ctype1_refcount);

        for (category = LC_MIN; category <= LC_MAX; ++category) {
            if (ptloci->lc_category[category].locale != __clocalestr &&
                ptloci->lc_category[category].refcount != NULL)
                InterlockedDecrement(ptloci->lc_category[category].refcount);
            if (ptloci->lc_category[category].wlocale != NULL &&
                ptloci->lc_category[category].wrefcount != NULL)
                InterlockedDecrement(ptloci->lc_category[category].wrefcount);
        }
        InterlockedDecrement(&(ptloci->lc_time_curr->refcount));
    }
    return ptloci;
}

/***
*
* _copytlocinfo_nolock(pthreadlocinfo ptlocid, pthreadlocinfo ptlocis)
*
* Purpose:
*       Copy the contents of ptlocis to ptlocid and increase the refcount of all the
*       elements in ptlocid after copy.
*
******************************************************************************/
static void __cdecl _copytlocinfo_nolock(
    pthreadlocinfo ptlocid,
    pthreadlocinfo ptlocis)
{
    if (ptlocis != NULL && ptlocid != NULL && ptlocid != ptlocis) {
        *ptlocid = *ptlocis;
        ptlocid->refcount = 0;
        __addlocaleref(ptlocid);
    }
}

/***
*
* _updatelocinfoEx_nolock(pthreadlocinfo *pptlocid, pthreadlocinfo ptlocis)
*
* Purpose:
*       Update *pptlocid to ptlocis. This might include freeing contents of *pptlocid.
*
******************************************************************************/
static pthreadlocinfo __cdecl _updatetlocinfoEx_nolock(
    pthreadlocinfo *pptlocid,
    pthreadlocinfo ptlocis)
{
    pthreadlocinfo ptloci;

    if (ptlocis == NULL || pptlocid == NULL)
        return NULL;
    ptloci = *pptlocid;
    if ( ptloci != ptlocis)
    {
        /*
         * Update to the current locale info structure and increment the
         * reference counts.
         */
        *pptlocid = ptlocis;
        __addlocaleref(ptlocis);
        /*
         * Decrement the reference counts in the old locale info
         * structure.
         */
        if ( ptloci != NULL )
        {
            __removelocaleref(ptloci);
        }
        /*
         * Free the old locale info structure, if necessary.  Must be done
         * after incrementing reference counts in current locale in case
         * any refcounts are shared with the old locale.
         */
        if ( (ptloci != NULL) &&
             (ptloci->refcount == 0) &&
             (ptloci != &__initiallocinfo) )
            __freetlocinfo(ptloci);

    }

    return ptlocis;
}

/***
*__updatetlocinfo() - refresh the thread's locale info
*
*Purpose:
*       If this thread does not have it's ownlocale which means that either
*       ownlocale flag in ptd is not set or ptd->ptloci == NULL, then Update
*       the current thread's reference to the locale information to match the
*       current global locale info. Decrement the reference on the old locale
*       information struct and if this count is now zero (so that no threads
*       are using it), free it.
*
*Entry:
*
*Exit:
*
*       if (!_getptd()->ownlocale || _getptd()->ptlocinfo == NULL)
*           _getptd()->ptlocinfo == __ptlocinfo
*       else
*           _getptd()->ptlocinfo
*
*Exceptions:
*
*******************************************************************************/
pthreadlocinfo __cdecl __updatetlocinfo(void)
{
    pthreadlocinfo ptloci;
    _ptiddata ptd = _getptd();

    if (!(ptd->_ownlocale & __globallocalestatus)|| !ptd->ptlocinfo) {
        _mlock(_SETLOCALE_LOCK);
        __try
        {
            ptloci = _updatetlocinfoEx_nolock(&ptd->ptlocinfo, __ptlocinfo);
        }
        __finally
        {
            _munlock(_SETLOCALE_LOCK);
        }
    } else {
        ptloci = _getptd()->ptlocinfo;
    }
    if(!ptloci)
    {
        _amsg_exit(_RT_LOCALE);
    }

    return ptloci;
}

/***
* _configthreadlocale(int i)
*
* Purpose:
*       To set _ownlocale flag on threadinfo sturct. If this flag is set, this thread
*       is going own it's threadlocinfo struct. Setlocale call on other thread will have
*       no effect on this thread's locale. If 0 is passed then nothing is changed, but
*       current status is returned.
* Exit   :
*       Returns the current status - i.e. per thread locale is enabled or not.
*
*******************************************************************************/
int __cdecl _configthreadlocale(int i)
{
    /*
     * ownlocale flag struct:
     * bits: 000000000000000000000000000000P1
     * P is set when _ENABLE_PER_THREAD_LOCALE is called for this thread
     * or _ENABLE_PER_THREAD_LOCALE_NEW was set when this thread was created.
     *
     * __globallocalestatus structure:
     * bits: 11111111111111111111111111111N1G
     * G is set if _ENABLE_PER_THREAD_LOCALE_GLOBAL is set.
     * G is 0 if _ENABLE_PER_THREAD_LOCALE_GLOBAL is not set.
     * N is set if _ENABLE_PER_THREAD_LOCALE_NEW is set.
     * N is 0 if _ENABLE_PER_THREAD_LOCALE_NEW is not set.
     */
    _ptiddata ptd = _getptd();
    int retval = (ptd->_ownlocale & _PER_THREAD_LOCALE_BIT)==0 ? _DISABLE_PER_THREAD_LOCALE:_ENABLE_PER_THREAD_LOCALE;

    switch(i)
    {
        case _ENABLE_PER_THREAD_LOCALE :
            ptd->_ownlocale = ptd->_ownlocale | _PER_THREAD_LOCALE_BIT;
            break;

        case _DISABLE_PER_THREAD_LOCALE :
            ptd->_ownlocale = ptd->_ownlocale & ~_PER_THREAD_LOCALE_BIT;
            break;

        case 0 :
            break;

        /* used only during dll startup for linkopt */
        case -1 :
            __globallocalestatus=-1;
            break;

        default :
            _VALIDATE_RETURN(("Invalid parameter for _configthreadlocale",0),EINVAL,-1);
            break;
    }

    return retval;

}

#ifdef _DEBUG
void __cdecl _locterm(void)
{
    if (__ptlocinfo != &__initiallocinfo) {
        _mlock(_SETLOCALE_LOCK);
        __try
        {
            __ptlocinfo = _updatetlocinfoEx_nolock(&__ptlocinfo, &__initiallocinfo);
        }
        __finally
        {
            _munlock(_SETLOCALE_LOCK);
        }
    }
}
#endif  /* _DEBUG */

/***
* void sync_legacy_variables_lk()
*
* Purpose:
*   Syncs all the legacy locale specific variables to the global locale.
*
*******************************************************************************/
static __inline void sync_legacy_variables_lk()
{
    __lc_codepage = __ptlocinfo->lc_codepage;
    __lc_collate_cp = __ptlocinfo->lc_collate_cp;
    __lc_clike = __ptlocinfo->lc_clike;
    __lc_time_curr = __ptlocinfo->lc_time_curr;
    __lconv = __ptlocinfo->lconv;
    _pctype = __ptlocinfo->pctype;
    __mb_cur_max = __ptlocinfo->mb_cur_max;
}
/***
*_free_locale() - free threadlocinfo
*
*Purpose:
*       Free up the per-thread locale info structure specified by the passed
*       pointer.
*
*Entry:
*       pthreadlocinfo ptloci
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _free_locale(
        _locale_t plocinfo
        )
{
    if (plocinfo != NULL)
    {
        _mlock(_MB_CP_LOCK);
        __try
        {
            if (plocinfo->mbcinfo != NULL &&
                    InterlockedDecrement(&(plocinfo->mbcinfo->refcount)) == 0 &&
                    plocinfo->mbcinfo != &__initialmbcinfo )
            {
                _free_crt(plocinfo->mbcinfo);
            }
        }
        __finally
        {
            _munlock(_MB_CP_LOCK);
        }
        if (plocinfo->locinfo != NULL)
        {
            /*
             * this portion has to be in locale lock as there may be case when
             * not this thread but some other thread is still holding to this
             * locale and is also trying to free this locale. In this case
             * we may end up leaking memory.
             */
            _mlock(_SETLOCALE_LOCK);
            __try
            {
                __removelocaleref(plocinfo->locinfo);
                if ( (plocinfo->locinfo != NULL) &&
                     (plocinfo->locinfo->refcount == 0) &&
                     (plocinfo->locinfo != &__initiallocinfo) )
                    __freetlocinfo(plocinfo->locinfo);
            }
            __finally
            {
                _munlock(_SETLOCALE_LOCK);
            }
        }
        /*
         * set plocinfo structure to zero. This will reduce the chance of
         * using plocinfo after it is being freed.
         */
        plocinfo->locinfo = (void *)(((char *)NULL) + 0xbaadf00d);
        plocinfo->mbcinfo = (void *)(((char *)NULL) + 0xbaadf00d);
        _free_crt(plocinfo);
    }
}

/* __free_locale will be removed in the next LKG */
void __cdecl __free_locale(
        _locale_t plocinfo
        )
{
    _free_locale(plocinfo);
}

/***
* _locale_t _create_locale(int category, char *locale) -
*    Set one or all locale categories of global locale structure
*
* Purpose:
*       The _create_locale() routine allows the user to create a _locale_t
*       object that can be used with other locale functions.
*
* Entry:
*       int category = One of the locale categories defined in locale.h
*       char *locale = String identifying a specific locale.
*
* Exit:
*       If supplied locale pointer != NULL:
*
*           If locale string is '\0', set locale to default.
*
*           If desired setting can be honored, return a pointer to the
*           locale string for the appropriate category.
*
*           If desired setting can NOT be honored, return NULL.
*
* Exceptions:
*       Compound locale strings of the form "LC_COLLATE=xxx;LC_CTYPE=xxx;..."
*       are allowed for the LC_ALL category.  This is to support the ability
*       to restore locales with the returned string, as specified by ANSI.
*       Setting the locale with a compound locale string will succeed unless
*       *all* categories failed.  The returned string will reflect the current
*       locale.  For example, if LC_CTYPE fails in the above string, setlocale
*       will return "LC_COLLATE=xxx;LC_CTYPE=yyy;..." where yyy is the
*       previous locale (or the C locale if restoring the previous locale
*       also failed).  Unrecognized LC_* categories are ignored.
*
*******************************************************************************/

_locale_t __cdecl _create_locale(
        int _category,
        const char *_locale
        )
{
    _locale_t retval = NULL;

    /* Validate input */
    if ( (_category < LC_MIN) || (_category > LC_MAX) || _locale == NULL)
        return NULL;

    if ((retval = _calloc_crt(sizeof(_locale_tstruct), 1)) == NULL)
    {
        errno = ENOMEM;
        return NULL;
    }
    if ((retval->locinfo = _calloc_crt(sizeof(threadlocinfo), 1)) == NULL)
    {
        _free_crt(retval);
        errno = ENOMEM;
        return NULL;
    }
    if ((retval->mbcinfo = _calloc_crt(sizeof(threadmbcinfo), 1)) == NULL)
    {
        _free_crt(retval->locinfo);
        _free_crt(retval);
        errno = ENOMEM;
        return NULL;
    }
    _copytlocinfo_nolock(retval->locinfo, &__initiallocinfo);

    if (_setlocale_nolock(retval->locinfo, _category, _locale) == NULL)
    {
        __removelocaleref(retval->locinfo);
        __freetlocinfo(retval->locinfo);

        _free_crt(retval);
        retval = NULL;
    }
    else
    {
        if (_setmbcp_nolock(retval->locinfo->lc_codepage, retval->mbcinfo) != 0)
        {
            _free_crt(retval->mbcinfo);
            __removelocaleref(retval->locinfo);
            __freetlocinfo(retval->locinfo);
            _free_crt(retval);
            retval = NULL;
        }
        else
        {
            retval->mbcinfo->refcount = 1;
            retval->mbcinfo->refcount = 1;
        }
    }

    return retval;
}

/* __create_locale will be removed in the next LKG */
_locale_t __cdecl __create_locale(
        int _category,
        const char *_locale
        )
{
    return _create_locale(_category, _locale);
}

/***
* _locale_t _get_current_locale() -
*    Gets the current locale setting.
*
* Purpose:
*       Gets the current locale setting for this thread. Returns locale
*       in form of _locale_t, which then can be used with other locale
*       aware string funcitons.
*
* Entry:
*
* Exit:
*
* Exceptions:
*
*******************************************************************************/

_locale_t __cdecl _get_current_locale(void)
{
    _locale_t retval = NULL;
    _ptiddata ptd = _getptd();

    if ((retval = _calloc_crt(sizeof(_locale_tstruct), 1)) == NULL)
    {
        errno = ENOMEM;
        return NULL;
    }

    __updatetlocinfo();
    __updatetmbcinfo();
    /*
     * No one can free the data pointed to by ptlocinfo while we're copying
     * it, since we're copying this thread's ptlocinfo, which won't be updated
     * during the copy.  So there are no worries about it being freed from
     * under us.  We still need a lock while adding a reference for the new
     * copy, though, because of the race condition found in _wsetlocale.
     */
    retval->locinfo = ptd->ptlocinfo;
    retval->mbcinfo = ptd->ptmbcinfo;
    _mlock(_SETLOCALE_LOCK);
    __try {
        __addlocaleref(retval->locinfo);
    }
    __finally {
        _munlock(_SETLOCALE_LOCK);
    }
    _mlock(_MB_CP_LOCK);
    __try
    {
        InterlockedIncrement(&(retval->mbcinfo->refcount));
    }
    __finally
    {
        _munlock(_MB_CP_LOCK);
    }

    return retval;
}

/* __get_current_locale will be removed in the next LKG */
_locale_t __cdecl __get_current_locale(void)
{
    return _get_current_locale();
}

/***
*char * setlocale(int category, char *locale) - Set one or all locale categories
*
*Purpose:
*       The setlocale() routine allows the user to set one or more of
*       the locale categories to the specific locale selected by the
*       user.  [ANSI]
*
*       NOTE: Under !_INTL, the C libraries only support the "C" locale.
*       Attempts to change the locale will fail.
*
*Entry:
*       int category = One of the locale categories defined in locale.h
*       char *locale = String identifying a specific locale or NULL to
*                  query the current locale.
*
*Exit:
*       If supplied locale pointer == NULL:
*
*           Return pointer to current locale string and do NOT change
*           the current locale.
*
*       If supplied locale pointer != NULL:
*
*           If locale string is '\0', set locale to default.
*
*           If desired setting can be honored, return a pointer to the
*           locale string for the appropriate category.
*
*           If desired setting can NOT be honored, return NULL.
*
*Exceptions:
*       Compound locale strings of the form "LC_COLLATE=xxx;LC_CTYPE=xxx;..."
*       are allowed for the LC_ALL category.  This is to support the ability
*       to restore locales with the returned string, as specified by ANSI.
*       Setting the locale with a compound locale string will succeed unless
*       *all* categories failed.  The returned string will reflect the current
*       locale.  For example, if LC_CTYPE fails in the above string, setlocale
*       will return "LC_COLLATE=xxx;LC_CTYPE=yyy;..." where yyy is the
*       previous locale (or the C locale if restoring the previous locale
*       also failed).  Unrecognized LC_* categories are ignored.
*
*******************************************************************************/

#if !defined (_WIN32)

char * __cdecl setlocale (
        int _category,
        const char *_locale
        )
{
    if ( (_locale == NULL) ||
         (_locale[0] == '\0') ||
         ( (_locale[0]=='C') && (_locale[1]=='\0'))  )
        return(__clocalestr);
    else
        return(NULL);
}

#else  /* !defined (_WIN32) */

char * __cdecl setlocale (
        int _category,
        const char *_locale
        )
{
    char * retval=NULL;
    pthreadlocinfo ptloci = NULL;
    _ptiddata ptd;

    /* Validate category */
    _VALIDATE_RETURN(LC_MIN <= _category && _category <= LC_MAX, EINVAL, NULL);

    ptd = _getptd();

    __updatetlocinfo();
    // Note here that we increment the _ownlocale for this thread. We need this
    // to make sure that the locale is not updated to some other locale by call to
    // stricmp().
    // Don't set any flag that aligns with N, P or G
    ptd->_ownlocale |= 0x10;
    __try {
        if ((ptloci = _calloc_crt(sizeof(threadlocinfo), 1)) != NULL)
        {
            /*
             * No one can free the data pointed to by ptlocinfo while we're
             * copying it, since we're copying this thread's ptlocinfo, which
             * won't be updated during the copy.  So there are no worries
             * about it being freed from under us.  We still need a lock while
             * making the copy, though, because of the race condition found in
             * _wsetlocale.
             */
            _mlock(_SETLOCALE_LOCK);
            __try {
                _copytlocinfo_nolock(ptloci, ptd->ptlocinfo);
            }
            __finally {
                _munlock(_SETLOCALE_LOCK);
            }

            if (( ptloci != NULL) && (retval = _setlocale_nolock(ptloci, _category, _locale))) {
                /*
                * What we are trying here is that if no call has been made to
                * setlocale to change locale from "C" locale to some other locale
                * we keep __locale_changed = 0. Other funcitons depending on locale
                * use this variable to optimize performance for C locale which is
                * normally the case in 90% of the applications.
                */
                if (_locale != NULL && strcmp(_locale, __clocalestr))
                {
                    __locale_changed = 1;
                }

                _mlock(_SETLOCALE_LOCK);
                __try {
                    (void)_updatetlocinfoEx_nolock(&ptd->ptlocinfo, ptloci);
                    __removelocaleref(ptloci);
                    // Note that after incrementing _ownlocale, if this thread doesn't
                    // have it's own locale, _ownlocale variable should be 1.
                    if (!(ptd->_ownlocale & _PER_THREAD_LOCALE_BIT) &&
                        !(__globallocalestatus & _GLOBAL_LOCALE_BIT)) {
                        (void)_updatetlocinfoEx_nolock(&__ptlocinfo, ptd->ptlocinfo);
                        // All these variables are for backward compatiblity.
                        memcpy(__lc_handle, __ptlocinfo->lc_handle, sizeof(LCID)*(LC_MAX-LC_MIN+1));
                        sync_legacy_variables_lk();
                    }
                } __finally {
                    _munlock(_SETLOCALE_LOCK);
                }
            } else {
                __removelocaleref(ptloci);
                __freetlocinfo(ptloci);
            }
        }
    } __finally {
        // Undo the previous action.
        ptd->_ownlocale &= ~0x10;
    }

    return retval;
}

static char * __cdecl _setlocale_nolock(
        pthreadlocinfo ploci,
        int _category,
        const char *_locale
        )
{
    char * retval;
    /* Interpret locale */

    if (_category != LC_ALL)
    {
        retval = (_locale) ? _setlocale_set_cat(ploci, _category,_locale) :
            ploci->lc_category[_category].locale;

    } else { /* LC_ALL */
        char lctemp[MAX_LC_LEN];
        int i;
        int same = 1;
        int fLocaleSet = 0; /* flag to indicate if anything successfully set */

        if (_locale != NULL)
        {
            if ( (_locale[0]=='L') && (_locale[1]=='C') && (_locale[2]=='_') )
            {
                /* parse compound locale string */
                size_t len;
                const char * p = _locale;  /* start of string to parse */
                const char * s;

                do {
                    s = strpbrk(p,"=;");

                    if ((s==(char *)NULL) || (!(len=(size_t)(s-p))) || (*s==';'))
                        return NULL;  /* syntax error */

                    /* match with known LC_ strings, if possible, else ignore */
                    for (i=LC_ALL+1; i<=LC_MAX; i++)
                    {
                        if ((!strncmp(__lc_category[i].catname,p,len))
                            && (len==strlen(__lc_category[i].catname)))
                        {
                            break;  /* matched i */
                        }
                    } /* no match if (i>LC_MAX) -- just ignore */

                    if ((!(len = strcspn(++s,";"))) && (*s!=';'))
                        return NULL;  /* syntax error */

                    if (i<=LC_MAX)
                    {
                        _ERRCHECK(strncpy_s(lctemp, _countof(lctemp), s, len));
                        lctemp[len]='\0';   /* null terminate string */

                        /* don't fail unless all categories fail */
                        if (_setlocale_set_cat(ploci, i,lctemp))
                            fLocaleSet++;       /* record a success */
                    }
                    if (*(p = s+len)!='\0')
                        p++;  /* skip ';', if present */

                } while (*p);

                retval = (fLocaleSet) ? _setlocale_get_all(ploci) : NULL;

            } else { /* simple LC_ALL locale string */

                /* confirm locale is supported, get expanded locale */
                if (retval = _expandlocale((char *)_locale, lctemp, _countof(lctemp), NULL, NULL, _category))
                {
                    for (i=LC_MIN; i<=LC_MAX; i++)
                    {
                        if (i!=LC_ALL)
                        {
                            if (strcmp(lctemp, ploci->lc_category[i].locale))
                            {
                                if (_setlocale_set_cat(ploci, i, lctemp))
                                {
                                    fLocaleSet++;   /* record a success */
                                }
                                else
                                {
                                    same = 0;       /* record a failure */
                                }
                            }
                            else
                                fLocaleSet++;   /* trivial succcess */
                        }
                    }
                    if (same) /* needn't call setlocale_get_all() if all the same */
                    {
                        retval = _setlocale_get_all(ploci);
                        /* retval set above */
                    }
                    else
                        retval = (fLocaleSet) ? _setlocale_get_all(ploci) : NULL;
                }
            }
        } else { /* LC_ALL & NULL */
            retval = _setlocale_get_all (ploci);
        }
    }

    /* common exit point */
    return retval;
} /* setlocale */


static char * __cdecl _setlocale_set_cat (
        pthreadlocinfo ploci,
        int category,
        const char * locale
        )
{
    char * oldlocale;
    LCID oldhandle;
    UINT oldcodepage;
    LC_ID oldid;

    LC_ID idtemp;
    UINT cptemp;
    char lctemp[MAX_LC_LEN];
    char * pch = NULL;
    size_t cch = 0;
    short out[sizeof(_first_127char)];
    int i;
    _ptiddata _ptd = _getptd();
    struct _is_ctype_compatible *_Lcid_c = _ptd->_setloc_data._Lcid_c; // __setloc_data._Lcid_c is array
    int _LOC_CCACHE = sizeof(_ptd->_setloc_data._Lcid_c)/sizeof(struct _is_ctype_compatible);
    struct _is_ctype_compatible buf1, buf2;

    if (!_expandlocale((char *)locale, lctemp, _countof(lctemp), &idtemp, &cptemp, category))
    {
        return NULL;            /* unrecognized locale */
    }
    if (!strcmp(lctemp, ploci->lc_category[category].locale))
    {
        return ploci->lc_category[category].locale;
    }

    cch = sizeof(int)+strlen(lctemp)+1;
    if (!(pch = (char *)_malloc_crt(cch)))
    {
        return NULL;  /* error if malloc fails */
    }

    oldlocale = ploci->lc_category[category].locale; /* save for possible restore*/
    oldhandle = ploci->lc_handle[category];
    memcpy((void *)&oldid, (void *)&ploci->lc_id[category], sizeof(oldid));
    oldcodepage = ploci->lc_codepage;

    /* update locale string */
    _ERRCHECK(strcpy_s(pch + sizeof(int), cch - sizeof(int), lctemp));
    ploci->lc_category[category].locale = pch + sizeof(int);
    ploci->lc_handle[category] = MAKELCID(idtemp.wLanguage, SORT_DEFAULT);
    memcpy((void *)&ploci->lc_id[category], (void *)&idtemp, sizeof(idtemp));

    /* To speedup locale based comparisions, we identify if the current
     * local has first 127 character set same as CLOCALE. If yes then
     * ploci->lc_clike = TRUE.
     */

    if (category==LC_CTYPE)
    {
        ploci->lc_codepage = cptemp;
        buf1 = _Lcid_c[_LOC_CCACHE -1];
        /* brings the recently used codepage to the top. or else shifts
         * every thing down by one so that new _Lcid_c can be placed at
         * the top.
         */
        for ( i = 0; i < _LOC_CCACHE; i++)
        {
            if (ploci->lc_codepage == _Lcid_c[i].id)
            {
                /* We don't really want to swap cache around in case what we are looking
                 *  for is the first element of the cache
                 */
                if (i!=0)
                {
                    _Lcid_c[0] = _Lcid_c[i];
                    _Lcid_c[i] = buf1;
                }
                break;
            }
            else
            {
                buf2 = _Lcid_c[i];
                _Lcid_c[i] = buf1;
                buf1 = buf2;
            }
        }
        if ( i == _LOC_CCACHE)
        {
            if ( __crtGetStringTypeA(NULL, CT_CTYPE1,
                                      _first_127char,
                                      sizeof(_first_127char),
                                      out,
                                      ploci->lc_codepage,
                                      ploci->lc_handle[LC_CTYPE],
                                      TRUE ))
            {
                int j;
                for ( j = 0; j < sizeof(_first_127char); j++)
                    out[j] = out[j]&
                            (_UPPER|_LOWER|_DIGIT|_SPACE|_PUNCT|_CONTROL|_BLANK|_HEX|_ALPHA);
                if ( !memcmp(out, _ctype_loc_style, (sizeof(_first_127char)/sizeof(char))*sizeof(short)))
                {
                    _Lcid_c[0].is_clike = TRUE;
                }
                else
                {
                    _Lcid_c[0].is_clike = FALSE;
                }
            }
            else
                _Lcid_c[0].is_clike = FALSE;
            _Lcid_c[0].id = ploci->lc_codepage;
        }
        ploci->lc_clike = _Lcid_c[0].is_clike;
    }

    if ( category == LC_COLLATE )
        ploci->lc_collate_cp = cptemp;

    if (__lc_category[category].init(ploci))
    {
        /* restore previous state! */
        ploci->lc_category[category].locale = oldlocale;
        _free_crt(pch);
        ploci->lc_handle[category] = oldhandle;
        ploci->lc_codepage = oldcodepage;

        return NULL; /* error if non-zero return */
    }

    /* locale set up successfully */
    /* Cleanup */
    if ((oldlocale != __clocalestr) &&
        (InterlockedDecrement(ploci->lc_category[category].refcount) == 0)
        )
    {
        _ASSERT(0);
        _free_crt(ploci->lc_category[category].refcount);
        _free_crt(ploci->lc_category[category].wrefcount);
        ploci->lc_category[category].wlocale = NULL;
    }
    if (pch) {
        *(int *)pch  = 1;
    }
    ploci->lc_category[category].refcount = (int *)pch;

    return ploci->lc_category[category].locale;
} /* _setlocale_set_cat */



static char * __cdecl _setlocale_get_all ( pthreadlocinfo ploci)
{
    int i;
    int same = 1;
    char *pch = NULL;
    size_t cch = 0;
    int *refcount = NULL;
    size_t refcountSize = 0;
    /* allocate memory if necessary */
    refcountSize = sizeof(int)+(MAX_LC_LEN+1) * (LC_MAX-LC_MIN+1) + CATNAMES_LEN;
    if ( (refcount = _malloc_crt(refcountSize))
           == NULL)
        return NULL;

    pch = (char *)(refcount + 1);
    cch = refcountSize - sizeof(int);
    *pch = '\0';
    *refcount = 1;
    for (i=LC_MIN+1; ; i++)
    {
        _strcats(pch, cch, 3, __lc_category[i].catname,"=",ploci->lc_category[i].locale);
        if (i<LC_MAX)
        {
            _ERRCHECK(strcat_s(pch, cch, ";"));
            if (strcmp(ploci->lc_category[i].locale, ploci->lc_category[i+1].locale))
                same=0;
        }
        else
        {
            if (!same) {
                if (ploci->lc_category[LC_ALL].refcount != NULL &&
                    InterlockedDecrement(ploci->lc_category[LC_ALL].refcount) == 0) {
                    _ASSERT(0);
                    _free_crt(ploci->lc_category[LC_ALL].refcount);
                }
                if (ploci->lc_category[LC_ALL].wrefcount != NULL &&
                    InterlockedDecrement(ploci->lc_category[LC_ALL].wrefcount) == 0) {
                    _ASSERT(0);
                    _free_crt(ploci->lc_category[LC_ALL].wrefcount);
                }
                ploci->lc_category[LC_ALL].wrefcount = NULL;
                ploci->lc_category[LC_ALL].wlocale = NULL;
                ploci->lc_category[LC_ALL].refcount = refcount;
                return ploci->lc_category[LC_ALL].locale = pch;
            } else {
                _free_crt(refcount);
                if (ploci->lc_category[LC_ALL].refcount != NULL &&
                    InterlockedDecrement(ploci->lc_category[LC_ALL].refcount) == 0) {
                    _ASSERT(0);
                    _free_crt(ploci->lc_category[LC_ALL].refcount);
                }
                if (ploci->lc_category[LC_ALL].wrefcount != NULL &&
                    InterlockedDecrement(ploci->lc_category[LC_ALL].wrefcount) == 0) {
                    _ASSERT(0);
                    _free_crt(ploci->lc_category[LC_ALL].wrefcount);
                }
                ploci->lc_category[LC_ALL].wrefcount = NULL;
                ploci->lc_category[LC_ALL].wlocale = NULL;
                ploci->lc_category[LC_ALL].refcount = NULL;
                ploci->lc_category[LC_ALL].locale = NULL;
                return ploci->lc_category[LC_CTYPE].locale;
            }
        }
    }
} /* _setlocale_get_all */


char * _expandlocale (
        char *expr,
        char * output,
        size_t sizeInChars,
        LC_ID * id,
        UINT * cp,
        int category
        )
{
    _psetloc_struct _psetloc_data = &_getptd()->_setloc_data;
    UINT *pcachecp = &_psetloc_data->_cachecp;
    LC_ID *pcacheid = &_psetloc_data->_cacheid;
    char *cachein = _psetloc_data->_cachein;
    size_t cacheinSize = _countof(_psetloc_data->_cachein);
    char *cacheout = _psetloc_data->_cacheout;
    size_t cacheoutSize = _countof(_psetloc_data->_cacheout);
    size_t charactersInExpression = 0;

    if (!expr)
        return NULL; /* error if no input */

    if (output == NULL || sizeInChars == 0)
        return NULL; /* error if no output */


    if (((*expr=='C') && (!expr[1]))
        )  /* for "C" locale, just return */
    {

        _ERRCHECK(strcpy_s(output, sizeInChars, "C"));
        if (id)
        {
            id->wLanguage = 0;
            id->wCountry  = 0;
            id->wCodePage = 0;
        }
        if (cp)
        {
            *cp = CP_ACP; /* return to ANSI code page */
        }
        return output; /* "C" */
    }

    /* first, make sure we didn't just do this one */
    charactersInExpression = strlen(expr);
    if (charactersInExpression >= MAX_LC_LEN ||       /* we would never have cached this */
        (strcmp(cacheout,expr) && strcmp(cachein,expr)))
    {
        /* do some real work */
        LC_STRINGS names;
        const char *source=NULL;
        size_t charactersInSource = 0;

        if (__lc_strtolc(&names, expr))
            return NULL;  /* syntax error */

        if (!__get_qualified_locale(&names, pcacheid, &names))
            return NULL;    /* locale not recognized/supported */

        /* begin: cache atomic section */

        *pcachecp = pcacheid->wCodePage;

        __lc_lctostr(cacheout, cacheoutSize, &names);

        if (*expr && charactersInExpression < MAX_LC_LEN)
        {
            source = expr;
            charactersInSource = charactersInExpression;
        }
        else
        {
            /* Don't cache "" empty string or over-long string */
            source = "";
        }
        /* Ensure that whatever we are about to copy in will be null terminated */

        _ERRCHECK(strncpy_s(cachein, cacheinSize, source, charactersInSource + 1));

        /* end: cache atomic section */
    }
    if (id)
        memcpy((void *)id, (void *)pcacheid, sizeof(*pcacheid));   /* possibly return LC_ID */
    if (cp)
        memcpy((void *)cp, (void *)pcachecp, sizeof(*pcachecp));   /* possibly return cp */

    _ERRCHECK(strcpy_s(output, sizeInChars, cacheout));
    return cacheout; /* return fully expanded locale string */
}

/* helpers */

int __cdecl __init_dummy(pthreadlocinfo ploci)  /* default routine for locale initializer */
{
        return 0;
}

void _strcats ( char *outstr, size_t sizeInBytes, int n, ...)
{
    int i;
    va_list substr;

    va_start (substr, n);

    for (i =0; i<n; i++)
    {
        _ERRCHECK(strcat_s(outstr, sizeInBytes, va_arg(substr, char *)));
    }
    va_end(substr);
}

int __lc_strtolc ( LC_STRINGS *names, const char *locale)
{
    int i;
    size_t len;
    char ch;

    memset((void *)names, '\0', sizeof(LC_STRINGS));  /* clear out result */

    if (*locale=='\0')
        return 0; /* trivial case */

    /* only code page is given */
    if (locale[0] == '.' && locale[1] != '\0')
    {
        _ERRCHECK(strncpy_s(names->szCodePage, _countof(names->szCodePage), &locale[1], MAX_CP_LEN-1));
        /* Make sure to null terminate the string in case locale is > MAX_CP_LEN */
        names->szCodePage[ MAX_CP_LEN -1] = 0;
        return 0;
    }

    for (i=0; ; i++)
    {
        if (!(len=strcspn(locale,"_.,")))
            return -1;  /* syntax error */

        ch = locale[len];

        if ((i==0) && (len<MAX_LANG_LEN) && (ch!='.'))
            _ERRCHECK(strncpy_s(names->szLanguage, _countof(names->szLanguage), locale, len));

        else if ((i==1) && (len<MAX_CTRY_LEN) && (ch!='_'))
            _ERRCHECK(strncpy_s(names->szCountry, _countof(names->szCountry), locale, len));

        else if ((i==2) && (len<MAX_CP_LEN) && (ch=='\0' || ch==','))
            _ERRCHECK(strncpy_s(names->szCodePage, _countof(names->szCodePage), locale, len));

        else
            return -1;  /* error parsing locale string */

        if (ch==',')
        {
            /* modifier not used in current implementation, but it
               must be parsed to for POSIX/XOpen conformance */
        /*  strncpy(names->szModifier, locale, MAX_MODIFIER_LEN-1); */
            break;
        }

        if (!ch)
            break;
        locale+=(len+1);
    }
    return 0;
}

void __lc_lctostr ( char *locale, size_t sizeInBytes, const LC_STRINGS *names)
{
    _ERRCHECK(strcpy_s(locale, sizeInBytes, (char *)names->szLanguage));
    if (*(names->szCountry))
        _strcats(locale, sizeInBytes, 2, "_", names->szCountry);
    if (*(names->szCodePage))
        _strcats(locale, sizeInBytes, 2, ".", names->szCodePage);
}


#endif  /* !defined (_WIN32) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnvp.c ===
/***
*spawnvp.c - spawn a child process; search along PATH
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnvp() - spawn a child process; search along PATH
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

/***
*int _spawnvp(modeflag, filename, argv) - spawn a child process (search PATH)
*
*Purpose:
*       Spawns a child process, with search along PATH variable.
*       formats the parameters and calls _spawnve to do the actual work. The
*       NULL environment pointer indicates the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                        only WAIT and OVERLAY currently supported
*       _TSCHAR *pathname - name of file to spawn
*       _TSCHAR **argv    - vector of arguments
*
*Exit:
*       returns exit code of child process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnvp (
        int modeflag,
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argv
        )
{
        return _tspawnvpe(modeflag, filename, argv, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnvpe.c ===
/***
*spawnvpe.c - spawn a child process with given environ (search PATH)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnvpe() - spawn a child process with given environ (search
*       PATH)
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <internal.h>
#include <process.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASH _T("\\")
#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')
#define DELIMITER _T(";")

#ifdef _MBCS
/* note, the macro below assumes p is to pointer to a single-byte character
 * or the 1st byte of a double-byte character, in a string.
 */
#define ISPSLASH(p)     ( ((p) == _mbschr((p), SLASHCHAR)) || ((p) == \
_mbschr((p), XSLASHCHAR)) )
#else  /* _MBCS */
#define ISSLASH(c)      ( ((c) == SLASHCHAR) || ((c) == XSLASHCHAR) )
#endif  /* _MBCS */

/***
*_spawnvpe(modeflag, filename, argv, envptr) - spawn a child process
*
*Purpose:
*       Spawns a child process with the given arguments and environ,
*       searches along PATH for given file until found.
*       Formats the parameters and calls _spawnve to do the actual work. The
*       NULL environment pointer indicates that the new process will inherit
*       the parents process's environment.  NOTE - at least one argument must
*       be present.  This argument is always, by convention, the name of the
*       file being spawned.
*
*Entry:
*       int modeflag - defines mode of spawn (WAIT, NOWAIT, or OVERLAY)
*                       only WAIT and OVERLAY supported
*       _TSCHAR *filename - name of file to execute
*       _TSCHAR **argv - vector of parameters
*       _TSCHAR **envptr - vector of environment variables
*
*Exit:
*       returns exit code of spawned process
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnvpe (
        int modeflag,
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envptr
        )
{
        intptr_t i;
        _TSCHAR *envbuf = NULL;
        REG1 _TSCHAR *env;
        REG2 _TSCHAR *buf = NULL;
        _TSCHAR *pfin;
        errno_t save_errno;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(argv != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*argv != NULL, EINVAL, -1);
        _VALIDATE_RETURN(**argv != _T('\0'), EINVAL, -1);


        save_errno = errno;
        errno = 0;

        if (
        (i = _tspawnve(modeflag, filename, argv, envptr)) != -1
                /* everything worked just fine; return i */

        || (errno != ENOENT)
                /* couldn't spawn the process, return failure */

        || (_tcschr(filename, XSLASHCHAR) != NULL)
                /* filename contains a '/', return failure */


        || (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envbuf, NULL, _T("PATH"))) != 0)
        || (envbuf == NULL)
                /* no PATH environment string name, return failure */

        || ( (buf = _calloc_crt(_MAX_PATH, sizeof(_TSCHAR))) == NULL )
                /* cannot allocate buffer to build alternate pathnames, return
                 * failure */
        ) {
                goto done;
        }



        /* could not find the file as specified, search PATH. try each
         * component of the PATH until we get either no error return, or the
         * error is not ENOENT and the component is not a UNC name, or we run
         * out of components to try.
         */

        env = envbuf;
#ifdef WPRFLAG
        while ( (env = _wgetpath(env, buf, _MAX_PATH - 1)) && (*buf) ) {
#else  /* WPRFLAG */
        while ( (env = _getpath(env, buf, _MAX_PATH - 1)) && (*buf) ) {
#endif  /* WPRFLAG */

                pfin = buf + _tcslen(buf) - 1;

                /* if necessary, append a '/'
                 */
#ifdef _MBCS
                if (*pfin == SLASHCHAR) {
                        if (pfin != _mbsrchr(buf,SLASHCHAR))
                        /* fin is the second byte of a double-byte char */
                                strcat_s(buf, _MAX_PATH, SLASH );
                }
                else if (*pfin !=XSLASHCHAR)
                        _ERRCHECK(strcat_s(buf, _MAX_PATH, SLASH));
#else  /* _MBCS */
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                        _ERRCHECK(_tcscat_s(buf, _MAX_PATH, SLASH));
#endif  /* _MBCS */
                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _spawnve()).
                 */
                if ( (_tcslen(buf) + _tcslen(filename)) < _MAX_PATH )
                        _ERRCHECK(_tcscat_s(buf, _MAX_PATH, filename));
                else
                        break;

                /* try spawning it. if successful, or if errno comes back with a
                 * value other than ENOENT and the pathname is not a UNC name,
                 * return to the caller.
                 */
                errno = 0;
                if ( (i = _tspawnve(modeflag, buf, argv, envptr)) != -1
                        || ((errno != ENOENT)
#ifdef _MBCS
                                && (!ISPSLASH(buf) || !ISPSLASH(buf+1))) )
#else  /* _MBCS */
                                && (!ISSLASH(*buf) || !ISSLASH(*(buf+1)))) )
#endif  /* _MBCS */
                        break;

        }

done:
        if (errno == 0)
        {
            errno = save_errno;
        }
        if (buf != NULL)
            _free_crt(buf);
        if (envbuf != NULL)
            _free_crt(envbuf);
        return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\splitpat.c ===
/***
*splitpath.c - break down path name into components
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To provide support for accessing the individual components of an
*       arbitrary path name
*
*******************************************************************************/


/* we don't want to fill up the buffers in debug to mantain back-compat */
#define _SECURECRT_FILL_BUFFER 0

#include <stdlib.h>
#ifdef _MBCS
#include <mbstring.h>
#endif  /* _MBCS */
#include <tchar.h>
#include <internal_securecrt.h>

/***
*_splitpath() - split a path name into its individual components
*
*Purpose:
*       to split a path name into its individual components
*
*Entry:
*       path  - pointer to path name to be parsed
*       drive - pointer to buffer for drive component, if any
*       dir   - pointer to buffer for subdirectory component, if any
*       fname - pointer to buffer for file base name component, if any
*       ext   - pointer to buffer for file name extension component, if any
*
*Exit:
*       drive - pointer to drive string.  Includes ':' if a drive was given.
*       dir   - pointer to subdirectory string.  Includes leading and trailing
*           '/' or '\', if any.
*       fname - pointer to file base name
*       ext   - pointer to file extension, if any.  Includes leading '.'.
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
#define _tsplitpath_helper _wsplitpath_helper
#else  /* _UNICODE */
#define _tsplitpath_helper _splitpath_helper
#endif  /* _UNICODE */

#define _FUNC_PROLOGUE static
#define _FUNC_NAME _tsplitpath_helper
#define _CHAR _TSCHAR

#ifndef _MBCS
#define _MBS_SUPPORT 0
#else  /* _MBCS */
#define _MBS_SUPPORT 1
/* _splitpath uses _ismbblead and not _ismbblead_l */
#undef _ISMBBLEAD
#define _ISMBBLEAD(_Character) \
    _ismbblead((_Character))
#endif  /* _MBCS */

/* _tsplitpath_helper does not call invalid_parameter if one of the buffer is too small */
#undef _RETURN_BUFFER_TOO_SMALL
#define _RETURN_BUFFER_TOO_SMALL(_String, _Size) \
    return (errno = ERANGE)

/* _tsplitpath_helper does not pad the string */
#define _TCSNCPY_S(_Dst, _Size, _Src, _Count) _tcsncpy_s((_Dst), ((size_t)-1), (_Src), (_Count))
#undef _RESET_STRING
#define _RESET_STRING(_String, _Size) \
    *(_String) = 0;

#include <tsplitpath_s.inl>

void __cdecl _tsplitpath (
        register const _TSCHAR *path,
        _TSCHAR *drive,
        _TSCHAR *dir,
        _TSCHAR *fname,
        _TSCHAR *ext
        )
{
    _tsplitpath_helper(
        path,
        drive, drive ? _MAX_DRIVE : 0,
        dir, dir ? _MAX_DIR : 0,
        fname, fname ? _MAX_FNAME : 0,
        ext, ext ? _MAX_EXT : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\snwprint.c ===
/***
*snwprintf.c - "Count" version of swprintf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       The _snwprintf() flavor takes a count argument that is
*       the max number of wide characters that should be written to
*       the user's buffer.
*
*******************************************************************************/


#define _COUNT_ 1
#include "swprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\snwscanf.c ===
/***
*snwscanf.c - read formatted data from string of given length
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines snwscanf() - reads formatted data from string of given length
*
*******************************************************************************/
#ifndef _UNICODE
#define _UNICODE
#endif  /* _UNICODE */
#ifndef UNICODE
#define UNICODE
#endif  /* UNICODE */
#define _SNSCANF
#include <wchar.h>
#include "sscanf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\sscanf.c ===
/***
*sscanf.c - read formatted data from string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines scanf() - reads formatted data from string
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*static int vscan_fn([w]inputfn, string, [count], format, ...)
*
*Purpose:
*       this is a helper function which is called by the other functions
*       in this file - sscanf/swscanf/snscanf etc. It calls either _(w)input or
*       _(w)input_s depending on the first parameter.
*
*******************************************************************************/
static int __cdecl vscan_fn (
        TINPUTFN inputfn,
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif  /* _SNSCANF */
        const _TCHAR *format,
        _locale_t plocinfo,
        va_list arglist
        )
/*
 * 'S'tring 'SCAN', 'F'ormatted
 */
{
        FILE str;
        REG1 FILE *infile = &str;
        REG2 int retval;
#ifndef _SNSCANF
        size_t count=_tcslen(string);
#endif  /* _SNSCANF */

        _VALIDATE_RETURN( (string != NULL), EINVAL, EOF);
        _VALIDATE_RETURN( (format != NULL), EINVAL, EOF);

        infile->_flag = _IOREAD|_IOSTRG|_IOMYBUF;
        infile->_ptr = infile->_base = (char *) string;

        if(count>(INT_MAX/sizeof(_TCHAR)))
        {
            /* old-style functions allow any large value to mean unbounded */
            infile->_cnt = INT_MAX;
        }
        else
        {
            infile->_cnt = (int)count*sizeof(_TCHAR);
        }

        retval = (inputfn(infile, format, plocinfo, arglist));

        return(retval);
}

/***
*int sscanf(string, format, ...) - read formatted data from string
*
*Purpose:
*       Reads formatted data from string into arguments.  _input does the real
*       work here.  Sets up a FILE so file i/o operations can be used, makes
*       string look like a huge buffer to it, but _filbuf will refuse to refill
*       it if it is exhausted.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - string to read data from
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
/***
*int snscanf(string, size, format, ...) - read formatted data from string of
*    given length
*
*Purpose:
*       Reads formatted data from string into arguments.  _input does the real
*       work here.  Sets up a FILE so file i/o operations can be used, makes
*       string look like a huge buffer to it, but _filbuf will refuse to refill
*       it if it is exhausted.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - string to read data from
*       size_t count - length of string
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
#ifdef _UNICODE
#ifdef _SNSCANF
int __cdecl _snwscanf (
#else  /* _SNSCANF */
int __cdecl swscanf (
#endif  /* _SNSCANF */
#else  /* _UNICODE */
#ifdef _SNSCANF
int __cdecl _snscanf (
#else  /* _SNSCANF */
int __cdecl sscanf (
#endif  /* _SNSCANF */
#endif  /* _UNICODE */
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif  /* _SNSCANF */
        const _TCHAR *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
#ifdef _SNSCANF
        return vscan_fn(_tinput_l, string, count, format, NULL, arglist);
#else  /* _SNSCANF */
        return vscan_fn(_tinput_l, string, format, NULL, arglist);
#endif  /* _SNSCANF */

}

#ifdef _UNICODE
#ifdef _SNSCANF
int __cdecl _snwscanf_l (
#else  /* _SNSCANF */
int __cdecl _swscanf_l (
#endif  /* _SNSCANF */
#else  /* _UNICODE */
#ifdef _SNSCANF
int __cdecl _snscanf_l (
#else  /* _SNSCANF */
int __cdecl _sscanf_l (
#endif  /* _SNSCANF */
#endif  /* _UNICODE */
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif  /* _SNSCANF */
        const _TCHAR *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
#ifdef _SNSCANF
        return vscan_fn(_tinput_l, string, count, format, plocinfo, arglist);
#else  /* _SNSCANF */
        return vscan_fn(_tinput_l, string, format, plocinfo, arglist);
#endif  /* _SNSCANF */

}

/***
*int sscanf_s(string, format, ...)
*   Same as sscanf above except that it calls _input_s to do the real work.
*
*int snscanf_s(string, size, format, ...)
*   Same as snscanf above except that it calls _input_s to do the real work.
*
*   _input_s has a size check for array parameters.
*
*******************************************************************************/
#ifdef _UNICODE
#ifdef _SNSCANF
int __cdecl _snwscanf_s (
#else  /* _SNSCANF */
int __cdecl swscanf_s (
#endif  /* _SNSCANF */
#else  /* _UNICODE */
#ifdef _SNSCANF
int __cdecl _snscanf_s (
#else  /* _SNSCANF */
int __cdecl sscanf_s (
#endif  /* _SNSCANF */
#endif  /* _UNICODE */
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif  /* _SNSCANF */
        const _TCHAR *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
#ifdef _SNSCANF
        return vscan_fn(_tinput_s_l, string, count, format, NULL, arglist);
#else  /* _SNSCANF */
        return vscan_fn(_tinput_s_l, string, format, NULL, arglist);
#endif  /* _SNSCANF */

}

#ifdef _UNICODE
#ifdef _SNSCANF
int __cdecl _snwscanf_s_l (
#else  /* _SNSCANF */
int __cdecl _swscanf_s_l (
#endif  /* _SNSCANF */
#else  /* _UNICODE */
#ifdef _SNSCANF
int __cdecl _snscanf_s_l (
#else  /* _SNSCANF */
int __cdecl _sscanf_s_l (
#endif  /* _SNSCANF */
#endif  /* _UNICODE */
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif  /* _SNSCANF */
        const _TCHAR *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
#ifdef _SNSCANF
        return vscan_fn(_tinput_s_l, string, count, format, plocinfo, arglist);
#else  /* _SNSCANF */
        return vscan_fn(_tinput_s_l, string, format, plocinfo, arglist);
#endif  /* _SNSCANF */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\smmintrin.h ===
/**
*** Copyright (C) 1985-2007 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * smmintrin.h
 *
 * Principal header file for Intel(R) Core(TM) 2 Duo processor
 * SSE4.1 intrinsics
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_SMM
#define _INCLUDED_SMM

#if defined (_M_CEE_PURE)
        #error ERROR: EMM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <tmmintrin.h>


/*
 * Rounding mode macros
 */

#define _MM_FROUND_TO_NEAREST_INT    0x00
#define _MM_FROUND_TO_NEG_INF        0x01
#define _MM_FROUND_TO_POS_INF        0x02
#define _MM_FROUND_TO_ZERO           0x03
#define _MM_FROUND_CUR_DIRECTION     0x04

#define _MM_FROUND_RAISE_EXC         0x00
#define _MM_FROUND_NO_EXC            0x08

#define _MM_FROUND_NINT      _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_RAISE_EXC
#define _MM_FROUND_FLOOR     _MM_FROUND_TO_NEG_INF     | _MM_FROUND_RAISE_EXC
#define _MM_FROUND_CEIL      _MM_FROUND_TO_POS_INF     | _MM_FROUND_RAISE_EXC
#define _MM_FROUND_TRUNC     _MM_FROUND_TO_ZERO        | _MM_FROUND_RAISE_EXC
#define _MM_FROUND_RINT      _MM_FROUND_CUR_DIRECTION  | _MM_FROUND_RAISE_EXC
#define _MM_FROUND_NEARBYINT _MM_FROUND_CUR_DIRECTION  | _MM_FROUND_NO_EXC

/*
 * MACRO functions for ceil/floor intrinsics
 */

#define _mm_ceil_pd(val)       _mm_round_pd((val), _MM_FROUND_CEIL);
#define _mm_ceil_sd(dst, val)  _mm_round_sd((dst), (val), _MM_FROUND_CEIL);

#define _mm_floor_pd(val)      _mm_round_pd((val), _MM_FROUND_FLOOR);
#define _mm_floor_sd(dst, val) _mm_round_sd((dst), (val), _MM_FROUND_FLOOR);

#define _mm_ceil_ps(val)       _mm_round_ps((val), _MM_FROUND_CEIL);
#define _mm_ceil_ss(dst, val)  _mm_round_ss((dst), (val), _MM_FROUND_CEIL);

#define _mm_floor_ps(val)      _mm_round_ps((val), _MM_FROUND_FLOOR);
#define _mm_floor_ss(dst, val) _mm_round_ss((dst), (val), _MM_FROUND_FLOOR);

#define _mm_test_all_zeros(mask, val)      _mm_testz_si128((mask), (val))

/*
 * MACRO functions for packed integer 128-bit comparison intrinsics.
 */

#define _mm_test_all_ones(val) \
              _mm_testc_si128((val), _mm_cmpeq_epi32((val),(val)))

#define _mm_test_mix_ones_zeros(mask, val) _mm_testnzc_si128((mask), (val))

#if __cplusplus
extern "C" {
#endif  /* __cplusplus */

        // Integer blend instructions - select data from 2 sources
        // using constant/variable mask

        extern __m128i _mm_blend_epi16 (__m128i v1, __m128i v2,
                                        const int mask);
        extern __m128i _mm_blendv_epi8 (__m128i v1, __m128i v2, __m128i mask);

        // Float single precision blend instructions - select data
        // from 2 sources using constant/variable mask

        extern __m128  _mm_blend_ps (__m128  v1, __m128  v2, const int mask);
        extern __m128  _mm_blendv_ps(__m128  v1, __m128  v2, __m128 v3);

        // Float double precision blend instructions - select data
        // from 2 sources using constant/variable mask

        extern __m128d _mm_blend_pd (__m128d v1, __m128d v2, const int mask);
        extern __m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3);

        // Dot product instructions with mask-defined summing and zeroing
        // of result's parts

        extern __m128  _mm_dp_ps(__m128  val1, __m128  val2, const int mask);
        extern __m128d _mm_dp_pd(__m128d val1, __m128d val2, const int mask);

        // Packed integer 64-bit comparison, zeroing or filling with ones
        // corresponding parts of result

        extern __m128i _mm_cmpeq_epi64(__m128i val1, __m128i val2);

        // Min/max packed integer instructions

        extern __m128i _mm_min_epi8 (__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi8 (__m128i val1, __m128i val2);

        extern __m128i _mm_min_epu16(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu16(__m128i val1, __m128i val2);

        extern __m128i _mm_min_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_min_epu32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu32(__m128i val1, __m128i val2);

        // Packed integer 32-bit multiplication with truncation
        // of upper halves of results

        extern __m128i _mm_mullo_epi32(__m128i a, __m128i b);

        // Packed integer 32-bit multiplication of 2 pairs of operands
        // producing two 64-bit results

        extern __m128i _mm_mul_epi32(__m128i a, __m128i b);

        // Packed integer 128-bit bitwise comparison.
        // return 1 if (val 'and' mask) == 0

        extern int _mm_testz_si128(__m128i mask, __m128i val);

        // Packed integer 128-bit bitwise comparison.
        // return 1 if (val 'and_not' mask) == 0

        extern int _mm_testc_si128(__m128i mask, __m128i val);

        // Packed integer 128-bit bitwise comparison
        // ZF = ((val 'and' mask) == 0)  CF = ((val 'and_not' mask) == 0)
        // return 1 if both ZF and CF are 0

        extern int _mm_testnzc_si128(__m128i mask, __m128i s2);

        // Insert single precision float into packed single precision
        // array element selected by index.
        // The bits [7-6] of the 3d parameter define src index,
        // the bits [5-4] define dst index, and bits [3-0] define zeroing
        // mask for dst

        extern __m128 _mm_insert_ps(__m128 dst, __m128 src, const int ndx);

        // Helper macro to create ndx-parameter value for _mm_insert_ps

#define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) \
        (((srcField)<<6) | ((dstField)<<4) | (zeroMask))

        // Extract binary representation of single precision float from
        // packed single precision array element selected by index

        extern int _mm_extract_ps(__m128 src, const int ndx);

        // Extract single precision float from packed single precision
        // array element selected by index into dest

#define _MM_EXTRACT_FLOAT(dest, src, ndx) \
        *((int*)&(dest)) = _mm_extract_ps((src), (ndx))

        // Extract specified single precision float element
        // into the lower part of __m128

#define _MM_PICK_OUT_PS(src, num) \
        _mm_insert_ps(_mm_setzero_ps(), (src), \
                      _MM_MK_INSERTPS_NDX((num), 0, 0x0e));

        // Insert integer into packed integer array element
        // selected by index

        extern __m128i _mm_insert_epi8 (__m128i dst, int s, const int ndx);
        extern __m128i _mm_insert_epi32(__m128i dst, int s, const int ndx);

#if defined (_M_X64)
        extern __m128i _mm_insert_epi64(__m128i dst, __int64 s, const int ndx);
#endif  /* defined (_M_X64) */
        // Extract integer from packed integer array element
        // selected by index

        extern int   _mm_extract_epi8 (__m128i src, const int ndx);
        extern int   _mm_extract_epi32(__m128i src, const int ndx);

#if defined (_M_X64)
        extern __int64 _mm_extract_epi64(__m128i src, const int ndx);
#endif  /* defined (_M_X64) */

        // Horizontal packed word minimum and its index in
        // result[15:0] and result[18:16] respectively

        extern __m128i _mm_minpos_epu16(__m128i shortValues);

        // Packed/single float double precision rounding

        extern __m128d _mm_round_pd(__m128d val, int iRoundMode);
        extern __m128d _mm_round_sd(__m128d dst, __m128d val, int iRoundMode);

        // Packed/single float single precision rounding

        extern __m128  _mm_round_ps(__m128  val, int iRoundMode);
        extern __m128  _mm_round_ss(__m128 dst, __m128  val, int iRoundMode);

        // Packed integer sign-extension

        extern __m128i _mm_cvtepi8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepi16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi64 (__m128i byteValues);
        extern __m128i _mm_cvtepi32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepi16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi16 (__m128i byteValues);

        // Packed integer zero-extension

        extern __m128i _mm_cvtepu8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepu16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi64 (__m128i shortValues);
        extern __m128i _mm_cvtepu32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepu16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi16 (__m128i byteValues);


        // Pack 8 double words from 2 operands into 8 words of result
        // with unsigned saturation

        extern __m128i _mm_packus_epi32(__m128i val1, __m128i val2);

        // Sum absolute 8-bit integer difference of adjacent groups of 4 byte
        // integers in operands. Starting offsets within operands are
        // determined by mask

        extern __m128i _mm_mpsadbw_epu8(__m128i s1, __m128i s2, const int msk);

        /*
         * Load double quadword using non-temporal aligned hint
         */

        extern __m128i _mm_stream_load_si128(__m128i* v1);

#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INCLUDED_SMM */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnlpe.c ===
/***
*spawnlpe.c - spawn a child process with environ and search along PATH
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _spawnlpe() - spawn a child process with environ/PATH search
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _spawnlpe(modeflag, filename, arglist) - spawn a child process
*
*Purpose:
*       Spawns a child process.
*       formats the parameters and calls _spawnvpe to do the work of searching
*       the PATH environment variable and calling _spawnve.  The NULL
*       environment pointer indicates that the new process will inherit the
*       parents process's environment.  NOTE - at least one argument must be
*       present.  This argument is always, by convention, the name of the file
*       being spawned.
*
*Entry:
*       int modeflag   - defines what mode of spawn (WAIT, NOWAIT, OVERLAY)
*                        only WAIT and OVERLAY currently supported
*       _TSCHAR *pathname - file to spawn
*       _TSCHAR *arglist  - list of arguments (environ at end)
*       call as _spawnlpe(modeflag, path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       returns exit code of spawned process
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _tspawnlpe (
        int modeflag,
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        REG1 const _TSCHAR **argp;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        argp = &arglist;
        while (*argp++)
                ;

        return(_tspawnvpe(modeflag,filename,&arglist,(_TSCHAR **)*argp));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _tspawnvpe(modeflag,filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Define __cdecl for non-Microsoft compilers */

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif  /* _SIG_ATOMIC_T_DEFINED */

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */

#define SIGABRT_COMPAT  6       /* SIGABRT compatible with other platforms, same as SIGABRT */

#ifndef _M_CEE_PURE
/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_GET (void (__cdecl *)(int))2           /* return current value */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */

#ifndef _INTERNAL_IFSTRIP_
/* internal use only! not valid as an argument to signal() */

#define SIG_DIE (void (__cdecl *)(int))5           /* terminate process */
#endif  /* _INTERNAL_IFSTRIP_ */

/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */
#else  /* _M_CEE_PURE */
/* signal action codes */

#define SIG_DFL (void (__clrcall *)(int))0           /* default signal action */
#define SIG_IGN (void (__clrcall *)(int))1           /* ignore signal */
#define SIG_GET (void (__clrcall *)(int))2           /* return current value */
#define SIG_SGE (void (__clrcall *)(int))3           /* signal gets error */
#define SIG_ACK (void (__clrcall *)(int))4           /* acknowledge */

#ifndef _INTERNAL_IFSTRIP_
/* internal use only! not valid as an argument to signal() */

#define SIG_DIE (void (__clrcall *)(int))5           /* terminate process */
#endif  /* _INTERNAL_IFSTRIP_ */

/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__clrcall *)(int))-1          /* signal error value */
#endif  /* _M_CEE_PURE */


/* pointer to exception information pointers structure */

extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())


/* Function prototypes */

#ifndef _M_CEE_PURE
_CRTIMP void (__cdecl * __cdecl signal(_In_ int _SigNum, _In_opt_ void (__cdecl * _Func)(int)))(int);
#endif  /* _M_CEE_PURE */

_CRTIMP int __cdecl raise(_In_ int _SigNum);

#if defined (_M_CEE) && defined (__cplusplus)
extern "C++"
{
_MRTIMP void (__clrcall * __cdecl signal(_In_ int _SigNum, _In_opt_ void (__clrcall * _Func)(int)))(int);
#ifndef _M_CEE_PURE
_MRTIMP void (__clrcall * __cdecl signal(_In_ int _SigNum, _In_ int))(int);
#endif  /* _M_CEE_PURE */
}
#endif  /* defined (_M_CEE) && defined (__cplusplus) */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stati32.c ===
/***
*stati32.c - get file status (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat64i32() - get file status
*
*******************************************************************************/


#define _USE_INT64 0

#include "stat64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\spawnve.c ===
/***
*spawnve.c - Low level routine eventually called by all _spawnXX routines
*       also contains all code for _execve, called by _execXX routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       This is the low level routine which is eventually invoked by all the
*       _spawnXX routines.
*
*       This is also the low-level routine which is eventually invoked by
*       all of the _execXX routines.
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include <msdos.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>

#define SLASHCHAR   _T('\\')
#define XSLASHCHAR  _T('/')

#ifndef EXECVE
#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd(int mode, const wchar_t * name,
        const wchar_t * const * argv, const wchar_t * const * envp);
#else  /* WPRFLAG */
static intptr_t __cdecl comexecmd(int mode, const char * name,
        const char * const * argv, const char * const * envp);
#endif  /* WPRFLAG */
#else  /* EXECVE */
#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd(const wchar_t * name,
        const wchar_t * const * argv, const wchar_t * const * envp);
#else  /* WPRFLAG */
static intptr_t __cdecl comexecmd(const char * name,
        const char * const * argv, const char * const * envp);
#endif  /* WPRFLAG */
#endif  /* EXECVE */

/***
*static int comexecmd(mode, name, argv, envp) - do the exec
*       or spawn after name fixup
*
*Purpose:
*       Spawns a child process with given parameters and environment.  Either
*       overlays current process or loads in free memory while parent process
*       waits.  If the named file is a .cmd file, modifies the calling sequence
*       and prepends the /c and filename arguments into the command string
*
*       Exec doesn't take a mode; instead, the parent process goes away as
*       the child process is brought in.
*
*Entry:
*       int mode - mode to spawn (WAIT, NOWAIT, or OVERLAY)
*                   only WAIT and OVERLAY currently supported
*
*           ****  mode is only used in the spawnve() version  ****
*
*       _TSCHAR *name - pathname of file to spawn.  Includes the extension
*       _TSCHAR **argv - vector of parameter strings
*       _TSCHAR **envp - vector of environment variables
*
*Exit:
*       returns exit code of child process
*       if fails, returns -1
*
*Exceptions:
*       Returns a value of (-1) to indicate an error in exec'ing the child
*       process.  errno may be set to:
*
*       E2BIG   = failed in argument/environment processing (_cenvarg)
*                 argument list or environment too big;
*       EACCESS = locking or sharing violation on file;
*       EMFILE  = too many files open;
*       ENOENT  = failed to find program name - no such file or directory;
*       ENOEXEC = failed in exec - bad executable format;
*       ENOMEM  = failed in memory allocation (during malloc, or in
*                 setting up memory for executing child process).
*
*******************************************************************************/

#ifdef WPRFLAG
static intptr_t __cdecl wcomexecmd (
#else  /* WPRFLAG */
static intptr_t __cdecl comexecmd (
#endif  /* WPRFLAG */

#ifndef EXECVE
        REG3 int mode,
#endif  /* EXECVE */

        REG2 const _TSCHAR *name,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp
        )
{
        _TSCHAR *argblk;
        _TSCHAR *envblk;
        REG4 intptr_t rc;

        /* validation section */
        _VALIDATE_RETURN(name != NULL, EINVAL, -1);
        _VALIDATE_RETURN(argv != NULL, EINVAL, -1);

#ifdef WPRFLAG
        if (_wcenvarg(argv, envp, &argblk, &envblk, name) == -1)
#else  /* WPRFLAG */
        if (_cenvarg(argv, envp, &argblk, &envblk, name) == -1)
#endif  /* WPRFLAG */
                return -1;

#ifndef EXECVE
#ifdef WPRFLAG
        rc = _wdospawn(mode, name, argblk, envblk);
#else  /* WPRFLAG */
        rc = _dospawn(mode, name, argblk, envblk);
#endif  /* WPRFLAG */
#else  /* EXECVE */
#ifdef WPRFLAG
        rc = _wdospawn(_P_OVERLAY, name, argblk, envblk);
#else  /* WPRFLAG */
        rc = _dospawn(_P_OVERLAY, name, argblk, envblk);
#endif  /* WPRFLAG */
#endif  /* EXECVE */
        /* free memory */

        _free_crt(argblk);
        _free_crt(envblk);

        return rc;
}

/***
*int _spawnve(mode, name, argv, envp) - low level _spawnXX library function
*int _execve(name, argv, envp) - low level _execXX library function
*
*Purpose:
*       spawns or execs a child process; takes a single pointer to an argument
*       list as well as a pointer to the environment; unlike _spawnvpe,
*       _spawnve does not search the PATH= list in processing the name
*       parameter; mode specifies the parent's execution mode.
*
*Entry:
*       int mode    - parent process's execution mode:
*                     must be one of _P_OVERLAY, _P_WAIT, _P_NOWAIT;
*                     not used for _execve
*       _TSCHAR *name  - path name of program to spawn;
*       _TSCHAR **argv - pointer to array of pointers to child's arguments;
*       _TSCHAR **envp - pointer to array of pointers to child's environment
*                     settings.
*
*Exit:
*       Returns : (int) a status value whose meaning is as follows:
*               0        = normal termination of child process;
*               positive = exit code of child upon error termination
*                          (abort or exit(nonzero));
*               -1       = child process was not spawned;
*                          errno indicates what kind of error:
*                          (E2BIG, EINVAL, ENOENT, ENOEXEC, ENOMEM).
*
*Exceptions:
*       Returns a value of (-1) to indicate an error in spawning the child
*       process.  errno may be set to:
*
*       E2BIG   = failed in argument/environment processing (_cenvarg) -
*                 argument list or environment too big;
*       EINVAL  = invalid mode argument;
*       ENOENT  = failed to find program name - no such file or directory;
*       ENOEXEC = failed in spawn - bad executable format;
*       ENOMEM  = failed in memory allocation (during malloc, or in
*                 setting up memory for spawning child process).
*
*******************************************************************************/

/* Extension array - ordered in search order from right to left.

   ext_strings  = array of extensions
*/

static _TSCHAR *ext_strings[] = { _T(".cmd"), _T(".bat"), _T(".exe"), _T(".com") };
enum {CMD, BAT, EXE, COM, EXTFIRST=CMD, EXTLAST=COM};

intptr_t __cdecl

#ifndef EXECVE

_tspawnve (
        REG3 int mode,

#else  /* EXECVE */

_texecve (

#endif  /* EXECVE */

        const _TSCHAR *name,
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp
        )
{
        _TSCHAR *ext;   /* where the extension goes if we have to add one */
        REG1 _TSCHAR *p;
        _TSCHAR *q;
        REG2 _TSCHAR *pathname = (_TSCHAR *)name;
        REG4 intptr_t rc;
        REG5 int i;
        errno_t save_errno = 0;

        /* validation section */
        _VALIDATE_RETURN(name != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*name != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(argv != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*argv != NULL, EINVAL, -1);
        _VALIDATE_RETURN(**argv != _T('\0'), EINVAL, -1);

        p = _tcsrchr(pathname, SLASHCHAR);
        q = _tcsrchr(pathname, XSLASHCHAR);

        /* ensure that pathname is an absolute or relative pathname. also,
         * position p to point at the filename portion of pathname (i.e., just
         * after the last occurence of a colon, slash or backslash character */

        if (!q) {
                if (!p)
                        if (!(p = _tcschr(pathname, _T(':')))) {

                                /* pathname is a filename only, force it to be
                                 * a relative pathname. note that an extra byte
                                 * is malloc-ed just in case pathname is NULL,
                                 * to keep the heap from being trashed by
                                 * strcpy */
                                size_t pathname_size = _tcslen(pathname) + 3;
                                if (!(pathname = _calloc_crt(pathname_size, sizeof(_TSCHAR))))
                                        return(-1);

                                _ERRCHECK(_tcscpy_s(pathname, pathname_size, _T(".\\")));
                                _ERRCHECK(_tcscat_s(pathname, pathname_size, name));

                                /* set p to point to the start of the filename
                                 * (i.e., past the ".\\" prefix) */
                                p = pathname + 2;
                        }
                        /* else pathname has drive specifier prefix and p is
                         * is pointing to the ':' */
        }
        else if (!p || q > p)   /* p == NULL or q > p */
                p = q;


        rc = -1;        /* init to error value */

        if (ext = _tcsrchr(p, _T('.')))  {

                /* extension given; only do filename */

                if (_taccess_s(pathname, 0) == 0) {

#ifndef EXECVE

#ifdef WPRFLAG
                        rc = wcomexecmd(mode, pathname, argv, envp);
#else  /* WPRFLAG */
                        rc = comexecmd(mode, pathname, argv, envp);
#endif  /* WPRFLAG */

#else  /* EXECVE */

#ifdef WPRFLAG
                        rc = wcomexecmd(pathname, argv, envp);
#else  /* WPRFLAG */
                        rc = comexecmd(pathname, argv, envp);
#endif  /* WPRFLAG */

#endif  /* EXECVE */
                }

        }
        else    {

                /* no extension; try .cmd/.bat, then .com and .exe */

                size_t size = _tcslen(pathname) + 5;
                if (!(p = _calloc_crt(size, sizeof(_TSCHAR))))
                        return(-1);

                _ERRCHECK(_tcscpy_s(p, size, pathname));
                ext = p + _tcslen(pathname);

                save_errno = errno;
                for (i = EXTLAST; i >= EXTFIRST; --i) {
                        _ERRCHECK(_tcscpy_s(ext, size - (ext - p), ext_strings[i]));

                        if (_taccess_s(p, 0) == 0) {
                                errno = save_errno;

#ifndef EXECVE
#ifdef WPRFLAG
                                rc = wcomexecmd(mode, p, argv, envp);
#else  /* WPRFLAG */
                                rc = comexecmd(mode, p, argv, envp);
#endif  /* WPRFLAG */
#else  /* EXECVE */
#ifdef WPRFLAG
                                rc = wcomexecmd(p, argv, envp);
#else  /* WPRFLAG */
                                rc = comexecmd(p, argv, envp);
#endif  /* WPRFLAG */
#endif  /* EXECVE */
                                break;
                        }
                }
                _free_crt(p);
        }

        if (pathname != name)
                _free_crt(pathname);

        return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\splitpath_s.c ===
/***
*splitpath_s.c - break down path name into components
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   To provide support for accessing the individual components of an
*   arbitrary path name
*
*******************************************************************************/

#include <stdlib.h>
#include <mbstring.h>
#include <internal_securecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME _splitpath_s
#define _CHAR char
#define _TCSNCPY_S strncpy_s
#define _T(_Character) _Character

#define _MBS_SUPPORT 1
/* _splitpath uses _ismbblead and not _ismbblead_l */
#undef _ISMBBLEAD
#define _ISMBBLEAD(_Character) \
    _ismbblead((_Character))

#include <tsplitpath_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdenvp.c ===
/***
*stdenvp.c - standard _setenvp routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module is called by the C start-up routine to set up "_environ".
*       Its sets up an array of pointers to strings in the environment.
*       The global symbol "_environ" is set to point to this array.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <rterr.h>
#include <oscalls.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef CRTDLL

#ifdef _MBCS
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

#endif  /* _MBCS */

/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
extern int __env_initialized;

#endif  /* CRTDLL */

/***
*_setenvp - set up "envp" for C programs
*
*Purpose:
*       Reads the environment and build the envp array for C programs.
*
*Entry:
*       The environment strings occur at _aenvptr.
*       The list of environment strings is terminated by an extra null
*       byte.  Thus two null bytes in a row indicate the end of the
*       last environment string and the end of the environment, resp.
*
*Exit:
*       "environ" points to a null-terminated list of pointers to ASCIZ
*       strings, each of which is of the form "VAR=VALUE".  The strings
*       are copied from the environment area. This array of pointers will
*       be malloc'ed.  The block pointed to by _aenvptr is deallocated.
*
*Uses:
*       Allocates space on the heap for the environment pointers.
*
*Exceptions:
*       If space cannot be allocated, program is terminated.
*
*******************************************************************************/

#ifdef WPRFLAG
#define _tsetenvp    _wsetenvp
#define _tenvptr     _wenvptr
#else  /* WPRFLAG */
#define _tsetenvp    _setenvp
#define _tenvptr     _aenvptr
#endif  /* WPRFLAG */

int __cdecl _tsetenvp (
        void
        )
{
        _TSCHAR *p;
        _TSCHAR **env;              /* _environ ptr traversal pointer */
        int numstrings;             /* number of environment strings */
        int cchars;

#if !defined (CRTDLL) && defined (_MBCS)
        /* If necessary, initialize the multibyte ctype table. */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif  /* !defined (CRTDLL) && defined (_MBCS) */

        numstrings = 0;

        p = _tenvptr;

        /*
         * We called __crtGetEnvironmentStrings[AW] just before this,
         * so if _[aw]envptr is NULL, we failed to get the environment.
         * Return an error.
         */
        if (p == NULL)
            return -1;

        /*
         * NOTE: starting with single null indicates no environ.
         * Count the number of strings. Skip drive letter settings
         * ("=C:=C:\foo" type) by skipping all environment variables
         * that begin with '=' character.
         */

        while (*p != _T('\0')) {
            /* don't count "=..." type */
            if (*p != _T('='))
                ++numstrings;
            p += _tcslen(p) + 1;
        }

        /* need pointer for each string, plus one null ptr at end */
        if ( (_tenviron = env = (_TSCHAR **)
            _calloc_crt((numstrings+1), sizeof(_TSCHAR *))) == NULL )
            return -1;

        /* copy strings to malloc'd memory and save pointers in _environ */
        for ( p = _tenvptr ; *p != L'\0' ; p += cchars )
        {
            cchars = (int)_tcslen(p) + 1;
            /* don't copy "=..." type */
            if (*p != _T('=')) {
                if ( (*env = (_TSCHAR *)_calloc_crt(cchars, sizeof(_TSCHAR)))
                     == NULL )
                {
                    _free_crt(_tenviron);
                    _tenviron = NULL;
                    return -1;
                }
                _ERRCHECK(_tcscpy_s(*env, cchars, p));
                env++;
            }
        }

        _free_crt(_tenvptr);
        _tenvptr = NULL;

        /* and a final NULL pointer */
        *env = NULL;

#ifndef CRTDLL
        /*
         * Set flag for getenv() and _putenv() to know the environment
         * has been set up.
         */
        __env_initialized = 1;
#endif  /* CRTDLL */

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines sprintf() and _snprintf() - print formatted data to string
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>
#include <stddef.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int sprintf(string, format, ...) - print formatted data to string
*else
*int _snprintf(string, cnt, format, ...) - print formatted data to string
*endif
*
*Purpose:
*       Prints formatted data to the using the format string to
*       format data and getting as many arguments as called for
*       Sets up a FILE so file i/o operations can be used, make
*       string look like a huge buffer to it, but _flsbuf will
*       refuse to flush it if it fills up.  Appends '\0' to make
*       it a true string. _output does the real work here
*
*       Allocate the 'fake' _iob[] entry statically instead of on
*       the stack so that other routines can assume that _iob[]
*       entries are in are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _snprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must
*       never try to get the stream lock (i.e., there is no stream
*       lock either). (2) Also, since there is only one statically
*       allocated 'fake' iob, we must lock/unlock to prevent collisions.
*
*Entry:
*       char *string - pointer to place to put output
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl sprintf (
        char *string,
        const char *format,
        ...
        )
#else  /* _COUNT_ */

#ifndef _SWPRINTFS_ERROR_RETURN_FIX

int __cdecl _snprintf (
        char *string,
        size_t count,
        const char *format,
        ...
        )
#else  /* _SWPRINTFS_ERROR_RETURN_FIX */

int __cdecl _snprintf_c (
        char *string,
        size_t count,
        const char *format,
        ...
        )

#endif  /* _SWPRINTFS_ERROR_RETURN_FIX */

#endif  /* _COUNT_ */

{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        _VALIDATE_RETURN( (format != NULL), EINVAL, -1);

#ifdef _COUNT_
        _VALIDATE_RETURN( (count == 0) || (string != NULL), EINVAL, -1 );
#else  /* _COUNT_ */
        _VALIDATE_RETURN( (string != NULL), EINVAL, -1 );
#endif  /* _COUNT_ */
        va_start(arglist, format);

#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else  /* _COUNT_ */
        if(count>INT_MAX)
        {
            /* old-style functions allow any large value to mean unbounded */
            outfile->_cnt = INT_MAX;
        }
        else
        {
            outfile->_cnt = (int)(count);
        }
#endif  /* _COUNT_ */
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = string;

        retval = _output_l(outfile,format,NULL,arglist);

        if (string == NULL)
            return(retval);

#ifndef _SWPRINTFS_ERROR_RETURN_FIX
        _putc_nolock('\0',outfile); /* no-lock version */

        return(retval);
#else  /* _SWPRINTFS_ERROR_RETURN_FIX */
        if((retval >= 0) && (_putc_nolock('\0',outfile) != EOF))
            return(retval);

        string[0] = 0;
        return -1;
#endif  /* _SWPRINTFS_ERROR_RETURN_FIX */
}

#ifndef _COUNT_

int __cdecl _sprintf_l (
        char *string,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;
    va_start(arglist, plocinfo);

#pragma warning(push)
#pragma warning(disable:4996) // Disable deprecation warning since calling function is also deprecated
    return _vsprintf_l(string, format, plocinfo, arglist);
#pragma warning(pop)
}

#else  /* _COUNT_ */
#ifndef _SWPRINTFS_ERROR_RETURN_FIX

int __cdecl _snprintf_l (
        char *string,
        size_t count,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;
    va_start(arglist, plocinfo);

#pragma warning(push)
#pragma warning(disable:4996) // Disable deprecation warning since calling function is also deprecated
    return _vsnprintf_l(string, count, format, plocinfo, arglist);
#pragma warning(pop)
}
#else  /* _SWPRINTFS_ERROR_RETURN_FIX */

int __cdecl _snprintf_c_l (
        char *string,
        size_t count,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;
    va_start(arglist, plocinfo);

    return _vsnprintf_c_l(string, count, format, plocinfo, arglist);

}

#endif  /* _SWPRINTFS_ERROR_RETURN_FIX */
#endif  /* _COUNT_ */

#ifndef _COUNT_
int __cdecl sprintf_s (
        char *string,
        size_t sizeInBytes,
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return _vsprintf_s_l(string, sizeInBytes, format, NULL, arglist);
}

int __cdecl _sprintf_s_l (
        char *string,
        size_t sizeInBytes,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return _vsprintf_s_l(string, sizeInBytes, format, plocinfo, arglist);
}

int __cdecl _snprintf_s (
        char *string,
        size_t sizeInBytes,
        size_t count,
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return _vsnprintf_s_l(string, sizeInBytes, count, format, NULL, arglist);
}

int __cdecl _snprintf_s_l (
        char *string,
        size_t sizeInBytes,
        size_t count,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return _vsnprintf_s_l(string, sizeInBytes, count, format, plocinfo, arglist);
}

int __cdecl _sprintf_p (
        char *string,
        size_t count,
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return _vsprintf_p_l(string, count, format, NULL, arglist);
}

int __cdecl _sprintf_p_l (
        char *string,
        size_t count,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return _vsprintf_p_l(string, count, format, plocinfo, arglist);
}

#endif  /* _COUNT_ */

/***
* _scprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/


#ifndef _COUNT_
int __cdecl _scprintf (
        const char *format,
        ...
        )
{
        va_list arglist;

        va_start(arglist, format);

        return _vscprintf(format, arglist);
}

int __cdecl _scprintf_p (
        const char *format,
        ...
        )
{
        va_list arglist;

        va_start(arglist, format);

        return _vscprintf_p(format, arglist);

}

int __cdecl _scprintf_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
       va_list arglist;
       va_start(arglist, plocinfo);

       return _vscprintf_l(format, plocinfo, arglist);
}

int __cdecl _scprintf_p_l (
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;

        va_start(arglist, plocinfo);

        return _vscprintf_p_l(format, plocinfo, arglist);

}
#endif  /* _COUNT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#include <crtdefs.h>

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */
#ifdef __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stati64.c ===
/***
*stati64.c - get file status
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _stati64() - get file status
*
*******************************************************************************/

#define _USE_INT64  1

#include "stat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stat.c ===
/***
*stat.c - get file status
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat() - get file status
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>
#include <msdos.h>
#include <oscalls.h>
#include <string.h>
#include <internal.h>
#include <stdlib.h>
#include <direct.h>
#include <mbstring.h>
#include <tchar.h>


#define ISSLASH(a)  ((a) == _T('\\') || (a) == _T('/'))


#ifdef _UNICODE
#define __tdtoxmode __wdtoxmode
#else  /* _UNICODE */
#define __tdtoxmode __dtoxmode
#endif  /* _UNICODE */


/*
 * Local routine which returns true if the argument is a UNC name
 * specifying the root name of a share, such as '\\server\share\'.
 */

static int IsRootUNCName(const _TSCHAR *path);
static _TSCHAR * _tfullpath_helper(_TSCHAR * ,const _TSCHAR *,size_t , _TSCHAR **);


/***
*unsigned __tdtoxmode(attr, name) -
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _USE_INT64

extern unsigned short __cdecl __tdtoxmode(int, const _TSCHAR *);

#else  /* _USE_INT64 */

unsigned short __cdecl __tdtoxmode (
        int attr,
        const _TSCHAR *name
        )
{
        REG1 unsigned short uxmode;
        unsigned dosmode;
        REG2 const _TSCHAR *p;

        dosmode = attr & 0xff;
        if ((p = name)[1] == _T(':'))
            p += 2;

        /* check to see if this is a directory - note we must make a special
        * check for the root, which DOS thinks is not a directory
        */

        uxmode = (unsigned short)
                 (((ISSLASH(*p) && !p[1]) || (dosmode & A_D) || !*p)
                 ? _S_IFDIR|_S_IEXEC : _S_IFREG);

        /* If attribute byte does not have read-only bit, it is read-write */

        uxmode |= (dosmode & A_RO) ? _S_IREAD : (_S_IREAD|_S_IWRITE);

        /* see if file appears to be executable - check extension of name */

        if (p = _tcsrchr(name, _T('.'))) {
            if ( !_tcsicmp(p, _T(".exe")) ||
                 !_tcsicmp(p, _T(".cmd")) ||
                 !_tcsicmp(p, _T(".bat")) ||
                 !_tcsicmp(p, _T(".com")) )
                uxmode |= _S_IEXEC;
        }

        /* propagate user read/write/execute bits to group/other fields */

        uxmode |= (uxmode & 0700) >> 3;
        uxmode |= (uxmode & 0700) >> 6;

        return(uxmode);
}

#endif  /* _USE_INT64 */

/***
*int _stat(name, buf) - get file status info
*
*Purpose:
*       _stat obtains information about the file and stores it in the
*       structure pointed to by buf.
*
*       Note: We cannot directly use the file time stamps returned in the
*       WIN32_FIND_DATA structure. The values are supposedly in system time
*       and system time is ambiguously defined (it is UTC for Windows NT, local
*       time for Win32S and probably local time for Win32C). Therefore, these
*       values must be converted to local time before than can be used.
*
*Entry:
*       _TSCHAR *name -    pathname of given file
*       struct _stat *buffer - pointer to buffer to store info in
*
*Exit:
*       fills in structure pointed to by buffer
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

#ifdef _USE_INT64

int __cdecl _tstat32i64 (
        REG1 const _TSCHAR *name,
        REG2 struct _stat32i64 *buf
        )

#else  /* _USE_INT64 */

int __cdecl _tstat32 (
        REG1 const _TSCHAR *name,
        REG2 struct _stat32 *buf
        )

#endif  /* _USE_INT64 */

{
        _TSCHAR *  path;
        _TSCHAR    pathbuf[ _MAX_PATH ];
        int drive;          /* A: = 1, B: = 2, etc. */
        HANDLE findhandle;
        WIN32_FIND_DATA findbuf;

        _VALIDATE_CLEAR_OSSERR_RETURN( (name != NULL), EINVAL, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1);

        /* Don't allow wildcards to be interpreted by system */

#ifdef _UNICODE
        if (wcspbrk(name, L"?*")) {
#else  /* _UNICODE */
        if (_mbspbrk(name, "?*")) {
#endif  /* _UNICODE */
            errno = ENOENT;
            _doserrno = E_nofile;
            return(-1);
        }

        /* Try to get disk from name.  If none, get current disk.  */

        if (name[1] == _T(':')){
            if ( *name && !name[2] ){
                errno = ENOENT;             /* return an error if name is   */
                _doserrno = E_nofile;       /* just drive letter then colon */
                return( -1 );
            }
            drive = _totlower(*name) - _T('a') + 1;
        }
        else
            drive = _getdrive();

        /* Call Find Match File */
        findhandle = FindFirstFile((_TSCHAR *)name, &findbuf);
        if ( findhandle == INVALID_HANDLE_VALUE ) {
            _TSCHAR * pBuf = NULL;
#ifdef _UNICODE
            if ( !( wcspbrk(name, L"./\\") &&
#else  /* _UNICODE */
            if ( !( _mbspbrk(name, "./\\") &&
#endif  /* _UNICODE */
                 (path = _tfullpath_helper( pathbuf, name, _MAX_PATH, &pBuf )) &&
                 /* root dir. ('C:\') or UNC root dir. ('\\server\share\') */
                 ((_tcslen( path ) == 3) || IsRootUNCName(path)) &&
                 (GetDriveType( path ) > 1) ) )
            {
                if(pBuf)
                    free(pBuf);

                errno = ENOENT;
                _doserrno = E_nofile;
                return( -1 );
            }

            if(pBuf)
                free(pBuf);
            /*
             * Root directories (such as C:\ or \\server\share\ are fabricated.
             */

            findbuf.dwFileAttributes = A_D;
            findbuf.nFileSizeHigh = 0;
            findbuf.nFileSizeLow = 0;
            findbuf.cFileName[0] = _T('\0');

            buf->st_mtime = __loctotime32_t(1980,1,1,0,0,0, -1);
            buf->st_atime = buf->st_mtime;
            buf->st_ctime = buf->st_mtime;
        }
        else {
            SYSTEMTIME SystemTime;
            FILETIME LocalFTime;

            if ( findbuf.ftLastWriteTime.dwLowDateTime ||
                 findbuf.ftLastWriteTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastWriteTime,
                                               &LocalFTime )            ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_mtime = __loctotime32_t( SystemTime.wYear,
                                                 SystemTime.wMonth,
                                                 SystemTime.wDay,
                                                 SystemTime.wHour,
                                                 SystemTime.wMinute,
                                                 SystemTime.wSecond,
                                                 -1 );
            } else
                buf->st_mtime = 0 ;

            if ( findbuf.ftLastAccessTime.dwLowDateTime ||
                 findbuf.ftLastAccessTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastAccessTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_atime = __loctotime32_t( SystemTime.wYear,
                                                 SystemTime.wMonth,
                                                 SystemTime.wDay,
                                                 SystemTime.wHour,
                                                 SystemTime.wMinute,
                                                 SystemTime.wSecond,
                                                 -1 );
            } else
                buf->st_atime = buf->st_mtime ;

            if ( findbuf.ftCreationTime.dwLowDateTime ||
                 findbuf.ftCreationTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftCreationTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_ctime = __loctotime32_t( SystemTime.wYear,
                                                 SystemTime.wMonth,
                                                 SystemTime.wDay,
                                                 SystemTime.wHour,
                                                 SystemTime.wMinute,
                                                 SystemTime.wSecond,
                                                 -1 );
            } else
                buf->st_ctime = buf->st_mtime ;

            FindClose(findhandle);
        }

        /* Fill in buf */

        buf->st_mode = __tdtoxmode(findbuf.dwFileAttributes, name);
        buf->st_nlink = 1;

#ifdef _USE_INT64
        buf->st_size = ((__int64)(findbuf.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(findbuf.nFileSizeLow);
#else  /* _USE_INT64 */
        buf->st_size = findbuf.nFileSizeLow;
#endif  /* _USE_INT64 */

        /* now set the common fields */

        buf->st_uid = buf->st_gid = buf->st_ino = 0;

        buf->st_rdev = buf->st_dev = (_dev_t)(drive - 1); /* A=0, B=1, etc. */

        return(0);
}


/*
 * IsRootUNCName - returns TRUE if the argument is a UNC name specifying
 *      a root share.  That is, if it is of the form \\server\share\.
 *      This routine will also return true if the argument is of the
 *      form \\server\share (no trailing slash) but Win32 currently
 *      does not like that form.
 *
 *      Forward slashes ('/') may be used instead of backslashes ('\').
 */

static int IsRootUNCName(const _TSCHAR *path)
{
        /*
         * If a root UNC name, path will start with 2 (but not 3) slashes
         */

        if ( ( _tcslen ( path ) >= 5 ) /* minimum string is "//x/y" */
             && ISSLASH(path[0]) && ISSLASH(path[1])
             && !ISSLASH(path[2]))
                {
            const _TSCHAR * p = path + 2 ;

            /*
             * find the slash between the server name and share name
             */
            while ( * ++ p )
                if ( ISSLASH(*p) )
                    break ;

            if ( *p && p[1] )
            {
                /*
                 * is there a further slash?
                 */
                while ( * ++ p )
                    if ( ISSLASH(*p) )
                        break ;

                /*
                 * just final slash (or no final slash)
                 */
                if ( !*p || !p[1])
                    return 1;
            }
        }

        return 0 ;
}

static _TSCHAR * __cdecl _tfullpath_helper(_TSCHAR * buf,const _TSCHAR *path,size_t sz, _TSCHAR ** pBuf)
{
    _TSCHAR * ret;
    errno_t save_errno = errno;

    errno = 0;
    ret = _tfullpath(buf, path, sz);
    if (ret)
    {
        errno = save_errno;
        return ret;
    }

    /* if _tfullpath fails because buf is too small, then we just call again _tfullpath and
     * have it allocate the appropriate buffer
     */
    if (errno != ERANGE)
    {
        /* _tfullpath is failing for another reason, just propagate the failure and keep the
         * failure code in errno
         */
        return NULL;
    }
    errno = save_errno;

    *pBuf = _tfullpath(NULL, path, 0);

    return *pBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_STDDEF
#define _INC_STDDEF

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */


/* Declare reference to errno */
#ifndef _CRT_ERRNO_DEFINED
#define _CRT_ERRNO_DEFINED
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())

errno_t __cdecl _set_errno(_In_ int _Value);
errno_t __cdecl _get_errno(_Out_ int * _Value);
#endif  /* _CRT_ERRNO_DEFINED */

/* Define offsetof macro */
#ifdef __cplusplus

#ifdef _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&reinterpret_cast<const volatile char&>((((s *)0)->m)) )
#else  /* _WIN64 */
#define offsetof(s,m)   (size_t)&reinterpret_cast<const volatile char&>((((s *)0)->m))
#endif  /* _WIN64 */

#else  /* __cplusplus */

#ifdef _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else  /* _WIN64 */
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif  /* _WIN64 */

#endif  /* __cplusplus */

_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_STDARG
#define _INC_STDARG

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#include <vadefs.h>

#define va_start _crt_va_start
#define va_arg _crt_va_arg
#define va_end _crt_va_end

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stat64.c ===
/***
*stat64.c - get file status
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _stat64() - get file status
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>
#include <msdos.h>
#include <oscalls.h>
#include <string.h>
#include <internal.h>
#include <stdlib.h>
#include <direct.h>
#include <mbstring.h>
#include <tchar.h>

#ifndef _USE_INT64
#define _USE_INT64 1
#endif  /* _USE_INT64 */

#define ISSLASH(a)  ((a) == _T('\\') || (a) == _T('/'))


/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64


#ifdef _UNICODE
#define __tdtoxmode __wdtoxmode
#else  /* _UNICODE */
#define __tdtoxmode __dtoxmode
#endif  /* _UNICODE */


/*
 * Local routine which returns true if the argument is a UNC name
 * specifying the root name of a share, such as '\\server\share\'.
 */

static int IsRootUNCName(const _TSCHAR *path);
static _TSCHAR * _tfullpath_helper(_TSCHAR * ,const _TSCHAR *,size_t , _TSCHAR **);

extern unsigned short __cdecl __tdtoxmode(int, const _TSCHAR *);


/***
*int _stat64(name, buf) - get file status info
*
*Purpose:
*       _stat64 obtains information about the file and stores it in the
*       structure pointed to by buf.
*
*       Note: Unlike _stat, _stat64 uses the UTC time values returned in
*       WIN32_FIND_DATA struct. This means the time values will always be
*       correct on NTFS, but may be wrong on FAT file systems for file times
*       whose DST state is different from the current DST state (this an NT
*       bug).
*
*Entry:
*       _TSCHAR *name -    pathname of given file
*       struct _stat *buffer - pointer to buffer to store info in
*
*Exit:
*       fills in structure pointed to by buffer
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

#if _USE_INT64

int __cdecl _tstat64 (
        REG1 const _TSCHAR *name,
        REG2 struct _stat64 *buf
        )

#else  /* _USE_INT64 */

int __cdecl _tstat64i32 (
        REG1 const _TSCHAR *name,
        REG2 struct _stat64i32 *buf
        )

#endif  /* _USE_INT64 */

{
        _TSCHAR *  path;
        _TSCHAR    pathbuf[ _MAX_PATH ];
        int drive;          /* A: = 1, B: = 2, etc. */
        HANDLE findhandle;
        WIN32_FIND_DATA findbuf;

        _VALIDATE_CLEAR_OSSERR_RETURN( (name != NULL), EINVAL, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1);

        /* Don't allow wildcards to be interpreted by system */

#ifdef _UNICODE
        if (wcspbrk(name, L"?*")) {
#else  /* _UNICODE */
        if (_mbspbrk(name, "?*")) {
#endif  /* _UNICODE */
            errno = ENOENT;
            _doserrno = E_nofile;
            return(-1);
        }

        /* Try to get disk from name.  If none, get current disk.  */

        if (name[1] == _T(':')){
            if ( *name && !name[2] ){
                errno = ENOENT;             /* return an error if name is   */
                _doserrno = E_nofile;       /* just drive letter then colon */
                return( -1 );
            }
            drive = _totlower(*name) - _T('a') + 1;
        }
        else
            drive = _getdrive();

        /* Call Find Match File */
        findhandle = FindFirstFile((_TSCHAR *)name, &findbuf);
        if ( findhandle == INVALID_HANDLE_VALUE ) {
            _TSCHAR * pBuf = NULL;

#ifdef _UNICODE
            if ( !( wcspbrk(name, L"./\\") &&
#else  /* _UNICODE */
            if ( !( _mbspbrk(name, "./\\") &&
#endif  /* _UNICODE */
                 (path = _tfullpath_helper( pathbuf, name, _MAX_PATH, &pBuf )) &&
                 /* root dir. ('C:\') or UNC root dir. ('\\server\share\') */
                 ((_tcslen( path ) == 3) || IsRootUNCName(path)) &&
                 (GetDriveType( path ) > 1) ) )
            {
                if(pBuf)
                    free(pBuf);

                errno = ENOENT;
                _doserrno = E_nofile;
                return( -1 );
            }

            if(pBuf)
                free(pBuf);

            /*
             * Root directories (such as C:\ or \\server\share\ are fabricated.
             */

            findbuf.dwFileAttributes = A_D;
            findbuf.nFileSizeHigh = 0;
            findbuf.nFileSizeLow = 0;
            findbuf.cFileName[0] = _T('\0');

            buf->st_mtime = __loctotime64_t(1980,1,1,0,0,0, -1);
            buf->st_atime = buf->st_mtime;
            buf->st_ctime = buf->st_mtime;
        }
        else {

            SYSTEMTIME SystemTime;
            FILETIME LocalFTime;

            if ( findbuf.ftLastWriteTime.dwLowDateTime ||
                 findbuf.ftLastWriteTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastWriteTime,
                                               &LocalFTime )            ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_mtime = __loctotime64_t( SystemTime.wYear,
                                                 SystemTime.wMonth,
                                                 SystemTime.wDay,
                                                 SystemTime.wHour,
                                                 SystemTime.wMinute,
                                                 SystemTime.wSecond,
                                                 -1 );
            } else
                buf->st_mtime = 0 ;

            if ( findbuf.ftLastAccessTime.dwLowDateTime ||
                 findbuf.ftLastAccessTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftLastAccessTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_atime = __loctotime64_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_atime = buf->st_mtime ;

            if ( findbuf.ftCreationTime.dwLowDateTime ||
                 findbuf.ftCreationTime.dwHighDateTime )
            {
                if ( !FileTimeToLocalFileTime( &findbuf.ftCreationTime,
                                               &LocalFTime )                ||
                     !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
                {
                    _dosmaperr( GetLastError() );
                    FindClose( findhandle );
                    return( -1 );
                }

                buf->st_ctime = __loctotime64_t( SystemTime.wYear,
                                               SystemTime.wMonth,
                                               SystemTime.wDay,
                                               SystemTime.wHour,
                                               SystemTime.wMinute,
                                               SystemTime.wSecond,
                                               -1 );
            } else
                buf->st_ctime = buf->st_mtime ;

            FindClose(findhandle);
        }

        /* Fill in buf */

        buf->st_mode = __tdtoxmode(findbuf.dwFileAttributes, name);
        buf->st_nlink = 1;
#if _USE_INT64
        buf->st_size = ((__int64)(findbuf.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(findbuf.nFileSizeLow);
#else  /* _USE_INT64 */
        buf->st_size = findbuf.nFileSizeLow;
#endif  /* _USE_INT64 */

        /* now set the common fields */

        buf->st_uid = buf->st_gid = buf->st_ino = 0;

        buf->st_rdev = buf->st_dev = (_dev_t)(drive - 1); /* A=0, B=1, etc. */

        return(0);
}


/*
 * IsRootUNCName - returns TRUE if the argument is a UNC name specifying
 *      a root share.  That is, if it is of the form \\server\share\.
 *      This routine will also return true if the argument is of the
 *      form \\server\share (no trailing slash) but Win32 currently
 *      does not like that form.
 *
 *      Forward slashes ('/') may be used instead of backslashes ('\').
 */

static int IsRootUNCName(const _TSCHAR *path)
{
        /*
         * If a root UNC name, path will start with 2 (but not 3) slashes
         */

        if ( ( _tcslen ( path ) >= 5 ) /* minimum string is "//x/y" */
             && ISSLASH(path[0]) && ISSLASH(path[1])
             && !ISSLASH(path[2]))
                {
            const _TSCHAR * p = path + 2 ;

            /*
             * find the slash between the server name and share name
             */
            while ( * ++ p )
                if ( ISSLASH(*p) )
                    break ;

            if ( *p && p[1] )
            {
                /*
                 * is there a further slash?
                 */
                while ( * ++ p )
                    if ( ISSLASH(*p) )
                        break ;

                /*
                 * just final slash (or no final slash)
                 */
                if ( !*p || !p[1])
                    return 1;
            }
        }

        return 0 ;
}

static _TSCHAR * __cdecl _tfullpath_helper(_TSCHAR * buf,const _TSCHAR *path,size_t sz, _TSCHAR ** pBuf)
{
    _TSCHAR * ret;
    errno_t save_errno = errno;

    errno = 0;
    ret = _tfullpath(buf, path, sz);
    if (ret)
    {
        errno = save_errno;
        return ret;
    }

    if (errno != ERANGE)
    {
        return NULL;
    }
    errno = save_errno;

    *pBuf = _tfullpath(NULL, path, 0);

    return *pBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdhndlr.cpp ===
// handler.cpp -- set_new_handler for Microsoft
#include <new>

typedef int (__cdecl *new_hand)(size_t);
new_hand __cdecl _set_new_handler(new_hand);

_STD_BEGIN
static new_handler _New_handler;

int __cdecl _New_handler_interface(size_t) _THROW1(std::bad_alloc)
	{	// interface to existing Microsoft _callnewh mechanism
	_New_handler();
	return (1);
	}

_CRTIMP2 new_handler __cdecl set_new_handler(new_handler pnew) _THROW0()
	{	// remove current handler
	_BEGIN_LOCK(_LOCK_MALLOC)	// lock thread to ensure atomicity
		new_handler pold = _New_handler;
		_New_handler = pnew;
		_set_new_handler(pnew ? _New_handler_interface : 0);
		return (pold);
	_END_LOCK()
	}

new_handler _CRTIMP2 __cdecl set_new_handler
( 
    int pnh 
) throw()
{
	return set_new_handler(static_cast<new_handler>(NULL));
}

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdargv.c ===
/***
*stdargv.c - standard & wildcard _setargv routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line, with or without wildcard expansion
*
*******************************************************************************/


#include <cruntime.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>
#include <dos.h>
#include <oscalls.h>
#ifdef _MBCS
#include <mbctype.h>
#endif  /* _MBCS */
#include <tchar.h>
#include <dbgint.h>
#include <limits.h>

#define NULCHAR    _T('\0')
#define SPACECHAR  _T(' ')
#define TABCHAR    _T('\t')
#define DQUOTECHAR _T('\"')
#define SLASHCHAR  _T('\\')

/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

#ifdef WPRFLAG
static void __cdecl wparse_cmdline(wchar_t *cmdstart, wchar_t **argv, wchar_t *args,
        int *numargs, int *numchars);
#else  /* WPRFLAG */
static void __cdecl parse_cmdline(char *cmdstart, char **argv, char *args,
        int *numargs, int *numchars);
#endif  /* WPRFLAG */

/***
*_setargv, __setargv - set up "argc" and "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line,
*       pointed to by _acmdln.
*
*Exit:
*       Returns 0 if successful, -1 if memory allocation failed.
*       "argv" points to a null-terminated list of pointers to ASCIZ
*       strings, each of which is an argument from the command line.
*       "argc" is the number of arguments.  The strings are copied from
*       the environment segment into space allocated on the heap/stack.
*       The list of pointers is also located on the heap or stack.
*       _pgmptr points to the program name.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

#ifdef WILDCARD

#ifdef WPRFLAG
int __cdecl __wsetargv (
#else  /* WPRFLAG */
int __cdecl __setargv (
#endif  /* WPRFLAG */

#else  /* WILDCARD */

#ifdef WPRFLAG
int __cdecl _wsetargv (
#else  /* WPRFLAG */
int __cdecl _setargv (
#endif  /* WPRFLAG */

#endif  /* WILDCARD */
    void
    )
{
        _TSCHAR *p = NULL;
        _TSCHAR *cmdstart;                  /* start of command line to parse */
        int numargs, numchars;

        static _TSCHAR _pgmname[ MAX_PATH + 1 ];

#if !defined (CRTDLL) && defined (_MBCS)
        /* If necessary, initialize the multibyte ctype table. */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif  /* !defined (CRTDLL) && defined (_MBCS) */

        /* Get the program name pointer from Win32 Base */

        _pgmname[ MAX_PATH ] = '\0';
        GetModuleFileName( NULL, _pgmname, MAX_PATH );
#ifdef WPRFLAG
        _set_wpgmptr(_pgmname);
#else  /* WPRFLAG */
        _set_pgmptr(_pgmname);
#endif  /* WPRFLAG */

        /* if there's no command line at all (won't happen from cmd.exe, but
           possibly another program), then we use _pgmptr as the command line
           to parse, so that argv[0] is initialized to the program name */

#ifdef WPRFLAG
        cmdstart = (_wcmdln == NULL || *_wcmdln == NULCHAR)
                   ? _pgmname : _wcmdln;
#else  /* WPRFLAG */
        cmdstart = (_acmdln == NULL || *_acmdln == NULCHAR)
                   ? _pgmname : _acmdln;
#endif  /* WPRFLAG */

        /* first find out how much space is needed to store args */
#ifdef WPRFLAG
        wparse_cmdline(cmdstart, NULL, NULL, &numargs, &numchars);
#else  /* WPRFLAG */
        parse_cmdline(cmdstart, NULL, NULL, &numargs, &numchars);
#endif  /* WPRFLAG */

        CRT_WARNING_DISABLE_PUSH(22011, "Silence prefast about overflow/underflow");

        /* allocate space for argv[] vector and strings */
        if (numargs >= (SIZE_MAX / sizeof(_TSCHAR *)) ||
            numchars >= (SIZE_MAX / sizeof(_TSCHAR)))
        {
            return -1;
        }
        if ((numargs * sizeof(_TSCHAR *) + numchars * sizeof(_TSCHAR)) < (numchars * sizeof(_TSCHAR)))
        {
            return -1;
        }
        p = _malloc_crt(numargs * sizeof(_TSCHAR *) + numchars * sizeof(_TSCHAR));
        if (p == NULL)
            return -1;

        /* store args and argv ptrs in just allocated block */

#ifdef WPRFLAG
        wparse_cmdline(cmdstart, (wchar_t **)p, (wchar_t *)(((char *)p) + numargs * sizeof(wchar_t *)), &numargs, &numchars);
#else  /* WPRFLAG */
        parse_cmdline(cmdstart, (char **)p, p + numargs * sizeof(char *), &numargs, &numchars);
#endif  /* WPRFLAG */
        CRT_WARNING_POP;

        /* set argv and argc */
        __argc = numargs - 1;
#ifdef WPRFLAG
        __wargv = (wchar_t **)p;
#else  /* WPRFLAG */
        __argv = (char **)p;
#endif  /* WPRFLAG */

#ifdef WILDCARD

        /* call _[w]cwild to expand wildcards in arg vector */
#ifdef WPRFLAG
        if (_wcwild())
#else  /* WPRFLAG */
        if (_cwild())
#endif  /* WPRFLAG */
            return -1;                  /* out of space */

#endif  /* WILDCARD */

        return 0;
}


/***
*static void parse_cmdline(cmdstart, argv, args, numargs, numchars)
*
*Purpose:
*       Parses the command line and sets up the argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, args
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numchars has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       _TSCHAR *cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       _TSCHAR **argv - where to build argv array; NULL means don't
*                       build array
*       _TSCHAR *args - where to place argument text; NULL means don't
*                       store text
*
*Exit:
*       no return value
*       int *numargs - returns number of argv entries created
*       int *numchars - number of characters used in args buffer
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static void __cdecl wparse_cmdline (
#else  /* WPRFLAG */
static void __cdecl parse_cmdline (
#endif  /* WPRFLAG */
    _TSCHAR *cmdstart,
    _TSCHAR **argv,
    _TSCHAR *args,
    int *numargs,
    int *numchars
    )
{
        _TSCHAR *p;
        _TUCHAR c;
        int inquote;                    /* 1 = inside quotes */
        int copychar;                   /* 1 = copy char to *args */
        unsigned numslash;              /* num of backslashes seen */

        *numchars = 0;
        *numargs = 1;                   /* the program name at least */

        /* first scan the program name, copy it, and count the bytes */
        p = cmdstart;
        if (argv)
            *argv++ = args;

#ifdef WILDCARD
        /* To handle later wild card expansion, we prefix each entry by
        it's first character before quote handling.  This is done
        so _[w]cwild() knows whether to expand an entry or not. */
        if (args)
            *args++ = *p;
        ++*numchars;

#endif  /* WILDCARD */

        /* A quoted program name is handled here. The handling is much
           simpler than for other arguments. Basically, whatever lies
           between the leading double-quote and next one, or a terminal null
           character is simply accepted. Fancier handling is not required
           because the program name must be a legal NTFS/HPFS file name.
           Note that the double-quote characters are not copied, nor do they
           contribute to numchars. */
        inquote = FALSE;
        do {
            if (*p == DQUOTECHAR )
            {
                inquote = !inquote;
                c = (_TUCHAR) *p++;
                continue;
            }
            ++*numchars;
            if (args)
                *args++ = *p;

            c = (_TUCHAR) *p++;
#ifdef _MBCS
            if (_ismbblead(c)) {
                ++*numchars;
                if (args)
                    *args++ = *p;   /* copy 2nd byte too */
                p++;  /* skip over trail byte */
            }
#endif  /* _MBCS */

        } while ( (c != NULCHAR && (inquote || (c !=SPACECHAR && c != TABCHAR))) );

        if ( c == NULCHAR ) {
            p--;
        } else {
            if (args)
                *(args-1) = NULCHAR;
        }

        inquote = 0;

        /* loop on each argument */
        for(;;) {

            if ( *p ) {
                while (*p == SPACECHAR || *p == TABCHAR)
                    ++p;
            }

            if (*p == NULCHAR)
                break;              /* end of args */

            /* scan an argument */
            if (argv)
                *argv++ = args;     /* store ptr to arg */
            ++*numargs;

#ifdef WILDCARD
        /* To handle later wild card expansion, we prefix each entry by
        it's first character before quote handling.  This is done
        so _[w]cwild() knows whether to expand an entry or not. */
        if (args)
            *args++ = *p;
        ++*numchars;

#endif  /* WILDCARD */

        /* loop through scanning one argument */
        for (;;) {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
               2N+1 backslashes + " ==> N backslashes + literal "
               N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == SLASHCHAR) {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == DQUOTECHAR) {
                /* if 2N backslashes before, start/end quote, otherwise
                    copy literally */
                if (numslash % 2 == 0) {
                    if (inquote && p[1] == DQUOTECHAR) {
                        p++;    /* Double quote inside quoted string */
                    } else {    /* skip first quote char and copy second */
                        copychar = 0;       /* don't copy quote */
                        inquote = !inquote;
                    }
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--) {
                if (args)
                    *args++ = SLASHCHAR;
                ++*numchars;
            }

            /* if at end of arg, break loop */
            if (*p == NULCHAR || (!inquote && (*p == SPACECHAR || *p == TABCHAR)))
                break;

            /* copy character into argument */
#ifdef _MBCS
            if (copychar) {
                if (args) {
                    if (_ismbblead(*p)) {
                        *args++ = *p++;
                        ++*numchars;
                    }
                    *args++ = *p;
                } else {
                    if (_ismbblead(*p)) {
                        ++p;
                        ++*numchars;
                    }
                }
                ++*numchars;
            }
            ++p;
#else  /* _MBCS */
            if (copychar) {
                if (args)
                    *args++ = *p;
                ++*numchars;
            }
            ++p;
#endif  /* _MBCS */
            }

            /* null-terminate the argument */

            if (args)
                *args++ = NULCHAR;          /* terminate string */
            ++*numchars;
        }

        /* We put one last argument in -- a null ptr */
        if (argv)
            *argv++ = NULL;
        ++*numargs;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_STDIO
#define _INC_STDIO

#include <crtdefs.h>
#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */


/* Buffered I/O macros */

#define BUFSIZ  512

#ifndef _INTERNAL_IFSTRIP_
/*
 * Real default size for stdio buffers
 */
#define _INTERNAL_BUFSIZ    4096
#define _SMALL_BUFSIZ       512
#endif  /* _INTERNAL_IFSTRIP_ */

/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif  /* _FILE_DEFINED */


/* Directory where temporary files may be created. */

#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 * L_tmpnam_s = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 16 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam   (sizeof(_P_tmpdir) + 12)
#if __STDC_WANT_SECURE_LIB__
#define L_tmpnam_s (sizeof(_P_tmpdir) + 16)
#endif  /* __STDC_WANT_SECURE_LIB__ */



/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767  /* SHRT_MAX */
#if __STDC_WANT_SECURE_LIB__
#define TMP_MAX_S       _TMP_MAX_S
#define _TMP_MAX_S      2147483647 /* INT_MAX */
#endif  /* __STDC_WANT_SECURE_LIB__ */

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
#ifndef _INTERNAL_IFSTRIP_
/* These functions are for enabling STATIC_CPPLIB functionality */
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP extern FILE * __cdecl __p__iob(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#ifndef _M_CEE_PURE
_CRTIMP extern FILE _iob[];
#endif  /* _M_CEE_PURE */
#endif  /* _INTERNAL_IFSTRIP_ */
_CRTIMP FILE * __cdecl __iob_func(void);
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF


#if !__STDC__
/* At this point we could switch both to long long, but we won't do that till next version to avoid any potential compat issues */
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else  /* !__STDC__ */
typedef long long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#endif  /* !__STDC__ */

#define _FPOS_T_DEFINED
#endif  /* _FPOS_T_DEFINED */

#ifndef _STDSTREAM_DEFINED
#define stdin  (&__iob_func()[0])
#define stdout (&__iob_func()[1])
#define stderr (&__iob_func()[2])
#define _STDSTREAM_DEFINED
#endif  /* _STDSTREAM_DEFINED */

#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080

/* constants used by _set_output_format */
#define _TWO_DIGIT_EXPONENT 0x1

/* Function prototypes */

#ifndef _STDIO_DEFINED

_Check_return_ _CRTIMP int __cdecl _filbuf(_Inout_ FILE * _File );
_Check_return_opt_ _CRTIMP int __cdecl _flsbuf(_In_ int _Ch, _Inout_ FILE * _File);

_Check_return_ _CRTIMP FILE * __cdecl _fsopen(_In_z_ const char * _Filename, _In_z_ const char * _Mode, _In_ int _ShFlag);

_CRTIMP void __cdecl clearerr(_Inout_ FILE * _File);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl clearerr_s(_Inout_ FILE * _File );
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl fclose(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _fcloseall(void);

_Check_return_ _CRTIMP FILE * __cdecl _fdopen(_In_ int _FileHandle, _In_z_ const char * _Mode);

_Check_return_ _CRTIMP int __cdecl feof(_In_ FILE * _File);
_Check_return_ _CRTIMP int __cdecl ferror(_In_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl fflush(_Inout_opt_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl fgetc(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _fgetchar(void);
_Check_return_opt_ _CRTIMP int __cdecl fgetpos(_Inout_ FILE * _File , _Out_ fpos_t * _Pos);
_Check_return_opt_ _CRTIMP char * __cdecl fgets(_Out_z_cap_(_MaxCount) char * _Buf, _In_ int _MaxCount, _Inout_ FILE * _File);

_Check_return_ _CRTIMP int __cdecl _fileno(_In_ FILE * _File);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_tempnam")
#undef _tempnam
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP char * __cdecl _tempnam(_In_opt_z_ const char * _DirName, _In_opt_z_ const char * _FilePrefix);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_tempnam")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_opt_ _CRTIMP int __cdecl _flushall(void);
_Check_return_ _CRT_INSECURE_DEPRECATE(fopen_s) _CRTIMP FILE * __cdecl fopen(_In_z_ const char * _Filename, _In_z_ const char * _Mode);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl fopen_s(_Deref_out_opt_ FILE ** _File, _In_z_ const char * _Filename, _In_z_ const char * _Mode);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl fprintf(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl fprintf_s(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl fputc(_In_ int _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _fputchar(_In_ int _Ch);
_Check_return_opt_ _CRTIMP int __cdecl fputs(_In_z_ const char * _Str, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP size_t __cdecl fread(_Out_bytecap_x_(_ElementSize*_Count) void * _DstBuf, _In_ size_t _ElementSize, _In_ size_t _Count, _Inout_ FILE * _File);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP size_t __cdecl fread_s(_Out_bytecap_x_(_ElementSize*_Count) void * _DstBuf, _In_ size_t _DstSize, _In_ size_t _ElementSize, _In_ size_t _Count, _Inout_ FILE * _File);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ _CRT_INSECURE_DEPRECATE(freopen_s) _CRTIMP FILE * __cdecl freopen(_In_z_ const char * _Filename, _In_z_ const char * _Mode, _Inout_ FILE * _File);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl freopen_s(_Deref_out_opt_ FILE ** _File, _In_z_ const char * _Filename, _In_z_ const char * _Mode, _Inout_ FILE * _OldFile);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ _CRT_INSECURE_DEPRECATE(fscanf_s) _CRTIMP int __cdecl fscanf(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fscanf_s_l) _CRTIMP int __cdecl _fscanf_l(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl fscanf_s(_Inout_ FILE * _File, _In_z_ _Scanf_s_format_string_ const char * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl _fscanf_s_l(_Inout_ FILE * _File, _In_z_ _Scanf_s_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl fsetpos(_Inout_ FILE * _File, _In_ const fpos_t * _Pos);
_Check_return_opt_ _CRTIMP int __cdecl fseek(_Inout_ FILE * _File, _In_ long _Offset, _In_ int _Origin);
_Check_return_ _CRTIMP long __cdecl ftell(_Inout_ FILE * _File);

_Check_return_opt_ _CRTIMP int __cdecl _fseeki64(_Inout_ FILE * _File, _In_ __int64 _Offset, _In_ int _Origin);
_Check_return_ _CRTIMP __int64 __cdecl _ftelli64(_Inout_ FILE * _File);

_Check_return_opt_ _CRTIMP size_t __cdecl fwrite(_In_count_x_(_Size*_Count) const void * _Str, _In_ size_t _Size, _In_ size_t _Count, _Inout_ FILE * _File);
_Check_return_ _CRTIMP int __cdecl getc(_Inout_ FILE * _File);
_Check_return_ _CRTIMP int __cdecl getchar(void);
_Check_return_ _CRTIMP int __cdecl _getmaxstdio(void);
#if __STDC_WANT_SECURE_LIB__
_CRTIMP char * __cdecl gets_s(_Out_z_cap_(_Size) char * _Buf, _In_ rsize_t _Size);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(char *, gets_s, char, _Buffer)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_SAME, _CRTIMP, gets, _Pre_notnull_ _Post_z_ _Out_z_cap_c_(((size_t)-1)), char, _Buffer)
_Check_return_ int __cdecl _getw(_Inout_ FILE * _File);
#ifndef _CRT_PERROR_DEFINED
#define _CRT_PERROR_DEFINED
_CRTIMP void __cdecl perror(_In_opt_z_ const char * _ErrMsg);
#endif  /* _CRT_PERROR_DEFINED */
_Check_return_opt_ _CRTIMP int __cdecl _pclose(_Inout_ FILE * _File);
_Check_return_ _CRTIMP FILE * __cdecl _popen(_In_z_ const char * _Command, _In_z_ const char * _Mode);
_Check_return_opt_ _CRTIMP int __cdecl printf(_In_z_ _Printf_format_string_ const char * _Format, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl printf_s(_In_z_ _Printf_format_string_ const char * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl putc(_In_ int _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl putchar(_In_ int _Ch);
_Check_return_opt_ _CRTIMP int __cdecl puts(_In_z_ const char * _Str);
_Check_return_opt_ _CRTIMP int __cdecl _putw(_In_ int _Word, _Inout_ FILE * _File);
#ifndef _CRT_DIRECTORY_DEFINED
#define _CRT_DIRECTORY_DEFINED
_Check_return_ _CRTIMP int __cdecl remove(_In_z_ const char * _Filename);
_Check_return_ _CRTIMP int __cdecl rename(_In_z_ const char * _OldFilename, _In_z_ const char * _NewFilename);
_Check_return_ _CRTIMP int __cdecl _unlink(_In_z_ const char * _Filename);
#if !__STDC__
_Check_return_ _CRT_NONSTDC_DEPRECATE(_unlink) _CRTIMP int __cdecl unlink(_In_z_ const char * _Filename);
#endif  /* !__STDC__ */
#endif  /* _CRT_DIRECTORY_DEFINED */
_CRTIMP void __cdecl rewind(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _rmtmp(void);
_Check_return_ _CRT_INSECURE_DEPRECATE(scanf_s) _CRTIMP int __cdecl scanf(_In_z_ _Scanf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_scanf_s_l) _CRTIMP int __cdecl _scanf_l(_In_z_ _Scanf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl scanf_s(_In_z_ _Scanf_s_format_string_ const char * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _scanf_s_l(_In_z_ _Scanf_s_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_CRT_INSECURE_DEPRECATE(setvbuf) _CRTIMP void __cdecl setbuf(_Inout_ FILE * _File, _Inout_opt_cap_c_(BUFSIZ) _Post_count_c_(0) char * _Buffer);
_Check_return_opt_ _CRTIMP int __cdecl _setmaxstdio(_In_ int _Max);
_Check_return_opt_ _CRTIMP unsigned int __cdecl _set_output_format(_In_ unsigned int _Format);
_Check_return_opt_ _CRTIMP unsigned int __cdecl _get_output_format(void);
_Check_return_opt_ _CRTIMP int __cdecl setvbuf(_Inout_ FILE * _File, _Inout_opt_z_bytecap_(_Size) char * _Buf, _In_ int _Mode, _In_ size_t _Size);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snprintf_s(_Out_z_bytecap_(_SizeInBytes) char * _DstBuf, _In_ size_t _SizeInBytes, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snprintf_s, _vsnprintf_s, char, _Dest, _In_ size_t, _MaxCount, _In_z_ _Printf_format_string_ const char *,_Format)
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl sprintf_s(_Out_z_bytecap_(_SizeInBytes) char * _DstBuf, _In_ size_t _SizeInBytes, _In_z_ _Printf_format_string_ const char * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)
_Check_return_ _CRTIMP int __cdecl _scprintf(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(sscanf_s) _CRTIMP int __cdecl sscanf(_In_z_ const char * _Src, _In_z_ _Scanf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sscanf_s_l) _CRTIMP int __cdecl _sscanf_l(_In_z_ const char * _Src, _In_z_ _Scanf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl sscanf_s(_In_z_ const char * _Src, _In_z_ _Scanf_s_format_string_ const char * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _sscanf_s_l(_In_z_ const char * _Src, _In_z_ _Scanf_s_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snscanf_s) _CRTIMP int __cdecl _snscanf(_In_bytecount_(_MaxCount) _Pre_z_ const char * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snscanf_s_l) _CRTIMP int __cdecl _snscanf_l(_In_bytecount_(_MaxCount) _Pre_z_ const char * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snscanf_s(_In_bytecount_(_MaxCount) _Pre_z_ const char * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_s_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snscanf_s_l(_In_bytecount_(_MaxCount) _Pre_z_ const char * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_s_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(tmpfile_s) _CRTIMP FILE * __cdecl tmpfile(void);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl tmpfile_s(_Out_opt_ _Deref_post_valid_ FILE ** _File);
_Check_return_wat_ _CRTIMP errno_t __cdecl tmpnam_s(_Out_z_cap_(_Size) char * _Buf, _In_ rsize_t _Size);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, tmpnam_s, _Deref_post_z_ char, _Buf)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, tmpnam, _Pre_maybenull_ _Post_z_, char, _Buffer)
_Check_return_opt_ _CRTIMP int __cdecl ungetc(_In_ int _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl vfprintf(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vfprintf_s(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl vprintf(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vprintf_s(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(vsnprintf_s) _CRTIMP int __cdecl vsnprintf(_Out_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vsnprintf_s(_Out_z_cap_(_DstSize) char * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vsnprintf_s(_Out_z_cap_(_SizeInBytes) char * _DstBuf, _In_ size_t _SizeInBytes, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int, _vsnprintf_s, char, _Dest, _In_ size_t, _MaxCount, _In_z_ _Printf_format_string_ const char *, _Format, va_list, _Args)
#pragma warning(push)
#pragma warning(disable:4793)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _CRTIMP, _snprintf, _vsnprintf, _Pre_notnull_ _Post_maybez_ char, _Out_cap_(_Count) _Post_maybez_, char, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const char *, _Format)
#pragma warning(pop)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE int __cdecl vsprintf_s(_Out_z_cap_(_SizeInBytes) char * _DstBuf, _In_ size_t _SizeInBytes, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format, va_list, _Args)
#pragma warning(push)
#pragma warning(disable:4793)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(int, __RETURN_POLICY_SAME, _CRTIMP, sprintf, vsprintf, _Pre_notnull_ _Post_z_, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)
#pragma warning(pop)
_Check_return_ _CRTIMP int __cdecl _vscprintf(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _snprintf_c(_Out_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vsnprintf_c(_Out_cap_(_MaxCount) char *_DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _fprintf_p(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _printf_p(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _sprintf_p(_Out_z_cap_(_MaxCount) char * _Dst, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vfprintf_p(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vprintf_p(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vsprintf_p(_Out_z_cap_(_MaxCount) char * _Dst, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
_Check_return_ _CRTIMP int __cdecl _scprintf_p(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_ _CRTIMP int __cdecl _vscprintf_p(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
_CRTIMP int __cdecl _set_printf_count_output(_In_ int _Value);
_CRTIMP int __cdecl _get_printf_count_output();

_Check_return_opt_ _CRTIMP int __cdecl _printf_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _printf_p_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _printf_s_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vprintf_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vprintf_p_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vprintf_s_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _fprintf_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _fprintf_p_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _fprintf_s_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vfprintf_l(_Inout_ FILE * _File, _In_z_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vfprintf_p_l(_Inout_ FILE * _File, _In_z_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vfprintf_s_l(_Inout_ FILE * _File, _In_z_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l) _CRTIMP int __cdecl _sprintf_l(_Pre_notnull_ _Post_z_ char * _DstBuf, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _sprintf_p_l(_Out_z_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _sprintf_s_l(_Out_z_bytecap_(_DstSize) char * _DstBuf, _In_ size_t _DstSize, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsprintf_s_l) _CRTIMP int __cdecl _vsprintf_l(_Pre_notnull_ _Post_z_ char * _DstBuf, _In_z_ const char * _Format, _In_opt_ _locale_t, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vsprintf_p_l(_Out_z_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char* _Format, _In_opt_ _locale_t _Locale,  va_list _ArgList);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vsprintf_s_l(_Out_z_cap_(_DstSize) char * _DstBuf, _In_ size_t _DstSize, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _scprintf_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _scprintf_p_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vscprintf_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vscprintf_p_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snprintf_s_l) _CRTIMP int __cdecl _snprintf_l(_Out_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _snprintf_c_l(_Out_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snprintf_s_l(_Out_z_cap_(_DstSize) char * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnprintf_s_l) _CRTIMP int __cdecl _vsnprintf_l(_Out_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vsnprintf_c_l(_Out_cap_(_MaxCount) char * _DstBuf, _In_ size_t _MaxCount, const char *, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vsnprintf_s_l(_Out_z_cap_(_DstSize) char * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const char* _Format,_In_opt_ _locale_t _Locale, va_list _ArgList);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif  /* WEOF */

_Check_return_ _CRTIMP FILE * __cdecl _wfsopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _In_ int _ShFlag);

_Check_return_opt_ _CRTIMP wint_t __cdecl fgetwc(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _fgetwchar(void);
_Check_return_opt_ _CRTIMP wint_t __cdecl fputwc(_In_ wchar_t _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _fputwchar(_In_ wchar_t _Ch);
_Check_return_ _CRTIMP wint_t __cdecl getwc(_Inout_ FILE * _File);
_Check_return_ _CRTIMP wint_t __cdecl getwchar(void);
_Check_return_opt_ _CRTIMP wint_t __cdecl putwc(_In_ wchar_t _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl putwchar(_In_ wchar_t _Ch);
_Check_return_opt_ _CRTIMP wint_t __cdecl ungetwc(_In_ wint_t _Ch, _Inout_ FILE * _File);

_Check_return_opt_ _CRTIMP wchar_t * __cdecl fgetws(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ int _SizeInWords, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl fputws(_In_z_ const wchar_t * _Str, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wchar_t * __cdecl _getws_s(_Out_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(wchar_t *, _getws_s, wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_SAME, _CRTIMP, _getws, _Pre_notnull_ _Post_z_, wchar_t, _String)
_Check_return_opt_ _CRTIMP int __cdecl _putws(_In_z_ const wchar_t * _Str);

_Check_return_opt_ _CRTIMP int __cdecl fwprintf(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl fwprintf_s(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl wprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl wprintf_s(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ _CRTIMP int __cdecl _scwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl vfwprintf(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vfwprintf_s(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl vwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vwprintf_s(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */

#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE int __cdecl swprintf_s(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, swprintf_s, vswprintf_s, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE int __cdecl vswprintf_s(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vswprintf_s, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, va_list, _Args)

_Check_return_opt_ _CRTIMP int __cdecl _swprintf_c(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_c(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwprintf_s(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snwprintf_s, _vsnwprintf_s, wchar_t, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vsnwprintf_s(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int, _vsnwprintf_s, wchar_t, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const wchar_t *, _Format, va_list, _Args)
#pragma warning(push)
#pragma warning(disable:4793)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _CRTIMP, _snwprintf, _vsnwprintf, _Pre_notnull_ _Post_maybez_ wchar_t, _Out_cap_(_Count) _Post_maybez_, wchar_t, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
#pragma warning(pop)

_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_p(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _wprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_p(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _swprintf_p(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_p(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_ _CRTIMP int __cdecl _scwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_ _CRTIMP int __cdecl _vscwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _wprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _wprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _wprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_p_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_s_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_p_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_s_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _swprintf_c_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _swprintf_p_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _swprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_c_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_p_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vswprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_ _CRTIMP int __cdecl _scwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRTIMP int __cdecl _scwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRTIMP int __cdecl _vscwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwprintf_s_l) _CRTIMP int __cdecl _snwprintf_l(_Out_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwprintf_s_l) _CRTIMP int __cdecl _vsnwprintf_l(_Out_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vsnwprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);


#ifndef _CRT_NON_CONFORMING_SWPRINTFS

#define _SWPRINTFS_DEPRECATED _CRT_DEPRECATE_TEXT("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")

#else  /* _CRT_NON_CONFORMING_SWPRINTFS */

#define _SWPRINTFS_DEPRECATED

#endif  /* _CRT_NON_CONFORMING_SWPRINTFS */

/* we could end up with a double deprecation, disable warnings 4141 and 4996 */
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, _swprintf, _swprintf_s, _vswprintf, vswprintf_s, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, __swprintf_l, __vswprintf_l, _vswprintf_s_l, _Pre_notnull_ _Post_z_ wchar_t, , wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, _locale_t, _Plocinfo)
#pragma warning(pop)

#if !defined (RC_INVOKED) && !defined (__midl)
#include <swprintf.inl>
#endif  /* !defined (RC_INVOKED) && !defined (__midl) */

#ifdef _CRT_NON_CONFORMING_SWPRINTFS
#ifndef __cplusplus
#define swprintf _swprintf
#define vswprintf _vswprintf
#define _swprintf_l __swprintf_l
#define _vswprintf_l __vswprintf_l
#endif  /* __cplusplus */
#endif  /* _CRT_NON_CONFORMING_SWPRINTFS */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wtempnam")
#undef _wtempnam
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP wchar_t * __cdecl _wtempnam(_In_opt_z_ const wchar_t * _Directory, _In_opt_z_ const wchar_t * _FilePrefix);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wtempnam")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP int __cdecl _vscwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_ _CRTIMP int __cdecl _vscwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_ _CRT_INSECURE_DEPRECATE(fwscanf_s) _CRTIMP int __cdecl fwscanf(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fwscanf_s_l) _CRTIMP int __cdecl _fwscanf_l(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl fwscanf_s(_Inout_ FILE * _File, _In_z_ _Scanf_s_format_string_ const wchar_t * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP int __cdecl _fwscanf_s_l(_Inout_ FILE * _File, _In_z_ _Scanf_s_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(swscanf_s) _CRTIMP int __cdecl swscanf(_In_z_ const wchar_t * _Src, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_swscanf_s_l) _CRTIMP int __cdecl _swscanf_l(_In_z_ const wchar_t * _Src, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl swscanf_s(_In_z_ const wchar_t *_Src, _In_z_ _Scanf_s_format_string_ const wchar_t * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _swscanf_s_l(_In_z_ const wchar_t * _Src, _In_z_ _Scanf_s_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s) _CRTIMP int __cdecl _snwscanf(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s_l) _CRTIMP int __cdecl _snwscanf_l(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwscanf_s(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_s_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwscanf_s_l(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_s_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(wscanf_s) _CRTIMP int __cdecl wscanf(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_wscanf_s_l) _CRTIMP int __cdecl _wscanf_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl wscanf_s(_In_z_ _Scanf_s_format_string_ const wchar_t * _Format, ...);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _wscanf_s_l(_In_z_ _Scanf_s_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#pragma warning(pop)

_Check_return_ _CRTIMP FILE * __cdecl _wfdopen(_In_ int _FileHandle , _In_z_ const wchar_t * _Mode);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wfopen_s) _CRTIMP FILE * __cdecl _wfopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wfopen_s(_Deref_out_opt_ FILE ** _File, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wfreopen_s) _CRTIMP FILE * __cdecl _wfreopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _Inout_ FILE * _OldFile);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wfreopen_s(_Deref_out_opt_ FILE ** _File, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _Inout_ FILE * _OldFile);

#ifndef _CRT_WPERROR_DEFINED
#define _CRT_WPERROR_DEFINED
_CRTIMP void __cdecl _wperror(_In_opt_z_ const wchar_t * _ErrMsg);
#endif  /* _CRT_WPERROR_DEFINED */
_Check_return_ _CRTIMP FILE * __cdecl _wpopen(_In_z_ const wchar_t *_Command, _In_z_ const wchar_t * _Mode);
_Check_return_ _CRTIMP int __cdecl _wremove(_In_z_ const wchar_t * _Filename);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wtmpnam_s(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wtmpnam_s, _Deref_post_z_ wchar_t, _Buffer)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wtmpnam, _Pre_maybenull_ _Post_z_, wchar_t, _Buffer)

_Check_return_opt_ _CRTIMP wint_t __cdecl _fgetwc_nolock(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _fputwc_nolock(_In_ wchar_t _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _ungetwc_nolock(_In_ wint_t _Ch, _Inout_ FILE * _File);

#ifdef _CRTBLD
#ifndef _INTERNAL_IFSTRIP_
#define _CRT_GETPUTWCHAR_NOINLINE
#else  /* _INTERNAL_IFSTRIP_ */
#undef _CRT_GETPUTWCHAR_NOINLINE
#endif  /* _INTERNAL_IFSTRIP_ */
#endif  /* _CRTBLD */

#if !defined (__cplusplus) || defined (_M_CEE_PURE) || defined (_CRT_GETPUTWCHAR_NOINLINE)
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else  /* !defined (__cplusplus) || defined (_M_CEE_PURE) || defined (_CRT_GETPUTWCHAR_NOINLINE) */
inline wint_t __CRTDECL getwchar()
        {return (fgetwc(stdin)); }   /* stdin */
inline wint_t __CRTDECL putwchar(wchar_t _C)
        {return (fputwc(_C, stdout)); }       /* stdout */
#endif  /* !defined (__cplusplus) || defined (_M_CEE_PURE) || defined (_CRT_GETPUTWCHAR_NOINLINE) */

#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)
#define _putwc_nolock(_c,_stm)     _fputwc_nolock(_c,_stm)
#define _getwc_nolock(_stm)        _fgetwc_nolock(_stm)

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define fgetwc(_stm)            _getwc_nolock(_stm)
#define fputwc(_c,_stm)         _putwc_nolock(_c,_stm)
#define ungetwc(_c,_stm)        _ungetwc_nolock(_c,_stm)
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */

#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define fgetc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getc(_stream)    fgetc(_stream)
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */


#define _fgetc_nolock(_stream)       (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define _fputc_nolock(_c,_stream)    (--(_stream)->_cnt >= 0 ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define _getc_nolock(_stream)       _fgetc_nolock(_stream)
#define _putc_nolock(_c, _stream)   _fputc_nolock(_c, _stream)
#define _getchar_nolock()           _getc_nolock(stdin)
#define _putchar_nolock(_c)         _putc_nolock((_c),stdout)
#define _getwchar_nolock()          _getwc_nolock(stdin)
#define _putwchar_nolock(_c)        _putwc_nolock((_c),stdout)

_CRTIMP void __cdecl _lock_file(_Inout_ FILE * _File);
_CRTIMP void __cdecl _unlock_file(_Inout_ FILE * _File);


_Check_return_opt_ _CRTIMP int __cdecl _fclose_nolock(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _fflush_nolock(_Inout_opt_ FILE * _File);
_Check_return_opt_ _CRTIMP size_t __cdecl _fread_nolock(_Out_bytecap_x_(_ElementSize*_Count) void * _DstBuf, _In_ size_t _ElementSize, _In_ size_t _Count, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP size_t __cdecl _fread_nolock_s(_Out_bytecap_x_(_ElementSize*_Count) void * _DstBuf, _In_ size_t _DstSize, _In_ size_t _ElementSize, _In_ size_t _Count, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _fseek_nolock(_Inout_ FILE * _File, _In_ long _Offset, _In_ int _Origin);
_Check_return_ _CRTIMP long __cdecl _ftell_nolock(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _fseeki64_nolock(_Inout_ FILE * _File, _In_ __int64 _Offset, _In_ int _Origin);
_Check_return_ _CRTIMP __int64 __cdecl _ftelli64_nolock(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP size_t __cdecl _fwrite_nolock(_In_bytecount_x_(_Size*_Count) const void * _DstBuf, _In_ size_t _Size, _In_ size_t _Count, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl _ungetc_nolock(_In_ int _Ch, _Inout_ FILE * _File);

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define fclose(_stm)                                            _fclose_nolock(_stm)
#define fflush(_stm)                                            _fflush_nolock(_stm)
#define fread(_DstBuf, _ElementSize, _Count, _File)             _fread_nolock(_DstBuf, _ElementSize, _Count, _File)
#define fread_s(_DstBuf, _DstSize, _ElementSize, _Count, _File) _fread_nolock_s(_DstBuf, _DstSize, _ElementSize, _Count, _File)
#define fseek(_stm,_offset,_origin)                             _fseek_nolock(_stm,_offset,_origin)
#define ftell(_stm)                                             _ftell_nolock(_stm)
#define _fseeki64(_stm,_offset,_origin)                         _fseeki64_nolock(_stm,_offset,_origin)
#define _ftelli64(_stm)                                         _ftelli64_nolock(_stm)
#define fwrite(_buf,_siz,_cnt,_stm)                             _fwrite_nolock(_buf,_siz,_cnt,_stm)
#define ungetc(_c,_stm)                                         _ungetc_nolock(_c,_stm)
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */

#if !__STDC__

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("tempnam")
#undef tempnam
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_CRT_NONSTDC_DEPRECATE(_tempnam) _CRTIMP char * __cdecl tempnam(_In_opt_z_ const char * _Directory, _In_opt_z_ const char * _FilePrefix);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("tempnam")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fcloseall) _CRTIMP int __cdecl fcloseall(void);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_fdopen) _CRTIMP FILE * __cdecl fdopen(_In_ int _FileHandle, _In_z_ const char * _Format);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fgetchar) _CRTIMP int __cdecl fgetchar(void);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_fileno) _CRTIMP int __cdecl fileno(_In_ FILE * _File);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_flushall) _CRTIMP int __cdecl flushall(void);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fputchar) _CRTIMP int __cdecl fputchar(_In_ int _Ch);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_getw) _CRTIMP int __cdecl getw(_Inout_ FILE * _File);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_putw) _CRTIMP int __cdecl putw(_In_ int _Ch, _Inout_ FILE * _File);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_rmtmp) _CRTIMP int __cdecl rmtmp(void);

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strchr.c ===
/***
*strchr.c - search a string for a given character
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines strchr() - search a string for a character
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strchr(string, c) - search a string for a character
*
*Purpose:
*       Searches a string for a given character, which may be the
*       null character '\0'.
*
*Entry:
*       char *string - string to search in
*       char c - character to search for
*
*Exit:
*       returns pointer to the first occurence of c in string
*       returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strchr (
        const char * string,
        int ch
        )
{
        while (*string && *string != (char)ch)
                string++;

        if (*string == (char)ch)
                return((char *)string);
        return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strcat.c ===
/***
*strcat.c - contains strcat() and strcpy()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Strcpy() copies one string onto another.
*
*       Strcat() concatenates (appends) a copy of the source string to the
*       end of the destination string, returning the destination string.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifndef _MBSCAT
#ifdef _MSC_VER
#pragma function(strcat,strcpy)
#endif  /* _MSC_VER */
#endif  /* _MBSCAT */

/***
*char *strcat(dst, src) - concatenate (append) one string to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       char *dst - string to which "src" is to be appended
*       const char *src - string to be appended to the end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strcat (
        char * dst,
        const char * src
        )
{
        char * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */

}


/***
*char *strcpy(dst, src) - copy one string over another
*
*Purpose:
*       Copies the string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       char * dst - string over which "src" is to be copied
*       const char * src - string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

char * __cdecl strcpy(char * dst, const char * src)
{
        char * cp = dst;

        while( *cp++ = *src++ )
                ;               /* Copy src over dst */

        return( dst );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strcat_s.c ===
/***
*strcat_s.c - contains strcat_s()
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   strcat_s() concatenates (appends) a copy of the source string to the
*   end of the destination string.
*
*******************************************************************************/

#include <string.h>
#include <internal_securecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME strcat_s
#define _CHAR char
#define _DEST _Dst
#define _SIZE _SizeInBytes
#define _SRC _Src

#include <tcscat_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdthrow.cpp ===
// throw -- terminate on thrown exception REPLACEABLE
#define _HAS_EXCEPTIONS 0
#include <cstdio>
#include <cstdlib>
#include <exception>
#include <crtdbg.h>
_STD_BEGIN


_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const char *s1, const char *s2)
	{	// legacy report error and die
	::fflush(0);
	::fputs(s1, _cpp_stderr);
	::fputs(s2 != 0 ? s2 : "unknown", _cpp_stderr);
	::fputs("\n", _cpp_stderr);
	::abort();
	}

#ifdef _DEBUG
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const wchar_t *message, const wchar_t *file, unsigned int line)
	{	// report error and die
        if(::_CrtDbgReportW(_CRT_ASSERT, file, line, NULL, message)==1)
        {
            ::_CrtDbgBreak();
        }
	}
_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const unsigned short *message, const unsigned short *file, unsigned int line)
	{	// report error and die
        _Debug_message((wchar_t *) message, (wchar_t *) file, line);
	}

#endif

_STD_END

_X_STD_BEGIN

_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Throw(const exception& ex)
	{	// report throw exception and die
	std::_Debug_message("exception: ", ex.what());
	}

_X_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strcpy_s.c ===
/***
*strcpy_s.c - contains strcpy_s()
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   strcpy_s() copies one string onto another.
*
*******************************************************************************/

#include <string.h>
#include <internal_securecrt.h>

#define _FUNC_PROLOGUE
#define _FUNC_NAME strcpy_s
#define _CHAR char
#define _DEST _Dst
#define _SIZE _SizeInBytes
#define _SRC _Src

#include <tcscpy_s.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strdup.c ===
/***
*strdup.c - duplicate a string in malloc'd memory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _strdup() - grab new memory, and duplicate the string into it.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <string.h>
#include <internal.h>

/***
*char *_strdup(string) - duplicate string into malloc'd memory
*
*Purpose:
*       Allocates enough storage via malloc() for a copy of the
*       string, copies the string into the new memory, and returns
*       a pointer to it.
*
*Entry:
*       char *string - string to copy into new memory
*
*Exit:
*       returns a pointer to the newly allocated storage with the
*       string in it.
*
*       returns NULL if enough memory could not be allocated, or
*       string was NULL.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _DEBUG

#include <crtdbg.h>

char * __cdecl _strdup (
        const char * string
        )
{
        return _strdup_dbg(string, _NORMAL_BLOCK, NULL, 0);
}

char * __cdecl _strdup_dbg (
        const char * string,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )

#else  /* _DEBUG */

char * __cdecl _strdup (
        const char * string
        )

#endif  /* _DEBUG */

{
        char *memory;
    size_t size = 0;

        if (!string)
                return(NULL);

    size = strlen(string) + 1;
#ifdef _DEBUG
        if (memory = _malloc_dbg(size, nBlockUse, szFileName, nLine))
#else  /* _DEBUG */
        if (memory = malloc(size))
#endif  /* _DEBUG */
        {
                _ERRCHECK(strcpy_s(memory, size, string));
        return memory;
        }

        return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strcmp.c ===
/***
*strcmp.c - routine to compare two strings (for equal, less, or greater)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compares two string, determining their lexical order.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef _MSC_VER
#pragma function(strcmp)
#endif  /* _MSC_VER */

/***
*strcmp - compare two strings, returning less than, equal to, or greater than
*
*Purpose:
*       STRCMP compares two strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done byte by byte on an UNSIGNED basis, which is to
*       say that Null (0) is less than any other character (1-255).
*
*Entry:
*       const char * src - string for left-hand side of comparison
*       const char * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strcmp (
        const char * src,
        const char * dst
        )
{
        int ret = 0 ;

        while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
                ++src, ++dst;

        if ( ret < 0 )
                ret = -1 ;
        else if ( ret > 0 )
                ret = 1 ;

        return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_STDLIB
#define _INC_STDLIB

#include <crtdefs.h>
#include <limits.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED

#if !defined (_M_CEE_PURE)
typedef int (__cdecl * _onexit_t)(void);
#else  /* !defined (_M_CEE_PURE) */
typedef int (__clrcall * _onexit_t)(void);
typedef _onexit_t _onexit_m_t;
#endif  /* !defined (_M_CEE_PURE) */

#if defined (_M_CEE_MIXED)
typedef int (__clrcall * _onexit_m_t)(void);
#endif  /* defined (_M_CEE_MIXED) */

#if !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif  /* !__STDC__ */

#define _ONEXIT_T_DEFINED
#endif  /* _ONEXIT_T_DEFINED */


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif  /* _DIV_T_DEFINED */

/*
 * structs used to fool the compiler into not generating floating point
 * instructions when copying and pushing [long] double values
 */

#ifndef _CRT_DOUBLE_DEC

#ifndef _LDSUPPORT

#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()

#define _PTR_LD(x) ((unsigned char  *)(&(x)->ld))

#else  /* _LDSUPPORT */

/* push and pop long, which is #defined as __int64 by a spec2k test */
#pragma push_macro("long")
#undef long
typedef long double _LDOUBLE;
#pragma pop_macro("long")

#define _PTR_LD(x) ((unsigned char  *)(x))

#endif  /* _LDSUPPORT */

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;

/* push and pop long, which is #defined as __int64 by a spec2k test */
#pragma push_macro("long")
#undef long

typedef struct {
        /*
         * Assume there is a long double type
         */
        long double x;
} _LONGDOUBLE;

#pragma pop_macro("long")

#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()

#define _CRT_DOUBLE_DEC
#endif  /* _CRT_DOUBLE_DEC */

/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#define __MB_CUR_MAX(ptloci) (ptloci)->mb_cur_max
#endif  /* _INTERNAL_IFSTRIP_ */
#define MB_CUR_MAX ___mb_cur_max_func()
#if !defined (_M_CEE_PURE)
_CRTIMP extern int __mb_cur_max;
#else  /* !defined (_M_CEE_PURE) */
_CRTIMP int* __cdecl __p___mb_cur_max();
#define __mb_cur_max (*__p___mb_cur_max())
#endif  /* !defined (_M_CEE_PURE) */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
_CRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t);
#endif  /* MB_CUR_MAX */

/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

/*
 * Argument values for _set_abort_behavior().
 */
#define _WRITE_ABORT_MSG    0x1
#define _CALL_REPORTFAULT   0x2

/*
 * Sizes for buffers used by the getenv/putenv family of functions.
 */
#define _MAX_ENV 32767

#if !defined (_M_CEE_PURE)
/* a purecall handler procedure. Never returns normally */
typedef void (__cdecl *_purecall_handler)(void);

/* establishes a purecall handler for the process */
_CRTIMP _purecall_handler __cdecl _set_purecall_handler(_In_opt_ _purecall_handler _Handler);
_CRTIMP _purecall_handler __cdecl _get_purecall_handler();
#endif  /* !defined (_M_CEE_PURE) */

#if defined (__cplusplus)
extern "C++"
{
#if defined (_M_CEE_PURE)
    typedef void (__clrcall *_purecall_handler)(void);
    typedef _purecall_handler _purecall_handler_m;
    _MRTIMP _purecall_handler __cdecl _set_purecall_handler(_In_opt_ _purecall_handler _Handler);
#endif  /* defined (_M_CEE_PURE) */

#if defined (_M_CEE_MIXED)
    typedef void (__clrcall *_purecall_handler_m)(void);

    _MRTIMP _purecall_handler_m __cdecl _set_purecall_handler(_In_opt_ _purecall_handler_m _Handler);

    _MRTIMP _purecall_handler __cdecl _set_purecall_handler(_In_ int _Handler); /* To disambiguate NULL/0 */
#endif  /* defined (_M_CEE_MIXED) */
}
#endif  /* defined (__cplusplus) */

#if !defined (_M_CEE_PURE)
/* a invalid_arg handler procedure. */
typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);

/* establishes a invalid_arg handler for the process */
_CRTIMP _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_In_opt_ _invalid_parameter_handler _Handler);
_CRTIMP _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#endif  /* !defined (_M_CEE_PURE) */

#if defined (__cplusplus)
extern "C++"
{
#if defined (_M_CEE_PURE)
    typedef void (__clrcall *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
    typedef _invalid_parameter_handler _invalid_parameter_handler_m;
    _MRTIMP _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_In_opt_ _invalid_parameter_handler _Handlerh);
#endif  /* defined (_M_CEE_PURE) */

#if defined (_M_CEE_MIXED)
    typedef void (__clrcall *_invalid_parameter_handler_m)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
    _MRTIMP _invalid_parameter_handler_m __cdecl _set_invalid_parameter_handler(_In_opt_ _invalid_parameter_handler_m _Handlerh);

    _MRTIMP _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_In_ int _Handler); /* To disambiguate NULL/0, only when we have both */
#endif  /* defined (_M_CEE_MIXED) */
}
#endif  /* defined (__cplusplus) */

/* External variable declarations */
#ifndef _CRT_ERRNO_DEFINED
#define _CRT_ERRNO_DEFINED
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())

errno_t __cdecl _set_errno(_In_ int _Value);
errno_t __cdecl _get_errno(_Out_ int * _Value);
#endif  /* _CRT_ERRNO_DEFINED */

_CRTIMP unsigned long * __cdecl __doserrno(void);
#define _doserrno   (*__doserrno())

errno_t __cdecl _set_doserrno(_In_ unsigned long _Value);
errno_t __cdecl _get_doserrno(_Out_ unsigned long * _Value);

/* you can't modify this, but it is non-const for backcompat */
_CRTIMP _CRT_INSECURE_DEPRECATE(strerror) char ** __cdecl __sys_errlist(void);
#define _sys_errlist (__sys_errlist())

_CRTIMP _CRT_INSECURE_DEPRECATE(strerror) int * __cdecl __sys_nerr(void);
#define _sys_nerr (*__sys_nerr())

#if defined (_DLL) && defined (_M_IX86)

_CRTIMP int *          __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP char **        __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);

#ifndef _INTERNAL_IFSTRIP_
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int *          __cdecl __p__fmode(void);

#endif  /* _INTERNAL_IFSTRIP_ */

#endif  /* defined (_DLL) && defined (_M_IX86) */

#if !defined (_M_CEE_PURE)
_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */
#else  /* !defined (_M_CEE_PURE) */
_CRTIMP int* __cdecl __p___argc();
_CRTIMP char*** __cdecl __p___argv();
_CRTIMP wchar_t*** __cdecl __p___wargv();
#define __argv (*__p___argv())
#define __argc (*__p___argc())
#define __wargv (*__p___wargv())
#endif  /* !defined (_M_CEE_PURE) */

#if !defined (_M_CEE_PURE)
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */

_CRT_INSECURE_DEPRECATE_GLOBALS(_get_pgmptr) _CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_wpgmptr) _CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

#ifndef _INTERNAL_IFSTRIP_

_DEFINE_SET_FUNCTION(_set_pgmptr, char *, _pgmptr)
_DEFINE_SET_FUNCTION(_set_wpgmptr, wchar_t *, _wpgmptr)

#endif  /* _INTERNAL_IFSTRIP_ */

#else  /* !defined (_M_CEE_PURE) */

_CRTIMP char*** __cdecl __p__environ();
_CRTIMP wchar_t*** __cdecl __p__wenviron();
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_pgmptr) _CRTIMP char** __cdecl __p__pgmptr();
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_wpgmptr) _CRTIMP wchar_t** __cdecl __p__wpgmptr();

#define _environ   (*__p__environ())
#define _wenviron  (*__p__wenviron())
#define _pgmptr    (*__p__pgmptr())
#define _wpgmptr   (*__p__wpgmptr())

#endif  /* !defined (_M_CEE_PURE) */

errno_t __cdecl _get_pgmptr(_Deref_out_z_ char ** _Value);
errno_t __cdecl _get_wpgmptr(_Deref_out_z_ wchar_t ** _Value);


#ifdef SPECIAL_CRTEXE
extern int _fmode;          /* default file translation mode */
#else  /* SPECIAL_CRTEXE */
#if !defined (_M_CEE_PURE)
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_fmode) _CRTIMP extern int _fmode;          /* default file translation mode */
#else  /* !defined (_M_CEE_PURE) */
_CRTIMP int* __cdecl __p__fmode();
#define _fmode (*__p__fmode())
#endif  /* !defined (_M_CEE_PURE) */
#endif  /* SPECIAL_CRTEXE */

_CRTIMP errno_t __cdecl _set_fmode(_In_ int _Mode);
_CRTIMP errno_t __cdecl _get_fmode(_Out_ int * _PMode);

/* _countof helper */
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */

/* function prototypes */

#ifndef _CRT_TERMINATE_DEFINED
#define _CRT_TERMINATE_DEFINED
_CRTIMP __declspec(noreturn) void __cdecl exit(_In_ int _Code);
_CRTIMP __declspec(noreturn) void __cdecl _exit(_In_ int _Code);
_CRTIMP void __cdecl abort(void);
#endif  /* _CRT_TERMINATE_DEFINED */

_CRTIMP unsigned int __cdecl _set_abort_behavior(_In_ unsigned int _Flags, _In_ unsigned int _Mask);

#ifndef _CRT_ABS_DEFINED
#define _CRT_ABS_DEFINED
        int     __cdecl abs(_In_ int _X);
        long    __cdecl labs(_In_ long _X);
#endif  /* _CRT_ABS_DEFINED */

        __int64    __cdecl _abs64(__int64);
#if _MSC_VER >= 1400 && defined(_M_CEE)
#pragma warning (suppress: 4985)
        _Check_return_ int    __clrcall _atexit_m_appdomain(_In_opt_ void (__clrcall * _Func)(void));
#if defined (_M_CEE_MIXED)
#pragma warning (suppress: 4985)
        _Check_return_ int    __clrcall _atexit_m(_In_opt_ void (__clrcall * _Func)(void));
#else  /* defined (_M_CEE_MIXED) */
        _Check_return_ inline int __clrcall _atexit_m(_In_opt_ void (__clrcall *_Function)(void))
#pragma warning (suppress: 4985)
        {
            return _atexit_m_appdomain(_Function);
        }
#endif  /* defined (_M_CEE_MIXED) */
#endif  /* _MSC_VER >= 1400 && defined(_M_CEE) */
#if defined (_M_CEE_PURE)
        /* In pure mode, atexit is the same as atexit_m_appdomain */
extern "C++"
{
inline  int    __clrcall atexit
(
    void (__clrcall *_Function)(void)
)
{
    return _atexit_m_appdomain(_Function);
}
}
#else  /* defined (_M_CEE_PURE) */
        int    __cdecl atexit(void (__cdecl *)(void));
#endif  /* defined (_M_CEE_PURE) */
#ifndef _CRT_ATOF_DEFINED
#define _CRT_ATOF_DEFINED
_Check_return_ _CRTIMP double  __cdecl atof(_In_z_ const char *_String);
_Check_return_ _CRTIMP double  __cdecl _atof_l(_In_z_ const char *_String, _In_opt_ _locale_t _Locale);
#endif  /* _CRT_ATOF_DEFINED */
_Check_return_ _CRTIMP _CRT_JIT_INTRINSIC int    __cdecl atoi(_In_z_ const char *_Str);
_Check_return_ _CRTIMP int    __cdecl _atoi_l(_In_z_ const char *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP long   __cdecl atol(_In_z_ const char *_Str);
_Check_return_ _CRTIMP long   __cdecl _atol_l(_In_z_ const char *_Str, _In_opt_ _locale_t _Locale);
#ifndef _CRT_ALGO_DEFINED
#define _CRT_ALGO_DEFINED
#if __STDC_WANT_SECURE_LIB__
_Check_return_ _CRTIMP void * __cdecl bsearch_s(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements * _SizeOfElements) const void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ _CRTIMP void * __cdecl bsearch(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements * _SizeOfElements) const void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));

#if __STDC_WANT_SECURE_LIB__
_CRTIMP void __cdecl qsort_s(_Inout_bytecap_x_(_NumOfElements* _SizeOfElements) void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_CRTIMP void __cdecl qsort(_Inout_bytecap_x_(_NumOfElements * _SizeOfElements) void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__cdecl * _PtFuncCompare)(const void *, const void *));
#endif  /* _CRT_ALGO_DEFINED */
        _Check_return_ unsigned short __cdecl _byteswap_ushort(_In_ unsigned short _Short);
        _Check_return_ unsigned long  __cdecl _byteswap_ulong (_In_ unsigned long _Long);
        _Check_return_ unsigned __int64 __cdecl _byteswap_uint64(_In_ unsigned __int64 _Int64);
_Check_return_ _CRTIMP div_t  __cdecl div(_In_ int _Numerator, _In_ int _Denominator);
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_dupenv_s) char * __cdecl getenv(_In_z_ const char * _VarName);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP errno_t __cdecl getenv_s(_Out_ size_t * _ReturnSize, _Out_z_cap_(_DstSize) char * _DstBuf, _In_ rsize_t _DstSize, _In_z_ const char * _VarName);
#endif  /* __STDC_WANT_SECURE_LIB__ */
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, getenv_s, _Out_ size_t *, _ReturnSize, char, _Dest, _In_z_ const char *, _VarName)
#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_dupenv_s")
#undef _dupenv_s
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_opt_ _CRTIMP errno_t __cdecl _dupenv_s(_Out_ _Deref_post_opt_z_cap_(*_PBufferSizeInBytes) char **_PBuffer, _Out_opt_ size_t * _PBufferSizeInBytes, _In_z_ const char * _VarName);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_dupenv_s")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_opt_ _CRTIMP errno_t __cdecl _itoa_s(_In_ int _Value, _Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(char *, __RETURN_POLICY_DST, _CRTIMP, _itoa, _In_ int, _Value, _Pre_notnull_ _Post_z_, char, _Dest, _In_ int, _Radix)
_Check_return_opt_ _CRTIMP errno_t __cdecl _i64toa_s(_In_ __int64 _Val, _Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ int _Radix);
_CRTIMP _CRT_INSECURE_DEPRECATE(_i64toa_s) char * __cdecl _i64toa(_In_ __int64 _Val, _Pre_notnull_ _Post_z_ char * _DstBuf, _In_ int _Radix);
_Check_return_opt_ _CRTIMP errno_t __cdecl _ui64toa_s(_In_ unsigned __int64 _Val, _Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ int _Radix);
_CRTIMP _CRT_INSECURE_DEPRECATE(_ui64toa_s) char * __cdecl _ui64toa(_In_ unsigned __int64 _Val, _Pre_notnull_ _Post_z_ char * _DstBuf, _In_ int _Radix);
_Check_return_ _CRTIMP __int64 __cdecl _atoi64(_In_z_ const char * _String);
_Check_return_ _CRTIMP __int64 __cdecl _atoi64_l(_In_z_ const char * _String, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP __int64 __cdecl _strtoi64(_In_z_ const char * _String, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP __int64 __cdecl _strtoi64_l(_In_z_ const char * _String, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned __int64 __cdecl _strtoui64(_In_z_ const char * _String, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP unsigned __int64 __cdecl _strtoui64_l(_In_z_ const char * _String, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_ int  _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP ldiv_t __cdecl ldiv(_In_ long _Numerator, _In_ long _Denominator);
#ifdef __cplusplus
extern "C++"
{
    inline ldiv_t  div(_In_ long _A1, _In_ long _A2)
    {
        return ldiv(_A1, _A2);
    }
}
#endif  /* __cplusplus */
_Check_return_opt_ _CRTIMP errno_t __cdecl _ltoa_s(_In_ long _Val, _Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ltoa_s, _In_ long, _Value, char, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(char *, __RETURN_POLICY_DST, _CRTIMP, _ltoa, _In_ long, _Value, _Pre_notnull_ _Post_z_, char, _Dest, _In_ int, _Radix)
_Check_return_ _CRTIMP int    __cdecl mblen(_In_opt_bytecount_(_MaxCount) _Pre_opt_z_ const char * _Ch, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int    __cdecl _mblen_l(_In_opt_bytecount_(_MaxCount) _Pre_opt_z_ const char * _Ch, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP size_t __cdecl _mbstrlen(_In_z_ const char * _Str);
_Check_return_ _CRTIMP size_t __cdecl _mbstrlen_l(_In_z_ const char *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP size_t __cdecl _mbstrnlen(_In_z_ const char *_Str, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP size_t __cdecl _mbstrnlen_l(_In_z_ const char *_Str, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRTIMP int    __cdecl mbtowc(_Pre_notnull_ _Post_z_ wchar_t * _DstCh, _In_opt_bytecount_(_SrcSizeInBytes) _Pre_opt_z_ const char * _SrcCh, _In_ size_t _SrcSizeInBytes);
_CRTIMP int    __cdecl _mbtowc_l(_Pre_notnull_ _Post_z_ wchar_t * _DstCh, _In_opt_bytecount_(_SrcSizeInBytes) _Pre_opt_z_ const char * _SrcCh, _In_ size_t _SrcSizeInBytes, _In_opt_ _locale_t _Locale);
_Check_return_opt_ _CRTIMP errno_t __cdecl mbstowcs_s(_Out_opt_ size_t * _PtNumOfCharConverted, _Out_opt_cap_post_count_(_SizeInWords, *_PtNumOfCharConverted) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_count_(_MaxCount) _Pre_z_ const char * _SrcBuf, _In_ size_t _MaxCount );
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(errno_t, mbstowcs_s, _Out_opt_ size_t *, _PtNumOfCharConverted, _Deref_post_z_ wchar_t, _Dest, _In_z_ const char *, _Source, _In_ size_t, _MaxCount)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_CRTIMP, mbstowcs, _Out_opt_z_cap_(_MaxCount), wchar_t, _Dest, _In_z_ const char *, _Source, _In_ size_t, _MaxCount)

_Check_return_opt_ _CRTIMP errno_t __cdecl _mbstowcs_s_l(_Out_opt_ size_t * _PtNumOfCharConverted, _Out_opt_cap_post_count_(_SizeInWords, *_PtNumOfCharConverted) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_count_(_MaxCount) _Pre_z_ const char * _SrcBuf, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(errno_t, _mbstowcs_s_l, _Out_opt_ size_t *, _PtNumOfCharConverted, wchar_t, _Dest, _In_z_ const char *, _Source, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_CRTIMP, _mbstowcs_l, _mbstowcs_s_l, _Out_opt_z_cap_(_Size) wchar_t, _Out_z_cap_(_MaxCount), wchar_t, _Dest, _In_z_ const char *, _Source, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)

_Check_return_ _CRTIMP int    __cdecl rand(void);
#if defined (_CRT_RAND_S)
_CRTIMP errno_t __cdecl rand_s ( _Out_ unsigned int *_RandomValue);
#endif  /* defined (_CRT_RAND_S) */

_Check_return_opt_ _CRTIMP int    __cdecl _set_error_mode(_In_ int _Mode);

_CRTIMP void   __cdecl srand(_In_ unsigned int _Seed);
_Check_return_ _CRTIMP double __cdecl strtod(_In_z_ const char * _Str, _Out_opt_ _Deref_post_z_ char ** _EndPtr);
_Check_return_ _CRTIMP double __cdecl _strtod_l(_In_z_ const char * _Str, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP long   __cdecl strtol(_In_z_ const char * _Str, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_ int _Radix );
_Check_return_ _CRTIMP long   __cdecl _strtol_l(_In_z_ const char *_Str, _Out_opt_ _Deref_post_z_ char **_EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned long __cdecl strtoul(_In_z_ const char * _Str, _Out_opt_ _Deref_post_z_ char ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP unsigned long __cdecl _strtoul_l(const char * _Str, _Out_opt_ _Deref_post_z_ char **_EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);
#ifndef _CRT_SYSTEM_DEFINED
#define _CRT_SYSTEM_DEFINED
_CRTIMP int __cdecl system(_In_opt_z_ const char * _Command);
#endif  /* _CRT_SYSTEM_DEFINED */
_Check_return_opt_ _CRTIMP errno_t __cdecl _ultoa_s(_In_ unsigned long _Val, _Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ultoa_s, _In_ unsigned long, _Value, char, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(char *, __RETURN_POLICY_DST, _CRTIMP, _ultoa, _In_ unsigned long, _Value, _Pre_notnull_ _Post_z_, char, _Dest, _In_ int, _Radix)
_CRTIMP _CRT_INSECURE_DEPRECATE(wctomb_s) int    __cdecl wctomb(_Out_opt_z_bytecap_c_(MB_LEN_MAX) char * _MbCh, _In_ wchar_t _WCh);
_CRTIMP _CRT_INSECURE_DEPRECATE(_wctomb_s_l) int    __cdecl _wctomb_l(_Pre_maybenull_ _Post_z_ char * _MbCh, _In_ wchar_t _WCh, _In_opt_ _locale_t _Locale);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl wctomb_s(_Out_opt_ int * _SizeConverted, _Out_opt_bytecap_post_bytecount_(_SizeInBytes, *_SizeConverted) char * _MbCh, _In_ rsize_t _SizeInBytes, _In_ wchar_t _WCh);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_wat_ _CRTIMP errno_t __cdecl _wctomb_s_l(_Out_opt_ int * _SizeConverted, _Out_opt_z_bytecap_(_SizeInBytes) char * _MbCh, _In_ size_t _SizeInBytes, _In_ wchar_t _WCh, _In_opt_ _locale_t _Locale);
_Check_return_wat_ _CRTIMP errno_t __cdecl wcstombs_s(_Out_opt_ size_t * _PtNumOfCharConverted, _Out_opt_bytecap_post_bytecount_(_DstSizeInBytes, *_PtNumOfCharConverted) char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const wchar_t * _Src, _In_ size_t _MaxCountInBytes);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(errno_t, wcstombs_s, _Out_opt_ size_t *, _PtNumOfCharConverted, _Out_opt_bytecap_(_Size) char, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _MaxCount)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_CRTIMP, wcstombs, _Out_opt_z_cap_(_MaxCount), char, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _MaxCount)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcstombs_s_l(_Out_opt_ size_t * _PtNumOfCharConverted, _Out_opt_bytecap_post_bytecount_(_DstSizeInBytes, *_PtNumOfCharConverted) char * _Dst, _In_ size_t _DstSizeInBytes, _In_z_ const wchar_t * _Src, _In_ size_t _MaxCountInBytes, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(errno_t, _wcstombs_s_l, _Out_opt_ size_t *,_PtNumOfCharConverted, _Out_opt_cap_(_Size) char, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_CRTIMP, _wcstombs_l, _wcstombs_s_l, _Out_opt_z_cap_(_Size) char, _Out_z_cap_(_MaxCount), char, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)

#if _MSC_VER >= 1400 && defined(__cplusplus) && defined(_M_CEE)
/*
 * Managed search routines. Note __cplusplus, this is because we only support
 * managed C++.
 */
extern "C++"
{
#if __STDC_WANT_SECURE_LIB__
_Check_return_ void * __clrcall bsearch_s(_In_ const void * _Key, _In_bytecount_x_(_NumOfElements*_SizeOfElements) const void * _Base, _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
_Check_return_ void * __clrcall bsearch  (_In_ const void * _Key, _In_bytecount_x_(_NumOfElements*_SizeOfElements) const void * _Base, _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(const void *, const void *));

#if __STDC_WANT_SECURE_LIB__
void __clrcall qsort_s(_Inout_bytecap_x_(_NumOfElements*_SizeOfElements) _Post_bytecount_x_(_NumOfElements*_SizeOfElements) void * _Base,
        _In_ rsize_t _NumOfElements, _In_ rsize_t _SizeOfElment,
        _In_ int (__clrcall * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#endif  /* __STDC_WANT_SECURE_LIB__ */
void __clrcall qsort(_Inout_bytecap_x_(_NumOfElements*_SizeOfElements) _Post_bytecount_x_(_NumOfElements*_SizeOfElements) void * _Base,
        _In_ size_t _NumOfElements, _In_ size_t _SizeOfElements,
        _In_ int (__clrcall * _PtFuncCompare)(const void *, const void *));

}
#endif  /* _MSC_VER >= 1400 && defined(__cplusplus) && defined(_M_CEE) */

#ifndef _CRT_ALLOCATION_DEFINED
#define _CRT_ALLOCATION_DEFINED

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)

#pragma push_macro("calloc")
#pragma push_macro("free")
#pragma push_macro("malloc")
#pragma push_macro("realloc")
#pragma push_macro("_recalloc")
#pragma push_macro("_aligned_free")
#pragma push_macro("_aligned_malloc")
#pragma push_macro("_aligned_offset_malloc")
#pragma push_macro("_aligned_realloc")
#pragma push_macro("_aligned_recalloc")
#pragma push_macro("_aligned_offset_realloc")
#pragma push_macro("_aligned_offset_recalloc")
#pragma push_macro("_aligned_msize")

#undef calloc
#undef free
#undef malloc
#undef realloc
#undef _recalloc
#undef _aligned_free
#undef _aligned_malloc
#undef _aligned_offset_malloc
#undef _aligned_realloc
#undef _aligned_recalloc
#undef _aligned_offset_realloc
#undef _aligned_offset_recalloc
#undef _aligned_msize

#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */
_Check_return_ _Ret_opt_bytecap_x_(_NumOfElements* _SizeOfElements) _CRTIMP _CRT_JIT_INTRINSIC _CRTNOALIAS _CRTRESTRICT    void * __cdecl calloc(_In_ size_t _NumOfElements, _In_ size_t _SizeOfElements);
_CRTIMP                     _CRTNOALIAS                                                                             void   __cdecl free(_Inout_opt_ void * _Memory);
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP _CRT_JIT_INTRINSIC _CRTNOALIAS _CRTRESTRICT                              void * __cdecl malloc(_In_ size_t _Size);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP _CRTNOALIAS _CRTRESTRICT                           void * __cdecl realloc(_In_opt_ void * _Memory, _In_ size_t _NewSize);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                       void * __cdecl _recalloc(_In_opt_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size);
_CRTIMP                     _CRTNOALIAS                                                                             void   __cdecl _aligned_free(_Inout_opt_ void * _Memory);
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_malloc(_In_ size_t _Size, _In_ size_t _Alignment);
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_offset_malloc(_In_ size_t _Size, _In_ size_t _Alignment, _In_ size_t _Offset);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_realloc(_In_opt_ void * _Memory, _In_ size_t _NewSize, _In_ size_t _Alignment);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                       void * __cdecl _aligned_recalloc(_In_opt_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size, _In_ size_t _Alignment);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP _CRTNOALIAS _CRTRESTRICT                              void * __cdecl _aligned_offset_realloc(_In_opt_ void * _Memory, _In_ size_t _NewSize, _In_ size_t _Alignment, _In_ size_t _Offset);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP _CRTNOALIAS _CRTRESTRICT                       void * __cdecl _aligned_offset_recalloc(_In_opt_ void * _Memory, _In_ size_t _Count, _In_ size_t _Size, _In_ size_t _Alignment, _In_ size_t _Offset);
_Check_return_ _CRTIMP                                                  size_t __cdecl _aligned_msize(_In_ void * _Memory, _In_ size_t _Alignment, _In_ size_t _Offset);


#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)

#pragma pop_macro("_aligned_msize")
#pragma pop_macro("_aligned_offset_recalloc")
#pragma pop_macro("_aligned_offset_realloc")
#pragma pop_macro("_aligned_recalloc")
#pragma pop_macro("_aligned_realloc")
#pragma pop_macro("_aligned_offset_malloc")
#pragma pop_macro("_aligned_malloc")
#pragma pop_macro("_aligned_free")
#pragma pop_macro("_recalloc")
#pragma pop_macro("realloc")
#pragma pop_macro("malloc")
#pragma pop_macro("free")
#pragma pop_macro("calloc")

#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

#endif  /* _CRT_ALLOCATION_DEFINED */

#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_Check_return_wat_ _CRTIMP errno_t __cdecl _itow_s (_In_ int _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itow_s, _In_ int, _Value, wchar_t, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _itow, _In_ int, _Value, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_ int, _Radix)
_Check_return_wat_ _CRTIMP errno_t __cdecl _ltow_s (_In_ long _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ltow_s, _In_ long, _Value, wchar_t, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _ltow, _In_ long, _Value, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_ int, _Radix)
_Check_return_wat_ _CRTIMP errno_t __cdecl _ultow_s (_In_ unsigned long _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ultow_s, _In_ unsigned long, _Value, wchar_t, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _ultow, _In_ unsigned long, _Value, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_ int, _Radix)
_Check_return_ _CRTIMP double __cdecl wcstod(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr);
_Check_return_ _CRTIMP double __cdecl _wcstod_l(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP long   __cdecl wcstol(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, int _Radix);
_Check_return_ _CRTIMP long   __cdecl _wcstol_l(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t **_EndPtr, int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned long __cdecl wcstoul(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, int _Radix);
_Check_return_ _CRTIMP unsigned long __cdecl _wcstoul_l(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t **_EndPtr, int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_wdupenv_s) wchar_t * __cdecl _wgetenv(_In_z_ const wchar_t * _VarName);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wgetenv_s(_Out_ size_t * _ReturnSize, _Out_z_cap_(_DstSizeInWords) wchar_t * _DstBuf, _In_ size_t _DstSizeInWords, _In_z_ const wchar_t * _VarName);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _wgetenv_s, _Out_ size_t *, _ReturnSize, wchar_t, _Dest, _In_z_ const wchar_t *, _VarName)

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wdupenv_s")
#undef _wdupenv_s
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_wat_ _CRTIMP errno_t __cdecl _wdupenv_s(_Out_ _Deref_post_opt_z_cap_(*_BufferSizeInWords) wchar_t **_Buffer, _Out_opt_ size_t *_BufferSizeInWords, _In_z_ const wchar_t *_VarName);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wdupenv_s")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

#ifndef _CRT_WSYSTEM_DEFINED
#define _CRT_WSYSTEM_DEFINED
_CRTIMP int __cdecl _wsystem(_In_opt_z_ const wchar_t * _Command);
#endif  /* _CRT_WSYSTEM_DEFINED */
_Check_return_ _CRTIMP double __cdecl _wtof(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP double __cdecl _wtof_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wtoi(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP int __cdecl _wtoi_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP long __cdecl _wtol(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP long __cdecl _wtol_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);

_Check_return_wat_ _CRTIMP errno_t __cdecl _i64tow_s(_In_ __int64 _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
_CRTIMP _CRT_INSECURE_DEPRECATE(_i64tow_s) wchar_t * __cdecl _i64tow(_In_ __int64 _Val, _Pre_notnull_ _Post_z_ wchar_t * _DstBuf, _In_ int _Radix);
_Check_return_wat_ _CRTIMP errno_t __cdecl _ui64tow_s(_In_ unsigned __int64 _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
_CRTIMP _CRT_INSECURE_DEPRECATE(_ui64tow_s) wchar_t * __cdecl _ui64tow(_In_ unsigned __int64 _Val, _Pre_notnull_ _Post_z_ wchar_t * _DstBuf, _In_ int _Radix);
_Check_return_ _CRTIMP __int64   __cdecl _wtoi64(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP __int64   __cdecl _wtoi64_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP __int64   __cdecl _wcstoi64(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP __int64   __cdecl _wcstoi64_l(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned __int64  __cdecl _wcstoui64(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP unsigned __int64  __cdecl _wcstoui64_l(_In_z_ const wchar_t *_Str , _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);

#define _WSTDLIB_DEFINED
#endif  /* _WSTDLIB_DEFINED */



/*
Buffer size required to be passed to _gcvt, fcvt and other fp conversion routines
*/
#define _CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)

#pragma push_macro("_fullpath")
#undef _fullpath

#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP char * __cdecl _fullpath(_Out_opt_z_cap_(_SizeInBytes) char * _FullPath, _In_z_ const char * _Path, _In_ size_t _SizeInBytes);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)

#pragma pop_macro("_fullpath")

#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_wat_ _CRTIMP errno_t __cdecl _ecvt_s(_Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ double _Val, _In_ int _NumOfDights, _Out_ int * _PtDec, _Out_ int * _PtSign);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _ecvt_s, char, _Dest, _In_ double, _Value, _In_ int, _NumOfDigits, _Out_ int *, _PtDec, _Out_ int *, _PtSign)
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_ecvt_s) char * __cdecl _ecvt(_In_ double _Val, _In_ int _NumOfDigits, _Out_ int * _PtDec, _Out_ int * _PtSign);
_Check_return_wat_ _CRTIMP errno_t __cdecl _fcvt_s(_Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ double _Val, _In_ int _NumOfDec, _Out_ int * _PtDec, _Out_ int * _PtSign);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _fcvt_s, char, _Dest, _In_ double, _Value, _In_ int, _NumOfDigits, _Out_ int *, _PtDec, _Out_ int *, _PtSign)
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_fcvt_s) char * __cdecl _fcvt(_In_ double _Val, _In_ int _NumOfDec, _Out_ int * _PtDec, _Out_ int * _PtSign);
_CRTIMP errno_t __cdecl _gcvt_s(_Out_z_cap_(_Size) char * _DstBuf, _In_ size_t _Size, _In_ double _Val, _In_ int _NumOfDigits);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _gcvt_s, char, _Dest, _In_ double, _Value, _In_ int, _NumOfDigits)
_CRTIMP _CRT_INSECURE_DEPRECATE(_gcvt_s) char * __cdecl _gcvt(_In_ double _Val, _In_ int _NumOfDigits, _Pre_notnull_ _Post_z_ char * _DstBuf);

_Check_return_ _CRTIMP int __cdecl _atodbl(_Out_ _CRT_DOUBLE * _Result, _In_z_ char * _Str);
_Check_return_ _CRTIMP int __cdecl _atoldbl(_Out_ _LDOUBLE * _Result, _In_z_ char * _Str);
_Check_return_ _CRTIMP int __cdecl _atoflt(_Out_ _CRT_FLOAT * _Result, _In_z_ char * _Str);
_Check_return_ _CRTIMP int __cdecl _atodbl_l(_Out_ _CRT_DOUBLE * _Result, _In_z_ char * _Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _atoldbl_l(_Out_ _LDOUBLE * _Result, _In_z_ char * _Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _atoflt_l(_Out_ _CRT_FLOAT * _Result, _In_z_ char * _Str, _In_opt_ _locale_t _Locale);
        _Check_return_ unsigned long __cdecl _lrotl(_In_ unsigned long _Val, _In_ int _Shift);
        _Check_return_ unsigned long __cdecl _lrotr(_In_ unsigned long _Val, _In_ int _Shift);
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t   __cdecl _makepath_s(_Out_z_cap_(_SizeInWords) char * _PathResult, _In_ size_t _SizeInWords, _In_opt_z_ const char * _Drive, _In_opt_z_ const char * _Dir, _In_opt_z_ const char * _Filename,
        _In_opt_z_ const char * _Ext);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _makepath_s, char, _Path, _In_opt_z_ const char *, _Drive, _In_opt_z_ const char *, _Dir, _In_opt_z_ const char *, _Filename, _In_opt_z_ const char *, _Ext)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(void, __RETURN_POLICY_VOID, _CRTIMP, _makepath, _Pre_notnull_ _Post_z_, char, _Path, _In_opt_z_ const char *, _Drive, _In_opt_z_ const char *, _Dir, _In_opt_z_ const char *, _Filename, _In_opt_z_ const char *, _Ext)

#if _MSC_VER >= 1400 && defined(_M_CEE)
                _onexit_m_t    __clrcall _onexit_m_appdomain(_onexit_m_t _Function);
#if defined (_M_CEE_MIXED)
                _onexit_m_t    __clrcall _onexit_m(_onexit_m_t _Function);
#else  /* defined (_M_CEE_MIXED) */
                inline _onexit_m_t    __clrcall _onexit_m(_onexit_t _Function)
                {
                        return _onexit_m_appdomain(_Function);
                }
#endif  /* defined (_M_CEE_MIXED) */

#endif  /* _MSC_VER >= 1400 && defined(_M_CEE) */
#if defined (_M_CEE_PURE)
        /* In pure mode, _onexit is the same as _onexit_m_appdomain */
extern "C++"
{
inline  _onexit_t    __clrcall _onexit
(
    _onexit_t _Function
)
{
    return _onexit_m_appdomain(_Function);
}
}
#else  /* defined (_M_CEE_PURE) */
        _onexit_t __cdecl _onexit(_In_opt_ _onexit_t _Func);
#endif  /* defined (_M_CEE_PURE) */

#ifndef _CRT_PERROR_DEFINED
#define _CRT_PERROR_DEFINED
_CRTIMP void __cdecl perror(_In_opt_z_ const char * _ErrMsg);
#endif  /* _CRT_PERROR_DEFINED */

#pragma warning (push)
#pragma warning (disable:6540) // the functions below have declspecs in their declarations in the windows headers, causing PREfast to fire 6540 here
_Check_return_ _CRTIMP int    __cdecl _putenv(_In_z_ const char * _EnvString);
_Check_return_wat_ _CRTIMP errno_t __cdecl _putenv_s(_In_z_ const char * _Name, _In_z_ const char * _Value);
        _Check_return_ unsigned int __cdecl _rotl(_In_ unsigned int _Val, _In_ int _Shift);
        _Check_return_ unsigned __int64 __cdecl _rotl64(_In_ unsigned __int64 _Val, _In_ int _Shift);
        _Check_return_ unsigned int __cdecl _rotr(_In_ unsigned int _Val, _In_ int _Shift);
        _Check_return_ unsigned __int64 __cdecl _rotr64(_In_ unsigned __int64 _Val, _In_ int _Shift);
#pragma warning (pop)

_CRTIMP errno_t __cdecl _searchenv_s(_In_z_ const char * _Filename, _In_z_ const char * _EnvVar, _Out_z_cap_(_SizeInBytes) char * _ResultPath, _In_ size_t _SizeInBytes);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(errno_t, _searchenv_s, _In_z_ const char *, _Filename, _In_z_ const char *, _EnvVar, char, _ResultPath)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(void, __RETURN_POLICY_VOID, _CRTIMP, _searchenv, _In_z_ const char *, _Filename, _In_z_ const char *, _EnvVar, _Pre_notnull_ _Post_z_, char, _ResultPath)

_CRT_INSECURE_DEPRECATE(_splitpath_s) _CRTIMP void   __cdecl _splitpath(_In_z_ const char * _FullPath, _Pre_maybenull_ _Post_z_ char * _Drive, _Pre_maybenull_ _Post_z_ char * _Dir, _Pre_maybenull_ _Post_z_ char * _Filename, _Pre_maybenull_ _Post_z_ char * _Ext);
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t  __cdecl _splitpath_s(_In_z_ const char * _FullPath,
                _Out_opt_z_cap_(_DriveSize) char * _Drive, _In_ size_t _DriveSize,
                _Out_opt_z_cap_(_DirSize) char * _Dir, _In_ size_t _DirSize,
                _Out_opt_z_cap_(_FilenameSize) char * _Filename, _In_ size_t _FilenameSize,
                _Out_opt_z_cap_(_ExtSize) char * _Ext, _In_ size_t _ExtSize);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(errno_t, _splitpath_s,  char, _Dest)

_CRTIMP void   __cdecl _swab(_Inout_cap_(_SizeInBytes) _Post_count_(_SizeInBytes) char * _Buf1, _Inout_cap_(_SizeInBytes) _Post_count_(_SizeInBytes) char * _Buf2, int _SizeInBytes);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wfullpath")
#undef _wfullpath
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP wchar_t * __cdecl _wfullpath(_Out_opt_z_cap_(_SizeInWords) wchar_t * _FullPath, _In_z_ const wchar_t * _Path, _In_ size_t _SizeInWords);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wfullpath")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _wmakepath_s(_Out_z_cap_(_SIZE) wchar_t * _PathResult, _In_ size_t _SIZE, _In_opt_z_ const wchar_t * _Drive, _In_opt_z_ const wchar_t * _Dir, _In_opt_z_ const wchar_t * _Filename,
        _In_opt_z_ const wchar_t * _Ext);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _wmakepath_s, wchar_t, _ResultPath, _In_opt_z_ const wchar_t *, _Drive, _In_opt_z_ const wchar_t *, _Dir, _In_opt_z_ const wchar_t *, _Filename, _In_opt_z_ const wchar_t *, _Ext)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(void, __RETURN_POLICY_VOID, _CRTIMP, _wmakepath, _Pre_notnull_ _Post_z_, wchar_t, _ResultPath, _In_opt_z_ const wchar_t *, _Drive, _In_opt_z_ const wchar_t *, _Dir, _In_opt_z_ const wchar_t *, _Filename, _In_opt_z_ const wchar_t *, _Ext)
#ifndef _CRT_WPERROR_DEFINED
#define _CRT_WPERROR_DEFINED
_CRTIMP void __cdecl _wperror(_In_opt_z_ const wchar_t * _ErrMsg);
#endif  /* _CRT_WPERROR_DEFINED */
_Check_return_ _CRTIMP int    __cdecl _wputenv(_In_z_ const wchar_t * _EnvString);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wputenv_s(_In_z_ const wchar_t * _Name, _In_z_ const wchar_t * _Value);
_CRTIMP errno_t __cdecl _wsearchenv_s(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _EnvVar, _Out_z_cap_(_SizeInWords) wchar_t * _ResultPath, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(errno_t, _wsearchenv_s, _In_z_ const wchar_t *, _Filename, _In_z_ const wchar_t *, _EnvVar, wchar_t, _ResultPath)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(void, __RETURN_POLICY_VOID, _CRTIMP, _wsearchenv, _In_z_ const wchar_t *, _Filename, _In_z_ const wchar_t *, _EnvVar, _Pre_notnull_ _Post_z_, wchar_t, _ResultPath)
_CRT_INSECURE_DEPRECATE(_wsplitpath_s) _CRTIMP void   __cdecl _wsplitpath(_In_z_ const wchar_t * _FullPath, _Pre_maybenull_ _Post_z_ wchar_t * _Drive, _Pre_maybenull_ _Post_z_ wchar_t * _Dir, _Pre_maybenull_ _Post_z_ wchar_t * _Filename, _Pre_maybenull_ _Post_z_ wchar_t * _Ext);
_CRTIMP_ALTERNATIVE errno_t __cdecl _wsplitpath_s(_In_z_ const wchar_t * _FullPath,
                _Out_opt_z_cap_(_DriveSize) wchar_t * _Drive, _In_ size_t _DriveSize,
                _Out_opt_z_cap_(_DirSize) wchar_t * _Dir, _In_ size_t _DirSize,
                _Out_opt_z_cap_(_FilenameSize) wchar_t * _Filename, _In_ size_t _FilenameSize,
                _Out_opt_z_cap_(_ExtSize) wchar_t * _Ext, _In_ size_t _ExtSize);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(errno_t, _wsplitpath_s, wchar_t, _Path)

#define _WSTDLIBP_DEFINED
#endif  /* _WSTDLIBP_DEFINED */

/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRT_OBSOLETE(SetErrorMode) _CRTIMP void __cdecl _seterrormode(_In_ int _Mode);
_CRT_OBSOLETE(Beep) _CRTIMP void __cdecl _beep(_In_ unsigned _Frequency, _In_ unsigned _Duration);
_CRT_OBSOLETE(Sleep) _CRTIMP void __cdecl _sleep(_In_ unsigned long _Duration);


#if !__STDC__


/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif  /* __cplusplus */

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

#pragma warning(push)
#pragma warning(disable: 4141) /* Using deprecated twice */
_Check_return_ _CRT_NONSTDC_DEPRECATE(_ecvt) _CRT_INSECURE_DEPRECATE(_ecvt_s) _CRTIMP char * __cdecl ecvt(_In_ double _Val, _In_ int _NumOfDigits, _Out_ int * _PtDec, _Out_ int * _PtSign);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_fcvt) _CRT_INSECURE_DEPRECATE(_fcvt_s) _CRTIMP char * __cdecl fcvt(_In_ double _Val, _In_ int _NumOfDec, _Out_ int * _PtDec, _Out_ int * _PtSign);
_CRT_NONSTDC_DEPRECATE(_gcvt) _CRT_INSECURE_DEPRECATE(_fcvt_s)          _CRTIMP char * __cdecl gcvt(_In_ double _Val, _In_ int _NumOfDigits, _Pre_notnull_ _Post_z_ char * _DstBuf);
_CRT_NONSTDC_DEPRECATE(_itoa) _CRT_INSECURE_DEPRECATE(_itoa_s)          _CRTIMP char * __cdecl itoa(_In_ int _Val, _Pre_notnull_ _Post_z_ char * _DstBuf, _In_ int _Radix);
_CRT_NONSTDC_DEPRECATE(_ltoa) _CRT_INSECURE_DEPRECATE(_ltoa_s)          _CRTIMP char * __cdecl ltoa(_In_ long _Val, _Pre_notnull_ _Post_z_ char * _DstBuf, _In_ int _Radix);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_putenv) _CRTIMP int    __cdecl putenv(_In_z_ const char * _EnvString);
_CRT_NONSTDC_DEPRECATE(_swab)                                                                           _CRTIMP void   __cdecl swab(_Inout_z_bytecap_(_SizeInBytes) char * _Buf1,_Inout_z_bytecap_(_SizeInBytes) char * _Buf2, _In_ int _SizeInBytes);
_CRT_NONSTDC_DEPRECATE(_ultoa) _CRT_INSECURE_DEPRECATE(_ultoa_s)        _CRTIMP char * __cdecl ultoa(_In_ unsigned long _Val, _Pre_notnull_ _Post_z_ char * _Dstbuf, _In_ int _Radix);
#pragma warning(pop)
onexit_t __cdecl onexit(_In_opt_ onexit_t _Func);


#endif  /* !__STDC__ */

#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strerror.c ===
/***
*strerror.c - Contains the strerror C runtime.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The strerror runtime accepts an error number as input
*       and returns the corresponding error string.
*
*       NOTE: The "old" strerror C runtime resides in file _strerr.c
*       and is now called _strerror.  The new strerror runtime
*       conforms to the ANSI standard.
*
*******************************************************************************/

#include <cruntime.h>
#include <errmsg.h>
#include <stdlib.h>
#include <syserr.h>
#include <string.h>
#include <mtdll.h>
#include <tchar.h>
#include <malloc.h>
#include <stddef.h>
#include <dbgint.h>
#include <internal.h>

/* [NOTE: The _MT error message buffer is shared by both strerror
   and _strerror so must be the max length of both. */
/* Max length of message = user_string(94)+system_string+2 */
#define _ERRMSGLEN_ (94+_SYS_MSGMAX+2)

#ifdef _UNICODE
#define _terrmsg    _werrmsg
#else  /* _UNICODE */
#define _terrmsg    _errmsg
#endif  /* _UNICODE */

/***
*char *strerror(errnum) - Map error number to error message string.
*
*Purpose:
*       The strerror runtime takes an error number for input and
*       returns the corresponding error message string.  This routine
*       conforms to the ANSI standard interface.
*
*Entry:
*       int errnum - Integer error number (corresponding to an errno value).
*
*Exit:
*       char * - Strerror returns a pointer to the error message string.
*       This string is internal to the strerror routine (i.e., not supplied
*       by the user).
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * cdecl _wcserror(
#else  /* _UNICODE */
char * __cdecl strerror (
#endif  /* _UNICODE */
        int errnum
        )
{

        _TCHAR *errmsg;
        _ptiddata ptd = _getptd_noexit();
        if (!ptd)
                return _T("Visual C++ CRT: Not enough memory to complete call to strerror.");



        if ( (ptd->_terrmsg == NULL) && ((ptd->_terrmsg =
                        _calloc_crt(_ERRMSGLEN_, sizeof(_TCHAR)))
                        == NULL) )
                return _T("Visual C++ CRT: Not enough memory to complete call to strerror.");
        else
                errmsg = ptd->_terrmsg;


#ifdef _UNICODE
        _ERRCHECK(mbstowcs_s(NULL, errmsg, _ERRMSGLEN_, _get_sys_err_msg(errnum), _ERRMSGLEN_ - 1));
#else  /* _UNICODE */
        _ERRCHECK(strcpy_s(errmsg, _ERRMSGLEN_, _get_sys_err_msg(errnum)));
#endif  /* _UNICODE */

        return(errmsg);
}

/***
*errno_t strerror_s(buffer, sizeInTChars, errnum) - Map error number to error message string.
*
*Purpose:
*       The strerror_s runtime takes an error number for input and
*       copies the corresponding error message string in the destination
*       buffer. If the buffer is too small, the message is truncated.
*
*Entry:
*       TCHAR * buffer - Destination buffer.
*       size_t sizeInTChars - Size of the destination buffer.
*       int errnum - Integer error number (corresponding to an errno value).
*
*Exit:
*       The error code.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef _UNICODE
errno_t __cdecl _wcserror_s(
#else  /* _UNICODE */
errno_t __cdecl strerror_s(
#endif  /* _UNICODE */
        TCHAR* buffer,
        size_t sizeInTChars,
        int errnum
        )
{
        errno_t e = 0;

        /* validation section */
        _VALIDATE_RETURN_ERRCODE(buffer != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInTChars > 0, EINVAL);

        /* we use mbstowcs_s or strncpy_s because we want to truncate the error string
         * if the destination is not big enough
         */
#ifdef _UNICODE
        e = _ERRCHECK_EINVAL_ERANGE(mbstowcs_s(NULL, buffer, sizeInTChars, _get_sys_err_msg(errnum), _TRUNCATE));
        /* ignore the truncate information */
        if (e == STRUNCATE)
        {
                e = 0;
        }
#else  /* _UNICODE */
        _ERRCHECK(strncpy_s(buffer, sizeInTChars, _get_sys_err_msg(errnum), sizeInTChars - 1));
#endif  /* _UNICODE */
    return e;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stricmp.c ===
/***
*stricmp.c - contains case-insensitive string comp routine _stricmp/_strcmpi
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _stricmp(), also known as _strcmpi()
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <locale.h>
#include <ctype.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>


/***
*int _strcmpi(dst, src), _strcmpi(dst, src) - compare strings, ignore case
*
*Purpose:
*       _stricmp/_strcmpi perform a case-insensitive string comparision.
*       For differences, upper case letters are mapped to lower case.
*       Thus, "abc_" < "ABCD" since "_" < "d".
*
*Entry:
*       char *dst, *src - strings to compare
*
*Return:
*       Returns <0 if dst < src
*       Returns 0 if dst = src
*       Returns >0 if dst > src
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _stricmp_l (
        const char * dst,
        const char * src,
        _locale_t plocinfo
        )
{
    int f,l;
    _LocaleUpdate _loc_update(plocinfo);

    /* validation section */
    _VALIDATE_RETURN(dst != NULL, EINVAL, _NLSCMPERROR);
    _VALIDATE_RETURN(src != NULL, EINVAL, _NLSCMPERROR);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
    {
        return __ascii_stricmp(dst, src);
    }
    else
    {
        do
        {
            f = _tolower_l( (unsigned char)(*(dst++)), _loc_update.GetLocaleT() );
            l = _tolower_l( (unsigned char)(*(src++)), _loc_update.GetLocaleT() );
        } while ( f && (f == l) );
    }

    return(f - l);
}

extern "C" int __cdecl __ascii_stricmp (
        const char * dst,
        const char * src
        )
{
    int f, l;

    do
    {
        if ( ((f = (unsigned char)(*(dst++))) >= 'A') && (f <= 'Z') )
            f -= 'A' - 'a';
        if ( ((l = (unsigned char)(*(src++))) >= 'A') && (l <= 'Z') )
            l -= 'A' - 'a';
    }
    while ( f && (f == l) );

    return(f - l);
}

extern "C" int __cdecl _stricmp (
        const char * dst,
        const char * src
        )
{
    if (__locale_changed == 0)
    {
        /* validation section */
        _VALIDATE_RETURN(dst != NULL, EINVAL, _NLSCMPERROR);
        _VALIDATE_RETURN(src != NULL, EINVAL, _NLSCMPERROR);

        return __ascii_stricmp(dst, src);
    }
    else
    {
        return _stricmp_l(dst, src, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\string.cpp ===
// string -- template string support functions
#include <istream>
_STD_BEGIN

// We are not using these functions from the mixed msvcm80.dll, because we cannot throw from /clr modules
// and catch from /clr:pure modules. These functions should never be called from msvcm80.dll, so we use _THROW_NCEE,
// which call _invoke_watsonsignaling an internal error in our libraries.
// The functions are actually implemented inline (see xstring and stdexcept).
// See VSW#476338 for details.

_MRTIMP2 void __cdecl _String_base::_Xlen()
	{	// report a length_error
	_THROW_NCEE(length_error, "string too long");
	}

_MRTIMP2 void __cdecl _String_base::_Xran()
	{	// report an out_of_range error
	_THROW_NCEE(out_of_range, "invalid string position");
	}

_MRTIMP2 void __cdecl _String_base::_Xinvarg()
	{	// report an out_of_range error
	_THROW_NCEE(invalid_argument, "invalid string argument");
	}

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\stricoll.c ===
/***
*stricoll.c - Collate locale strings without regard to case
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <errno.h>
#include <awint.h>
#include <string.h>
#include <internal.h>
#include <windows.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int _stricoll() - Collate locale strings without regard to case
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information
*       without regard to case.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _stricoll_l (
        const char *_string1,
        const char *_string2,
        _locale_t plocinfo
        )
{
    int ret;
    _LocaleUpdate _loc_update(plocinfo);

    /* validation section */
    _VALIDATE_RETURN(_string1 != NULL, EINVAL, _NLSCMPERROR);
    _VALIDATE_RETURN(_string2 != NULL, EINVAL, _NLSCMPERROR);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
    {
        return _stricmp(_string1, _string2);
    }

    if ( 0 == (ret = __crtCompareStringA(_loc_update.GetLocaleT(),
                    _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE],
                    SORT_STRINGSORT | NORM_IGNORECASE,
                    _string1,
                    -1,
                    _string2,
                    -1,
                    _loc_update.GetLocaleT()->locinfo->lc_collate_cp)) )
    {
        errno = EINVAL;
        return _NLSCMPERROR;
    }

    return (ret - 2);

}

extern "C" int __cdecl _stricoll (
        const char *_string1,
        const char *_string2
        )
{
    if (__locale_changed == 0)
    {
        return _stricmp(_string1, _string2);
    }
    else
    {
        return _stricoll_l(_string1, _string2, NULL);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strlen.c ===
/***
*strlen.c - contains strlen() routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       strlen returns the length of a null-terminated string,
*       not including the null byte itself.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef _MSC_VER
#pragma function(strlen)
#endif  /* _MSC_VER */

/***
*strlen - return the length of a null-terminated string
*
*Purpose:
*       Finds the length in bytes of the given string, not including
*       the final null character.
*
*Entry:
*       const char * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null byte
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strlen (
        const char * str
        )
{
        const char *eos = str;

        while( *eos++ ) ;

        return( eos - str - 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strlwr.c ===
/***
*strlwr.c - routine to map upper-case characters in a string to lower-case
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the upper case characters in a string to lower case,
*       in place.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <limits.h>     /* for INT_MAX */
#include <awint.h>
#include <dbgint.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*char *_strlwr(string) - map upper-case characters in a string to lower-case
*
*Purpose:
*       _strlwr() converts upper-case characters in a null-terminated string
*       to their lower-case equivalents.  Conversion is done in place and
*       characters other than upper-case letters are not modified.
*
*       In the C locale, this function modifies only 7-bit ASCII characters
*       in the range 0x41 through 0x5A ('A' through 'Z').
*
*       If the locale is not the 'C' locale, LCMapString() is used to do
*       the work.  Assumes enough space in the string to hold result.
*
*Entry:
*       char *string - string to change to lower case
*
*Exit:
*       input string address
*
*Exceptions:
*       The original string is returned unchanged on any error, and errno is set.
*
*******************************************************************************/

extern "C" char * __cdecl _strlwr_l (
        char * string,
        _locale_t plocinfo
        )
{
    _strlwr_s_l(string, (size_t)(-1), plocinfo);
    return string;
}

extern "C" char * __cdecl _strlwr (
        char * string
        )
{
    if (__locale_changed == 0)
    {
        char * cp;

        /* validation section */
        _VALIDATE_RETURN(string != NULL, EINVAL, NULL);

        for (cp=string; *cp; ++cp)
        {
            if ('A' <= *cp && *cp <= 'Z')
                *cp += 'a' - 'A';
        }

        return(string);
    }
    else
    {
        _strlwr_s_l(string, (size_t)(-1), NULL);
        return string;
    }
}

/***
*errno_t _strlwr_s(string, size_t) - map upper-case characters in a string to lower-case
*
*Purpose:
*       _strlwr_s() converts upper-case characters in a null-terminated string
*       to their lower-case equivalents.  Conversion is done in place and
*       characters other than upper-case letters are not modified.
*
*       In the C locale, this function modifies only 7-bit ASCII characters
*       in the range 0x41 through 0x5A ('A' through 'Z').
*
*       If the locale is not the 'C' locale, LCMapString() is used to do
*       the work.  Assumes enough space in the string to hold result.
*
*Entry:
*       char *string - string to change to lower case
*       size_t sizeInBytes - size of the destination buffer
*
*Exit:
*       the error code
*
*Exceptions:
*       The original string is returned unchanged on any error, and errno is set.
*
*******************************************************************************/

errno_t __cdecl _strlwr_s_l_stat (
        char * string,
        size_t sizeInBytes,
        _locale_t plocinfo
        )
{

    int dstsize;                /* size of dst string buffer (include null)  */
    unsigned char *dst;         /* destination string */
    errno_t e = 0;
    size_t stringlen;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(string != NULL, EINVAL);
    stringlen = strnlen(string, sizeInBytes);
    if (stringlen >= sizeInBytes)
    {
        _RESET_STRING(string, sizeInBytes);
        _RETURN_DEST_NOT_NULL_TERMINATED(string, sizeInBytes);
    }
    _FILL_STRING(string, sizeInBytes, stringlen + 1);

    if ( plocinfo->locinfo->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
        char *cp;       /* traverses string for C locale conversion */

        for ( cp = string ; *cp ; ++cp )
            if ( ('A' <= *cp) && (*cp <= 'Z') )
                *cp -= 'A' - 'a';

        return 0;
    }   /* C locale */

    /* Inquire size of dst string */
    if ( 0 == (dstsize = __crtLCMapStringA(
                    plocinfo,
                    plocinfo->locinfo->lc_handle[LC_CTYPE],
                    LCMAP_LOWERCASE,
                    string,
                    -1,
                    NULL,
                    0,
                    plocinfo->locinfo->lc_codepage,
                    TRUE )) )
    {
        errno = EILSEQ;
        return errno;
    }

    if (sizeInBytes < (size_t)dstsize)
    {
        _RESET_STRING(string, sizeInBytes);
        _RETURN_BUFFER_TOO_SMALL(string, sizeInBytes);
    }

    /* Allocate space for dst */
    dst = (unsigned char *)_calloca(dstsize, sizeof(unsigned char));
    if (dst == NULL)
    {
        errno = ENOMEM;
        return errno;
    }

    /* Map src string to dst string in alternate case */
    if (__crtLCMapStringA(
                plocinfo,
                plocinfo->locinfo->lc_handle[LC_CTYPE],
                LCMAP_LOWERCASE,
                string,
                -1,
                (LPSTR)dst,
                dstsize,
                plocinfo->locinfo->lc_codepage,
                TRUE ) != 0)
    {
        /* copy dst string to return string */
        e = strcpy_s(string, sizeInBytes, (const char *)dst);
    }
    else
    {
        e = errno = EILSEQ;
    }

    _freea(dst);

    return e;
}

extern "C" errno_t __cdecl _strlwr_s_l (
        char * string,
        size_t sizeInBytes,
        _locale_t plocinfo
        )
{

    _LocaleUpdate _loc_update(plocinfo);

    return _strlwr_s_l_stat(string, sizeInBytes, _loc_update.GetLocaleT());
}

extern "C" errno_t __cdecl _strlwr_s(
        char * string,
        size_t sizeInBytes
        )
{
    return _strlwr_s_l(string, sizeInBytes, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strcoll.c ===
/***
*strcoll.c - Collate locale strings
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <errno.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*int strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*       Returns _NLSCMPERROR is something went wrong
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" int __cdecl _strcoll_l (
        const char *_string1,
        const char *_string2,
        _locale_t plocinfo
        )
{
    int ret;
    _LocaleUpdate _loc_update(plocinfo);

    /* validation section */
    _VALIDATE_RETURN(_string1 != NULL, EINVAL, _NLSCMPERROR);
    _VALIDATE_RETURN(_string2 != NULL, EINVAL, _NLSCMPERROR);

    if ( _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
            return strcmp(_string1, _string2);

    if ( 0 == (ret = __crtCompareStringA(
                    _loc_update.GetLocaleT(), _loc_update.GetLocaleT()->locinfo->lc_handle[LC_COLLATE],
                               SORT_STRINGSORT,
                               _string1,
                               -1,
                               _string2,
                               -1,
                    _loc_update.GetLocaleT()->locinfo->lc_collate_cp )) )
    {
        errno = EINVAL;
        return _NLSCMPERROR;
    }

    return (ret - 2);

}

extern "C" int __cdecl strcoll (
        const char *_string1,
        const char *_string2
        )
{
    return _strcoll_l(_string1, _string2, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strcspn.c ===
/***
*strcspn.c - Defines the strcspn function.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The function strcspn is mostly common code with strspn in strspn.c.
*
*******************************************************************************/

#define SSTRCSPN
#include "strspn.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\strncat.c ===
/***
*strncat.c - append n chars of string to new string
*
*       Copyright (c) Microsoft Corporation. All rights