    }

    if (m_scale.x != 1.0f || m_scale.y != 1.0f || m_scale.z != 1.0f)
    {
        D3DXMATRIX mat;
        D3DXMatrixScaling(&mat, m_scale.x, m_scale.y, m_scale.z);
        D3DXMatrixMultiply(&m_matrix, &m_matrix, &mat);
    }

    if (m_rotationQuat.w != 0.0f)
    {
        D3DXMATRIX mat;
//      D3DXMatrixRotationAxis(&mat, (D3DXVECTOR3*)&m_rotation, m_rotation.w);
        D3DXMatrixRotationQuaternion(&mat, &m_rotationQuat);
        D3DXMatrixMultiply(&m_matrix, &m_matrix, &mat);
    }

    if (m_translation.x != 0.0f || m_translation.y != 0.0f || m_translation.z != 0.0f)
    {
        D3DXMATRIX mat;
        D3DXMatrixTranslation(&mat, m_translation.x, m_translation.y, m_translation.z);
        D3DXMatrixMultiply(&m_matrix, &m_matrix, &mat);
    }

    m_bDirty = (m_timeScaleStart + m_timeTranslationStart + m_timeRotationStart) > 0.0f;
}

void CTransform::SetScale(float sx, float sy, float sz)
{
    if (m_fade > 0.0f)
    {
        m_timeScaleStart = XAppGetNow();

        m_scaleStart = m_scale;

        m_scaleEnd.x = sx;
        m_scaleEnd.y = sy;
        m_scaleEnd.z = sz;

        m_moving = true;
    }
    else
    {
        m_scale.x = sx;
        m_scale.y = sy;
        m_scale.z = sz;
    }

    m_bDirty = true;
}

void CTransform::SetScaleOrientation(float x, float y, float z, float a)
{
    // TODO: Animation

    m_scaleOrientation.x = x;
    m_scaleOrientation.y = y;
    m_scaleOrientation.z = z;
    m_scaleOrientation.w = a;

    m_bDirty = true;
}

void CTransform::SetTranslation(float x, float y, float z)
{
    if (m_fade > 0.0f)
    {
        m_timeTranslationStart = XAppGetNow();

        m_translationStart = m_translation;

        m_translationEnd.x = x;
        m_translationEnd.y = y;
        m_translationEnd.z = z;

        m_moving = true;
    }
    else
    {
        m_translation.x = x;
        m_translation.y = y;
        m_translation.z = z;
    }

    m_bDirty = true;
}

void CTransform::SetCenter(float x, float y, float z)
{
    // TODO: Animation

    m_center.x = x;
    m_center.y = y;
    m_center.z = z;

    m_bDirty = true;
}

void CTransform::SetRotation(float x, float y, float z, float a)
{
    D3DXVECTOR3 v(x, y, z);
    D3DXQUATERNION q;
    D3DXQuaternionRotationAxis(&q, &v, a);

    if (m_fade > 0.0f)
    {
        m_timeRotationStart = XAppGetNow();

        m_rotationStart = m_rotationQuat;

        m_rotationEnd = q;

        m_moving = true;
    }
    else
    {
        m_rotation.x = x;
        m_rotation.y = y;
        m_rotation.z = z;
        m_rotation.w = a;

        m_rotationQuat = q;
    }

    m_bDirty = true;
}

void CTransform::SetAlpha(float a)
{
    if (m_fade > 0.0f)
    {
        m_timeAlphaStart = XAppGetNow();
        m_alphaStart = m_alpha;
        m_alphaEnd = a;
    }
    else
    {
        m_alpha = a;
    }
}

void CTransform::DisappearAfter(float t)
{
    m_timeToDisappear = XAppGetNow() + t;
}

extern float g_nEffectAlpha;

void CTransform::Render()
{
    m_moving = false;

    if (m_bDirty)
        CalcMatrix();

    XAppPushWorld();
    XAppMultWorld(&m_matrix);

    XAppUpdateWorld();

    float nEffectAlphaSave = g_nEffectAlpha;
    g_nEffectAlpha *= m_alpha;

	if(m_alpha > 0.0f)  // If object has an alpha of 0, it is not rendered
	{
		CGroup::Render();
	}

    g_nEffectAlpha = nEffectAlphaSave;

    XAppPopWorld();
}

////////////////////////////////////////////////////////////////////////////

class CInline : public CGroup
{
    DECLARE_NODE(CInline, CGroup)
public:
    CInline();
    ~CInline();

    TCHAR* m_url;
    bool m_preload;
    bool m_bClassLoaded;
    bool m_fadeInDelayLoad;

    void Render();
    void Advance(float nSeconds);

protected:
    void Init();
    void FinishLoad();
    bool m_bDirty;

    bool m_bLoading; // true when a background XIP load is in progress
    bool m_bFirstLoad;
    CXipFile* m_pXipFile;
    XTIME m_timeOfLoad;

    CClass m_class;

    DECLARE_NODE_PROPS()

private:
    HANDLE m_hClassLoaderThread;
    TCHAR m_szAbsURL[MAX_PATH];
    static void WINAPI ClassLoaderThread(CInline* p);
};

IMPLEMENT_NODE("Inline", CInline, CGroup)

START_NODE_PROPS(CInline, CGroup)
    NODE_PROP(pt_string, CInline, url)
    NODE_PROP(pt_boolean, CInline, preload)
    NODE_PROP(pt_boolean, CInline, fadeInDelayLoad)
END_NODE_PROPS()

CInline::CInline() :
    m_url(NULL),
    m_hClassLoaderThread(NULL),
    m_bClassLoaded(false),
    m_fadeInDelayLoad(true),
    m_preload(false)
{
    m_bDirty = true;
    m_bLoading = false;
    m_bFirstLoad = false;
    m_pXipFile = NULL;
    m_timeOfLoad = 0.0f;
}

CInline::~CInline()
{
    delete [] m_url;
}

void CInline::Init()
{
    ASSERT(m_bDirty);
    m_bDirty = false;
    m_children.ReleaseAll();

    if (m_url == NULL)
        return;

    ASSERT(!m_bLoading);

    // BLOCK: Start the background load if there is a XIP file...
    {
        TCHAR szURL [MAX_PATH];

        MakeAbsoluteURL(szURL, m_url);
        TCHAR* pch = _tcsrchr(szURL, '/');
        if (pch != NULL)
        {
            _tcscpy(pch, _T(".xip"));

            m_bLoading = true;
            m_bFirstLoad = true;
            m_pXipFile = LoadXIP(szURL);
            if (m_pXipFile != NULL)
                return;

            TRACE(_T("\001LoadXIP: %s failed!\n"));

            m_bLoading = false;
        }
    }

    FinishLoad();
}

void CInline::FinishLoad()
{
    TRACE(_T("FinishLoad: (0x%08x) %s\n"), this, m_url);
    ASSERT(!m_bClassLoaded);

    if (m_class.LoadAbsURL(m_szAbsURL))
    {
        CNode* pNode = m_class.CreateNode();
        CallFunction(pNode, _T("initialize"));

        m_children.AddNode(pNode);
        pNode->m_pParent = this;
        CallFunction(this, _T("onLoad"));
    }
    m_bFirstLoad = false;
    m_bClassLoaded = true;
}

void CInline::Render()
{
    if (m_url == NULL || m_bLoading)
        return;

    if (m_pXipFile != NULL && m_pXipFile->IsUnloaded())
    {
        m_bLoading = true;
        m_pXipFile->Reload();
        return;
    }

    if (m_bDirty)
        Init();

    if (m_bLoading || !m_bClassLoaded)
        return;

    float a = (float) (XAppGetNow() - m_timeOfLoad) / 2.0f;

    if (!m_fadeInDelayLoad)
    {
        a = 1.0f;
    }
    else if (a > 1.0f)
    {
        a = 1.0f;
    }

    float nEffectAlphaSave = g_nEffectAlpha;
    g_nEffectAlpha *= a;

    CDirPush dirPush(m_url);

    CGroup::Render();

    g_nEffectAlpha = nEffectAlphaSave;
}

void WINAPI CInline::ClassLoaderThread(CInline* p)
{
    ASSERT(p->m_pXipFile);
    ASSERT(p->m_bFirstLoad);
    ASSERT(!p->m_bLoading);
    ASSERT(!p->m_bClassLoaded);
    ASSERT(p->m_pXipFile->IsReady());
    p->FinishLoad();
}

void CInline::Advance(float nSeconds)
{
    if (m_bDirty && m_preload)
        Init();

    if (m_pXipFile != NULL && !m_pXipFile->IsReady())
    {
        m_bLoading = true;
        return;
    }

    if (m_bLoading)
    {
        ASSERT(m_pXipFile != NULL);
        if (!m_pXipFile->IsReady())
            return;

        m_bLoading = false;

        if (m_bFirstLoad)
        {
            ASSERT(m_hClassLoaderThread == NULL);

            MakeAbsoluteURL(m_szAbsURL, m_url);

            // BUGBUG: class loader can't be in separate thread since many of scripting engine is not multi-threaded safe
            // m_hClassLoaderThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)ClassLoaderThread, (LPVOID)this, 0, 0);

            if (!m_hClassLoaderThread)
            {
                FinishLoad();
            }
        }

        m_timeOfLoad = XAppGetNow();
    }

    if (m_hClassLoaderThread)
    {
        if (WaitForSingleObject(m_hClassLoaderThread, 0) == WAIT_OBJECT_0)
        {
            ASSERT(m_bClassLoaded);
            CloseHandle(m_hClassLoaderThread);
            m_hClassLoaderThread = NULL;
        }
    }

    //if (m_bLoading || !m_bClassLoaded)
        //return;

    CGroup::Advance(nSeconds);
}

////////////////////////////////////////////////////////////////////////////

class CSpinner : public CGroup
{
    DECLARE_NODE(CSpinner, CGroup)
public:
    CSpinner();

    float m_rpm;
    D3DXVECTOR3 m_axis;

    float m_angle;

    void Render();
    void Advance(float nSeconds);

    DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Spinner", CSpinner, CGroup)

START_NODE_PROPS(CSpinner, CGroup)
    NODE_PROP(pt_number, CSpinner, rpm)
    NODE_PROP(pt_vec3, CSpinner, axis)
    NODE_PROP(pt_number, CSpinner, angle)
END_NODE_PROPS()

CSpinner::CSpinner()
{
    m_rpm = 1.0f;
    m_axis.x = 0.0f;
    m_axis.y = 1.0f;
    m_axis.z = 0.0f;
    m_angle = 0.0f;
}

void CSpinner::Render()
{
    XAppPushWorld();

    D3DXMATRIX matrix;
    D3DXMatrixRotationAxis(&matrix, &m_axis, m_angle);

    XAppMultWorld(&matrix);

    XAppUpdateWorld();

    CGroup::Render();

    XAppPopWorld();
}

void CSpinner::Advance(float nSeconds)
{
    CGroup::Advance(nSeconds);

    m_angle += ((m_rpm / 60.0f) * nSeconds) * (2.0f * D3DX_PI);

    while (m_angle > 2.0f * D3DX_PI)
        m_angle -= 2.0f * D3DX_PI;
    while (m_angle < -2.0f * D3DX_PI)
        m_angle += 2.0f * D3DX_PI;
}

////////////////////////////////////////////////////////////////////////////


class CWaver : public CSpinner
{
    DECLARE_NODE(CWaver, CSpinner)
public:
    CWaver();

    float m_field;

    void Advance(float nSeconds);

    DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Waver", CWaver, CGroup)

START_NODE_PROPS(CWaver, CSpinner)
    NODE_PROP(pt_number, CWaver, field)
END_NODE_PROPS()

CWaver::CWaver()
{
    m_field = D3DX_PI / 4.0f;
}

void CWaver::Advance(float nSeconds)
{
    CGroup::Advance(nSeconds); // Skip CSpinner!

    m_angle = sinf((float) (XAppGetNow() * D3DX_PI * m_rpm / 60.0f)) * m_field / 2.0f;
}

////////////////////////////////////////////////////////////////////////////

class CLayout : public CGroup
{
    DECLARE_NODE(CLayout, CGroup)
public:
    CLayout();

    D3DXVECTOR3 m_direction;
    float m_spacing;

    void Render();
    void GetBBox(BBox* pBBox);
    float GetRadius();

    DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Layout", CLayout, CGroup)

START_NODE_PROPS(CLayout, CGroup)
    NODE_PROP(pt_vec3, CLayout, direction)
    NODE_PROP(pt_number, CLayout, spacing)
END_NODE_PROPS()

CLayout::CLayout() :
    m_direction(1.0f, 0.0f, 0.0f),
    m_spacing(1.0f)
{
}

void CLayout::Render()
{
    int nChildren = m_children.GetLength();
    if (nChildren == 0)
        return;

    if (m_direction.x == 0 && m_direction.y == 0 && m_direction.z == 0)
    {
        // Make a circle...
        D3DXMATRIX mat = *XAppGetWorld();

        float r = (nChildren / 4) * m_spacing;

        for (int i = 0; i < nChildren; i += 1)
        {
            XAppPushWorld();

            CNode* pNode = m_children.GetNode(i);
            if (!pNode->m_visible)
                continue;

            float a = D3DX_PI * 2.0f * i / nChildren;
            float x = r * cosf(-a);
            float z = r * sinf(-a);

            D3DXVECTOR3 axis(0.0f, 0.1f, 0.0f);
            XAppTranslateWorld(x, 0.0f, z);
            XAppRotateWorld(&axis, a + D3DX_PI / 2.0f);
            XAppUpdateWorld();

            pNode->Render();

            XAppPopWorld();
        }

        return;
    }

    float spacing = m_spacing;

    XAppPushWorld();

    D3DXVECTOR3 v;
    D3DXVec3Scale(&v, &m_direction, /*-GetRadius()*/-((float)nChildren + spacing) / 2);
    XAppTranslateWorld(v.x, v.y, v.z);

    for (int i = 0; i < nChildren; i += 1)
    {
        CNode* pNode = m_children.GetNode(i);
        if (!pNode->m_visible)
            continue;

        D3DXVec3Scale(&v, &m_direction, 0.5f/*pNode->GetRadius()*/);

        XAppTranslateWorld(v.x, v.y, v.z);

        XAppUpdateWorld();
        pNode->Render();

        if (i < nChildren - 1)
        {
            D3DXVec3Scale(&v, &m_direction, 0.5f/*pNode->GetRadius()*/ + spacing);
            XAppTranslateWorld(v.x, v.y, v.z);
        }
    }

    XAppPopWorld();
}

void CLayout::GetBBox(BBox* pBBox)
{
    if (m_children.GetLength() == 0)
    {
        CNode::GetBBox(pBBox);
        return;
    }

    float spacing = m_spacing + 1.0f;
    m_children.GetNode(0)->GetBBox(pBBox);
    for (int i = 1; i < m_children.GetLength(); i += 1)
    {
        CNode* pNode = m_children.GetNode(i);
        BBox bbox;
        pNode->GetBBox(&bbox);

        D3DXVECTOR3 v;
        D3DXVec3Scale(&v, &m_direction, spacing);
        v.x *= bbox.size.x;
        v.y *= bbox.size.y;
        v.z *= bbox.size.z;
        pBBox->size += bbox.size;

        if (pBBox->size.x > bbox.size.x)
            pBBox->size.x = bbox.size.x;
        if (pBBox->size.y > bbox.size.y)
            pBBox->size.y = bbox.size.y;
        if (pBBox->size.z > bbox.size.z)
            pBBox->size.z = bbox.size.z;
    }
}

float CLayout::GetRadius()
{
    float radius = 0.0f;

    for (int i = 0; i < m_children.GetLength(); i += 1)
        radius += m_children.GetNode(i)->GetRadius();

    if (m_children.GetLength() > 1)
        radius += (m_children.GetLength() - 1) * m_spacing / 2.0f;

    return radius;
}

////////////////////////////////////////////////////////////////////////////

class CSwitch : public CNode
{
    DECLARE_NODE(CSwitch, CNode)
public:
    CSwitch();
    ~CSwitch();

    int m_whichChoice;
    CNodeArray m_choice;

    void Render();
    void Advance(float nSeconds);

    void GetBBox(BBox* pBBox);
    float GetRadius();
#ifdef _LIGHTS
    void SetLight(int& nLight, D3DCOLORVALUE& ambient);
#endif

    DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Switch", CSwitch, CNode)

START_NODE_PROPS(CSwitch, CNode)
    NODE_PROP(pt_integer, CSwitch, whichChoice)
    NODE_PROP(pt_nodearray, CSwitch, choice)
END_NODE_PROPS()

CSwitch::CSwitch() :
    m_whichChoice(-1)
{
}

CSwitch::~CSwitch()
{
}

void CSwitch::Render()
{
    if (m_whichChoice >= 0 && m_whichChoice < m_choice.GetLength())
    {
        CNode* pNode = m_choice.GetNode(m_whichChoice);
        if (pNode->m_visible)
            pNode->Render();
    }
}

void CSwitch::GetBBox(BBox* pBBox)
{
    if (m_whichChoice >= 0 && m_whichChoice < m_choice.GetLength())
        m_choice.GetNode(m_whichChoice)->GetBBox(pBBox);
    else
        CNode::GetBBox(pBBox);
}

float CSwitch::GetRadius()
{
    if (m_whichChoice >= 0 && m_whichChoice < m_choice.GetLength())
        return m_choice.GetNode(m_whichChoice)->GetRadius();

    return 0.0f;
}

void CSwitch::Advance(float nSeconds)
{
    CNode::Advance(nSeconds);

    for (int i = 0; i < m_choice.GetLength(); i += 1)
        m_choice.GetNode(i)->Advance(nSeconds);
}

#ifdef _LIGHTS
void CSwitch::SetLight(int& nLight, D3DCOLORVALUE& ambient)
{
    if (m_whichChoice >= 0 && m_whichChoice < m_choice.GetLength())
    {
        CNode* pNode = m_choice.GetNode(m_whichChoice);

        if (pNode != NULL)
            pNode->SetLight(nLight, ambient);
    }
}
#endif

////////////////////////////////////////////////////////////////////////////

class CBillboard : public CGroup
{
    DECLARE_NODE(CBillboard, CGroup)
public:
    CBillboard();
    ~CBillboard();

    D3DXVECTOR3 m_axisOfRotation;

    void Render();

    D3DXMATRIX m_matrix;

    void CalcMatrix();

    DECLARE_NODE_PROPS()
};


IMPLEMENT_NODE("Billboard", CBillboard, CGroup)

START_NODE_PROPS(CBillboard, CGroup)
    NODE_PROP(pt_vec3, CBillboard, axisOfRotation)
END_NODE_PROPS()


CBillboard::CBillboard() :
    m_axisOfRotation(0.0f, 1.0f, 0.0f)
{
}

CBillboard::~CBillboard()
{
}

void CBillboard::Render()
{
    CalcMatrix();

    XAppPushWorld();
    XAppMultWorld(&m_matrix);

    XAppUpdateWorld();

    CGroup::Render();

    XAppPopWorld();
}

void CBillboard::CalcMatrix()
{
    // Determine the line between the Billboard's origin and the viewer's
    // position. This line and the axis of rotation define a plane. The
    // local z-axis of the Billboard needs to be rotated onto that plane,
    // pivoting around the axis of rotation.

    // Using the plane equation, find the distance between a unit vector
    // along the z-axis of the billboard and the plane. Use this distance
    // to create the base of right-triangle with the oposite corner at 0,0,0.
    // Now I've got the hypotenuse and one side of a right triangle and can
    // find the angle

    D3DXMATRIX world;
    D3DXMATRIX world2local;

    XAppGetTransform(D3DTS_WORLD, &world);

    D3DXMatrixInverse(&world2local, NULL, &world);

    // get eye vector in local coordinate space
    D3DXVECTOR3 eye = theCamera.m_position;
    D3DXVec3TransformNormal(&eye, &eye, &world2local);
    D3DXVec3Normalize(&eye, &eye);


    D3DXVECTOR3 axis = m_axisOfRotation;
    float alen = D3DXVec3Length(&axis);

    if (alen <= 0.001f)
    {
        // viewer-alignment

        // viewer's up vector
        D3DXVECTOR3 up(world2local.m[0][3], world2local.m[1][1], world2local.m[1][2]);
        D3DXVec3Normalize(&up, &up);

        // get x-axis vector from cross product of z and y
        D3DXVECTOR3 x;
        D3DXVec3Cross(&x, &up, &eye);
        D3DXVec3Normalize(&x, &x);

        m_matrix.m[0][0] = x.x;
        m_matrix.m[0][1] = x.y;
        m_matrix.m[0][2] = x.z;
        m_matrix.m[0][3] = 0.0f;

        m_matrix.m[1][0] = up.x;
        m_matrix.m[1][1] = up.y;
        m_matrix.m[1][2] = up.z;
        m_matrix.m[1][3] = 0.0f;

        m_matrix.m[2][0] = eye.x;
        m_matrix.m[2][1] = eye.y;
        m_matrix.m[2][2] = eye.z;
        m_matrix.m[2][3] = 0.0f;

        m_matrix.m[3][0] = 0.0f;
        m_matrix.m[3][1] = 0.0f;
        m_matrix.m[3][2] = 0.0f;
        m_matrix.m[3][3] = 1.0f;
    }
    else
    {
        // normalize axis of rotation
        axis *= 1.0f / alen;

        D3DXVECTOR3 x;
        D3DXVec3Cross(&x, &axis, &eye);
        D3DXVec3Normalize(&x, &x);

        // get z-axis vector from cross product of x and axis
        D3DXVECTOR3 z;
        D3DXVec3Cross(&z, &x, &axis);

        // calculate angle which the z-axis vector of the current coordinate system has to be rotated around
        // the y-axis of the new coordinate system to lie in its x=0 plane
        float angle = acosf(z.z);
        if (x.z > 0)
          angle = -angle;

        D3DXMatrixRotationAxis(&m_matrix, &axis, angle);


/*
        // normalize axis of rotation
        axis *= 1.0f / alen;

        // map eye & z into plane with normal axis through 0.0

        float d = -D3DXVec3Dot(&axis, &eye);
        eye += axis * d;
        D3DXVec3Normalize(&eye, &eye);


        // rotate z into plane
        D3DXVECTOR3 z(0.0f, 0.0f, 1.0f);
        d = -D3DXVec3Dot(&axis, &z);
        z += axis * d;
        D3DXVec3Normalize(&z, &z);


        // now take the angle between eye and z
        float cosw = D3DXVec3Dot(&eye, &z);

        D3DXVECTOR3 v;
        D3DXVec3Cross(&v, &eye, &z);
        float sinw = D3DXVec3Length(&v);

        float angle = acosf(cosw);


        D3DXVec3Normalize(&v, &v);

        if ((sinw > 0.0) && (D3DXVec3Dot(&axis, &v) > 0.0f))  // axis,v are opposite
        {
            axis.x = -axis.x;
            axis.y = -axis.y;
            axis.z = -axis.z;
        }

        D3DXMatrixRotationAxis(&m_matrix, &axis, angle);
*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\FileUtil.cpp ===
#include "std.h"
#include "xapp.h"

bool DoesFileExist(const TCHAR* szFileName)
{
    CHAR szFile[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA fad;

    Ansi(szFile, szFileName, MAX_PATH);
    return GetFileAttributesEx(szFile, GetFileExInfoStandard, &fad) != 0;
}

void MakePath(TCHAR* szBuf, const TCHAR* szDir, const TCHAR* szFile)
{
	int cch = _tcslen(szDir);

	if (szBuf != szDir)
		CopyChars(szBuf, szDir, cch);

	ASSERT(cch > 0);
	if (szBuf[cch - 1] != '\\')
	{
		szBuf[cch] = '\\';
		cch += 1;
	}

	_tcscpy(szBuf + cch, szFile);
}

void CleanFilePath(char* szPath, const TCHAR* szSrcPath)
{
	char* pchPath = szPath;
	const TCHAR* pch = szSrcPath;
	if (_tcsnicmp(pch, _T("file:"), 5) == 0)
		pch += 5;
	for (; *pch != '\0'; pch += 1)
	{
		if (*pch == '/')
			*pchPath++ = '\\';
		else if (*pch == '?')
			break;
		else
			*pchPath++ = (char)*pch;
	}
	*pchPath = '\0';
}

#if defined(_UNICODE)
void CleanFilePath(TCHAR* szPath, const TCHAR* szSrcPath)
{
	TCHAR* pchPath = szPath;
	const TCHAR* pch = szSrcPath;
	if (_tcsnicmp(pch, _T("file:"), 5) == 0)
		pch += 5;
	for (; *pch != '\0'; pch += 1)
	{
		if (*pch == '/')
			*pchPath++ = '\\';
		else if (*pch == '?')
			break;
		else
			*pchPath++ = (TCHAR)*pch;
	}
	*pchPath = '\0';
}
#endif

void MakeAbsoluteURL2(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL)
{
    ASSERT(theApp.m_dwMainThreadId == GetCurrentThreadId());

	if (_tcschr(szURL, ':') != NULL || (szURL[0] == '\\' && szURL[1] == '\\') || szBase == NULL || (_tcschr(szBase, ':') == NULL && _tcschr(szBase, '/') == NULL))
	{
		_tcscpy(szBuf, szURL);
		return;
	}

	const TCHAR* pchURL = szURL;

	// make relative url absolute...
	_tcscpy(szBuf, szBase);
	TCHAR* pch = _tcsrchr(szBuf, '/');
	if (pch == NULL)
		pch = _tcsrchr(szBuf, '\\');
	if (*pch == NULL)
	{
		pch = szBuf + _tcslen(szBuf) - 1;
	}
	else
	{
		while (pchURL[0] == '.' && pchURL[1] == '.' && (pchURL[2] == '/' || pchURL[2] == '\\'))
		{
			pchURL += 3;

			*pch = '\0';
			pch = _tcsrchr(szBuf, '/');
			if (pch == NULL)
				pch = _tcsrchr(szBuf, '\\');
			if (pch == NULL)
			{
				pch = szBuf + _tcslen(szBuf) - 1;
				break;
			}
		}
	}

	*pch = '/';
	_tcscpy(pch + 1, pchURL);
}

void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL)
{
	if (szBase == NULL)
	{
		MakeAbsoluteURL2(szBuf, theApp.m_szAppDir, szURL);
	}
	else
	{
		TCHAR szBuf2 [1024];
		MakeAbsoluteURL2(szBuf2, theApp.m_szAppDir, szBase);
		MakeAbsoluteURL2(szBuf, szBuf2, szURL);
	}
}

TCHAR g_szCurDir [1024];

void UpdateCurDirFromFile(const TCHAR* szURL)
{
	TCHAR szBuf [1024];
	MakeAbsoluteURL(szBuf, szURL);

	if (_tcschr(szBuf, ':') != NULL || (szBuf[0] == '\\' && szBuf[1] == '\\'))
	{
//		if (_tcsicmp(g_szCurDir, szBuf) != 0)
//		{
			_tcscpy(g_szCurDir, szBuf);
//			TRACE(_T("Setting base directory to %s\n"), g_szCurDir);
//		}

/* REVIEW: File is removed in MakeAbsoluteURL...
		TCHAR* pch = _tcsrchr(g_szCurDir, '/');
		if (pch == NULL)
			pch = _tcsrchr(g_szCurDir, '\\');
		if (pch != NULL)
			*pch = '\0';
		TRACE(_T("Set base URL to: %s\n"), g_szCurDir);
*/
	}
}

void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szURL)
{
	TCHAR szCurDir [1024];
	MakeAbsoluteURL2(szCurDir, theApp.m_szAppDir, g_szCurDir);
	MakeAbsoluteURL2(szBuf, szCurDir, szURL);
}

void FindFilePath(TCHAR* szFullPath/*[MAX_PATH]*/, const TCHAR* szFile)
{
	// Make it absolute...
	MakeAbsoluteURL(szFullPath, szFile);

	if (!DoesFileExist(szFullPath))
	{
		TRACE(_T("File not found: %s\n"), szFullPath);
		_tcscpy(szFullPath, theApp.m_szAppDir);
		_tcscat(szFullPath, szFile);
		TRACE(_T("\ttrying %s instead...\n"), szFullPath);
	}
}


DWORD GetUniqueFile(const TCHAR* szBase, TCHAR* szPath/*=NULL*/)
{
	TCHAR szDirBuf [MAX_PATH];
	if (szPath == NULL)
		szPath = szDirBuf;

	for (DWORD dw = 0; ; dw += 1)
	{
		_stprintf(szPath, _T("%s\\%08x"), szBase, dw);
		if (!DoesFileExist(szPath))
			return dw;
	}
}

DWORD CreateUniqueDir(const TCHAR* szBase)
{
	TCHAR szDirBuf [MAX_PATH];
	DWORD dw = GetUniqueFile(szBase, szDirBuf);
	TRACE(_T("CreateDirectory: %s\n"), szDirBuf);
	VERIFY(XAppCreateDirectory(szDirBuf));

	return dw;
}

int GetFileBlocks(const TCHAR* szFilePath, int nBlockSize)
{
	HANDLE hFile = XAppCreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return 0;

	int nBytes = GetFileSize(hFile, NULL);

	CloseHandle(hFile);

	return (nBytes + nBlockSize - 1) / nBlockSize;
}

int GetDirectoryBlocks(const TCHAR* szDirPath, int nBlockSize, bool bRecursive, HANDLE hCancelEvent)
{
    if (hCancelEvent && WaitForSingleObject(hCancelEvent, 0) == WAIT_OBJECT_0)
    {
        return -1;
    }

	TCHAR szBuf [MAX_PATH];
	MakePath(szBuf, szDirPath, _T("*.*"));
	
    WIN32_FIND_DATA fd;

	//
	// nTotalBlocks starts out with 1 to take into account the size taken up from the directory entry itself.
	//
	int nTotalBlocks = 1;
    bool bCancel = false;

	char sszBuf [MAX_PATH];
	Ansi(sszBuf, szBuf, MAX_PATH);
	HANDLE hFind = FindFirstFile(sszBuf, &fd);

	if (hFind == INVALID_HANDLE_VALUE)
		return 0;

	do
	{
        if (hCancelEvent && WaitForSingleObject(hCancelEvent, 0) == WAIT_OBJECT_0)
        {
            bCancel = true;
            break;
        }

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
		{
			nTotalBlocks += (fd.nFileSizeLow + nBlockSize - 1) / nBlockSize;
		}
		else if (bRecursive && fd.cFileName[0] != '.')
		{
			TCHAR szFileName [MAX_PATH];
			Unicode(szFileName, fd.cFileName, countof(szFileName));
			MakePath(szBuf, szDirPath, szFileName);
			nTotalBlocks += GetDirectoryBlocks(szBuf, nBlockSize, true, hCancelEvent);
		}
	}
	while (FindNextFile(hFind, &fd));
	FindClose(hFind);

	return bCancel ? -1 : nTotalBlocks;
}

int GetFileSize(const TCHAR* szFilePath)
{
	HANDLE hFile = XAppCreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return 0;

	int nFileSize = GetFileSize(hFile, NULL);

	CloseHandle(hFile);

	return nFileSize;
}

#ifdef _WINDOWS // TODO: Need Xbox versions too!

bool DeleteDirectory(const TCHAR* szPath)
{
	TCHAR szBuf [MAX_PATH];
	_stprintf(szBuf, _T("%s\\*.*"), szPath);

	WIN32_FIND_DATA fd;
	HANDLE h = FindFirstFile(szBuf, &fd);
	if (h != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (_tcscmp(fd.cFileName, _T(".")) == 0 || _tcscmp(fd.cFileName, _T("..")) == 0)
				continue;

			_stprintf(szBuf, _T("%s\\%s"), szPath, fd.cFileName);

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				if (!DeleteDirectory(szBuf))
					return false;
			}
			else
			{
				if (!DeleteFile(szBuf))
					return false;
			}
		}
		while (FindNextFile(h, &fd));
		FindClose(h);
	}

	return RemoveDirectory(szPath) != FALSE;
}

bool CopyDirectory(const TCHAR* szSrcPath, const TCHAR* szDestPath)
{
	CreateDirectory(szDestPath, NULL);

	TCHAR szBuf [MAX_PATH];
	_stprintf(szBuf, _T("%s\\*.*"), szSrcPath);

	WIN32_FIND_DATA fd;
	HANDLE h = FindFirstFile(szBuf, &fd);
	if (h != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (_tcscmp(fd.cFileName, _T(".")) == 0 || _tcscmp(fd.cFileName, _T("..")) == 0)
				continue;

			_stprintf(szBuf, _T("%s\\%s"), szSrcPath, fd.cFileName);

			TCHAR szBuf2 [MAX_PATH];
			_stprintf(szBuf2, _T("%s\\%s"), szDestPath, fd.cFileName);

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				if (!CopyDirectory(szBuf, szBuf2))
					return false;
			}
			else
			{
				if (!CopyFile(szBuf, szBuf2, FALSE))
					return false;
			}
		}
		while (FindNextFile(h, &fd));
		FindClose(h);
	}

	return true;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Files.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "Node.h"
#include "Date.h"
#include "Runner.h"

class CFile : public CNode
{
	DECLARE_NODE(CFile, CNode)
public:
	CFile();
	~CFile();

	TCHAR* m_name;
	TCHAR* m_type;
	TCHAR* m_path;
	int m_length;
	CDateObject* m_date;

	CStrObject* readText();

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};


class CFolder : public CNode
{
	DECLARE_NODE(CFolder, CNode)
public:
	CFolder();
	~CFolder();

	TCHAR* m_path;
	TCHAR* m_name;
	CNodeArray m_files;
	CNodeArray m_subFolders;

	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	void Refresh(const TCHAR* szPath);

	void sortByName();
	void sortByType();
	void sortByDate();
	void sortByLength();

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};


IMPLEMENT_NODE("File", CFile, CNode)

START_NODE_PROPS(CFile, CNode)
	NODE_PROP(pt_string, CFile, name)
	NODE_PROP(pt_string, CFile, type)
	NODE_PROP(pt_string, CFile, path)
	NODE_PROP(pt_integer, CFile, length)
	NODE_PROP(pt_node, CFile, date)
END_NODE_PROPS()

START_NODE_FUN(CFile, CNode)
	NODE_FUN_SV(readText)
END_NODE_FUN()


IMPLEMENT_NODE("Folder", CFolder, CNode)

START_NODE_PROPS(CFolder, CNode)
	NODE_PROP(pt_string, CFolder, path)
	NODE_PROP(pt_string, CFolder, name)
	NODE_PROP(pt_nodearray, CFolder, files)
	NODE_PROP(pt_nodearray, CFolder, subFolders)
END_NODE_PROPS()

START_NODE_FUN(CFolder, CNode)
	NODE_FUN_VV(sortByName)
	NODE_FUN_VV(sortByType)
	NODE_FUN_VV(sortByDate)
	NODE_FUN_VV(sortByLength)
END_NODE_FUN()


CFile::CFile() :
	m_name(NULL),
	m_type(NULL),
	m_path(NULL),
	m_length(-1),
	m_date(NULL)
{
}

CFile::~CFile()
{
	delete [] m_name;
	delete [] m_type;
	delete [] m_path;
	delete m_date;
}

CStrObject* CFile::readText()
{
	CStrObject* pStr = new CStrObject;

	if (m_path != NULL)
	{
		CActiveFile file;
		if (file.Fetch(m_path))
		{
#ifdef _UNICODE
			file.MakeUnicode();
#endif

			pStr->Append((TCHAR*)file.GetContent());
		}
	}

	return pStr;
}


CFolder::CFolder() :
	m_path(NULL),
	m_name(NULL)
{
}

CFolder::~CFolder()
{
	delete [] m_path;
	delete [] m_name;
}

bool CFolder::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_path))
	{
		const TCHAR* szPath = *((const TCHAR**)pvValue);
		Refresh(szPath);
	}

	return true;
}

void CFolder::Refresh(const TCHAR* szPath)
{
	TCHAR szWild [MAX_PATH];
	WIN32_FIND_DATA fd;
	HANDLE h;

	lstrcpyn(szWild, szPath, MAX_PATH - sizeof("\\*.*"));
	_tcscat(szWild, _T("\\*.*"));

	char szWildA [MAX_PATH];
	Ansi(szWildA, szWild, MAX_PATH);
	h = FindFirstFile(szWildA, &fd);

    if (h == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001Cannot read directory: \"%s\" (%d)\n"), szPath, GetLastError());
		return;
	}

	// BLOCK: Update name based on path...
	{
		const TCHAR* pchName = _tcsrchr(szPath, '\\');
		if (pchName == NULL)
			pchName = _T("");
		else
			pchName += 1;

		int cchName = _tcslen(pchName);
		delete [] m_name;

		m_name = new TCHAR [cchName + 1];
		_tcscpy(m_name, pchName);
	}


	do
	{
		if (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
			continue;

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			continue;

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
			continue;

		TCHAR szFileName [MAX_PATH];
		Unicode(szFileName, fd.cFileName, countof(szFileName));

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			CFolder* pFolder = new CFolder;
			m_subFolders.AddNode(pFolder);

			pFolder->m_path = new TCHAR [_tcslen(szPath) + 1 + _tcslen(szFileName) + 1];
			_stprintf(pFolder->m_path, _T("%s\\%s"), szPath, szFileName);

			pFolder->m_name = new TCHAR [_tcslen(szFileName) + 1];
			_tcscpy(pFolder->m_name, szFileName);
		}
		else
		{
			CFile* pFile = new CFile;
			m_files.AddNode(pFile);

			pFile->m_date = new CDateObject;
			pFile->m_date->m_time = fd.ftLastWriteTime;

			const TCHAR* pch = _tcsrchr(szFileName, '.');

			int cchName = _tcslen(szFileName);
			if (pch != NULL)
				cchName -= _tcslen(pch);
			pFile->m_name = new TCHAR [cchName + 1];
			CopyChars(pFile->m_name, szFileName, cchName);
			pFile->m_name[cchName] = 0;

			if (pch != NULL)
				pch += 1;
			else
				pch = _T("");
			pFile->m_type = new TCHAR [_tcslen(pch) + 1];
			_tcscpy(pFile->m_type, pch);
			_tcslwr(pFile->m_type);

			pFile->m_path = new TCHAR [_tcslen(szPath) + 1 + _tcslen(szFileName) + 1];
			_stprintf(pFile->m_path, _T("%s\\%s"), szPath, szFileName);

			pFile->m_length = fd.nFileSizeLow;
		}
	}
	while (FindNextFile(h, &fd));

	FindClose(h);
}

static int __cdecl CmpName(const void* p1, const void* p2)
{
	const CFile* pFile1 = *(CFile**)p1;
	const CFile* pFile2 = *(CFile**)p2;

	return _tcsicmp(pFile1->m_name, pFile2->m_name);
}

void CFolder::sortByName()
{
	m_files.Sort(&CmpName);
}

static int __cdecl CmpType(const void* p1, const void* p2)
{
	const CFile* pFile1 = *(CFile**)p1;
	const CFile* pFile2 = *(CFile**)p2;

	return _tcsicmp(pFile1->m_type, pFile2->m_type);
}

void CFolder::sortByType()
{
	m_files.Sort(CmpType);
}

static int __cdecl CmpDate(const void* p1, const void* p2)
{
	const CFile* pFile1 = *(CFile**)p1;
	const CFile* pFile2 = *(CFile**)p2;

	return CompareFileTime(&pFile1->m_date->m_time, &pFile2->m_date->m_time);
}

void CFolder::sortByDate()
{
	m_files.Sort(CmpDate);
}

static int __cdecl CmpLength(const void* p1, const void* p2)
{
	const CFile* pFile1 = *(CFile**)p1;
	const CFile* pFile2 = *(CFile**)p2;

	return pFile1->m_length - pFile2->m_length;
}

void CFolder::sortByLength()
{
	m_files.Sort(CmpLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\font.h ===
//****************************************************************************
//
// XBox internal font header.
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

#include <d3d8.h>
#include "xfontformat.h"

#pragma once

#if defined(__cplusplus)

extern "C" {

#endif

//
// Callbacks used to communicate to the true-type font package.  We go 
// through these callbacks to give the linker the opportunity to
// throw all of the true type stuff away...if the user doesn't call
// XFONT_OpenTrueTypeFont, then none of the TrueType methods get 
// referenced 
//

typedef void (__stdcall *CB_UnloadFont)(struct _Font *);
typedef HRESULT (__stdcall *CB_ResetTransform)(struct _Font *);
typedef HRESULT (__fastcall *CB_GetCharacterData)(struct _Font *, WCHAR, struct _Glyph **, unsigned *pcbGlyphSize);

//
// Structure definitions.
//

//============================================================================
// An entry in the cache.  The glyph immediately follows this structure.
//============================================================================

typedef struct _CacheEntry
{
	WCHAR wch;			// Cached character
	WORD wLength;		// Length of this entry, including the header

	// The entry is stashed on a circular, doubly-linked list.
	struct _CacheEntry *pNextEntry;
	struct _CacheEntry *pPrevEntry;
} CacheEntry;

//============================================================================
// The structure that holds the state of a font.  This is opaquely given to
// the consumer so they can manually switch between fonts without having to
// unload/load them.
//============================================================================

typedef struct _Font
{
	// 
	// Metrics information about this font.
	//

	unsigned uCellHeight;			// the height of the character cell
	unsigned uDescent;				// bottom of the cell to the baseline

	unsigned uAntialiasLevel;		// amount of antialiasing information (0, 2, 4)
    unsigned uRLEWidth;             // # of bits for RLE
    unsigned uMaxBitmapHeight;      // height of the tallest glyph
    unsigned uMaxBitmapWidth;       // width of the widest glyph
    unsigned uStyle;                // the style of the font to simulate (truetype only)
	unsigned uIntercharacterSpacing;// how many extra pixels to put between each character
    
	unsigned uAlignmentMode;		// how to align the text
	D3DCOLOR TextColor;				// the color of the text
	D3DCOLOR BackgroundColor;		// the color of the background
	BOOL     fPaintBackground;      // whether to fill the background or not

	//
	// Information about the current surface.
	//

//	IDirect3DSurface8 *pSurface;	// The surface itself.
//	D3DSURFACE_DESC SurfaceDesc;	// Describes the format/size/etc of the surface.
	
	//
	// Indirection tables used to abstract rendering bitmaps and truetype
	// fonts.
	//

	CB_UnloadFont pfnUnloadFont;
	CB_ResetTransform pfnResetTransform;
	CB_GetCharacterData pfnGetCharacterData;

    //
    // The glyph cache.
    //

	// Memory to hold the glyph/bitmap when there is no cache.
	void *pvOneGlyph;

	// The real cache.
	BYTE *pbCache;				// Start of the cache.
	BYTE *pbCacheEnd;			// End of the cache.
	BYTE *pbCacheNext;          // Where to put the next new entry.

	unsigned cbCacheSize;		// Size of the cache.
	unsigned cbCacheUsed;		// How much as been used.

	CacheEntry CacheHead;		// Head of the cache list.
} Font;

//
// Exposed functions.
//

// Open a TrueType font.
HRESULT __stdcall TT_OpenTrueTypeFont(LPCWSTR wszFileName, struct _Font **ppFont);

// Open a bitmap font.
HRESULT __stdcall BP_OpenBitmapFont(LPCWSTR wszFileName, unsigned uCacheSize, struct _Font **ppFont, BOOL *pfUseCache);

// Render a single character.
HRESULT __stdcall PaintText(D3DLOCKED_RECT* pLock, D3DFORMAT Format, Font *, LPCWSTR, unsigned, long, long, unsigned, unsigned, unsigned, unsigned);

// Methods used by the font packages to control the font cache.
HRESULT AddToCache(WCHAR wch, unsigned cbGlyph,	Glyph **ppGlyph);
void ClearCache();

extern Font *s_pFont;

#if defined(__cplusplus)

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\hud.cpp ===
#include "std.h"
#include "xapp.h"
#include "Lerper.h"
#include "Node.h"
#include "Texture.h"
#include "Lerper.h"

extern D3DXMATRIX g_matIdentity;

class CHud : public CGroup
{
	DECLARE_NODE(CHud, CGroup)
public:
	CHud();
	~CHud();

	void Render();

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("HUD", CHud, CGroup)

START_NODE_PROPS(CHud, CGroup)
END_NODE_PROPS()


CHud::CHud()
{
}

CHud::~CHud()
{
}

extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matProjection;

void CHud::Render()
{
	D3DXMATRIX matProjection, matProjectionSave, matViewSave;
	D3DXMatrixOrthoLH(&matProjection, 720.0f, 480.0f, -10000.0f, 10000.0f);

	matProjectionSave = g_matProjection;
	g_matProjection = matProjection;
	XAppSetTransform(D3DTS_PROJECTION, &g_matProjection);

	matViewSave = g_matView;
	g_matView = g_matIdentity;
	XAppSetTransform(D3DTS_VIEW, &g_matView);

	DWORD dwLighting;
	XAppGetRenderState(D3DRS_LIGHTING, &dwLighting);
	XAppSetRenderState(D3DRS_LIGHTING, FALSE);

	XAppPushWorld();
	XAppIdentityWorld();
	XAppUpdateWorld();


	// Disable Edge Antialiasing
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);

	//XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);

	CGroup::Render();

	//XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);

	XAppPopWorld();

	XAppSetRenderState(D3DRS_LIGHTING, dwLighting);

	g_matProjection = matProjectionSave;
	XAppSetTransform(D3DTS_PROJECTION, &g_matProjection);
	g_matView = matViewSave;
	XAppSetTransform(D3DTS_VIEW, &g_matView);
}


////////////////////////////////////////////////////////////////////////////

class CPicture : public CNode
{
	DECLARE_NODE(CPicture, CNode)
public:
	CPicture();
	~CPicture();

	float m_left;
	float m_top;
	float m_width;
	float m_height;
	CNode* m_texture;
	float m_transparency;
	float m_fade;
	D3DXVECTOR3 m_color;

	void OnLoad();
	void Render();
	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	float m_alpha;
//	float m_startAlpha;
//	float m_endAlpha;
	XTIME m_startFadeTime;

	float m_startLeft;
	float m_endLeft;
	float m_startTop;
	float m_endTop;
	float m_startWidth;
	float m_endWidth;
	float m_startHeight;
	float m_endHeight;

	LPDIRECT3DVERTEXBUFFER8 m_pVB;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Picture", CPicture, CNode)

START_NODE_PROPS(CPicture, CNode)
	NODE_PROP(pt_number, CPicture, top)
	NODE_PROP(pt_number, CPicture, left)
	NODE_PROP(pt_number, CPicture, width)
	NODE_PROP(pt_number, CPicture, height)
	NODE_PROP(pt_node, CPicture, texture)
	NODE_PROP(pt_number, CPicture, transparency)
	NODE_PROP(pt_number, CPicture, fade)
	NODE_PROP(pt_color, CPicture, color)
END_NODE_PROPS()

CPicture::CPicture() :
	m_texture(NULL),
	m_left(0.0f),
	m_top(0.0f),
	m_width(-1.0f),
	m_height(-1.0f),
	m_transparency(0.0f),
	m_fade(0.0f),
	m_color(1.0f, 1.0f, 1.0f)
{
	m_alpha = 1.0f;
//	m_startAlpha = 1.0f;
//	m_endAlpha = 1.0f;
	m_startFadeTime = 0.0f;

	m_pVB = NULL;
}

CPicture::~CPicture()
{
	if (m_pVB != NULL)
		m_pVB->Release();

	if (m_texture != NULL)
		m_texture->Release();
}

typedef struct _LITVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    union {
    D3DVALUE     nx;            /* Normal */
    D3DVALUE     dvNX;
    };
    union {
    D3DVALUE     ny;
    D3DVALUE     dvNY;
    };
    union {
    D3DVALUE     nz;
    D3DVALUE     dvNZ;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _LITVERTEX() { }
    _LITVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z;
          nx = n.x; ny = n.y; nz = n.z;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} LITVERTEX, *LPLITVERTEX;

void CPicture::Render()
{
	if (m_alpha <= 0.0f)
		return;

//	if (m_texture == NULL)
//		return;
	LPDIRECT3DTEXTURE8 pTexture = NULL;
	if (m_texture != NULL)
	{
		pTexture = m_texture->GetTextureSurface();
		if (pTexture == NULL)
			return;
	}

	if (m_pVB == NULL)
	{
		VERIFYHR(XAppGetD3DDev()->CreateVertexBuffer(4 * sizeof(LITVERTEX), D3DUSAGE_WRITEONLY, D3DFVF_VERTEX | D3DFVF_DIFFUSE, D3DPOOL_MANAGED, &m_pVB));
	}

	float nWidth = m_width;
	float nHeight = m_height;

	if (nWidth < 0.0f || nHeight < 0.0f)
	{
		if (pTexture == NULL)
			return;

		float nTexWidth, nTexHeight;
		XAppGetTextureSize(pTexture, nTexWidth, nTexHeight);

		if (nWidth < 0.0f)
			nWidth = nTexWidth;
		if (nHeight < 0.0f)
			nHeight = nTexHeight;

		if (m_texture->IsKindOf(NODE_CLASS(CTexture)))
		{
			CTexture* pTex = (CTexture*)m_texture;
			nWidth *= pTex->m_nImageWidth / nWidth;
			nHeight *= pTex->m_nImageHeight / nHeight;
		}
	}

	float tu = 1.0f;
	float tv = 1.0f;

	if (m_texture != NULL && m_texture->IsKindOf(NODE_CLASS(CTexture)))
	{
		// The texture image may have been stretched during creation on order to fill the texture surface.
		// Here we calculate a correction factor to the image looks right...

		float width, height;
		XAppGetTextureSize(pTexture, width, height);

		CTexture* pTex = (CTexture*)m_texture;

		tu = pTex->m_nImageWidth / width;
		tv = pTex->m_nImageHeight / height;
	}

	XAppSetTexture(0, pTexture);
	LITVERTEX verts [4];

	verts[0].dvX = m_left + nWidth;
	verts[0].dvY = m_top + nHeight;
	verts[0].dvTU = tu;
	verts[0].dvTV = tv;
	verts[0].dcColor = D3DCOLOR_RGBA(255, 255, 255, 255);

	verts[1].dvX = m_left;
	verts[1].dvY = m_top + nHeight;
	verts[1].dvTU = 0.0f;
	verts[1].dvTV = tv;
	verts[1].dcColor = D3DCOLOR_RGBA(255, 255, 255, 255);

	verts[2].dvX = m_left + nWidth;
	verts[2].dvY = m_top;
	verts[2].dvTU = tu;
	verts[2].dvTV = 0.0f;
	verts[2].dcColor = D3DCOLOR_RGBA(255, 255, 255, 255);

	verts[3].dvX = m_left;
	verts[3].dvY = m_top;
	verts[3].dvTU = 0.0f;
	verts[3].dvTV = 0.0f;
	verts[3].dcColor = D3DCOLOR_RGBA(255, 255, 255, 255);

	for (int i = 0; i < 4; i += 1)
	{
		verts[i].dvX -= theApp.m_nViewWidth / 2.0f;
		verts[i].dvY -= theApp.m_nViewHeight / 2.0f;
		verts[i].dvZ = 0.0f;
		verts[i].dvY = -verts[i].dvY;

		verts[i].dvNX = verts[i].dvX;
		verts[i].dvNY = verts[i].dvY;
		verts[i].dvNZ = 1.0f;
	}

	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	XAppSetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	XAppSetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_COLORVALUE(m_color.x, m_color.y, m_color.z, m_alpha));

	if (pTexture != NULL)
	{
		XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		XAppSetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TFACTOR);

		XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
		XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
		XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);

		XAppSetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT);
		XAppSetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_POINT);
	}
	else
	{
		XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

		XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
		XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
	}

	// Disable Edge Antialiasing
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);

	D3DVERTEX* v;
    VERIFYHR(m_pVB->Lock(0, 4 * sizeof (LITVERTEX), (BYTE**)&v, 0));
    CopyMemory(v, verts, 4 * sizeof (LITVERTEX));
    VERIFYHR(m_pVB->Unlock());

	VERIFYHR(XAppGetD3DDev()->SetStreamSource(0, m_pVB, sizeof (LITVERTEX)));
	VERIFYHR(XAppGetD3DDev()->SetVertexShader(D3DFVF_VERTEX | D3DFVF_DIFFUSE));
	VERIFYHR(XAppGetD3DDev()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2));

	XAppSetTexture(0, NULL);
	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

	XAppSetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	XAppSetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
}

void CPicture::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_texture != NULL)
		m_texture->Advance(nSeconds);
	if (m_fade != 0.0f && m_startFadeTime != 0.0f)
	{
		float t = (float) (XAppGetNow() - m_startFadeTime) / m_fade;

		if (t > 1.0f)
		{
			t = 1.0f;
			m_startFadeTime = 0.0f;
		}

		float t1 = 1.0f - t;

//		m_alpha = t1 * m_startAlpha + t * m_endAlpha;

		m_left = t1 * m_startLeft + t * m_endLeft;
		m_top = t1 * m_startTop + t * m_endTop;
		m_width = t1 * m_startWidth + t * m_endWidth;
		m_height = t1 * m_startHeight + t * m_endHeight;

//		TRACE("start %f end %f t %f a %f\n", m_startAlpha, m_endAlpha, t, m_alpha);
	}
}

void CPicture::OnLoad()
{
	m_alpha = 1.0f - m_transparency;

	m_startLeft = m_endLeft = m_left;
	m_startTop = m_endTop = m_top;
	m_startWidth = m_endWidth = m_width;
	m_startHeight = m_endHeight = m_height;

	CNode::OnLoad();
}

bool CPicture::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_transparency))
	{
		float value = *(float*)pvValue;

//		TRACE("Set transparency to %f\n", value);
		value = 1.0f - value;

		if (m_fade == 0.0f)
			m_alpha = value;
		else
			new CLerper(this, &m_alpha, value, m_fade);
/*
		m_endAlpha = 1.0f - value;

		if (m_fade == 0.0f)
		{
			m_startAlpha = m_endAlpha;
			m_alpha = m_endAlpha;
			m_startFadeTime = 0.0f;
//			TRACE("\timmediate; alpha = %f\n", m_alpha);
		}
		else
		{
			m_startAlpha = m_alpha;
			m_startFadeTime = XAppGetNow();
//			TRACE("\tfade over %f seconds; alpha = %f\n", m_fade, m_alpha);
		}
*/
	}
	else if ((int)pprd->pbOffset == offsetof(m_fade))
	{
		float value = *(float*)pvValue;
//		TRACE("Set fade to %f\n", value);

		if (value == 0.0f)
		{
//			m_alpha = m_endAlpha;
			m_startFadeTime = 0.0f;
//			TRACE("\tadjusting alpha to %f\n", m_alpha);
		}

		CLerper::RemoveObject(this);
	}
	else if ((int)pprd->pbOffset == offsetof(m_left))
	{
		float value = *(float*)pvValue;

		m_endLeft = value;
		m_startLeft = m_left;
		if (m_fade != 0.0f)
		{
			m_startFadeTime = XAppGetNow();
			return false;
		}
	}
	else if ((int)pprd->pbOffset == offsetof(m_top))
	{
		float value = *(float*)pvValue;
		m_endTop = value;
		m_startTop = m_top;
		if (m_fade != 0.0f)
		{
			m_startFadeTime = XAppGetNow();
			return false;
		}
	}
	else if ((int)pprd->pbOffset == offsetof(m_width))
	{
		float value = *(float*)pvValue;
		m_endWidth = value;
		m_startWidth = m_width;
		if (m_fade != 0.0f)
		{
			m_startFadeTime = XAppGetNow();
			return false;
		}
	}
	else if ((int)pprd->pbOffset == offsetof(m_height))
	{
		float value = *(float*)pvValue;
		m_endHeight = value;
		m_startHeight = m_height;
		if (m_fade != 0.0f)
		{
			m_startFadeTime = XAppGetNow();
			return false;
		}
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\image.h ===
#pragma once

#if !defined(_WINDOWS) && !defined(_WIN32_WCE)
#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
#define PALETTERGB(r,g,b)   (0x02000000 | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))
#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

#define SetRect(pRect, nLeft, nTop, nRight, nBottom) \
{ \
	(pRect)->left = (nLeft); \
	(pRect)->top = (nTop); \
	(pRect)->right = (nRight); \
	(pRect)->bottom = (nBottom); \
}

/* Background Modes */
#define TRANSPARENT         1
#define OPAQUE              2

/* Text Alignment Options */
#define TA_LEFT              0
#define TA_RIGHT             2
#define TA_TOP               0
#define TA_BOTTOM            8
#define TA_BASELINE          24

#endif



#if defined(_WINDOWS) || defined(_WIN32_WCE)
#define _USEGDI
#endif

#ifdef _USEGDI
#define HDRAW HDC
#else
#define XFONT_TRUETYPE
#include <xfont.h>

#ifndef __cplusplus
typedef struct IDirect3DSurface8 * LPDIRECT3DSURFACE8;
typedef unsigned long D3DCOLOR;
#endif

#ifdef __cplusplus
struct DRAW
{
	LPDIRECT3DSURFACE8 pSurface;
	D3DSURFACE_DESC Desc;
	D3DLOCKED_RECT Lock;
};
#endif

typedef struct DRAW* /*LPDIRECT3DSURFACE8*/ HDRAW;
#endif


#ifdef _USEGDI
typedef HBITMAP HIMAGE;
#endif

#ifdef _XBOX
EXTERN_C HRESULT X_BitBlt(HDRAW hDraw, int x, int y, int cx, int cy, LPDIRECT3DTEXTURE8 pSrcSurface, int xSrc, int ySrc);
EXTERN_C HRESULT X_FillRect(HDRAW hDraw, int x, int y, int cx, int cy, D3DCOLOR color);
typedef LPDIRECT3DTEXTURE8 HIMAGE;
#endif



EXTERN_C void DrawImage(HDRAW hDC, const TCHAR* szImgFile, int x, int y, int align, WORD* pcx, WORD* pcy);
EXTERN_C BOOL GetImageSize(const TCHAR* szImgFile, SIZE* pSize);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Image.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Texture.h"
#include "ActiveFile.h"
#include "xip.h"
#include "Image.h"


/*
TODO:
	Load images from arbitrary URL
	Perform load/decode in background thread
	Deal with incremental display (as an option)
	Deal with animated GIF's
	Handle the same image formats for both BITMAP and SURFACE cases
	Optimize case where CreateTexture actually returns the right size/format
*/

bool DecodeRAW(const TCHAR* szFileName, CTexture* pTexture);

////////////////////////////////////////////////////////////////////////////

class CImage
{
public:
	CImage();
	~CImage();

	int m_nWidth;
	int m_nHeight;
	BYTE* m_pels;
	int m_nPitch;
};


CImage::CImage()
{
	m_pels = NULL;
	m_nWidth = 0;
	m_nHeight = 0;
}

CImage::~CImage()
{
}

////////////////////////////////////////////////////////////////////////////

LPDIRECT3DTEXTURE8 ParseTexture(const TCHAR* szURL, const BYTE* pbContent, int cbContent, UINT width, UINT height)
{
#ifdef _XBOX
	const TCHAR* pch = _tcsrchr(szURL, '.');
	if (pch != NULL)
	{
		pch += 1;
		if (_tcsicmp(pch, _T("xt")) == 0)
		{
			IDirect3DTexture8* pTexture = (IDirect3DTexture8*)XAppD3D_AllocNoncontiguousMemory(sizeof (D3DBaseTexture));
			CopyMemory(pTexture, pbContent, sizeof (IDirect3DTexture8));

			int cbData = cbContent - sizeof (IDirect3DTexture8);

			BYTE* pbData = (BYTE*)XAppD3D_AllocContiguousMemory(cbData, D3DTEXTURE_ALIGNMENT);
			CopyMemory(pbData, pbContent + sizeof (IDirect3DTexture8), cbData);
			D3D_CopyContiguousMemoryToVideo(pbData);

			pTexture->Data = NULL;
			pTexture->Register(pbData);
			pTexture->Common |= D3DCOMMON_D3DCREATED;

			return pTexture;
		}
		else if (_tcsicmp(pch, _T("xbx")) == 0)
		{
//			TRACE(_T("Attempting to load XBX format image: %s...\n"), szURL);
			const XPR_HEADER* pxprh = (const XPR_HEADER*)pbContent;
			if (pxprh->dwMagic == XPR_MAGIC_VALUE)
			{
				int cbHeaders = pxprh->dwHeaderSize - sizeof (XPR_HEADER);
				int cbData = pxprh->dwTotalSize - pxprh->dwHeaderSize;

				// BLOCK: do some validation before we do any more
				{
					if (cbHeaders < sizeof (IDirect3DTexture8))
					{
						TRACE(_T("Invalid XBX image file (wrong header size; is %d should be %d)!\n"), cbHeaders, sizeof (IDirect3DTexture8));
						return NULL;
					}

					D3DResource* pResource = (D3DResource*)(pbContent + sizeof (XPR_HEADER));
					if ((pResource->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_TEXTURE)
					{
						TRACE(_T("Invalid XBX image file (not a texture)!\n"));
						return NULL;
					}

					if (cbData <= 0 || (UINT)cbContent < pxprh->dwHeaderSize + cbData)
					{
						TRACE(_T("Invalid XBX image file! (wrong data size)\n"));
						return NULL;
					}

                    if (width != 0 && height != 0)
                    {
                        DWORD dwU, dwV;
                        DWORD dwInfo = *((DWORD*)pbContent + 6);
                        const DWORD exptbl[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,0,0,0,0,0,0};

                        dwU = exptbl[(dwInfo & D3DFORMAT_USIZE_MASK) >> D3DFORMAT_USIZE_SHIFT];
                        dwV = exptbl[(dwInfo & D3DFORMAT_VSIZE_MASK) >> D3DFORMAT_VSIZE_SHIFT];

                        if (dwU != width || dwV != height)
                        {
    						TRACE(_T("\001Invalid XBX image size! (not %dx%d)\n"), width, height);
    						return NULL;
                        }
                    }
                }

				IDirect3DTexture8* pTexture = (IDirect3DTexture8*)XAppD3D_AllocNoncontiguousMemory(sizeof (D3DBaseTexture));
				if (pTexture == NULL)
				{
					TRACE(_T("Not enough memory to load XBX image file!\n"));
					return NULL;
				}

				CopyMemory(pTexture, pbContent + sizeof (XPR_HEADER), sizeof (IDirect3DTexture8));

				BYTE* pbData = (BYTE*)XAppD3D_AllocContiguousMemory(cbData, D3DTEXTURE_ALIGNMENT);
				if (pbData == NULL)
				{
					// TODO: Leaking pTexture!
					TRACE(_T("Not enough memory to load XBX image file!\n"));
					return NULL;
				}

				CopyMemory(pbData, pbContent + pxprh->dwHeaderSize, cbData);
				D3D_CopyContiguousMemoryToVideo(pbData);

				pTexture->Data = NULL;
				pTexture->Register(pbData);
				pTexture->Common |= D3DCOMMON_D3DCREATED;

				return pTexture;
			}
		}
	}

	TRACE(_T("\002Texture '%s' needs to be converted to an Xbox friendly format!\n"), szURL);
#endif

	for (;;)
	{
		LPDIRECT3DTEXTURE8 lpTexture = NULL;
		HRESULT hr = D3DXCreateTextureFromFileInMemoryEx(XAppGetD3DDev(), pbContent, cbContent, D3DX_DEFAULT, D3DX_DEFAULT, 1, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, &lpTexture);
		if (hr == D3D_OK)
			return lpTexture;

		if (hr != E_OUTOFMEMORY || NewFailed(cbContent) == 0)
			break;
	}

	return NULL;
}

LPDIRECT3DTEXTURE8 LoadTexture(const TCHAR* szURL, UINT width, UINT height)
{
//#ifdef _DEBUG
//	TRACE(_T("Loading texture image: \"%s\"\n"), szURL);
//	int nStartTime = GetTickCount();
//#endif
	// Look for an XBX file
	{
		TCHAR szBuf [MAX_PATH];
		MakeAbsoluteURL(szBuf, szURL);

		TCHAR* pch = _tcsrchr(szBuf, '.');
		if (pch != NULL)
		{
#ifdef COOL_XDASH
			_tcscpy(pch + 1, _T("xbx.cool"));
#else
			_tcscpy(pch + 1, _T("xbx"));
#endif

			LPDIRECT3DTEXTURE8 lpTexture = (LPDIRECT3DTEXTURE8)FindObjectInXIP(szBuf, szURL, XIP_TYPE_TEXTURE);
			if (lpTexture != NULL)
				return lpTexture;

			TRACE(_T("\002Cannot find %s in a XIP!\n"), szBuf);
		}
	}

	/*
	CActiveFile file;
	if (!file.Fetch(szURL, true))
		return NULL;

	LPDIRECT3DTEXTURE8 lpTexture = ParseTexture(szURL, file.GetContent(), file.GetContentLength(), width, height);
	*/

	ALERT(_T("Unable to load XBX file (%s) for scene!"), szURL);

	//#ifdef _DEBUG
	//	TRACE(_T("%s took %d mS to load\n"), szURL, GetTickCount() - nStartTime);
	//#endif

	return NULL;
}

/*
bool CreateTextureFromFile(const TCHAR* szFileName, CTexture* pTexture)
{
	const TCHAR* pch = _tcsrchr(szFileName, '.');

	if (pch == NULL)
		return false;

	if (_tcsicmp(pch, _T(".raw")) == 0)
		return DecodeRAW(szFileName, pTexture);

	CActiveFile file;

	if (!file.Fetch(szFileName, true))
		return false;

	if (D3DXCreateTextureFromFileInMemoryEx(XAppGetD3DDev(), file.GetContent(), file.GetContentLength(), D3DX_DEFAULT, D3DX_DEFAULT, 1, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, &pTexture->m_pSurface) == D3D_OK)
		return true;

	TRACE(_T("\001Could not load texture: \"%s\"\n"), szFileName);

	return false;
}
*/

////////////////////////////////////////////////////////////////////////////

HIMAGE MyLoadImage(const TCHAR* szURL);

struct IMGCACHE
{
	TCHAR* m_szURL;
	HIMAGE m_hImage;
	SIZE m_size;
	XTIME m_usage;
};

static IMGCACHE imageCache [100];
static IMGCACHE* pImgLock;

void CleanupImageCache()
{
	for (int i = 0; i < countof(imageCache); i += 1)
	{
		IMGCACHE* pImg = &imageCache[i];
		if (pImg == pImgLock)
			continue;

		delete [] pImg->m_szURL;

#ifdef _USEGDI
		if (pImg->m_hImage != NULL)
			DeleteObject(pImg->m_hImage);
#endif
#ifdef _XBOX
		if (pImg->m_hImage != NULL)
			pImg->m_hImage->Release();
#endif

		ZeroMemory(pImg, sizeof (IMGCACHE));
	}
}

IMGCACHE* FindImage(const TCHAR* szURL)
{
	IMGCACHE* pFreeOne = NULL;
	IMGCACHE* pOldOne = NULL;
	for (int i = 0; i < countof(imageCache); i += 1)
	{
		if (imageCache[i].m_szURL != NULL && _tcsicmp(imageCache[i].m_szURL, szURL) == 0)
		{
//			TRACE(_T("Found %s in image cache\n"), szURL);
			imageCache[i].m_usage = XAppGetNow();
			return &imageCache[i];
		}

		if (pFreeOne != NULL)
			continue;

		if (imageCache[i].m_szURL == NULL)
			pFreeOne = &imageCache[i];
		else if (pOldOne == NULL || pOldOne->m_usage > imageCache[i].m_usage)
			pOldOne = &imageCache[i];
	}

	if (pFreeOne == NULL && pOldOne != NULL)
	{
		TRACE(_T("Unloading %s from image cache\n"), pOldOne->m_szURL);
		delete [] pOldOne->m_szURL;

#ifdef _USEGDI
		if (pOldOne->m_hImage != NULL)
			DeleteObject(pOldOne->m_hImage);
#endif
#ifdef _XBOX
		if (pOldOne->m_hImage != NULL)
			pOldOne->m_hImage->Release();
#endif

		ZeroMemory(pOldOne, sizeof (IMGCACHE));
		pFreeOne = pOldOne;
	}

	ASSERT(pFreeOne != NULL);

	TRACE(_T("Loading %s into image cache...\n"), szURL);

	ASSERT(pImgLock == NULL);
	pImgLock = pFreeOne;

	pFreeOne->m_szURL = new TCHAR [_tcslen(szURL) + 1];
	_tcscpy(pFreeOne->m_szURL, szURL);

	pFreeOne->m_usage = XAppGetNow();

	pFreeOne->m_hImage = MyLoadImage(szURL);
	
	if (pFreeOne->m_hImage != NULL)
	{
#ifdef _USEGDI
		BITMAP bitmap;
		GetObject(pFreeOne->m_hImage, sizeof (BITMAP), &bitmap);
		pFreeOne->m_size.cx = bitmap.bmWidth;
		pFreeOne->m_size.cy = bitmap.bmHeight;
#endif
#ifdef _XBOX
		D3DSURFACE_DESC sd;
		VERIFYHR(pFreeOne->m_hImage->GetLevelDesc(0, &sd));
		pFreeOne->m_size.cx = (int)sd.Width;
		pFreeOne->m_size.cy = (int)sd.Height;
#endif
	}

	pImgLock = NULL;

	return pFreeOne;
}


extern "C" // this one is used by the RenderHTML C-code...
HIMAGE FetchImage(const TCHAR* szURL, SIZE* pSize)
{
	IMGCACHE* pImgCache = FindImage(szURL);
	if (pImgCache == NULL)
		return NULL;

	if (pSize != NULL)
		*pSize = pImgCache->m_size;

	return pImgCache->m_hImage;
}

HIMAGE MyLoadImage(const TCHAR* szURL)
{
	return LoadTexture(szURL, 0, 0);
}

////////////////////////////////////////////////////////////////////////////

bool DecodeRAW(const TCHAR* szFileName, CTexture* pTexture)
{
	FILE* fp = _tfopen(szFileName, _T("rb"));
	if (fp == NULL)
		return false;

	fseek(fp, 0, SEEK_END);
	DWORD dwFileSize = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	int nWidth = 0;
	int nHeight = 0;
	int nDepth = 0;

	if (dwFileSize == 1024 * 1024 * 3)
	{
		nWidth = 1024;
		nHeight = 1024;
		nDepth = 24;
	}

	if (nWidth == 0 || nHeight == 0 || nDepth == 0)
	{
		fclose(fp);
		return false;
	}

	if (!pTexture->Create(nWidth, nHeight))
	{
		TRACE(_T("Create texture failed!\n"));
		fclose(fp);
		return false;
	}

/*
	D3DX_SURFACEFORMAT sf = D3DX_SF_R8G8B8;
	DWORD nMipMaps = 0;
	DWORD dwWidth = nWidth;
	DWORD dwHeight = nHeight;
	DWORD dwFlags = DDSD_CKSRCBLT;
	if (FAILED(D3DXCreateTexture(XAppGetD3DDev(), &dwFlags, &dwWidth, &dwHeight, &sf, NULL, &pSurface, &nMipMaps)))
	{
		TRACE(_T("Create texture failed!\n"));
		fclose(fp);
		return false;
	}

	ASSERT(sf == D3DX_SF_A8R8G8B8 || sf == D3DX_SF_X8R8G8B8);
*/

	D3DLOCKED_RECT lr;
	VERIFYHR(pTexture->m_pSurface->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));
	void* pvPels = lr.pBits;
	int nPitch = lr.Pitch;

	BYTE* rgbsrc = new BYTE [nWidth * (nDepth / 8)];

	for (int y = 0; y < nHeight; y += 1)
	{
		fread(rgbsrc, 1, nWidth * (nDepth / 8), fp);

		BYTE* pbSrc = rgbsrc;
		BYTE* pbDest = (BYTE*)pvPels + y * nPitch;

		for (int x = 0; x < nWidth; x += 1)
		{
			pbDest[0] = pbSrc[2];
			pbDest[1] = pbSrc[1];
			pbDest[2] = pbSrc[0];
			pbDest[3] = 255;

			pbDest += 4;
			pbSrc += 3;
		}
	}

	delete [] rgbsrc;

	pTexture->m_pSurface->UnlockRect(0);

	fclose(fp);

	return true;
}




////////////////////////////////////////////////////////////////////////////

EXTERN_C BOOL GetImageSize(const TCHAR* szImgFile, SIZE* pSize)
{
	return FetchImage(szImgFile, pSize) != NULL;
}

EXTERN_C void DrawImage(HDRAW hDC, const TCHAR* szImgFile, int x, int y, int align, WORD* pcx, WORD* pcy)
{
	HIMAGE hImage;
	SIZE size;

	hImage = FetchImage(szImgFile, &size);

	if (hImage != NULL)
	{
		if ((align & TA_RIGHT) != 0)
			x -= size.cx;

		if ((align & TA_BOTTOM) != 0)
			y -= size.cy;

#ifdef _USEGDI
		HDRAW hImageDC = CreateCompatibleDC(hDC);
		if (hImageDC != NULL)
		{
			HGDIOBJ hOldBitmap = SelectObject(hImageDC, hImage);
			BitBlt(hDC, x, y, size.cx, size.cy, hImageDC, 0, 0, SRCCOPY);
			SelectObject(hImageDC, hOldBitmap);
			DeleteDC(hImageDC);
		}
#endif
#ifdef _XBOX
		X_BitBlt(hDC, x, y, size.cx, size.cy, hImage, 0, 0);
#endif
	}
	else
	{
		size.cx = 20;
		size.cy = 20;
	}

	if (pcx != NULL)
		*pcx = (WORD)size.cx;

	if (pcy != NULL)
		*pcy = (WORD)size.cy;
}

////////////////////////////////////////////////////////////////////////////

#ifndef _USEGDI
static bool Clip(HDRAW hDraw/*LPDIRECT3DSURFACE8 pSurface*/, int& x, int& y, int& cx, int& cy)
{
	ASSERT(hDraw != NULL);
//	ASSERT(pSurface != NULL);

//	D3DSURFACE_DESC desc;
//	VERIFYHR(pSurface->GetDesc(&desc));

	if (x < 0)
	{
		cx += x;
		x = 0;
	}

	if (y < 0)
	{
		cy += y;
		y = 0;
	}

	if (x + cx > (int)hDraw->Desc/*desc*/.Width)
		cx = (int)hDraw->Desc/*desc*/.Width - x;

	if (y + cy > (int)hDraw->Desc/*desc*/.Height)
		cy = (int)hDraw->Desc/*desc*/.Height - y;

	if (cx <= 0 || cy <= 0)
		return false;

	return true;
}

EXTERN_C HRESULT X_FillRect(HDRAW hDraw, int x, int y, int cx, int cy, D3DCOLOR color)
{
	ASSERT(hDraw != NULL);
//	ASSERT(pSurface != NULL);

//	TRACE(_T("X_FillRect: %d,%d %dx%d\n"), x, y, cx, cy);

#ifdef _DEBUG
	{
//		D3DSURFACE_DESC desc;
//		VERIFYHR(pSurface->GetDesc(&desc));
		ASSERT(hDraw->Desc/*desc*/.Format == D3DFMT_A8R8G8B8 || hDraw->Desc/*desc*/.Format == D3DFMT_X8R8G8B8);
	}
#endif

	if (!Clip(hDraw/*pSurface*/, x, y, cx, cy))
		return S_OK;

//	TRACE(_T("clipped to: %d,%d %dx%d\n"), x, y, cx, cy);

//    D3DLOCKED_RECT lock;
//	HRESULT hr = pSurface->LockRect(&lock, NULL, 0);
//	if (FAILED(hr))
//		return hr;

	for (int j = 0; j < cy; j += 1)
	{
		DWORD* ppel = (DWORD*)((BYTE*)hDraw->Lock/*lock*/.pBits + hDraw->Lock/*lock*/.Pitch * (y + j)) + x;
		for (int i = 0; i < cx; i += 1)
			*ppel++ = color;
	}

//	pSurface->UnlockRect();

	return S_OK;
}


EXTERN_C HRESULT X_BitBlt(HDRAW hDraw, int x, int y, int cx, int cy, LPDIRECT3DTEXTURE8 pSrcSurface, int xSrc, int ySrc)
{
	ASSERT(hDraw != NULL);
	ASSERT(pSrcSurface != NULL);

#ifdef _DEBUG
	{
		D3DSURFACE_DESC descSrc;

		VERIFYHR(pSrcSurface->GetLevelDesc(0, &descSrc));

		ASSERT(hDraw->Desc.Format == D3DFMT_A8R8G8B8 || hDraw->Desc.Format == D3DFMT_X8R8G8B8);
		ASSERT(hDraw->Desc.Format == descSrc.Format);
	}
#endif

	// REVIEW: This doesn't clip against the source size...

	if (!Clip(hDraw, x, y, cx, cy))
		return S_OK;

    D3DLOCKED_RECT lockSrc;
	HRESULT hr = pSrcSurface->LockRect(0, &lockSrc, NULL, D3DLOCK_READONLY);
	if (FAILED(hr))
		return hr;

	for (int j = 0; j < cy; j += 1)
	{
		DWORD* ppel = (DWORD*)((BYTE*)hDraw->Lock.pBits + hDraw->Lock.Pitch * (y + j)) + x;
		DWORD* ppelSrc = (DWORD*)((BYTE*)lockSrc.pBits + lockSrc.Pitch * (ySrc + j)) + xSrc;

		for (int i = 0; i < cx; i += 1)
			*ppel++ = *ppelSrc++;
	}

	pSrcSurface->UnlockRect(0);

	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Interpolator.h ===
#pragma once

class CPositionInterpolator : public CNode
{
	DECLARE_NODE(CPositionInterpolator, CNode)
public:
	CPositionInterpolator();
	~CPositionInterpolator();

	CNumArray m_key;
	CVec3Array m_keyValue;

	D3DXVECTOR3 Interpolate(float key);

	DECLARE_NODE_PROPS()
};

class COrientationInterpolator : public CNode
{
	DECLARE_NODE(COrientationInterpolator, CNode)
public:
	COrientationInterpolator();
	~COrientationInterpolator();

	CNumArray m_key;
	CVec4Array m_keyValue;

	D3DXQUATERNION Interpolate(float key);
	void OnLoad();

	DECLARE_NODE_PROPS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\interpolator.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Interpolator.h"

IMPLEMENT_NODE("PositionInterpolator", CPositionInterpolator, CNode)

START_NODE_PROPS(CPositionInterpolator, CNode)
	NODE_PROP(pt_numarray, CPositionInterpolator, key)
	NODE_PROP(pt_vec3array, CPositionInterpolator, keyValue)
END_NODE_PROPS()

CPositionInterpolator::CPositionInterpolator()
{
}

CPositionInterpolator::~CPositionInterpolator()
{
}

D3DXVECTOR3 CPositionInterpolator::Interpolate(float key)
{
	D3DXVECTOR3 v;

//	if (m_key.m_nSize == 0)
	{
		ASSERT(m_keyValue.m_nSize > 0);

		float k = key * (m_keyValue.m_nSize - 1);
		int i = (int)floorf(k);
		float f = k - floorf(k);

		if (i < 0)
			return m_keyValue.m_value[0];
		
		if (i >= m_keyValue.m_nSize - 1)
			return m_keyValue.m_value[m_keyValue.m_nSize - 1];

		if (i > 0 && i < m_keyValue.m_nSize - 2 && m_keyValue.m_nSize >= 4)
		{
			D3DXVec3CatmullRom(&v, &m_keyValue.m_value[i - 1], &m_keyValue.m_value[i], &m_keyValue.m_value[i + 1], &m_keyValue.m_value[i + 2], f);
			return v;
		}

		D3DXVec3Lerp(&v, &m_keyValue.m_value[i], &m_keyValue.m_value[i + 1], f);
		return v;
	}
//	else
//	{
//		D3DXVECTOR3 v;
//		ASSERT(FALSE); // NYI!
//		return v;
//	}
}

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("OrientationInterpolator", COrientationInterpolator, CNode)

START_NODE_PROPS(COrientationInterpolator, CNode)
	NODE_PROP(pt_numarray, COrientationInterpolator, key)
	NODE_PROP(pt_vec4array, COrientationInterpolator, keyValue)
END_NODE_PROPS()

COrientationInterpolator::COrientationInterpolator()
{
}

COrientationInterpolator::~COrientationInterpolator()
{
}

void COrientationInterpolator::OnLoad()
{
	CNode::OnLoad();

	for (int i = 0; i < m_keyValue.m_nSize; i += 1)
	{
		D3DXQUATERNION q;
		D3DXQuaternionRotationAxis(&q, (D3DXVECTOR3*)&m_keyValue.m_value[i], -m_keyValue.m_value[i].w);
		*((D3DXQUATERNION*)&m_keyValue.m_value[i]) = q;
	}
}

D3DXQUATERNION COrientationInterpolator::Interpolate(float key)
{
	D3DXQUATERNION v;

//	if (m_key.m_nSize == 0)
	{
		ASSERT(m_keyValue.m_nSize > 0);

		float k = key * (m_keyValue.m_nSize - 1);
		int i = (int)floorf(k);
		float f = k - floorf(k);

		if (i < 0)
			return *((D3DXQUATERNION*)&m_keyValue.m_value[0]);

		if (i >= m_keyValue.m_nSize - 1)
			return *((D3DXQUATERNION*)&m_keyValue.m_value[m_keyValue.m_nSize - 1]);
/*
		if (i > 0 && i < m_keyValue.m_nSize - 2 && m_keyValue.m_nSize >= 4)
		{
			D3DXQuaternionSquad(&v, (D3DXQUATERNION*)&m_keyValue.m_value[i - 1], (D3DXQUATERNION*)&m_keyValue.m_value[i], (D3DXQUATERNION*)&m_keyValue.m_value[i + 1], (D3DXQUATERNION*)&m_keyValue.m_value[i + 2], f);
			return v;
		}
*/
		D3DXQuaternionSlerp(&v, (D3DXQUATERNION*)&m_keyValue.m_value[i], (D3DXQUATERNION*)&m_keyValue.m_value[i + 1], f);
		return v;
	}
//	else
//	{
//		D3DXVECTOR4 v;
//		ASSERT(FALSE); // NYI!
//		return v;
//	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ISO639.cpp ===
#include "std.h"

#define MKLANG(c, d)	(((WORD)c << 8) | (WORD)d)

struct ISO639
{
	WORD wCode;
	TCHAR* szLanguage;
};

static const ISO639 languages [] =
{
	{ MKLANG('a','b'), _T("Abkhazian") },
	{ MKLANG('o','m'), _T("Afan (Oromo)") },
	{ MKLANG('a','a'), _T("Afar") },
	{ MKLANG('a','f'), _T("Afrikaans") },
	{ MKLANG('s','q'), _T("Albanian") },
	{ MKLANG('a','m'), _T("Amharic") },
	{ MKLANG('a','r'), _T("Arabic") },
	{ MKLANG('h','y'), _T("Armenian") },
	{ MKLANG('a','s'), _T("Assamese") },
	{ MKLANG('a','y'), _T("Aymara") },
	{ MKLANG('a','z'), _T("Azerbaijani") },
	{ MKLANG('b','a'), _T("Bashkir") },
	{ MKLANG('e','u'), _T("Basque") },
	{ MKLANG('b','n'), _T("Bengali") },
	{ MKLANG('d','z'), _T("Bhutani") },
	{ MKLANG('b','h'), _T("Bihari") },
	{ MKLANG('b','i'), _T("Bislama") },
	{ MKLANG('b','r'), _T("Breton") },
	{ MKLANG('b','g'), _T("Bulgarian") },
	{ MKLANG('m','y'), _T("Burmese") },
	{ MKLANG('b','e'), _T("Byelorussian") },
	{ MKLANG('k','m'), _T("Cambodian") },
	{ MKLANG('c','a'), _T("Catalan") },
	{ MKLANG('z','h'), _T("Chinese") },
	{ MKLANG('c','o'), _T("Corsican") },
	{ MKLANG('h','r'), _T("Croatian") },
	{ MKLANG('c','s'), _T("Czech") },
	{ MKLANG('d','a'), _T("Danish") },
	{ MKLANG('n','l'), _T("Dutch") },
	{ MKLANG('e','n'), _T("English") },
	{ MKLANG('e','o'), _T("Esperanto") },
	{ MKLANG('e','t'), _T("Estonian") },
	{ MKLANG('f','o'), _T("Faroese") },
	{ MKLANG('f','j'), _T("Fiji") },
	{ MKLANG('f','i'), _T("Finnish") },
	{ MKLANG('f','r'), _T("French") },
	{ MKLANG('f','y'), _T("Frisian") },
	{ MKLANG('g','l'), _T("Galician") },
	{ MKLANG('k','a'), _T("Georgian") },
	{ MKLANG('d','e'), _T("German") },
	{ MKLANG('e','l'), _T("Greek") },
	{ MKLANG('k','l'), _T("Greenlandic") },
	{ MKLANG('g','n'), _T("Guarani") },
	{ MKLANG('g','u'), _T("Gujarati") },
	{ MKLANG('h','a'), _T("Hausa") },
	{ MKLANG('h','e'), _T("Hebrew") },
	{ MKLANG('h','i'), _T("Hindi") },
	{ MKLANG('h','u'), _T("Hungarian") },
	{ MKLANG('i','s'), _T("Icelandic") },
	{ MKLANG('i','d'), _T("Indonesian") },
	{ MKLANG('i','a'), _T("Interlingua") },
	{ MKLANG('i','e'), _T("Interlingue") },
	{ MKLANG('i','u'), _T("Inuktitut") },
	{ MKLANG('i','k'), _T("Inupiak") },
	{ MKLANG('g','a'), _T("Irish") },
	{ MKLANG('i','t'), _T("Italian") },
	{ MKLANG('j','a'), _T("Japanese") },
	{ MKLANG('j','v'), _T("Javanese") },
	{ MKLANG('k','n'), _T("Kannada") },
	{ MKLANG('k','s'), _T("Kashmiri") },
	{ MKLANG('k','k'), _T("Kazakh") },
	{ MKLANG('r','w'), _T("Kinyarwanda") },
	{ MKLANG('k','y'), _T("Kirghiz") },
	{ MKLANG('r','n'), _T("Kurundi") },
	{ MKLANG('k','o'), _T("Korean") },
	{ MKLANG('k','u'), _T("Kurdish") },
	{ MKLANG('l','o'), _T("Laothian") },
	{ MKLANG('l','a'), _T("Latin") },
	{ MKLANG('l','v'), _T("Latvian") },
	{ MKLANG('l','n'), _T("Lingala") },
	{ MKLANG('l','t'), _T("Lithuanian") },
	{ MKLANG('m','k'), _T("Macedonian") },
	{ MKLANG('m','g'), _T("Malagasy") },
	{ MKLANG('m','s'), _T("Malay") },
	{ MKLANG('m','l'), _T("Malayalam") },
	{ MKLANG('m','t'), _T("Maltese") },
	{ MKLANG('m','i'), _T("Maori") },
	{ MKLANG('m','r'), _T("Marathi") },
	{ MKLANG('m','o'), _T("Moldavian") },
	{ MKLANG('m','n'), _T("Mongolian") },
	{ MKLANG('n','a'), _T("Nauru") },
	{ MKLANG('n','e'), _T("Nepali") },
	{ MKLANG('n','o'), _T("Norwegian") },
	{ MKLANG('o','c'), _T("Occitan") },
	{ MKLANG('o','r'), _T("Oriya") },
	{ MKLANG('p','s'), _T("Pashto") },
	{ MKLANG('f','a'), _T("Persian") },
	{ MKLANG('p','l'), _T("Polish") },
	{ MKLANG('p','t'), _T("Portuguese") },
	{ MKLANG('p','a'), _T("Punjabi") },
	{ MKLANG('q','u'), _T("Quechua") },
	{ MKLANG('r','m'), _T("Rhaeto-Romance") },
	{ MKLANG('r','o'), _T("Romanian") },
	{ MKLANG('r','u'), _T("Russian") },
	{ MKLANG('s','m'), _T("Samoan") },
	{ MKLANG('s','g'), _T("Sangho") },
	{ MKLANG('s','a'), _T("Sanskrit") },
	{ MKLANG('g','d'), _T("Scots Gaelic") },
	{ MKLANG('s','r'), _T("Serbian") },
	{ MKLANG('s','h'), _T("Serbo-Croatian") },
	{ MKLANG('s','t'), _T("Sesotho") },
	{ MKLANG('t','n'), _T("Setswana") },
	{ MKLANG('s','n'), _T("Shona") },
	{ MKLANG('s','d'), _T("Sindhi") },
	{ MKLANG('s','i'), _T("Singhalese") },
	{ MKLANG('s','s'), _T("Siswati") },
	{ MKLANG('s','k'), _T("Slovak") },
	{ MKLANG('s','l'), _T("Slovenian") },
	{ MKLANG('s','o'), _T("Somali") },
	{ MKLANG('e','s'), _T("Spanish") },
	{ MKLANG('s','u'), _T("Sundanese") },
	{ MKLANG('s','w'), _T("Swahili") },
	{ MKLANG('s','v'), _T("Swedish") },
	{ MKLANG('t','l'), _T("Tagalog") },
	{ MKLANG('t','g'), _T("Tajik") },
	{ MKLANG('t','a'), _T("Tamil") },
	{ MKLANG('t','t'), _T("Tatar") },
	{ MKLANG('t','e'), _T("Telugu") },
	{ MKLANG('t','h'), _T("Thai") },
	{ MKLANG('b','o'), _T("Tibetan") },
	{ MKLANG('t','i'), _T("Tigrinya") },
	{ MKLANG('t','o'), _T("Tonga") },
	{ MKLANG('t','s'), _T("Tsonga") },
	{ MKLANG('t','r'), _T("Turkish") },
	{ MKLANG('t','k'), _T("Turkmen") },
	{ MKLANG('t','w'), _T("Twi") },
	{ MKLANG('u','g'), _T("Uigur") },
	{ MKLANG('u','k'), _T("Ukrainian") },
	{ MKLANG('u','r'), _T("Urdu") },
	{ MKLANG('u','z'), _T("Uzbek") },
	{ MKLANG('v','i'), _T("Vietnamese") },
	{ MKLANG('v','o'), _T("Volapuk") },
	{ MKLANG('c','y'), _T("Welsh") },
	{ MKLANG('w','o'), _T("Wolof") },
	{ MKLANG('x','h'), _T("Xhosa") },
	{ MKLANG('y','i'), _T("Yiddish") },
	{ MKLANG('y','o'), _T("Yoruba") },
	{ MKLANG('z','a'), _T("Zhuang") },
	{ MKLANG('z','u'), _T("Zulu") }
};

const TCHAR* LanguageNameFromCode(WORD code)
{
	for (int i = 0; i < countof (languages); i += 1)
	{
		if (code == languages[i].wCode)
			return languages[i].szLanguage;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\lerper.cpp ===
#include "std.h"
#include "xapp.h"
#include "Lerper.h"

CLerper* CLerper::c_pHead;

CLerper::CLerper(CObject* pObject, float* pValue, float nNewValue, float nInterval)
{
	ASSERT(pObject != NULL);
	ASSERT(pValue != NULL);
	ASSERT(nInterval != 0.0f);

	m_pObject = pObject;
	m_interval = nInterval;
	m_startTime = XAppGetNow();
	m_startValue = *pValue;
	m_endValue = nNewValue;
	m_pValue = pValue;

	m_pNext = c_pHead;
	c_pHead = this;
}

bool CLerper::Advance()
{
	float t = (float) (XAppGetNow() - m_startTime) / m_interval;

	if (t >= 1.0f)
	{
		*m_pValue = m_endValue;
		return false;
	}

	float t1 = 1.0f - t;

	*m_pValue = t1 * m_startValue + t * m_endValue;

	return true;
}

void CLerper::AdvanceAll()
{
	for (CLerper** ppLerper = &c_pHead; *ppLerper != NULL; )
	{
		CLerper* pLerper = *ppLerper;
		if (!pLerper->Advance())
		{
			*ppLerper = pLerper->m_pNext;
			delete pLerper;
		}
		else
		{
			ppLerper = &pLerper->m_pNext;
		}
	}
}

void CLerper::RemoveObject(CObject* pObject)
{
	for (CLerper** ppLerper = &c_pHead; *ppLerper != NULL; )
	{
		CLerper* pLerper = *ppLerper;
		if (pLerper->m_pObject == pObject)
		{
			*ppLerper = pLerper->m_pNext;
			delete pLerper;
		}
		else
		{
			ppLerper = &pLerper->m_pNext;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\lerper.h ===
#pragma once

class CLerper
{
public:
	CLerper(CObject* pObject, float* pValue, float nNewValue, float nInterval);

	float m_interval;
	XTIME m_startTime;
	float m_startValue;
	float m_endValue;
	float* m_pValue;
	CObject* m_pObject;

	bool Advance();

	static void RemoveObject(CObject* pObject);
	static void AdvanceAll();
	static CLerper* c_pHead;
	CLerper* m_pNext;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Joystick.cpp ===
/*
	TODO: Update for "real" xbox controller...

		2 2-axis joysticks
		2 buttons in joysticks
		"D-Pad"
		analog buttons
		digital buttons
*/

#include "std.h"
#include "xapp.h"
#include "node.h"

#define REPEAT_DELAY	0.3f
#define REPEAT_INTERVAL 0.12f

#define KS_BEGIN        0x0001
#define KS_VERIFIED     0x0002
#define KS_END          0x0004

float g_xaxis, g_yaxis;

#ifdef _DEBUG
extern bool g_bWireframe;
extern bool g_bDumpMemState;
extern void CycleLanguage();
#endif

bool g_bInputEnable;

class CJoystick : public CNode
{
	DECLARE_NODE(CJoystick, CNode)

public:
	CJoystick();
	~CJoystick();

	bool m_bNeedsInit;

	bool m_isBound;
	float m_frequency;

	float m_hat;
	
	float m_xaxis;
	float m_yaxis;

	float m_xaxis2;
	float m_yaxis2;

	float m_a;
	float m_b;
	float m_x;
	float m_y;
	float m_black;
	float m_white;
	float m_left;
	float m_right;
	float m_leftThumb;
	float m_rightThumb;
	float m_start;
	float m_back;

    TCHAR* m_secretKey;
    size_t m_secretKeyLength;
    size_t m_secretKeyCurrentIndex;
    bool   m_enableSecretKey;
    bool   m_eatSecretKey;

    bool   m_enableRemote;
    bool   m_enableGamepad;

	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	void Bind();

	bool CheckDevice();
	bool OpenDevice();

    void EnableGlobalInput(int bEnable);

	void CallFunction(const TCHAR* szFunc, bool bRemote = false);

	static HANDLE c_hDevices [4];
	static PXPP_DEVICE_TYPE c_devtype [4];

	static CJoystick* c_pPreviousBoundJoystick;
	static CJoystick* c_pBoundJoystick;

	XINPUT_STATE_INTERNAL m_joystate [4];
	XTIME m_nextRepeatTime [4];
	float m_repeatInterval [4];
    float m_remoteIdleTime;
    DWORD m_remoteRepeatCount;

	XTIME m_timeNextUpdate;
    XTIME m_timeRemoteRemoved;
    bool  m_bRemoveRemoteCalled;

	DECLARE_NODE_PROPS()
    DECLARE_NODE_FUNCTIONS()

protected:
    int CheckSecretKeySequence(TCHAR key);
    void ProcessSecretKeySequence(int flags);
};

HANDLE CJoystick::c_hDevices [4];
PXPP_DEVICE_TYPE CJoystick::c_devtype [4];

CJoystick* CJoystick::c_pBoundJoystick = NULL;
CJoystick* CJoystick::c_pPreviousBoundJoystick = NULL;

IMPLEMENT_NODE("Joystick", CJoystick, CNode)

START_NODE_PROPS(CJoystick, CNode)
	NODE_PROP(pt_boolean, CJoystick, isBound)
	NODE_PROP(pt_number, CJoystick, frequency)
	NODE_PROP(pt_number, CJoystick, hat)
	NODE_PROP(pt_number, CJoystick, xaxis)
	NODE_PROP(pt_number, CJoystick, yaxis)
	NODE_PROP(pt_number, CJoystick, xaxis2)
	NODE_PROP(pt_number, CJoystick, yaxis2)
	NODE_PROP(pt_number, CJoystick, a)
	NODE_PROP(pt_number, CJoystick, b)
	NODE_PROP(pt_number, CJoystick, x)
	NODE_PROP(pt_number, CJoystick, y)
	NODE_PROP(pt_number, CJoystick, black)
	NODE_PROP(pt_number, CJoystick, white)
	NODE_PROP(pt_number, CJoystick, left)
	NODE_PROP(pt_number, CJoystick, right)
	NODE_PROP(pt_number, CJoystick, leftThumb)
	NODE_PROP(pt_number, CJoystick, rightThumb)
	NODE_PROP(pt_number, CJoystick, start)
	NODE_PROP(pt_number, CJoystick, back)
	NODE_PROP(pt_string, CJoystick, secretKey)
	NODE_PROP(pt_boolean, CJoystick, enableSecretKey)
	NODE_PROP(pt_boolean, CJoystick, enableGamepad)
	NODE_PROP(pt_boolean, CJoystick, enableRemote)
END_NODE_PROPS()

START_NODE_FUN(CJoystick, CNode)
    NODE_FUN_VI(EnableGlobalInput)
END_NODE_FUN()

CJoystick::CJoystick() :
	m_frequency(20.0f),
	m_hat(-1.0f),
	m_xaxis(0.0f),
	m_yaxis(0.0f),
	m_xaxis2(0.0f),
	m_yaxis2(0.0f),
	m_a(0.0f),
	m_b(0.0f),
	m_x(0.0f),
	m_y(0.0f),
	m_black(0.0f),
	m_white(0.0f),
	m_left(0.0f),
	m_right(0.0f),
	m_leftThumb(0.0f),
	m_rightThumb(0.0f),
	m_start(0.0f),
	m_back(0.0f),
    m_secretKey(NULL),
    m_secretKeyLength(0),
    m_secretKeyCurrentIndex(0),
    m_enableSecretKey(false),
    m_eatSecretKey(false),
    m_enableRemote(true),
    m_enableGamepad(true),
	m_isBound(false),
    m_remoteIdleTime(0.0f),
    m_timeRemoteRemoved(0.0f),
    m_bRemoveRemoteCalled(false),
    m_remoteRepeatCount(0)
{
	m_bNeedsInit = true;

	for (int i = 0; i < 4; i += 1)
	{
		m_nextRepeatTime[i] = 0.0f;
		m_repeatInterval[i] = 0.0f;
	}

	if (c_pBoundJoystick == NULL)
		Bind();
}

CJoystick::~CJoystick()
{
	if (c_pPreviousBoundJoystick == this)
		c_pPreviousBoundJoystick = NULL;

	if (c_pBoundJoystick == this)
		c_pBoundJoystick = c_pPreviousBoundJoystick;

    delete [] m_secretKey;
}

void CJoystick::CallFunction(const TCHAR* szFunc, bool bRemote /* = false */)
{
	if (c_pBoundJoystick == this)
    {
        if (bRemote && !m_enableRemote)
        {
            TRACE(_T("Ignoring input from remote\n"));
            return;
        }
        if (!bRemote && !m_enableGamepad)
        {
            TRACE(_T("Ignoring input from gamepad\n"));
            return;
        }
        ::CallFunction(this, szFunc);
    }
}

void BindJoystick(CNode* pJoystickNode)
{
	if (pJoystickNode == NULL)
	{
		CJoystick::c_pBoundJoystick = NULL;
		CJoystick::c_pPreviousBoundJoystick = NULL;
		return;
	}
	
	if (!pJoystickNode->IsKindOf(NODE_CLASS(CJoystick)))
		return;

	((CJoystick*)pJoystickNode)->Bind();
}

void CJoystick::Bind()
{
	c_pPreviousBoundJoystick = c_pBoundJoystick;
	c_pBoundJoystick = this;

	if (!m_bNeedsInit)
	{
		CheckDevice();
		for (int i = 0; i < 4; i += 1)
		{
			if (c_hDevices[i] != NULL)
				XInputGetState(c_hDevices[i], (XINPUT_STATE*)&m_joystate[i]);
		}
	}
}

bool CJoystick::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_isBound))
	{
		if (*(bool*)pvValue)
		{
			Bind();
		}
		else if (c_pBoundJoystick == this)
		{
			c_pBoundJoystick = NULL;

			if (c_pPreviousBoundJoystick != NULL)
				c_pPreviousBoundJoystick->Bind();
		}
	}
    else if ((int)pprd->pbOffset == offsetof(m_secretKey))
    {
        // Delete the previous one if exists
        delete [] m_secretKey;
        m_secretKey = NULL;
        m_secretKeyLength = 0;

        // Cancel if we are in the middle of sequence checking
        if (m_secretKeyCurrentIndex)
            ProcessSecretKeySequence(KS_END);

        m_secretKeyCurrentIndex = 0;

        TCHAR* pszNewKey = *(TCHAR**)pvValue;
        if (pszNewKey)
        {
            m_secretKeyLength = _tcslen(pszNewKey);
            m_secretKey = new TCHAR[ m_secretKeyLength + 1 ];
            _tcscpy(m_secretKey, pszNewKey);
            m_enableSecretKey = true;
        }
    }
    else if ((int)pprd->pbOffset == offsetof(m_enableSecretKey))
    {
        m_enableSecretKey = *(bool*)pvValue;

        if (!m_enableSecretKey)
        {
            // Cancel if we are in the middle of sequence checking
            if (m_secretKeyCurrentIndex && m_secretKeyCurrentIndex < m_secretKeyLength)
                ProcessSecretKeySequence(KS_END);
        }

        m_secretKeyCurrentIndex = 0;
    }
    else if ((int)pprd->pbOffset == offsetof(m_eatSecretKey))
    {
        m_eatSecretKey = *(bool*)pvValue;
        return false;
    }
    else if ((int)pprd->pbOffset == offsetof(m_enableGamepad))
    {
#if defined(_DEBUG) || defined(COOL_XDASH)
        TRACE(_T("\001Gamepad can be disabled only in retail build! ask Tyler (a-tylerc) why\n"));
#else
        m_enableGamepad = *(bool*)pvValue;
#endif
        return false;
    }
    else if ((int)pprd->pbOffset == offsetof(m_enableRemote))
    {
        m_enableRemote = *(bool*)pvValue;
        return false;
    }

	return true;
}

bool CJoystick::CheckDevice()
{
	// BLOCK: Check for gamepads
	{
		DWORD dwGamepadDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);

		for (int i = 0; i < 4; i += 1)
		{
			if (c_hDevices[i] == NULL)
			{
				if ((dwGamepadDevices & (1 << i)) != 0)
				{
					TRACE(_T("Opening device %d\n"), i);
					c_hDevices[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL);
					if (c_hDevices[i] != NULL)
					{
						TRACE(_T("We have a gamepad on port %d (0x%08x)\n"), i, c_hDevices[i]);
						c_devtype[i] = XDEVICE_TYPE_GAMEPAD;
						XInputGetState(c_hDevices[i], (XINPUT_STATE*)&m_joystate[i]);
						m_timeNextUpdate = XAppGetNow();
					}
				}
			}
			else if (c_devtype[i] == XDEVICE_TYPE_GAMEPAD)
			{
				if ((dwGamepadDevices & (1 << i)) == 0)
				{
					TRACE(_T("Gamepad %d was removed! (0x%08x)\n"), i, c_hDevices[i]);

					XInputClose(c_hDevices[i]);
					c_devtype[i] = NULL;
					c_hDevices[i] = NULL;
				}
			}
		}
	}

	// BLOCK: Check for remote controls
	{
		DWORD dwDevices = XGetDevices(XDEVICE_TYPE_IR_REMOTE);

		for (int i = 0; i < 4; i += 1)
		{
			if (c_hDevices[i] == NULL)
			{
				if ((dwDevices & (1 << i)) != 0)
				{
					TRACE(_T("Opening device %d\n"), i);
					c_hDevices[i] = XInputOpen(XDEVICE_TYPE_IR_REMOTE, i, XDEVICE_NO_SLOT, NULL);
					if (c_hDevices[i] != NULL)
					{
						TRACE(_T("We have a remote control on port %d (0x%08x)\n"), i, c_hDevices[i]);
						c_devtype[i] = XDEVICE_TYPE_IR_REMOTE;
						XInputGetState(c_hDevices[i], (XINPUT_STATE*)&m_joystate[i]);
						m_timeNextUpdate = XAppGetNow();
                        m_timeRemoteRemoved = 0.0f;
                        if (m_bRemoveRemoteCalled)
                        {
                            CallFunction(_T("OnInsertRemote"), true);
                        }
					}
				}
			}
			else if (c_devtype[i] == XDEVICE_TYPE_IR_REMOTE)
			{
				if ((dwDevices & (1 << i)) == 0)
				{
					XInputClose(c_hDevices[i]);
					c_devtype[i] = NULL;
					c_hDevices[i] = NULL;
                    m_timeRemoteRemoved = XAppGetNow() + 2.0f;
                    m_bRemoveRemoteCalled = false;
				}
			}
		}
	}

	return true;
}

bool CJoystick::OpenDevice()
{
	return true;
}

void CJoystick::EnableGlobalInput(int bEnable)
{
    g_bInputEnable = (bEnable != 0);
}

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

static float ConvertThumb(SHORT sThumb)
{
	float axis = (float)sThumb / 32767.0f;

	// Large dead zone for prototype dukes...
	if (axis < 0.0f && axis > -0.9f)
		axis = 0.0f;
	else if (axis > 0.0f && axis < 0.9f)
		axis = 0.0f;

	return axis;
}

static bool EqualGamepads(const XINPUT_GAMEPAD* pad1, const XINPUT_GAMEPAD* pad2)
{
	if (pad1->wButtons != pad2->wButtons)
		return false;

	for (int i = 0; i < 8; i += 1)
	{
		if ((pad1->bAnalogButtons[i] > XINPUT_ANALOGBUTTONTHRESHOLD) !=
		    (pad2->bAnalogButtons[i] > XINPUT_ANALOGBUTTONTHRESHOLD))
			return false;
	}

	if (ConvertThumb(pad1->sThumbLX) != ConvertThumb(pad2->sThumbLX))
		return false;

	if (ConvertThumb(pad1->sThumbLY) != ConvertThumb(pad2->sThumbLY))
		return false;

	if (ConvertThumb(pad1->sThumbRX) != ConvertThumb(pad2->sThumbRX))
		return false;

	if (ConvertThumb(pad1->sThumbRY) != ConvertThumb(pad2->sThumbRY))
		return false;

	return true;
}

struct REMOTE_CODE_TABLE
{
    TCHAR* szFunction1;
    TCHAR* szFunction2;
    WORD wCode;
};

static const REMOTE_CODE_TABLE RemoteCodeTable[] =
{
	{ _T("OnPower"),		NULL,			0xAD5 },
	{ _T("OnReverse"),		NULL,			0xAE2 },
	{ _T("OnPlay"),			NULL,			0xAEA },
	{ _T("OnForward"),		NULL,			0xAE3 },
	{ _T("OnSkipBack"),		NULL,			0xADD },
	{ _T("OnStop"),			NULL,			0xAE0 },
	{ _T("OnPause"),		NULL,			0xAE6 },
	{ _T("OnSkipForward"),	NULL,			0xADF },
	{ _T("OnGuide"),		NULL,			0xAE5 },
	{ _T("OnInfo"),			NULL,			0xAC3 },
	{ _T("OnMenu"),			NULL,			0xAF7 },
	{ _T("OnBDown"),		_T("OnBUp"),	0xAD8 },
	{ _T("OnMoveUp"),		NULL,			0xAA6 },
	{ _T("OnMoveLeft"),		NULL,			0xAA9 },
	{ _T("OnADown"),		_T("OnAUp"),	0xA0B },
	{ _T("OnMoveRight"),	NULL,			0xAA8 },
	{ _T("OnMoveDown"),		NULL,			0xAA7 },
	{ _T("On0"),			NULL,			0xACF },
	{ _T("On1"),			NULL,			0xACE },
	{ _T("On2"),			NULL,			0xACD },
	{ _T("On3"),			NULL,			0xACC },
	{ _T("On4"),			NULL,			0xACB },
	{ _T("On5"),			NULL,			0xACA },
	{ _T("On6"),			NULL,			0xAC9 },
	{ _T("On7"),			NULL,			0xAC8 },
	{ _T("On8"),			NULL,			0xAC7 },
	{ _T("On9"),			NULL,			0xAC6 },
	{ NULL,					NULL,			0 }
};

static const REMOTE_CODE_TABLE* GetCodeFunction(WORD wCode)
{
	const REMOTE_CODE_TABLE* pRemoteEntry = RemoteCodeTable;
	while (pRemoteEntry->wCode != 0)
	{
		if (pRemoteEntry->wCode == wCode)
			return pRemoteEntry;

		pRemoteEntry += 1;
	}

	return NULL;
}

void CJoystick::Advance(float nSeconds)
{
    int k;

	CNode::Advance(nSeconds);

    if (!g_bInputEnable)
    {
        return;
    }

	if (this != c_pBoundJoystick)
		return;

    if (!m_bRemoveRemoteCalled && m_timeRemoteRemoved != 0.0f && XAppGetNow() > m_timeRemoteRemoved)
    {
        TRACE(_T("Remote control was removed!\n"));
        CallFunction(_T("OnRemoveRemote"), true);
        m_bRemoveRemoteCalled = true;
    }

	if (!CheckDevice())
		return;

	if (m_bNeedsInit)
	{
		for (int i = 0; i < 4; i += 1)
		{
			if (c_hDevices[i] != NULL)
				XInputGetState(c_hDevices[i], (XINPUT_STATE*)&m_joystate[i]);
		}

		m_timeNextUpdate = XAppGetNow();
		m_bNeedsInit = false;
	}

	if (m_timeNextUpdate > XAppGetNow())
		return;

	m_timeNextUpdate = XAppGetNow() + 1.0f / m_frequency;

	g_xaxis = g_yaxis = 0.0f;

	XINPUT_STATE_INTERNAL joystate;
	for (int nJoypad = 0; nJoypad < 4; nJoypad += 1)
	{
		if (c_hDevices[nJoypad] == NULL)
			continue;

		if (c_devtype[nJoypad] == XDEVICE_TYPE_IR_REMOTE)
		{
			XINPUT_STATE_INTERNAL state;
			if (XInputGetState(c_hDevices[nJoypad], (XINPUT_STATE*)&state) != ERROR_SUCCESS)
			{
				TRACE(_T("XInputGetState for remote failed; close the device...\n"));
				XInputClose(c_hDevices[nJoypad]);
				c_hDevices[nJoypad] = NULL;
				c_devtype[nJoypad] = NULL;
                m_timeRemoteRemoved = XAppGetNow() + 2.0f;
                m_bRemoveRemoteCalled = false;
				break;
			}

            //
            //  Now some logic to implement typomatic on the IR remote.
            //-----------------------------------------------------------------
            //  It is important to understand how codes are sent:
            //  1) When a button is depressed its code is sent in
            //      state.IrRemote.wKeyCode.
            //  2) The time since the last code (as measured by the FW)
            //     is sent in c_state.IrRemote.wTimeDelta.
            //  3) A button held depressed on the remote will repeat about
            //     every 65 ms.
            //  4) Codes are not cached, so if we poll too slowly (less than
            //     once every 65 ms) we are likely to miss a code or see only
            //     its repeat.
            //  5) If state.dwPacketNumber doesn't change we have not received
            //     a packet since the last poll.
            //-----------------------------------------------------------------
            //  The desired behavior is:
            //  1) If a key is pressed quickly and repeatedly, it should fire once
            //     per press.
            //  2) If a key is held, there should be a short delay (~325 ms), followed
            //     by a more rapid repeat (~130 ms interval).  This interval is partly
            //     chosen as it is easy.
            //  3) When a key is released, it should stop repeating immediately.
            //-----------------------------------------------------------------
            //  To achieve this we follow the following rules:
            //  1) If we do not got a new packet in over 150 ms assume that the user
            //     has released the key.
            //  2) Use the state.IrRemote.wTimeDelta to distinguish rapid press
            //     from repeats.  In particular, if the state.IrRemote.wTimeDelta
            //     is less than 120 ms (and the key is the same as the last one)
            //     assume that it is repeat, otherwise, assume that it is a new
            //     button press.
            //  3) Pass on the first press, then pause for a number of presses
            //     and pass every n'th press.  The initiali pause and n are
            //     adjusted for a good feel.

	        if (state.dwPacketNumber == m_joystate[nJoypad].dwPacketNumber)
            {
                m_remoteIdleTime += nSeconds;
                if(m_remoteIdleTime > 0.150)
                {
                    m_remoteRepeatCount = 0;
                }
            }
            else
            {
                //
                //  Reset Screen Saver
                //

                ResetScreenSaver();

                //
                //  Reset repeat delay.
                //

                m_remoteIdleTime = 0.0;

                //
                //  Copy the state.
                //

                m_joystate[nJoypad] = state;

                //
                //  Check for new key press
                //
		        if (state.IrRemote.wKeyCode != m_joystate[nJoypad].IrRemote.wKeyCode || state.IrRemote.wTimeDelta > 120)
                {
                    m_remoteRepeatCount = 1;
                } else
                //
                //  Otherwise, it is a repeat
                //
                {
                    m_remoteRepeatCount++;
                }
                //
                //  Let through repeated buttons based on their repeat count.
                //  Adjust for an immediate key (on 1) and then a pause with
                //  a reasonable repeat rate.
                //
                if( (1 == m_remoteRepeatCount) ||
                    ((m_remoteRepeatCount > 7) && m_remoteRepeatCount%2)
                )
                {
                    const REMOTE_CODE_TABLE* pFunction = GetCodeFunction(state.IrRemote.wKeyCode);
				    if (pFunction != NULL)
				    {
					    TRACE(_T("IR Code: 0x%04x %s\n"), state.IrRemote.wKeyCode, pFunction->szFunction1);

                        // TODO: check for secret key sequence from remote too!
					    CallFunction(pFunction->szFunction1, true);

					    if (pFunction->szFunction2 != NULL)
						    CallFunction(pFunction->szFunction2, true);
				    }
                }
            }
            continue; //done with IR Remote, continue with next port
		}

        DWORD dwError = XInputGetState(c_hDevices[nJoypad], (XINPUT_STATE*)&joystate);

		if (dwError != ERROR_SUCCESS)
		{
			// NOTE: We catch device removal above...
			TRACE(_T("\001XInputGetState returned %d (device %d)\n"), dwError, nJoypad);
			ZeroMemory(&joystate, sizeof (joystate));
			continue;
//			return;
		}

		if (!EqualGamepads(&joystate.Gamepad, &m_joystate[nJoypad].Gamepad)/*memcmp(&joystate.Gamepad, &m_joystate[nJoypad].Gamepad, sizeof (XINPUT_GAMEPAD)) != 0*/)
		{
			if (ResetScreenSaver())
			{
				// Screen saver was active, so ignore this change...
				m_joystate[nJoypad] = joystate;
				continue;
			}
		}

    	bool bWasCentered = m_xaxis == 0.0f && m_yaxis == 0.0f;

        m_xaxis = ConvertThumb(joystate.Gamepad.sThumbLX);
        m_yaxis = ConvertThumb(joystate.Gamepad.sThumbLY);

        m_xaxis2 = ConvertThumb(joystate.Gamepad.sThumbRX);
        m_yaxis2 = ConvertThumb(joystate.Gamepad.sThumbRY);

        // Make the DPad act like the left joystick; maybe I'll be more clever later...
        if (m_xaxis == 0 && m_yaxis == 0)
        {
            if (joystate.Gamepad.wButtons & 1)
                m_yaxis = 1.0f;
            else if (joystate.Gamepad.wButtons & 2)
                m_yaxis = -1.0f;
            if (joystate.Gamepad.wButtons & 4)
                m_xaxis = -1.0f;
            else if (joystate.Gamepad.wButtons & 8)
                m_xaxis = 1.0f;
        }

        g_xaxis += m_xaxis;
        g_yaxis += m_yaxis;

        {
            if (m_xaxis == 0 && m_yaxis == 0)
            {
                m_nextRepeatTime[nJoypad] = 0;
                m_repeatInterval[nJoypad] = REPEAT_DELAY; // delay to first repeat
            }
            else if (XAppGetNow() >= m_nextRepeatTime[nJoypad])
            {
                if (m_xaxis != 0)
                {
                    k = CheckSecretKeySequence(m_xaxis < 0.0f ? _T('L') : _T('R'));
                    CallFunction(m_xaxis < 0.0f ? _T("OnMoveLeft") : _T("OnMoveRight"));
                    ProcessSecretKeySequence(k);
                }

                if (m_yaxis != 0)
                {
                    k = CheckSecretKeySequence(m_yaxis < 0.0f ? _T('D') : _T('U'));
                    CallFunction(m_yaxis < 0.0f ? _T("OnMoveDown") : _T("OnMoveUp"));
                    ProcessSecretKeySequence(k);
                }

                m_nextRepeatTime[nJoypad] = XAppGetNow() + m_repeatInterval[nJoypad];
                m_repeatInterval[nJoypad] = REPEAT_INTERVAL; // delay for all but first repeat
            }
        }

        for (int i = 0; i < 8; i += 1)
        {
            bool bIsDown = joystate.Gamepad.bAnalogButtons[i] > XINPUT_ANALOGBUTTONTHRESHOLD;
            bool bWasDown = m_joystate[nJoypad].Gamepad.bAnalogButtons[i] > XINPUT_ANALOGBUTTONTHRESHOLD;

            if (bIsDown != bWasDown)
            {
                static const TCHAR* rgszDown [] =
                {
                    _T("OnADown"),
                    _T("OnBDown"),
                    _T("OnXDown"),
                    _T("OnYDown"),
                    _T("OnBlackDown"),
                    _T("OnWhiteDown"),
                    _T("OnLeftDown"),
                    _T("OnRightDown")
                };

                static const TCHAR* rgszUp [] =
                {
                    _T("OnAUp"),
                    _T("OnBUp"),
                    _T("OnXUp"),
                    _T("OnYUp"),
                    _T("OnBlackUp"),
                    _T("OnWhiteUp"),
                    _T("OnLeftUp"),
                    _T("OnRightUp")
                };

                static const TCHAR rgszSecretKey[] =
                {
                    _T('A'),
                    _T('B'),
                    _T('X'),
                    _T('Y'),
                    _T('b'),    // Black
                    _T('w'),    // Write
                    _T('l'),    // Left-trigger
                    _T('r'),    // Right-trigger
                };

                if (bIsDown) k = CheckSecretKeySequence(rgszSecretKey[i]);
                CallFunction(bIsDown ? rgszDown[i] : rgszUp[i]);
                if (bIsDown) ProcessSecretKeySequence(k);

#if defined(_DEBUG) && defined(_CYCLE_LANGUAGE)
                if (i == 7 && bIsDown && m_joystate[nJoypad].Gamepad.bAnalogButtons[6] > XINPUT_ANALOGBUTTONTHRESHOLD)
                    CycleLanguage();
#endif

#ifdef COOL_XDASH
                if (m_joystate[nJoypad].Gamepad.bAnalogButtons[6] > XINPUT_ANALOGBUTTONTHRESHOLD && \
                    m_joystate[nJoypad].Gamepad.bAnalogButtons[7] > XINPUT_ANALOGBUTTONTHRESHOLD)
                {
                    if (m_joystate[nJoypad].Gamepad.bAnalogButtons[4] > XINPUT_ANALOGBUTTONTHRESHOLD) {
                        XWriteTitleInfoAndReboot("xshell.xbe", "\\Device\\Harddisk0\\Partition2", ~0, 0, NULL);
                    } else if (m_joystate[nJoypad].Gamepad.bAnalogButtons[5] > XINPUT_ANALOGBUTTONTHRESHOLD) {
                        XWriteTitleInfoAndReboot("default.xbe", "\\Device\\Harddisk0\\Partition1\\Devkit\\Gripper", ~0, 0, NULL);
                    }
                }
#endif
            }
        }

#ifdef _DEBUG
        g_bWireframe = joystate.Gamepad.bAnalogButtons[4] > XINPUT_ANALOGBUTTONTHRESHOLD;
#endif

        WORD bit = 1;
        for (i = 0; i < 8; i += 1, bit <<= 1)
        {
            if ((joystate.Gamepad.wButtons & bit) != (m_joystate[nJoypad].Gamepad.wButtons & bit))
            {
                static const TCHAR* rgszDown [] =
                {
                    _T("OnPressUp"),
                    _T("OnPressDown"),
                    _T("OnPressLeft"),
                    _T("OnPressRight"),
#if 1 // Make Start/Back the same as A/B; maybe I'll be more clever later...
                    _T("OnADown"),
                    _T("OnBDown"),
#else
                    _T("OnStartDown"),
                    _T("OnBackDown"),
#endif
                    _T("OnLeftThumbDown"),
                    _T("OnRightThumbDown")
                };

                static const TCHAR* rgszUp [] =
                {
                    _T("OnReleaseUp"),
                    _T("OnReleaseDown"),
                    _T("OnReleaseLeft"),
                    _T("OnReleaseRight"),
#if 1 // Make Start/Back the same as A/B; maybe I'll be more clever later...
                    _T("OnAUp"),
                    _T("OnBUp"),
#else
                    _T("OnStartUp"),
                    _T("OnBackUp"),
#endif
                    _T("OnLeftThumbUp"),
                    _T("OnRightThumbUp")
                };

                static const TCHAR rgszSecretKey[] =
                {
                    _T('\0'),
                    _T('\0'),
                    _T('\0'),
                    _T('\0'),
                    _T('S'),    // Start
                    _T('P'),    // Back
                    _T('Q'),    // Left-thumb
                    _T('W')     // Right-thumb
                };

                if (joystate.Gamepad.wButtons & bit) k = CheckSecretKeySequence(rgszSecretKey[i]);
                CallFunction((joystate.Gamepad.wButtons & bit) ? rgszDown[i] : rgszUp[i]);
                if (joystate.Gamepad.wButtons & bit) ProcessSecretKeySequence(k);

            }
        }

        if ((joystate.Gamepad.wButtons & XINPUT_GAMEPAD_START) != 0 &&
             joystate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD &&
             joystate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD)
            CallFunction(_T("OnReset"));

        bool bIsCentered = m_xaxis == 0.0f && m_yaxis == 0.0f;

        if (!bWasCentered && bIsCentered)
            CallFunction(_T("OnMoveCenter"));

        m_joystate[nJoypad] = joystate;
    }
}

int CJoystick::CheckSecretKeySequence(TCHAR key)
{
    int nReturn = 0;

    if (!m_enableSecretKey || m_secretKeyLength == 0 || !m_secretKey)
    {
        ASSERT(m_secretKeyCurrentIndex == 0);
        return 0;
    }

    ASSERT(m_secretKeyCurrentIndex < m_secretKeyLength);

    if (key != m_secretKey[m_secretKeyCurrentIndex])
    {
        if (m_secretKeyCurrentIndex)
        {
            nReturn |= KS_END;
        }
        m_secretKeyCurrentIndex = 0;
        return nReturn;
    }

    if (m_secretKeyCurrentIndex == 0)
    {
        nReturn |= KS_BEGIN;
    }

    if (++m_secretKeyCurrentIndex == m_secretKeyLength)
    {
        nReturn |= KS_END;
        nReturn |= KS_VERIFIED;
        m_secretKeyCurrentIndex = 0;
    }

    return nReturn;
}

void CJoystick::ProcessSecretKeySequence(int flags)
{
    if (flags & KS_BEGIN)
        CallFunction(_T("OnKeyVerificationEnter"));

    if (flags & KS_END)
        CallFunction(_T("OnKeyVerificationExit"));

    if (flags & KS_VERIFIED)
        CallFunction(_T("OnKeyVerified"));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Layer.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "NavInfo.h"
#include "Viewpoint.h"
#include "Lerper.h"

extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matPosition;
extern D3DXMATRIX g_matProjection;
extern D3DXMATRIX g_matIdentity;

class CLayer : public CGroup
{
	DECLARE_NODE(CLayer, CGroup)
public:
	CLayer();
	~CLayer();

	void Render();
	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	CNode* m_viewpoint;
	CNode* m_navigationInfo;

	float m_fade;
	float m_transparency;

protected:
	LPDIRECT3DVERTEXBUFFER8 m_pVB;
	float m_alpha;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Layer", CLayer, CGroup)

START_NODE_PROPS(CLayer, CGroup)
	NODE_PROP(pt_node, CLayer, viewpoint)
	NODE_PROP(pt_node, CLayer, navigationInfo)
	NODE_PROP(pt_number, CLayer, fade)
	NODE_PROP(pt_number, CLayer, transparency)
END_NODE_PROPS()


CLayer::CLayer() :
	m_viewpoint(NULL),
	m_navigationInfo(NULL),
	m_fade(0.0f),
	m_transparency(0.0f)
{
	m_pVB = NULL;
}

CLayer::~CLayer()
{
	if (m_viewpoint != NULL)
		m_viewpoint->Release();

	if (m_navigationInfo != NULL)
		m_navigationInfo->Release();

	if (m_pVB != NULL)
		m_pVB->Release();
}

struct COLORVERTEX
{
	float dvX, dvY, dvZ;
	DWORD color;
};

bool CLayer::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_transparency))
	{
		CLerper::RemoveObject(this);
		if (m_fade > 0.0f)
			new CLerper(this, &m_alpha, 1.0f - *(float*)pvValue, m_fade);
		else
			m_alpha = 1.0f - *(float*)pvValue;
	}

	return CGroup::OnSetProperty(pprd, pvValue);
}

void CLayer::Render()
{
	D3DXMATRIX matProjection, matProjectionSave, matWorldSave, matViewSave;

	if (m_viewpoint == NULL)
	{
		TRACE(_T("\001Layer is missing a viewpoint!\n"));
		return;
	}

	if (m_alpha == 0.0f)
		return;

	{
		if (m_pVB == NULL)
		{
			VERIFYHR(XAppGetD3DDev()->CreateVertexBuffer(4 * sizeof(COLORVERTEX), D3DUSAGE_WRITEONLY, D3DFVF_XYZ | D3DFVF_DIFFUSE, D3DPOOL_MANAGED, &m_pVB));

			COLORVERTEX* verts;
			VERIFYHR(m_pVB->Lock(0, 4 * sizeof (COLORVERTEX), (BYTE**)&verts, 0));

			verts[0].dvX = (float)theApp.m_nViewWidth / 2.0f;
			verts[0].dvY = -(float)theApp.m_nViewHeight / 2.0f;
			verts[0].dvZ = 0.0f;
			verts[0].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, 1.0f);

			verts[1].dvX = -(float)theApp.m_nViewWidth / 2.0f;
			verts[1].dvY = -(float)theApp.m_nViewHeight / 2.0f;
			verts[1].dvZ = 0.0f;
			verts[1].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, 1.0f);

			verts[2].dvX = (float)theApp.m_nViewWidth / 2.0f;
			verts[2].dvY = (float)theApp.m_nViewHeight / 2.0f;
			verts[2].dvZ = 0.0f;
			verts[2].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, 1.0f);

			verts[3].dvX = -(float)theApp.m_nViewWidth / 2.0f;
			verts[3].dvY = (float)theApp.m_nViewHeight / 2.0f;
			verts[3].dvZ = 0.0f;
			verts[3].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, 1.0f);

			VERIFYHR(m_pVB->Unlock());
		}

		D3DXMATRIX matProjection, matProjectionSave, matWorldSave, matViewSave;

		XAppGetTransform(D3DTS_PROJECTION, &matProjectionSave);
		XAppGetTransform(D3DTS_WORLD, &matWorldSave);
		XAppGetTransform(D3DTS_VIEW, &matViewSave);

		//D3DXMatrixOrthoLH(&matProjection, 720.0f, 480.0f, -10000.0f, 10000.0f);
		D3DXMatrixOrthoLH(&matProjection, theApp.m_nViewWidth, theApp.m_nViewHeight, -10000.0f, 10000.0f);
		XAppSetTransform(D3DTS_PROJECTION, &matProjection);
		XAppSetTransform(D3DTS_WORLD, &g_matIdentity);
		XAppSetTransform(D3DTS_VIEW, &g_matIdentity);

        XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
        XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
        XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
        XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(0, 0, 0, (BYTE)(m_alpha * 255.0f)));
        XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
        XAppSetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
        XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
		XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
		XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

        VERIFYHR(XAppGetD3DDev()->SetStreamSource(0, m_pVB, sizeof (COLORVERTEX)));
        VERIFYHR(XAppGetD3DDev()->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE));
        VERIFYHR(XAppGetD3DDev()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2));

		XAppSetTransform(D3DTS_PROJECTION, &matProjectionSave);
		XAppSetTransform(D3DTS_WORLD, &matWorldSave);
		XAppSetTransform(D3DTS_VIEW, &matViewSave);
	}

	CViewpoint* pViewpoint = (CViewpoint*)m_viewpoint;
	CNavigationInfo* pNavigationInfo = (CNavigationInfo*)m_navigationInfo;

	if (pNavigationInfo != NULL && !pNavigationInfo->IsKindOf(NODE_CLASS(CNavigationInfo)))
		TRACE(_T("\002Layer with bogus NavigationInfo!\n"));

	XAppGetTransform(D3DTS_PROJECTION, &matProjectionSave);
	XAppGetTransform(D3DTS_WORLD, &matWorldSave);
	XAppGetTransform(D3DTS_VIEW, &matViewSave);

	// BLOCK: Calculate projection matrix
	{
		float nNear = 0.1f;
		float nFar = 1000.0f;
		float fieldOfView = D3DX_PI / 2.0f;

		if (pNavigationInfo != NULL)
		{
			nNear = pNavigationInfo->m_avatarSize.x / 2.0f;
			if (pNavigationInfo->m_visibilityLimit != 0.0f)
				nFar = pNavigationInfo->m_visibilityLimit;
		}

		fieldOfView = pViewpoint->m_fieldOfView;

		float aspect = 720.0f/480.0f;

		if (theApp.m_bStretchWidescreen)
		{
			// This adjusts for 4x3 style resolutions being displayed
			// widescreen on a 16x9 monitor...
			aspect *= 1.25f;
		}

		D3DXMatrixPerspectiveFovLH(&g_matProjection, fieldOfView, aspect, nNear, nFar);
		XAppSetTransform(D3DTS_PROJECTION, &g_matProjection);
	}

	// BLOCK: Calculate view matrix
	if (pViewpoint != NULL)
	{
		D3DXVECTOR3 position = pViewpoint->m_position;
		position.z = -position.z;

		D3DXQUATERNION orientation;
		D3DXQuaternionRotationAxis(&orientation, (D3DXVECTOR3*)&pViewpoint->m_orientation, -pViewpoint->m_orientation.w);

		D3DXMatrixAffineTransformation(&g_matView, 1.0f, NULL, &orientation, &position);
		D3DXMatrixInverse(&g_matView, NULL, &g_matView);

		g_matView._31 = -g_matView._31;
		g_matView._32 = -g_matView._32;
		g_matView._33 = -g_matView._33;
		g_matView._34 = -g_matView._34;
		XAppSetTransform(D3DTS_VIEW, &g_matView);
	}

	// BLOCK: Render children
	{
		XAppPushWorld();
		XAppIdentityWorld();
		XAppUpdateWorld();
		CGroup::Render();
		XAppPopWorld();
	}

	// BLOCK: Restore everything...
	{
		g_matProjection = matProjectionSave;
		g_matView = matViewSave;

		XAppSetTransform(D3DTS_PROJECTION, &matProjectionSave);
		XAppSetTransform(D3DTS_WORLD, &matWorldSave);
		XAppSetTransform(D3DTS_VIEW, &matViewSave);
	}
}

void CLayer::Advance(float nSeconds)
{
	CGroup::Advance(nSeconds);

	if (m_navigationInfo != NULL)
		m_navigationInfo->Advance(nSeconds);

	if (m_viewpoint != NULL)
		m_viewpoint->Advance(nSeconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\level.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Level.h"
#include "Camera.h"
#include "Viewpoint.h"
#include "xip.h"

extern float g_nEffectAlpha;
extern float g_transitionMotionBlur;

////////////////////////////////////////////////////////////////////////////

extern void BindJoystick(CNode* pJoystickNode);

CLevel* g_pCurLevel;
CLevel* g_pFromLevel;
CNode* g_pCurTunnel;
XTIME g_timeToNextLevel;
bool g_bLevelTransition;

IMPLEMENT_NODE("Level", CLevel, CGroup)

START_NODE_PROPS(CLevel, CGroup)
	NODE_PROP(pt_node, CLevel, control)
	NODE_PROP(pt_node, CLevel, tunnel)
	NODE_PROP(pt_node, CLevel, path)
	NODE_PROP(pt_node, CLevel, shell)
	NODE_PROP(pt_string, CLevel, archive)
	NODE_PROP(pt_boolean, CLevel, unloadable)
	NODE_PROP(pt_boolean, CLevel, fade)
END_NODE_PROPS()

START_NODE_FUN(CLevel, CGroup)
	NODE_FUN_VV(GoTo)
	NODE_FUN_VV(GoBackTo)
END_NODE_FUN()

CLevel::CLevel() :
	m_tunnel(NULL),
	m_control(NULL),
	m_path(NULL),
	m_shell(NULL),
	m_archive(NULL),
    m_fade(true),
	m_unloadable(true)
{
	m_visible = false; // override default
	m_pXipFile = NULL;
	g_timeToNextLevel = 0.0f;
	m_bArrive = false;
}

CLevel::~CLevel()
{
	if (this == g_pCurLevel)
		g_pCurLevel = NULL;
	
	if (this == g_pFromLevel)
		g_pFromLevel = NULL;

	if (m_tunnel == g_pCurTunnel)
		g_pCurTunnel = NULL;

	if (m_tunnel != NULL)
		m_tunnel->Release();

	if (m_control != NULL)
		m_control->Release();

	if (m_path != NULL)
		m_path->Release();

	if (m_shell != NULL)
		m_shell->Release();

	delete [] m_archive;
}

void CLevel::Render()
{
	float alpha = 1.0f;

    if (m_fade)
    {
    	float t = (float) (g_timeToNextLevel - XAppGetNow()) / 0.75f;
    	if (t > 1.0f)
    		t = 1.0f;
    	else if (t < 0.0f)
    		t = 0.0f;

    	if (g_pCurLevel == this)
    		alpha = 1.0f - t;
    	else if (g_pFromLevel == this)
    		alpha = t;

    	if (alpha == 0.0f)
    		return;
    }

	float nEffectAlphaSave = g_nEffectAlpha;
	g_nEffectAlpha *= alpha;

	if (m_shell != NULL)
		m_shell->Render();

	if (g_pCurLevel == this)
	{
		// turn on motion blur
		float blurAlpha = alpha * 1.3f;
		if(blurAlpha > 1.0f)
			blurAlpha = 1.0f;
		g_transitionMotionBlur = blurAlpha;
	}

	CGroup::Render();

//	if (m_tunnel != NULL && m_tunnel->m_visible)
//		m_tunnel->Render();

	g_nEffectAlpha = nEffectAlphaSave;
}

void CLevel::Activate()
{
    g_bLevelTransition = true;

	TRACE(_T("Leaving level  0x%08x\n"), g_pCurLevel);
	TRACE(_T("Going to level 0x%08x\n"), this);

	if (m_archive != NULL && m_pXipFile == NULL)
	{
		m_pXipFile = LoadXIP(m_archive);
	}

	if (g_pFromLevel != NULL || g_pCurLevel != NULL && g_timeToNextLevel != 0.0f)
	{
		TRACE(_T("\taborting goto level 0x%08x\n"), g_pFromLevel);

		if (g_pFromLevel != NULL)
		{
			g_pFromLevel->Deactivate();
			g_pFromLevel = NULL;
			g_timeToNextLevel = 0.0f;
		}

		if (g_pCurLevel != NULL)
		{
			g_pCurLevel->m_visible = false;
			if (g_pCurLevel->m_pXipFile && g_pCurLevel->m_unloadable && !g_pCurLevel->m_pXipFile->m_bLocked)
				g_pCurLevel->m_pXipFile->DeleteMeshBuffers();
			g_pCurLevel = NULL;
			g_timeToNextLevel = 0.0f;
		}

		if (g_pCurTunnel != NULL)
		{
			g_pCurTunnel->m_visible = false;
			g_pCurTunnel = NULL;
		}
	}

	ASSERT(g_pFromLevel == NULL);

	g_timeToNextLevel = XAppGetNow() + 1.0f;
	g_pFromLevel = g_pCurLevel;

	m_visible = true;

	BindJoystick(NULL); // disable joystick while transitioning

	g_pCurLevel = this;
}

void CLevel::GoTo()
{
	if (this == g_pCurLevel)
		return;

	Activate();

	g_pCurTunnel = m_tunnel;

	if (g_pCurTunnel != NULL)
		g_pCurTunnel->m_visible = true;

	if (m_path != NULL)
	{
		if (m_path->IsKindOf(NODE_CLASS(CViewpoint)))
			BindViewpoint(m_path);
		else if (m_path->IsKindOf(NODE_CLASS(CCameraPath)))
			((CCameraPath*)m_path)->Activate(false);
	}

	CallFunction(this, _T("OnActivate"));
}

void CLevel::GoBackTo()
{
	if (this == g_pCurLevel)
		return;

	Activate();

	g_pCurTunnel = (g_pFromLevel == NULL) ? NULL : g_pFromLevel->m_tunnel;

	if (g_pCurTunnel != NULL)
		g_pCurTunnel->m_visible = true;

	if (g_pFromLevel != NULL && g_pFromLevel->m_path != NULL && g_pFromLevel->m_path->IsKindOf(NODE_CLASS(CCameraPath)))
		((CCameraPath*)g_pFromLevel->m_path)->Activate(true);
	else if (m_path != NULL && m_path->IsKindOf(NODE_CLASS(CViewpoint)))
		BindViewpoint(m_path);

	CallFunction(this, _T("OnActivate"));
}

void CLevel::Advance(float nSeconds)
{
	CGroup::Advance(nSeconds);

	if (m_tunnel != NULL)
		m_tunnel->Advance(nSeconds);

	if (m_path != NULL)
		m_path->Advance(nSeconds);

	if (m_control != NULL)
		m_control->Advance(nSeconds);

	if (m_shell != NULL)
		m_shell->Advance(nSeconds);

	if (g_pCurLevel == this && g_timeToNextLevel != 0.0f && XAppGetNow() >= g_timeToNextLevel)
	{
		TRACE(_T("Arrived at level 0x%08x\n"), this);

		ASSERT(g_pCurLevel == this);

		// We're there...
		g_timeToNextLevel = 0.0f;

		if (g_pCurTunnel != NULL)
			g_pCurTunnel->m_visible = false;

		if (g_pFromLevel != NULL)
		{
			g_pFromLevel->Deactivate();
			g_pFromLevel = NULL;
		}

		m_bArrive = true;
	}

	if (m_bArrive && (m_pXipFile == NULL || m_pXipFile->m_bLoaded))
	{
		m_bArrive = false;
		BindJoystick(m_control);
		CallFunction(this, _T("OnArrival"));
        g_bLevelTransition = false;
	}
}

void CLevel::Deactivate()
{
	ASSERT(this == g_pFromLevel);

	m_visible = false;
	CallFunction(this, _T("OnDeactivate"));

	if (m_unloadable && !m_pXipFile->m_bLocked)
		m_pXipFile->DeleteMeshBuffers();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\keyboard.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"

extern CNode* GetTextNode(const TCHAR* szText, float nWidth);
extern bool g_bActiveKey;
extern TCHAR* g_szText;
extern int g_nTextChar;
extern int g_nCurLanguage;

#define MAX_LENGTH		31

#define modeAlpha		0
#define modeSymbol		1
#define modeAccent		2

#define jmodeHiragana	0
#define jmodeKatakana	1
#define jmodeEnglish	2

#define keyShift		1
#define keyCaps			2
#define keyAlpha		3
#define keySym			4
#define keyAcc			5
#define keyLT			6
#define keyRT			7
#define keyBS			8
#define keyDone			9
#define keySpace		10

// Japanese keys
#define keyHiragana     11
#define keyKatakana		12
#define keyEnglish		13

#define keyVoid			14

#define _nbsp		0x00a0 // non-breaking space
#define _iexcl		0x00a1 // 
#define _cent		0x00a2 // 
#define _pound		0x00a3 // 
#define _curren		0x00a4 // 
#define _yen		0x00a5 // 
#define _brvbar		0x00a6 // 
#define _sect		0x00a7 // 
#define _uml		0x00a8 // 
#define _copy		0x00a9 // 
#define _ordf		0x00aa // 
#define _laquo		0x00ab // 
#define _not		0x00ac // 
#define _shy		0x00ad // soft hyphen
#define _reg		0x00ae // 
#define _macr		0x00af // 
#define _deg		0x00b0 // 
#define _plusmn		0x00b1 // 
#define _sup2		0x00b2 // 
#define _sup3		0x00b3 // 
#define _acute		0x00b4 // 
#define _micro		0x00b5 // 
#define _para		0x00b6 // 
#define _middot		0x00b7 // 
#define _cedil		0x00b8 // 
#define _sup1		0x00b9 // 
#define _ordm		0x00ba // 
#define _raquo		0x00bb // 
#define _iquest		0x00bf // 
#define _Agrave		0x00c0 // 
#define _Aacute		0x00c1 // 
#define _Acirc		0x00c2 // 
#define _Atilde		0x00c3 // 
#define _Auml		0x00c4 // 
#define _Aring		0x00c5 // 
#define _AElig		0x00c6 // 
#define _Ccedil		0x00c7 // 
#define _Egrave		0x00c8 // 
#define _Eacute		0x00c9 // 
#define _Ecirc		0x00ca // 
#define _Euml		0x00cb // 
#define _Igrave		0x00cc // 
#define _Iacute		0x00cd // 
#define _Icirc		0x00ce // 
#define _Iuml		0x00cf // 
#define _ETH		0x00d0 // 
#define _Ntilde		0x00d1 // 
#define _Ograve		0x00d2 // 
#define _Oacute		0x00d3 // 
#define _Ocirc		0x00d4 // 
#define _Otilde		0x00d5 // 
#define _Ouml		0x00d6 // 
#define _times		0x00d7 // 
#define _Oslash		0x00d8 // 
#define _Ugrave		0x00d9 // 
#define _Uacute		0x00da // 
#define _Ucirc		0x00db // 
#define _Uuml		0x00dc // 
#define _Yacute		0x00dd // 
#define _THORN		0x00de // 
#define _szlig		0x00df // 
#define _agrave		0x00e0 // 
#define _aacute		0x00e1 // 
#define _acirc		0x00e2 // 
#define _atilde		0x00e3 // 
#define _auml		0x00e4 // 
#define _aring		0x00e5 // 
#define _aelig		0x00e6 // 
#define _ccedil		0x00e7 // 
#define _egrave		0x00e8 // 
#define _eacute		0x00e9 // 
#define _ecirc		0x00ea // 
#define _euml		0x00eb // 
#define _igrave		0x00ec // 
#define _iacute		0x00ed // 
#define _icirc		0x00ee // 
#define _iuml		0x00ef // 
#define _eth		0x00f0 // 
#define _ntilde		0x00f1 // 
#define _ograve		0x00f2 // 
#define _oacute		0x00f3 // 
#define _ocirc		0x00f4 // 
#define _otilde		0x00f5 // 
#define _ouml		0x00f6 // 
#define _divide		0x00f7 // 
#define _oslash		0x00f8 // 
#define _ugrave		0x00f9 // 
#define _uacute		0x00fa // 
#define _ucirc		0x00fb // 
#define _uuml		0x00fc // 
#define _yacute		0x00fd // 
#define _thorn		0x00fe // 
#define _yuml		0x00ff // 

#define _euro		0x20ac // euro sign

static const WORD rgkeyAlpha [] =
{
	keyDone,	L'1',	L'2',	L'3',	L'4',	L'5',	L'6',	L'7',	L'8',	L'9',	L'0',
	keyShift,	L'a',	L'b',	L'c',	L'd',	L'e',	L'f',	L'g',	L'h',	L'i',	L'j',
	keyCaps,	L'k',	L'l',	L'm',	L'n',	L'o',	L'p',	L'q',	L'r',	L's',	L't',
	keyAcc,		L'u',	L'v',	L'w',	L'x',	L'y',	L'z',	keyBS,	keyBS,	keyBS,	keyBS,
	keySym,		keySpace,	keySpace,	keySpace,	keySpace,	keySpace,	keySpace,	keyLT,	keyLT,	keyRT,	keyRT,
};

static const WORD rgkeySymbol [] =
{
	keyDone,	L'(',	L')',	L'&',	L'_',	L'^',		L'%',	L'\\',	L'/',	L'@',	L'#',
	keyShift,	L'[',	L']',	L'$',	_pound,	_euro,		_yen,	L';',	L':',	L'\'',	L'"',
	keyCaps,	L'<',	L'>',	L'?',	L'!',	_iquest,	_iexcl,	L'-',	L'*',	L'+',	L'=',
	keyAcc,		L'{',	L'}',	_laquo,	_raquo,	',',		L'.',	keyBS,	keyBS,	keyBS,	keyBS,
	keyAlpha,	keySpace,	keySpace,	keySpace,	keySpace,	keySpace,		keySpace,	keyLT,	keyLT,	keyRT,	keyRT,
};

static const WORD rgkeyAccent [] =
{
	keyDone,	L'1',		L'2',		L'3',		L'4',		L'5',		L'6',		L'7',		L'8',		L'9',		L'0',
	keyShift,	_agrave,	_aacute,	_acirc,		_auml,		_egrave,	_eacute,	_ecirc,		_euml,		_igrave,	_iacute,
	keyCaps,	_icirc,		_iuml,		_ograve,	_oacute,	_ocirc,		_otilde,	_ugrave,	_uacute,	_ucirc,		_uuml,
	keyAlpha,	_yacute,	_yuml,		_ccedil,	_szlig,		_ntilde,	_aelig,		keyBS,		keyBS,		keyBS,		keyBS,
	keySym,		keySpace,	keySpace,	keySpace,	keySpace,	keySpace,	keySpace,	keyLT,		keyLT,		keyRT,		keyRT,
};

static const WORD* rgmode [] =
{
	rgkeyAlpha,
	rgkeySymbol,
	rgkeyAccent
};

static const WORD HiraganaSet [] =
{
	0x3042,	0x3044,	0x3046,	0x3048,	0x304A,	0x308F,	0x3092,	0x3093,	keyVoid,keyVoid,keyHiragana,
	0x304B,	0x304D,	0x304F,	0x3051,	0x3053,	0x3041,	0x3043,	0x3045,	0x3047,	0x3049, keyKatakana,
	0x3055,	0x3057,	0x3059,	0x305B,	0x305D,	0x3063,	0x3083,	0x3085,	0x3087,	0x308e, keyEnglish,
	0x305F,	0x3061,	0x3064,	0x3066,	0x3068,	0x304c,	0x304e,	0x3050,	0x3052,	0x3054, keySpace,
	0x306a,	0x306b,	0x306c,	0x306d,	0x306e,	0x3056,	0x3058,	0x305a,	0x305c,	0x305e, keyBS,
	0x306f,	0x3072,	0x3075,	0x3078,	0x307b,	0x3060,	0x3062,	0x3065,	0x3067,	0x3069, keyLT,
	0x307E,	0x307F,	0x3080,	0x3081,	0x3082,	0x3070,	0x3073,	0x3076,	0x3079,	0x307c, keyRT,
	0x3084,	keyVoid,0x3086,	keyVoid,0x3088,	0x3071,	0x3074,	0x3077,	0x307a,	0x307d, keyVoid,
	0x3089,	0x308a,	0x308b,	0x308c,	0x308d,	0x30fc,	0x3001,	0x3002,	0x300c,	0x300d, keyDone,

};

static const WORD KatakanaSet [] =
{
	0x30A2,	0x30A4,	0x30A6,	0x30A8,	0x30AA,	0x30EF,	0x30F2,	0x30F3,	0x30f4,	keyVoid,keyHiragana,
	0x30AB,	0x30AD,	0x30AF,	0x30B1,	0x30B3,	0x30A1,	0x30A3,	0x30A5,	0x30A7,	0x30A9,	keyKatakana,
	0x30B5,	0x30B7,	0x30B9,	0x30BB,	0x30BD,	0x30C3,	0x30E3,	0x30E5,	0x30E7,	0x30EE, keyEnglish,
	0x30BF,	0x30C1,	0x30C4,	0x30C6,	0x30C8,	0x30AC,	0x30AE,	0x30B0,	0x30B2,	0x30B4, keySpace,
	0x30CA,	0x30CB,	0x30CC,	0x30CD,	0x30CE,	0x30B6,	0x30B8,	0x30BA,	0x30BC,	0x30BE, keyBS,
	0x30CF,	0x30D2,	0x30D5,	0x30D8,	0x30DB,	0x30C0,	0x30C2,	0x30C5,	0x30C7,	0x30C9, keyLT,
	0x30DE,	0x30DF,	0x30E0,	0x30E1,	0x30E2,	0x30D0,	0x30D3,	0x30D6,	0x30D9,	0x30DC, keyRT,
	0x30E4,	keyVoid,0x30E6,	keyVoid,0x30E8,	0x30D1,	0x30D4,	0x30D7,	0x30DA,	0x30DD, keyVoid,
	0x30E9,	0x30EA,	0x30EB,	0x30EC,	0x30ED,	0x30fc,	0x3001,	0x3002,	0x300c,	0x300d, keyDone,
};

static const WORD EnglishSet [] =
{
	0x41,	0x42,	0x43,	0x44,	0x45,	0x61,	0x62,	0x63,	0x64,	0x65,	keyHiragana,
	0x46,	0x47,	0x48,	0x49,	0x4A,	0x66,	0x67,	0x68,	0x69,	0x6A,	keyKatakana,
	0x4B,	0x4C,	0x4D,	0x4E,	0x4F,	0x6B,	0x6C,	0x6D,	0x6E,	0x6F,	keyEnglish,
	0x50,	0x51,	0x52,	0x53,	0x54,	0x70,	0x71,	0x72,	0x73,	0x74,	keySpace,
	0x55,	0x56,	0x57,	0x58,	0x59,	0x75,	0x76,	0x77,	0x78,	0x79,	keyBS,
	0x5A,	0x22,	0x27,	0x40,	0x23,	0x7A,	0x28,	0x29,	0x7B,	0x7D,	keyLT,
	0x26,	0x5E,	0x24,	0xA5,	0x25,	0x2D,	0x2B,	0x3D,	0x2A,	0x2F,	keyRT,
	0x30,	0x31,	0x32,	0x33,	0x34,	0x3F,	0x21,	0x3A,	0x3B,	0x5C,	keyVoid,
	0x35,	0x36,	0x37,	0x38,	0x39,	0x3C,	0x3E,	0x2C,	0x2E,	0x5F,	keyDone,
};

static const WORD* japmode [] =
{
	HiraganaSet,
	KatakanaSet,
	EnglishSet
};

class CKeyboard : public CNode
{
	DECLARE_NODE(CKeyboard, CNode)
public:
	CKeyboard();
	~CKeyboard();

	CNodeArray m_keys;
	CNode* m_frame;
	CNode* m_text;
	CNode* m_control;

	TCHAR* m_string;

	bool m_shift;
	bool m_caps;
	int m_mode;
	int m_jmode;

    void selectKey(int nRow, int nColumn);
	bool validKey(int nRow, int nColumn);
	void selectUp();
	void selectDown();
	void selectLeft();
	void selectRight();
	void activate();

	void Backspace();
	void Delete();
	void CursorLeft();
	void CursorRight();
	void Shift();
	void CycleMode();
	void Insert(const TCHAR* szInsert);

	void Advance(float nSeconds);
	void Render();
	bool OnSetProperty(const PRD* pprd, const void* pvValue);


protected:
	TCHAR m_rgch [MAX_LENGTH + 1];
	int m_nLength;
	int m_nCursor;

	int m_nRow;
	int m_nColumn;

	TCHAR GetCharFromKey(WORD key);

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS();
};

IMPLEMENT_NODE("Keyboard", CKeyboard, CNode)

START_NODE_PROPS(CKeyboard, CNode)
	NODE_PROP(pt_nodearray, CKeyboard, keys)
	NODE_PROP(pt_node, CKeyboard, frame)
	NODE_PROP(pt_node, CKeyboard, text)
	NODE_PROP(pt_node, CKeyboard, control)
	NODE_PROP(pt_integer, CKeyboard, mode)
	NODE_PROP(pt_integer, CKeyboard, jmode)
	NODE_PROP(pt_boolean, CKeyboard, shift)
	NODE_PROP(pt_boolean, CKeyboard, caps)
	NODE_PROP(pt_string, CKeyboard, string)
END_NODE_PROPS()

START_NODE_FUN(CKeyboard, CNode)
    NODE_FUN_VII(selectKey)
	NODE_FUN_VV(selectUp)
	NODE_FUN_VV(selectDown)
	NODE_FUN_VV(selectLeft)
	NODE_FUN_VV(selectRight)
	NODE_FUN_VV(activate)
	NODE_FUN_VV(Backspace)
	NODE_FUN_VV(Delete)
	NODE_FUN_VV(CursorLeft)
	NODE_FUN_VV(CursorRight)
	NODE_FUN_VV(Shift)
	NODE_FUN_VV(CycleMode)
	NODE_FUN_VS(Insert)
END_NODE_FUN()

CKeyboard::CKeyboard() :
	m_control(NULL),
	m_frame(NULL),
	m_text(NULL),
	m_mode(modeAlpha),
	m_jmode(jmodeHiragana),
	m_shift(false),
	m_caps(false),
	m_string(NULL)
{
	m_nLength = 0;
	m_nCursor = -1; // select all
	m_nRow = 0;
	m_nColumn = 0;
}

CKeyboard::~CKeyboard()
{
	if (m_text != NULL)
		m_text->Release();

	if (m_frame != NULL)
		m_frame->Release();

	if (m_control != NULL)
		m_control->Release();

	delete [] m_string;
}

void CKeyboard::selectKey(int nRow, int nColumn)
{
	int numRows = 4;
	if(g_nCurLanguage == 1)  // Japanese
		numRows = 8;

    if( ( nRow < 0 ) || ( nRow > numRows ) )
    {
        m_nRow = 0;
    }
    else
    {
        m_nRow = nRow;
    }

    if( ( nColumn < 0 ) || ( nColumn > 10 ) )
    {
        m_nColumn = 0;
    }
    else
    {
        m_nColumn = nColumn;
    }
}

bool CKeyboard::validKey(int nRow, int nColumn)
{
	const WORD* rgkey;
	if(g_nCurLanguage == 1)  // Japanese
		rgkey = japmode[m_jmode];
	else
		rgkey = rgmode[m_mode];

	WORD key = rgkey[nRow * 11 + nColumn];

	if(key == keyVoid) // missing key
		return false;

	return true;
}


void CKeyboard::selectUp()
{
retryUp:
	int numRows = 4;
	if(g_nCurLanguage == 1)  // Japanese
		numRows = 8;

	if (m_nRow == 0)
	{
		m_nRow = numRows;
		if(validKey(m_nRow, m_nColumn))
			return;
		else
			goto retryUp;
	}

	m_nRow -= 1;
	if(!validKey(m_nRow, m_nColumn))
		goto retryUp;
}

void CKeyboard::selectDown()
{
retryDown:
	int numRows = 4;
	if(g_nCurLanguage == 1)  // Japanese
		numRows = 8;

	if (m_nRow == numRows)
	{
		m_nRow = 0;
		if(validKey(m_nRow, m_nColumn))
			return;
		else
			goto retryDown;
	}

	m_nRow += 1;
	if(!validKey(m_nRow, m_nColumn))
		goto retryDown;
}

void CKeyboard::selectLeft()
{
retryLeft:
	if (m_nColumn == 0)
	{
		m_nColumn = 10;
		if(validKey(m_nRow, m_nColumn))
			return;
		else
			goto retryLeft;
	}

	if(g_nCurLanguage == 1)  // Japanese
	{
		m_nColumn -= 1;
		if(!validKey(m_nRow, m_nColumn))
			goto retryLeft;
	}
	else
	{
		if (m_nRow == 3)
		{
			if (m_nColumn > 6)
				m_nColumn = 6;
			else
				m_nColumn -= 1;
		}
		else if (m_nRow == 4)
		{
			if (m_nColumn > 8)
				m_nColumn = 8;
			else if (m_nColumn > 6)
				m_nColumn = 6;
			else
				m_nColumn = 0;
		}
		else
		{
			m_nColumn -= 1;
		}
	}
}

void CKeyboard::selectRight()
{
retryRight:
	if (m_nColumn == 10)
	{
		m_nColumn = 0;
		if(validKey(m_nRow, m_nColumn))
			return;
		else
			goto retryRight;
	}
	
	if(g_nCurLanguage == 1)  // Japanese
	{
		m_nColumn += 1;
		if(!validKey(m_nRow, m_nColumn))
			goto retryRight;
	}
	else
	{
		if (m_nRow == 3)
		{
			if (m_nColumn >= 7)
			{
				m_nColumn = 0;
				return;
			}

			m_nColumn += 1;
		}
		else if (m_nRow == 4)
		{
			if (m_nColumn >= 9)
			{
				m_nColumn = 0;
				return;
			}

			if (m_nColumn == 0)
				m_nColumn = 1;
			else if (m_nColumn < 7)
				m_nColumn = 7;
			else if (m_nColumn < 9)
				m_nColumn = 9;
		}
		else
		{
			m_nColumn += 1;
		}
	}
}

void CKeyboard::activate()
{
	const WORD* rgkey;
	if(g_nCurLanguage == 1)  // Japanese
		rgkey = japmode[m_jmode];
	else
		rgkey = rgmode[m_mode];

	WORD key = rgkey[m_nRow * 11 + m_nColumn];

	switch (key)
	{
	case keyDone:
		{
			// BLOCK: Make sure we have something other than spaces...
			{
				for (int i = 0; i < m_nLength; i += 1)
				{
					if (m_rgch[i] != ' ')
						break;
				}

				if (i == m_nLength)
				{
					CallFunction(this, _T("OnError"));
					break;
				}
			}

            // Trim the Right Spaces from the String
            TCHAR* prgcUserString = m_rgch + ( m_nLength - 1 );

            while( *prgcUserString == _T(' ') )
            {
                *prgcUserString = _T('\0');
                prgcUserString--;
            }

            // Trim the Left Spaces from the String
            prgcUserString = m_rgch;
            while( *prgcUserString == _T(' ') )
                prgcUserString++;

            // Copy good characters of the string
            if( prgcUserString != m_rgch )
                MoveMemory( m_rgch, prgcUserString, sizeof(TCHAR) * (_tcslen(prgcUserString) + 1) );

			delete [] m_string;
			m_string = new TCHAR [m_nLength + 1];
			CopyChars(m_string, m_rgch, m_nLength);
			m_string[m_nLength] = 0;

			CallFunction(this, _T("OnDone"));
		}
		break;

	case keyShift:
		Shift();
		break;

	case keyCaps:
		if (m_mode != modeAlpha && m_mode != modeAccent)
			CallFunction(this, _T("OnError"));
		else
			m_caps = !m_caps;
		break;

	case keyAlpha:
		m_mode = modeAlpha;
		break;

	case keySym:
		m_mode = modeSymbol;
		break;

	case keyAcc:
		m_mode = modeAccent;
		break;

	case keyHiragana:
		m_jmode = jmodeHiragana;
		break;

	case keyKatakana:
		m_jmode = jmodeKatakana;
		break;

	case keyEnglish:
		m_jmode = jmodeEnglish;
		break;

	case keyLT:
		CursorLeft();
		break;

	case keyRT:
		CursorRight();
		break;

	case keyBS:
		Backspace();
		break;

	case keySpace:
		if (m_nCursor == -1)
		{
			m_nLength = 0;
			m_nCursor = 0;
		}

		if (m_nLength < MAX_LENGTH)
		{
			MoveMemory(&m_rgch[m_nCursor + 1], &m_rgch[m_nCursor], (m_nLength - m_nCursor) * sizeof (TCHAR));
			m_rgch[m_nCursor] = _T(' ');
			m_nCursor += 1;
			m_nLength += 1;
			//m_shift = false;
		}
		break;

	default:
		if (m_nCursor == -1)
		{
			m_nLength = 0;
			m_nCursor = 0;
		}

		if (m_nLength < MAX_LENGTH)
		{
			MoveMemory(&m_rgch[m_nCursor + 1], &m_rgch[m_nCursor], (m_nLength - m_nCursor) * sizeof (TCHAR));
			m_rgch[m_nCursor] = GetCharFromKey(key);
			m_nCursor += 1;
			m_nLength += 1;
			m_shift = false;
		}
        else
        {
            // We want to play the error sound if the user has "filled" the string and attempts to add
            // another character
            CallFunction(this, _T("OnError"));
        }

		break;
	}
}

void CKeyboard::Backspace()
{
	if (m_nCursor == -1)
	{
		m_nLength = 0;
		m_nCursor = 0;
	}

	if (m_nCursor > 0)
	{
		MoveMemory(&m_rgch[m_nCursor - 1], &m_rgch[m_nCursor], (m_nLength - m_nCursor) * sizeof (TCHAR));
		m_nLength -= 1;
		m_nCursor -= 1;
	}
    else
    {
        // We want to play the error sound if the user has no character to backspace
        CallFunction(this, _T("OnError"));
    }
}

void CKeyboard::Delete()
{
	if (m_nCursor == -1)
	{
		m_nLength = 0;
		m_nCursor = 0;
	}

	if (m_nCursor < m_nLength)
	{
		CursorRight();
		Backspace();
	}
    else
    {
        // We want to play the error sound if the user has no character to delete
        CallFunction(this, _T("OnError"));
    }
}

void CKeyboard::CursorLeft()
{
	if (m_nCursor == -1)
		m_nCursor = 0;
	else if (m_nCursor > 0)
		m_nCursor -= 1;
	else
		CallFunction(this, _T("OnError"));
}

void CKeyboard::CursorRight()
{
	if (m_nCursor == -1)
		m_nCursor = m_nLength;
	else if (m_nCursor < m_nLength)
		m_nCursor += 1;
	else
		CallFunction(this, _T("OnError"));
}

void CKeyboard::Shift()
{
	if (m_mode != modeAlpha && m_mode != modeAccent)
		CallFunction(this, _T("OnError"));
	else
		m_shift = !m_shift;
}

void CKeyboard::CycleMode()
{
	m_mode += 1;    // English Keyboard
    m_jmode += 1;   // Japanese Keyboard

    // English Keyboard
	if (m_mode > 2)
		m_mode = 0;

    // Japanese Keyboard
	if (m_jmode > 2)
		m_jmode = 0;
}

void CKeyboard::Insert(const TCHAR* szInsert)
{
	if (m_nCursor == -1)
	{
		m_nLength = 0;
		m_nCursor = 0;
	}

	int cchInsert = _tcslen(szInsert);

	if (m_nLength + cchInsert > MAX_LENGTH)
	{
		CallFunction(this, _T("OnError"));
		return;
	}

	MoveMemory(&m_rgch[m_nCursor + cchInsert], &m_rgch[m_nCursor], (m_nLength - m_nCursor) * sizeof (TCHAR));
	CopyChars(&m_rgch[m_nCursor], szInsert, cchInsert);
	m_nCursor += cchInsert;
	m_nLength += cchInsert;
	m_shift = false;
}

TCHAR CKeyboard::GetCharFromKey(WORD key)
{
	ASSERT(key >= 32);

	TCHAR ch = (TCHAR)key;

	if (m_caps ^ m_shift)
		ch = (TCHAR)CharUpper((LPTSTR)ch);

	return ch;
}

bool CKeyboard::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_string))
	{
		TCHAR* szNew = *(TCHAR**)pvValue;
		if (szNew == NULL)
			szNew = _T("");
		int cchNew = _tcslen(szNew);
		if (cchNew > MAX_LENGTH)
			cchNew = MAX_LENGTH;
		CopyChars(m_rgch, szNew, cchNew);
		m_nLength = cchNew;
		m_nCursor = -1;
	}

	return true;
}

void CKeyboard::Render()
{
	const WORD* rgkey;
	if(g_nCurLanguage == 1)  // Japanese
		rgkey = japmode[m_jmode];
	else
		rgkey = rgmode[m_mode];

	if (m_frame != NULL)
		m_frame->Render();

	if (m_text != NULL)
	{
		m_rgch[m_nLength] = 0;
		g_szText = m_rgch;
		g_nTextChar = m_nCursor;
		m_text->Render();
		g_nTextChar = -1;
	}

	int keyLength = 0;
	if(g_nCurLanguage == 1)  // Japanese
	{
		if (m_keys.GetLength() != 99)
		{
			TRACE(_T("\001Japanese keyboard does not have 99 keys!\n"));
			return;
		}
		keyLength = 99;
	}
	else
	{
		if (m_keys.GetLength() != 45)
		{
			TRACE(_T("\001Keyboard does not have 45 keys!\n"));
			return;
		}
		keyLength = 55;
	}

	TCHAR szBuf [2];
	int nNode = 0;
	for (int i = 0; i < keyLength; i += 1)
	{
		if(g_nCurLanguage != 1)  // Not Japanese
		{
			if (i > 0 && rgkey[i] == rgkey[i - 1])
				continue;
		}

		CNode* pNode = m_keys.GetNode(nNode);
		int nKey = m_nRow * 11 + m_nColumn;

		if(g_nCurLanguage != 1)  // Not Japanese
		{
			if (nKey > 40 && nKey <= 43)
				nKey = 40;
			else if (nKey > 45 && nKey <= 50)
				nKey = 45;
			else if (nKey == 52)
				nKey = 51;
			else if (nKey == 54)
				nKey = 53;
		}

		switch (rgkey[i])
		{
		case keyShift:
			g_szText = _T("SHIFT");
			break;

		case keyCaps:
			g_szText = _T("CAPS LOCK");
			break;

		case keyAlpha:
			g_szText = _T("ALPHABET");
			break;

		case keySym:
			g_szText = _T("SYMBOLS");
			break;

		case keyAcc:
			g_szText = _T("ACCENTS");
			break;

		case keyEnglish:
			g_szText = _T("ENGLISH");
			break;

		case keyHiragana:
			g_szText = _T("HIRAGANA");
			break;

		case keyKatakana:
			g_szText = _T("KATAKANA");
			break;

		case keyLT:
			g_szText = _T("<");
			break;

		case keyRT:
			g_szText = _T(">");
			break;

		case keyBS:
			g_szText = _T("BACKSPACE");
			break;

		case keyDone:
			g_szText = _T("DONE");
			break;

		case keySpace:
			g_szText = _T("SPACE");
			break;
		
		case keyVoid:
			g_szText = _T(" ");
			break;

		default:
			szBuf[0] = (TCHAR)rgkey[i];
			szBuf[1] = 0;

			if(g_nCurLanguage != 1)  // Not Japanese
			{
				if (m_caps ^ m_shift)
					szBuf[0] = (TCHAR)CharUpper((LPTSTR)szBuf[0]);
			}

			g_szText = szBuf;
		break;
		}

		g_bActiveKey = (i == nKey);
		if(rgkey[i] != keyVoid)  // key is visible
			pNode->Render();

		nNode += 1;
	}
}

void CKeyboard::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_control != NULL)
		m_control->Advance(nSeconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\level.h ===
#pragma once

class CLevel : public CGroup
{
	DECLARE_NODE(CLevel, CGroup)
public:
	CLevel();
	~CLevel();

	CNode* m_control;	// a joystick
	CNode* m_tunnel;	// the tunnel that leads here
	CNode* m_path;		// the path through the tunnel
	CNode* m_shell;		// the sphere around the level
	TCHAR* m_archive;
	bool m_unloadable;
    bool m_fade;

	// NYI: path for the tunnel
	// NYI: ambient music controls

	float m_timeToNextLevel;

	void GoTo();
	void GoBackTo();

	void Advance(float nSeconds);
	void Render();

protected:
	void Activate();
	void Deactivate();

	class CXipFile* m_pXipFile;
	bool m_bArrive;

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Locale.cpp ===
#include "std.h"
#include "XApp.h"
#include "Node.h"
#include "Runner.h"
#include "Locale.h"
#include "Parser.h"
#include "TitleCollection.h"

#define MAX_XLATE 500 // This is the maximum number of terms in a translation file

int g_nCurLanguage;
int g_nCurRegion;

static const CHAR* rgszTranslateSection[] =
{
    "EnglishXlate",
    "JapaneseXlate",
    "GermanXlate",
    "FrenchXlate",
    "SpanishXlate",
    "ItalianXlate"
};

struct XLATE
{
    TCHAR* m_szKey;
    TCHAR* m_szValue;
};

static HANDLE g_hXlate;
static TCHAR* rgchXlateData;
static XLATE rgxlate [MAX_XLATE];

static void FreeXlate()
{
    ASSERT(g_nCurLanguage >= 0 && g_nCurLanguage < countof(rgszTranslateSection));

    if (g_hXlate != NULL && g_hXlate != INVALID_HANDLE_VALUE)
    {
        VERIFY(XFreeSectionByHandle(g_hXlate));
    }

    rgchXlateData = NULL;
    ZeroMemory(rgxlate, sizeof(rgxlate));
}

static void LoadXlate(const CHAR* szXlateSection)
{
    // BLOCK: load translation table from XBE section
    {
        g_hXlate = XGetSectionHandle(szXlateSection);

        if (g_hXlate != INVALID_HANDLE_VALUE)
        {
            for (;;)
            {
                rgchXlateData = (TCHAR*)XLoadSectionByHandle(g_hXlate);
                if (rgchXlateData)
                {
                    break;
                }
                NewFailed(32 * 1024U);
            }
        }

        if (g_hXlate == INVALID_HANDLE_VALUE || !rgchXlateData || *(WORD*)rgchXlateData != 0xFEFF)
        {
            ALERT(_T("Unable to load translation \"%hs\" from section, data maybe corrupted"), szXlateSection);
#ifdef _DEBUG
            __asm int 3;
#endif
            HalReturnToFirmware(HalFatalErrorRebootRoutine);
            return; // Should never been here
        }
    }

    // BLOCK: create mapping table
    {
        TCHAR* pch = rgchXlateData + 1; // Skip Unicode BOM
        int nXlate = 0;
        int nLine = 1;
        while (*pch != 0)
        {
            const TCHAR* pchKey;
            int cchKey;

            while (*pch == ' ' || *pch == '\t')
                pch += 1;

            if (*pch == '#')
            {
                pch += 1;
                while (*pch != 0 && *pch != '\r' && *pch != '\n')
                    pch += 1;
            }

            if (*pch == '\r')
            {
                pch += 1;
                if (*pch == '\n')
                    pch += 1;

                nLine += 1;
                continue;
            }

            if (*pch == '"')
            {
                pch += 1;
                pchKey = pch;
                while (*pch != 0 && *pch != '\r' && *pch != '\n' && *pch != '"')
                    pch += 1;
            }
            else
            {
                pchKey = pch;
                while ((unsigned)*pch > ' ' && *pch != '=')
                {
                    if (*pch == '_')
                    {
                        if (*(pch + 1) == '=' || *(pch + 1) == ' ')
                            *pch = ':';
                        else
                            *pch = ' ';
                    }

                    pch += 1;
                }
            }
            cchKey = (int)(pch - pchKey);

            if (*pch == '"')
                pch += 1;

            while (*pch == ' ' || *pch == '\t')
                pch += 1;

            if (*pch != '=')
            {
                TRACE(_T("\001%hs(%d): invalid translation data: expected an '='\n"), szXlateSection, nLine);
                return;
            }

            pch += 1;

            const TCHAR* pchValue;
            int cchValue;

            while (*pch == ' ' || *pch == '\t')
                pch += 1;

            if (*pch == '"')
                pch += 1;

            pchValue = pch;
            while (*pch != 0 && *pch != '\r' && *pch != '\n' && *pch != '"')
                pch += 1;
            cchValue = (int)(pch - pchValue);

            if (*pch == '"')
                pch += 1;

            while (*pch == ' ' || *pch == '\t')
                pch += 1;

            if (*pch == '#')
            {
                pch += 1;
                while (*pch != 0 && *pch != '\r')
                    pch += 1;
            }

            if (*pch == '\r')
            {
                pch += 1;
                if (*pch == '\n')
                    pch += 1;

                nLine += 1;
            }
            else
            {
                TRACE(_T("\001%hs(%d): expected end of line!\n"), szXlateSection, nLine);
                return;
            }

            if (cchKey == 0 || cchValue == 0)
            {
                TRACE(_T("\001%hs(%d): missing key or value\n"), szXlateSection, nLine);
                continue;
            }

            cchValue = ExpandCString((TCHAR*)pchValue, cchValue, pchValue, cchValue);
            if (cchValue < 0)
                return;

            ((TCHAR*)pchKey)[cchKey] = 0;
            ((TCHAR*)pchValue)[cchValue] = 0;

    //      TRACE(_T("XLATE: \"%s\" = \"%s\"\n"), pchKey, pchValue);

            ASSERT(nXlate < MAX_XLATE); // need to increase MAX_XLATE!
            rgxlate[nXlate].m_szKey = (TCHAR*)pchKey;
            rgxlate[nXlate].m_szValue = (TCHAR*)pchValue;
            nXlate += 1;
        }
    }
}

const TCHAR* Translate(const TCHAR* szString, TCHAR* szTranslate, int nLanguage/*=LANGUAGE_CURRENT*/)
{
    if (nLanguage == LANGUAGE_CURRENT)
        nLanguage = g_nCurLanguage;

    _tcscpy(szTranslate, szString);
    TCHAR* pch = _tcschr(szTranslate, '@');
    if (pch != NULL)
        *pch = '@';

    bool bFound = false;
    for (int i = 0; i < MAX_XLATE; i += 1)
    {
        if (rgxlate[i].m_szKey == NULL)
            break;

        if (_tcscmp(rgxlate[i].m_szKey, szTranslate) == 0)
        {
            _tcscpy(szTranslate, rgxlate[i].m_szValue);
            bFound = true;
            break;
        }
    }

#ifdef _DEBUG
    if (!bFound)
    {
        for (const TCHAR* pch = szTranslate; *pch != '\0'; pch += 1)
        {
            if (*pch != ' ')
            {
                // TODO: Start ASSERTing when this warning stop happening...
                TRACE(_T("Translate: '%s' not found in %hs\n"), szString, rgszTranslateSection[nLanguage]);
                break;
            }
        }
    }
#endif

    return szTranslate;
}

////////////////////////////////////////////////////////////////////////////

class CTranslator : public CNode
{
    DECLARE_NODE(CTranslator, CNode)
public:
    CTranslator();
    ~CTranslator();

    void SetLanguage(int nNewLanguage);
    CStrObject* Translate(const TCHAR* szString);
    CStrObject* TranslateStripColon(const TCHAR* szString);
    CStrObject* GetLanguageCode();
    CStrObject* GetDateSeparator();
    CStrObject* FormatNumber(int nNumber);

    int GetTimeZoneCount();
    CStrObject* GetTimeZoneText(int nTimeZone);

    DECLARE_NODE_FUNCTIONS()
};

IMPLEMENT_NODE("Translator", CTranslator, CNode)

START_NODE_FUN(CTranslator, CNode)
    NODE_FUN_VI(SetLanguage)
    NODE_FUN_SS(Translate)
    NODE_FUN_SV(GetLanguageCode)
    NODE_FUN_SV(GetDateSeparator)
    NODE_FUN_SI(FormatNumber)
    NODE_FUN_IV(GetTimeZoneCount)
    NODE_FUN_SI(GetTimeZoneText)
    NODE_FUN_SS(TranslateStripColon)
END_NODE_FUN()

CTranslator::CTranslator()
{
}

CTranslator::~CTranslator()
{
}

#include "timezone.h"

int CTranslator::GetTimeZoneCount()
{
    return TIMEZONECOUNT;
}

CStrObject* CTranslator::GetTimeZoneText(int nTimeZone)
{
    if (nTimeZone < 0 || nTimeZone >= TIMEZONECOUNT)
        return new CStrObject;

    return Translate(g_timezoneinfo[nTimeZone].dispname);
}

int GetTimeZoneIndex(const TIME_ZONE_INFORMATION* tzinfo)
{
    ASSERT(tzinfo->StandardDate.wYear == 0 &&
           tzinfo->DaylightDate.wYear == 0);

    int index, bestmatch, bestresult;
    bestmatch = bestresult = -1;
    for (index=0; index < TIMEZONECOUNT; index++) {
        const struct TZINFO* srcinfo = &g_timezoneinfo[index];
        if (srcinfo->bias == tzinfo->Bias) {
            int match = 1;
            if (srcinfo->stdbias == tzinfo->StandardBias &&
                srcinfo->dltbias == tzinfo->DaylightBias) {
                match++;

                // Compare only the first 4 characters of the time zone name
                // because that's what we store in the EEPROM.
                // If everything matches, no need to continue searching.
                if (wcsncmp(srcinfo->stdname, tzinfo->StandardName, 4) == 0)
                    return index;
            }

            if (match > bestmatch) {
                bestmatch = match;
                bestresult = index;
            }
        }
    }

    return bestresult;
}

inline void TZDateToSysTime(const struct TZDATE* tzdate, SYSTEMTIME* systime)
{
    systime->wMonth = tzdate->month;
    systime->wDay = tzdate->day;
    systime->wDayOfWeek = tzdate->dayofweek;
    systime->wHour = tzdate->hour;
}

bool GetTimeZoneInfo(int index, TIME_ZONE_INFORMATION* tzinfo)
{
    if (index < 0 || index >= TIMEZONECOUNT)
        return false;

    const struct TZINFO* srcinfo = &g_timezoneinfo[index];
    memset(tzinfo, 0, sizeof(*tzinfo));

    tzinfo->Bias = srcinfo->bias;
    tzinfo->StandardBias = srcinfo->stdbias;
    tzinfo->DaylightBias = srcinfo->dltbias;

    wcsncpy(tzinfo->StandardName, srcinfo->stdname, countof(tzinfo->StandardName));
    wcsncpy(tzinfo->DaylightName,
            srcinfo->dltname ? srcinfo->dltname : srcinfo->stdname,
            countof(tzinfo->DaylightName));

    TZDateToSysTime(&srcinfo->stddate, &tzinfo->StandardDate);
    TZDateToSysTime(&srcinfo->dltdate, &tzinfo->DaylightDate);
    return true;
}

#ifdef _DEBUG
void CycleLanguage()
{
    FreeXlate();

    g_nCurLanguage += 1;
    if (g_nCurLanguage >= countof(rgszTranslateSection))
        g_nCurLanguage = 0;

    LoadXlate(rgszTranslateSection[g_nCurLanguage]);
}
#endif

void CTranslator::SetLanguage(int nNewLanguage)
{
    if (nNewLanguage == g_nCurLanguage && rgxlate[0].m_szKey != NULL)
        return;

    if (nNewLanguage < 0 || nNewLanguage >= LANGUAGE_COUNT)
    {
        TRACE(_T("CTranslator::SetLanguage: invalid language %d\n"), nNewLanguage);
        return;
    }

    g_nCurLanguage = nNewLanguage;
    FreeXlate();

    LoadXlate(rgszTranslateSection[g_nCurLanguage]);

    for (int i=0; i<countof(g_titles); i++)
    {
        if (g_titles[i].IsValid())
            g_titles[i].DeleteAll(false);
    }
}

CStrObject* CTranslator::Translate(const TCHAR* szString)
{
    TCHAR sz[MAX_TRANSLATE_LEN];
    return new CStrObject(::Translate(szString, sz));
}

CStrObject* CTranslator::TranslateStripColon(const TCHAR* szString)
{
    TCHAR sz[MAX_TRANSLATE_LEN];
    ::Translate(szString, sz);

    int cch = _tcslen(sz);
    if (cch > 0 && sz[cch - 1] == _T(':'))
        sz[cch - 1] = _T('\0');

    return new CStrObject(sz);
}

static const TCHAR rgszLangCodes [] = { _T("ENJADEFRESIT") };

const TCHAR* GetLanguageCode(TCHAR* sz)
{
    if (g_nCurLanguage < 0 || g_nCurLanguage > countof(rgszLangCodes) / 2)
    {
        sz[0] = 0;
        return sz;
    }

    sz[0] = rgszLangCodes[g_nCurLanguage * 2];
    sz[1] = rgszLangCodes[g_nCurLanguage * 2 + 1];
    sz[2] = 0;

    return sz;
}

CStrObject* CTranslator::GetLanguageCode()
{
    if (g_nCurLanguage < 0 || g_nCurLanguage > countof(rgszLangCodes) / 2)
        return new CStrObject; // empty string

    return new CStrObject(rgszLangCodes + g_nCurLanguage * 2, 2);
}

TCHAR GetDateSeparator()
{
    TCHAR chSep;

    switch (LOCALE_FROM_REGION_LANGUAGE(g_nCurRegion, g_nCurLanguage))
    {
    case LOCALE_NA_GERMAN: // Germany: d.m.y h:m
    case LOCALE_JAPAN_GERMAN: // Germany: d.m.y h:m
    case LOCALE_RESTOFWORLD_GERMAN: // Germany: d.m.y h:m
    case LOCALE_NA_ITALIAN: // Italian: d.m.y h:m
    case LOCALE_JAPAN_ITALIAN: // Italian: d.m.y h:m
    case LOCALE_RESTOFWORLD_ITALIAN: // Italian: d.m.y h:m
    case LOCALE_JAPAN_FRENCH: // French: d.m.y h:m
    case LOCALE_RESTOFWORLD_FRENCH: // French: d.m.y h:m
        chSep = '.';
        break;

    default: // the rest of the world
        chSep = '/';
    }

    return chSep;
}

CStrObject* CTranslator::GetDateSeparator()
{
    TCHAR chSep = ::GetDateSeparator();
    return new CStrObject(&chSep, 1);
}

CStrObject* CTranslator::FormatNumber(int nNumber)
{
    TCHAR szBuf [64];
    FormatInteger(szBuf, nNumber);
    return new CStrObject(szBuf);
}

////////////////////////////////////////////////////////////////////////////

void FormatInteger(TCHAR* szBuf, int nNumber, int locale/*=LOCALE_CURRENT*/)
{
    // Bug 7784: remove all number separator from the dash
    _stprintf(szBuf, _T("%d"), nNumber);

#if 0
    if (locale == LOCALE_CURRENT)
        locale = LOCALE_FROM_REGION_LANGUAGE(g_nCurRegion, g_nCurLanguage);

    TCHAR chSeperator;
    switch (LANGUAGE_FROM_LOCALE(locale))
    {
    default:
        chSeperator = ',';
        break;

    case LANGUAGE_FRENCH:
        chSeperator = ' ';
        break;

    case LANGUAGE_ITALIAN:
    case LANGUAGE_GERMAN:
        chSeperator = '.';
        break;
    }

    TCHAR* pch = szBuf;

    if (nNumber < 0)
    {
        *pch++ = '-';
        nNumber = -nNumber;
    }

    if (nNumber == 0)
    {
        *pch++ = '0';
        *pch = '\0';
        return;
    }

    bool bNonZero = false;
    for (int nDiv = 1000000000; nDiv > 0; nDiv /= 10)
    {
        int nDigit = nNumber / nDiv;
        if (nDigit != 0 || bNonZero)
        {
            bNonZero = true;
            *pch++ = nDigit + '0';
            nNumber -= nDigit * nDiv;

            if (nDiv == 1000000000 || nDiv == 1000000 || nDiv == 1000)
                *pch++ = chSeperator;
        }
    }

    *pch = '\0';
#endif
}

void FormatBlocks (TCHAR* szBuf, int nBlocks, int locale/*=LOCALE_CURRENT*/)
{
    if (nBlocks > MAX_BLOCKS_TO_SHOW) {
        FormatInteger(szBuf, MAX_BLOCKS_TO_SHOW, locale);
        _tcscat (szBuf, TEXT("+"));
    }
    else {
        FormatInteger(szBuf, nBlocks, locale);
    }
}

bool FormatTime(TCHAR* szBuf, SIZE_T chLen, SYSTEMTIME* pst, int locale/*=LOCALE_CURRENT*/)
{
    bool bPM;
    int nHour;
    TCHAR szDate[32], szTime[32];

    if (locale == LOCALE_CURRENT)
        locale = LOCALE_FROM_REGION_LANGUAGE(g_nCurRegion, g_nCurLanguage);

    // Format date
    TCHAR chSep = GetDateSeparator();

    switch (locale)
    {
    case LOCALE_NA_ENGLISH: // US: mm/dd/yy
        _sntprintf(szDate, countof(szDate), _T("%02d%c%02d%c%d "), pst->wMonth, chSep, pst->wDay, chSep, pst->wYear);
        break;

    case LOCALE_NA_JAPANESE: // Japanese: yy/mm/dd
    case LOCALE_JAPAN_JAPANESE:
    case LOCALE_RESTOFWORLD_JAPANESE:
        _sntprintf(szDate, countof(szDate), _T("%d%c%02d%c%02d "), pst->wYear, chSep, pst->wMonth, chSep, pst->wDay);
        break;

    default: // Rest: dd?mm?yy
        _sntprintf(szDate, countof(szDate), _T("%02d%c%02d%c%d "), pst->wDay, chSep, pst->wMonth, chSep, pst->wYear);
    }

    // Format time
    switch (locale)
    {
    case LOCALE_NA_ENGLISH: // US: h:m ampm
    case LOCALE_JAPAN_ENGLISH:
    case LOCALE_RESTOFWORLD_ENGLISH:
    case LOCALE_NA_JAPANESE: // Japanese: h:m ampm
    case LOCALE_JAPAN_JAPANESE:
    case LOCALE_RESTOFWORLD_JAPANESE:
        bPM = pst->wHour >= 12;
        nHour = pst->wHour;

        if (nHour >= 12)
            nHour -= 12;
        if (nHour == 0)
            nHour = 12;

        _sntprintf(szTime, countof(szTime), _T("%d:%02d %s"), nHour, pst->wMinute, bPM ? _T("PM") : _T("AM"));
        break;

    default: // the rest of the world
        _sntprintf(szTime, countof(szTime), _T("%d:%02d"), pst->wHour, pst->wMinute);
    }

    if (chLen < lstrlen(szDate) + lstrlen(szTime) + sizeof(_T('\0')))
    {
        return false;
    }

    lstrcpy(szBuf, szDate);
    lstrcat(szBuf, szTime);
    return true;
}

void Locale_Exit()
{
    FreeXlate();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Lexer.cpp ===
#include "std.h"
#include "xapp.h"
#include "Parser.h"


CParser::CParser(const TCHAR* szFilePath, const TCHAR* pchFile, int cchFile/*=-1*/)
{
	m_pchFile = pchFile;

	if (cchFile == -1)
		m_cchFile = _tcslen(pchFile);
	else
		m_cchFile = cchFile;

	m_szFilePath = szFilePath;

	m_pch = m_pchFile;
	m_nLine = 1;
}

CParser::~CParser()
{
}

void CParser::SkipWhite()
{
	m_pch = ::SkipWhite(m_pch);
}

bool CParser::Token(const TCHAR*& pchToken, int& cchToken, bool bAllowPaths/*=false*/)
{
	m_pch = ::Token(m_pch, pchToken, cchToken, bAllowPaths);
	return cchToken != 0;
}

void CParser::SyntaxError(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, countof (szBuffer), szMsg, args);

	TCHAR szMessage [1024];
	_stprintf(szMessage, _T("Syntax Error\n\nFile: %s\nLine: %d\n\n%s"), m_szFilePath, m_nLine, szBuffer);

#ifdef _WINDOWS
	XAppMessageBox(szMessage);
#else
	Trace(_T("\007%s\n"), szMessage);
#endif

	va_end(args);
}


////////////////////////////////////////////////////////////////////////////


// REVIEW: This crap should be in CLexer

#define IsAlNum(ch) (((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z') || ((ch) >= '0' && (ch) <= '9') || (ch) == '.' || (ch) == '-' || (ch) == '_')

int g_nLine;
const TCHAR* g_szFileName;
static TCHAR g_szFileNameBuf [MAX_PATH];
bool g_bParseError;

#if 1
#define TRACE_LINE(pch)
#else
void TraceLine(const TCHAR* pch)
{
	TRACE(_T("file: \"%s\" line %d\n"), g_szFileName, g_nLine);

	TCHAR szLine [256];
	_tcsncpy(szLine, pch, 255);
	szLine[255] = '\0';
	TCHAR* p = _tcschr(szLine, '\r');
	if (p != NULL)
		*p = '\0';
	TRACE(_T("\002    %s\n"), szLine);
}
#define TRACE_LINE(pch) TraceLine(pch)
#endif


void StartParse(const TCHAR* pch, const TCHAR* szFileName, int nLine/*=1*/)
{
	g_szFileName = szFileName;
	g_nLine = nLine;
	g_bParseError = false;

	TRACE_LINE(pch);
}

void EndParse()
{
	g_szFileName = NULL;
	g_nLine = 0;
}

void SyntaxError(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, countof (szBuffer), szMsg, args);

	TCHAR szMessage [1024];
	_stprintf(szMessage, _T("Syntax Error\n\nFile: %s\nLine: %d\n\n%s"), g_szFileName, g_nLine, szBuffer);

#ifdef _WINDOWS
	XAppMessageBox(szMessage);
#else
	Trace(_T("\007%s\n"), szMessage);
#endif

	va_end(args);

	g_bParseError = true;
}

const TCHAR* SkipWhite(const TCHAR* pch, COMMENT_TYPE ct)
{
	for (;;)
	{
		while (*pch != '\0' && *pch <= ' ')
		{
			if (*pch == '\n')
			{
				g_nLine += 1;
				TRACE_LINE(pch + 1);
			}

			pch += 1;
		}

		if (((ct & pound) && *pch == '#') || ((ct & slashslash) && *pch == '/' && *(pch + 1) == '/'))
		{
			if (*pch == '#')
			{
				pch += 1;
				while (*pch == ' ' || *pch == '\t')
					pch += 1;

				if (_tcsncmp(pch, _T("line"), 4) == 0)
				{
					pch += 4;
					while (*pch == ' ' || *pch == '\t')
						pch += 1;
					g_nLine = _ttoi(pch) - 1; // -1 since we will add one at eol...
				}
				else if (_tcsncmp(pch, _T("file"), 4) == 0)
				{
					pch += 4;
					while (*pch == ' ' || *pch == '\t')
						pch += 1;

					TCHAR* pchDest = g_szFileNameBuf;
					if (*pch == '"')
						pch += 1;
					while (*pch != '\0' && *pch != '\r' && *pch != '\n' && *pch != '"')
						*pchDest++ = *pch++;
					*pchDest = 0;

					g_szFileName = g_szFileNameBuf;
				}
			}

			while (*pch != '\0' && *pch != '\r' && *pch != '\n')
				pch += 1;
		}
		else if ((ct & slashstar) && *pch == '/' && *(pch + 1) == '*')
		{
			pch += 2;
			while (*pch != '\0' && !(*pch == '*' && *(pch + 1) == '/'))
			{
				if (*pch == '\n')
				{
					g_nLine += 1;
					TRACE_LINE(pch + 1);
				}

				pch += 1;
			}

			if (*pch != '\0')
				pch += 2;
		}
		else
		{
			return pch;
		}
	}
}

const TCHAR* Token(const TCHAR* pch, const TCHAR*& pchToken, int& cchToken, bool bAllowPaths/*=false*/, COMMENT_TYPE ct/*=any*/)
{
	pch = SkipWhite(pch, ct);

	BOOL bQuoted = FALSE;
	TCHAR chQuote = 0;
	if (*pch == '"' || *pch == '\'')
	{
		bQuoted = TRUE;
		chQuote = *pch;
		pch += 1;
	}

	pchToken = pch;

	if (bQuoted)
	{
		while (*pch != '\0' && *pch != chQuote)
		{
			if (*pch == '\\' && *(pch + 1) != '\0')
				pch += 1;
			pch += 1;
		}
	}
	else if (bAllowPaths)
	{
		while (*pch != '\0' && *pch > ' ')
			pch += 1;
	}
	else if ((*pch >= 'a' && *pch <= 'z' || *pch >= 'A' && *pch <= 'Z' || *pch == '_'))
	{
		while (*pch >= 'a' && *pch <= 'z' || *pch >= 'A' && *pch <= 'Z' || *pch >= '0' && *pch <= '9' || *pch == '_')
			pch += 1;
	}
	else
	{
		BOOL bAlNum = IsAlNum(*pch);
		if (bAlNum)
		{
			while (IsAlNum(*pch))
				pch += 1;
		}
		else
		{
			while (*pch > ' ' && !IsAlNum(*pch))
				pch += 1;
		}
	}

	cchToken = (int)(pch - pchToken);

	if (bQuoted && *pch == chQuote)
		pch += 1;

	return pch;
}


const TCHAR* ParseBoolean(const TCHAR* pch, bool& b)
{
	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);

	if (_tcsnicmp(pchToken, _T("true"), cchToken) == 0)
		b = true;
	else if (_tcsnicmp(pchToken, _T("false"), cchToken) == 0)
		b = false;
	else
		SyntaxError(_T("Invalid boolean value"));

	return pch;
}

const TCHAR* ParseInteger(const TCHAR* pch, int& i)
{
	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);

	TCHAR szBuf [64];
	ASSERT(cchToken < countof(szBuf));
	_tcsncpy(szBuf, pchToken, cchToken);
	szBuf[cchToken] = 0;

	i = _ttoi(szBuf);

	return pch;
}

const TCHAR* ParseNumber(const TCHAR* pch, float& n)
{
	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);

	TCHAR szBuf [64];
	ASSERT(cchToken < countof(szBuf));
	_tcsncpy(szBuf, pchToken, cchToken);
	szBuf[cchToken] = 0;

	n = (float)_tcstod(szBuf, NULL);

	return pch;
}

const TCHAR* ParseString(const TCHAR* pch, TCHAR*& sz)
{
	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);
	
	sz = new TCHAR [cchToken + 1];
	CopyChars(sz, pchToken, cchToken);
	sz[cchToken] = '\0';

	return pch;
}

const TCHAR* ParseVec3(const TCHAR* pch, float v[3])
{
	pch = ParseNumber(pch, v[0]);
	pch = ParseNumber(pch, v[1]);
	pch = ParseNumber(pch, v[2]);

	return pch;
}

const TCHAR* ParseVec4(const TCHAR* pch, float v[4])
{
	pch = ParseNumber(pch, v[0]);
	pch = ParseNumber(pch, v[1]);
	pch = ParseNumber(pch, v[2]);
	pch = ParseNumber(pch, v[3]);

	return pch;
}

const TCHAR* ParseIntArray(const TCHAR* pch, BYTE*& pbArray, int& cbArray)
{
	pch = SkipWhite(pch);

	if (*pch != '[')
	{
		SyntaxError(_T("Expected '[' to start array"));
		return _T("");
	}

	pch += 1;

	const TCHAR* pchStart = pch;
	int nLineStart = g_nLine;
	int nValues = 0;

	for (;;)
	{
		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

		int n;
		pch = ParseInteger(pch, n);
		nValues += 1;

		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

/*
		if (*pch != ',')
		{
			SyntaxError(_T("Expected ']' or ','"));
			return _T("");
		}

		pch += 1;
*/
		if (*pch == ',')
			pch += 1;
	}

	cbArray = nValues * sizeof (int);
	pbArray = new BYTE [cbArray];

	BYTE* pb = pbArray;

	pch = pchStart;
	g_nLine = nLineStart;
	for (;;)
	{
		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

		int n;
		pch = ParseInteger(pch, n);
		*(int*)pb = n;
		pb += sizeof (int);

		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

/*
		if (*pch != ',')
		{
			SyntaxError(_T("Expected ']' or ','"));
			return _T("");
		}

		pch += 1;
*/
		if (*pch == ',')
			pch += 1;
	}

	return pch + 1;
}

const TCHAR* ParseVecArray(const TCHAR* pch, BYTE*& pbArray, int& cbArray, int nVecSize)
{
	ASSERT(nVecSize > 0 && nVecSize <= 4);

	pch = SkipWhite(pch);

	if (*pch != '[')
	{
		SyntaxError(_T("Expected '[' to start array"));
		return _T("");
	}

	pch += 1;

	const TCHAR* pchStart = pch;
	int nLineStart = g_nLine;
	int nValues = 0;

	for (;;)
	{
		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

		for (int i = 0; i < nVecSize; i += 1)
		{
			float n;
			pch = ParseNumber(pch, n);
			nValues += 1;
		}

		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

/*
		if (*pch != ',')
		{
			SyntaxError(_T("Expected ']' or ','"));
			return _T("");
		}

		pch += 1;
*/
		if (*pch == ',')
			pch += 1;
	}

	cbArray = nValues * sizeof (float);
	pbArray = new BYTE [cbArray];

	BYTE* pb = pbArray;

	pch = pchStart;
	g_nLine = nLineStart;
	for (;;)
	{
		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

		for (int i = 0; i < nVecSize; i += 1)
		{
			float n;
			pch = ParseNumber(pch, n);
			*(float*)pb = n;
			pb += sizeof (float);
		}

		pch = SkipWhite(pch);

		if (*pch == ']')
			break;

/*
		if (*pch != ',')
		{
			SyntaxError(_T("Expected ']' or ','"));
			return _T("");
		}

		pch += 1;
*/
		if (*pch == ',')
			pch += 1;
	}

	return pch + 1;
}


int ExpandCString(TCHAR* szString, int cchMaxString, const TCHAR* pchToken, int cchToken)
{
	TCHAR* pchString = szString;
	while (cchToken > 0)
	{
		if (pchString >= szString + cchMaxString)
		{
			SyntaxError(_T("string constant is too long"));
			return -1;
		}

		if (*pchToken == '\\')
		{
			pchToken += 1;
			cchToken -= 1;
			if (cchToken == 0)
			{
				SyntaxError(_T("backslash at end of string"));
				return -1;
			}

			TCHAR ch = *pchToken++;
			cchToken -= 1;
			switch (ch)
			{
			case 'b':
				*pchString++ = '\b';
				break;

			case 'f':
				*pchString++ = '\f';
				break;

			case 'n':
				*pchString++ = '\n';
				break;

			case 'r':
				*pchString++ = '\r';
				break;

			case 't':
				*pchString++ = '\t';
				break;

			case 'x':
				{
					if (cchToken < 2)
					{
						SyntaxError(_T("Invalid hex character escape sequence"));
						return -1;
					}

					ch = 0;
					for (int i = 0; i < 2; i += 1)
					{
						TCHAR chHex = *pchToken++;
						cchToken -= 1;

						if (chHex >= '0' && chHex <= '9')
						{
							ch = 16 * ch + chHex - '0';
						}
						else if (chHex >= 'A' && chHex <= 'F')
						{
							ch = 16 * ch + chHex - 'A' + 10;
						}
						else if (chHex >= 'a' && chHex <= 'f')
						{
							ch = 16 * ch + chHex - 'a' + 10;
						}
						else
						{
							SyntaxError(_T("Invalid hex character"));
							return -1;
						}
					}
					*pchString++ = ch;
				}
				break;

#ifdef _UNICODE
			case 'u':
				{
					if (cchToken < 4)
					{
						SyntaxError(_T("Invalid Unicode character escape sequence"));
						return -1;
					}

					ch = 0;
					for (int i = 0; i < 4; i += 1)
					{
						TCHAR chHex = *pchToken++;
						cchToken -= 1;

						if (chHex >= '0' && chHex <= '9')
						{
							ch = 16 * ch + chHex - '0';
						}
						else if (chHex >= 'A' && chHex <= 'F')
						{
							ch = 16 * ch + chHex - 'A' + 10;
						}
						else if (chHex >= 'a' && chHex <= 'f')
						{
							ch = 16 * ch + chHex - 'a' + 10;
						}
						else
						{
							SyntaxError(_T("Invalid Unicode character"));
							return -1;
						}
					}
					*pchString++ = ch;
				}
				break;
#endif

			default:
				if (ch >= '0' && ch <= '7')
				{
					if (ch == '0' && cchToken > 0 && *pchToken < '0' || *pchToken > '7')
					{
						*pchString++ = '\0';
					}
					else
					{
						ch -= '0';
						while (cchToken != 0 && *pchToken >= '0' && *pchToken <= '7')
						{
							ch = ch * 8 + *pchToken - '0';
							pchToken += 1;
							cchToken -= 1;
						}

						*pchString++ = ch;
					}
				}
				else
				{
					// REVIEW: Here we deal with \' \" and \\ as well as ignoring the \ for "unknown" escape sequences...
					// Should Unknown escapes cause an error?
					*pchString++ = ch;
				}
				break;
			}
		}
		else
		{
			*pchString++ = *pchToken++;
			cchToken -= 1;
		}
	}
	
	return (int)(pchString - szString);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Locale.h ===
#pragma once

#define LOCALE_FROM_REGION_LANGUAGE(region, language)	(((region) << 16) | (language))
#define LANGUAGE_FROM_LOCALE(locale) ((locale) & 0x0000ffff)
#define REGION_FROM_LOCALE(locale) (((locale) >> 16) & 0x0000ffff)

#define REGION_AMERICA				0
#define REGION_EUROPE				1
#define REGION_ASIA					2

#define MAX_TRANSLATE_LEN           1024
#define MAX_LANGUAGE_CODE_LEN       3

#define LANGUAGE_CURRENT			-1
#define LANGUAGE_ENGLISH			0
#define LANGUAGE_JAPANESE			1
#define LANGUAGE_GERMAN				2
#define LANGUAGE_FRENCH				3
#define LANGUAGE_SPANISH			4
#define LANGUAGE_ITALIAN			5

#define LANGUAGE_COUNT				6

#define LOCALE_CURRENT				-1
#define LOCALE_NA_ENGLISH		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_NA, LANGUAGE_ENGLISH)
#define LOCALE_NA_JAPANESE		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_NA, LANGUAGE_JAPANESE)
#define LOCALE_NA_GERMAN		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_NA, LANGUAGE_GERMAN)
#define LOCALE_NA_FRENCH		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_NA, LANGUAGE_FRENCH)
#define LOCALE_NA_SPANISH		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_NA, LANGUAGE_SPANISH)
#define LOCALE_NA_ITALIAN		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_NA, LANGUAGE_ITALIAN)
#define LOCALE_JAPAN_ENGLISH		LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_JAPAN, LANGUAGE_ENGLISH)
#define LOCALE_JAPAN_JAPANESE		LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_JAPAN, LANGUAGE_JAPANESE)
#define LOCALE_JAPAN_GERMAN		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_JAPAN, LANGUAGE_GERMAN)
#define LOCALE_JAPAN_FRENCH		    LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_JAPAN, LANGUAGE_FRENCH)
#define LOCALE_JAPAN_SPANISH		LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_JAPAN, LANGUAGE_SPANISH)
#define LOCALE_JAPAN_ITALIAN		LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_JAPAN, LANGUAGE_ITALIAN)
#define LOCALE_RESTOFWORLD_ENGLISH	LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_RESTOFWORLD, LANGUAGE_ENGLISH)
#define LOCALE_RESTOFWORLD_JAPANESE	LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_RESTOFWORLD, LANGUAGE_JAPANESE)
#define LOCALE_RESTOFWORLD_GERMAN	LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_RESTOFWORLD, LANGUAGE_GERMAN)
#define LOCALE_RESTOFWORLD_FRENCH	LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_RESTOFWORLD, LANGUAGE_FRENCH)
#define LOCALE_RESTOFWORLD_SPANISH	LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_RESTOFWORLD, LANGUAGE_SPANISH)
#define LOCALE_RESTOFWORLD_ITALIAN	LOCALE_FROM_REGION_LANGUAGE(XC_GAME_REGION_RESTOFWORLD, LANGUAGE_ITALIAN)

extern void FormatInteger(TCHAR* szBuf, int nNumber, int locale = LOCALE_CURRENT);
extern void FormatBlocks(TCHAR* szBuf, int nNumber, int locale = LOCALE_CURRENT);
extern bool FormatTime(TCHAR* szBuf, SIZE_T chLen, SYSTEMTIME* pst, int locale = LOCALE_CURRENT);
extern const TCHAR* Translate(const TCHAR* szString, TCHAR* szTranslate, int nLanguage = LANGUAGE_CURRENT);

extern int g_nCurLanguage;
extern int g_nCurRegion;

const TCHAR* GetLanguageCode(TCHAR* sz);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Math.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"


CMathClass g_Math;

// TODO: Need a way to expose class properties...

START_NODE_FUN(CMathClass, CNodeClass)
	NODE_FUN_NN(abs)
	NODE_FUN_NN(acos)
	NODE_FUN_NN(asin)
	NODE_FUN_NN(atan)
	NODE_FUN_NNN(atan2)
	NODE_FUN_NN(ceil)
	NODE_FUN_NN(cos)
	NODE_FUN_NN(exp)
	NODE_FUN_NN(floor)
	NODE_FUN_NN(log)
	NODE_FUN_NNN(max)
	NODE_FUN_NNN(min)
	NODE_FUN_NNN(pow)
	NODE_FUN_NV(random)
	NODE_FUN_NN(round)
	NODE_FUN_NN(sin)
	NODE_FUN_NN(sqrt)
	NODE_FUN_NN(tan)
END_NODE_FUN()


CMathClass::CMathClass() : CNodeClass(_T("Math"), 0, NULL, NULL, NULL)
{
	m_E = 2.7182818284590452354f;
	m_LN2 = 0.69314718055994530942f;
	m_LN10 = 2.30258509299404568402f;
	m_LOG2E = 1.442f;
	m_LOG10E = 0.434f;
	m_PI = 3.14159265358979323846f;
	m_SQRT1_2 = 0.70710678118654752440f;
	m_SQRT2 = 1.41421356237309504880f;
}

void CMathClass::AddRef()
{
	// not reference counted!
}

void CMathClass::Release()
{
	// not reference counted!
}

float CMathClass::abs(float number)
{
	return ::fabsf(number);
}

float CMathClass::acos(float number)
{
	return ::acosf(number);
}

float CMathClass::asin(float number)
{
	return ::asinf(number);
}

float CMathClass::atan(float number)
{
	return ::atanf(number);
}

float CMathClass::atan2(float y, float x)
{
	return ::atan2f(x, y);
}

float CMathClass::ceil(float number)
{
	return ::ceilf(number);
}

float CMathClass::cos(float number)
{
	return ::cosf(number);
}

float CMathClass::exp(float number)
{
	return ::expf(number);
}

float CMathClass::floor(float number)
{
	return ::floorf(number);
}

float CMathClass::log(float number)
{
	return ::logf(number);
}

float CMathClass::max(float number1, float number2)
{
	if (number1 > number2)
		return number1;
	else
		return number2;
}

float CMathClass::min(float number1, float number2)
{
	if (number1 < number2)
		return number1;
	else
		return number2;
}

float CMathClass::pow(float base, float exponent)
{
	return ::powf(base, exponent);
}

float CMathClass::random()
{
	return (float)rand() / (float)RAND_MAX;
}

float CMathClass::round(float number)
{
	return (float)((int)(number + 0.5f));
}

float CMathClass::sin(float number)
{
	return ::sinf(number);
}

float CMathClass::sqrt(float number)
{
	return ::sqrtf(number);
}

float CMathClass::tan(float number)
{
	return ::tanf(number);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\MaxMat.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Shape.h"

extern class CMeshNode* g_pRenderMeshNode;
extern void SetFalloffShaderValues(const D3DXCOLOR& sideColor, const D3DXCOLOR& frontColor);
extern DWORD GetEffectShader(int nEffect, DWORD fvf);
extern LPDIRECT3DTEXTURE8 CreateTexture(int& nWidth, int& nHeight, D3DFORMAT format);
extern LPDIRECT3DTEXTURE8 GetTexture(const TCHAR* szURL, XTIME* pTimeLoaded = NULL, UINT width=0, UINT height=0, bool binXIP=false);
extern void SetReflectShaderFrameValues();

BOOL g_bEdgeAntialiasOverride; //REVIEW: Hackorama!
const TCHAR* g_szCurTitleImage; // REVIEW: Hackorama!
const TCHAR* g_szSelTitleImage; // REVIEW: Hackorama!
bool g_bActiveKey = false; // REVIEW: Hackorama!
extern float g_nEffectAlpha;
extern D3DRECT g_scissorRect;
extern D3DRECT g_scissorRectx2;
XTIME g_pulseStartTime;
static class CMaxMaterial* g_pLastPulseMaxMat = NULL;

class CMaxMaterial : public CMaterial
{
	DECLARE_NODE(CMaxMaterial, CMaterial)
public:
	CMaxMaterial();
	~CMaxMaterial();

	TCHAR* m_name;
	XTIME m_param;

	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	void Render();

	class CMatInfo* m_pMatInfo;

	DECLARE_NODE_PROPS()
};

////////////////////////////////////////////////////////////////////////////

void GenerateRadialAlphaMask(BYTE* pbPels, int nPitch, int nWidth, int nHeight, float nFactor, float nMax, float nScale = 1.0f)
{
    LPDWORD pdwPels = (LPDWORD)pbPels;
    int nRadialWidth = (int)((float)nWidth * nScale);
    int nRadialHeight = (int)((float)nHeight * nScale);
    int x, y;

	for (y = 0; y < nRadialHeight; y += 1)
	{
		for (x = 0; x < nRadialWidth; x += 1)
		{
			float cx = (float)(x - nRadialWidth / 2) / (nRadialWidth / 2);
			float cy = (float)(y - nRadialHeight / 2) / (nRadialHeight / 2);
			float d = sqrtf(cx * cx + cy * cy);

			if (d < 0.0f)
				d = 0.0f;
			else if (d > 1.0f)
				d = 1.0f;

			float a = 1.0f - d;

			a = a * nFactor;

			if (a < 0.0f)
				a = 0.0f;
			else if (a > nMax)
				a = nMax;

            pdwPels[x] = ((BYTE)(a * 255.0f)) << 24;
		}

        for (; x < nWidth; x += 1)
        {
            pdwPels[x] = 0;
        }

        pdwPels += (nPitch >> 2);
	}

	for (; y < nHeight; y += 1)
	{
        memset(pdwPels, 0, nWidth << 2);
        pdwPels += (nPitch >> 2);
    }
}

LPDIRECT3DTEXTURE8 GetRadialAlphaMask()
{
	static LPDIRECT3DTEXTURE8 pTexture = NULL;

	if (pTexture != NULL)
		return pTexture;

	int nWidth = 256;
	int nHeight = 256;
	pTexture = CreateTexture(nWidth, nHeight, D3DFMT_A8R8G8B8);
	ASSERT(pTexture != NULL);

	D3DLOCKED_RECT lr;
	VERIFYHR(pTexture->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));

#ifdef _XBOX
	BYTE* pbBuf = new BYTE [4 * nWidth * nHeight];
	GenerateRadialAlphaMask(pbBuf, nWidth * 4, nWidth, nHeight, 1.0f, 1.0f);
	XGSwizzleRect(pbBuf, 0, NULL, lr.pBits, nWidth, nHeight, NULL, 4);
	delete [] pbBuf;
#else
	GenerateRadialAlphaMask((BYTE*)lr.pBits, lr.Pitch, nWidth, nHeight, 1.0f, 1.0f);
#endif

	VERIFYHR(pTexture->UnlockRect(0));

	return pTexture;
}

LPDIRECT3DTEXTURE8 GetRadialAVAlphaMask()
{
	static LPDIRECT3DTEXTURE8 pTexture = NULL;

	if (pTexture != NULL)
		return pTexture;

	int nWidth = 256;
	int nHeight = 256;
	pTexture = CreateTexture(nWidth, nHeight, D3DFMT_A8R8G8B8);
	ASSERT(pTexture != NULL);

	D3DLOCKED_RECT lr;
	VERIFYHR(pTexture->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));

#ifdef _XBOX
	BYTE* pbBuf = new BYTE [4 * nWidth * nHeight];
	GenerateRadialAlphaMask(pbBuf, nWidth * 4, nWidth, nHeight, 1.0f, 1.0f, 0.6875f);
	XGSwizzleRect(pbBuf, 0, NULL, lr.pBits, nWidth, nHeight, NULL, 4);
	delete [] pbBuf;
#else
	GenerateRadialAlphaMask((BYTE*)lr.pBits, lr.Pitch, nWidth, nHeight, 1.0f, 1.0f);
#endif

	VERIFYHR(pTexture->UnlockRect(0));

	return pTexture;
}

LPDIRECT3DTEXTURE8 GetRadialEdgeAlphaMask()
{
	static LPDIRECT3DTEXTURE8 pTexture = NULL;

	if (pTexture != NULL)
		return pTexture;

	int nWidth = 256;
	int nHeight = 256;
	pTexture = CreateTexture(nWidth, nHeight, D3DFMT_A8R8G8B8);
	ASSERT(pTexture != NULL);

	D3DLOCKED_RECT lr;
	VERIFYHR(pTexture->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));

#ifdef _XBOX
	BYTE* pbBuf = new BYTE [4 * nWidth * nHeight];
	GenerateRadialAlphaMask(pbBuf, nWidth * 4, nWidth, nHeight, 10.0f, 0.8f);
	XGSwizzleRect(pbBuf, 0, NULL, lr.pBits, nWidth, nHeight, NULL, 4);
	delete [] pbBuf;
#else
	GenerateRadialAlphaMask((BYTE*)lr.pBits, lr.Pitch, nWidth, nHeight, 10.0f, 0.8f);
#endif

	VERIFYHR(pTexture->UnlockRect(0));

	return pTexture;
}

LPDIRECT3DTEXTURE8 GetRadialEdgeAlphaMainMask()
{
	static LPDIRECT3DTEXTURE8 pTexture = NULL;

	if (pTexture != NULL)
		return pTexture;

	int nWidth = 256;
	int nHeight = 256;
	pTexture = CreateTexture(nWidth, nHeight, D3DFMT_A8R8G8B8);
	ASSERT(pTexture != NULL);

	D3DLOCKED_RECT lr;
	VERIFYHR(pTexture->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));

#ifdef _XBOX
	BYTE* pbBuf = new BYTE [4 * nWidth * nHeight];
	GenerateRadialAlphaMask(pbBuf, nWidth * 4, nWidth, nHeight, 3.0f, 1.0f);
	XGSwizzleRect(pbBuf, 0, NULL, lr.pBits, nWidth, nHeight, NULL, 4);
	delete [] pbBuf;
#else
	GenerateRadialAlphaMask((BYTE*)lr.pBits, lr.Pitch, nWidth, nHeight, 3.0f, 1.0f);
#endif

	VERIFYHR(pTexture->UnlockRect(0));

	return pTexture;
}

////////////////////////////////////////////////////////////////////////////

#define MATINFO_STANDARD_MATERIAL		0x00000001
#define MATINFO_CULL_NONE				0x00000002
#define MATINFO_RADIAL_ALPHA			0x00000004
#define MATINFO_RADIAL_EDGE_ALPHA		0x00000008
#define MATINFO_RADIAL_EDGE_MAIN_ALPHA	0x00000010
#define MATINFO_RADIAL_AV_ALPHA			0x00000020

class CMatInfo
{
public:
	CMatInfo(const TCHAR* szName, DWORD dwFlags = 0);

	virtual bool Setup(CMaxMaterial* pMaxMat);

	const TCHAR* m_szName;
	DWORD m_dwFlags;
};

class CSolidMatInfo : public CMatInfo
{
public:
	CSolidMatInfo(const TCHAR* szName, BYTE r, BYTE g, BYTE b, BYTE a, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);

	BYTE m_r, m_g, m_b, m_a;
};

class CFalloffMatInfo : public CMatInfo
{
public:
	CFalloffMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);

	D3DCOLOR m_colorSide;
	D3DCOLOR m_colorFront;
	int m_nShaderEffect;
	TCHAR m_matName[MAX_PATH];
};

class CFalloffTexInfo : public CMatInfo
{
public:
	CFalloffTexInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);

	D3DCOLOR m_colorSide;
	D3DCOLOR m_colorFront;
	int m_nShaderEffect;
};

class CAnisoMatInfo : public CMatInfo
{
public:
	CAnisoMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);

	D3DCOLOR m_colorSide;
	D3DCOLOR m_colorFront;
	int m_nShaderEffect;
};

class CIconMatInfo : public CMatInfo
{
public:
	CIconMatInfo(const TCHAR* szName, UINT width, UINT height, bool bFadeIn = false, bool binXIP = false, bool bSelImg = false);

	bool Setup(CMaxMaterial* pMaxMat);

	bool m_bFadeIn;
	bool m_binXIP;
	bool m_bSelImg;

private:
    UINT m_width, m_height;
};

class CKeyMatInfo : public CFalloffMatInfo
{
public:
	CKeyMatInfo(const TCHAR* szName, bool bBright, bool bText);

	bool Setup(CMaxMaterial* pMaxMat);

	bool m_bBright;
	bool m_bText;
};

class CEggGlowPulseMatInfo : public CFalloffMatInfo
{
public:
	CEggGlowPulseMatInfo(const TCHAR* szName);

	bool Setup(CMaxMaterial* pMaxMat);
};

class CEggGlowFadeMatInfo : public CFalloffMatInfo
{
public:
	CEggGlowFadeMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);
};

class CBackingMatInfo : public CMatInfo
{
public:
	CBackingMatInfo(const TCHAR* szName, BYTE r, BYTE g, BYTE b, BYTE a, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);

	BYTE m_r, m_g, m_b, m_a;
};

class CModulateTextureMatInfo : public CMatInfo
{
public:
	CModulateTextureMatInfo(const TCHAR* szName, BYTE r, BYTE g, BYTE b, BYTE a, DWORD dwFlags/*=0*/);

	bool Setup(CMaxMaterial* pMaxMat);

	BYTE m_r, m_g, m_b, m_a;
};

class CReflectMatInfo : public CMatInfo
{
public:
	CReflectMatInfo(const TCHAR* szName);

	bool Setup(CMaxMaterial* pMaxMat);
	
	int m_nShaderEffect;
};

class CMaskTextureMatInfo : public CMatInfo
{
public:
	CMaskTextureMatInfo(const TCHAR* szName, DWORD dwFlags);

	bool Setup(CMaxMaterial* pMaxMat);
};

class CFreeSpaceMatInfo : public CMatInfo
{
public:
	CFreeSpaceMatInfo(const TCHAR* szName);

	bool Setup(CMaxMaterial* pMaxMat);
};

class CInnerWallMatInfo : public CMatInfo
{
public:
	CInnerWallMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags = 0);

	bool Setup(CMaxMaterial* pMaxMat);

	D3DCOLOR m_colorSide;
	D3DCOLOR m_colorFront;
	int m_nShaderEffect;
};


CMatInfo* g_rgMatInfo [120];
int g_nMatInfoCount = 0;


////////////////////////////////////////////////////////////////////////////


CInnerWallMatInfo::CInnerWallMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_nShaderEffect = 3;
	m_colorSide = colorSide;
	m_colorFront = colorFront;
}
bool CInnerWallMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_pRenderMeshNode == NULL)
		return false;

	XAppSetVertexShader(GetEffectShader(m_nShaderEffect, g_pRenderMeshNode->GetFVF()));
	SetFalloffShaderValues(m_colorSide, m_colorFront);

	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	XAppSetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);

	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

	XAppSetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	return CMatInfo::Setup(pMaxMat);
}


CFreeSpaceMatInfo::CFreeSpaceMatInfo(const TCHAR* szName) :
	CMatInfo(szName)
{
}

bool CFreeSpaceMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	// This is the free/used space guage texture for memory units...
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
//	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
//	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(255, 255, 255, (BYTE)(128 * g_nEffectAlpha)));
	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(255, 255, 255, (BYTE)(70 * g_nEffectAlpha)));
	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

	D3DXMATRIX mat;
	D3DXMatrixIdentity(&mat);
	mat._32 = (float) ((1.0f - pMaxMat->m_param) * 2.0f - 1.0f) * 0.3f + 0.1f;
	XAppSetTransform(D3DTS_TEXTURE0, &mat);
	XAppSetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);
	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

	return true;
}

CMaskTextureMatInfo::CMaskTextureMatInfo(const TCHAR* szName, DWORD dwFlags) :
	CMatInfo(szName, dwFlags)
{
}

bool CMaskTextureMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if ((m_dwFlags & MATINFO_RADIAL_ALPHA) != 0)
		XAppSetTexture(1, GetRadialAlphaMask());
	else if ((m_dwFlags & MATINFO_RADIAL_EDGE_ALPHA) != 0)
		XAppSetTexture(1, GetRadialEdgeAlphaMask());
	else if ((m_dwFlags & MATINFO_RADIAL_EDGE_MAIN_ALPHA) != 0)
		XAppSetTexture(1, GetRadialEdgeAlphaMainMask());
    else if ((m_dwFlags & MATINFO_RADIAL_AV_ALPHA) != 0)
        XAppSetTexture(1, GetRadialAVAlphaMask());

	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_CURRENT);
	XAppSetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_ADD);
	XAppSetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);
	XAppSetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 0);

	XAppSetTextureStageState(2, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(2, D3DTSS_COLORARG1, D3DTA_CURRENT);
	XAppSetTextureStageState(2, D3DTSS_COLORARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(2, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(2, D3DTSS_ALPHAARG1, D3DTA_CURRENT);
	XAppSetTextureStageState(2, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);

	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(0, 0, 0, (BYTE)(255.0f * g_nEffectAlpha)));

	return CMatInfo::Setup(pMaxMat);
}

CModulateTextureMatInfo::CModulateTextureMatInfo(const TCHAR* szName, BYTE r, BYTE g, BYTE b, BYTE a, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_r = r;
	m_g = g;
	m_b = b;
	m_a = a;
}

bool CModulateTextureMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
//	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);

	if (g_pLastPulseMaxMat != pMaxMat && g_nEffectAlpha == 1.0f)
	{
//		TRACE(_T("Resetting pulse (hilite) 0x%08x\n"), pMaxMat);
		g_pLastPulseMaxMat = pMaxMat;
		g_pulseStartTime = XAppGetNow();
	}

	float t = (float) (XAppGetNow() - g_pulseStartTime) / 2.0f;
	float a = 1.0f - fabsf(sinf(t * D3DX_PI));

	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(m_r, m_g, m_b, (BYTE)(m_a * (a * 0.25f + 0.75f) * g_nEffectAlpha)));

	// Edge Aliasing mode enable
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
//	XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN);
//	XAppGetD3DDev()->SetScissors(1, FALSE, &g_scissorRectx2);

	return CMatInfo::Setup(pMaxMat);
}

CReflectMatInfo::CReflectMatInfo(const TCHAR* szName) :
	CMatInfo(szName, 0)
{
	m_nShaderEffect = 4;
}

bool CReflectMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_pRenderMeshNode == NULL)
		return false;

	XAppSetVertexShader(GetEffectShader(m_nShaderEffect, g_pRenderMeshNode->GetFVF()));
	SetFalloffShaderValues(D3DCOLOR_RGBA(229, 229, 229, 0), D3DCOLOR_RGBA(229, 229, 229, 255));

	SetReflectShaderFrameValues();

	XAppSetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

	//XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(0, 0, 0, (BYTE)(255.0f * g_nEffectAlpha)));

	return CMatInfo::Setup(pMaxMat);
}

CBackingMatInfo::CBackingMatInfo(const TCHAR* szName, BYTE r, BYTE g, BYTE b, BYTE a, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_r = r;
	m_g = g;
	m_b = b;
	m_a = a;
}

bool CBackingMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if ((m_dwFlags & MATINFO_RADIAL_ALPHA) != 0)
		XAppSetTexture(0, GetRadialAlphaMask());
	else if ((m_dwFlags & MATINFO_RADIAL_EDGE_ALPHA) != 0)
		XAppSetTexture(0, GetRadialEdgeAlphaMask());
	else if ((m_dwFlags & MATINFO_RADIAL_EDGE_MAIN_ALPHA) != 0)
		XAppSetTexture(0, GetRadialEdgeAlphaMainMask());
    else if ((m_dwFlags & MATINFO_RADIAL_AV_ALPHA) != 0)
        XAppSetTexture(0, GetRadialAVAlphaMask());

	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(m_r, m_g, m_b, (BYTE)(m_a * g_nEffectAlpha)));
	//XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(m_r, m_g, m_b, (BYTE)()));

	return CMatInfo::Setup(pMaxMat);
}


CEggGlowPulseMatInfo::CEggGlowPulseMatInfo(const TCHAR* szName) :
	CFalloffMatInfo(szName, 0, D3DCOLOR_RGBA(0, 0, 0, 0), D3DCOLOR_RGBA(0, 0, 0, 0))
{
}

bool CEggGlowPulseMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_pLastPulseMaxMat != pMaxMat)
	{
		//TRACE(_T("Resetting pulse (egg)\n"));
		g_pLastPulseMaxMat = pMaxMat;
		//g_pulseStartTime = XAppGetNow();
		g_pulseStartTime = 2.0f;
	}

	float t = (float) (XAppGetNow() - g_pulseStartTime) / 2.0f;
	float a = 1.0f - fabsf(sinf(t * D3DX_PI));

	//m_colorSide = D3DCOLOR_RGBA(252, 255, 0, 0);
	//m_colorFront = D3DCOLOR_RGBA(255, 255, 128, (int)(64.0f + 64.0f * a));

#ifdef COOL_XDASH
	m_colorSide = D3DCOLOR_RGBA(0, 146, 208, 0);
	m_colorFront = D3DCOLOR_RGBA(128, 236, 255, (int)(64.0f + 128.0f * a));
#else
	m_colorSide = D3DCOLOR_RGBA(178, 208, 0, 0);
	m_colorFront = D3DCOLOR_RGBA(255, 255, 128, (int)(64.0f + 128.0f * a));
#endif
	
	//m_colorSide = D3DCOLOR_RGBA(178, 208, 0, (int)(64.0f + 191.0f * a));
	//m_colorFront = D3DCOLOR_RGBA(178, 208, 0, (int)(64.0f + 191.0f * a));

	return CFalloffMatInfo::Setup(pMaxMat);
}

CEggGlowFadeMatInfo::CEggGlowFadeMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags) :
	CFalloffMatInfo(szName, dwFlags, colorSide, colorFront)
{
}

bool CEggGlowFadeMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	float a = 0.0f;

	if (pMaxMat->m_param == 1.0f)
	{
		pMaxMat->m_param = XAppGetNow();
		ASSERT(pMaxMat->m_param > 1.0f);
	}

	if (pMaxMat->m_param > 0.0f)
	{
		float t = (float) (XAppGetNow() - pMaxMat->m_param) / 1.25f;
		if (t >= 1.0f)
		{
			t = 1.0f;
			pMaxMat->m_param = 0.0f;
		}

		a = 1.0f - t;
	}

	m_colorFront = D3DCOLOR_RGBA(254, 255, 188, (int)(255.0f * a));

	return CFalloffMatInfo::Setup(pMaxMat);
}

CKeyMatInfo::CKeyMatInfo(const TCHAR* szName, bool bBright, bool bText) :
	CFalloffMatInfo(szName, D3DCOLOR_RGBA(0, 0, 0, 0), D3DCOLOR_RGBA(0, 0, 0, 0), 0)
{
	m_bBright = bBright;
	m_bText = bText;
}

bool CKeyMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_bActiveKey)
	{
		if (g_pLastPulseMaxMat != pMaxMat && g_nEffectAlpha > 0.0f)
		{
			//TRACE(_T("Resetting pulse (key)\n"));
			g_pLastPulseMaxMat = pMaxMat;
			g_pulseStartTime = XAppGetNow();
		}

		float t = (float) (XAppGetNow() - g_pulseStartTime) / 2.0f;
		float a = fabsf(sinf(t * D3DX_PI));

		if (m_bBright)
		{
#ifdef COOL_XDASH
			m_colorSide = D3DCOLOR_RGBA(0, 146, 208, 255);//D3DCOLOR_RGBA(0, 188, 0, 0);
			m_colorFront = D3DCOLOR_RGBA(0, 146, 208, 190);//D3DCOLOR_RGBA(0, 188, 0, (int)(192.0f + 64.0f * a));
#else
			m_colorSide = D3DCOLOR_RGBA(178, 208, 0, 255);//D3DCOLOR_RGBA(0, 188, 0, 0);
			m_colorFront = D3DCOLOR_RGBA(178, 208, 0, 190);//D3DCOLOR_RGBA(0, 188, 0, (int)(192.0f + 64.0f * a));
#endif
		}
		else
		{
#ifdef COOL_XDASH
			m_colorSide = D3DCOLOR_RGBA(0, 146, 208, 255);//D3DCOLOR_RGBA(0, 188, 0, 0);
			m_colorFront = D3DCOLOR_RGBA(0, 146, 208, 190);//D3DCOLOR_RGBA(0, 188, 0, (int)(128.0f + 64.0f * a));
#else
			m_colorSide = D3DCOLOR_RGBA(178, 208, 0, 255);//D3DCOLOR_RGBA(0, 188, 0, 0);
			m_colorFront = D3DCOLOR_RGBA(178, 208, 0, 190);//D3DCOLOR_RGBA(0, 188, 0, (int)(128.0f + 64.0f * a));
#endif
		}

		if(m_bText)
		{
			XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
			XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
			XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
			XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
			XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
			XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(0, 0, 0, (BYTE)(192 * g_nEffectAlpha)));
		}
	}
	else
	{
		if (m_bBright)
		{
#ifdef COOL_XDASH
			m_colorSide = D3DCOLOR_RGBA(107, 220, 255, 255);
			m_colorFront = D3DCOLOR_RGBA(13, 0, 255, 34);
#else
			m_colorSide = D3DCOLOR_RGBA(243, 255, 107, 255);
			m_colorFront = D3DCOLOR_RGBA(25, 225, 0, 34);
#endif
		}
		else
		{
#ifdef COOL_XDASH
			m_colorSide = D3DCOLOR_RGBA(107, 220, 255, 222);//D3DCOLOR_RGBA(243, 255, 107, 255);
			m_colorFront = D3DCOLOR_RGBA(8, 0, 192, 15);//D3DCOLOR_RGBA(30, 255, 0, 32);
#else
			m_colorSide = D3DCOLOR_RGBA(243, 255, 107, 222);//D3DCOLOR_RGBA(243, 255, 107, 255);
			m_colorFront = D3DCOLOR_RGBA(20, 192, 0, 15);//D3DCOLOR_RGBA(30, 255, 0, 32);
#endif
		}

		if(m_bText)
		{
			XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
			XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
			XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
			XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
			XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
#ifdef COOL_XDASH
			XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(94, 167, 250, (BYTE)(178 * g_nEffectAlpha)));
#else
			XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(190, 250, 94, (BYTE)(178 * g_nEffectAlpha)));
#endif
		}
	}

	// Edge Aliasing mode enable
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
//	XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN);
//	XAppGetD3DDev()->SetScissors(1, FALSE, &g_scissorRectx2);

	return CFalloffMatInfo::Setup(pMaxMat);
}

CIconMatInfo::CIconMatInfo(const TCHAR* szName, UINT width, UINT height, bool bFadeIn/*=false*/, bool binXIP /*=false*/, bool bSelImg) :
	CMatInfo(szName)
{
	m_bFadeIn = bFadeIn;
	m_binXIP = binXIP;
	m_bSelImg = bSelImg;
    m_width = width;
    m_height = height;
}

bool CIconMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	LPDIRECT3DTEXTURE8 pTexture = NULL;
	float alpha = 1.0f;
    bool bInXip = m_binXIP;

	if ((g_szCurTitleImage != NULL) && (!m_bSelImg))
	{
#ifdef COOL_XDASH
		if((_tcsicmp(g_szCurTitleImage, _T("xboxlogo64.xbx.cool")) == 0) ||
		  (_tcsicmp(g_szCurTitleImage, _T("xboxlogo128.xbx.cool")) == 0))
#else
        if((_tcsicmp(g_szCurTitleImage, _T("xboxlogo64.xbx")) == 0) ||
          (_tcsicmp(g_szCurTitleImage, _T("xboxlogo128.xbx")) == 0))
#endif
		{
			bInXip = true;
		}

		XTIME timeLoaded = 0.0f;
		pTexture = GetTexture(g_szCurTitleImage, &timeLoaded, m_width, m_height, bInXip);
		if (pTexture != NULL && m_bFadeIn)
		{
			alpha = (float) (XAppGetNow() - timeLoaded) / 0.25f;
			if (alpha > 1.0f)
				alpha = 1.0f;
		}
	}
	else if ((g_szSelTitleImage != NULL) && (m_bSelImg))  //for the selected image orb
	{
#ifdef COOL_XDASH
		if((_tcsicmp(g_szSelTitleImage, _T("xboxlogo64.xbx.cool")) == 0) ||
		  (_tcsicmp(g_szSelTitleImage, _T("xboxlogo128.xbx.cool")) == 0))
#else
		if((_tcsicmp(g_szSelTitleImage, _T("xboxlogo64.xbx")) == 0) ||
		  (_tcsicmp(g_szSelTitleImage, _T("xboxlogo128.xbx")) == 0))
#endif
		{
			bInXip = true;
		}

		XTIME timeLoaded = 0.0f;
		pTexture = GetTexture(g_szSelTitleImage, &timeLoaded, m_width, m_height, bInXip);
		if (pTexture != NULL && m_bFadeIn)
		{
			alpha = (float) (XAppGetNow() - timeLoaded) / 0.25f;
			if (alpha > 1.0f)
				alpha = 1.0f;
		}
	}

	if (pTexture != NULL)
	{
		XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
		XAppSetRenderState(D3DRS_ZWRITEENABLE, FALSE);
		XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		XAppSetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		XAppSetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

		XAppSetTexture(0, pTexture);
		XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
		XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
		XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
		XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
		XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, (alpha * g_nEffectAlpha)));
	}
	else
	{
		XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
		XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
		XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
		XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, 0.0f));
	}

	XAppSetTexture(1, GetRadialEdgeAlphaMask());
	XAppSetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 0);
	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_CURRENT);
	XAppSetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_ADD);
	XAppSetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);
	XAppSetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);

	return true;
}




CMatInfo::CMatInfo(const TCHAR* szName, DWORD dwFlags/*=0*/)
{
	ASSERT(g_nMatInfoCount < countof (g_rgMatInfo));
	g_rgMatInfo[g_nMatInfoCount] = this;
	g_nMatInfoCount += 1;

	m_szName = szName;
	m_dwFlags = dwFlags;
}

CSolidMatInfo::CSolidMatInfo(const TCHAR* szName, BYTE r, BYTE g, BYTE b, BYTE a, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_r = r;
	m_g = g;
	m_b = b;
	m_a = a;
}

bool CMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if ((m_dwFlags & MATINFO_STANDARD_MATERIAL) != 0)
		return false;

	if ((m_dwFlags & MATINFO_CULL_NONE) != 0)
		XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	return true;
}

bool CSolidMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(m_r, m_g, m_b, (BYTE)(m_a * g_nEffectAlpha)));

	// Edge Aliasing mode enable
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
//	XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN);
//	XAppGetD3DDev()->SetScissors(1, FALSE, &g_scissorRectx2);

	return CMatInfo::Setup(pMaxMat);
}

CFalloffMatInfo::CFalloffMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_nShaderEffect = 1;
	m_colorSide = colorSide;
	m_colorFront = colorFront;
	_tcscpy(m_matName, szName);
}

bool CFalloffMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_pRenderMeshNode == NULL)
		return false;

	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetVertexShader(GetEffectShader(m_nShaderEffect, g_pRenderMeshNode->GetFVF()));
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

	// Edge Aliasing mode enable
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
//	XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN);
//	XAppGetD3DDev()->SetScissors(1, FALSE, &g_scissorRectx2);

	SetFalloffShaderValues(m_colorSide, m_colorFront);

	return CMatInfo::Setup(pMaxMat);
}

CFalloffTexInfo::CFalloffTexInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_nShaderEffect = 3;
	m_colorSide = colorSide;
	m_colorFront = colorFront;
}


bool CFalloffTexInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_pRenderMeshNode == NULL)
		return false;

	XAppSetVertexShader(GetEffectShader(m_nShaderEffect, g_pRenderMeshNode->GetFVF()));
	SetFalloffShaderValues(m_colorSide, m_colorFront);

	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	XAppSetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);

	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

	return CMatInfo::Setup(pMaxMat);
}

CAnisoMatInfo::CAnisoMatInfo(const TCHAR* szName, D3DCOLOR colorSide, D3DCOLOR colorFront, DWORD dwFlags/*=0*/) :
	CMatInfo(szName, dwFlags)
{
	m_nShaderEffect = 2;
	m_colorSide = colorSide;
	m_colorFront = colorFront;
}

bool CAnisoMatInfo::Setup(CMaxMaterial* pMaxMat)
{
	if (g_pRenderMeshNode == NULL)
		return false;

	XAppSetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	XAppSetVertexShader(GetEffectShader(m_nShaderEffect, g_pRenderMeshNode->GetFVF()));
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

	SetFalloffShaderValues(m_colorSide, m_colorFront);

	return CMatInfo::Setup(pMaxMat);
}

static int __cdecl SortMatInfoCompare(const void *elem1, const void *elem2)
{
	const CMatInfo* pMatInfo1 = *(const CMatInfo**)elem1;
	const CMatInfo* pMatInfo2 = *(const CMatInfo**)elem2;
	return _tcscmp(pMatInfo1->m_szName, pMatInfo2->m_szName);
}

static int __cdecl SearchMatInfoCompare(const void *elem1, const void *elem2)
{
	const TCHAR* szName = (const TCHAR*)elem1;
	const CMatInfo* pMatInfo = *(const CMatInfo**)elem2;
	return _tcscmp(szName, pMatInfo->m_szName);
}

CMatInfo* LookupMatInfo(const TCHAR* szName)
{
	CMatInfo** ppMatInfo = (CMatInfo**)bsearch(szName, g_rgMatInfo, g_nMatInfoCount, sizeof (CMatInfo*), SearchMatInfoCompare);
	if (ppMatInfo == NULL)
		return NULL;
	return *ppMatInfo;
}

void Material_Init()
{

#ifdef COOL_XDASH
	new CInnerWallMatInfo(_T("InnerWall_01"), D3DCOLOR_RGBA(107, 180, 255, 255), D3DCOLOR_RGBA(9, 0, 192, 20));
	new CFalloffMatInfo(_T("InnerWall_02"), D3DCOLOR_RGBA(107, 180, 255, 255), D3DCOLOR_RGBA(9, 0, 192, 20), MATINFO_CULL_NONE);
#else
	new CInnerWallMatInfo(_T("InnerWall_01"), D3DCOLOR_RGBA(243, 255, 107, 255), D3DCOLOR_RGBA(40, 212, 20, 20));
	new CFalloffMatInfo(_T("InnerWall_02"), D3DCOLOR_RGBA(243, 255, 107, 255), D3DCOLOR_RGBA(20, 192, 0, 20), MATINFO_CULL_NONE);
#endif

	new CMatInfo(_T("MetaInfo_Text"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("NamePanel_Text"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("GameNameText_01"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("GameNameText_02"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("GameNameText_03"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("GameIcon_01"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("GameIcon_03"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("Material #132"), MATINFO_STANDARD_MATERIAL);
	new CMatInfo(_T("u2 info"), MATINFO_STANDARD_MATERIAL);

	new CSolidMatInfo(_T("Material #1334"), 11, 32, 0, 192);
	new CSolidMatInfo(_T("XBOXgreendark"), 6, 33, 0, 255);
#ifdef COOL_XDASH
	new CSolidMatInfo(_T("XBOXgreen"), 25, 114, 201, 255);
	new CSolidMatInfo(_T("XBoxGreen2"), 25, 114, 201, 255);
#else
	new CSolidMatInfo(_T("XBOXgreen"), 140, 201, 25, 255);
	new CSolidMatInfo(_T("XBoxGreen2"), 139, 200, 24, 255);
#endif
	new CSolidMatInfo(_T("GameHilite33"), 221, 208, 120, 178);
	new CSolidMatInfo(_T("Nothing"), 128, 128, 128, 255);

#ifdef COOL_XDASH
	new CSolidMatInfo(_T("NavType"), 94, 190, 250, 178);
#else
	new CSolidMatInfo(_T("NavType"), 190, 250, 94, 178);
#endif
	new CSolidMatInfo(_T("RedType"), 200, 30, 30, 255);

#ifdef COOL_XDASH
	new CSolidMatInfo(_T("XBoxGreen"), 25, 114, 201, 255);
#else
	new CSolidMatInfo(_T("XBoxGreen"), 139, 200, 24, 255);
#endif
	new CSolidMatInfo(_T("Type"), 100, 200, 25, 255);
	new CSolidMatInfo(_T("Typesdsafsda"), 255, 255, 255, 179);
	new CSolidMatInfo(_T("Material #133"), 0, 0, 0, 192);

#ifdef COOL_XDASH
	new CSolidMatInfo(_T("Material #1335"), 0, 52, 162, 200);
#else
	new CSolidMatInfo(_T("Material #1335"), 76, 162, 0, 200);
#endif

	new CSolidMatInfo(_T("Material #133511"), 41, 87, 0, 255);
	new CSolidMatInfo(_T("Material #1336"), 0, 0, 0, 128);

#ifdef COOL_XDASH
	new CSolidMatInfo(_T("HilightedType"), 4, 0, 44, 255);
#else
	new CSolidMatInfo(_T("HilightedType"), 3, 44, 0, 255);
#endif

	new CSolidMatInfo(_T("XBoxGreenq"), 139, 200, 24, 255);
	new CSolidMatInfo(_T("Black80"), 0, 0, 0, 204);

#ifdef COOL_XDASH
	new CSolidMatInfo(_T("CellEgg/Partsw"), 9, 0, 192, 20, MATINFO_CULL_NONE);
	new CSolidMatInfo(_T("CellEgg/Partsz"), 107, 180, 255, 255, MATINFO_CULL_NONE);
#else
	new CSolidMatInfo(_T("CellEgg/Partsw"), 77, 224, 57, 166, MATINFO_CULL_NONE);
	new CSolidMatInfo(_T("CellEgg/Partsz"), 170, 170, 170, 255, MATINFO_CULL_NONE);
#endif

	new CSolidMatInfo(_T("Material #108"), 160, 252, 0, 255, MATINFO_CULL_NONE);
	new CSolidMatInfo(_T("ItemsType"), 182, 245, 96, 255, MATINFO_CULL_NONE);
	new CSolidMatInfo(_T("GameHiliteMemory"), 178, 208, 0, 255);

//	new CBackingMatInfo(_T("highlight"), 254, 255, 188, 80, MATINFO_CULL_NONE | MATINFO_RADIAL_ALPHA);

	new CSolidMatInfo(_T("red"), 255, 0, 0, 255);

	// m_nFalloff == 1 colors
	{
#ifdef COOL_XDASH
		const D3DCOLOR side = D3DCOLOR_RGBA(107, 180, 255, 192);
		const D3DCOLOR front = D3DCOLOR_RGBA(9, 0, 192, 0);
#else
		const D3DCOLOR side = D3DCOLOR_RGBA(243, 255, 107, 192);
		const D3DCOLOR front = D3DCOLOR_RGBA(20, 192, 0, 0);
#endif

		new CFalloffMatInfo(_T("FlatSurfaces"), side, front);

		new CFalloffMatInfo(_T("FlatSurfacesSelected"), side, D3DCOLOR_RGBA(30, 255, 0, 128));
#ifdef COOL_XDASH
		new CFalloffMatInfo(_T("FlatSurfacesMemory"), side, D3DCOLOR_RGBA(0, 6, 160, 128));
        new CFalloffMatInfo(_T("DarkSurfaces"), D3DCOLOR_RGBA(85, 133, 205, 90), front);
		new CFalloffMatInfo(_T("DarkSurfaces2"), D3DCOLOR_RGBA(85, 133, 205, 90), D3DCOLOR_RGBA(7, 0, 100, 0));
#else
		new CFalloffMatInfo(_T("FlatSurfacesMemory"), side, D3DCOLOR_RGBA(30, 160, 0, 128));
        new CFalloffMatInfo(_T("DarkSurfaces"), D3DCOLOR_RGBA(203, 205, 85, 90), front);
		new CFalloffMatInfo(_T("DarkSurfaces2"), D3DCOLOR_RGBA(203, 205, 85, 90), D3DCOLOR_RGBA(10, 100, 0, 0));
#endif
		new CFalloffMatInfo(_T("FlatSurfaces2sided"), side, front, MATINFO_CULL_NONE);
		new CFalloffMatInfo(_T("DetailLegSkin_Inner"), side, front);
		new CFalloffMatInfo(_T("Screen"), side, front, MATINFO_CULL_NONE);
		new CFalloffMatInfo(_T("Spout"), side, front);
		new CFalloffMatInfo(_T("NavType34"), side, front);
		new CFalloffMatInfo(_T("MetaFlatSurfaces"), side, front);
		new CFalloffMatInfo(_T("SC_SavedGame_Row01"), side, front);
		new CFalloffMatInfo(_T("HK_SavedGame_Row01"), side, front);
		new CFalloffMatInfo(_T("SavedEgg_Selected"), side, front);
		new CFalloffMatInfo(_T("FlatUnselected"), side, front);
		new CFalloffMatInfo(_T("Mem_InnerWall_Outer"), side, front);
		new CFalloffMatInfo(_T("SavedGameEgg"), side, front);
		new CFalloffMatInfo(_T("GameMenuEgg"), side, front);
		new CFalloffMatInfo(_T("Shell"), side, front);
		new CFalloffMatInfo(_T("Material #133sdsfdsf"), side, front);
		new CFalloffMatInfo(_T("IconParts"), side, front, MATINFO_CULL_NONE);
		new CFalloffMatInfo(_T("IconParts1"), side, front);
		new CFalloffMatInfo(_T("MU1Pod_HL"), side, front);
		new CFalloffMatInfo(_T("MU1Pod"), side, front);
		new CFalloffMatInfo(_T("GamePodb"), side, front, MATINFO_CULL_NONE);
		new CFalloffMatInfo(_T("GamePod"), side, front);
		new CFalloffMatInfo(_T("JwlSrfc01/InfoPnls"), side, front);

		new CFalloffMatInfo(_T("MenuCell"), side, front);

//		new CFalloffMatInfo(_T("InnerWall_02"), D3DCOLOR_RGBA(243, 255, 107, 255/*100*/), front, MATINFO_CULL_NONE);
//		new CFalloffMatInfo(_T("InnerWall_02"), D3DCOLOR_RGBA(243, 255, 107, 100), D3DCOLOR_RGBA(20, 192, 0, 0), MATINFO_CULL_NONE);
//		new CFalloffMatInfo(_T("InnerWall_02"), side, front, MATINFO_CULL_NONE);
		

		new CFalloffTexInfo(_T("Wireframe"), D3DCOLOR_RGBA(125, 198, 34, 100), D3DCOLOR_RGBA(125, 198, 34, 0));
	}

	// m_nFalloff == 2 colors
	{
#ifdef COOL_XDASH
		const D3DCOLOR side = D3DCOLOR_RGBA(107, 180, 255, 192);
		const D3DCOLOR front = D3DCOLOR_RGBA(9, 0, 192, 0);
#else
        const D3DCOLOR side = D3DCOLOR_RGBA(242, 250, 153, 215);
        const D3DCOLOR front = D3DCOLOR_RGBA(7, 104, 0, 37);
#endif

		new CFalloffMatInfo(_T("Tubes"), side, front, MATINFO_CULL_NONE);
		new CFalloffMatInfo(_T("JewelSurface02/PodMesh"), side, front);
		new CFalloffMatInfo(_T("TubesFade"), side, front, MATINFO_CULL_NONE);
		new CFalloffMatInfo(_T("TubesQ"), side, front);
		new CFalloffMatInfo(_T("EmptyMU"), side, front);
		new CFalloffMatInfo(_T("Tube"), side, front);
		new CFalloffMatInfo(_T("MemoryHeader"), D3DCOLOR_RGBA(60, 198, 67, 122), front, MATINFO_CULL_NONE);
	}

	// m_nFalloff == 3 colors
	{
		const D3DCOLOR side = D3DCOLOR_RGBA(252, 255, 0, 0);
		const D3DCOLOR front = D3DCOLOR_RGBA(254, 255, 188, 228);
//		const D3DCOLOR side = D3DCOLOR_RGBA(252, 0, 255, 0);
//		const D3DCOLOR front = D3DCOLOR_RGBA(254, 188, 255, 228);

		new CEggGlowFadeMatInfo(_T("EggGlow"), side, front);
		new CFalloffMatInfo(_T("ButtonGlow"), side, front);
	}

	// m_nFalloff == 4 colors
	{
#ifdef COOL_XDASH
		const D3DCOLOR side = D3DCOLOR_RGBA(107, 180, 255, 192);
		const D3DCOLOR front = D3DCOLOR_RGBA(9, 0, 192, 0);
#else
        const D3DCOLOR side = D3DCOLOR_RGBA(191, 255, 107, 51);
        const D3DCOLOR front = D3DCOLOR_RGBA(0, 255, 18, 0);
#endif

		new CFalloffMatInfo(_T("gradient"), side, front);
		new CFalloffMatInfo(_T("CellWallStructure"), side, front);
		new CFalloffMatInfo(_T("FlatSrfc/PodParts"), side, front);
		new CFalloffMatInfo(_T("Cell_Light"), side, front);
		new CFalloffMatInfo(_T("Cell_Light/LegSkin"), side, front);
	}

#ifdef COOL_XDASH
	new CFalloffMatInfo(_T("CellEgg/Parts"), D3DCOLOR_RGBA(107, 180, 255, 192), D3DCOLOR_RGBA(9, 0, 192, 0));
	new CFalloffMatInfo(_T("GameEgg"), D3DCOLOR_RGBA(107, 180, 255, 192), D3DCOLOR_RGBA(9, 0, 192, 0));
	new CFalloffMatInfo(_T("FlatSurfaces2sided3"), D3DCOLOR_RGBA(107, 180, 255, 192), D3DCOLOR_RGBA(9, 0, 192, 0), MATINFO_CULL_NONE);
	new CFalloffMatInfo(_T("console_hilite"), D3DCOLOR_RGBA(255, 173, 107, 255), D3DCOLOR_RGBA(246, 255, 0, 0));
#else
	new CFalloffMatInfo(_T("CellEgg/Parts"), D3DCOLOR_RGBA(243, 255, 107, 178), D3DCOLOR_RGBA(30, 255, 0, 0));
	new CFalloffMatInfo(_T("GameEgg"), D3DCOLOR_RGBA(243, 255, 107, 178), D3DCOLOR_RGBA(30, 255, 0, 0));
	new CFalloffMatInfo(_T("FlatSurfaces2sided3"), D3DCOLOR_RGBA(253, 30, 0, 255), D3DCOLOR_RGBA(242, 28, 0, 0), MATINFO_CULL_NONE);
	new CFalloffMatInfo(_T("console_hilite"), D3DCOLOR_RGBA(255, 173, 107, 255), D3DCOLOR_RGBA(246, 255, 0, 0));
#endif


	new CIconMatInfo(_T("TitleIcon"), 128, 128);
	new CIconMatInfo(_T("TitleSoundtrackIcon"), 128, 128, false, true);
	new CIconMatInfo(_T("SavedGameIcon"), 64, 64, true);
	new CIconMatInfo(_T("SoundtrackIcon"), 64, 64, true, true);
	new CIconMatInfo(_T("SelectedIcon"), 128, 128, false, false, true);
	new CKeyMatInfo(_T("Key"), false, false);
	new CKeyMatInfo(_T("BrightKey"), true, false);
	new CKeyMatInfo(_T("KeyText"), false, true);
	new CEggGlowPulseMatInfo(_T("EggGlowPulse"));
	new CAnisoMatInfo(_T("Metal_Chrome"), D3DCOLOR_RGBA(229, 229, 229, 0), D3DCOLOR_RGBA(229, 229, 229, 255));
	new CAnisoMatInfo(_T("Tvbox"), D3DCOLOR_RGBA(229, 229, 229, 0), D3DCOLOR_RGBA(229, 229, 229, 255));
	new CAnisoMatInfo(_T("AudioCD"), D3DCOLOR_RGBA(255, 255, 255, 40), D3DCOLOR_RGBA(255, 255, 255, 180));

#ifdef COOL_XDASH
	new CBackingMatInfo(_T("PanelBacking_01"), 0, 4, 20, 255);
	new CBackingMatInfo(_T("PanelBacking_02"), 0, 0, 0, 255);
	new CBackingMatInfo(_T("PanelBacking_03"), 0, 4, 20, 240);
	new CBackingMatInfo(_T("PanelBacking_04"), 7, 14, 46, 255);
	new CBackingMatInfo(_T("NameBacking"), 0, 1, 8, 255);
	new CBackingMatInfo(_T("ModeBacking"), 0, 1, 8, 255);
	new CBackingMatInfo(_T("SavedGameBacking"), 11, 10, 18, 255);
	new CBackingMatInfo(_T("MemManMetaBacking"), 0, 4, 25, 255);
	new CBackingMatInfo(_T("DarkenBacking"), 0, 4, 50, 255, MATINFO_CULL_NONE | MATINFO_RADIAL_EDGE_ALPHA);
#else
	new CBackingMatInfo(_T("PanelBacking_01"), 4, 20, 0, 255);
	new CBackingMatInfo(_T("PanelBacking_02"), 0, 0, 0, 255);
	new CBackingMatInfo(_T("PanelBacking_03"), 4, 20, 0, 240);
	new CBackingMatInfo(_T("PanelBacking_04"), 14, 46, 7, 255);
	new CBackingMatInfo(_T("NameBacking"), 1, 8, 0, 255);
	new CBackingMatInfo(_T("ModeBacking"), 1, 8, 0, 255);
	new CBackingMatInfo(_T("SavedGameBacking"), 11, 18, 10, 255);
	new CBackingMatInfo(_T("MemManMetaBacking"), 4, 25, 0, 255);
	new CBackingMatInfo(_T("DarkenBacking"), 4, 50, 0, 255, MATINFO_CULL_NONE | MATINFO_RADIAL_EDGE_ALPHA);
#endif

	new CBackingMatInfo(_T("TextBacking"), 0, 0, 0, 255, MATINFO_CULL_NONE | MATINFO_RADIAL_ALPHA);
	new CBackingMatInfo(_T("MetaBacking"), 4, 50, 0, 255, MATINFO_CULL_NONE | MATINFO_RADIAL_ALPHA);
	new CBackingMatInfo(_T("DarkenBackingDark"), 1, 8, 0, 255, MATINFO_CULL_NONE | MATINFO_RADIAL_ALPHA);

	new CModulateTextureMatInfo(_T("GameHilite"), 255, 255, 255, 255/*192*/, MATINFO_CULL_NONE);
	new CMaskTextureMatInfo(_T("equalizer"), MATINFO_RADIAL_AV_ALPHA);
	new CMaskTextureMatInfo(_T("MainMenuOrb"), MATINFO_RADIAL_EDGE_MAIN_ALPHA);  //new texture added for main menu

	new CReflectMatInfo(_T("ReflectSurface"));
	
	new CModulateTextureMatInfo(_T("PanelBacking"), 4, 20, 0, 255, MATINFO_CULL_NONE);

	new CFreeSpaceMatInfo(_T("Material #10822"));

	qsort(g_rgMatInfo, g_nMatInfoCount, sizeof (CMatInfo*), SortMatInfoCompare);

#ifdef _DEBUG
	// Check for duplicates!
	for (int i = 1; i < g_nMatInfoCount; i += 1)
		ASSERT(_tcscmp(g_rgMatInfo[i - 1]->m_szName, g_rgMatInfo[i]->m_szName) != 0);
#endif
}

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("MaxMaterial", CMaxMaterial, CMaterial)

START_NODE_PROPS(CMaxMaterial, CMaterial)
	NODE_PROP(pt_string, CMaxMaterial, name)
	NODE_PROP(pt_number, CMaxMaterial, param)
END_NODE_PROPS()

CMaxMaterial::CMaxMaterial() :
	m_name(NULL),
	m_param(0.0f)
{
	m_pMatInfo = NULL;
}

CMaxMaterial::~CMaxMaterial()
{
	delete [] m_name;
}

bool CMaxMaterial::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_name))
		m_pMatInfo = NULL;
    else if ((int)pprd->pbOffset == offsetof(m_param))
    {
        m_param = (XTIME)(*(float*)pvValue);
        return false;
    }

	return true;
}

void CMaxMaterial::Render()
{
	if (m_pMatInfo == NULL && m_name != NULL)
		m_pMatInfo = LookupMatInfo(m_name);

	if (m_pMatInfo == NULL)
	{
		TRACE(_T("\001Referencing undefined MaxMaterial '%s'\n"), m_name);
//		ASSERT(FALSE);
		return;
	}

	//Disable Edge Antialiasing
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
//	XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN);
//	XAppGetD3DDev()->SetScissors(1, FALSE, &g_scissorRect);

	if (_tcscmp(m_name, TEXT("Tubes")) == 0 ||
		_tcscmp(m_name, TEXT("TubesFade")) == 0 ||
		_tcscmp(m_name, TEXT("TubesQ")) == 0 ||
		_tcscmp(m_name, TEXT("Tube")) == 0)
	{
		g_bEdgeAntialiasOverride = TRUE;
	}
	else {
		g_bEdgeAntialiasOverride = FALSE;
	}

	m_pMatInfo->Setup(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\MemUtil.cpp ===
#include "std.h"
#include "xapp.h"

// privately exposed functions from Xbox D3D
extern "C" void* WINAPI D3D_AllocNoncontiguousMemory(DWORD Size);
extern "C" void WINAPI D3D_FreeNoncontiguousMemory(void *pMemory);

extern void CleanupImageCache();
extern bool CleanupTextureCache();
extern bool CleanupMeshCache();

int g_nNewFailedState;

int __cdecl NewFailed(size_t nBytes)
{
	TRACE(_T("\001new failed to allocate %d bytes!\n"), nBytes);

	switch (g_nNewFailedState)
	{
	case 0:
		TRACE(_T("\002Cleaning the texture cache!\n"));
		if (CleanupTextureCache())
			return 1;
		break;

	case 1:
		TRACE(_T("\002Cleaning the mesh cache!\n"));
		if (CleanupMeshCache())
			return 1;
		break;

	default:
		// We've run out of things to try!
        DbgPrint("xdash: out of memory (failed to allocate %d bytes)\n", nBytes);
#ifdef DEVKIT
        __asm int 3;
#endif
        HalReturnToFirmware(HalRebootRoutine);
	}

	g_nNewFailedState += 1;
	return 1; // keep trying!
}

void* XAppAllocMemory(int nBytes)
{
	for (;;)
	{
		void* pv = (void*)GlobalAlloc(GMEM_FIXED, nBytes);
		if (pv != NULL)
			return pv;

		if (NewFailed(nBytes) == 0)
			return NULL;
	}
}

void XAppFreeMemory(void* pv)
{
	if (pv != NULL)
		GlobalFree((HGLOBAL)pv);
}

void* XAppD3D_AllocContiguousMemory(DWORD Size, DWORD Alignment)
{
	for (;;)
	{
		void* pv = D3D_AllocContiguousMemory(Size, Alignment);
		if (pv != NULL)
			return pv;

		if (NewFailed(Size) == 0)
			return NULL;
	}
}

void* XAppD3D_AllocNoncontiguousMemory(DWORD Size)
{
	for (;;)
	{
		void* pv = D3D_AllocNoncontiguousMemory(Size);
		if (pv != NULL)
			return pv;

		if (NewFailed(Size) == 0)
			return NULL;
	}
}

void XAppCreateMeshFVF(DWORD NumFaces, DWORD NumVertices, DWORD Options, DWORD FVF, LPD3DXMESH* ppMesh)
{
	for (;;)
	{
		HRESULT hr = D3DXCreateMeshFVF(NumFaces, NumVertices, Options, FVF, XAppGetD3DDev(), ppMesh);
		if (hr != E_OUTOFMEMORY)
		{
			ASSERTHR(hr);
			return;
		}

		if (NewFailed(NumVertices * 32 + NumFaces * 6) == 0)
			return;
	}
}

void Memory_Init()
{
	// Setup our memory allocation failure hook...
	_set_new_handler(NewFailed);
	_set_new_mode(1);
	g_nNewFailedState = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\main.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "xip.h"
#include "Node.h"
#include "Screen.h"
#include "Runner.h"
#include "Lerper.h"
#include "Camera.h"
#include "NavInfo.h"
#include "Viewpoint.h"
#include "Background.h"
#include "xlaunch.h"

extern void DSound_Exit();

extern void Memory_Init();

extern void Debug_Init();
extern void Debug_Exit();

extern void Class_Init();
extern void Class_Exit();

#ifdef _DEBUG
extern void Debug_Frame();
#endif // _DEBUG

extern void Xbox_Init();

extern void DiscDrive_Init();

extern void BackgroundLoader_Frame();

extern void Text_Exit();

extern void Locale_Exit();

extern void TitleArray_Init();

extern void Material_Init();
extern float g_nEffectAlpha;

#ifdef _DEBUG
bool g_bWireframe = false;
#endif // _DEBUG

////////////////////////////////////////////////////////////////////////////

CXApp theApp;

D3DXMATRIX g_matView;
D3DXMATRIX g_matPosition;
D3DXMATRIX g_matProjection;
D3DRECT	   g_scissorRect;
D3DRECT	   g_scissorRectx2;

D3DXMATRIX g_matIdentity(
	1.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 1.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 1.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 1.0f);

#ifdef COOL_XDASH
UINT g_uMesh;
UINT g_uMeshRef;
#endif

extern "C" void Alert(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, countof(szBuffer), szMsg, args);
	Trace(_T("\007%s\n"), szBuffer);
	va_end(args);
}

#ifdef _UNICODE
void Unicode(TCHAR* wsz, const char* sz, int nMaxChars)
{
	while (nMaxChars-- > 0)
	{
		if ((*wsz++ = (unsigned char)*sz++) == 0)
			return;
	}
}

void Ansi(char* sz, const TCHAR* wsz, int nMaxChars)
{
	while (nMaxChars-- > 0)
	{
		if ((*sz++ = (char)*wsz++) == 0)
			return;
	}
}
#endif // _UNICODE

extern "C" PLAUNCH_DATA_PAGE* LaunchDataPage;

CXApp::CXApp()
{
	m_dwStartTick = m_dwFrameTick = GetTickCount();
	m_now = (float)m_dwFrameTick / 1000.0f;

	m_pD3D = NULL;
    m_pD3DDev = NULL;

	m_pViewpoint = NULL;
	m_pNavigationInfo = NULL;
	m_pBackground = NULL;

	m_worldStack = NULL;
	m_bProjectionDirty = true;

	m_bZBuffer = false;

	m_pScreen = NULL;

	m_pClass = new CClass;
	m_pObject = NULL;

	m_bStretchWidescreen = false;

	m_szAppDir = NULL;

    // Retrieve the launch data, if any
    if (*LaunchDataPage && (*LaunchDataPage)->Header.dwLaunchDataType == LDT_LAUNCH_DASHBOARD) {
        PLD_LAUNCH_DASHBOARD pLaunchDashboard =
            (PLD_LAUNCH_DASHBOARD) ((*LaunchDataPage)->LaunchData);

        m_bHasLaunchData = true;
        m_dwTitleID = (*LaunchDataPage)->Header.dwTitleId;
        m_dwLaunchReason = pLaunchDashboard->dwReason;
        m_dwLaunchContext = pLaunchDashboard->dwContext;
        m_dwLaunchParameter1 = pLaunchDashboard->dwParameter1;
        m_dwLaunchParameter2 = pLaunchDashboard->dwParameter2;

        PLAUNCH_DATA_PAGE pTemp = *LaunchDataPage;
        *LaunchDataPage = NULL;
        MmFreeContiguousMemory(pTemp);
    } else {
        m_bHasLaunchData = false;
        m_dwTitleID =
        m_dwLaunchReason =
        m_dwLaunchContext =
        m_dwLaunchParameter1 =
        m_dwLaunchParameter2 = 0;
    }

    m_dwMainThreadId = GetCurrentThreadId();
}

CXApp::~CXApp()
{
	// All cleanup code should be in CleanupApp or the debug code
	// will complain about it not happening!
}

// REVIEW: Nuke this when GetRenderState is implemented!

DWORD xapp_rgdwRenderStateCache [256];
bool xapp_rgbRenderStateCache [256];
float g_transitionMotionBlur;

void XboxInitRenderState()
{
	float zero = 0.0f;
	float one = 1.0f;

	XAppSetRenderState(D3DRS_ZENABLE, theApp.m_bZBuffer ? D3DZB_TRUE : D3DZB_FALSE);
	XAppSetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	XAppSetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	XAppSetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	XAppSetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	XAppSetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	XAppSetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	XAppSetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	XAppSetRenderState(D3DRS_ALPHAREF, 0);
	XAppSetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
	XAppSetRenderState(D3DRS_DITHERENABLE, TRUE);
	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	XAppSetRenderState(D3DRS_FOGENABLE, FALSE);
	XAppSetRenderState(D3DRS_SPECULARENABLE, FALSE);
	XAppSetRenderState(D3DRS_FOGCOLOR, 0);
	XAppSetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
//	XAppSetRenderState(D3DRS_FOGSTART, ); // Undocumented!
//	XAppSetRenderState(D3DRS_FOGEND, ); // Undocumented!
	XAppSetRenderState(D3DRS_FOGDENSITY, *(LPDWORD)&one);
	XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	XAppSetRenderState(D3DRS_ZBIAS, 0);
	XAppSetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	XAppSetRenderState(D3DRS_STENCILENABLE, FALSE);
	XAppSetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
	XAppSetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
	XAppSetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	XAppSetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
	XAppSetRenderState(D3DRS_STENCILREF, 0);
	XAppSetRenderState(D3DRS_STENCILMASK, 0xffffffff);
	XAppSetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
//	XAppSetRenderState(D3DRS_TEXTUREFACTOR, ); // Undocumented!
	XAppSetRenderState(D3DRS_WRAP0, 0);
	XAppSetRenderState(D3DRS_WRAP1, 0);
	XAppSetRenderState(D3DRS_WRAP2, 0);
	XAppSetRenderState(D3DRS_WRAP3, 0);
	XAppSetRenderState(D3DRS_LIGHTING, TRUE);
	XAppSetRenderState(D3DRS_AMBIENT, 0);
	XAppSetRenderState(D3DRS_COLORVERTEX, TRUE);
	XAppSetRenderState(D3DRS_LOCALVIEWER, TRUE);
	XAppSetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
	XAppSetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
	XAppSetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
	XAppSetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
	XAppSetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	XAppSetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	XAppSetRenderState(D3DRS_POINTSIZE, *(LPDWORD)&one);
	XAppSetRenderState(D3DRS_POINTSIZE_MIN, *(LPDWORD)&one);
	XAppSetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	XAppSetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	XAppSetRenderState(D3DRS_POINTSCALE_A, *(LPDWORD)&one);
	XAppSetRenderState(D3DRS_POINTSCALE_B, *(LPDWORD)&zero);
	XAppSetRenderState(D3DRS_POINTSCALE_C, *(LPDWORD)&zero);
	XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	XAppSetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
//	XAppSetRenderState(D3DRS_PATCHEDGESTYLE, ); // Undocumented!
//	XAppSetRenderState(D3DRS_PATCHSEGMENTS, ); // Undocumented!
//	XAppSetRenderState(D3DRS_DEBUGMONITORTOKEN, ); // Undocumented!
//	XAppSetRenderState(D3DRS_POINTSIZE_MAX, ); // Undocumented!
	XAppSetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
//	XAppSetRenderState(D3DRS_TWEENFACTOR, ); // Undocumented!

	// Initalize the motion blur
	g_transitionMotionBlur = 1.0f;
}

bool CXApp::InitD3D()
{
	m_pD3D = Direct3DCreate8(D3D_SDK_VERSION);
	if (m_pD3D == NULL)
	{
		Alert(_T("Cannot initialize Direct3D! (D3D_SDK_VERSION=%d)"), D3D_SDK_VERSION);
		return false;
	}

	D3DDEVTYPE devtype = D3DDEVTYPE_HAL;

	ZeroMemory(&m_pp, sizeof (m_pp));
	m_pp.BackBufferCount = 1;
	m_pp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
	m_pp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
	//m_pp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
	m_pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	//m_pp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR;
	m_pp.MultiSampleType = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;
	m_pp.EnableAutoDepthStencil = m_bZBuffer;
	if (m_bZBuffer)
		m_pp.AutoDepthStencilFormat = D3DFMT_D24S8;

    DWORD dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING;

    m_pp.Flags = D3DPRESENTFLAG_INTERLACED;
	
    m_bStretchWidescreen = (XGetVideoFlags() & XC_VIDEO_FLAGS_WIDESCREEN) != 0;
    if (m_bStretchWidescreen)
    {
        m_pp.Flags |= D3DPRESENTFLAG_WIDESCREEN;
    }

    switch (XGetAVPack())
    {
    default:
        m_pp.BackBufferWidth = 640;
        m_pp.BackBufferHeight = 480;
        break;

    case XC_AV_PACK_STANDARD:
    case XC_AV_PACK_SVIDEO:
    case XC_AV_PACK_RFU:
    case XC_AV_PACK_SCART:
        m_pp.BackBufferWidth = g_nDiscType == DISC_VIDEO ? 720 : 640;
        if (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I)
            m_pp.BackBufferHeight = 576;
        else
            m_pp.BackBufferHeight = 480;
        break;

    case XC_AV_PACK_HDTV:
        m_pp.BackBufferWidth = g_nDiscType == DISC_VIDEO ? 720 : 640;
        m_pp.BackBufferHeight = 480;

        // If we are about to play DVD, check if 480p is enabled
#ifdef COOL_XDASH
        if (g_nDiscType == DISC_VIDEO)
#else
        if ((XBOX_480P_MACROVISION_ENABLED & XboxHardwareInfo->Flags) && g_nDiscType == DISC_VIDEO)
#endif
        {
            DWORD dwFlags, dwType;
            if (XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL) == ERROR_SUCCESS)
            {
                if (dwFlags & AV_FLAGS_HDTV_480p)
                {
                    m_pp.Flags &= ~D3DPRESENTFLAG_INTERLACED;
                    m_pp.Flags |= D3DPRESENTFLAG_PROGRESSIVE;
                }
            }
        }

        break;
    }

	TRACE(_T("\001\nVideo Settings: %dx%d%c %s\n"), m_pp.BackBufferWidth, m_pp.BackBufferHeight,
          m_pp.Flags & D3DPRESENTFLAG_PROGRESSIVE ? 'p' : 'i', m_bStretchWidescreen ? _T("16:9") : _T("4:3"));

	m_pp.BackBufferFormat = D3DFMT_X8R8G8B8;//D3DFMT_R5G6B5; // REVIEW: Really want D3DFMT_R8G8B8
//	m_pp.AutoDepthStencilFormat = D3DFMT_D16; // REVIEW: Really want D3DFMT_D24S8

	m_pp.hDeviceWindow = NULL;
	m_pp.Windowed = FALSE;

#ifdef _DEBUG
	m_pp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_UNLIMITED;
#endif

	m_nViewWidth = (float)m_pp.BackBufferWidth;
	m_nViewHeight = (float)m_pp.BackBufferHeight;

	HRESULT hr = m_pD3D->CreateDevice(D3DADAPTER_DEFAULT, devtype, m_pp.hDeviceWindow, dwBehavior, &m_pp, &m_pD3DDev);
	if (FAILED(hr))
	{
		LogComError(hr, "InitD3D");
		return false;
	}

	LPDIRECT3DSURFACE8 pFrontBuffer;
	D3DSURFACE_DESC d3dsd;
	m_pD3DDev->GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
	pFrontBuffer->GetDesc(&d3dsd);
	pFrontBuffer->Release();
	g_scissorRect.x1 = 0;
	g_scissorRect.y1 = 0;
	g_scissorRect.x2 = d3dsd.Width;
	g_scissorRect.y2 = d3dsd.Height;

	m_pD3DDev->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
	pFrontBuffer->GetDesc(&d3dsd);
	pFrontBuffer->Release();
	g_scissorRectx2.x1 = 0;
	g_scissorRectx2.y1 = 0;
	g_scissorRectx2.x2 = d3dsd.Width;
	g_scissorRectx2.y2 = d3dsd.Height;

	

#ifdef _DEBUG
	{
		D3DCAPS8 d3dCaps;

		m_pD3DDev->GetDeviceCaps(&d3dCaps);

		// Does this device support the two bump mapping blend operations?
		if ((d3dCaps.TextureOpCaps & (D3DTEXOPCAPS_BUMPENVMAP | D3DTEXOPCAPS_BUMPENVMAPLUMINANCE)) == 0)
			TRACE(_T("Device does not support bump mapping\n"));

		// Does this device support up to three blending stages?
		if (d3dCaps.MaxTextureBlendStages < 3)
			TRACE(_T("Device supports less than 3 blending stages\n"));
	}
#endif


    // REVIEW: Nuke this when GetRenderState is implemented!
	XboxInitRenderState();

	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	XAppSetRenderState(D3DRS_AMBIENT, 0xffffffff);

	XAppSetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
	XAppSetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);

	XAppSetTextureStageState(1, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
	XAppSetTextureStageState(1, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);

	XAppSetTextureStageState(0,D3DTSS_MIPFILTER, D3DTEXF_LINEAR);

	TRACE(_T("Display sub-system initialized.\n"));

	return true;
}

void CXApp::ReleaseD3D()
{
	RELEASENULL(m_worldStack);

	if (m_pD3D != NULL)
	{
		m_pD3D->Release();
		m_pD3D = NULL;
	}
}

struct COLORVERTEX
{
	float dvX, dvY, dvZ;
	DWORD color;
};

void CXApp::Draw()
{
	// Setup projection transform...
	if (m_bProjectionDirty)
	{
		m_bProjectionDirty = false;

		float nNear = 0.1f;
		float nFar = 1000.0f;
		float fieldOfView = D3DX_PI / 2.0f;

		if (m_pNavigationInfo != NULL)
		{
			nNear = m_pNavigationInfo->m_avatarSize.x / 2.0f;
			if (m_pNavigationInfo->m_visibilityLimit != 0.0f)
				nFar = m_pNavigationInfo->m_visibilityLimit;
		}

		if (m_pViewpoint != NULL)
		{
			fieldOfView = m_pViewpoint->m_fieldOfView;
		}

		//float aspect = m_nViewWidth / m_nViewHeight;
		float aspect = 720.0f / 480.0f;
		if (m_bStretchWidescreen)
		{
			// This adjusts for 4x3 style resolutions being displayed widescreen on a 16x9 monitor...
			aspect *= 1.25f;
		}

		D3DXMatrixPerspectiveFovLH(&g_matProjection, fieldOfView, aspect, nNear, nFar);
		XAppSetTransform(D3DTS_PROJECTION, &g_matProjection);
	}

#ifdef COOL_XDASH
    g_uMesh = 0;
    g_uMeshRef = 0;
#endif

	XAppBeginScene();

#ifdef _DEBUG
	XAppSetRenderState(D3DRS_FILLMODE, g_bWireframe ? D3DFILL_WIREFRAME : D3DFILL_SOLID);
#endif

	//const float blurAlpha = 0.25f; // bigger number -> less blur
	//const float blurAlpha = 1.0f; // bigger number -> less blur
	const float blurAlpha = g_transitionMotionBlur;

	D3DCOLOR color;
	bool bBackdrop = false;
	if (m_pBackground == NULL)
		color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.3f, 1.0f);
	else
		color = D3DCOLOR_COLORVALUE(m_pBackground->m_skyColor.x, m_pBackground->m_skyColor.y, m_pBackground->m_skyColor.z, 1.0f);

	if (m_pBackground != NULL && m_pBackground->m_backdrop != NULL)
		bBackdrop = true;

	// REVIEW: don't clear the back buffer if we're going to fill it with a background anyway!
	static int nBeenHere;
	if (blurAlpha >= 1.0f || nBeenHere++ < 2 || color != D3DCOLOR_XRGB(0, 0, 0) || bBackdrop)
	{
		XAppClear(color); // NOTE: Clears back and Z buffers (if Z buffer is enabled)

		if (bBackdrop)
			m_pBackground->RenderBackdrop();
	}
	else
	{
		static LPDIRECT3DVERTEXBUFFER8 m_pVB;
		if (m_pVB == NULL)
		{
			VERIFYHR(XAppGetD3DDev()->CreateVertexBuffer(4 * sizeof(COLORVERTEX), D3DUSAGE_WRITEONLY, D3DFVF_XYZ | D3DFVF_DIFFUSE, D3DPOOL_MANAGED, &m_pVB));

			COLORVERTEX* verts;
			VERIFYHR(m_pVB->Lock(0, 4 * sizeof (COLORVERTEX), (BYTE**)&verts, 0));

			verts[0].dvX = (float)theApp.m_nViewWidth / 2.0f;
			verts[0].dvY = -(float)theApp.m_nViewHeight / 2.0f;
			verts[0].dvZ = 0.0f;
			verts[0].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			verts[1].dvX = -(float)theApp.m_nViewWidth / 2.0f;
			verts[1].dvY = -(float)theApp.m_nViewHeight / 2.0f;
			verts[1].dvZ = 0.0f;
			verts[1].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			verts[2].dvX = (float)theApp.m_nViewWidth / 2.0f;
			verts[2].dvY = (float)theApp.m_nViewHeight / 2.0f;
			verts[2].dvZ = 0.0f;
			verts[2].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			verts[3].dvX = -(float)theApp.m_nViewWidth / 2.0f;
			verts[3].dvY = (float)theApp.m_nViewHeight / 2.0f;
			verts[3].dvZ = 0.0f;
			verts[3].color = D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, blurAlpha);

			VERIFYHR(m_pVB->Unlock());
		}

    	D3DXMATRIX matProjection, matProjectionSave, matWorldSave, matViewSave;

    	XAppGetTransform(D3DTS_PROJECTION, &matProjectionSave);
    	XAppGetTransform(D3DTS_WORLD, &matWorldSave);
    	XAppGetTransform(D3DTS_VIEW, &matViewSave);

    	//D3DXMatrixOrthoLH(&matProjection, 720.0f, 480.0f, -10000.0f, 10000.0f);
		D3DXMatrixOrthoLH(&matProjection, theApp.m_nViewWidth, theApp.m_nViewHeight, -10000.0f, 10000.0f);
    	XAppSetTransform(D3DTS_PROJECTION, &matProjection);
    	XAppSetTransform(D3DTS_WORLD, &g_matIdentity);
    	XAppSetTransform(D3DTS_VIEW, &g_matIdentity);

        XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
        XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
        XAppSetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
        XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

        VERIFYHR(XAppGetD3DDev()->SetStreamSource(0, m_pVB, sizeof (COLORVERTEX)));
        VERIFYHR(XAppGetD3DDev()->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE));
        VERIFYHR(XAppGetD3DDev()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2));

    	XAppSetTransform(D3DTS_PROJECTION, &matProjectionSave);
    	XAppSetTransform(D3DTS_WORLD, &matWorldSave);
    	XAppSetTransform(D3DTS_VIEW, &matViewSave);
    }

#ifdef _LIGHTS
	// Setup lights...
	{
		static int nLastLight = -1;
		int nLight = 0;
		D3DCOLORVALUE ambient;
		ambient.r = 0.0f;
		ambient.g = 0.0f;
		ambient.b = 0.0f;

		// Headlight...
		if (m_pNavigationInfo == NULL || m_pNavigationInfo->m_headlight)
		{
			XAppSetTransform(D3DTS_WORLD, &g_matIdentity);

			D3DLIGHT8 d3dLight;
			ZeroMemory(&d3dLight, sizeof(d3dLight));

			d3dLight.Type = D3DLIGHT_DIRECTIONAL;

			d3dLight.Diffuse.r = 0.5f;
			d3dLight.Diffuse.g = 0.5f;
			d3dLight.Diffuse.b = 0.5f;

			d3dLight.Specular.r = 0.75f;
			d3dLight.Specular.g = 0.75f;
			d3dLight.Specular.b = 0.75f;

			d3dLight.Ambient.r = 0.2f;
			d3dLight.Ambient.g = 0.2f;
			d3dLight.Ambient.b = 0.2f;

			ambient.g += d3dLight.Ambient.r;
			ambient.g += d3dLight.Ambient.g;
			ambient.b += d3dLight.Ambient.b;

			D3DXVECTOR3 dir(0.0f, 0.0f, -1.0f);
			D3DXVec3TransformNormal(&dir, &dir, &g_matPosition);
			d3dLight.Direction = dir;

			// BLOCK: Extra spotlight stuff...
			if (0)
			{
				d3dLight.Type = D3DLIGHT_SPOT;
				d3dLight.Position = theCamera.m_position;
				d3dLight.Range = 100.0f;
				d3dLight.Falloff = 1.0f;
				d3dLight.Attenuation0 = 1.0f;
				d3dLight.Attenuation1 = 0.0f;
				d3dLight.Attenuation2 = 0.0f;
				d3dLight.Theta = 0.1f;
				d3dLight.Phi = 0.7f;
			}

			XAppSetLight(nLight, &d3dLight);
			XAppLightEnable(nLight, true);
			nLight += 1;
		}

		m_pObject->SetLight(nLight, ambient);

		if (ambient.r < 0.0f)
			ambient.r = 0.0f;
		else if (ambient.r > 1.0f)
			ambient.r = 1.0f;
		if (ambient.g < 0.0f)
			ambient.g = 0.0f;
		else if (ambient.g > 1.0f)
			ambient.g = 1.0f;
		if (ambient.b < 0.0f)
			ambient.b = 0.0f;
		else if (ambient.b > 1.0f)
			ambient.b = 1.0f;

		XAppSetRenderState(D3DRS_AMBIENT, D3DCOLOR_COLORVALUE(ambient.r, ambient.g, ambient.b, 1.0f));

#ifdef _DEBUG
		{
			if (nLight != nLastLight)
			{
				nLastLight = nLight;
				TRACE(_T("Lighting: %s (%d lights)\n"), nLight > 0 ? _T("enabled") : _T("disabled"), nLight);
			}
		}
#endif

		// Turn off lights we are not using...
		for (int i = nLight; i < nLastLight; i += 1)
			XAppLightEnable(i, false);

		XAppSetRenderState(D3DRS_LIGHTING, nLight > 0);
		nLastLight = nLight;
	}
#else // !_LIGHTS
	XAppSetRenderState(D3DRS_LIGHTING, FALSE);
#endif // _LIGHTS

#ifndef _XBOX
	if (m_pNavigator != NULL)
		m_pNavigator->Render();
#endif

    // BLOCK: Setup a default material
	{
		static D3DMATERIAL8 mat;
		if (mat.Diffuse.r == 0.0f)
		{
			mat.Diffuse.r = 0.5f;
			mat.Diffuse.g = 0.5f;
			mat.Diffuse.b = 0.5f;
			mat.Diffuse.a = 1.0f;

			mat.Ambient.r = 0.5f;
			mat.Ambient.g = 0.5f;
			mat.Ambient.b = 0.5f;
			mat.Ambient.a = 1.0f;

			mat.Specular.r = 0.5f;
			mat.Specular.g = 0.5f;
			mat.Specular.b = 0.5f;
			mat.Specular.a = 1.0f;

			mat.Emissive.r = 0.5f;
			mat.Emissive.g = 0.5f;
			mat.Emissive.b = 0.5f;
			mat.Emissive.a = 1.0f;

			mat.Power = 0.0f;
		}

		XAppSetMaterial(&mat);
	}

//		if (m_pGround != NULL)
//			m_pGround->RenderGround();

	// Draw the world...
	{
		XAppPushWorld();
		XAppIdentityWorld();
		XAppUpdateWorld();
		m_pObject->Render();
		XAppPopWorld();
	}

	XAppEndScene();
    XAppSetRenderState(D3DRS_SWATHWIDTH, D3DSWATH_OFF);
	XAppPresent();
    XAppSetRenderState(D3DRS_SWATHWIDTH, D3DSWATH_128);

	m_dwFrameTick = GetTickCount();
}

bool CXApp::InitApp()
{
//	START_PROFILE();

	Memory_Init();
	Xbox_Init();

	srand(GetTickCount());

#ifdef _DEBUG
	Debug_Init();
#endif

	TRACE(_T("Initializing XApp...\n"));

	DiscDrive_Init();

	if (!InitD3D())
		return false;

	LoadXIP(_T("y:\\default.xip"), true);

	Class_Init();
	TitleArray_Init();
	Material_Init();

	// BLOCK: Load the appropriate class file...
	{
		TCHAR szFileToLoad [MAX_PATH];
		szFileToLoad[0] = 0;

		GetStartupClassFile(szFileToLoad);
		ASSERT(szFileToLoad[0] != 0);

		TRACE(_T("Loading %s\n"), szFileToLoad);
		if (!m_pClass->Load(szFileToLoad))
		{
			extern bool g_bParseError;
			if (!g_bParseError)
				Alert(_T("%s\n\nCannot open file."), szFileToLoad);
			return false;
		}
	}

	m_pObject = (CInstance*)m_pClass->CreateNode();
	ASSERT(m_pObject != NULL);


	VERIFYHR(D3DXCreateMatrixStack(0, &m_worldStack));
	ASSERT(m_worldStack != NULL);

	CallFunction(m_pObject, _T("initialize"));

//	END_PROFILE();
	return true;
}

void CXApp::CleanupApp()
{
	ReleaseD3D();

	delete m_pObject;
	m_pObject = NULL;

	delete m_pClass;
	m_pClass = NULL;

	Class_Exit();
	Locale_Exit();
	Text_Exit();

	DSound_Exit();

	delete [] m_szAppDir;
	m_szAppDir = NULL;

#ifdef _DEBUG
	Debug_Exit();
#endif
}

void CXApp::Advance()
{
	XTIME now = (float)GetTickCount() / 1000.0f;
	float nDelta = (float) (now - m_now);
	if (nDelta == 0.0f)
		nDelta = 0.001f;
	m_now = now;

	ASSERT(g_nEffectAlpha == 1.0f); // this should always have been restored here!

#ifndef _XBOX
	if (m_pNavigator != NULL)
		m_pNavigator->Advance(nDelta);
#endif

	theCamera.Advance(nDelta);

	CLerper::AdvanceAll();
	m_pObject->Advance(nDelta);

	BackgroundLoader_Frame();

#ifdef _DEBUG
	Debug_Frame();
#endif
}

void XApp()
{
	if (!theApp.InitApp())
	{
		TRACE(_T("\001Initialization failed; exiting...\n"));
		theApp.CleanupApp();
		return;
	}

	TRACE(_T("Initialization completed...\n"));

	for (;;)
	{
		theApp.Advance();
		theApp.Draw();
	}

	theApp.CleanupApp();
}

void CXApp::GetStartupClassFile(TCHAR* szFileToLoad)
{
	TCHAR szAppDir [MAX_PATH];

	_tcscpy(szFileToLoad, _T("y:\\default.xap"));
	_tcscpy(szAppDir, _T("y:\\"));
	_tcscpy(g_szCurDir, _T("y:/default.xap"));

	m_szAppDir = new TCHAR [_tcslen(szAppDir) + 1];
	_tcscpy(m_szAppDir, szAppDir);
}

LONG XdashUnhandledExceptionFilter(LPEXCEPTION_POINTERS *pEx)
{
    HalReturnToFirmware(HalRebootRoutine);
    __asm { hlt }   // Shouldn't be here
}

void __cdecl main(int /*argc*/, char* /*argv*/ [])
{
#ifndef DEVKIT
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)XdashUnhandledExceptionFilter);
#endif
	XApp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Memory.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "node.h"
#include "runner.h"
#include "locale.h"
#include "TitleCollection.h"

#define up			0
#define down		1
#define left		2
#define right		3

#define end			0xff

struct PATHS
{
	const BYTE* rgpath [4];
};

static const BYTE pathDev1Unit1Up [] = { end };
static const BYTE pathDev1Unit1Down [] = { Dev2Unit1, Dev2Unit2, /*Dev0,*/ end  };
static const BYTE pathDev1Unit1Left [] = { end };
static const BYTE pathDev1Unit1Right [] = { Dev1Unit2, Dev0, end };

static const BYTE pathDev1Unit2Up [] = { end };
static const BYTE pathDev1Unit2Down [] = { Dev2Unit2, Dev2Unit1, /*Dev0,*/ end  };
static const BYTE pathDev1Unit2Left [] = { Dev1Unit1, end };
static const BYTE pathDev1Unit2Right [] = { Dev0, end };

static const BYTE pathDev2Unit1Up [] = { Dev1Unit1, Dev1Unit2, /*Dev0,*/ end  };
static const BYTE pathDev2Unit1Down [] = { end  };
static const BYTE pathDev2Unit1Left [] = { end };
static const BYTE pathDev2Unit1Right [] = { Dev2Unit2, Dev0, end };

static const BYTE pathDev2Unit2Up [] = { Dev1Unit2, Dev1Unit1, /*Dev0,*/ end  };
static const BYTE pathDev2Unit2Down [] = { end  };
static const BYTE pathDev2Unit2Left [] = { Dev2Unit1, end };
static const BYTE pathDev2Unit2Right [] = { Dev0, end };

static const BYTE pathDev3Unit1Up [] = { Dev4Unit1, Dev4Unit2, /*Dev0,*/ end  };
static const BYTE pathDev3Unit1Down [] = { end  };
static const BYTE pathDev3Unit1Left [] = { Dev0, end };
static const BYTE pathDev3Unit1Right [] = { Dev3Unit2, end };

static const BYTE pathDev3Unit2Up [] = { Dev4Unit2, Dev4Unit1, /*Dev0,*/ end  };
static const BYTE pathDev3Unit2Down [] = { end  };
static const BYTE pathDev3Unit2Left [] = { Dev3Unit1, Dev0, end };
static const BYTE pathDev3Unit2Right [] = { end };

static const BYTE pathDev4Unit1Up [] = { end  };
static const BYTE pathDev4Unit1Down [] = { Dev3Unit1, Dev3Unit2, /*Dev0,*/ end  };
static const BYTE pathDev4Unit1Left [] = { Dev0, end };
static const BYTE pathDev4Unit1Right [] = { Dev4Unit2, end };

static const BYTE pathDev4Unit2Up [] = { end  };
static const BYTE pathDev4Unit2Down [] = { Dev3Unit2, Dev3Unit1, /*Dev0,*/ end  };
static const BYTE pathDev4Unit2Left [] = { Dev4Unit1, Dev0, end };
static const BYTE pathDev4Unit2Right [] = { end };

static const PATHS pathsDev1Unit1 =
{
	pathDev1Unit1Up,
	pathDev1Unit1Down,
	pathDev1Unit1Left,
	pathDev1Unit1Right,
};

static const PATHS pathsDev1Unit2 =
{
	pathDev1Unit2Up,
	pathDev1Unit2Down,
	pathDev1Unit2Left,
	pathDev1Unit2Right,
};

static const PATHS pathsDev2Unit1 =
{
	pathDev2Unit1Up,
	pathDev2Unit1Down,
	pathDev2Unit1Left,
	pathDev2Unit1Right,
};

static const PATHS pathsDev2Unit2 =
{
	pathDev2Unit2Up,
	pathDev2Unit2Down,
	pathDev2Unit2Left,
	pathDev2Unit2Right,
};

static const PATHS pathsDev3Unit1 =
{
	pathDev3Unit1Up,
	pathDev3Unit1Down,
	pathDev3Unit1Left,
	pathDev3Unit1Right,
};

static const PATHS pathsDev3Unit2 =
{
	pathDev3Unit2Up,
	pathDev3Unit2Down,
	pathDev3Unit2Left,
	pathDev3Unit2Right,
};

static const PATHS pathsDev4Unit1 =
{
	pathDev4Unit1Up,
	pathDev4Unit1Down,
	pathDev4Unit1Left,
	pathDev4Unit1Right,
};

static const PATHS pathsDev4Unit2 =
{
	pathDev4Unit2Up,
	pathDev4Unit2Down,
	pathDev4Unit2Left,
	pathDev4Unit2Right,
};

static const PATHS* rgpaths [] =
{
	&pathsDev1Unit1,
	&pathsDev1Unit2,
	&pathsDev2Unit1,
	&pathsDev2Unit2,
	&pathsDev3Unit1,
	&pathsDev3Unit2,
	&pathsDev4Unit1,
	&pathsDev4Unit2,
};

class CMemoryMonitor : public CNode
{
	DECLARE_NODE(CMemoryMonitor, CNode)
public:
	CMemoryMonitor();
	~CMemoryMonitor();

	void Advance(float nSeconds);

	void selectUp();
	void selectDown();
	void selectLeft();
	void selectRight();
    int  selectDevUnit(int DriveLetter);

	CStrObject* FormatDeviceName(int devUnit);
	CStrObject* FormatTotalBlocks();
	CStrObject* FormatFreeBlocks(int devUnit);

	float GetFreeTotalRatio(int devUnit);
	int GetTotalFreeBlocks(int devUnit);
	void FormatMemoryUnit(int devUnit);

	int HaveDeviceTop(int nDevice);
	int HaveDeviceBottom(int nDevice);

	void SetMUName(int devUnit, const TCHAR* szName);

	int  m_curDevUnit;
    int  m_invalidDevUnit;
	bool m_blockInsertion;
    bool m_enumerationOn;


	bool FormatDeviceName2(int devUnit, TCHAR* szBuf);

protected:
	void UpdateValidDeviceFlags();
	bool GetTotalAndFreeBlocks(int devUnit, int* pnTotalBlocks, int* pnFreeBlocks);

	int m_nTotalBlocks;
	int m_nFreeBlocks;
	int m_nPrefRow;
	int m_nPrefCol;
	int m_nPrefUnit;

    //
    //  Tracking the status of found memory units
    //
    DWORD m_dwPendingDevUnits;
    bool  m_rgbValidDevUnit [8];
	char  m_rgchMount [8];

	DECLARE_NODE_PROPS();
	DECLARE_NODE_FUNCTIONS();
};

CMemoryMonitor* g_pMemoryMonitor;

IMPLEMENT_NODE("MemoryMonitor", CMemoryMonitor, CNode)

START_NODE_PROPS(CMemoryMonitor, CNode)
	NODE_PROP(pt_integer, CMemoryMonitor, curDevUnit)
    NODE_PROP(pt_integer, CMemoryMonitor, invalidDevUnit)
    NODE_PROP(pt_boolean, CMemoryMonitor, blockInsertion)
    NODE_PROP(pt_boolean, CMemoryMonitor, enumerationOn)
END_NODE_PROPS()

START_NODE_FUN(CMemoryMonitor, CNode)
	NODE_FUN_VV(selectUp)
	NODE_FUN_VV(selectDown)
	NODE_FUN_VV(selectLeft)
	NODE_FUN_VV(selectRight)
    NODE_FUN_II(selectDevUnit)
    NODE_FUN_SI(FormatDeviceName)
	NODE_FUN_SV(FormatTotalBlocks)
	NODE_FUN_SI(FormatFreeBlocks)
	NODE_FUN_II(GetTotalFreeBlocks)
	NODE_FUN_II(HaveDeviceTop)
	NODE_FUN_II(HaveDeviceBottom)
	NODE_FUN_NI(GetFreeTotalRatio)
	NODE_FUN_VIS(SetMUName)
	NODE_FUN_VI(FormatMemoryUnit)
END_NODE_FUN()

CMemoryMonitor::CMemoryMonitor()
{
	ASSERT(g_pMemoryMonitor == NULL);
	g_pMemoryMonitor = this;

	ZeroMemory(m_rgchMount, sizeof (m_rgchMount));

	m_nTotalBlocks = -1;
	m_nFreeBlocks = -1;

	m_nPrefRow = 0;
	m_nPrefCol = 0;
	m_nPrefUnit = 0;
	m_curDevUnit = Dev0;


    ZeroMemory(m_rgbValidDevUnit, sizeof(m_rgbValidDevUnit));

    m_invalidDevUnit = -1;
    m_blockInsertion = false;
    m_enumerationOn = false;


    m_dwPendingDevUnits = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

    UpdateValidDeviceFlags();
}

CMemoryMonitor::~CMemoryMonitor()
{
}

bool XboxFormatMemoryUnit(UINT nDevicePort, UINT nMemoryUnit);

void CMemoryMonitor::UpdateValidDeviceFlags()
{

    //
    //  If the current scene does not require
    //  enumeration, then just don't bother.
    //
    if(!m_enumerationOn) return;

    DWORD dwMUInsertions;
    DWORD dwMURemovals;
    DWORD dwMask;

    if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &dwMUInsertions, &dwMURemovals) || m_dwPendingDevUnits)
    {
        //
        //  Stave off the screen saver on device removal or insertion
        //
        ResetScreenSaver();

        //
        //  Update the pending list
        //
        m_dwPendingDevUnits &= ~dwMURemovals;
        m_dwPendingDevUnits |= dwMUInsertions;

        for (int i = 0; i < 8; i += 1)
        {
            dwMask = ((i%2) ? 0x10000 : 1) << (i>>1);

            //
            //  Handle Removal
            //
            if(dwMURemovals & dwMask)
            {
                //
                //  If device was mounted then unmount it.
                //
                if(m_rgbValidDevUnit[i])
                {
                    DWORD dwError = XUnmountMU(i / 2, i & 1);
                    if (dwError != ERROR_SUCCESS)
                        TRACE(_T("\001XUnmountMU(%d, %d) failed: %d\n"), i / 2, i & 1, dwError);
					else
                        TRACE(_T("Unmounted %d %d (was %c:)\n"), i / 2, i & 1, m_rgchMount[i]);
                    m_rgchMount[i] = 0;
                    g_titles[i].SetRoot(0, false);
                    m_rgbValidDevUnit[i] = false;

                    if(m_curDevUnit == i)
                    {
                        TRACE(_T("Pulled out current device; selecting hard drive!\n"));
                        m_curDevUnit = Dev0;
                        CallFunction(this, _T("OnCurDevUnitChange"));
                    }
                }

                if (m_invalidDevUnit == i)
                {
                    // Don't fire this more than once
                    m_invalidDevUnit = -1;
                    CallFunction(this, _T("OnInvalidMURemoved"));
                }

                CallFunction(this, _T("OnDeviceChange"));
            }
            //
            //  If we are not handling a bad unit, then
            //  try to mount any devices on the m_dwPendingDevUnits
            //  list.
            //
            if(!m_blockInsertion && (m_dwPendingDevUnits&dwMask))
            {
                int retry;
                DWORD dwError;

                ASSERT(0==m_rgchMount[i]);

                //
                //  Clear the pending flag, we will either
                //  mount it, or it becomes the current
                //  bad unit.
                //
                m_dwPendingDevUnits &= ~dwMask;

                //
                //  Make up to three attempts to mount the
                //  thing.
                //
                for (retry=0; retry<3; retry++)
                {
                    dwError = XMountMURoot(i / 2, i & 1, &m_rgchMount[i]);
                    if(dwError == ERROR_SUCCESS)
                    {
                        XCleanMUFromRoot(m_rgchMount[i], 0);
                        break;
                    }
                }

                if (dwError == ERROR_SUCCESS)
                {
                    TRACE(_T("Mounted %d %d as devUnit %d drive %c:\n"), i / 2, i & 1, i, m_rgchMount[i]);
                    m_rgbValidDevUnit[i] = true;
                    g_titles[i].SetRoot(m_rgchMount[i], false);
                    CallFunction(this, _T("OnDeviceChange"));
                } else
                {
                    bool bFormatSucceeded = false;

                    m_invalidDevUnit = i;

                    TRACE(_T("\002XMountMU(%d, %d) failed: %d\n"), i / 2, i & 1, dwError);

                    //
                    //  Reformat, this will also attempt the mount
                    //

                    FormatMemoryUnit(i);
                    CallFunction(this, _T("OnDeviceChange"));

                    //
                    //  Notify script that we found a bad device.
                    //
                    CObject* rgparam [2];
                    rgparam[0] = new CNumObject((float)i);
                    rgparam[1] = new CNumObject(m_rgbValidDevUnit[i] ? 1.0f : 0.0f);

                    CallFunction(this, _T("OnInvalidMU"), 2, rgparam);
                }
            }
        }
    }
}


int CMemoryMonitor::HaveDeviceTop(int nDevice)
{
	if (nDevice < 0 || nDevice > 3)
		return 0;

	return m_rgbValidDevUnit[nDevice * 2];
}

int CMemoryMonitor::HaveDeviceBottom(int nDevice)
{
	if (nDevice < 0 || nDevice > 3)
		return 0;

	return m_rgbValidDevUnit[nDevice * 2 + 1];
}

bool CMemoryMonitor::GetTotalAndFreeBlocks(int devUnit, int* pnTotalBlocks, int* pnFreeBlocks)
{
	char szPath [4];

	if (devUnit == Dev0)
	{
		szPath[0] = 'C';
	}
	else
	{
		szPath[0] = m_rgchMount[devUnit];
		if (szPath[0] == 0)
		{
			TRACE(_T("Attempted GetTotalAndFreeBlocks on unmounted devUnit %d\n"), devUnit);
			return false;
		}
	}

	szPath[1] = ':';
	szPath[2] = '\\';
	szPath[3] = 0;

	ULARGE_INTEGER qwAvailBytes, qwTotalBytes, qwFreeBytes;
	if (GetDiskFreeSpaceEx(szPath, &qwAvailBytes, &qwTotalBytes, &qwFreeBytes))
	{
		int nTotalBlocks = (int)((qwTotalBytes.QuadPart + BLOCK_SIZE - 1) / BLOCK_SIZE);
		int nFreeBlocks = (int)((qwFreeBytes.QuadPart + BLOCK_SIZE - 1) / BLOCK_SIZE);

		nTotalBlocks -= 1; // we always have a root dir that uses at least one block...

		if (pnTotalBlocks != NULL)
			*pnTotalBlocks = nTotalBlocks;
		if (pnFreeBlocks != NULL)
			*pnFreeBlocks = nFreeBlocks;
	}
	else
	{
		DWORD dwError = GetLastError();
		TRACE(_T("GetDiskFreeSpaceEx(%c:) failed (%d)\n"), szPath, dwError);

        if (devUnit != Dev0)
        {
            m_rgbValidDevUnit[devUnit] = false;
        }

		if (pnTotalBlocks != NULL)
			*pnTotalBlocks = 0;
		if (pnFreeBlocks != NULL)
			*pnFreeBlocks = 0;

		return false;
	}

	return true;
}

void CMemoryMonitor::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	UpdateValidDeviceFlags();

	if (m_curDevUnit != Dev0 && !m_rgbValidDevUnit[m_curDevUnit])
	{
		// We lost the curent memory unit; select the hard drive...
		TRACE(_T("We lost the curent memory unit; select the hard drive...\n"));
		m_curDevUnit = Dev0;
		CallFunction(this, _T("OnCurDevUnitChange"));
	}

	// BLOCK: Get total/free space info...
	{
		int totalBlocks = 0;
		int freeBlocks = 0;
		
        GetTotalAndFreeBlocks(m_curDevUnit, &totalBlocks, &freeBlocks);

        if (totalBlocks != m_nTotalBlocks || freeBlocks != m_nFreeBlocks)
        {
            m_nTotalBlocks = totalBlocks;
            m_nFreeBlocks = freeBlocks;
            CallFunction(this, _T("OnTotalFreeChanged"));
        }
	}
}

void CMemoryMonitor::selectUp()
{
	if (m_curDevUnit == Dev0)
	{
		return;
/*
		m_curDevUnit = (m_nPrefCol == 0 ? Dev1Unit1 : Dev4Unit1) + m_nPrefUnit;
		if (!m_rgbValidDevUnit[m_curDevUnit])
		{
			m_curDevUnit = (m_nPrefCol == 0 ? Dev1Unit1 : Dev4Unit1) + (1 - m_nPrefUnit);
			if (!m_rgbValidDevUnit[m_curDevUnit])
			{
				m_curDevUnit = (m_nPrefCol != 0 ? Dev1Unit1 : Dev4Unit1) + m_nPrefUnit;
				if (!m_rgbValidDevUnit[m_curDevUnit])
				{
					m_curDevUnit = (m_nPrefCol != 0 ? Dev1Unit1 : Dev4Unit1) + (1 - m_nPrefUnit);
					if (!m_rgbValidDevUnit[m_curDevUnit])
					{
						m_curDevUnit = Dev0;
						return;
					}
				}
			}
		}
*/
	}
	else
	{
		const PATHS* ppath = rgpaths[m_curDevUnit];
		for (const BYTE* path = ppath->rgpath[up]; *path != end; path += 1)
		{
			if (*path == Dev0 || m_rgbValidDevUnit[*path])
			{
				m_curDevUnit = *path;
				break;
			}
		}
	}

	m_nPrefRow = 0;

	if (m_curDevUnit != Dev0)
	{
		m_nPrefUnit = m_curDevUnit & 1;
		m_nPrefCol = (m_curDevUnit / 2) >= 2;
	}

	CallFunction(this, _T("OnCurDevUnitChange"));
}

void CMemoryMonitor::selectDown()
{
	if (m_curDevUnit == Dev0)
	{
		return;
/*
		m_curDevUnit = (m_nPrefCol == 0 ? Dev2Unit1 : Dev3Unit1) + m_nPrefUnit;
		if (!m_rgbValidDevUnit[m_curDevUnit])
		{
			m_curDevUnit = (m_nPrefCol == 0 ? Dev2Unit1 : Dev3Unit1) + (1 - m_nPrefUnit);
			if (!m_rgbValidDevUnit[m_curDevUnit])
			{
				m_curDevUnit = (m_nPrefCol != 0 ? Dev2Unit1 : Dev3Unit1) + m_nPrefUnit;
				if (!m_rgbValidDevUnit[m_curDevUnit])
				{
					m_curDevUnit = (m_nPrefCol != 0 ? Dev2Unit1 : Dev3Unit1) + (1 - m_nPrefUnit);
					if (!m_rgbValidDevUnit[m_curDevUnit])
					{
						m_curDevUnit = Dev0;
						return;
					}
				}
			}
		}
*/
	}
	else
	{
		const PATHS* ppath = rgpaths[m_curDevUnit];
		for (const BYTE* path = ppath->rgpath[down]; *path != end; path += 1)
		{
			if (*path == Dev0 || m_rgbValidDevUnit[*path])
			{
				m_curDevUnit = *path;
				break;
			}
		}
	}

	m_nPrefRow = 1;
	
	if (m_curDevUnit != Dev0)
	{
		m_nPrefUnit = m_curDevUnit & 1;
		m_nPrefCol = (m_curDevUnit / 2) >= 2;
	}

	CallFunction(this, _T("OnCurDevUnitChange"));
}

void CMemoryMonitor::selectLeft()
{
	if (m_curDevUnit == Dev0)
	{
		m_curDevUnit = (m_nPrefRow == 0 ? Dev1Unit1 : Dev2Unit1) + 1;
		if (!m_rgbValidDevUnit[m_curDevUnit])
		{
			m_curDevUnit = (m_nPrefRow == 0 ? Dev1Unit1 : Dev2Unit1) + 0;
			if (!m_rgbValidDevUnit[m_curDevUnit])
			{
				m_curDevUnit = (m_nPrefRow != 0 ? Dev1Unit1 : Dev2Unit1) + 1;
				if (!m_rgbValidDevUnit[m_curDevUnit])
				{
					m_curDevUnit = (m_nPrefRow != 0 ? Dev1Unit1 : Dev2Unit1) + 0;
					if (!m_rgbValidDevUnit[m_curDevUnit])
					{
						m_curDevUnit = Dev0;
						return;
					}
				}
			}
		}
	}
	else
	{
		const PATHS* ppath = rgpaths[m_curDevUnit];
		for (const BYTE* path = ppath->rgpath[left]; *path != end; path += 1)
		{
			if (*path == Dev0 || m_rgbValidDevUnit[*path])
			{
				m_curDevUnit = *path;
				break;
			}
		}
	}

	m_nPrefCol = 0;

	if (m_curDevUnit != Dev0)
	{
		m_nPrefUnit = m_curDevUnit & 1;
		m_nPrefRow = (m_curDevUnit / 2) == 1 || (m_curDevUnit / 2) == 2;
	}

	CallFunction(this, _T("OnCurDevUnitChange"));
}

void CMemoryMonitor::selectRight()
{
	if (m_curDevUnit == Dev0)
	{
		m_curDevUnit = (m_nPrefRow == 0 ? Dev4Unit1 : Dev3Unit1) + 0;
		if (!m_rgbValidDevUnit[m_curDevUnit])
		{
			m_curDevUnit = (m_nPrefRow == 0 ? Dev4Unit1 : Dev3Unit1) + 1;
			if (!m_rgbValidDevUnit[m_curDevUnit])
			{
				m_curDevUnit = (m_nPrefRow != 0 ? Dev4Unit1 : Dev3Unit1) + 0;
				if (!m_rgbValidDevUnit[m_curDevUnit])
				{
					m_curDevUnit = (m_nPrefRow != 0 ? Dev4Unit1 : Dev3Unit1) + 1;
					if (!m_rgbValidDevUnit[m_curDevUnit])
					{
						m_curDevUnit = Dev0;
						return;
					}
				}
			}
		}
	}
	else
	{
		const PATHS* ppath = rgpaths[m_curDevUnit];
		for (const BYTE* path = ppath->rgpath[right]; *path != end; path += 1)
		{
			if (*path == Dev0 || m_rgbValidDevUnit[*path])
			{
				m_curDevUnit = *path;
				break;
			}
		}
	}

	m_nPrefCol = 1;

	if (m_curDevUnit != Dev0)
	{
		m_nPrefUnit = m_curDevUnit & 1;
		m_nPrefRow = (m_curDevUnit / 2) == 1 || (m_curDevUnit / 2) == 2;
	}

	CallFunction(this, _T("OnCurDevUnitChange"));
}

int CMemoryMonitor::selectDevUnit(int DriveLetter)
{
    int nDevUnit;

    DriveLetter = toupper(DriveLetter);

    // Convert drive letter to device unit
    if (DriveLetter == 'T' || DriveLetter == 'U')
    {
        nDevUnit = Dev0;
    }
    else if (DriveLetter >= 'F' && DriveLetter <= 'M')
    {
        nDevUnit = DriveLetter - 'F';
        ASSERT(nDevUnit >= Dev1Unit1 && nDevUnit <= Dev4Unit2);
    }
    else
    {
        TRACE(_T("Invalid drive letter: %c\n"), DriveLetter);
        return false;
    }

    // Save enumeration state
    bool bSaveEnumerationState = m_enumerationOn;

    // Force enumeration in case we haven't done that before
    m_enumerationOn = true;
    UpdateValidDeviceFlags();

    // Restore enumeration state
    m_enumerationOn = bSaveEnumerationState;

    if (nDevUnit != Dev0 && !m_rgbValidDevUnit[nDevUnit])
    {
        return false;
    }

    m_curDevUnit = nDevUnit;
    return true;
}

void FormatDeviceName(int devUnit, TCHAR* szBuf)
{
	ASSERT(g_pMemoryMonitor != NULL);
	if (!g_pMemoryMonitor->FormatDeviceName2(devUnit, szBuf))
		szBuf[0] = 0;
}

CStrObject* CMemoryMonitor::FormatDeviceName(int devUnit)
{
	TCHAR szBuf [MAX_MUNAME];

	if (!FormatDeviceName2(devUnit, szBuf))
		szBuf[0] = 0;

	return new CStrObject(szBuf);
}

bool CMemoryMonitor::FormatDeviceName2(int devUnit, TCHAR* szBuf)
{
	if (devUnit == -1)
		devUnit = m_curDevUnit;

	if (devUnit < Dev1Unit1 || devUnit > Dev4Unit2 || m_rgchMount[devUnit] == 0)
	{
		TRACE(_T("Attempt to get name of unmounted unit: %d\n"), devUnit);
		return false;
	}

	TCHAR szName [MAX_MUNAME];
	DWORD dwError = XMUNameFromDriveLetter(m_rgchMount[devUnit], szName, MAX_MUNAME);
	if (dwError != ERROR_SUCCESS)
		return false;

    _tcscpy(szBuf, szName);
	return true;
}

CStrObject* CMemoryMonitor::FormatFreeBlocks(int devUnit)
{
	int nFreeBlocks;
	if (devUnit == -1)
		nFreeBlocks = m_nFreeBlocks;
	else
		GetTotalAndFreeBlocks(devUnit, NULL, &nFreeBlocks);

	TCHAR szBuf [16];

	FormatBlocks (szBuf, nFreeBlocks);
	
	return new CStrObject(szBuf);
}

int CMemoryMonitor::GetTotalFreeBlocks(int devUnit)
{
	int nFreeBlocks;
	if (devUnit == -1)
		nFreeBlocks = m_nFreeBlocks;
	else
		GetTotalAndFreeBlocks(devUnit, NULL, &nFreeBlocks);

	return nFreeBlocks;
}

CStrObject* CMemoryMonitor::FormatTotalBlocks()
{
	TCHAR szBuf [16];

	FormatBlocks(szBuf, m_nTotalBlocks);			
	
	return new CStrObject(szBuf);
}

float CMemoryMonitor::GetFreeTotalRatio(int devUnit)
{
	int nTotalBlocks, nFreeBlocks;
	if (!GetTotalAndFreeBlocks(devUnit, &nTotalBlocks, &nFreeBlocks))
		return 0.0f;

	ASSERT(nTotalBlocks != 0);

	static float nLast[9];
	float nReturn = (float)nFreeBlocks / nTotalBlocks;
	if (nReturn != nLast[devUnit])
	{
		TRACE(_T("GetFreeTotalRatio(%d) %f\n"), devUnit, nReturn);
		nLast[devUnit] = nReturn;
	}

	return (float)nFreeBlocks / nTotalBlocks;
}

void CMemoryMonitor::SetMUName(int devUnit, const TCHAR* szName)
{
	if (devUnit < Dev1Unit1 || devUnit > Dev4Unit2 || m_rgchMount[devUnit] == 0)
	{
		TRACE(_T("Attempt to set name of unmounted unit: %d\n"), devUnit);
		return;
	}

	if (_tcslen(szName) + 1 > MAX_MUNAME)
	{
		TRACE(_T("%s is too long!\n"), szName);
		return;
	}

	XMUWriteNameToDriveLetter(m_rgchMount[devUnit], szName);
}

void CMemoryMonitor::FormatMemoryUnit(int devUnit)
{
	if (m_rgchMount[devUnit] != 0)
	{
		XUnmountMU(devUnit / 2, devUnit & 1);
		m_rgchMount[devUnit] = 0;
		g_titles[devUnit].SetRoot(0, false);
	}

	m_rgbValidDevUnit[devUnit] = false;
	XboxFormatMemoryUnit(devUnit / 2, devUnit & 1);

	DWORD dwError = XMountMURoot(devUnit / 2, devUnit & 1, &m_rgchMount[devUnit]);
	if (dwError == ERROR_SUCCESS)
	{
		TRACE(_T("Mounted %d %d as devUnit %d drive %c:\n"), devUnit / 2, devUnit & 1, devUnit, m_rgchMount[devUnit]);
		m_rgbValidDevUnit[devUnit] = true;

        //
        // Set root drive and force update right away so that the dirty flag
        // won't show up in the next CSavedGameGrid::Advance.  Besides, this
        // should be fast since we just format it to be empty.
        //
		g_titles[devUnit].SetRoot(m_rgchMount[devUnit], true);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Mesh.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Shape.h"
#include "Runner.h"
#include "Texture.h"
#include "xip.h"
#include "Mesh.h"
#include "FileUtil.h"

#ifdef COOL_XDASH
#include "Camera.h"
extern CCamera theCamera;
extern UINT g_uMesh;
#endif

extern BOOL g_bEdgeAntialiasOverride;

CMesh::CMesh()
{
//	m_bOwnMemory = true;
	m_pVertexBuffer = NULL;
	m_pIndexBuffer = NULL;
	m_nVertexStride = 0;
	m_nFaceCount = 0;
	m_nVertexCount = 0;
	m_nIndexCount = 0;
	m_fvf = 0;
	m_primitiveType = (D3DPRIMITIVETYPE)0;
}

CMesh::~CMesh()
{
//	if (m_bOwnMemory)
	{
		if (m_pVertexBuffer != NULL)
			m_pVertexBuffer->Release();

		if (m_pIndexBuffer != NULL)
			m_pIndexBuffer->Release();
	}
}

DWORD CMesh::GetFVF() const
{
    ASSERT(m_fvf != D3DFVF_RESERVED0);
	return m_fvf;
}

bool CMesh::Create(BYTE* pbData, DWORD dwData)
{
	MESHFILEHEADER* pHeader = (MESHFILEHEADER*)pbData;
	pbData += sizeof (MESHFILEHEADER);

#ifdef _XBOX
	switch (pHeader->dwPrimitiveType)
	{
	default:
		ASSERT(FALSE); // unsupported primitive type
		return false;

	case 4:
		m_primitiveType = D3DPT_TRIANGLELIST;
		break;

	case 5:
		m_primitiveType = D3DPT_TRIANGLESTRIP;
		break;
	}
#else
	m_primitiveType = (D3DPRIMITIVETYPE)pHeader->dwPrimitiveType;
#endif

	m_nFaceCount = pHeader->dwFaceCount;
	m_fvf = pHeader->dwFVF;
	m_nVertexStride = pHeader->dwVertexStride;
	m_nVertexCount = pHeader->dwVertexCount;
	m_nIndexCount = pHeader->dwIndexCount;

	XAppCreateVertexBuffer(m_nVertexCount * m_nVertexStride, D3DUSAGE_DYNAMIC, m_fvf, D3DPOOL_DEFAULT, &m_pVertexBuffer);

	BYTE* verts;
#ifdef _XBOX
	const DWORD dwLockFlags = D3DLOCK_DISCARD | D3DLOCK_NOFLUSH;
#else
	const DWORD dwLockFlags = D3DLOCK_DISCARD;
#endif
	VERIFYHR(m_pVertexBuffer->Lock(0, 0, &verts, dwLockFlags));
	CopyMemory(verts, pbData, m_nVertexCount * m_nVertexStride);
	pbData += m_nVertexCount * m_nVertexStride;
	VERIFYHR(m_pVertexBuffer->Unlock());

	XAppCreateIndexBuffer(m_nIndexCount * sizeof (WORD), D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIndexBuffer);

	BYTE* indices;
	VERIFYHR(m_pIndexBuffer->Lock(0, m_nIndexCount * sizeof (WORD), (BYTE**)&indices, dwLockFlags));
	CopyMemory(indices, pbData, m_nIndexCount * sizeof (WORD));
	VERIFYHR(m_pIndexBuffer->Unlock());

	return true;
}

bool CMesh::Create(HANDLE hFile)
{
	DWORD dwRead;
	MESHFILEHEADER header;

	VERIFY(ReadFile(hFile, &header, sizeof (header), &dwRead, NULL) && dwRead == sizeof (header));

#ifdef _XBOX
	switch (header.dwPrimitiveType)
	{
	default:
		ASSERT(FALSE); // unsupported primitive type
		return false;

	case 4:
		m_primitiveType = D3DPT_TRIANGLELIST;
		break;

	case 5:
		m_primitiveType = D3DPT_TRIANGLESTRIP;
		break;
	}
#else
	m_primitiveType = (D3DPRIMITIVETYPE)header.dwPrimitiveType;
#endif

	m_nFaceCount = header.dwFaceCount;
	m_fvf = header.dwFVF;
    ASSERT(m_fvf != D3DFVF_RESERVED0);
	m_nVertexStride = header.dwVertexStride;
	m_nVertexCount = header.dwVertexCount;
	m_nIndexCount = header.dwIndexCount;

    XAppCreateVertexBuffer(m_nVertexCount * m_nVertexStride, D3DUSAGE_DYNAMIC, m_fvf, D3DPOOL_DEFAULT, &m_pVertexBuffer);

	BYTE* verts;
#ifdef _XBOX
	const DWORD dwLockFlags = D3DLOCK_DISCARD | D3DLOCK_NOFLUSH;
#else
	const DWORD dwLockFlags = D3DLOCK_DISCARD;
#endif
	VERIFYHR(m_pVertexBuffer->Lock(0, 0, &verts, dwLockFlags));
	VERIFY(ReadFile(hFile, verts, m_nVertexCount * m_nVertexStride, &dwRead, NULL) && dwRead == (DWORD)(m_nVertexCount * m_nVertexStride));
	VERIFYHR(m_pVertexBuffer->Unlock());

	XAppCreateIndexBuffer(m_nIndexCount * sizeof (WORD), D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIndexBuffer);

	BYTE* indices;
	VERIFYHR(m_pIndexBuffer->Lock(0, m_nIndexCount * sizeof (WORD), (BYTE**)&indices, D3DLOCK_DISCARD));
	VERIFY(ReadFile(hFile, indices, m_nIndexCount * sizeof (WORD), &dwRead, NULL) && dwRead == m_nIndexCount * sizeof (WORD));
	VERIFYHR(m_pIndexBuffer->Unlock());

	return true;
}

bool CMesh::Load(const TCHAR* szFilePath)
{
	HANDLE hFile = XAppCreateFile(szFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001Cannot load MeshNode: %s\n"), szFilePath);
		return false;
	}

	bool b = Create(hFile);

	CloseHandle(hFile);

	return b;
}

void CMesh::Render(bool bSetFVF)
{
	if (m_pVertexBuffer == NULL || m_pIndexBuffer == NULL)
		return;

	ASSERT(m_primitiveType != 0); // forget to set this?

	if (bSetFVF)
		XAppSetVertexShader(GetFixedFunctionShader(m_fvf));

	if (m_nFaceCount > 800 && !g_bEdgeAntialiasOverride) {
		XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
		XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
		//XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN);
	}

#ifdef COOL_XDASH

    D3DMATRIX matOldView;

    if (g_uMesh == 0) {
        // Turn off breathing for the background sphere in the ugliest way imaginable...
        D3DXMATRIX matPosition, matView;
	    D3DXMatrixAffineTransformation(&matPosition, 1.0f, NULL, &theCamera.m_orientation, &theCamera.m_position);
	    D3DXMatrixInverse(&matView, NULL, &matPosition);
	    matView._31 = -matView._31;
	    matView._32 = -matView._32;
	    matView._33 = -matView._33;
	    matView._34 = -matView._34;
        XAppGetTransform(D3DTS_VIEW, &matOldView);
	    XAppSetTransform(D3DTS_VIEW, &matView);
    }

#endif

	XAppSetStreamSource(0, m_pVertexBuffer, m_nVertexStride);
	XAppSetIndices(m_pIndexBuffer, 0);
	XAppDrawIndexedPrimitive(m_primitiveType, 0, m_nVertexCount, 0, m_nFaceCount);

#ifdef _WINDOWS
	theApp.m_nVertPerFrame += m_nVertexCount;
	theApp.m_nTriPerFrame += m_nFaceCount;
#endif

#ifdef COOL_XDASH
    if (g_uMesh == 0) {
        XAppSetTransform(D3DTS_VIEW, &matOldView);
    }

    g_uMesh++;
#endif
}

////////////////////////////////////////////////////////////////////////////

class CMeshNode* g_pRenderMeshNode = NULL;

CMeshNode* CMeshNode::c_pFirst;

IMPLEMENT_NODE("Mesh", CMeshNode, CNode)

START_NODE_PROPS(CMeshNode, CNode)
	NODE_PROP(pt_string, CMeshNode, url)
END_NODE_PROPS()

START_NODE_FUN(CMeshNode, CNode)
	NODE_FUN_VS(load)
END_NODE_FUN()

CMeshNode::CMeshNode() :
	m_url(NULL)
{
	m_pNext = c_pFirst;
	c_pFirst = this;
	m_renderTime = 0.0f;

	m_bDirty = true;
	m_pMesh = NULL;
	m_bOwnMesh = true;
}

CMeshNode::~CMeshNode()
{
	if (m_bOwnMesh)
		delete m_pMesh;

	delete [] m_url;

	for (CMeshNode** ppMeshNode = &c_pFirst; *ppMeshNode != this; ppMeshNode = &(*ppMeshNode)->m_pNext)
		ASSERT(*ppMeshNode != NULL);
	*ppMeshNode = m_pNext;
}

bool CMeshNode::Initialize()
{
	ASSERT(m_bDirty);

	if (m_url != NULL && m_url[0] != 0)
		load(m_url);

	Init();

	return m_pMesh != NULL;
}

void CMeshNode::Init()
{
	m_bDirty = false;
}

void CMeshNode::Render()
{
	m_renderTime = XAppGetNow();

	if (m_bDirty && !Initialize())
		return;

	if (m_pMesh != NULL)
		m_pMesh->Render(g_pRenderMeshNode != this); // REVIEW: Does this ever happen anymore?
}

void CMeshNode::load(const TCHAR* szFile)
{
	ASSERT(m_pMesh == NULL);

	TCHAR szFilePath [MAX_PATH];
	MakeAbsoluteURL(szFilePath, szFile);

	m_pMesh = (CMeshCore*)FindObjectInXIP(szFilePath, szFile);

	if (m_pMesh == NULL)
	{
		m_bOwnMesh = true;
		CMesh* pMesh = LoadMesh(szFilePath);
		m_pMesh = pMesh;
		if (pMesh->GetFVF() == 0)
		{
			delete pMesh;
			MakePath(szFilePath, theApp.m_szAppDir, szFile);
			pMesh = LoadMesh(szFilePath);
			m_pMesh = pMesh;
			if (pMesh->GetFVF() == 0)
				return;
		}
		TRACE(_T("\002Loaded %s from file\n"), szFilePath);
	}
	else
	{
		m_bOwnMesh = false;
//		TRACE(_T("Loaded %s from XIP\n"), szFilePath);
	}
}

DWORD CMeshNode::GetFVF()
{
	if (m_pMesh == NULL)
		return 0;

	return m_pMesh->GetFVF();
}

////////////////////////////////////////////////////////////////////////////

CMesh* LoadMesh(const TCHAR* szFilePath)
{
	CMesh* pMesh = new CMesh;
	pMesh->Load(szFilePath);
	return pMesh;
}

CMesh* CreateMesh(HANDLE hFile)
{
	CMesh* pMesh = new CMesh;
	pMesh->Create(hFile);
	return pMesh;
}

CMesh* CreateMesh(BYTE* pbContent, DWORD cbContent)
{
	CMesh* pMesh = new CMesh;
	pMesh->Create(pbContent, cbContent);
	return pMesh;
}

CMesh* MakeSphere(float nRadius, int nSlices, int nStacks)
{
    HRESULT hr;
	
	CMesh* pMesh = new CMesh;

	pMesh->m_primitiveType = D3DPT_TRIANGLELIST;

	pMesh->m_fvf = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE /*| D3DFVF_TEX1*/;
	pMesh->m_nVertexStride = 3 * sizeof (float) + 3 * sizeof (float) + sizeof (DWORD) /*+ 2 * sizeof (float)*/;

	// REVIEW: Tacky (and inefficient) way to create a sphere!

	LPD3DXMESH pSphere = NULL;
	LPD3DXMESH pClone = NULL;

	hr = D3DXCreateSphere(XAppGetD3DDev(), nRadius, nSlices, nStacks, &pSphere, NULL);

    if (SUCCEEDED(hr))
    {
        ASSERT(pSphere);
	    hr = pSphere->CloneMeshFVF(D3DXMESH_MANAGED, pMesh->m_fvf, XAppGetD3DDev(), &pClone);
        pSphere->Release();
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pClone);
	    hr = D3DXComputeNormals(pClone);
    }

    if (SUCCEEDED(hr))
    {
    	hr = pClone->GetVertexBuffer(&pMesh->m_pVertexBuffer);
    }

    if (SUCCEEDED(hr))
    {
	    hr = pClone->GetIndexBuffer(&pMesh->m_pIndexBuffer);
    }

    if (SUCCEEDED(hr))
    {
        pMesh->m_nIndexCount = pClone->GetNumFaces() * 3;
        pMesh->m_nFaceCount = pClone->GetNumFaces();
        pMesh->m_nVertexCount = pClone->GetNumVertices();
    }
    else
    {
        if (pMesh->m_pVertexBuffer)
        {
            pMesh->m_pVertexBuffer->Release();
        }
        if (pMesh->m_pIndexBuffer)
        {
            pMesh->m_pIndexBuffer->Release();
        }
        delete pMesh;
        pMesh = NULL;
    }

	if (pClone)
    {
        pClone->Release();
    }

	// Compress the vertices
	LPDIRECT3DVERTEXBUFFER8 pCompressedVertexBuffer;
	BYTE *pSrc, *pDst;
	DWORD dwNormal;

	XAppCreateVertexBuffer(pMesh->m_nVertexCount * (3 * sizeof(float) + 2 * sizeof(DWORD)), D3DUSAGE_DYNAMIC, 0, D3DPOOL_MANAGED, &pCompressedVertexBuffer);

	pMesh->m_pVertexBuffer->Lock(0, 0, &pSrc, 0);
	pCompressedVertexBuffer->Lock(0, 0, &pDst, 0);

	for (int i = 0; i < pMesh->m_nVertexCount; i++) 
	{
		memcpy(pDst, pSrc, 3 * sizeof(float));
		pSrc += 3 * sizeof(float);
		pDst += 3 * sizeof(float);
		dwNormal = CompressNormal((float*)pSrc);
		memcpy(pDst, &dwNormal, sizeof(DWORD));
		pSrc += 3 * sizeof(float);
		pDst += sizeof(DWORD);
		memcpy(pDst, pSrc, sizeof(DWORD));
		pSrc += sizeof(DWORD);
		pDst += sizeof(DWORD);
	}

	pCompressedVertexBuffer->Unlock();
	pMesh->m_pVertexBuffer->Unlock();

	pMesh->m_pVertexBuffer->Release();
	pMesh->m_pVertexBuffer = pCompressedVertexBuffer;
	pMesh->m_fvf = D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_DIFFUSE /*| D3DFVF_TEX1*/;
	pMesh->m_nVertexStride = 3 * sizeof (float) + sizeof (DWORD) + sizeof (DWORD) /*+ 2 * sizeof (float)*/;

	return pMesh;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\navinfo.h ===
class CNavigationInfo : public CNode
{
	DECLARE_NODE(CNavigationInfo, CNode)
public:
	CNavigationInfo();
	~CNavigationInfo();

	bool OnSetProperty(const PRD* pprd, const void* pvValue);
	void OnLoad();

	bool m_isBound;
	D3DXVECTOR3 m_avatarSize;
	bool m_headlight;
	float m_speed;
	TCHAR* m_type;
	float m_visibilityLimit;
	CNode* m_shape;

	void Bind();

	DECLARE_NODE_PROPS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\MusicCollection.cpp ===
#include "std.h"
#include "xapp.h"
#include "node.h"
#include "runner.h"
#include "locale.h"
#include "cdda.h"
#include "fileutil.h"

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

extern bool CompressAudio(DWORD dwSongID, short sMax);
extern DWORD g_dwMusicCompressPos;
extern DWORD g_dwMusicCompressLength;

// Weighting factors for calculating the progress of each phase of an audio CD song copy...
const float WEIGHT_READ = 0.30f;
const float WEIGHT_COMPRESS = 0.70f;

// "Special" soundtrack id to represent the audio cd
#define STID_AUDIOCD    65535

#define COPY_NO_ERROR           0
#define COPY_HARDDISK_FULL      1
#define COPY_TOO_MANY_SONGS     2
#define COPY_DISC_EJECTED       3
#define COPY_DISC_READ_ERROR    4

extern "C" {

#define _DASHST_
#include "../dashst/dashst.c"

}; // extern "C"

#define MAX_SOUNDTRACKS 100

#define BLOCK_SIZE  16384

struct CCopySong
{
    DWORD m_dwSongID;
    DWORD m_dwSongLength;
    int m_nSoundtrack;
    int m_nSong;
    float m_progressBase;
    float m_progressAmount;
};

class CMusicCollection : public CNode
{
    DECLARE_NODE(CMusicCollection, CNode)
public:
    CMusicCollection();
    ~CMusicCollection();

    int GetSoundtrackCount();
    int GetSoundtrackID(int nSoundtrack);
    int GetSoundtrackIndexFromID(int nSoundtrackID);
    CStrObject* GetSoundtrackName(int nSoundtrack);
    int GetSoundtrackSongCount(int nSoundtrack);
    CStrObject* FormatSoundtrackTime(int nSoundtrack);
    CStrObject* GetSoundtrackSongID(int nSoundtrack, int nSong);
    CStrObject* GetSoundtrackSongName(int nSoundtrack, int nSong);
    CStrObject* FormatSoundtrackSongTime(int nSoundtrack, int nSong);
    int AddSoundtrack(const TCHAR* szName);
    void DeleteSoundtrack(int nSoundtrack);

    void SetSongName(int nSoundtrack, int nSong, const TCHAR* szName);
    void SetSoundtrackName(int nSoundtrack, const TCHAR* szName);
    void MoveSongUp(int nSoundtrack, int nSong);
    void MoveSongDown(int nSoundtrack, int nSong);
    void DeleteSong(int nSoundtrack, int nSong);

    void ClearCopyList(int nCopySongCount);
    void AddSongToCopyList(int nSoundtrack, int nSong);
    void StartCopy(int nDestSoundtrack);

    CStrObject* CreateSoundtrackName(const TCHAR* szBaseName);
	CStrObject* GetUpdateString(void);

    void Advance(float nSeconds);

    float m_copyProgress;
    int m_error;
    bool m_done;

protected:
    DWORD ThreadProc();
    static DWORD CALLBACK StartThread(LPVOID pvContext);
    void CopySong(CCopySong* pCopySong, TCHAR* pszTrackName);

    bool m_bCopying;
    CCopySong* m_rgCopySong;
    int m_nCopySongCount;
    int m_nCopySongAlloc;
    int m_nCopySongCur;
    float m_lastCopyProgress;
    BYTE* m_buffer;
    HANDLE m_hThread;
    int m_dwDestSoundtrack;
    int m_nTrackCount;

    float m_readProgress;

	DWORD m_strProgress;
	int m_periodStatus;
	TCHAR m_szStatus[MAX_TRANSLATE_LEN];


    DECLARE_NODE_PROPS()
    DECLARE_NODE_FUNCTIONS()
};

static int c_nSoundtrackCount = -1;
static XSOUNDTRACK_DATA* c_rgsoundtrack = NULL;
static void DeleteAll();
static void Update();


IMPLEMENT_NODE("MusicCollection", CMusicCollection, CNode)

START_NODE_PROPS(CMusicCollection, CNode)
    NODE_PROP(pt_number, CMusicCollection, copyProgress)
    NODE_PROP(pt_integer, CMusicCollection, error)
END_NODE_PROPS()

START_NODE_FUN(CMusicCollection, CNode)
    NODE_FUN_IV(GetSoundtrackCount)
    NODE_FUN_II(GetSoundtrackID)
    NODE_FUN_II(GetSoundtrackIndexFromID)
    NODE_FUN_SI(GetSoundtrackName)
    NODE_FUN_SI(FormatSoundtrackTime)
    NODE_FUN_II(GetSoundtrackSongCount)
    NODE_FUN_SII(GetSoundtrackSongID)
    NODE_FUN_SII(GetSoundtrackSongName)
    NODE_FUN_SII(FormatSoundtrackSongTime)
    NODE_FUN_IS(AddSoundtrack)
    NODE_FUN_VI(DeleteSoundtrack)
    NODE_FUN_VI(ClearCopyList)
    NODE_FUN_VII(AddSongToCopyList)
    NODE_FUN_VI(StartCopy)
    NODE_FUN_VIIS(SetSongName)
    NODE_FUN_VIS(SetSoundtrackName)
    NODE_FUN_VII(MoveSongUp)
    NODE_FUN_VII(MoveSongDown)
    NODE_FUN_VII(DeleteSong)
    NODE_FUN_SS(CreateSoundtrackName)
	NODE_FUN_SV(GetUpdateString)
END_NODE_FUN()


CMusicCollection::CMusicCollection() :
    m_copyProgress(0.0f),
    m_error(COPY_NO_ERROR),
    m_done(false)
{
    m_rgCopySong = 0;
    m_nCopySongCount = 0;
    m_nCopySongAlloc = 0;
    m_lastCopyProgress = 0.0f;
    m_bCopying = false;
    m_buffer = NULL;
    m_hThread = NULL;
}

CMusicCollection::~CMusicCollection()
{
    DeleteAll();

    delete [] m_rgCopySong;
    delete [] m_buffer;
}

static void DeleteAll()
{
    delete [] c_rgsoundtrack;
    c_rgsoundtrack = NULL;
    c_nSoundtrackCount = 0;
}

static int __cdecl SortSoundtrackCompare(const void *elem1, const void *elem2)
{
    const XSOUNDTRACK_DATA* pSoundtrack1 = (const XSOUNDTRACK_DATA*)elem1;
    const XSOUNDTRACK_DATA* pSoundtrack2 = (const XSOUNDTRACK_DATA*)elem2;

    int cch1 = _tcslen(pSoundtrack1->szName);
    int cch2 = _tcslen(pSoundtrack2->szName);

    if (_istdigit(pSoundtrack1->szName[cch1 - 1]) && _istdigit(pSoundtrack2->szName[cch2 - 1]))
    {
        while (cch1 > 0 && _istdigit(pSoundtrack1->szName[cch1 - 1]))
            cch1 -= 1;
        while (cch2 > 0 && _istdigit(pSoundtrack2->szName[cch2 - 1]))
            cch2 -= 1;
        if (cch1 == cch2 && _tcsnicmp(pSoundtrack1->szName, pSoundtrack2->szName, cch1) == 0)
        {
            return _ttoi(pSoundtrack1->szName + cch1) - _ttoi(pSoundtrack2->szName + cch2);
        }
    }

    return _tcsicmp(pSoundtrack1->szName, pSoundtrack2->szName);
}

void Update()
{
    TRACE(_T("Updating soundtrack collection...\n"));

    DeleteAll();

    c_rgsoundtrack = new XSOUNDTRACK_DATA [MAX_SOUNDTRACKS];
    c_nSoundtrackCount = 0;

    // BLOCK: Read all the soundtrack info...
    {
        HANDLE hFind = XFindFirstSoundtrack(&c_rgsoundtrack[c_nSoundtrackCount]);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                c_nSoundtrackCount += 1;
                if (c_nSoundtrackCount == MAX_SOUNDTRACKS)
                    break;
            }
            while (XFindNextSoundtrack(hFind, &c_rgsoundtrack[c_nSoundtrackCount]));

            XFindClose(hFind);
        }
    }

    TRACE(_T("Found %d soundtracks!\n"), c_nSoundtrackCount);

    qsort(c_rgsoundtrack, c_nSoundtrackCount, sizeof (XSOUNDTRACK_DATA), SortSoundtrackCompare);
}

int GetSoundtrackCount()
{
    if (c_nSoundtrackCount < 0)
        Update();

    return c_nSoundtrackCount;
}

int GetSoundtrackSize(int nSoundtrack, HANDLE hCancelEvent)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < -1 || nSoundtrack >= c_nSoundtrackCount)
        return 0;

    TCHAR szPath [MAX_PATH];
    if (nSoundtrack == -1)
        _stprintf(szPath, _T("c:\\tdata\\fffe0000\\music")); // all of them
    else
        _stprintf(szPath, _T("c:\\tdata\\fffe0000\\music\\%04x"), c_rgsoundtrack[nSoundtrack].uSoundtrackId);

    return GetDirectoryBlocks(szPath, 16384, true, hCancelEvent);
}

const TCHAR* GetSoundtrackName(int nSoundtrack)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
        return NULL;

    return c_rgsoundtrack[nSoundtrack].szName;
}

int CMusicCollection::GetSoundtrackCount()
{
    if (c_nSoundtrackCount < 0)
        Update();

    return c_nSoundtrackCount;
}

int CMusicCollection::GetSoundtrackID(int nSoundtrack)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
        return 0;

    return c_rgsoundtrack[nSoundtrack].uSoundtrackId;
}

int CMusicCollection::GetSoundtrackIndexFromID(int nSoundtrackID)
{
    if (c_nSoundtrackCount < 0)
        Update();

    for (int i=0; i<c_nSoundtrackCount; i++)
    {
        if (c_rgsoundtrack[i].uSoundtrackId == nSoundtrackID)
        {
            return i;
        }
    }

    return 0;
}

CStrObject* CMusicCollection::GetSoundtrackName(int nSoundtrack)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
        return new CStrObject;

    ASSERT(c_rgsoundtrack != NULL);

    return new CStrObject(c_rgsoundtrack[nSoundtrack].szName);
}

int CMusicCollection::GetSoundtrackSongCount(int nSoundtrack)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
        return 0;

    return c_rgsoundtrack[nSoundtrack].uSongCount;
}

CStrObject* CMusicCollection::GetSoundtrackSongID(int nSoundtrack, int nSong)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
        return new CStrObject;

    DWORD dwSongID, dwSongLength;
    VERIFY(XGetSoundtrackSongInfo(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, &dwSongID, &dwSongLength, NULL, 0));

    TCHAR szBuf [32];
    _stprintf(szBuf, _T("%d"), dwSongID);
    return new CStrObject(szBuf);
}

CStrObject* CMusicCollection::GetSoundtrackSongName(int nSoundtrack, int nSong)
{
    if (c_nSoundtrackCount < 0)
        Update();

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
        return new CStrObject;

    DWORD dwSongID, dwSongLength;
    TCHAR szName [MAX_SONG_NAME];
    VERIFY(XGetSoundtrackSongInfo(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, &dwSongID, &dwSongLength, szName, countof (szName)));
    return new CStrObject(szName);
}

CStrObject* CMusicCollection::FormatSoundtrackTime(int nSoundtrack)
{
    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
        return new CStrObject;

    UINT nTime = c_rgsoundtrack[nSoundtrack].uSoundtrackLength / 1000;
    UINT nMinutes = nTime / 60;
    UINT nSeconds = nTime % 60;

    TCHAR szBuf [32];
    _stprintf(szBuf, _T("%02u:%02u"), nMinutes, nSeconds);
    return new CStrObject(szBuf);
}

CStrObject* CMusicCollection::FormatSoundtrackSongTime(int nSoundtrack, int nSong)
{
    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
        return new CStrObject;

    DWORD dwSongID, dwSongLength;
    VERIFY(XGetSoundtrackSongInfo(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, &dwSongID, &dwSongLength, NULL, 0));

    UINT nTime = dwSongLength / 1000;
    UINT nMinutes = nTime / 60;
    UINT nSeconds = nTime % 60;

    TCHAR szBuf [32];
    _stprintf(szBuf, _T("%02u:%02u"), nMinutes, nSeconds);
    return new CStrObject(szBuf);
}

int CMusicCollection::AddSoundtrack(const TCHAR* szName)
{
    ASSERT(c_nSoundtrackCount >= 0);

#ifdef DEVKIT
    static const BYTE KeyDigest[] = {
        0x3a, 0x14, 0x47, 0xe8, 0xbd, 0xaf, 0xfc, 0xff, 0x24, 0x7a,
        0x88, 0x1e, 0x93, 0x20, 0x73, 0xef, 0x00, 0x99, 0x22, 0xe8,
        0xdc, 0xc1, 0x7e, 0x01, 0xdd, 0x4c, 0xba, 0x28, 0x07, 0x7d,
        0xe2, 0xf0, 0x37, 0xe2, 0x35, 0xd5, 0xb7, 0x7f, 0xcd, 0x62
    };
#else
    static const BYTE KeyDigest[] = {
        0xa6, 0xcd, 0x04, 0xb7, 0x03, 0x81, 0x9e, 0x38, 0xae, 0xc2,
        0xed, 0xf3, 0xff, 0xb9, 0xa7, 0xa9, 0xc2, 0xa5, 0x39, 0x8c,
        0xdc, 0xc1, 0x7e, 0x01, 0xdd, 0x4c, 0xba, 0x28, 0x07, 0x7d,
        0xe2, 0xf0, 0x37, 0xe2, 0x35, 0xd5, 0xb7, 0x7f, 0xcd, 0x62
    };
#endif

    BYTE Digest[XC_DIGEST_LEN];
    XCCalcDigest((PBYTE)szName, _tcslen(szName) * sizeof(TCHAR), Digest);

    if (memcmp(Digest, KeyDigest, XC_DIGEST_LEN) == 0 || memcmp(Digest, &KeyDigest[XC_DIGEST_LEN], XC_DIGEST_LEN) == 0)
    {
        bool b = DoesFileExist(_T("y:\\Settings_adoc.xip"));
        if (b || Digest[0] == 0xdc)
        {
            CObject* param = new CNumObject(Digest[0] != 0xdc ? 1.0f : 2.0f);
            CallFunction(this, _T("OnAddSoundtrackNewSongFailed"), 1, &param);
            if (Digest[0] != 0xdc) return -3;
        }
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return -1;
    }

    DWORD id;
    if (!DashAddSoundtrack(szName, &id))
    {
        DashEndUsingSoundtracks();
        TRACE(_T("DashAddSoundtrack failed!\n"));
		ASSERT (GetLastError () != ERROR_INVALID_HANDLE);
		//
		// Two main errors:
		// ERROR_NOT_ENOUGH_MEMORY: Too many soundtracks.
		// ERROR_DISK_FULL: Not enough disk space.
		//
        return GetLastError () == ERROR_NOT_ENOUGH_MEMORY ? -1 : -2;
    }

    DashEndUsingSoundtracks();

    for (int i = 0; i < c_nSoundtrackCount; i += 1)
    {
        if (_tcsicmp(szName, c_rgsoundtrack[i].szName) < 0)
            break;
    }

    if (i < c_nSoundtrackCount)
        MoveMemory(&c_rgsoundtrack[i + 1], &c_rgsoundtrack[i], sizeof (XSOUNDTRACK_DATA) * (c_nSoundtrackCount - i));
    c_nSoundtrackCount += 1;

    c_rgsoundtrack[i].uSoundtrackId = id;
    c_rgsoundtrack[i].uSongCount = 0;
    c_rgsoundtrack[i].uSoundtrackLength = 0;
    _tcscpy(c_rgsoundtrack[i].szName, szName);

    return i;
}

void DeleteSoundtrack(int nSoundtrack)
{
    TRACE(_T("CMusicCollection::DeleteSoundtrack: %d\n"), nSoundtrack);

    ASSERT(c_nSoundtrackCount >= 0);

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
    {
        TRACE(_T("DeleteSoundtrack(%d) index out of range!\n"), nSoundtrack);
        return;
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    if (!DashDeleteSoundtrack(c_rgsoundtrack[nSoundtrack].uSoundtrackId))
    {
        DashEndUsingSoundtracks();
        TRACE(_T("DashDeleteSoundtrack failed!\n"));
        return;
    }

    DashEndUsingSoundtracks();

    c_nSoundtrackCount -= 1;
    MoveMemory(&c_rgsoundtrack[nSoundtrack], &c_rgsoundtrack[nSoundtrack + 1], sizeof (XSOUNDTRACK_DATA) * (c_nSoundtrackCount - nSoundtrack));
}

void DeleteAllSoundtracks()
{
    ASSERT(c_nSoundtrackCount >= 0);

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    for (int i = 0; i < c_nSoundtrackCount; i += 1)
    {
        if (!DashDeleteSoundtrack(c_rgsoundtrack[i].uSoundtrackId))
            TRACE(_T("DashDeleteSoundtrack failed!\n"));
    }

    DashEndUsingSoundtracks();

    c_nSoundtrackCount = 0;
}

void CMusicCollection::DeleteSoundtrack(int nSoundtrack)
{
    ::DeleteSoundtrack(nSoundtrack);
}

void CMusicCollection::ClearCopyList(int nSongCount)
{
    delete [] m_rgCopySong;

    m_rgCopySong = new CCopySong[nSongCount];
    m_nCopySongAlloc = nSongCount;
    m_nCopySongCount = 0;
}

void CMusicCollection::AddSongToCopyList(int nSoundtrack, int nSong)
{
    if (m_nCopySongCount >= m_nCopySongAlloc)
    {
        TRACE(_T("CMusicCollection::AddSongToCopyList: too many songs!\n"));
        return;
    }

    if (nSoundtrack == -1)
    {
        int nTrackCount = g_cdrom.GetTrackCount();
        ASSERT(nTrackCount > 0);

        if (nSong < 0 || nSong >= nTrackCount)
        {
            TRACE(_T("CMusicCollection::AddSongToCopyList invalid cd audio track %d\n"), nSong);
            return;
        }

        DWORD dwStartPosition = g_cdrom.GetTrackFrame(nSong);
        DWORD dwStopPosition = g_cdrom.GetTrackFrame(nSong + 1);
        m_rgCopySong[m_nCopySongCount].m_dwSongLength = (dwStopPosition - dwStartPosition) * 1000 / CDAUDIO_FRAMES_PER_SECOND;

        m_rgCopySong[m_nCopySongCount].m_dwSongID = (STID_AUDIOCD << 16) | nSong;
    }
    else
    {
        if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
        {
            TRACE(_T("CMusicCollection::AddSongToCopyList: invalid soundtrack (%d)!\n"), nSoundtrack);
            return;
        }

        if (nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
        {
            TRACE(_T("CMusicCollection::AddSongToCopyList: invalid song (%d)!\n"), nSong);
            return;
        }

        DWORD dwSongID, dwSongLength;
        VERIFY(XGetSoundtrackSongInfo(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, &dwSongID, &dwSongLength, NULL, 0));

        m_rgCopySong[m_nCopySongCount].m_dwSongID = dwSongID;
        m_rgCopySong[m_nCopySongCount].m_dwSongLength = dwSongLength;
        m_rgCopySong[m_nCopySongCount].m_nSoundtrack = nSoundtrack;
        m_rgCopySong[m_nCopySongCount].m_nSong = nSong;
    }

    m_nCopySongCount += 1;
}

void CMusicCollection::Advance(float nSeconds)
{
    CNode::Advance(nSeconds);

    if (m_bCopying)
    {
        if (m_done)
        {
            m_bCopying = false;

            // REVIEW: This is because there is no way to get an update for one soundtrack!
            c_nSoundtrackCount = -1;
            Update();

            CallFunction(this, _T("OnCopyComplete"));
        }
        else
        {
            float compressProgress = 0.0f;

            if (g_dwMusicCompressLength != 0)
            {
                // we're compressing...
                compressProgress = (float)g_dwMusicCompressPos / g_dwMusicCompressLength;
            }

            float songProgress = 0.0f;

            if (HIWORD(m_rgCopySong[m_nCopySongCur].m_dwSongID) == STID_AUDIOCD)
                songProgress = m_readProgress * WEIGHT_READ + compressProgress * WEIGHT_COMPRESS;
            else
                songProgress = m_readProgress;

            m_copyProgress = m_rgCopySong[m_nCopySongCur].m_progressBase + m_rgCopySong[m_nCopySongCur].m_progressAmount * songProgress;

            if (m_copyProgress != m_lastCopyProgress)
            {
                if (m_copyProgress != 0.0f)
				{
                    CallFunction(this, _T("OnCopyProgressChanged"));
					GetUpdateString();
				}
                m_lastCopyProgress = m_copyProgress;
            }
        }
    }
}

CStrObject* CMusicCollection::GetUpdateString(void)
{
	if((GetTickCount() - m_strProgress) > 500)
	{
		m_strProgress = GetTickCount();
		m_periodStatus++;
		if(m_periodStatus > 3)
			m_periodStatus = 0;

		Translate(_T("MUSIC COPYING"), m_szStatus);

		for(int i = 0; i < m_periodStatus; i++)
			_tcscat(m_szStatus, _T("."));
	}

	return new CStrObject(m_szStatus);
}

void CMusicCollection::StartCopy(int nDestSoundtrack)
{
    m_dwDestSoundtrack = c_rgsoundtrack[nDestSoundtrack].uSoundtrackId;
    m_bCopying = true;
    m_done = false;
    m_error = COPY_NO_ERROR;
	m_strProgress = GetTickCount();
	m_periodStatus = 0;
	m_szStatus[0] = 0;
	// Translate(_T("Copying"), m_szStatus);   // JNH - Removed this because it doesn't do anything -- the string that is returned is thrown away

    m_nCopySongCur = 0;
    m_nTrackCount = c_rgsoundtrack[nDestSoundtrack].uSongCount;
    m_lastCopyProgress = m_copyProgress = 0.0f;

    // BLOCK: Calculate how much each song counts towards the progress
    {
        DWORD dwTotalLength = 0;
        for (int i = 0; i < m_nCopySongCount; i += 1)
            dwTotalLength += m_rgCopySong[i].m_dwSongLength;

        float base = 0.0f;
        for (i = 0; i < m_nCopySongCount; i += 1)
        {
            m_rgCopySong[i].m_progressBase = base;
            m_rgCopySong[i].m_progressAmount = (float)m_rgCopySong[i].m_dwSongLength / dwTotalLength;
            base += m_rgCopySong[i].m_progressAmount;

            TRACE(_T("song %d base %f abount %f\n"), i, m_rgCopySong[i].m_progressBase, m_rgCopySong[i].m_progressAmount);
        }
    }

    if (m_buffer == NULL)
        m_buffer = new BYTE [BLOCK_SIZE];

    DWORD dwThreadID;
    VERIFY((m_hThread = CreateThread(NULL, 0, StartThread, this, 0, &dwThreadID)) != NULL);
}

DWORD CALLBACK CMusicCollection::StartThread(LPVOID pvContext)
{
    CMusicCollection *pThis = (CMusicCollection*)pvContext;
    return pThis->ThreadProc();
}

DWORD CMusicCollection::ThreadProc()
{
    ASSERT(m_buffer != NULL);

    while (!m_error && m_nCopySongCur < m_nCopySongCount)
    {
        // Get the song name and pass it in to the CopySong Functions
        // We are doing this work here, instead of
        if(HIWORD(m_rgCopySong[m_nCopySongCur].m_dwSongID) == STID_AUDIOCD)
        {
            CopySong( &m_rgCopySong[m_nCopySongCur], NULL );
        }
        else
        {
            TCHAR pszSongName[MAX_SONG_NAME];
            pszSongName[0] = 0;

            DWORD dwSongID, dwSongLength;
            VERIFY(XGetSoundtrackSongInfo(HIWORD(m_rgCopySong[m_nCopySongCur].m_dwSongID), m_rgCopySong[m_nCopySongCur].m_nSong, &dwSongID, &dwSongLength, pszSongName, MAX_SONG_NAME));

            CopySong(&m_rgCopySong[m_nCopySongCur], pszSongName );
        }
        m_nCopySongCur += 1;
    }

    m_done = true;

    delete [] m_buffer;
    m_buffer = NULL;

    m_hThread = NULL;

    return 1;
}

void CMusicCollection::CopySong(CCopySong* pCopySong, TCHAR* pszTrackName)
{
    CHAR szDestFile[MAX_PATH];
    int nSoundtrack = GetSoundtrackIndexFromID(m_dwDestSoundtrack);

    TCHAR szTranslateBuffer[MAX_TRANSLATE_LEN];
    Translate(_T("TRACK"), szTranslateBuffer);

    ASSERT(nSoundtrack < c_nSoundtrackCount);
    ASSERT(!m_error);

    m_readProgress = 0.0f;

    // Bail out if already we already reach MAX_SONGS maximum tracks
    if (c_rgsoundtrack[nSoundtrack].uSongCount >= MAX_SONGS)
    {
        m_error = COPY_TOO_MANY_SONGS;
        return;
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    DWORD dwNewSongID = DashGetNewSongId(m_dwDestSoundtrack);

    TCHAR szName [MAX_SONG_NAME];
    m_nTrackCount += 1;

    if (HIWORD(pCopySong->m_dwSongID) == STID_AUDIOCD)
    {
        // Set the Track name -- For an Audio CD, it can't have a name, so it's always "Track #"
        _stprintf(szName, _T("%s %d"), szTranslateBuffer, m_nTrackCount);

#ifdef _DEBUG
        DWORD dwStartCopy = GetTickCount();
        DWORD dwStartCompress;
#endif
        CCDDAStreamer streamer(&g_cdrom, 5);

        int nTrack = LOWORD(pCopySong->m_dwSongID);

        DWORD dwStartPosition = g_cdrom.GetTrackFrame(nTrack);
        DWORD dwStopPosition = g_cdrom.GetTrackFrame(nTrack + 1);

        DWORD dwLength = (dwStopPosition - dwStartPosition) * 1000 / CDAUDIO_FRAMES_PER_SECOND;

        if (dwStopPosition < dwStartPosition)
        {
            dwLength = 0;
        }

        // Check if disc is ejected
        if (!g_cdrom.IsOpen())
        {
            m_error = COPY_DISC_EJECTED;
            dwLength = 0;
        }
        else if (dwLength == 0)
        {
            m_error = COPY_DISC_READ_ERROR;
        }

        if (m_error)
        {
            goto end_ripping;
        }

        streamer.SetFrame(dwStartPosition);

        strcpy(szDestFile, XappTempPcmFileA);

        HANDLE hDestFile = CreateFileA(szDestFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hDestFile == INVALID_HANDLE_VALUE)
        {
            TRACE(_T("CreateFile(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
            DashEndUsingSoundtracks();
            return;
        }

        // Allocate the clusters for the file now.
        LARGE_INTEGER liDistanceToMove;
        liDistanceToMove.QuadPart = (LONGLONG)(dwStopPosition - dwStartPosition) * CDAUDIO_BYTES_PER_FRAME;
        if (!SetFilePointerEx(hDestFile, liDistanceToMove, NULL, FILE_BEGIN) ||
            !SetEndOfFile(hDestFile))
        {
            TRACE(_T("SetEndOfFile(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
        }

        // Check if we have enough space for WMA file
        ULARGE_INTEGER luiFreeBytesAvailable;
        if (!GetDiskFreeSpaceEx("C:\\", &luiFreeBytesAvailable, 0, 0) || \
            luiFreeBytesAvailable.QuadPart < (ULONGLONG)liDistanceToMove.QuadPart)
        {
            TRACE(_T("Not enough space for WMA file\n"));
            m_error = COPY_HARDDISK_FULL;
        }

        SetFilePointer(hDestFile, 0, NULL, FILE_BEGIN);

        TRACE(_T("Copying track %d from CD to %hs...\n"), nTrack, szDestFile);

        DWORD dwBytesRemaining = liDistanceToMove.LowPart;
        short sMax = -32767;
        while (!m_error && dwBytesRemaining > 0)
        {
            int nRead = streamer.Read(m_buffer, min(BLOCK_SIZE, dwBytesRemaining));
            if (nRead == 0)
                break;

            if (nRead < 0)
            {
                m_error = g_cdrom.IsOpen() ? COPY_DISC_READ_ERROR : COPY_DISC_EJECTED;
                break;
            }

            DWORD dwWrite;
            if (!WriteFile(hDestFile, m_buffer, nRead, &dwWrite, NULL))
            {
                m_error = COPY_HARDDISK_FULL; // hard disk full
                break;
            }

            int nSamples = nRead / 2;
            const short* samples = (const short*)m_buffer;
            for (int i = 0; i < nSamples; i += 1, samples += 1)
            {
                short s = *samples;
                if (s < 0)
                    s = -s;
                if (s > sMax)
                    sMax = s;
            }

            m_readProgress = (float)(min(streamer.GetFrame(), dwStopPosition) -
                dwStartPosition) / (dwStopPosition - dwStartPosition);

            dwBytesRemaining -= nRead;
        }

        if (!SetEndOfFile(hDestFile))
        {
            TRACE(_T("SetEndOfFile(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
        }

        if (!CloseHandle(hDestFile))
        {
            TRACE(_T("CloseHandle(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
        }

        if (!m_error)
        {
            TRACE(_T("Compression audio file...\n"));
#ifdef _DEBUG
            dwStartCompress = GetTickCount();
#endif
            m_error = CompressAudio(dwNewSongID, sMax) ? COPY_NO_ERROR : COPY_HARDDISK_FULL;

            if (!m_error)
            {
                sprintf(szDestFile, "c:\\tdata\\fffe0000\\music\\%04x\\%08x.wma", HIWORD(dwNewSongID), dwNewSongID);
                if (!MoveFileEx(XappTempWmaFileA, szDestFile, 0))
                {
                    TRACE(_T("MoveFileEx(%hs, %hs) failed (%d)\n"), XappTempWmaFileA, szDestFile, GetLastError());
                    DeleteFileA(XappTempWmaFileA);
                    // Restore source file so that the clean up code at the end will be deleting the right file
                    strcpy(szDestFile, XappTempPcmFileA);
                }
            }
        }

#ifdef _DEBUG
        {
            DWORD dwFinish = GetTickCount();
            TRACE(_T("Copy:      %dmS\n"), dwStartCompress - dwStartCopy);
            TRACE(_T("Compress:  %dmS\n"), dwFinish - dwStartCompress);
            TRACE(_T("Total:     %dmS\n"), dwFinish - dwStartCopy);
            TRACE(_T("Copy:      %f%%\n"), ((float)(dwStartCompress - dwStartCopy) / (dwFinish - dwStartCopy)) * 100.0f);
            TRACE(_T("Compress:  %f%%\n"), ((float)(dwFinish - dwStartCompress) / (dwFinish - dwStartCopy)) * 100.0f);
        }
#endif
end_ripping:
        NOTHING;
    }
    else
    {
        // Set the Track name -- For a Soundtrack, we need to check to see if the String starts with "Track".
        // If so, we don't want to copy the name (we will generate it) -- if it's different, we will copy the
        // song name
        if( _tcsnccmp( pszTrackName, szTranslateBuffer, _tcslen(szTranslateBuffer) ) == 0 )
        //
        // Yes, the name matches our default, we should not copy the name
        //
        {
            _stprintf(szName, _T("%s %d"), szTranslateBuffer, m_nTrackCount);
        }
        else
        //
        // No, our name does not match the default name, we should copy the track name
        //
        {
            lstrcpyn(szName, pszTrackName, MAX_SONG_NAME);
        }

        CHAR szSrcFile [MAX_PATH];
        sprintf(szSrcFile, "c:\\tdata\\fffe0000\\music\\%04x\\%08x.wma", HIWORD(pCopySong->m_dwSongID), pCopySong->m_dwSongID);
        sprintf(szDestFile, "c:\\tdata\\fffe0000\\music\\%04x\\%08x.wma", m_dwDestSoundtrack, dwNewSongID);

        HANDLE hSrcFile = CreateFileA(szSrcFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hSrcFile == INVALID_HANDLE_VALUE)
        {
            TRACE(_T("CreateFile(%hs) failed (%d)\n"), szDestFile, GetLastError());
            m_error = COPY_HARDDISK_FULL; // hard disk full
            DashEndUsingSoundtracks();
            return;
        }

        HANDLE hDestFile = CreateFileA(szDestFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hDestFile == INVALID_HANDLE_VALUE)
        {
            CloseHandle(hSrcFile);

            TRACE(_T("CreateFile(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
            DashEndUsingSoundtracks();
            return;
        }

        TRACE(_T("Copying file from %hs to %hs\n"), szSrcFile, szDestFile);

        DWORD dwPos = 0;
        DWORD dwLen = GetFileSize(hSrcFile, NULL);

        // Allocate the clusters for the file now.
        LARGE_INTEGER liDistanceToMove;
        liDistanceToMove.QuadPart = (LONGLONG)dwLen;
        if (!SetFilePointerEx(hDestFile, liDistanceToMove, NULL, FILE_BEGIN) ||
            !SetEndOfFile(hDestFile))
        {
            TRACE(_T("SetEndOfFile(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
        }

        SetFilePointer(hDestFile, 0, NULL, FILE_BEGIN);

        if (!m_error)
        {
            for (;;)
            {
                DWORD dwRead, dwWrite;

                if (!ReadFile(hSrcFile, m_buffer, BLOCK_SIZE, &dwRead, NULL))
                {
                    TRACE(_T("ReadFile(%s) failed (%d)\n"), szSrcFile, GetLastError());
                    m_error = COPY_HARDDISK_FULL; // hard disk full
                    break;
                }

                if (dwRead == 0)
                    break;

                if (!WriteFile(hDestFile, m_buffer, dwRead, &dwWrite, NULL))
                {
                    TRACE(_T("WriteFile(%hs) failed (%d)\n"), szDestFile, GetLastError());
                    m_error = COPY_HARDDISK_FULL; // hard disk full
                    break;
                }

                dwPos += dwRead;
                m_readProgress = (float)dwPos / dwLen;
            }
        }

        if (!m_error)
        {
            FILETIME create, access, write;
            GetFileTime(hSrcFile, &create, &access, &write);
            SetFileTime(hDestFile, &create, &access, &write);
        }

        CloseHandle(hSrcFile);

        if (!CloseHandle(hDestFile))
        {
            TRACE(_T("CloseHandle(%hs) failed\n"), szDestFile);
            m_error = COPY_HARDDISK_FULL; // hard disk full
        }

        m_readProgress = 1.0f;
    }

    TRACE(_T("Adding the file to the soundtrack database...\n"));

    if (!m_error && !DashAddSongToSoundtrack(m_dwDestSoundtrack, dwNewSongID, pCopySong->m_dwSongLength, szName))
    {
        TRACE(_T("DashAddSongToSoundtrack failed!\n"));
        m_error = COPY_TOO_MANY_SONGS; // more than MAX_SONGS tracks
    }

    DashEndUsingSoundtracks();

    if (m_error)
    {
        ::DeleteFile(szDestFile);
    }
    else
    {
        c_rgsoundtrack[nSoundtrack].uSongCount++;
    }
}

void CMusicCollection::SetSongName(int nSoundtrack, int nSong, const TCHAR* szName)
{
    TRACE(_T("SetSongName(%d, %d, %s)\n"), nSoundtrack, nSong, szName);

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
    {
        TRACE(_T("CMusicCollection::SetSongName: soundtrack or song out of range!\n"));
        return;
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    VERIFY(DashEditSongName(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, szName));

    DashEndUsingSoundtracks();
}

void CMusicCollection::SetSoundtrackName(int nSoundtrack, const TCHAR* szName)
{
    TRACE(_T("SetSoundtrackName(%d, %s)\n"), nSoundtrack, szName);

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount)
    {
        TRACE(_T("CMusicCollection::SetSoundtrackName: soundtrack out of range!\n"));
        return;
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    VERIFY(DashEditSoundtrackName(c_rgsoundtrack[nSoundtrack].uSoundtrackId, szName));
    DashEndUsingSoundtracks();
    Update();
}

void CMusicCollection::MoveSongUp(int nSoundtrack, int nSong)
{
    TRACE(_T("MoveSongUp(%d, %d)\n"), nSoundtrack, nSong);

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong <= 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
    {
        TRACE(_T("CMusicCollection::MoveSongUp: soundtrack or song out of range!\n"));
        return;
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    VERIFY(DashSwapSongs(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, nSong - 1));

    DashEndUsingSoundtracks();
}

void CMusicCollection::MoveSongDown(int nSoundtrack, int nSong)
{
    TRACE(_T("MoveSongDown(%d, %d)\n"), nSoundtrack, nSong);

    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount - 1)
    {
        TRACE(_T("CMusicCollection::MoveSongDown: soundtrack or song out of range!\n"));
        return;
    }

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    VERIFY(DashSwapSongs(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, nSong + 1));

    DashEndUsingSoundtracks();
}

void CMusicCollection::DeleteSong(int nSoundtrack, int nSong)
{
    if (nSoundtrack < 0 || nSoundtrack >= c_nSoundtrackCount || nSong < 0 || (UINT)nSong >= c_rgsoundtrack[nSoundtrack].uSongCount)
    {
        TRACE(_T("CMusicCollection::DeleteSong: soundtrack or song out of range!\n"));
        return;
    }

    DWORD dwSongID, dwSongLength;
    VERIFY(XGetSoundtrackSongInfo(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong, &dwSongID, &dwSongLength, NULL, 0));

    if (!DashBeginUsingSoundtracks())
    {
        TRACE(_T("DashBeginUsingSoundtracks failed!\n"));
        return;
    }

    VERIFY(DashDeleteSongFromSoundtrack(c_rgsoundtrack[nSoundtrack].uSoundtrackId, nSong));

    c_rgsoundtrack[nSoundtrack].uSongCount -= 1;
    c_rgsoundtrack[nSoundtrack].uSoundtrackLength -= dwSongLength;

    DashEndUsingSoundtracks();
}

int FindSoundtrack(const TCHAR* szName)
{
    for (int i = 0; i < c_nSoundtrackCount; i += 1)
    {
        if (_tcsicmp(szName, c_rgsoundtrack[i].szName) == 0)
            return i;
    }

    return -1;
}

CStrObject* CMusicCollection::CreateSoundtrackName(const TCHAR* szBaseName)
{
    TCHAR szBuf [MAX_SOUNDTRACK_NAME];

    for (int n = 1; ; n += 1)
    {
        _stprintf(szBuf, _T("%s %d"), szBaseName, n);
        if (FindSoundtrack(szBuf) < 0)
            return new CStrObject(szBuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\navinfo.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "NavInfo.h"


IMPLEMENT_NODE("NavigationInfo", CNavigationInfo, CNode)

START_NODE_PROPS(CNavigationInfo, CNode)
	NODE_PROP(pt_boolean, CNavigationInfo, isBound)
	NODE_PROP(pt_vec3, CNavigationInfo, avatarSize)
	NODE_PROP(pt_boolean, CNavigationInfo, headlight)
	NODE_PROP(pt_number, CNavigationInfo, speed)
	NODE_PROP(pt_string, CNavigationInfo, type)
	NODE_PROP(pt_number, CNavigationInfo, visibilityLimit)
	NODE_PROP(pt_node, CNavigationInfo, shape)
END_NODE_PROPS()

CNavigationInfo::CNavigationInfo() :
	m_isBound(false),
	m_avatarSize(0.25f, 1.6f, 0.75f),
	m_headlight(true),
	m_speed(1.0f),
	m_type(NULL),
	m_visibilityLimit(0.0f),
	m_shape(NULL)
{
}

CNavigationInfo::~CNavigationInfo()
{
	delete [] m_type;

	if (theApp.m_pNavigationInfo == this)
		theApp.m_pNavigationInfo = NULL;
}

void CNavigationInfo::OnLoad()
{
	CNode::OnLoad();

	if (theApp.m_pNavigationInfo == NULL)
	{
		theApp.m_pNavigationInfo = this;
		Bind();
	}
}

void CNavigationInfo::Bind()
{
	m_isBound = true;

#ifndef _XBOX
	if (m_type != NULL)
	{
		CNavigator* pNavigator = CNavigator::Lookup(m_type);
		if (pNavigator == NULL)
		{
			TRACE(_T("\001Unknown navigation type: %s\n"), m_type);
		}
		else
		{
			theApp.m_pNavigator = pNavigator;
		}
	}
#endif

	theApp.m_bProjectionDirty = true;
}

bool CNavigationInfo::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_isBound))
	{
		if (*(bool*)pvValue)
			Bind();
	}
	else if ((int)pprd->pbOffset == offsetof(m_avatarSize))
	{
		theApp.m_bProjectionDirty = true;
	}
	else if ((int)pprd->pbOffset == offsetof(m_visibilityLimit))
	{
		theApp.m_bProjectionDirty = true;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Mesh.h ===
#pragma once

struct MESHFILEHEADER
{
	DWORD dwPrimitiveType;
	DWORD dwFaceCount;
	DWORD dwFVF;
	DWORD dwVertexStride;
	DWORD dwVertexCount;
	DWORD dwIndexCount;
};

class CMeshCore
{
public:
	virtual void Render(bool bSetFVF = true) = 0;
	virtual DWORD GetFVF() const = 0;
};

class CMesh : public CMeshCore
{
public:
	CMesh();
	virtual ~CMesh();

	bool Load(const TCHAR* szFilePath);
	bool Create(HANDLE hFile);
	bool Create(BYTE* pbContent, DWORD cbContent);
	void Render(bool bSetFVF = true);
	DWORD GetFVF() const;

	int m_nFaceCount;
	int m_nVertexCount;
	int m_nIndexCount;
	D3DPRIMITIVETYPE m_primitiveType;
	DWORD m_fvf;
	int m_nVertexStride;
	IDirect3DVertexBuffer8* m_pVertexBuffer;
	IDirect3DIndexBuffer8* m_pIndexBuffer;

	friend class CIndexedFaceSet;
};

class CMeshRef : public CMeshCore
{
public:
	void Render(bool bSetFVF = true);
	DWORD GetFVF() const;

	class CXipFile* m_pXipFile;
	int m_nMeshBuffer;

	int m_nFirstIndex;
	int m_nPrimitiveCount;
};

extern CMesh* LoadMesh(const TCHAR* szFilePath);
extern CMesh* CreateMesh(HANDLE hFile);
extern CMesh* CreateMesh(BYTE* pbContent, DWORD cbContent);
extern CMesh* MakeSphere(float nRadius, int nSlices, int nStacks);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ntiosvc.cpp ===
#include "std.h"
#include "xapp.h"
#include "CDPlayer.h"

CNtIoctlCdromService g_cdrom;

////////////////////////////////////////////////////////////////////////////

CNtIoctlCdromService::CNtIoctlCdromService()
{
    m_hDevice = INVALID_HANDLE_VALUE;
}

CNtIoctlCdromService::~CNtIoctlCdromService()
{
    Close();
}

void CNtIoctlCdromService::Close()
{
    if (m_hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hDevice);
        m_hDevice = INVALID_HANDLE_VALUE;
    }

    m_toc.Delete();
}

HRESULT CNtIoctlCdromService::Open(DWORD dwDriveNumber)
{
//  Close();

    ASSERT(m_hDevice == INVALID_HANDLE_VALUE);

#ifdef _WINDOWS
    TCHAR szPath [] = _T("\\\\.\\A:");
    szPath[4] += (TCHAR)dwDriveNumber;
#endif
#ifdef _XBOX
    TCHAR szPath [] = _T("CDROM0:");
#endif

    m_hDevice = XAppCreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (m_hDevice == INVALID_HANDLE_VALUE)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
#ifdef _DEBUG
        LogComError(hr, "CNtIoctlCdromService::Initialize");
#endif
        return hr;
    }

    if (!GetTableOfContents())
        Close();

    return S_OK;
}


bool CNtIoctlCdromService::GetTableOfContents()
{
    HRESULT hr;
    CDROM_TOC toc;

    for (int nRetry = 0; nRetry < 1; nRetry += 1)
    {
        hr = DeviceIoControl(IOCTL_CDROM_READ_TOC, NULL, 0, &toc, sizeof (toc));

        if (SUCCEEDED(hr))
            break;

        if (hr != HRESULT_FROM_WIN32(ERROR_NOT_READY))
        {
#ifdef _DEBUG
            LogComError(hr, "CNtIoctlCdromService::GetTableOfContents");
#endif
            return false;
        }
        else
        {
            TRACE(_T("ERROR_NOT_READY\n"));
        }

//      Sleep(10);
    }

    if (FAILED(hr))
        return false;

    // BLOCK: Convert TOC format...
    {
        TRACE(_T("Read TOC: %d tracks\n"), toc.LastTrack);

        // Verify that the TOC is structurally correct and has at least one
        // track.
        if (toc.FirstTrack > toc.LastTrack)
            return false;

        BOOL fFoundEndTrack = FALSE;

        for (DWORD i = 0; i <= (DWORD)(toc.LastTrack - toc.FirstTrack + 1); i++)
        {
#define TOC_DATA_TRACK              (0x04)
#define TOC_LAST_TRACK              (0xaa)

            m_toc.TrackAddr[i] = TocValToFrames(toc.TrackData[i].Address);

            // Break out if we find a last track marker.
            if (toc.TrackData[i].TrackNumber == TOC_LAST_TRACK)
            {
                fFoundEndTrack = TRUE;
                break;
            }

            // Break out if we find a data track.
            if ((toc.TrackData[i].Control & TOC_DATA_TRACK) != 0)
            {
                // Knock off 2.5 minutes to account for the final leadin.
                toc.TrackData[i].Address[1] -= 2;
                toc.TrackData[i].Address[2] += 30;

                if (toc.TrackData[i].Address[2] < 60)
                    toc.TrackData[i].Address[1] -= 1;
                else
                    toc.TrackData[i].Address[2] -= 60;

                m_toc.TrackAddr[i] = TocValToFrames(toc.TrackData[i].Address);

                fFoundEndTrack = TRUE;
                break;
            }
        }

        // If we didn't find an ending track, whether it be a data track or a
        // track with the last track marker, then knock off one track because we
        // don't know how long the last "audio" track might really be.  We can't
        // underflow "i" here because the above code already checked for an
        // empty TOC.
        if (!fFoundEndTrack)
            i--;

        m_toc.LastTrack = i;
    }

#ifdef _CD_INFO
    if (m_toc.LastTrack > 0)
    {
        m_toc.UpdateDiscID();
        FetchDiscInfo(&m_toc);
    }
#endif

    return m_toc.LastTrack > 0;
}

HRESULT CNtIoctlCdromService::Read(DWORD  dwReadStart, DWORD  dwReadLength, LPVOID pvBuffer, DWORD dwRetries)
{
    RAW_READ_INFO rri;
    HRESULT hr;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    rri.DiskOffset.QuadPart = (ULONGLONG)(dwReadStart - 150) * (ULONGLONG)2048;
    rri.SectorCount = dwReadLength;
    rri.TrackMode = CDDA;

    do
    {
        hr = DeviceIoControl(IOCTL_CDROM_RAW_READ, &rri, sizeof (rri), pvBuffer, CDAUDIO_BYTES_PER_FRAME * dwReadLength);

        if (SUCCEEDED(hr))
            break;

#ifdef _DEBUG
        if (hr != HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
            LogComError(hr, "CNtIoctlCdromService::Read");
#endif
    }
    while(dwRetries--);

    return hr;
}

HRESULT CNtIoctlCdromService::DeviceIoControl(DWORD dwControlCode, LPVOID pvInBuffer, DWORD dwInBufferSize, LPVOID pvOutBuffer, DWORD dwOutBufferSize, LPDWORD pdwBytesReturned)
{
    DWORD dwBytesReturned;

    if (pdwBytesReturned == NULL)
        pdwBytesReturned = &dwBytesReturned;

    if (!::DeviceIoControl(m_hDevice, dwControlCode, pvInBuffer, dwInBufferSize, pvOutBuffer, dwOutBufferSize, pdwBytesReturned, NULL))
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}

bool CNtIoctlCdromService::GetTotalLength(int* pnMinutes, int* pnSeconds, int* pnFrames)
{
    if (!IsOpen())
        return false;

    DWORD dwFrames = m_toc.TrackAddr[GetTrackCount()] - m_toc.TrackAddr[0];
    DWORD dwMsf = FramesToMsf(dwFrames);

    if (pnMinutes != NULL)
        *pnMinutes = MCI_MSF_MINUTE(dwMsf);

    if (pnSeconds != NULL)
        *pnSeconds = MCI_MSF_SECOND(dwMsf);

    if (pnFrames != NULL)
        *pnFrames = MCI_MSF_FRAME(dwMsf);

    return true;
}

bool CNtIoctlCdromService::GetTrackLength(int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames)
{
    if (!IsOpen() || nTrack < 0 || nTrack > GetTrackCount() - 1)
        return false;

    DWORD dwFrames = m_toc.TrackAddr[nTrack + 1] - m_toc.TrackAddr[nTrack];
    DWORD dwMsf = FramesToMsf(dwFrames);

    if (pnMinutes != NULL)
        *pnMinutes = MCI_MSF_MINUTE(dwMsf);

    if (pnSeconds != NULL)
        *pnSeconds = MCI_MSF_SECOND(dwMsf);

    if (pnFrames != NULL)
        *pnFrames = MCI_MSF_FRAME(dwMsf);

    return true;
}


#ifdef _CD_INFO
const TCHAR* CNtIoctlCdromService::GetTitle()
{
    if (!IsOpen())
        return NULL;

    return m_toc.szTitle;
}

const TCHAR* CNtIoctlCdromService::GetArtist()
{
    if (!IsOpen())
        return NULL;

    return m_toc.szArtist;
}

const TCHAR* CNtIoctlCdromService::GetTrackName(int nTrack)
{
    if (!IsOpen())
        return NULL;

    ASSERT(nTrack >= 0 && nTrack < m_toc.LastTrack);

    return m_toc.rgszTrack[nTrack];
}
#endif//_CD_INFO

////////////////////////////////////////////////////////////////////////////

XCDROM_TOC::XCDROM_TOC()
{
    Clear();
}

XCDROM_TOC::~XCDROM_TOC()
{
    Delete();
}

void XCDROM_TOC::Delete()
{
#ifdef _CD_INFO
    delete [] szTitle;
    delete [] szArtist;
    delete [] szID;

    for (unsigned i = 0; i < 100; i += 1)
        delete [] rgszTrack[i];
#endif

    Clear();
}

void XCDROM_TOC::Clear()
{
#ifdef _CD_INFO
    szTitle = NULL;
    szArtist = NULL;
    szID = NULL;

    for (unsigned i = 0; i < 100; i += 1)
    {
        rgszTrack[i] = NULL;
        TrackAddr[i] = 0;
    }
#endif

    LastTrack = 0;
}

int XCDROM_TOC::GetTrackFromFrame(DWORD dwPosition) const
{
    for (int i = 0; i < LastTrack; i += 1)
    {
        if (dwPosition < TrackAddr[i + 1])
            return i;
    }

    return 0;
}

// Calculate the disc id used by WindowsMedia.com
#ifdef _CD_INFO
void XCDROM_TOC::UpdateDiscID()
{
    ASSERT(szID == NULL);
    szID = new TCHAR [6 * LastTrack + 1];

    TCHAR* pch = szID;
    for (int i = 0; i < LastTrack; i += 1)
        pch += _stprintf(pch, _T("%06X"), TrackAddr[i]);
    *pch = 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Node.h ===
#include "DefUse.h"
#include "ActiveFile.h"

struct BBox
{
	D3DXVECTOR3 center;
	D3DXVECTOR3 size;
};

////////////////////////////////////////////////////////////////////////////

class CIntArray
{
public:
	CIntArray();
	~CIntArray();

	void SetSize(int nSize);

	int m_nAlloc;
	int m_nSize;
	int* m_value;
};

////////////////////////////////////////////////////////////////////////////

class CNumArray
{
public:
	CNumArray();
	~CNumArray();

	void SetSize(int nSize);

	int m_nAlloc;
	int m_nSize;
	float* m_value;
};

////////////////////////////////////////////////////////////////////////////

class CVec2Array
{
public:
	CVec2Array();
	~CVec2Array();

	void SetSize(int nSize);

	int m_nAlloc;
	int m_nSize;
	D3DXVECTOR2* m_value;
};

////////////////////////////////////////////////////////////////////////////

class CVec3Array
{
public:
	CVec3Array();
	~CVec3Array();

	void SetSize(int nSize);

	int m_nAlloc;
	int m_nSize;
	D3DXVECTOR3* m_value;
};

////////////////////////////////////////////////////////////////////////////

class CVec4Array
{
public:
	CVec4Array();
	~CVec4Array();

	void SetSize(int nSize);

	int m_nAlloc;
	int m_nSize;
	D3DXVECTOR4* m_value;
};

////////////////////////////////////////////////////////////////////////////

class CObject;
class CNode;
class CNodeClass;
class CNumObject;
class CStrObject;
class CSurfx;
class CFunction;
class CRunner;

#define objUndefined		0
#define objNull				1
#define objNumber			2
#define objString			3
#define objVariable			4
#define objNode				5
#define objClass			6
#define objNodeArray		7
#define objFunctionRef		8
#define objMember			9
#define objMemberVar		10
#define objInstance			11
#define objUse				12
#define objFunction			13
#define objMemberFunction	14
#define objArray			15
#define objVec3				16

enum PROP_TYPE
{
	pt_null,
	pt_integer,
	pt_boolean,
	pt_number,
	pt_children,
	pt_vec3,
	pt_vec4,
	pt_quaternion,
	pt_color,
	pt_node,
	pt_string,
	pt_nodearray,
	pt_intarray,
	pt_numarray,
	pt_vec2array,
	pt_vec3array,
	pt_vec4array
};


// PRoperty Descriptor
//
struct PRD
{
	const void* pbOffset;
	PROP_TYPE nType;
	const TCHAR* szName;
};


////////////////////////////////////////////////////////////////////////////
// Member Functions...

typedef CObject* (__cdecl CObject::*NODE_PFN)(void);

#define sig_default			0
#define sig_vv				1
#define sig_iv				2
#define sig_ii				3
#define sig_si				4
#define sig_ss				5
#define sig_isi				6
#define sig_sii				7
#define sig_sv				8
#define sig_nv				9
#define sig_nn				10
#define sig_nnn				11
#define sig_vs				12
#define sig_vss				13
#define sig_vi				14
#define sig_ov				15
#define sig_os				16
#define sig_oo				17
#define sig_vii				18
#define sig_vn				19
#define sig_vnn				20
#define sig_vo				21
#define sig_vnnn			22
#define sig_vnnnn			23
#define sig_iii				24
#define sig_is				25
#define sig_viis			26
#define sig_ni				27
#define sig_vis				28

union FSIG
{
	NODE_PFN pfn;

	CObject* (CObject::*pfn_default)(CObject** rgparam, int nParam);
	void (CObject::*pfn_vv)(void);
	void (CObject::*pfn_vi)(int);
	void (CObject::*pfn_vii)(int, int);
	void (CObject::*pfn_vis)(int, const TCHAR*);
	void (CObject::*pfn_viis)(int, int, const TCHAR*);
	int (CObject::*pfn_iv)(void);
	int (CObject::*pfn_ii)(int);
	int (CObject::*pfn_is)(const TCHAR*);
	int (CObject::*pfn_iii)(int, int);
	CStrObject* (CObject::*pfn_sv)(void);
	CStrObject* (CObject::*pfn_si)(int);
	CStrObject* (CObject::*pfn_sii)(int, int);
	CStrObject* (CObject::*pfn_ss)(const TCHAR*);
	void (CObject::*pfn_vs)(const TCHAR*);
	void (CObject::*pfn_vss)(const TCHAR*, const TCHAR*);
	float (CObject::*pfn_nv)(void);
	float (CObject::*pfn_nn)(float);
	float (CObject::*pfn_nnn)(float, float);
	void (CObject::*pfn_vn)(float);
	void (CObject::*pfn_vnn)(float, float);
	void (CObject::*pfn_vnnn)(float, float, float);
	void (CObject::*pfn_vnnnn)(float, float, float, float);
	CObject* (CObject::*pfn_ov)(void);
	CObject* (CObject::*pfn_os)(const TCHAR*);
	CObject* (CObject::*pfn_oo)(CObject* pObject);
	void (CObject::*pfn_vo)(CObject* pObject);
	float (CObject::*pfn_ni)(int);
};

// FuNction Descriptors
//
struct FND
{
	union FSIG pfn;
	WORD sig;
	const TCHAR* szName;
};

#define START_NODE_FUN(className, baseClassName) \
	FND className::c_rgfnd [] = {

#define END_NODE_FUN() \
	{ NULL, 0, NULL } };

#define NODE_FUN(name) \
	{ (NODE_PFN)(CObject* (CObject::*)(CObject**, int))&name, sig_default, _T(#name) },

#define NODE_FUN_VV(name) \
	{ (NODE_PFN)(void (CObject::*)(void))&name, sig_vv, _T(#name) },

#define NODE_FUN_VI(name) \
	{ (NODE_PFN)(void (CObject::*)(int))&name, sig_vi, _T(#name) },

#define NODE_FUN_VII(name) \
	{ (NODE_PFN)(void (CObject::*)(int, int))&name, sig_vii, _T(#name) },

#define NODE_FUN_VIIS(name) \
	{ (NODE_PFN)(void (CObject::*)(int, int, const TCHAR*))&name, sig_viis, _T(#name) },

#define NODE_FUN_VIS(name) \
	{ (NODE_PFN)(void (CObject::*)(int, const TCHAR*))&name, sig_vis, _T(#name) },

#define NODE_FUN_IV(name) \
	{ (NODE_PFN)(int (CObject::*)(void))&name, sig_iv, _T(#name) },

#define NODE_FUN_II(name) \
	{ (NODE_PFN)(int (CObject::*)(int))&name, sig_ii, _T(#name) },

#define NODE_FUN_III(name) \
	{ (NODE_PFN)(int (CObject::*)(int, int))&name, sig_iii, _T(#name) },

#define NODE_FUN_SI(name) \
	{ (NODE_PFN)(CStrObject* (CObject::*)(int))&name, sig_si, _T(#name) },

#define NODE_FUN_SII(name) \
	{ (NODE_PFN)(CStrObject* (CObject::*)(int, int))&name, sig_sii, _T(#name) },

#define NODE_FUN_SS(name) \
	{ (NODE_PFN)(CStrObject* (CObject::*)(const TCHAR*))&name, sig_ss, _T(#name) },

#define NODE_FUN_SV(name) \
	{ (NODE_PFN)(CStrObject* (CObject::*)(void))&name, sig_sv, _T(#name) },

#define NODE_FUN_VS(name) \
	{ (NODE_PFN)(void (CObject::*)(const TCHAR*))&name, sig_vs, _T(#name) },

#define NODE_FUN_VSS(name) \
	{ (NODE_PFN)(void (CObject::*)(const TCHAR*, const TCHAR*))&name, sig_vss, _T(#name) },

#define NODE_FUN_NV(name) \
	{ (NODE_PFN)(float (CObject::*)(void))&name, sig_nv, _T(#name) },

#define NODE_FUN_NI(name) \
	{ (NODE_PFN)(float (CObject::*)(int))&name, sig_ni, _T(#name) },

#define NODE_FUN_NN(name) \
	{ (NODE_PFN)(float (CObject::*)(float))&name, sig_nn, _T(#name) },

#define NODE_FUN_NNN(name) \
	{ (NODE_PFN)(float (CObject::*)(float, float))&name, sig_nnn, _T(#name) },

#define NODE_FUN_VN(name) \
	{ (NODE_PFN)(void (CObject::*)(float))&name, sig_vn, _T(#name) },

#define NODE_FUN_VNN(name) \
	{ (NODE_PFN)(void (CObject::*)(float, float))&name, sig_vnn, _T(#name) },

#define NODE_FUN_VNNN(name) \
	{ (NODE_PFN)(void (CObject::*)(float, float, float))&name, sig_vnnn, _T(#name) },

#define NODE_FUN_VNNNN(name) \
	{ (NODE_PFN)(void (CObject::*)(float, float, float, float))&name, sig_vnnnn, _T(#name) },

#define NODE_FUN_OV(name) \
	{ (NODE_PFN)(CObject* (CObject::*)(void))&name, sig_ov, _T(#name) },

#define NODE_FUN_OS(name) \
	{ (NODE_PFN)(CObject* (CObject::*)(const TCHAR*))&name, sig_os, _T(#name) },

#define NODE_FUN_OO(name) \
	{ (NODE_PFN)(CObject* (CObject::*)(CObject*))&name, sig_oo, _T(#name) },

#define NODE_FUN_VO(name) \
	{ (NODE_PFN)(void (CObject::*)(CObject*))&name, sig_vo, _T(#name) },

#define NODE_FUN_IS(name) \
	{ (NODE_PFN)(int (CObject::*)(const TCHAR*))&name, sig_is, _T(#name) },

////////////////////////////////////////////////////////////////////////////

class CNodeArray
{
public:
	CNodeArray();
	~CNodeArray();

	void AddNode(CNode* pNode);
	void RemoveNode(CNode* pNode);

	void RemoveAll();
	void ReleaseAll();

	int GetLength()
	{
		return m_nLength;
	}

	CNode* GetNode(int iNode)
	{
		if (iNode < 0 || iNode >= m_nLength)
			return NULL;

		return m_rgpNode[iNode];
	}

	void SetNode(int iNode, CNode* pNode)
	{
		if (iNode < 0 || iNode >= m_nLength)
		{
			ASSERT(FALSE);
			return;
		}

		m_rgpNode[iNode] = pNode;
	}

	void Allocate(int nAlloc);
	void SetLength(int nNodes);

	void Sort(int (__cdecl *pfnCompare)(const void*, const void*))
	{
		qsort(m_rgpNode, m_nLength, sizeof (CNode*), pfnCompare);
	}

protected:
	int m_nLength;
	int m_nAlloc;
	CNode** m_rgpNode;
};

class CObject
{
public:
	CObject();
	virtual ~CObject();

	static PRD m_rgprd [];
	static CNodeClass classCObject;
	static CObject* CreateNode();

	virtual const PRD* GetPropMap() const
	{ return &m_rgprd[0]; }
	const PRD* FindProp(const TCHAR* szName, int cchName);

	void SetProperty(const PRD* pprd, const void* pvValue, int cbValue);
	virtual bool OnSetProperty(const PRD* pprd, const void* pvValue);

	virtual void AddRef();
	virtual void Release();

	int m_nRefCount;

	int m_obj;
	CObject* m_pParent;

	int FindFunction(const TCHAR* pchFunction, int cchFunction);
	virtual FND* GetFunctionMap() const;


	virtual CNodeClass* GetNodeClass() const;
	bool IsKindOf(CNodeClass* pClass) const;

	virtual CNumObject* ToNum();
	virtual CStrObject* ToStr();

	virtual CObject* Deref();
	virtual void Assign(CObject* pObject);

	virtual CObject* Call(int nFunction, CObject** rgparam, int nParam);
	virtual CObject* Dot(CObject* pObj);

	CNameSpace* m_members;
	void AddMember(const TCHAR* pchName, int cchName, CObject* pObject);
	void SetMember(const TCHAR* pchName, int cchName, CObject* pObject);
	virtual CObject* GetMember(const TCHAR* pchName, int cchName);

	CFunction* FindMemberFunction(const TCHAR* pchName, int cchName);

#ifdef _DEBUG
	virtual void Dump() const;
#endif
};

class CNodeClass : public CObject
{
public:
	CNodeClass(const TCHAR* szClassName, int nObjectSize, CObject* (*pfnCreateNode)(), CNodeClass* pBaseClass, const PRD* rgprd);
	~CNodeClass();

	const TCHAR* m_szClassName;
	int m_nObjectSize;
	CObject* (*m_pfnCreateNode)();
	CNodeClass* m_pBaseClass;
	const PRD* m_rgprd;

	CObject* CreateNode();

	const PRD* FindProp(const TCHAR* pchPropName, int cchPropName);
	const PRD* GetPropMap() const { return m_rgprd; }

	static CNodeClass* FindByName(const TCHAR* szNodeClass, int cchNodeClass);
	static CNodeClass* c_pFirstClass;
	CNodeClass* m_pNextClass;
};

// This is an entry in CObject's m_members table...
class CFunction : public CObject
{
public:
	CFunction();
	~CFunction();

#ifdef _DEBUG
	TCHAR* m_szName;
#endif

	int m_cbop;
	BYTE m_rgop[ANYSIZE_ARRAY];

#pragma push_macro("new")
#undef new
    void * operator new(size_t sz, int cbop)
    {
        return ::operator new(sz + cbop);
    }
#pragma pop_macro("new")
};

class CClass : public CNodeClass
{
public:
	CClass();
	~CClass();

	bool Load(const TCHAR* szURL);
	bool LoadAbsURL(const TCHAR* szURL);
	bool ParseFile(const TCHAR* szFileName, const TCHAR* szFile);
	const TCHAR* ParseClassBody(const TCHAR* pch);

	CNode* CreateNode();

	TCHAR* m_szURL;

	CActiveFile m_file;

	CNodeArray m_instanceFunctions;

	CFunction* m_pConstructor;

	int m_nVarCount;

	int GetVariableCount() { return m_nVarCount; }
};


#define NODE_CLASS(className) (&className::class##className)



#define DECLARE_NODE_FUNCTIONS() \
public: \
	static FND c_rgfnd []; \
	virtual FND* GetFunctionMap() const \
	{ return c_rgfnd; };


#define DECLARE_NODE_PROPS() \
	public: \
		static PRD m_rgprd []; \
		virtual const PRD* GetPropMap() const \
		{ return &m_rgprd[0]; }

#define DECLARE_NODE(className, baseClassName) \
public: \
	static CNodeClass class##className; \
	virtual CNodeClass* GetNodeClass() const; \
	static CObject* CreateNode();

#define IMPLEMENT_NODE(friendlyName, className, baseClassName) \
	CObject* className::CreateNode() \
		{ return new className; } \
	CNodeClass className::class##className( \
			_T(##friendlyName), sizeof(class className), className::CreateNode, \
			NODE_CLASS(baseClassName), className::m_rgprd ); \
	CNodeClass* className::GetNodeClass() const \
		{ return NODE_CLASS(className); }



#define START_NODE_PROPS(className, baseClassName) \
	PRD className::m_rgprd [] = { \
		{ &baseClassName::m_rgprd[0], pt_null, _T(#className) },

#define END_NODE_PROPS() \
	{ NULL, pt_null, NULL } };

#define NODE_PROP(theType, theClass, name) \
	{ &((theClass*)0)->m_##name, theType, _T(#name) },


class CNode : public CObject
{
public:
	CNode();
	virtual ~CNode();

	DECLARE_NODE_PROPS()

	CObject* Dot(CObject* pObj);

	CStrObject* ToStr();

	static CObject* CreateNode();
	static CNodeClass classCNode;
	virtual CNodeClass* GetNodeClass() const;

	virtual void OnLoad();

	virtual void Advance(float nSeconds);
	virtual void Render();
	virtual void GetBBox(BBox* pBBox);
	virtual float GetRadius();
#ifdef _LIGHTS
	virtual void SetLight(int& nLight, D3DCOLORVALUE& ambient);
#endif
	virtual const DWORD* GetPalette();
	virtual void RenderDynamicTexture(CSurfx* pSurfx);
	virtual float GetGroundHeight(float x, float z);

	virtual LPDIRECT3DTEXTURE8 GetTextureSurface();

	CRunner* m_pBehavior;
	bool m_visible;

#ifdef _DEBUG
	virtual void Dump() const;
#endif
};

////////////////////////////////////////////////////////////////////////////

class CGroup : public CNode
{
	DECLARE_NODE(CGroup, CNode)
public:
	CGroup();
	~CGroup();

	CNodeArray m_children;

	D3DXVECTOR3 m_bboxCenter;
	D3DXVECTOR3 m_bboxSize;

	bool m_bboxSpecified;
	bool m_bboxDirty;

	void GetBBox(BBox* pBBox);
	float GetRadius();
#ifdef _LIGHTS
	void SetLight(int& nLight, D3DCOLORVALUE& ambient);
#endif
	LPDIRECT3DTEXTURE8 GetTextureSurface();

	void Render();
	void Advance(float nSeconds);
	void RenderDynamicTexture(CSurfx* pSurfx);

	DECLARE_NODE_PROPS()
};

////////////////////////////////////////////////////////////////////////////

class CInstance : public CGroup
{
public:
	CInstance(CClass* pClass);
	~CInstance();

	void Render();

	BYTE* Construct();
	CNodeClass* GetNodeClass() const;

	CObject* Dot(CObject* pObj);

	CClass* m_pClass;
	CNodeArray m_vars;
};

////////////////////////////////////////////////////////////////////////////

class CTimeDepNode : public CNode
{
	DECLARE_NODE(CTimeDepNode, CNode)
public:
	CTimeDepNode();

	bool m_loop;
	float m_startTime;
	float m_stopTime;
	bool m_isActive;

	void Advance(float nSeconds);

	virtual void OnIsActiveChanged();
	virtual void OnCycleEnded();

	float m_lastStartTime;

	DECLARE_NODE_PROPS()
};

////////////////////////////////////////////////////////////////////////////


class CProperty : public CObject
{
public:
	CProperty(CObject* pNode, const PRD* pprd);
	~CProperty();

	CObject* m_pNode;
	const PRD* m_pprd;

	CObject* Deref();
	void Assign(CObject* pObject);
};

////////////////////////////////////////////////////////////////////////////


struct TAGID;


CObject* NewNode(const TCHAR* pchNodeClass, int cchNodeClass);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ntiosvc.h ===
#pragma once
#include "xcddefs.h"

class CNtIoctlCdromService
{
private:
	HANDLE m_hDevice;

public:
	CNtIoctlCdromService();
	~CNtIoctlCdromService();

	HRESULT Open(DWORD dwDriveNumber);
	void Close();
	HRESULT Read(DWORD dwReadStart, DWORD dwReadLength, LPVOID pvBuffer, DWORD dwRetries = 0);

	inline bool IsOpen() const
	{
		return m_hDevice != INVALID_HANDLE_VALUE;
	}

	inline int GetTrackCount() const
	{
		if (!IsOpen())
			return 0;

		return m_toc.LastTrack;
	}

	bool GetTotalLength(int* pnMinutes, int* pnSeconds, int* pnFrames);
	bool GetTrackLength(int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames);

#ifdef _CD_INFO
	const TCHAR* GetTitle();
	const TCHAR* GetArtist();
	const TCHAR* GetTrackName(int nTrack);
#endif

	inline DWORD GetTrackFrame(int nTrack) const
	{
		if (!IsOpen())
			return 0;

		ASSERT(nTrack >= 0 && nTrack <= m_toc.LastTrack);
		return m_toc.TrackAddr[nTrack];
	}

	inline int GetTrackFromFrame(DWORD dwFrame) const
	{
		return m_toc.GetTrackFromFrame(dwFrame);
	}

protected:
	XCDROM_TOC m_toc;
	bool GetTableOfContents();
	HRESULT DeviceIoControl(DWORD dwControlCode, LPVOID pvInBuffer = NULL, DWORD dwInBufferSize = 0, LPVOID pvOutBuffer = NULL, DWORD dwOutBufferSize = 0, LPDWORD pdwBytesReturned = NULL);
};

extern CNtIoctlCdromService g_cdrom;
extern bool OpenCDROM();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Node.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"

#ifdef _DEBUG
int SizeOfType(PROP_TYPE type)
{
	switch (type)
	{
	default:
		return 0;

	case pt_boolean:
		return sizeof (bool);

	case pt_integer:
		return sizeof (int);

	case pt_number:
		return sizeof (float);

	case pt_string:
		return sizeof (TCHAR*);

	case pt_children:
		return sizeof (CNodeArray);

	case pt_vec3:
	case pt_color:
		return sizeof (D3DXVECTOR3);

	case pt_vec4:
	case pt_quaternion:
		return sizeof (D3DXVECTOR4);

	case pt_node:
		return sizeof (CNode*);
	}
}
#endif

CNodeClass* CNodeClass::c_pFirstClass = NULL;

CNodeClass::CNodeClass(const TCHAR* szClassName, int nObjectSize, CObject* (*pfnCreateNode)(), CNodeClass* pBaseClass, const PRD* rgprd)
{
	m_szClassName = szClassName;
	m_nObjectSize = nObjectSize;
	m_pfnCreateNode = pfnCreateNode;
	m_pBaseClass = pBaseClass;
	m_pNextClass = c_pFirstClass;
	m_rgprd = rgprd;
	c_pFirstClass = this;
}

CNodeClass::~CNodeClass()
{
	for (CNodeClass** ppClass = &c_pFirstClass; *ppClass != NULL && *ppClass != this; ppClass = &(*ppClass)->m_pNextClass)
		;

	if (*ppClass == this)
		*ppClass = m_pNextClass;
#ifdef _DEBUG
	else
		ASSERT(FALSE);
#endif
}

CObject* CNodeClass::CreateNode()
{
	return (*m_pfnCreateNode)();
}

CNodeClass* CNodeClass::FindByName(const TCHAR* pchNodeClass, int cchNodeClass)
{
	for (CNodeClass* pClass = CNodeClass::c_pFirstClass; pClass != NULL; pClass = pClass->m_pNextClass)
	{
		if (_tcsncmp(pClass->m_szClassName, pchNodeClass, cchNodeClass) == 0 && pClass->m_szClassName[cchNodeClass] == '\0')
			return pClass;
	}

	return NULL;
}

CObject* NewNode(const TCHAR* pchNodeClass, int cchNodeClass)
{
	CNodeClass* pNodeClass = CNodeClass::FindByName(pchNodeClass, cchNodeClass);
	if (pNodeClass == NULL)
	{
		return NULL;
	}

	return pNodeClass->CreateNode();
}



PRD CNode::m_rgprd [] =
{
	{ NULL, pt_null, _T("Node") },
	NODE_PROP(pt_boolean, CNode, visible)
	{ NULL, pt_null, NULL }
};

CNode::CNode()
{
	m_obj = objNode;
	m_pBehavior = NULL;
	m_visible = true;
}

CNode::~CNode()
{
	delete m_pBehavior;
}

void CNode::OnLoad()
{
	CFunction* pFunction = FindMemberFunction(_T("behavior"), 8);
	if (pFunction != NULL)
	{
		m_pBehavior = new CRunner(this);
		m_pBehavior->SetFunc(pFunction);
	}
}

CObject* CNode::CreateNode()
{
	return new CNode;
}

CNodeClass CNode::classCNode(_T("Node"), sizeof(class CNode), CNode::CreateNode, NULL, CNode::m_rgprd);

CNodeClass* CNode::GetNodeClass() const
{
	return &classCNode;
}

const PRD* CNodeClass::FindProp(const TCHAR* szName, int cchName)
{
	const PRD* rgprd = GetPropMap();

	while (rgprd != NULL)
	{
		const PRD* pNext = (const PRD*)rgprd[0].pbOffset;

		for (int i = 1; rgprd[i].szName != NULL/*rgprd[i].nType != pt_null*/; i += 1)
		{
			if (_tcsnicmp(szName, rgprd[i].szName, cchName) == 0 && rgprd[i].szName[cchName] == '\0')
				return &rgprd[i];
		}

		rgprd = pNext;
	}

	return NULL;
}

const PRD* CObject::FindProp(const TCHAR* szName, int cchName)
{
	const PRD* rgprd = GetPropMap();

	while (rgprd != NULL)
	{
		const PRD* pNext = (const PRD*)rgprd[0].pbOffset;

		for (int i = 1; rgprd[i].szName != NULL/*rgprd[i].nType != pt_null*/; i += 1)
		{
			if (_tcsnicmp(szName, rgprd[i].szName, cchName) == 0 && rgprd[i].szName[cchName] == '\0')
				return &rgprd[i];
		}

		rgprd = pNext;
	}

	return NULL;
}

bool CObject::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	return true;
}

void CObject::SetProperty(const PRD* pprd, const void* pvValue, int cbValueIn)
{
	BYTE* pbThisValue = (BYTE*)this + (int)pprd->pbOffset;

	if (pprd->nType == pt_string)
	{
		// Shortcut equal strings...

		TCHAR* szOld = *(TCHAR**)pbThisValue;
		TCHAR* szNew = *(TCHAR**)pvValue;
		if (szOld != NULL && szNew != NULL && _tcscmp(szOld, szNew) == 0)
			return;
	}

	if (!OnSetProperty(pprd, pvValue))
		return;

	switch (pprd->nType)
	{
	case pt_intarray:
		{
			CIntArray* pArray = (CIntArray*)pbThisValue;
			pArray->SetSize(cbValueIn / sizeof (int));
			CopyMemory(pArray->m_value, pvValue, cbValueIn);
		}
		break;

	case pt_numarray:
		{
			CNumArray* pArray = (CNumArray*)pbThisValue;
			pArray->SetSize(cbValueIn / sizeof (float));
			CopyMemory(pArray->m_value, pvValue, cbValueIn);
		}
		break;

	case pt_vec2array:
		{
			CVec2Array* pArray = (CVec2Array*)pbThisValue;
			pArray->SetSize(cbValueIn / (sizeof (float) * 2));
			CopyMemory(pArray->m_value, pvValue, cbValueIn);
		}
		break;

	case pt_vec3array:
		{
			CVec3Array* pArray = (CVec3Array*)pbThisValue;
			pArray->SetSize(cbValueIn / (sizeof (float) * 3));
			CopyMemory(pArray->m_value, pvValue, cbValueIn);
		}
		break;

	case pt_vec4array:
		{
			CVec4Array* pArray = (CVec4Array*)pbThisValue;
			pArray->SetSize(cbValueIn / (sizeof (float) * 4));
			CopyMemory(pArray->m_value, pvValue, cbValueIn);
		}
		break;

	case pt_string:
		{
			// NOTE: cbValueIn is really a character count!

			TCHAR* szOld = *(TCHAR**)pbThisValue;
			delete [] szOld;

			TCHAR* sz = *(TCHAR**)pvValue;
			ASSERT((int)_tcslen(sz) == cbValueIn);
			TCHAR* szNew = new TCHAR [cbValueIn + 1];
			CopyChars(szNew, sz, cbValueIn);
			szNew[cbValueIn] = 0;
			*(TCHAR**)pbThisValue = szNew;
		}
		break;

	default:
		if (pprd->nType == pt_node)
		{
			CNode* pNode = *(CNode**)pbThisValue;
			if (pNode != NULL)
				pNode->Release();
		}

		ASSERT(SizeOfType(pprd->nType) == cbValueIn);
		CopyMemory(pbThisValue, pvValue, cbValueIn);

		if (pprd->nType == pt_node)
		{
			CNode* pNode = *(CNode**)pvValue;
			if (pNode != NULL)
				pNode->AddRef();
		}
		break;
	}
}

void CNode::Render()
{
	// If we get here, the node subclass does not have a render function, 
	// so don't bother calling it anymore!
	m_visible = false;
}

void CNode::Advance(float nSeconds)
{
	if (m_pBehavior != NULL && !m_pBehavior->IsSleeping())
	{
		g_pRunner = m_pBehavior;
		g_pThis = this;

		do
		{
			if (!m_pBehavior->Step())
			{
				// The function completed, so start it over!
				m_pBehavior->ResetFunc();
			}
		}
		while (!m_pBehavior->IsSleeping());
	}
}

float CNode::GetGroundHeight(float x, float z)
{
	return 0.0f;
}

void CNode::GetBBox(BBox* pBBox)
{
	pBBox->center.x = 0.0f;
	pBBox->center.y = 0.0f;
	pBBox->center.z = 0.0f;
	pBBox->size.x = 0.0f;
	pBBox->size.y = 0.0f;
	pBBox->size.z = 0.0f;
}

float CNode::GetRadius()
{
	return 0.0f;
}

#ifdef _LIGHTS
void CNode::SetLight(int& nLight, D3DCOLORVALUE& ambient)
{
}
#endif

LPDIRECT3DTEXTURE8 CNode::GetTextureSurface()
{
	return NULL;
}

void CNode::RenderDynamicTexture(CSurfx* pSurfx)
{
}

const DWORD* CNode::GetPalette()
{
	return NULL;
}


#ifdef _DEBUG
void CNode::Dump() const
{
	CObject::Dump();

	for (const PRD* rgprd = GetPropMap(); rgprd != NULL; rgprd = (const PRD*)rgprd[0].pbOffset)
	{
		for (int i = 1; rgprd[i].szName != NULL; i += 1)
		{
			TRACE(_T("prop: '%s::%s' = "), rgprd[0].szName, rgprd[i].szName);
			const BYTE* pbThisValue = (const BYTE*)this + (int)rgprd[i].pbOffset;
			switch (rgprd[i].nType)
			{
			case pt_integer:
				TRACE(_T("%d"), *((const int*)pbThisValue));
				break;

			case pt_boolean:
				TRACE(_T("%s"), *((const bool*)pbThisValue) ? _T("true") : _T("false"));
				break;

			case pt_number:
				TRACE(_T("%f"), *((const float*)pbThisValue));
				break;

			case pt_string:
				TRACE(_T("%s"), *((const TCHAR**)pbThisValue));
				break;

			// FUTURE: Dump other types too!
			}

			TRACE(_T("\n"));
		}
	}
}
#endif

////////////////////////////////////////////////////////////////////////////


CNodeArray::CNodeArray()
{
	m_nLength = 0;
	m_nAlloc = 0;
	m_rgpNode = NULL;
}

CNodeArray::~CNodeArray()
{
	ReleaseAll();
}

void CNodeArray::AddNode(CNode* pNode)
{
	if (m_nAlloc < m_nLength + 1)
		Allocate(m_nAlloc + 16);

	m_rgpNode[m_nLength++] = pNode;
}

void CNodeArray::RemoveNode(CNode* pNode)
{
	for (int i = 0; i < m_nLength; i += 1)
	{
		if (m_rgpNode[i] == pNode)
		{
			CopyMemory(&m_rgpNode[i], &m_rgpNode[i + 1], (m_nLength - i) - 1);
			m_nLength -= 1;
			i -= 1;
		}
	}
}

void CNodeArray::ReleaseAll()
{
	for (int i = 0; i < m_nLength; i += 1)
	{
		if (m_rgpNode[i] != NULL)
			m_rgpNode[i]->Release();
	}

	RemoveAll();
}

void CNodeArray::RemoveAll()
{
	m_nLength = 0;
	m_nAlloc = 0;
	delete [] m_rgpNode;
	m_rgpNode = NULL;
}

void CNodeArray::Allocate(int nLength)
{
	if (m_nAlloc < nLength)
	{
		CNode** rgpNode = new CNode* [nLength];

		if (m_rgpNode != NULL)
		{
			CopyMemory(rgpNode, m_rgpNode, m_nAlloc * sizeof (CNode*));
			delete [] m_rgpNode;
		}

		m_rgpNode = rgpNode;
		m_nAlloc = nLength;
	}
}

void CNodeArray::SetLength(int nLength)
{
	Allocate(nLength);

	if (nLength > m_nLength)
		ZeroMemory(m_rgpNode + m_nLength, (nLength - m_nLength) * sizeof (CNode*));

	m_nLength = nLength;
}


////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("TimeDepNode", CTimeDepNode, CNode)

START_NODE_PROPS(CTimeDepNode, CNode)
	NODE_PROP(pt_boolean, CTimeDepNode, loop)
	NODE_PROP(pt_number, CTimeDepNode, startTime)
	NODE_PROP(pt_number, CTimeDepNode, stopTime)
	NODE_PROP(pt_boolean, CTimeDepNode, isActive)
END_NODE_PROPS()

CTimeDepNode::CTimeDepNode() :
	m_loop(false),
	m_startTime(0),
	m_stopTime(0),
	m_isActive(false)
{
	m_lastStartTime = 0.0f;
}

void CTimeDepNode::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_isActive)
	{
		if (m_stopTime > m_startTime && theApp.m_now >= m_stopTime)
		{
			m_isActive = false;
			OnIsActiveChanged();
		}
	}
	else
	{
		if (theApp.m_now >= m_startTime && m_startTime != m_lastStartTime && (m_stopTime == 0.0f || theApp.m_now < m_stopTime))
		{
			m_lastStartTime = m_startTime;
			m_isActive = true;
			OnIsActiveChanged();
		}
	}
}

void CTimeDepNode::OnIsActiveChanged()
{
}

void CTimeDepNode::OnCycleEnded()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Object.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"
#include "Lerper.h"

PRD CObject::m_rgprd [] =
{
	{ NULL, pt_null, _T("Object") },
	{ NULL, pt_null, NULL }
};

CObject::CObject()
{
	m_obj = objUndefined;
	m_nRefCount = 1;
	m_members = NULL;
	m_pParent = NULL;
}

CObject::~CObject()
{
	CLerper::RemoveObject(this);
	delete m_members;
}

void CObject::AddRef()
{
	m_nRefCount += 1;
}

void CObject::Release()
{
	m_nRefCount -= 1;
	if (m_nRefCount == 0)
		delete this;
}

CNodeClass CObject::classCObject(_T("Object"), sizeof(class CObject), CObject::CreateNode, NULL, NULL);

CNodeClass* CObject::GetNodeClass() const
{
	return &classCObject;
}

bool CObject::IsKindOf(CNodeClass* pClass) const
{
	for (CNodeClass* pCheckClass = GetNodeClass(); pCheckClass != NULL; pCheckClass = pCheckClass->m_pBaseClass)
	{
		if (pClass == pCheckClass)
			return true;
	}

	return false;
}

CObject* CObject::CreateNode()
{
	return new CObject;
}

CStrObject* CObject::ToStr()
{
	return new CStrObject(_T("[object]"));
}

CNumObject* CObject::ToNum()
{
	return new CNumObject(0.0f);
}

CObject* CObject::Deref()
{
	return this;
}

FND* CObject::GetFunctionMap() const
{
	return NULL;
}

int CObject::FindFunction(const TCHAR* pchFunction, int cchFunction)
{
	FND* rgfnd = GetFunctionMap();
	if (rgfnd == NULL)
		return -1;

	for (FND* pfnd = rgfnd; pfnd->pfn.pfn != NULL; pfnd += 1)
	{
		if ((int)_tcslen(pfnd->szName) == cchFunction && _tcsncmp(pfnd->szName, pchFunction, cchFunction) == 0)
			return (int)(pfnd - rgfnd);
	}

	return -1;
}

typedef CObject* (__cdecl CObject::*NODE_PFN_DEFAULT)(CObject**, int);

extern CObject* Dereference(CObject* pObject);

CObject* CObject::Call(int nFunction, CObject** rgparam, int nParam)
{
	ASSERT(nFunction >= 0);

	FND* pfnd = &GetFunctionMap()[nFunction];

	union FSIG fsig = pfnd->pfn;

	CObject* pRetObject = NULL;

	for (int i = 0; i < nParam; i += 1)
		rgparam[i] = Dereference(rgparam[i]);

	switch (pfnd->sig)
	{
	default:
		ASSERT(FALSE);
		return NULL;

	case sig_default:
		pRetObject = (this->*fsig.pfn_default)(rgparam, nParam);
		break;

	case sig_vv:
		{
			if (nParam != 0)
				goto LBadParamCount;

			(this->*fsig.pfn_vv)();
		}
		break;
		
	case sig_vi:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			(this->*fsig.pfn_vi)(i1);
			pNum1->Release();
		}
		break;
		
	case sig_vii:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			CNumObject* pNum2 = rgparam[1]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			int i2 = (int)pNum2->m_nValue;
			(this->*fsig.pfn_vii)(i1, i2);
			pNum1->Release();
			pNum2->Release();
		}
		break;
		
	case sig_vis:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			CStrObject* pStr1 = rgparam[1]->ToStr();
			int i1 = (int)pNum1->m_nValue;
			const TCHAR* sz1 = pStr1->GetSz();
			(this->*fsig.pfn_vis)(i1, sz1);
			pNum1->Release();
			pStr1->Release();
		}
		break;
		
	case sig_viis:
		{
			if (nParam != 3)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			CNumObject* pNum2 = rgparam[1]->ToNum();
			CStrObject* pStr1 = rgparam[2]->ToStr();
			int i1 = (int)pNum1->m_nValue;
			int i2 = (int)pNum2->m_nValue;
			const TCHAR* sz1 = pStr1->GetSz();
			(this->*fsig.pfn_viis)(i1, i2, sz1);
			pNum1->Release();
			pNum2->Release();
			pStr1->Release();
		}
		break;
		
	case sig_iv:
		{
			if (nParam != 0)
				goto LBadParamCount;

			pRetObject = new CNumObject((float)(this->*fsig.pfn_iv)());
		}
		break;

	case sig_sv:
		{
			if (nParam != 0)
				goto LBadParamCount;

			pRetObject = (this->*fsig.pfn_sv)();
		}
		break;

	case sig_vs:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CStrObject* pStr1 = rgparam[0]->ToStr();
			const TCHAR* sz1 = pStr1->GetSz();
			(this->*fsig.pfn_vs)(sz1);
			pStr1->Release();
		}
		break;

	case sig_vss:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CStrObject* pStr1 = rgparam[0]->ToStr();
			CStrObject* pStr2 = rgparam[1]->ToStr();
			const TCHAR* sz1 = pStr1->GetSz();
			const TCHAR* sz2 = pStr2->GetSz();
			(this->*fsig.pfn_vss)(sz1, sz2);
			pStr1->Release();
			pStr2->Release();
		}
		break;

	case sig_ii:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			pRetObject = new CNumObject((float)(this->*fsig.pfn_ii)(i1));
			pNum1->Release();
		}
		break;

	case sig_ni:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			pRetObject = new CNumObject((this->*fsig.pfn_ni)(i1));
			pNum1->Release();
		}
		break;

	case sig_iii:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			CNumObject* pNum2 = rgparam[1]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			int i2 = (int)pNum2->m_nValue;
			pRetObject = new CNumObject((float)(this->*fsig.pfn_iii)(i1, i2));
			pNum1->Release();
			pNum2->Release();
		}
		break;

	case sig_si:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			pRetObject = (this->*fsig.pfn_si)(i1);
			pNum1->Release();
		}
		break;

	case sig_sii:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			CNumObject* pNum2 = rgparam[1]->ToNum();
			int i1 = (int)pNum1->m_nValue;
			int i2 = (int)pNum2->m_nValue;
			pRetObject = (this->*fsig.pfn_sii)(i1, i2);
			pNum1->Release();
			pNum2->Release();
		}
		break;

	case sig_ss:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CStrObject* pStr1 = rgparam[0]->ToStr();
			const TCHAR* sz1 = pStr1->GetSz();
			pRetObject = (this->*fsig.pfn_ss)(sz1);
			pStr1->Release();
		}
		break;

	case sig_nv:
		{
			if (nParam != 0)
				goto LBadParamCount;

			pRetObject = new CNumObject((this->*fsig.pfn_nv)());
		}
		break;

	case sig_nn:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			float n1 = pNum1->m_nValue;
			pRetObject = new CNumObject((this->*fsig.pfn_nn)(n1));
			pNum1->Release();
		}
		break;

	case sig_nnn:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			float n1 = pNum1->m_nValue;
			CNumObject* pNum2 = rgparam[1]->ToNum();
			float n2 = pNum2->m_nValue;
			pRetObject = new CNumObject((this->*fsig.pfn_nnn)(n1, n2));
			pNum1->Release();
			pNum2->Release();
		}
		break;

	case sig_vn:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			float n1 = pNum1->m_nValue;
			(this->*fsig.pfn_vn)(n1);
			pNum1->Release();
		}
		break;
		
	case sig_vnn:
		{
			if (nParam != 2)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			float n1 = pNum1->m_nValue;
			CNumObject* pNum2 = rgparam[1]->ToNum();
			float n2 = pNum2->m_nValue;
			(this->*fsig.pfn_vnn)(n1, n2);
			pNum1->Release();
			pNum2->Release();
		}
		break;
		
	case sig_vnnn:
		{
			if (nParam != 3)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			float n1 = pNum1->m_nValue;
			CNumObject* pNum2 = rgparam[1]->ToNum();
			float n2 = pNum2->m_nValue;
			CNumObject* pNum3 = rgparam[2]->ToNum();
			float n3 = pNum3->m_nValue;
			(this->*fsig.pfn_vnnn)(n1, n2, n3);
			pNum1->Release();
			pNum2->Release();
			pNum3->Release();
		}
		break;
		
	case sig_vnnnn:
		{
			if (nParam != 4)
				goto LBadParamCount;

			CNumObject* pNum1 = rgparam[0]->ToNum();
			float n1 = pNum1->m_nValue;
			CNumObject* pNum2 = rgparam[1]->ToNum();
			float n2 = pNum2->m_nValue;
			CNumObject* pNum3 = rgparam[2]->ToNum();
			float n3 = pNum3->m_nValue;
			CNumObject* pNum4 = rgparam[3]->ToNum();
			float n4 = pNum4->m_nValue;
			(this->*fsig.pfn_vnnnn)(n1, n2, n3, n4);
			pNum1->Release();
			pNum2->Release();
			pNum3->Release();
			pNum4->Release();
		}
		break;
		
	case sig_ov:
		{
			if (nParam != 0)
				goto LBadParamCount;

			pRetObject = (this->*fsig.pfn_ov)();
		}
		break;

	case sig_os:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CStrObject* pStr1 = rgparam[0]->ToStr();
			const TCHAR* sz1 = pStr1->GetSz();
			pRetObject = (this->*fsig.pfn_os)(sz1);
			pStr1->Release();
		}
		break;

	case sig_oo:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CObject* pObj1 = rgparam[0];
			pRetObject = (this->*fsig.pfn_oo)(pObj1);
		}
		break;

	case sig_vo:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CObject* pObj1 = rgparam[0];
			(this->*fsig.pfn_vo)(pObj1);
		}
		break;

	case sig_is:
		{
			if (nParam != 1)
				goto LBadParamCount;

			CStrObject* pStr1 = rgparam[0]->ToStr();
			const TCHAR* sz1 = pStr1->GetSz();
			pRetObject = new CNumObject((float)(this->*fsig.pfn_is)(sz1));
			pStr1->Release();
		}
		break;
	}

	return pRetObject;

LBadParamCount:
	g_pRunner->Error(_T("invalid number of parameters"));
	return NULL;
}

CObject* CObject::Dot(CObject* pObj)
{
	if (pObj->m_obj == objVariable)
	{
		CVarObject* pVar = (CVarObject*)pObj;
		int nFunction = FindFunction(pVar->m_sz, pVar->m_nLength);
		if (nFunction >= 0)
		{
			CFunctionObject* pFun = new CFunctionObject;
			pFun->m_nFunction = nFunction;
			pFun->m_pObject = this;
			AddRef();

			return pFun;
		}

		CObject* pObject = GetMember(pVar->m_sz, pVar->m_nLength);
		if (pObject != NULL)
		{
			pObject->AddRef();
			return pObject;
		}
	}

	if (pObj->m_obj == objVariable)
	{
		CVarObject* pVar = (CVarObject*)pObj;
		const PRD* pprd = FindProp(pVar->m_sz, pVar->m_nLength);
		if (pprd != NULL)
		{
			return new CProperty(this, pprd);
		}
	}

	return NULL;
}

void CObject::AddMember(const TCHAR* pchName, int cchName, CObject* pObject)
{
	if (m_members == NULL)
		m_members = new CNameSpace;

	CDefine* pDefine = m_members->Add(pchName, cchName);
	pDefine->m_pNode = (CNode*)pObject;
}

void CObject::SetMember(const TCHAR* pchName, int cchName, CObject* pObject)
{
	if (m_members == NULL)
		m_members = new CNameSpace;

	CDefine* pDefine = m_members->Get(pchName, cchName);
	pDefine->m_pNode = (CNode*)pObject;
}

CObject* CObject::GetMember(const TCHAR* pchName, int cchName)
{
	if (m_members == NULL)
		return NULL;

	return m_members->Lookup(pchName, cchName);
}


extern CObject* FindMember(CNodeClass* pClass, const TCHAR* pchName, int cchName);

CFunction* CObject::FindMemberFunction(const TCHAR* pchName, int cchName)
{
	// BLOCK: Try for an instance function...
	{
		CFunction* pFunction = (CFunction*)GetMember(pchName, cchName);
		if (pFunction != NULL && pFunction->m_obj == objFunction)
			return pFunction;
	}

	// BLOCK: Try for a class member (all the way up through the base classes...
	{
		CFunction* pFunction = (CFunction*)FindMember(GetNodeClass(), pchName, cchName);
		if (pFunction != NULL && pFunction->m_obj == objFunction)
			return pFunction;
	}

	return NULL;
}


#ifdef _DEBUG

void CObject::Dump() const
{
	static const TCHAR* rgszType [] =
	{
		_T("Unknown"),
		_T("Null"),
		_T("Number"),
		_T("String"),
		_T("Variable"),
		_T("Node"),
		_T("Class"),
		_T("NodeArray"),
		_T("FunctionRef"),
		_T("Member"),
		_T("MemberVar"),
		_T("Instance"),
		_T("Use"),
		_T("Function"),
		_T("MemberFunction"),
		_T("Array"),
	};

	TRACE(_T("{\nObject: 0x%08x\n"), this);
	if (this != NULL)
	{
		TRACE(_T("Type: %s\n"), rgszType[m_obj]);
		TRACE(_T("Parent: 0x%08x\n"), m_pParent);
		TRACE(_T("RefCount: %d\n"), m_nRefCount);

		CNodeClass* pNodeClass = GetNodeClass();
		if (pNodeClass != NULL)
			TRACE(_T("Class: %s\n"), pNodeClass->m_szClassName);
		else
			TRACE(_T("Class: null\n"));

		if (m_members != NULL)
		{
			TRACE(_T("members:\n"));
			m_members->Dump();
		}
	}

	TRACE(_T("}\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Ravisent.h ===
/*
This file is derived from Ravisent's dvdcpl32.h header, which had some things that
could not be compiled in XApp.

The changes that need to be made to the original are:

	1. Get rid of new and delete operators
	2. Put parens around x in MKFLAG macro
	3. Change VDR_OpenDriver to use a char* instead of TCHAR* for name
*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDFPL32_H
#define DVDFPL32_H

#define ONLY_EXTERNAL_VISIBLE






//
// Disable warnings for "inline assembler", "lost debugging information"
// and "inline functions".
//
#pragma warning(disable : 4505)
#pragma warning(disable : 4704)
#pragma warning(disable : 4791)


//wmpx
#ifdef _XBOX
#include <xtl.h>
#include <xbox.h>
#else
#include <windows.h>
#include <winnt.h>
#endif

#define __far
#define __huge
#define __loadds

#define _fmemcpy	memcpy
#if UNICODE
#define _fstrcpy	wcscpy
#define _fstrcat	wcscat
#define _fstrlen  wcslen
#define _fstrcmp	wcscmp
#else
#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#endif
#define _fmalloc	malloc
#define _ffree		free
#define _halloc(x,y)	new BYTE[x*y]
#define _hfree(x) delete[] x

typedef int			BOOL;
typedef char	 * LPSTR;

typedef unsigned char		BYTE;
typedef unsigned short		WORD;
typedef unsigned long		DWORD;

typedef unsigned __int64	QWORD;

typedef unsigned int		UINT;
typedef signed long		LONG;


#ifndef LOBYTE
#define LOBYTE(w)	    	((BYTE)(w))
#endif

#ifndef HIBYTE
#define HIBYTE(w)     	((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif

#ifndef LOWORD
#define LOWORD(l)     	((WORD)(DWORD)(l))
#endif

#ifndef HIWORD
#define HIWORD(l)     	((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif

#ifndef MAKELONG
#define MAKELONG(low, high) ((DWORD)(WORD)(low) | ((DWORD)(WORD)(high) << 16))
#endif

#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif









//
// Some extended definitions for word/dword arithmetic
//
#ifndef MAKEWORD
#define MAKEWORD(low, high) ((WORD)(BYTE)(low) | ((WORD)(BYTE)(high) << 8))
#endif

#define MAKELONG4(low, lmid, hmid, high) ((DWORD)(BYTE)(low) | ((DWORD)(BYTE)(lmid) << 8) | ((DWORD)(BYTE)(hmid) << 16) | ((DWORD)(BYTE)(high) << 24))
#define LBYTE0(w) ((BYTE)((w) & 0xff))
#define LBYTE1(w) ((BYTE)(((DWORD)(w) >> 8) & 0xff))
#define LBYTE2(w) ((BYTE)(((DWORD)(w) >> 16) & 0xff))
#define LBYTE3(w) ((BYTE)(((DWORD)(w) >> 24) & 0xff))

inline DWORD FLIPENDIAN(DWORD x)
	{
	return MAKELONG4(LBYTE3(x), LBYTE2(x), LBYTE1(x), LBYTE0(x));
	}

//
// Some standard pointer types
//

typedef void 		 	*	APTR;			// local pointer
typedef void __far	*	FPTR;			// far pointer
typedef void __huge	*	HPTR;			//	huge pointer
typedef BYTE __huge 	*	HBPTR;		// huge byte pointer



//
// We need a memory copy for huge memory; will use the windows version
// when available.
//



#define _hmemcpy memcpy





//
// Some more stuff
//
typedef BOOL				BIT;

#define HIGH				TRUE
#define LOW					FALSE

#ifndef FP_OFF
#define FP_OFF(x)			LOWORD(x)
#define FP_SEG(x)			HIWORD(x)
#endif



//
// Flag construction macro
//
#define MKFLAG(x)		(1UL << (x))

//
// DWORD Bitfield construction and extraction functions
//
inline DWORD MKBF(int bit, int num, DWORD val) {return (((DWORD)val & ((1UL << num) -1)) << bit);}
inline DWORD MKBF(int bit, BOOL val) {return (val ? (1UL << bit) : 0);}
inline DWORD XTBF(int bit, int num, DWORD bf) {return ((bf >> bit) & ((1UL << num) -1));}
inline BOOL XTBF(int bit, DWORD bf) {return ((bf & (1UL << bit)) != 0);}
inline DWORD WRBF(DWORD bf, int bit, int num, DWORD val)
	{
	DWORD mask = ((1UL << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline DWORD WRBF(DWORD bf, int bit, BOOL val) {return (val ? (bf | (1UL << bit)) : (bf & ~(1UL << bit)));}

//
// WORD Bitfield construction and extraction functions
//
inline WORD MKBFW(int bit, int num, WORD val) {return (((WORD)val & ((1 << num) -1)) << bit);}
inline WORD MKBFW(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline WORD XTBFW(int bit, int num, WORD bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFW(int bit, WORD bf) {return ((bf & (1 << bit)) != 0);}
inline WORD WRBFW(WORD bf, int bit, int num, WORD val)
	{
	WORD mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline WORD WRBFW(WORD bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// BYTE Bitfield construction and extraction functions
//
inline BYTE MKBFB(int bit, int num, BYTE val) {return (((BYTE)val & ((1 << num) -1)) << bit);}
inline BYTE MKBFB(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline BYTE XTBFB(int bit, int num, BYTE bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFB(int bit, BYTE bf) {return ((bf & (1 << bit)) != 0);}
inline BYTE WRBFB(BYTE bf, int bit, int num, BYTE val)
	{
	BYTE mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline BYTE WRBFB(BYTE bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// Find the most significate one bit or the least significant one bit in a double word
//
inline int FindMSB(DWORD bf) {int i; for(i=31; i>=0; i--) {if (XTBF(31, bf)) return i; bf <<= 1;} return -1;}
inline int FindLSB(DWORD bf) {int i; for(i=0; i<=31; i++) {if (XTBF( 0, bf)) return i; bf >>= 1;} return 32;}



//
// Scaling of values of WORD range to values of WORD range
//
inline WORD ScaleWord(WORD op, WORD from, WORD to) {return (WORD)((DWORD)op * (DWORD) to / (DWORD) from);}
	DWORD ScaleDWord(DWORD op, DWORD from, DWORD to);
	long ScaleLong(long op, long from, long to);
	void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower);
	DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op);
//
// Most values in drivers etc. are scaled in a range from 0 to 10000, this functions transfer from and
// to this range
//
inline WORD ScaleFrom10k(WORD op, WORD to) {return ScaleWord(op, 10000, to);}
inline BYTE ScaleByteFrom10k(WORD op, BYTE to) {return (BYTE)ScaleWord(op, 10000, to);}
inline WORD ScaleTo10k(WORD op, WORD from) {return ScaleWord(op, from, 10000);}







class GenericHook;


extern "C" {
#define DLLCALL __declspec(dllexport)
DLLCALL	void	WINAPI VDR_RegisterCallback(GenericHook * hook);
DLLCALL	void	WINAPI VDR_UnregisterCallback(GenericHook * hook);
#define H20_RegisterCallback	VDR_RegisterCallback
}


#if !VIDEO_MINIPORT_DRIVER
#endif

//typedef unsigned long Error;

//
// The last error, that was raised, is not only returned, but preserved in
// this variable.
//
//extern Error LastError;

//
// Error numbers are composed of four parts, an severity level, that
// tells how hard the error hit; a unit id, describing the unit that
// failed; an error type giving some general reasons and an unique
// id (unique for the module, not all error messages).
//
//                  SS-UUUUUUUU-TTTTTTTT-IIIIIIIIIIIIII
//


#define GNR_SEVERITY_BITS	(2)
#define GNR_SEVERITY_SHIFT	(30)
#define GNR_SEVERITY_MASK	(0xC0000000)

#define GNR_UNIT_BITS		(8)
#define GNR_UNIT_SHIFT		(22)
#define GNR_UNIT_MASK		(0x3FC00000)

#define GNR_TYPE_BITS		(8)
#define GNR_TYPE_SHIFT		(14)
#define GNR_TYPE_MASK	   (0x003FC000)

#define GNR_UNIQUE_BITS		(14)
#define GNR_UNIQUE_SHIFT	(0)
#define GNR_UNIQUE_MASK		(0x00003FFF)


//
// The severity level describes how hard this error affected the operation.
//
// As the severity level is the most significant part of an error message,
// it can be tested with a simple compare (not the Error is defined as
// unsigned, so no special sign effects can occur).
//
#define GNR_OK					(0x0L << GNR_SEVERITY_SHIFT)
	// everything did well; The neat side effect of defining the OK level as
	// 0, is that the check for an error can be done with a simple not
	// 0 compare like "if (error) { ... }".

#define GNR_WARNING			(0x1L << GNR_SEVERITY_SHIFT)
	// something not quite perfect happened, but the action was performed

#define GNR_ERROR				(0x2L << GNR_SEVERITY_SHIFT)
	// an error accured, that kept the routine from doing its job

#define GNR_DEADLY			(0x3L << GNR_SEVERITY_SHIFT)
	// something happened, that will keep the program from working correct,
	// it would be better to exit gracefully

//
// The error unit specifies the module where this error was defined
//
#define GNR_UNIT_COMMON		(0x0L << GNR_UNIT_SHIFT)
	// defined in gnerrors.H

#define GNR_UNIT_GENERAL	(0x1L << GNR_UNIT_SHIFT)
	// define in ..\general\*.h

#define GNR_UNIT_MEMMPDIO	(0x2L << GNR_UNIT_SHIFT)
	// define in memmpdio.h

#define GNR_UNIT_I2C			(0x3L << GNR_UNIT_SHIFT)
	// defined in viperi2c.h

#define GNR_UNIT_INTERRUPT	(0x4L << GNR_UNIT_SHIFT)
   // defined in intrctrl.h

#define GNR_UNIT_PARSER		(0x5L << GNR_UNIT_SHIFT)
	// defined in mpgparse.h

#define GNR_UNIT_PCI					(0x6L << GNR_UNIT_SHIFT)
	// define in pci.h

#define GNR_UNIT_DMA					(0x7L << GNR_UNIT_SHIFT)
	// define in dma*.h

#define GNR_UNIT_VDECODER			(0x8L << GNR_UNIT_SHIFT)
	// defined in viddec.h

#define GNR_UNIT_VENCODER			(0x9L << GNR_UNIT_SHIFT)
	// defined in videnc.h

#define GNR_UNIT_JPEG				(0xCL << GNR_UNIT_SHIFT)
	// defined in core.h

#define GNR_UNIT_MPEG				(0xDL << GNR_UNIT_SHIFT)
	// defined in library\hardware\mpeg2dec\mp2eldec.h

#define GNR_UNIT_TVTUNER			(0xEL << GNR_UNIT_SHIFT)
	// defined in tvtuner.h

#define GNR_UNIT_VESA20				(0xFL << GNR_UNIT_SHIFT)
	// defined in vesa20.h

#define GNR_UNIT_GFC					(0x10L << GNR_UNIT_SHIFT)
	// defined in gfxconfig.h

#define GNR_UNIT_PIP					(0x11L << GNR_UNIT_SHIFT)
	// defined in *pip*.h

#define GNR_UNIT_DMAMEM				(0x12L << GNR_UNIT_SHIFT)
	//	defined in ctdmamem.h

#define GNR_UNIT_CD					(0x13L << GNR_UNIT_SHIFT)
	// defined in cdifs.h

#define GNR_UNIT_PROFILES			(0x14L << GNR_UNIT_SHIFT)
	// defined in profiles.h

#define GNR_UNIT_AUDIO				(0x15L << GNR_UNIT_SHIFT)
	// defined in audio

#define GNR_UNIT_PCICONTROLLER	(0x16L << GNR_UNIT_SHIFT)

#define GNR_UNIT_AC3					(0x17L << GNR_UNIT_SHIFT)

#define GNR_UNIT_VTX					(0x18L << GNR_UNIT_SHIFT)
	// defined in vtxdll.h

#define GNR_UNIT_MPEG2				(0x19L << GNR_UNIT_SHIFT)

#define GNR_UNIT_MP2PARSER			(0x1AL << GNR_UNIT_SHIFT)

#define GNR_UNIT_VXD					(0x1BL << GNR_UNIT_SHIFT)
	// Error messages from PnP VxD interfaces

#define GNR_UNIT_DISK				(0x1CL << GNR_UNIT_SHIFT)
	// General disk errors (library\hardware\drives\generic\diskerrors.h)

#define GNR_UNIT_NAVIGATION		(0x1DL << GNR_UNIT_SHIFT)
	// Navigation errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DVD					(0x1EL << GNR_UNIT_SHIFT)
	// DVD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_VCD					(0x1FL << GNR_UNIT_SHIFT)
	// VCD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_CDA					(0x20L << GNR_UNIT_SHIFT)
	// CDA specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DECRYPTION		(0x21L << GNR_UNIT_SHIFT)
	// Decryption errors (library\hardware\mpeg2dec\generic\mp2dcryp.h)

#define GNR_UNIT_FILE				(0x22L << GNR_UNIT_SHIFT)
	// File errors (library\files\fileerrors.h)

#define GNR_UNIT_UNITS				(0x21L << GNR_UNIT_SHIFT)
	// in virtunit.h

#define GNR_UNIT_SUBPICTURE		(0x22L << GNR_UNIT_SHIFT)

#define GNR_UNIT_FRONTPANEL             (0x23L << GNR_UNIT_SHIFT)

//
// The error type gives a general hint, what caused the malfunction
//
#define GNR_TYPE_GENERAL			(0x00L << GNR_TYPE_SHIFT)
	// no special info

#define GNR_TYPE_FILEIO				(0x01L << GNR_TYPE_SHIFT)
	// some file specific error occured

#define GNR_TYPE_HARDWARE			(0x02L << GNR_TYPE_SHIFT)
	// it was a general hardware problem

#define GNR_TYPE_PARAMS				(0x03L << GNR_TYPE_SHIFT)
	// illegal parameters were used

#define GNR_TYPE_TIMEOUT			(0x04L << GNR_TYPE_SHIFT)
	// a timeout happened

#define GNR_TYPE_BUSY				(0x05L << GNR_TYPE_SHIFT)
	// the requested unit is currently busy

#define GNR_TYPE_NOACK				(0x06L << GNR_TYPE_SHIFT)
	// the requested unit did not respond

#define GNR_TYPE_INACTIVE			(0x07L << GNR_TYPE_SHIFT)
	// the requested unit is currently not active, or in an illegal
	// state for the type of the requested operation

#define GNR_TYPE_MEMORY				(0x08L << GNR_TYPE_SHIFT)
	// there was no sufficient free store left

#define GNR_TYPE_UNIMPLEMENTED 	(0x09L << GNR_TYPE_SHIFT)
	// the called function is not yet completely implemented

#define GNR_TYPE_FORMAT				(0x0aL << GNR_TYPE_SHIFT)
	// the examined object was in the wrong format

#define GNR_TYPE_OBJECT				(0x0bL << GNR_TYPE_SHIFT)

#define GNR_TYPE_BOUNDS				(0x0cL << GNR_TYPE_SHIFT)

#define GNR_TYPE_ILLEGALACCESS	(0x0dL << GNR_TYPE_SHIFT)

#define GNR_TYPE_REGION				(0x0eL << GNR_TYPE_SHIFT)

#define GNR_TYPE_PARENTAL			(0x0fL << GNR_TYPE_SHIFT)

#define GNR_TYPE_UOP					(0x10L << GNR_TYPE_SHIFT)

#define GNR_TYPE_OPERATION			(0x11L << GNR_TYPE_SHIFT)

#define GNR_TYPE_INTERNALSTATE	(0x12L << GNR_TYPE_SHIFT)

#define GNR_TYPE_COPYPROTECTION	(0x13L << GNR_TYPE_SHIFT)

//
// Macros to build and decompose error numbers
//
#define MKERR(level, unit, type, unique) ((ULONG)(GNR_##level | GNR_UNIT_##unit | GNR_TYPE_##type | unique))
	// build an error number from its parts

#define GNR_SEVERITY(err) (err & GNR_SEVERITY_MASK)
	// extracts the severity of the error number

#define GNR_UNIT(err) (err & GNR_UNIT_MASK)
	// extracts the unit of the error number

#define GNR_TYPE(err) (err & GNR_TYPE_MASK)
	// extracts the type of the error number

#define GNR_UNIQUE(err) (err & GNR_UNIQUE_MASK)
	// extracts the unique id of the error number

#ifndef IS_ERROR
	//
	// sidenote, the original definition of IS_ERROR in <winerror.h> is
	// #define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
	// this is functional identical to our definition, so no need to redefine it
	// here.  In any case a new define is added, which is to be used in all future
	// tests.
	//
#define IS_ERROR(err) ((err) >= GNR_ERROR)
#endif
#define IS_GNERROR(err) ((err) >= GNR_ERROR)

//
// Some default error messages
//
#define GNR_FILE_NOT_FOUND			MKERR(ERROR, COMMON, FILEIO, 0x00)
	// general file not found error

#define GNR_FILE_IN_USE 			MKERR(ERROR, COMMON, FILEIO, 0x01)
	// the file is currently in use

#define GNR_FILE_WRONG_FORMAT 	MKERR(ERROR, COMMON, FILEIO, 0x02)
	// the file is in the wrong file format

#define GNR_END_OF_FILE 			MKERR(ERROR, COMMON, FILEIO, 0x03)
	// attempt to read behind the end of a file

#define GNR_NOT_ENOUGH_MEMORY 	MKERR(ERROR, COMMON, MEMORY, 0x04)
	// general not enough memory left

#define GNR_MEM_NOT_ALLOCATED 	MKERR(WARNING, COMMON, MEMORY, 0x05)
	// the memory that was requested to be freed was not allocated
	// before.

#define GNR_MEM_ALLOCATED_BEFORE MKERR(WARNING, COMMON, MEMORY, 0x06)
	// the memory was allocated before


#define GNR_UNIMPLEMENTED 			MKERR(ERROR, COMMON, UNIMPLEMENTED, 0x07)
	// the function is not yet implemented, and will never be


#define GNR_OBJECT_NOT_FOUND		MKERR(ERROR, COMMON, OBJECT, 0x08)
	// the requested object could not be found

#define GNR_OBJECT_EXISTS			MKERR(ERROR, COMMON, OBJECT, 0x09)
	// the object requested to be created does already exist

#define GNR_OBJECT_IN_USE			MKERR(ERROR, COMMON, OBJECT, 0x0a)
	// an operation that needs exclusive access to an object, found the object
	// already in use

#define GNR_OBJECT_FOUND			MKERR(ERROR, COMMON, OBJECT, 0x0b)
	// an object that was to be inserted in a data structure with unique objects
	// was already in there

#define GNR_RANGE_VIOLATION		MKERR(ERROR, COMMON, BOUNDS, 0x0c)
	// a given parameter was out of bounds


#define GNR_INVALID_CONFIGURE_STATE		MKERR(ERROR, COMMON, INACTIVE, 0x0d)
	// the unit was in an invalid state for configuration

#define GNR_OBJECT_FULL				MKERR(ERROR, COMMON, BOUNDS, 0x0e)

#define GNR_OBJECT_EMPTY			MKERR(ERROR, COMMON, BOUNDS, 0x0f)

#define GNR_OBJECT_NOT_ALLOCATED	MKERR(ERROR, COMMON, INACTIVE, 0x10)

#define GNR_OBJECT_READ_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x11)

#define GNR_OBJECT_WRITE_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x12)

#define GNR_OPERATION_PROHIBITED	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x13)

#define GNR_OBJECT_INVALID			MKERR(ERROR, COMMON, OBJECT, 0x14)

#define GNR_INSUFFICIENT_RIGHTS	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x15)

#define GNR_TIMEOUT					MKERR(ERROR, COMMON, NOACK, 0x16)

#define GNR_FILE_READ_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x17)

#define GNR_FILE_WRITE_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x18)

#define GNR_INVALID_PARAMETERS	MKERR(ERROR, COMMON, PARAMS, 0x19)

#define GNR_CONNECTION_LOST		MKERR(ERROR, COMMON, INACTIVE, 0x1a)

#define GNR_OPERATION_ABORTED		MKERR(ERROR, COMMON, TIMEOUT, 0x1b)

//
// Error invocation macros, to be used to standardize erroneous returns
//
#define GNRAISE(e) return (e)
	// raise an error, store it into the global error variable, and
	// return with the error number.

#define GNRAISE_OK return GNR_OK
	// raise the OK error, all did well

//#define GNRAISE_AGAIN return LastError
	// raise the last error again

#define GNASSERT(cond, except) if (cond) GNRAISE(except); else	0
	// if the condition evaluates to true, the exception is raised

#define GNREASSERT(cond) if (1) {ULONG e; if (e = (cond)) GNRAISE(e);} else 0
	// if the condition evaluates to not OK, the error is raised again

#define GNREASSERTMAP(cond, ne) if (1) {ULONG e; if (e = (cond)) GNRAISE(ne);} else 0
	// if the condition evaluates to not OK, the error ne is returned





// In order to be flexible, we use tags for setting and getting data and query
// module capabilities. Tag pairs consist of the tag itself and a data item.
// The tag tells which variable shall be set or retrieved. The data item is
// the value written to the variable or a pointer to the location where the
// retrieved value is to be stored.
// Tags have 32 bits and are built the following way:
//
// iccc uuuu uuuu uuuu rsss ssss ssss ssss
//
// "cc" is the tag command get, set or query. The tagging unit follows. The
// tag specifier itself is contained in the lowest 15 bits.
// Internal tags are marked with an i=1, external tags marked with an i=0.
// The difference between internal and external tagunits is, that external
// units have a type bit each, internal units only have numbers.
// Tags are type checked. Tags are constructed by the MKTAG_* macros and
// terminated by TAGDONE. The inline functions below do the type checking and
// are optimized to NOPs.  The r bit is used for reference tags.  These tags
// do not carry a value, but a reference to a more extendet structure;
//

#define TAG_VAL  0x00000000
#define TAG_GET  0x10000000
#define TAG_SET  0x20000000
#define TAG_QRY  0x30000000

#define TAG_REF  0x00008000

#define TAG_TYPE(x)	(x & 0x30000000)

#define ANYUNIT	0x4fff0000
#define MAIN_UNIT	0x00000000

#define MKTAGUNIT(unit, id)	\
	static const WORD unit##_ID	=	id;	\
	static const DWORD unit =  MKFLAG(16 + id);

#define GETTAGUNITS(tag)   XTBF(16, 12, tag)
#define USESTAGUNIT(tag, id) XTBF(16+id, tag)

#define MKITAGUNIT(unit, id)	\
	static const DWORD unit = 0x80000000L | (id << 16);

struct __far TAG {
	DWORD	id;
	DWORD	data;
	TAG (DWORD _id, DWORD _data) { data = _data; id = _id; };
	TAG() {};
#if !__EDG__ || __EDG_VERSION__<240
	~TAG() {}	// This is mainly used as a workaround for a certain C++ frontend compiler bug.
#endif
	};

inline BOOL __far & QRY_TAG(TAG __far * tag) {return *((BOOL __far *)(tag->data));}

	//
	// TAG terminator
	//
#define TAGDONE TAG(0,0)

DWORD FilterTags(TAG __far * tags, DWORD id, DWORD def);


#define MKTAG(name, unit, val, type)	\
	inline TAG SET_##name(type x) {return TAG(val | unit | TAG_SET, (DWORD)(x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET, (DWORD)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return (type)(tag->data);}	\
	inline type FVAL_##name(TAG __far * tags, type def) {return (type)(FilterTags(tags, val | unit | TAG_GET, (DWORD)def));}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET;	\
	static const DWORD CGET_##name = val | unit | TAG_GET;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY;

#define MKRTG(name, unit, val, type)	\
	inline TAG SET_##name(type __far &x) {return TAG(val | unit | TAG_SET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY | TAG_REF, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET | TAG_REF;	\
	static const DWORD CGET_##name = val | unit | TAG_GET | TAG_REF;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY | TAG_REF;


#if UNICODE

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

struct UnicodeBoardVersionInfo
	{
	TCHAR boardName[100];
	DWORD boardVersion;
	};

MKRTG(BOARD_VERSION_UNICODE, MAIN_UNIT, 2, UnicodeBoardVersionInfo)

#else

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

#endif

MKRTG(BOARD_VERSION,						MAIN_UNIT, 1,		BoardVersionInfo)
// 2 is used above!

MKRTG(BOARD_REGION_CODE,				MAIN_UNIT,	0x10,	BYTE)
MKRTG(BOARD_REGION_COUNT,				MAIN_UNIT,	0x11,	WORD)

MKRTG(BOARD_SPLIT_STREAM_SUPPORT,	MAIN_UNIT,	0x20, BOOL)

struct SoftwareVersionInfo
	{
	DWORD softwareVersion, softwareRevision;
	DWORD buildNumber;
	};

MKRTG(SOFTWARE_VERSION,		MAIN_UNIT,	0x30, SoftwareVersionInfo)

//
// Macros for easy access to TAG lists during parsing
//
// GETSET     : Simple get and set of a variable
// GETSETV    : Calls a function when the variable is changed
// GETSETVC   : Like GETSETV, but only calls on real changes
// GETSETC    : Sets a variable "changed" to TRUE when a variable is changed
// GETSETP    : Allows changing only when the virtual unit is passivated
// GETSETCF   : Ors a variable "changed" with a flag when the variable is changed
// GETONLY    : Allows only reading of a value
// GETINQUIRE : Calls an inquire function, the result is to be placed
//              in the pseudo variable "data".
//
// A typical TAG parsing routine will look like this
//
//	Error VirtualMPEGDecoder::Configure(TAG *tags)
//		{
//		PARSE_TAGS_START(tags)
//			GETSETP(MPEG_AUDIO_BITRATE,  params.audioBitRate);
//			GETSETP(MPEG_AUDIO_STREAMID, params.audioStreamID);
//			GETSETP(MPEG_VIDEO_STREAMID, params.videoStreamID);
//			GETSETP(MPEG_VIDEO_WIDTH,    params.videoWidth);
//			GETSETP(MPEG_VIDEO_HEIGHT,   params.videoHeight);
//			GETSETP(MPEG_VIDEO_FPS,      params.videoFPS);
//			GETSETP(MPEG_STREAM_TYPE,    params.streamType);
//
//			GETSET(MPEG_STREAM_HOOK, streamHook);
//
//			GETSETV(MPEG_LEFT_VOLUME,  leftVolume,  GNREASSERT(decoder->SetLeftVolume(leftVolume)));
//			GETSETV(MPEG_RIGHT_VOLUME, rightVolume, GNREASSERT(decoder->SetRightVolume(rightVolume)));
//			GETSETV(MPEG_AUDIO_MUTE,   audioMute,   GNREASSERT(decoder->MuteAudio(audioMute)));
//		PARSE_TAGS_END
//
//		GNRAISE_OK;
//		}
//




MKTAGUNIT(PIP_UNIT,            0)
MKTAGUNIT(VIDEO_ENCODER_UNIT,  1)
MKTAGUNIT(VIDEO_DECODER_UNIT,  2)
MKTAGUNIT(MPEG_DECODER_UNIT,   3)
MKTAGUNIT(TV_TUNER_UNIT,       4)
MKTAGUNIT(AUDIO_MIXER_UNIT,    5)
MKTAGUNIT(AUDIO_DECODER_UNIT,  6)
MKTAGUNIT(AUDIO_ENCODER_UNIT,  7)
MKTAGUNIT(JPEG_CODEC_UNIT,     8)
MKTAGUNIT(OSD_UNIT,				 9)
MKTAGUNIT(PANEL_UNIT,         10)
MKTAGUNIT(COMMUNICATION_UNIT, 11)
// DO NOT USE 12 or 13 due to contention with tag type
MKTAGUNIT(MPEG_ENCODER_UNIT,  14)

#define VIDEO_CHIP_UNIT			(VIDEO_ENCODER_UNIT | VIDEO_DECODER_UNIT)
#define AUDIO_STREAMDEV_UNIT	(AUDIO_ENCODER_UNIT | AUDIO_DECODER_UNIT)

#define NUM_UNITS		12




//
// A hook is a generalized callback.  The receiver of the callback
// gets two parameters, first the hook itself (this may be used for
// caller specific data), and a hook specific data element.
//
// The callback function is _NOT_ a virtual function, but a function
// pointer.  This has been done, to avoid incompatibilities with
// traditional 'C'.
//
// A typical use for a hook would be a refill request for a buffer
// in a buffer based stream:
//
// typedef struct RefillMsgStruct
//    {void __far * data, long num, long actual} RefillMsg;
//
// MKHOOK(Refill, RefillMsg);
//
// The implementor of the hook may then add some additional data,
// to customize the hook:
//
// class FileRefillHook : public RefillHook {
//		private:
//			Error Refill(void __far * data, long num, long &actual);
//			friend Error Refill(RefillHook * me, RefillMsg data);
//			FILE 	*	file;
//    public:
//       FileRefillHook(FILE * file) : RefillHook(Refill);
//		};
//
//	Error Refill(RefillHook * me, RefillMsg data)
//		{
//		return (FileRefillHook *)me->Refill(data.data, data.num, data.actual);
//		};
//
//
// Note that you have to do a MakeProcInstance if your callback function is not
// inside a DLL.
//


class KWorkerQueue;

class GenericHook
	{
	protected:
		KWorkerQueue	*	queue;
	public:
		void Register(KWorkerQueue * queue) {this->queue = queue;}
	};



extern "C" {
__declspec(dllexport) void  WINAPI VDR_RegisterCallback(GenericHook * hook);
}

#define MKHOOK(name, type) \
	class __far name##Hook : public GenericHook { \
		public: \
			typedef ULONG (WINAPI * CallType)(name##Hook __far * me, type & data); \
		private: \
			CallType	call; \
			class KWorkerQueue	*	queue;	\
		public: \
			name##Hook(CallType call) {this->call = call;VDR_RegisterCallback(this);} \
	};





enum VideoStandard
	{
	VIDEOSTANDARD_MIN,
		VSTD_NTSC  = 0,
		VSTD_PAL   = 1,
		VSTD_SECAM = 2,
		VSTD_HDTV  = 3,
	VIDEOSTANDARD_MAX = VSTD_HDTV
	};

enum PALVideoSubStandard
	{
	PALVIDEOSUBSTANDARD_MIN	= 0,
		PALVSSTD_DEFAULT		= 0,
		PALVSSTD_BDGHI			= 1,
		PALVSSTD_N				= 2,
		PALVSSTD_NC				= 3,
	PALVIDEOSUBSTANDARD_MAX	= PALVSSTD_NC
	};

enum NTSCVideoSubStandard
	{
	NTSCVIDEOSUBSTANDARD_MIN	= 0,
		NTSCVSSTD_DEFAULT			= 0,
		NTSCVSSTD_NORMAL			= 1,
		NTSCVSSTD_PALM				= 2,
		NTSCVSSTD_443				= 3,
		NTSCVSSTD_JAPAN			= 4,
		NTSCVSSTD_PAL60			= 5,
	NTSCVIDEOSUBSTANDARD_MAX	= NTSCVSSTD_PAL60
	};

enum VideoSource
	{
	VIDEOSOURCE_MIN			= 0,
		VSRC_COMPOSITE			= 0,
		VSRC_SVIDEO				= 1,
		VSRC_SERIAL_DIGITAL	= 2,
	VIDEOSOURCE_MAX	= VSRC_SVIDEO
	};

enum VideoFormat
	{
	VIDEOFORMAT_MIN = 0,
		VFMT_YUV_422 = 0,
		VFMT_YUV_411 = 1,
		VFMT_YUV_420 = 2,
		VFMT_YUV_444 = 3,
		VFMT_RGB_444 = 4,
	VIDEOFORMAT_MAX = VFMT_RGB_444
	};

enum VideoBusFormat
	{
	VIDEOBUSFORMAT_MIN = 0,
		FBFM_YC16 = 0,
		FBFM_YC8  = 1,
	VIDEOBUSFORMAT_MAX = FBFM_YC8
	};


enum VideoLineMode
	{
	VIDEOLINEMODE_MIN		= 0,
		VLM_PROGRESSIVE	= 0,
		VLM_INTERLACED		= 1,
	VIDEOLINEMODE_MAX		= VLM_INTERLACED
	};

enum VideoMode
	{
	VIDEOMODE_MIN = 0,
		VMOD_RESET    = 0,
		VMOD_PATTERN  = 1,
		VMOD_CAPTURE  = 2,
		VMOD_PLAYBACK = 3,
		VMOD_PATTERNSYNC = 4,
	VIDEOMODE_MAX = VMOD_PATTERNSYNC
//	ModeForceReprogramming   // this one internal use only
	};

enum VideoSampleMode
	{
	VIDEOSAMPLEMODE_MIN = 0,
		VSAMOD_CCIR	= 0,
		VSAMOD_SQP	= 1,
	VIDEOSAMPLEMODE_MAX = VSAMOD_SQP
	};

enum VideoField
	{
	VIDEOFIELD_MIN = 0,
		VFLD_SINGLE = 0,
		VFLD_ODD    = 1,
		VFLD_EVEN   = 2,
	VIDEOFIELD_MAX = VFLD_EVEN
	};

// The values of the following two enums are hardware-independent.

enum GrabFormat
	{
	GRABFORMAT_MIN = 0,
		VGRB_MJPEG    = 0,
		VGRB_RGB_888x = 1,
		VGRB_RGB_888  = 2,
		VGRB_RGB_565  = 3,
		VGRB_RGB_555  = 4,
		VGRB_YUV_422  = 5,
	GRABFORMAT_MAX = VGRB_YUV_422
	};

enum PIPFormat
	{
	PIPFORMAT_MIN = 0,
		PFMT_RGB_888x	= 0,
		PFMT_RGB_888	= 1,
		PFMT_RGB_565	= 2,
		PFMT_RGB_555	= 3,
		PFMT_YUV_422	= 4,
		PFMT_UVY_422	= 5,
		PFMT_PALETTE_8	= 6,
		PFMT_OTHER		= 7,
	PIPFORMAT_MAX = PFMT_OTHER
	};


struct HardVideoParams
	{
	int totalWidth,
	    totalHeight,
	    activeWidth,
	    activeHeight;   // activeHeight must be even (interlace)
	BIT hsPol,          // can be 0 or 1
	    vsPol;          // can be 0 or 1
	int hStart,
	    hEnd,           // hEnd = hStart + activeWidth - 1
	    vStart,
	    vEnd;           // vEnd = vStart + activeHeight/2 - 1
	BIT oddFirst;
	};


// These are defines for TV standard (CCIR) dependent sizes.

const HardVideoParams NTSCParams =
	{
	858, 525,
	720, 480,
	0,   0,
	123, 123+720-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALParams =
	{
	864, 625,
	720, 576,
	0,   0,
	133, 133+720-1,
	46,  46+576-1,
	FALSE
	};


// These are defines for TV standard (square pixel) dependent sizes.

const HardVideoParams NTSCSquareParams =
	{
	780, 525,
	640, 480,
	1,   1,
	75,  75+640-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALSquareParams =
	{
	944, 625,
	768, 576,
	1,   1,
	83,  83+768-1,
	34,  34+576-1,
	FALSE
	};


// Video Port specific definitions

// Possible video formats on video port (format field in VideoPortCaps struct)
#define VP_FMT_RGB_555		MKFLAG(0)
#define VP_FMT_RGB_565		MKFLAG(1)
#define VP_FMT_CCIR_422		MKFLAG(2)
#define VP_FMT_YUV_411		MKFLAG(3)
#define VP_FMT_YUV_420		MKFLAG(4)
#define VP_FMT_YONLY_400	MKFLAG(5)
#define VP_FMT_RGB_888_24	MKFLAG(6)
#define VP_FMT_RGB_888_32	MKFLAG(7)
#define VP_FMT_RGB_332		MKFLAG(8)
#define VP_FMT_ACCUPAK		MKFLAG(9)
#define VP_FMT_DYUV			MKFLAG(10)

// Protocols
#define VP_PORT_DI_8A		MKFLAG(0)
#define VP_PORT_DIV_8A		MKFLAG(1)
#define VP_PORT_DE_8A		MKFLAG(2)
#define VP_PORT_SI_8A		MKFLAG(3)
#define VP_PORT_SIV_8A		MKFLAG(4)
#define VP_PORT_SE_8A		MKFLAG(5)
#define VP_PORT_16A			MKFLAG(6)
#define VP_PORT_V_16A		MKFLAG(7)
#define VP_PORT_FIREWIRE	MKFLAG(8)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_PORT_DUMMY		MKFLAG(9)

// generate from the ones above!
//#define VP_PROT_BROOKTREE
//#define VP_PROT_PHILIPS

// Special connection features
#define VP_FEAT_INVERTPOLARITY	MKFLAG(0)
#define VP_FEAT_INTERLACED			MKFLAG(1)
#define VP_FEAT_TELETEXT			MKFLAG(2)
#define VP_FEAT_CLOSEDCAPTION		MKFLAG(3)
#define VP_FEAT_E_HREFH_VREFH		MKFLAG(4)
#define VP_FEAT_E_HREFH_VREFL		MKFLAG(5)
#define VP_FEAT_E_HREFL_VREFH		MKFLAG(6)
#define VP_FEAT_E_HREFL_VREFL		MKFLAG(7)
#define VP_FEAT_COLORCONTROL		MKFLAG(8)
#define VP_FEAT_BOB					MKFLAG(9)
#define VP_FEAT_WEAVE				MKFLAG(10)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_FEAT_DUMMY					MKFLAG(11)

struct VideoPortCaps
	{
	DWORD	videoFormat;		// Video format on port connection

	DWORD	protocol;			// Communication protocol(s)
	DWORD	connFeatures;		// Special features for the connection

	DWORD	fieldWidth;			// Maximum total transfer width of one field
	DWORD	vbiWidth;			// Maximum transfer width for VBI information
	DWORD	fieldHeight;		// Maximum total transfer height of one field

	DWORD	usPerField;			// Shortest possible time between two VREFs in microseconds
	DWORD	pixelsPerSecond;	// Number of pixels per second

	DWORD	displayOnly;		// The VGA can only display, but not capture.

	DWORD	clrControls;		// Will contain possible color controls
	};




MKTAG(PIP_VIDEOSTANDARD,	PIP_UNIT,	0x00000001, VideoStandard)
MKTAG(PIP_WINDOW,				PIP_UNIT,	0x00000002, HWND)

	//
	// Source region, relative to active display
	//
MKTAG(PIP_SOURCE_LEFT,		PIP_UNIT,	0x00000003, int)
MKTAG(PIP_SOURCE_TOP,		PIP_UNIT,	0x00000004, int)
MKTAG(PIP_SOURCE_WIDTH,		PIP_UNIT,   0x00000005, int)
MKTAG(PIP_SOURCE_HEIGHT,	PIP_UNIT,   0x00000006, int)

	//
	// Destination region, relative to current window
	//
MKTAG(PIP_DEST_LEFT,			PIP_UNIT,	0x00000007, int)
MKTAG(PIP_DEST_TOP,			PIP_UNIT,	0x00000008, int)
MKTAG(PIP_DEST_WIDTH,		PIP_UNIT,   0x00000009, int)
MKTAG(PIP_DEST_HEIGHT,		PIP_UNIT,   0x0000000A, int)

MKTAG(PIP_ADAPT_CLIENT_SIZE, PIP_UNIT, 0x0000000B, BOOL)
MKTAG(PIP_ADAPT_SOURCE_SIZE, PIP_UNIT, 0x0000000C, BOOL)
MKTAG(PIP_SCREEN_DEST,     PIP_UNIT,   0x0000000D, BOOL)
MKTAG(PIP_SAMPLEMODE,		PIP_UNIT,	0x0000000E, VideoSampleMode)
MKTAG(PIP_HOFFSET,			PIP_UNIT,	0x0000000F, int)
MKTAG(PIP_VOFFSET,			PIP_UNIT,	0x00000010, int)
MKTAG(PIP_ALWAYS_OVERLAY,	PIP_UNIT,	0x00000011, BOOL)
MKTAG(PIP_COLORKEY_COLOR,	PIP_UNIT,	0x00000012, DWORD)
MKTAG(PIP_COLORKEYED,		PIP_UNIT,	0x00000013, BOOL)

	//
	// Display region, relative to the destination rectangle
	//
MKTAG(PIP_DISPLAY_LEFT,		PIP_UNIT,	0x00000014, short)
MKTAG(PIP_DISPLAY_TOP,		PIP_UNIT,	0x00000015, short)
MKTAG(PIP_DISPLAY_WIDTH,	PIP_UNIT,	0x00000016, short)
MKTAG(PIP_DISPLAY_HEIGHT,	PIP_UNIT,	0x00000017, short)

MKTAG(PIP_COLORKEY_INDEX,	PIP_UNIT,	0x00000018, DWORD)

// Make sure to set physical, bytesPerRow and pixelFormat at the same time when enabling this:
MKTAG (PIP_OFFSCREEN_OVERRIDE,		PIP_UNIT, 0x00000019, BOOL)
MKTAG (PIP_OFFSCREEN_BASE,				PIP_UNIT, 0x0000001a, void __far *)
MKTAG (PIP_OFFSCREEN_BASE_LINEAR,	PIP_UNIT, 0x0000001b, DWORD)		// Use a 32bit flat pointer
MKTAG (PIP_OFFSCREEN_BYTES_PER_ROW,	PIP_UNIT, 0x0000001c, WORD)
MKTAG (PIP_OFFSCREEN_PIXEL_FORMAT,	PIP_UNIT, 0x0000001d, PIPFormat)

struct FieldDisplayMsg
	{
	DWORD	fieldCnt;
	};

MKHOOK(FieldDisplay, FieldDisplayMsg);

MKTAG (PIP_FIELD_DISPLAY_HOOK,		PIP_UNIT, 0x0000001e, FieldDisplayHook *)

MKTAG (PIP_IS_POSSIBLE,					PIP_UNIT, 0x0000001f, BOOL)



#define PCCF_BRIGHTNESS					0x00000001l
#define PCCF_CONTRAST					0x00000002l
#define PCCF_HUE							0x00000004l
#define PCCF_SATURATION					0x00000008l
#define PCCF_SHARPNESS					0x00000010l
#define PCCF_GAMMA						0x00000020l
#define PCCF_RED_BRIGHTNESS			0x00001000l
#define PCCF_BLUE_BRIGHTNESS			0x00002000l
#define PCCF_GREEN_BRIGHTNESS			0x00004000l



MKTAG (PIP_COLORCONTROL,				PIP_UNIT, 0x00000020, WORD)			// Get only tag to query color control support
MKTAG (PIP_BRIGHTNESS,					PIP_UNIT, 0x00000021, WORD)
MKTAG (PIP_CONTRAST,						PIP_UNIT, 0x00000022, WORD)
MKTAG (PIP_SATURATION,					PIP_UNIT, 0x00000023, WORD)
MKTAG (PIP_HUE,							PIP_UNIT, 0x00000024, WORD)
MKTAG (PIP_GAMMA,							PIP_UNIT, 0x00000025, WORD)			// Gamma correction
MKTAG (PIP_SHARPNESS,					PIP_UNIT, 0x00000026, WORD)
MKTAG (PIP_COLORENABLE,					PIP_UNIT, 0x00000027, BOOL)			// Used to toggle between B/W and color

// Use these to adjust brightness individually for R/G/B (only works with special VGAs)
MKTAG (PIP_RED_BRIGHTNESS,				PIP_UNIT, 0x00000028, WORD)
MKTAG (PIP_BLUE_BRIGHTNESS,			PIP_UNIT, 0x00000029, WORD)
MKTAG (PIP_GREEN_BRIGHTNESS,			PIP_UNIT, 0x0000002a, WORD)

// Used to crop the source rectangle when ADAPT_SOURCE_SIZE is TRUE
MKTAG (PIP_SOURCE_CROP_LEFT,			PIP_UNIT, 0x0000002b, WORD)
MKTAG (PIP_SOURCE_CROP_TOP,			PIP_UNIT, 0x0000002c, WORD)
MKTAG (PIP_SOURCE_CROP_RIGHT,			PIP_UNIT, 0x0000002d, WORD)
MKTAG (PIP_SOURCE_CROP_BOTTOM,		PIP_UNIT, 0x0000002e, WORD)



// Error definitions.
#define GNR_DMA_PIP_NOT_POSSIBLE			MKERR(ERROR, PIP, GENERAL, 0x01)		// Current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED		MKERR(ERROR, PIP, GENERAL, 0x02)		// Desired video standard (e.g. SECAM) not supported.
#define GNR_PIP_NOT_RUNNING				MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX				MKERR(ERROR, PIP, GENERAL, 0x04)		// No optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE					MKERR(ERROR, PIP, GENERAL, 0x05)		// Destination rectangle too small or too big.
#define GNR_WRONG_GRAB_SIZE				MKERR(ERROR, PIP, GENERAL, 0x06)		// Dimensions of frame to grab are too big.
#define GNR_NO_VBLANK_IRQ					MKERR(ERROR, PIP, GENERAL, 0x07)		// An expected VBlank IRQ did not occur.
#define GNR_GRAB_TIMEOUT					MKERR(ERROR, PIP, GENERAL, 0x08)		// A timeout occurred during grabbing a frame.
#define GNR_WRONG_GRAB_FORMAT				MKERR(ERROR, PIP, GENERAL, 0x09)		// An unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// Desired video sample mode not supported
#define GNR_VP_ERROR							MKERR(ERROR, PIP, GENERAL, 0x0b)		// General error with Video Port
#define GNR_VP_NO_PORT_MATCH				MKERR(ERROR, PIP, GENERAL, 0x0c)		// Video source does not match Video Port
#define GNR_VP_HARDWARE_IN_USE			MKERR(ERROR, PIP, GENERAL, 0x0d)		// Video Port Hardware in use
#define GNR_VPM_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0e)		// General error with VPM services
#define GNR_VPE_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0f)		// General error with DirectX5/VPE services
#define GNR_NOT_ENOUGH_VIDEO_MEMORY		MKERR(ERROR, PIP, MEMORY,  0x10)
#define GNR_NO_OVERLAY_HARDWARE			MKERR(ERROR, PIP, GENERAL, 0x11)
#define GNR_OVERLAY_BUSY					MKERR(ERROR, PIP, BUSY,    0x12)
#define GNR_PRIMARY_NOT_AVAILABLE		MKERR(ERROR, PIP, BUSY,		0x13)






typedef struct StreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	DWORD captureTime;
	} StreamCaptureMsg;

MKHOOK(StreamCapture, StreamCaptureMsg);



typedef struct YStreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	WORD yCaptureCounter;
	} YStreamCaptureMsg;

MKHOOK(YStreamCapture, YStreamCaptureMsg);









MKTAG (VID_VIDEOSTANDARD,				VIDEO_CHIP_UNIT, 0x0001, VideoStandard)
MKTAG (VID_MODE,							VIDEO_CHIP_UNIT, 0x0002, VideoMode    )
MKTAG (VID_EXTSYNC,						VIDEO_CHIP_UNIT, 0x0003, BOOL         )
MKTAG (VID_PAL_VIDEOSUBSTANDARD,		VIDEO_CHIP_UNIT, 0x0004, PALVideoSubStandard)
MKTAG (VID_NTSC_VIDEOSUBSTANDARD,	VIDEO_CHIP_UNIT, 0x0005, NTSCVideoSubStandard)














MKTAG (ENC_SAMPLEMODE,  VIDEO_ENCODER_UNIT, 0x0001001, VideoSampleMode)
MKTAG (ENC_HOFFSET,     VIDEO_ENCODER_UNIT, 0x0001002, int)
MKTAG (ENC_VOFFSET,     VIDEO_ENCODER_UNIT, 0x0001003, int)

// The idle screen mapping depends on the specific video encoder. First ask
// for the number of entries via GET_ENC_IDLE_NUMBER, then allocate enough
// space to hold ENC_IDLE_NUMBER times a struct VideoEncoderIdleEntry,
// then call GET_ENC_IDLE_ENTRY to get an array of these structs filled
// with ENC_IDLE_NUMBER entries.

#define VIDENC_IdleNameMaxSize  40

struct __far VideoEncoderIdleEntry
	{
	int number;   // in increasing order
	TCHAR name[VIDENC_IdleNameMaxSize];
	};

MKTAG (ENC_IDLESCREEN,  VIDEO_ENCODER_UNIT, 0x0001004, int)   // global for all units
MKTAG (ENC_IDLE_NUMBER, VIDEO_ENCODER_UNIT, 0x0001005, int)   // global for all units
MKTAG (ENC_IDLE_ENTRY,  VIDEO_ENCODER_UNIT, 0x0001006, VideoEncoderIdleEntry __far *)   // global for all units

MKTAG (ENC_COPY_PROTECTION, VIDEO_ENCODER_UNIT, 0x00001007, int)

MKTAG (ENC_CHROMA_FILTER, VIDEO_ENCODER_UNIT, 0x00001008, DWORD)

MKTAG (ENC_SVIDEO_ACTIVE, VIDEO_ENCODER_UNIT, 0x00001009, BOOL)


// Errors from the video encoder.

#define GNR_VENC_PARAMS						MKERR(ERROR, VENCODER, PARAMS,  0x01)
	// illegal parameters
#define GNR_MACROVISION_NOT_SUPPORTED	MKERR(ERROR, VENCODER, GENERAL, 0x02)

#define GNR_CC_NOT_SUPPORTED				MKERR(ERROR, VENCODER, GENERAL, 0x03)




class KernelStringBuffer;

class __far KernelString
	{
	private:
		KernelStringBuffer	*	buffer;
	public:
		KernelString(void);
		KernelString(const TCHAR __far * str);
		KernelString(const TCHAR ch);
		KernelString(const KernelString & str);
		KernelString(DWORD value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		KernelString(int value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		~KernelString();

		int Length();

		long ToInt(int base = 10);
		DWORD ToUnsigned(int base = 10);


		BOOL Get(TCHAR __far * str, int len);

		KernelString & operator = (const TCHAR __far * str);
		KernelString & operator = (const KernelString str);

		friend KernelString operator+ (const KernelString u, const KernelString v);
		KernelString & operator+= (const KernelString u);
		friend KernelString operator* (const KernelString u, const int num);
		KernelString & operator*= (const int num);

		int Compare(const KernelString str);

		friend BOOL operator==(const KernelString u, const KernelString v);
		friend BOOL operator!=(const KernelString u, const KernelString v);
		friend BOOL operator<(const KernelString u, const KernelString v);
		friend BOOL operator>(const KernelString u, const KernelString v);
		friend BOOL operator<=(const KernelString u, const KernelString v);
		friend BOOL operator>=(const KernelString u, const KernelString v);

		friend KernelString operator << (const KernelString u, int index);
		friend KernelString operator >> (const KernelString u, int index);
		KernelString & operator <<= (int index);
		KernelString & operator >>= (int index);

		KernelString Seg(int start, int num);
		KernelString Caps(void);

		int First(KernelString str);				// Find first occurrence of str
		int Next(KernelString str, int pos);	// Find next occurrence of str
		int Last(KernelString str);				// Find last occurrence of str
		int Prev(KernelString str, int pos);	// Find previous occurrence of str

		int First(TCHAR c);							// Find first occurrence of c
		int Next(TCHAR c, int pos);				// Find next occurrence of c
		int Last(TCHAR c);							// Find last occurrence of c
		int Prev(TCHAR c, int pos);				// Find prevoius occurrence of c

		// deletes spaces (and tabs) at beginning or end of string...
		KernelString Trim();

		TCHAR& operator[] (const int index);
		const TCHAR& operator[] (const int index) const;

//
// Unsafe functions
//
		operator TCHAR * (void);
	};



class __far KernelInt64
	{
	private:
		unsigned long lower;
		signed long upper;
	public:
		KernelInt64(void) {lower = 0; upper = 0;}
		KernelInt64(DWORD val) {lower = val; upper = 0;}
		KernelInt64(long val) {lower = val; upper = val < 0 ? -1 : 0;}
		KernelInt64(int val) {lower = val; upper = val < 0 ? -1 : 0;}
		KernelInt64(unsigned int val) {lower = val; upper =  0;}
      KernelInt64(const KernelInt64 & val) {lower = val.lower; upper = val.upper;}
      KernelInt64 & operator= (const KernelInt64 val) {lower = val.lower; upper = val.upper; return *this;}

		KernelInt64(unsigned long lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, signed long upper) {this->lower = lower; this->upper = upper;}

		KernelInt64(KernelString str, int base = 10);
		KernelString ToString(int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));

		long ToLong(void)
			{
			if      (upper == 0x00000000 && !(lower & 0x80000000)) return lower;
			else if (upper == 0xffffffff &&  (lower & 0x80000000)) return lower;
			else if (upper < 0) return 0x8000000;
			else return 0x7fffffff;
			}

		DWORD ToDWORD(void)
			{
			if (upper < 0) return 0;
			else if (upper > 0) return 0xffffffff;
			else return lower;
			}

		int ToInt(void)
			{
			if (*this < -32768) return -32768;
			else if (*this > 32767) return 32767;
			else return (int)lower;
			}


		DWORD Lower(void) {return lower;}
		long Upper(void) {return upper;}

		inline int operator! (void) const {return !lower && !upper;}
		inline KernelInt64 operator- (void) const;
		inline KernelInt64 operator~ (void) const {return KernelInt64(~lower, ~upper);}

		inline friend KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const KernelInt64 u, const long v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const long v);
		friend KernelInt64 operator* (const KernelInt64 u, const KernelInt64 v);
		friend KernelInt64 operator/ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator% (const KernelInt64 u, const KernelInt64 v);

		inline KernelInt64 & operator+= (const KernelInt64 u);
		inline KernelInt64 & operator-= (const KernelInt64 u);
		inline KernelInt64 & operator+= (const long u);
		inline KernelInt64 & operator-= (const long u);
		inline KernelInt64 & operator*= (const KernelInt64 u);
		inline KernelInt64 & operator/= (const KernelInt64 u);
		inline KernelInt64 & operator%= (const KernelInt64 u);

		inline KernelInt64 & operator++ (void);
		inline KernelInt64 & operator-- (void);

		inline friend KernelInt64 operator << (const KernelInt64 u, const int shl);
		inline friend KernelInt64 operator >> (const KernelInt64 u, const int shl);

		inline KernelInt64 & operator <<= (const int shl);
		inline KernelInt64 & operator >>= (const int shl);

		inline int Compare(const KernelInt64 u) const;

		friend BOOL operator==(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) >= 0;}

		friend KernelInt64 operator& (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower & v.lower, u.upper & v.upper);}
		friend KernelInt64 operator| (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower | v.lower, u.upper | v.upper);}

		KernelInt64 & operator&= (const KernelInt64 u) {lower &= u.lower; upper &= u.upper; return *this;}
		KernelInt64 & operator|= (const KernelInt64 u) {lower |= u.lower; upper |= u.upper; return *this;}
	};

inline KernelInt64 & KernelInt64::operator+= (const KernelInt64 u)
	{
	lower += u.lower;
	if (lower < u.lower)
		upper += u.upper+1;
	else
		upper += u.upper;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const KernelInt64 u)
	{
	unsigned long sum = lower - u.lower;
	if (sum > lower)
		upper -= u.upper+1;
	else
		upper -= u.upper;
	lower = sum;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator+= (const long u)
	{
	if (u < 0)
		*this -= -u;
	else
		{
		lower += u;
		if (lower < (DWORD)u)
			upper += 1;
		}
	return *this;
	}

inline KernelInt64 & KernelInt64::operator++ (void)
	{
	lower ++;
	if (!lower)
		upper ++;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-- (void)
	{
	if (!lower)
		upper --;
	lower --;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const long u)
	{
	if (u < 0)
		*this += -u;
	else
		{
		unsigned long sum = lower - u;
		if (sum > lower)
			upper -= 1;
		lower = sum;
		}
	return *this;
	}

inline KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v)
	{
	unsigned long sum = u.lower + v.lower;
	if (sum < u.lower)
		return KernelInt64(sum, u.upper + v.upper + 1);
	else
		return KernelInt64(sum, u.upper + v.upper);
	}

inline KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v)
	{
	unsigned long sum = u.lower - v.lower;
	if (sum > u.lower)
		return KernelInt64(sum, u.upper - v.upper - 1);
	else
		return KernelInt64(sum, u.upper - v.upper);
	}

inline KernelInt64 operator+ (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u - -v;
	else
		{
		unsigned long sum = u.lower + v;
		if (sum < u.lower)
			return KernelInt64(sum, u.upper + 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}

inline KernelInt64 operator- (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u + -v;
	else
		{
		unsigned long sum = u.lower - v;
		if (sum > u.lower)
			return KernelInt64(sum, u.upper - 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}


inline KernelInt64 operator+ (const long u, const KernelInt64 v)
	{
	if (u < 0)
		return v - -u;
	else
		{
		unsigned long sum = u + v.lower;
		if (sum < v.lower)
			return KernelInt64(sum, v.upper + 1);
		else
			return KernelInt64(sum, v.upper);
		}
	}

inline KernelInt64 operator- (const long u, const KernelInt64 v)
	{
	return u + -v;
	}

inline KernelInt64 KernelInt64::operator- (void) const
	{
	if (lower == 0)
		return KernelInt64(0, -upper);
	else
		return KernelInt64((DWORD)-(long)lower, ~upper);
	}

inline int KernelInt64::Compare(const KernelInt64 u) const
	{
	if (upper < u.upper) return -1;
	else if (upper > u.upper) return 1;
	else if (lower < u.lower) return -1;
	else if (lower > u.lower) return 1;
	else return 0;
	}

inline KernelInt64 operator<< (const KernelInt64 u, const int shl)
	{
	KernelInt64 v = u;
	v <<= shl;
	return v;
	}

inline KernelInt64 operator>> (const KernelInt64 u, const int shl)
	{
	KernelInt64 v = u;
	v >>= shl;
	return v;
	}

inline KernelInt64 & KernelInt64::operator*= (const KernelInt64 u)
	{
	*this = *this * u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator/= (const KernelInt64 u)
	{
	*this = *this / u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator%= (const KernelInt64 u)
	{
	*this = *this % u;
	return *this;
	}

inline KernelInt64 operator % (const KernelInt64 u, const KernelInt64 v)
	{
	return u - (u / v) * v;
	}

inline KernelInt64 & KernelInt64::operator<<= (const int shl)
	{
	int s = shl;

	while (s > 0)
		{
		upper <<= 1;
		if (lower & 0x80000000) upper |= 1;
		lower <<= 1;
		s--;
		}

	return *this;
	}

inline KernelInt64 & KernelInt64::operator>>= (const int shl)
	{
	int s = shl;

	while (s > 0)
		{
		lower >>= 1;
		if (upper & 0x00000001) lower |= 0x80000000;
		upper >>= 1;
		s--;
		}

	return *this;
	}


enum MPEGCommand {mpc_none, 	  		// 0x0
                  mpc_start,    		// 0x1
                  mpc_play,     		// 0x2
                  mpc_seek,     		// 0x3
                  mpc_stop,     		// 0x4
                  mpc_step,     		// 0x5
                  mpc_freeze,   		// 0x6
                  mpc_resync,   		// 0x7
                  mpc_resyncue, 		// 0x8
                  mpc_cue,				// 0x9
                  mpc_end,				// 0xA
                  mpc_params,			// 0xB
                  mpc_stepkey,		// 0xC
                  mpc_scan,			// 0xD
						mpc_reverse,		// 0xE
						mpc_trickplay,		// 0xF
						mpc_seekaudio,		// 0x10
						mpc_resyncaudio,	// 0x11
						mpc_test				// 0x12	Audio test tone/video test picture
						};

enum MPEGState   {mps_reset, mps_preempted, mps_initial,
                  mps_frozen, mps_playing, mps_stepping,
                  mps_seeking, mps_resyncing, mps_stopped,
                  mps_scanning, mps_trickplaying, mps_testing,
						mps_capturing};

enum MPEGElementaryStreamType
	{
	MST_VIDEO,
	MST_AUDIO,
	MST_SUBPICTURE
	};




//
// Commands and parameters:
//
//		none                  : do nothing
//    start                 : start the operation
//    play([1..1000] speed) : play at specific speed (1000 = normal)
//    seek                  : stop playback, go standby
//    stop                  : stop playback
//    step(int frames)      : step some frames
//    freeze                : freeze current frame
//    resync                : resync after seek
//    end                   : end the operation
//
// State transition diagram
//
//	INITIAL:		reset
//
//	SRCSTATE		COMMAND/EVENT		DSTSTATE		ACTION
//
//	reset			start					initial		Init MPEG Decoder, start transfering data
// 				default				reset
//
//	initial		play					playing		Start playing the MPEG Stream
//					...					frozen		Freeze after first I-Frame
//
//	frozen		play					playing		Continue playing from current location
//					seek					seeking		Complete operation, and stop playback
//       		step					stepping		Go to step mode
//					end					reset
//					stop					stopped
//					default				frozen
//
//	playing		play					leaping		Adjust playback speed if required
//											playing
//					seek					seeking		Complete operation and stop playback
//					end					reset
//					stop					stopped
//					default				playing
//
// leaping     default           playing
//
//	stepping		play					playing
//					seek					seeking
//					end					reset
//					stop					stopped
//					default				stepping
//											frozen
//
//	seeking		resync				resyncing
//					resyncue				cued
//					end					reset
//
//	resyncing	play					playing
//					...					frozen
//
//	stopped		play					initial
//					end					reset
//					default				stopped
//

struct MPEGStreamMsg {
	DWORD		size;
	};

struct MPEGSignalMsg {
	DWORD		position;
	};

struct MPEGIdleMsg {
	};

MKHOOK(MPEGStream, MPEGStreamMsg);
MKHOOK(MPEGSignal, MPEGSignalMsg);
MKHOOK(MPEGIdle,   MPEGIdleMsg);

typedef MPEGStreamHook	__far *	MPEGStreamHookPtr;
typedef MPEGSignalHook	__far *	MPEGSignalHookPtr;
typedef MPEGIdleHook		__far *	MPEGIdleHookPtr;

enum MPEGStreamType {audioOnly, videoOnly, multiplexed};

enum MPEGStreamMode {singleStream, dualStream};

MKTAG(MPEG_AUDIO_BITRATE,					MPEG_DECODER_UNIT,	0x00000001, DWORD)
MKTAG(MPEG_AUDIO_STREAMID,					MPEG_DECODER_UNIT,	0x00000002,	BYTE)
MKTAG(MPEG_VIDEO_STREAMID,					MPEG_DECODER_UNIT,	0x00000003, BYTE)
MKTAG(MPEG_VIDEO_WIDTH,						MPEG_DECODER_UNIT,	0x00000004, WORD)
MKTAG(MPEG_VIDEO_HEIGHT,   				MPEG_DECODER_UNIT,   0x00000005, WORD)
MKTAG(MPEG_VIDEO_FPS,      				MPEG_DECODER_UNIT,   0x00000006, WORD)
MKTAG(MPEG_STREAM_TYPE,						MPEG_DECODER_UNIT,	0x00000007, MPEGStreamType)
MKTAG(MPEG_STREAM_HOOK,						MPEG_DECODER_UNIT,	0x00000008, MPEGStreamHookPtr)
MKTAG(MPEG_LEFT_VOLUME,    				MPEG_DECODER_UNIT,   0x00000009, WORD)
MKTAG(MPEG_RIGHT_VOLUME,   				MPEG_DECODER_UNIT,   0x0000000A, WORD)
MKTAG(MPEG_AUDIO_MUTE,     				MPEG_DECODER_UNIT,   0x0000000B, BOOL)
MKTAG(MPEG_SIGNAL_HOOK,						MPEG_DECODER_UNIT,	0x0000000C, MPEGSignalHookPtr)
MKTAG(MPEG_SIGNAL_POSITION,				MPEG_DECODER_UNIT,	0x0000000D, DWORD)
MKTAG(MPEG_DONE_HOOK,						MPEG_DECODER_UNIT,	0x0000000E, MPEGSignalHookPtr)
MKTAG(MPEG_VIDEO_BITRATE,					MPEG_DECODER_UNIT,   0x0000000F, DWORD)
MKTAG(MPEG_STREAM_BITRATE,					MPEG_DECODER_UNIT,   0x00000010, DWORD)
MKTAG(MPEG_INTRA_QUANTIZER_MATRIX,		MPEG_DECODER_UNIT,	0x00000011, BYTE __far *)
MKTAG(MPEG_NON_INTRA_QUANTIZER_MATRIX,	MPEG_DECODER_UNIT,	0x00000012, BYTE __far *)
MKTAG(MPEG_VIDEOSTANDARD,					MPEG_DECODER_UNIT,	0x00000013,	VideoStandard)

MKTAG(MPEG_STREAM_MODE,						MPEG_DECODER_UNIT,	0x00000014, MPEGStreamMode)

MKTAG(MPEG_DISPLAY_WIDTH,					MPEG_DECODER_UNIT,	0x00000020, WORD)
MKTAG(MPEG_DISPLAY_HEIGHT,					MPEG_DECODER_UNIT,	0x00000021, WORD)

MKTAG(MPEG_VIDEO_BRIGHTNESS,				MPEG_DECODER_UNIT,	0x00000022, WORD)
MKTAG(MPEG_VIDEO_CONTRAST,					MPEG_DECODER_UNIT,	0x00000023, WORD)

MKTAG(MPEG_AUDIO_SAMPLERATE,				MPEG_DECODER_UNIT,	0x00000024, WORD)
MKTAG(MPEG_IDLE_HOOK,						MPEG_DECODER_UNIT,	0x00000025, MPEGIdleHookPtr)

MKTAG(MPEG_ASPECT_RATIO,					MPEG_DECODER_UNIT,	0x00000026, WORD)
MKTAG(MPEG_SUPPORTS_HIRES_STILL,			MPEG_DECODER_UNIT,	0x00000027, BOOL)

MKTAG(MPEG_CURRENT_STREAM_SEGMENT,		MPEG_DECODER_UNIT,	0x00000028, DWORD)
MKTAG(MPEG_FIRST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x00000029, DWORD)
MKTAG(MPEG_LAST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x0000002a, DWORD)

MKTAG(MPEG_DISPLAY_MODE,					MPEG_DECODER_UNIT,   0x00000030, VideoMode)



enum AC3BassConfig
	{
	AC3BC_NO_REDIRECTION,
	AC3BC_REDIRECT_CENTER_BASS_TO_LEFT_AND_RIGHT,
	AC3BC_REDIRECT_LEFT_RIGHT_CENTER_BASS_TO_SUBWOOFER,
	AC3BC_REDIRECT_CENTER_BASS_TO_SUBWOOFER
	};

enum AC3SpeakerConfig
	{
	AC3SC_20_SURROUND_COMPATIBLE,
	AC3SC_10,
	AC3SC_20_NORMAL,
	AC3SC_30,
	AC3SC_21,
	AC3SC_31,
	AC3SC_22,
	AC3SC_32,
	AC3SC_KARAOKE		// This may only be available for MPEG-2 audio, but it is
							// added to the AC3 settings to avoid introducing new tags
	};

enum AC3DualModeConfig
	{
	AC3DMDM_DEFAULT,	// default is stereo
	AC3DMDM_STEREO = AC3DMDM_DEFAULT,
	AC3DMDM_CHANNEL1,	// channel 1 on both L/R
	AC3DMDM_CHANNEL2, // channel 2 on both L/R
	AC3DMDM_MIX			// mix channel 1 and 2 to mono, output on both L/R
	};

enum AC3KaraokeConfig
	{
	AC3KARA_AWARE,
	AC3KARA_DEFAULT,
	AC3KARA_OFF = AC3KARA_DEFAULT,
	AC3KARA_MULTICHANNEL	= 3,
	AC3KARA_CAPABLE_NO_VOCAL,
	AC3KARA_CAPABLE_V1,
	AC3KARA_CAPABLE_V2,
	AC3KARA_CAPABLE_BOTH_VOCAL
	};

enum DolbyProLogicConfig
	{
	DPLCFG_OFF,
	DPLCFG_DEFAULT = DPLCFG_OFF,
	DPLCFG_3_0 = 3,	// LCR three stereo
	DPLCFG_2_1,			// LRS phantom (= center not used)
	DPLCFG_3_1,			// LCRS
	DPLCFG_2_2,			// LRSS phantom
	DPLCFG_3_2			// LCRSS
	};

enum DolbyProLogicMode
	{
	DPLMODE_AUTOMATIC,	// Decoding depends on input fed into the PL decoder
	DPLMODE_DEFAULT = DPLMODE_AUTOMATIC,
	DPLMODE_ON,				// force it always on
	DPLMODE_OFF				// always off
	};

enum AC3DynamicRange
	{
	AC3DYNRG_DEFAULT,
	AC3DYNRG_COMPRESSED = AC3DYNRG_DEFAULT,	// Dynamic range sclae factor taken from MPEG-2 AC3 stream
	AC3DYNRG_MAXIMUM,									// Always use full dynamic range
	AC3DYNRG_MINIMUM,
	AC3DYNRG_TV
	};

enum AC3DialogNorm
    {
	AC3DNORM_DEFAULT,
	AC3DNORM_ON = AC3DNORM_DEFAULT,
	AC3DNORM_OFF
	};

enum AC3OperationalMode
	{
	AC3OPMODE_DEFAULT,
	AC3OPMODE_LINE = AC3OPMODE_DEFAULT,
	AC3OPMODE_RF,
	AC3OPMODE_CUSTOM_0,
	AC3OPMODE_CUSTOM_1
	};

enum SPUButtonState
	{
	SBS_DISABLED,
	SBS_SELECTED,
	SBS_ACTIVATED
	};

struct MPEG2SPUCommandMsg {
	DWORD		pts;
	int		command;
	};

MKHOOK(MPEG2SPUCommand, MPEG2SPUCommandMsg);

typedef MPEG2SPUCommandHook	__far *	MPEG2SPUCommandHookPtr;

//
//  Error definitions
//

#define GNR_DISPLAY_MODE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x00)
// The display mode could not be set

#define GNR_AUDIO_TYPE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x01)
// The audio format is not supported

#define GNR_NO_SPDIF_HARDWARE								MKERR(ERROR, MPEG, HARDWARE, 0x02)
// We do not SPDIF hardware

#define GNR_FRAME_ADVANCE_BOUNDARY_REACHED			MKERR(WARNING, MPEG, BOUNDS, 0x03)

enum MPEG2PresentationMode
	{
	MPM_FULLSIZE,
	MPM_LETTERBOXED,
	MPM_PANSCAN,
	MPM_FULLSIZE16by9
	};

enum SPDIFHandling
	{
	SPDIFH_DEFAULT,			// On when playback is running, off in all other cases
	SPDIFH_ON,					// Always physically on
	SPDIFH_OFF					// Always physically off (line idle)
	};

// This can be specified for each audio type
enum SPDIFOutputMode
	{
	SPDIFOM_DEFAULT,			// AC3: compressed, LPCM: decompressed, idle: NULL output
	SPDIFOM_DECOMPRESSED,	// Force decompressed output, even for AC3
	SPDIFOM_MUTE_NULL,		// Force mute with NULL output, if SPDIF_ON
	SPDIFOM_OFF					// Physically off
	};

enum SPDIFCopyMode
	{
	SPDIFCM_DEFAULT,			// Use system's default (transfer rights from source material to output)
	SPDIFCM_NO_COPIES,		// do not allow any copies
	SPDIFCM_ONE_GENERATION,	// allow one generation of copies
	SPDIFCM_UNRESTRICTED		// no copy restrictions
	};

enum MPEG2SplitStreamType
	{
	MP2SST_DVD_ENCRYPTED,
	MP2SST_PROGRAM,
	MP2SST_PES,
	MP2SST_ELEMENTARY
	};

enum MPEG2PESType
	{
	MP2PES_ELEMENTARY,
	MP2PES_DVD,
	MP2PES_MPEG
	};

enum MPEG2AudioType
	{
	MP2AUDTYP_DEFAULT,		// means: use MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM tags to determine audio type
	MP2AUDTYP_MPEG,			// MPEG(-1) all layers
	MP2AUDTYP_MPEG2,
	MP2AUDTYP_AC3,
	MP2AUDTYP_LPCM,			// includes CDDA (set # of bits and sample rate accordingly)
	MP2AUDTYP_DTS,
	MP2AUDTYP_SDDS,
	MP2AUDTYP_DTS_CDDA,		// CDDA with DTS information

	MP2AUDTYP_NUMBER_OF_TYPES
	};

enum MPEG2AudioSpatializer
	{
	MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_NONE = MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_SRS_TS_3D			// SRS True Surround or 3D sound, depending on source material
	};

enum PCMOutputConfig
	{
	PCMOCFG_ALL,
	PCMOCFG_LSW,
	PCMOCFG_LLR,
	PCMOCFG_SLP,
	PCMOCFG_SUM,	// subwoofer = sum of all input channels
	PCMOCFG_BYP,	// Bypass
	PCMOCFG_DEFAULT = PCMOCFG_BYP		// Bypass is default
	};

// Downsample mode for 96kHz LPCM
enum PCM96DownsampleMode
	{
	PCM96DWNS_DEFAULT,
	PCM96DWNS_DOWN_48KHZ = PCM96DWNS_DEFAULT,	// sample down to 48kHz by default
	PCM96DWNS_NONE										// no downsampling, play back using 96kHz
	};

struct AudioTypeConfig
	{
	union
		{
		struct
			{
			SPDIFOutputMode	spdifOutMode : 3;
			// ...can be expanded up to size of a DWORD...
			} config;

		DWORD	dummy;
		};

	friend BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b);
	friend BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b);

	operator DWORD (void) {return dummy;}

	AudioTypeConfig(DWORD arg) {dummy = arg;}
	AudioTypeConfig(void) {dummy = 0;}
	AudioTypeConfig(SPDIFOutputMode initMode)
		{
		config.spdifOutMode = initMode;
		// ...
		}
	};

static inline BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy == b.dummy);
	}

static inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy != b.dummy);
	}

struct MPEGDataSizePair
	{
	HBPTR		data;
	DWORD		size;
	int		timeStamp;
	DWORD		pad0;
	};


enum ForcedAspectRatio
	{
	FORCED_AR_DEFAULT	= 0,
	// 1 left out. Do not change the following two assignments:
	FORCED_AR_4_BY_3	= 2,
	FORCED_AR_16_BY_9	= 3
	};

enum FrameRateValue
	{
	FRV_23976 = 1,
	FRV_24000 = 2,
	FRV_25000 = 3,
	FRV_29970 = 4,
	FRV_30000 = 5,
	FRV_50000 = 6,
	FRV_59940 = 7,
	FRV_60000 = 8
	};



#define MP2SR_SCALE_BITS		0x80000L
#define MP2SR_SCALE_BYTES		0x10000L
#define MP2SR_SCALE_WORDS		0x08000L
#define MP2SR_SCALE_DWORDS		0x04000L
#define MP2SR_SCALE_DVDPES		0x00020L

MKTAG(MPEG2_AUDIO_AC3,						MPEG_DECODER_UNIT,	0x1001, BOOL)
MKTAG(MPEG2_AUDIO_AC3_STREAMID,			MPEG_DECODER_UNIT,	0x1002, BYTE)
MKTAG(MPEG2_CODING_STANDARD,	  		   MPEG_DECODER_UNIT,	0x1003, BOOL)

MKTAG(MPEG2_AC3_BASS_CONFIG,				MPEG_DECODER_UNIT,	0x1004, AC3BassConfig)
MKTAG(MPEG2_AC3_SPEAKER_CONFIG,			MPEG_DECODER_UNIT,	0x1005, AC3SpeakerConfig)
MKTAG(MPEG2_AC3_CENTER_DELAY,				MPEG_DECODER_UNIT,	0x1006, WORD)
MKTAG(MPEG2_AC3_SURROUND_DELAY,			MPEG_DECODER_UNIT,	0x1007, WORD)

MKTAG(MPEG2_AC3_CENTER_VOLUME,			MPEG_DECODER_UNIT,	0x1008, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_VOLUME,  MPEG_DECODER_UNIT,	0x1009, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_VOLUME,	MPEG_DECODER_UNIT,	0x100a, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_VOLUME,		MPEG_DECODER_UNIT,	0x100b, WORD)

MKTAG(MPEG2_AC3_DUAL_MODE_CONFIG,		MPEG_DECODER_UNIT,	0x100c, AC3DualModeConfig)
MKTAG(MPEG2_AC3_KARAOKE_CONFIG,			MPEG_DECODER_UNIT,	0x100d, AC3KaraokeConfig)

MKTAG(MPEG2_SPU_STREAMID,					MPEG_DECODER_UNIT,	0x1010, BYTE)
MKTAG(MPEG2_SPU_ENABLE,						MPEG_DECODER_UNIT,	0x1011, BOOL)

MKTAG(MPEG2_SPU_BUTTON_STATE,				MPEG_DECODER_UNIT,	0x1012, SPUButtonState)
MKTAG(MPEG2_SPU_BUTTON_LEFT,				MPEG_DECODER_UNIT,	0x1013, WORD)
MKTAG(MPEG2_SPU_BUTTON_TOP,				MPEG_DECODER_UNIT,	0x1014, WORD)
MKTAG(MPEG2_SPU_BUTTON_WIDTH,				MPEG_DECODER_UNIT,	0x1015, WORD)
MKTAG(MPEG2_SPU_BUTTON_HEIGHT,			MPEG_DECODER_UNIT,	0x1016, WORD)
MKTAG(MPEG2_SPU_BUTTON_SELECT_COLOR,	MPEG_DECODER_UNIT,	0x1017, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ACTIVE_COLOR,	MPEG_DECODER_UNIT,	0x1018, DWORD)
MKTAG(MPEG2_SPU_PALETTE_ENTRY,			MPEG_DECODER_UNIT,	0x1019, DWORD)
	// Palette Bits 0..7 Pen, 8..15 V, 16..23 U, 24..31 Y
MKTAG(MPEG2_SPU_COMMAND_HOOK,				MPEG_DECODER_UNIT,	0x101a, MPEG2SPUCommandHookPtr)
MKTAG(MPEG2_SPU_BUTTON_ID,					MPEG_DECODER_UNIT,	0x101b, WORD)
MKTAG(MPEG2_SPU_BUTTON_STARTTIME,		MPEG_DECODER_UNIT,	0x101c, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ENDTIME,			MPEG_DECODER_UNIT,	0x101d, DWORD)

MKTAG(MPEG2_AUDIO_LPCM,						MPEG_DECODER_UNIT,	0x1021, BOOL)
MKTAG(MPEG2_AUDIO_LPCM_STREAMID,			MPEG_DECODER_UNIT,	0x1022, BYTE)
MKTAG(MPEG2_LPCM_BITSPERSAMPLE,			MPEG_DECODER_UNIT,	0x1023, WORD)
MKTAG(MPEG2_LPCM_CHANNELS,					MPEG_DECODER_UNIT,	0x1024, WORD)

MKTAG(MPEG2_AUDIO_DTS_STREAMID,			MPEG_DECODER_UNIT,	0x1028, BYTE)

MKTAG(MPEG2_PRESENTATION_MODE,			MPEG_DECODER_UNIT,	0x1030, MPEG2PresentationMode)

MKTAG(MPEG2_DVD_STREAM_DEMUX,				MPEG_DECODER_UNIT,	0x1031, BOOL)
MKTAG(MPEG2_DVD_STREAM_ENCRYPTED,		MPEG_DECODER_UNIT,	0x1032, BOOL)


// Use this for overriding the default handling of switching ON/OFF SPDIF output
// (on decoders that can control SPDIF out)
MKTAG(MPEG2_SPDIF_HANDLING,				MPEG_DECODER_UNIT,	0x1034, SPDIFHandling)
MKTAG(MPEG2_SPDIF_OUTPUT_MODE,			MPEG_DECODER_UNIT,	0x1035, SPDIFOutputMode)
MKTAG(MPEG2_SPDIF_COPY_MODE,				MPEG_DECODER_UNIT,	0x1036, SPDIFCopyMode)

// This supercedes tags MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM, if available
MKTAG(MPEG2_AUDIO_TYPE,						MPEG_DECODER_UNIT,	0x103a, MPEG2AudioType)

// Specifies audio spatializing algorithm (e.g. SRS True Surround)
MKTAG(MPEG2_AUDIO_SPATIALIZER,			MPEG_DECODER_UNIT,	0x103b, MPEG2AudioSpatializer)


MKTAG(MPEG2_POSITION_SCALE,				MPEG_DECODER_UNIT,	0x1040, DWORD)

// Tags for downscaling the MPEG image and positioning it at an offset.
MKTAG(MPEG2_DOWNSCALE_FACTOR,				MPEG_DECODER_UNIT,	0x1050, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET,			MPEG_DECODER_UNIT,	0x1051, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET,			MPEG_DECODER_UNIT,	0x1052, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1053, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1054, int)


MKTAG(MPEG2_AC3_EQUALIZER_FRONT_ENABLE,MPEG_DECODER_UNIT,	0x1100, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_BACK_ENABLE,	MPEG_DECODER_UNIT,	0x1101, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_FRONT,			MPEG_DECODER_UNIT,	0x1104, DWORD)
MKTAG(MPEG2_AC3_EQUALIZER_BACK,			MPEG_DECODER_UNIT,	0x1105, DWORD)
MKTAG(MPEG2_STILL_FRAME_SEQUENCE,		MPEG_DECODER_UNIT,	0x1106, BOOL)
MKTAG(MPEG2_CURRENT_PLAYBACK_TIME,		MPEG_DECODER_UNIT,	0x1107, LONG)
MKTAG(MPEG2_AC3_VIRTUAL_3D_AUDIO,		MPEG_DECODER_UNIT,	0x1108, BOOL)

// Tags for split stream playback configuration
MKTAG(MPEG2_VIDEO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1109, MPEG2SplitStreamType)
MKTAG(MPEG2_AUDIO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1110, MPEG2SplitStreamType)
MKTAG(MPEG2_SPU_SPLIT_STREAM_TYPE,		MPEG_DECODER_UNIT,	0x1111, MPEG2SplitStreamType)

MKTAG(MPEG2_FORCED_SOURCE_ASPECT_RATIO, MPEG_DECODER_UNIT,	0x1120, ForcedAspectRatio)
// Switch to WDM playback (meaning: no navpacks in DVD data streams)
MKTAG(MPEG2_WDM_PLAYBACK,					MPEG_DECODER_UNIT,	0x1122, BOOL)
// Returns current value of the decoder's STC
MKTAG(MPEG2_CURRENT_STC,					MPEG_DECODER_UNIT,	0x1123, LONG)

MKTAG(MPEG2_REQUESTED_PLAYBACK_TIME,   MPEG_DECODER_UNIT,   0x1130, LONG)

// Closed Caption output on/off
MKTAG(MPEG2_CC_ENABLE,						MPEG_DECODER_UNIT,	0x1140, BOOL)

// Additional delay tags
MKTAG(MPEG2_AC3_LEFT_DELAY,				MPEG_DECODER_UNIT,	0x1200, WORD)
MKTAG(MPEG2_AC3_RIGHT_DELAY,				MPEG_DECODER_UNIT,	0x1201, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1202, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1203, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_DELAY,			MPEG_DECODER_UNIT,	0x1204, WORD)

// Dolby Pro Logic Decoder config and mode
MKTAG(MPEG2_PRO_LOGIC_CONFIG,				MPEG_DECODER_UNIT,	0x1210, DolbyProLogicConfig)
MKTAG(MPEG2_PRO_LOGIC_MODE,				MPEG_DECODER_UNIT,	0x1211, DolbyProLogicMode)

// Low Frequency Enable (LFE). Applicable for AC3 and DTS stream playback
MKTAG(MPEG2_DECODE_LFE,						MPEG_DECODER_UNIT,	0x1220, BOOL)

// PCM output configuration
MKTAG(MPEG2_PCM_OUTPUT_CONFIG,			MPEG_DECODER_UNIT,	0x1230, PCMOutputConfig)

// Dynamic range
MKTAG(MPEG2_AC3_DYNAMIC_RANGE,			MPEG_DECODER_UNIT,	0x1236, AC3DynamicRange)
MKTAG(MPEG2_AC3_HIGH_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1237, WORD)
MKTAG(MPEG2_AC3_LOW_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1238, WORD)

MKTAG(MPEG2_AC3_DIALOG_NORM,			MPEG_DECODER_UNIT,	0x1239, AC3DialogNorm)
MKTAG(MPEG2_AC3_OPERATIONAL_MODE,		MPEG_DECODER_UNIT,	0x123a, AC3OperationalMode)

// Audio type specific configurations
MKTAG(MPEG2_AC3_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1240, AudioTypeConfig)
MKTAG(MPEG2_LPCM_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1241, AudioTypeConfig)
MKTAG(MPEG2_DTS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1242, AudioTypeConfig)
MKTAG(MPEG2_MPEG_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1243, AudioTypeConfig)
MKTAG(MPEG2_MPEG2_AUDIO_TYPE_CONFIG,	MPEG_DECODER_UNIT,	0x1244, AudioTypeConfig)
MKTAG(MPEG2_SDDS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1245, AudioTypeConfig)
MKTAG(MPEG2_CDDA_DTS_AUDIO_TYPE_CONFIG,MPEG_DECODER_UNIT,	0x1246, AudioTypeConfig)

MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_DAC,		MPEG_DECODER_UNIT,	0x1300, PCM96DownsampleMode)
MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_SPDIF,	MPEG_DECODER_UNIT,	0x1301, PCM96DownsampleMode)

MKTAG(MPEG2_VIDEO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1330, WORD)
MKTAG(MPEG2_VIDEO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1331, WORD)

MKTAG(MPEG2_AUDIO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1334, WORD)
MKTAG(MPEG2_AUDIO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1335, WORD)

MKTAG(MPEG2_VIDEO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1340, WORD)
MKTAG(MPEG2_VIDEO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1341, WORD)

MKTAG(MPEG2_AUDIO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1344, WORD)
MKTAG(MPEG2_AUDIO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1345, WORD)





#define GNR_CSS_NOT_SUPPORTED			MKERR(ERROR, DECRYPTION, OPERATION, 0x00)
#define GNR_AUTHENTICATION_FAILED	MKERR(ERROR, DECRYPTION, OPERATION, 0x00)

enum MPEG2DVDAuthenticationCommand
	{
	M2D_CHECK_DISK_KEY,				// 0
	M2D_CHECK_TITLE_KEY,          // 1
	M2D_START_AUTHENTICATION,     // 2
	M2D_READ_CHALLENGE_KEY,       // 3
	M2D_WRITE_BUS_KEY,            // 4
	M2D_WRITE_CHALLENGE_KEY,      // 5
	M2D_READ_BUS_KEY,             // 6
	M2D_WRITE_DISK_KEY,           // 7
	M2D_WRITE_TITLE_KEY,          // 8
	M2D_COMPLETE_AUTHENTICATION,  // 9
	M2D_CANCEL_AUTHENTICATION     // 10
	};





#if BOARD_HAS_MPEG2_ENCODER


void __cdecl MDebugPrint(const TCHAR * szFormat, ...);
#define RDP MDebugPrint

	#ifdef _PROPTEST
		extern ULONG Print(const TCHAR __far * szFormat, ...);
		#define DP Print
#else
		inline void __cdecl DebugPrintEmpty(const TCHAR __far * szFormat, ...) {};		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
	#endif


#define BREAKPOINT



#define GNR_CAN_NOT_PASSIVATE_IDLE_UNIT			MKERR(ERROR,	UNITS,	OBJECT,	0x01)

#define GNR_OBJECT_NOT_CURRENT						MKERR(ERROR,	UNITS,	OBJECT,	0x02)

#define GNR_OBJECT_ALREADY_JOINED					MKERR(ERROR,	UNITS,	OBJECT,	0x03)

#define GNR_UNITS_BUSY									MKERR(ERROR,	UNITS,	BUSY,		0x04)

#define GNR_INVALID_UNITS								MKERR(ERROR,	UNITS,	PARAMS,	0x05)




struct MPEGTransferDoneMsg {
	};

struct MPEGEncoderBufferStarvingMsg {
	};


MKHOOK(MPEGTransferDone, MPEGTransferDoneMsg)
MKHOOK(MPEGEncoderBufferStarving, MPEGEncoderBufferStarvingMsg)


typedef MPEGTransferDoneHook	__far *	MPEGTransferDoneHookPtr;
typedef MPEGEncoderBufferStarvingHook __far *  MPEGEncoderBufferStarvingHookPtr;


enum MPEGEncoderStreamType
	{
	MST_UNKNOWN					= 0x00,
	MST_AUDIO_ELEMENTARY		= 0x01,
	MST_VIDEO_ELEMENTARY		= 0x02,
	MST_PROGRAM					= 0x03,
	MST_TRANSPORT				= 0x04,
	MST_PACKET_ELEMENTARY	= 0x05,
	MST_PACKET_VIDEO_ES		= 0x06,
	MST_PACKET_AUDIO_ES		= 0x07,
	MST_MPEG1					= 0x08
	};


MKTAG(MPEG_TRANSFER_DONE_HOOK,		MPEG_ENCODER_UNIT,	0x0001, MPEGTransferDoneHookPtr)
MKTAG(MPEG_ENCODER_BUFFER_STARVING, MPEG_ENCODER_UNIT,   0x0002, MPEGEncoderBufferStarvingHookPtr)
MKTAG(MPEG_ENC_OUTPUT_TYPE,			MPEG_ENCODER_UNIT,   0x0003, MPEGEncoderStreamType)
MKTAG(MPEG_ENC_VIDEO_SOURCE,			MPEG_ENCODER_UNIT,	0x0004, VideoSource)
MKTAG(MPEG_ENC_VIDEOSTANDARD,			MPEG_ENCODER_UNIT,	0x0005, VideoStandard)
//MKTAG(MPEG_ENC_VIDEO_WIDTH,	MPEG_ENCODER_UNIT,	0x0002, WORD)
//MKTAG(MPEG_ENC_VIDEO_HEIGHT,  MPEG_ENCODER_UNIT,   0x0003, WORD)

//
// Previous definition conflicted with decoder definition.
// Should move shared defines to hardware\mpgcodec\generic\mpgcodec.h"
//
//#include "library\hardware\mpegdec\generic\mpegdec.h"








#endif



typedef class __far UnitSetClass __far *UnitSet;
typedef class __far VDRHandleClass __far *VDRHandle;

extern "C" {
#ifdef XSTATIC_LINK
void VDR_ServiceProcess(void);

ULONG WINAPI VDR_OpenDriver(char * name, DWORD boardID, VDRHandle __far & handle);
ULONG WINAPI VDR_CloseDriver(VDRHandle handle);

DWORD WINAPI VDR_AvailUnits(VDRHandle handle);

ULONG WINAPI VDR_ReconfigureDriver(VDRHandle handle);

ULONG WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet &units);
ULONG WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet &units);
ULONG WINAPI VDR_CloseUnits(UnitSet units);


ULONG WINAPI VDR_ConfigureUnits(UnitSet units, TAG * tags);
inline ULONG __cdecl VDR_ConfigureUnitsTags(UnitSet units, TAG tags, ...) {return VDR_ConfigureUnits(units, &tags);}

ULONG WINAPI VDR_LockUnits(UnitSet units);
ULONG WINAPI VDR_UnlockUnits(UnitSet units);
ULONG WINAPI VDR_ActivateUnits(UnitSet units);
ULONG WINAPI VDR_PassivateUnits(UnitSet units);


ULONG WINAPI VDR_EnablePIP(UnitSet units, BOOL enable);
ULONG WINAPI VDR_UpdatePIP(UnitSet units);
ULONG WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                           WORD width, WORD height,
                           WORD stride,
                           GrabFormat fmt);

ULONG WINAPI VDR_OptimizeBuffer(UnitSet units, WORD __far & minPixVal);


//
// MPEG Functions
//
DWORD	WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size);
void	WINAPI VDR_CompleteMPEGData(UnitSet units);
DWORD	WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size);

DWORD	WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, LONG timeStamp);
void	WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);
DWORD  WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size, int timeStamp);
void	WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

ULONG	WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag);
ULONG	WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param);
ULONG	WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag);
BOOL	WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag);

DWORD	WINAPI VDR_CurrentMPEGLocation(UnitSet units);
DWORD	WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units);
MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units);

ULONG	WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg);

ULONG	WINAPI VDR_RemoveMPEGWinHooks(UnitSet units);
ULONG	WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units);

BOOL WINAPI CinMstStaticInit(HINSTANCE hDLLInst,
	                 DWORD  fdwReason,
		              LPVOID lpvReserved);

#if BOARD_HAS_MPEG2_ENCODER

ULONG  WINAPI VDR_DoCommand(UnitSet units, MPEGCommand com, long param);
ULONG	 WINAPI VDR_PutBuffer(UnitSet units, HPTR data, DWORD size);
ULONG  WINAPI VDR_InstallMPEGTransferDoneHook(UnitSet units, HWND hwnd, WORD transferDoneMsg);
ULONG  WINAPI VDR_RemoveMPEGTransferDoneHook(UnitSet units);
ULONG  WINAPI VDR_InstallMPEGEncoderBufferStarvingHook(UnitSet units, HWND hwnd, WORD bufferStarvingMsg);
ULONG  WINAPI VDR_RemoveMPEGEncoderBufferStarvingHook(UnitSet units);

#endif //BOARD_HAS_MPEG2_ENCODER

#else

DLLCALL void VDR_ServiceProcess(void);

DLLCALL ULONG WINAPI VDR_OpenDriver(char * name, DWORD boardID, VDRHandle __far & handle);
DLLCALL ULONG WINAPI VDR_CloseDriver(VDRHandle handle);

DLLCALL DWORD WINAPI VDR_AvailUnits(VDRHandle handle);

DLLCALL ULONG WINAPI VDR_ReconfigureDriver(VDRHandle handle);

DLLCALL ULONG WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet &units);
DLLCALL ULONG WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet &units);
DLLCALL ULONG WINAPI VDR_CloseUnits(UnitSet units);


DLLCALL ULONG WINAPI VDR_ConfigureUnits(UnitSet units, TAG * tags);
inline ULONG __cdecl VDR_ConfigureUnitsTags(UnitSet units, TAG tags, ...) {return VDR_ConfigureUnits(units, &tags);}

DLLCALL ULONG WINAPI VDR_LockUnits(UnitSet units);
DLLCALL ULONG WINAPI VDR_UnlockUnits(UnitSet units);
DLLCALL ULONG WINAPI VDR_ActivateUnits(UnitSet units);
DLLCALL ULONG WINAPI VDR_PassivateUnits(UnitSet units);


DLLCALL ULONG WINAPI VDR_EnablePIP(UnitSet units, BOOL enable);
DLLCALL ULONG WINAPI VDR_UpdatePIP(UnitSet units);
DLLCALL ULONG WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                                   WORD width, WORD height,
                                   WORD stride,
                                   GrabFormat fmt);

DLLCALL ULONG WINAPI VDR_OptimizeBuffer(UnitSet units, WORD __far & minPixVal);


//
// MPEG Functions
//
DLLCALL DWORD	WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size);
DLLCALL void	WINAPI VDR_CompleteMPEGData(UnitSet units);
DLLCALL DWORD	WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size);

DLLCALL DWORD	WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, LONG timeStamp);
DLLCALL void	WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);
DLLCALL DWORD  WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size, int timeStamp);
DLLCALL void	WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

DLLCALL ULONG	WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag);
DLLCALL ULONG	WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL ULONG	WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag);
DLLCALL BOOL	WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag);

DLLCALL DWORD	WINAPI VDR_CurrentMPEGLocation(UnitSet units);
DLLCALL DWORD	WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units);
DLLCALL MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units);

DLLCALL ULONG	WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg);

DLLCALL ULONG	WINAPI VDR_RemoveMPEGWinHooks(UnitSet units);
DLLCALL ULONG	WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units);



#if BOARD_HAS_MPEG2_ENCODER

DLLCALL ULONG  WINAPI VDR_DoCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL ULONG	WINAPI VDR_PutBuffer(UnitSet units, HPTR data, DWORD size);
DLLCALL ULONG  WINAPI VDR_InstallMPEGTransferDoneHook(UnitSet units, HWND hwnd, WORD transferDoneMsg);
DLLCALL ULONG  WINAPI VDR_RemoveMPEGTransferDoneHook(UnitSet units);
DLLCALL ULONG  WINAPI VDR_InstallMPEGEncoderBufferStarvingHook(UnitSet units, HWND hwnd, WORD bufferStarvingMsg);
DLLCALL ULONG  WINAPI VDR_RemoveMPEGEncoderBufferStarvingHook(UnitSet units);

#endif //BOARD_HAS_MPEG2_ENCODER

#endif //XSTATIC_LINK
	}



#define GNR_DRIVE_FAILURE							MKERR(ERROR,	DISK,			HARDWARE,			0x00)
// General drive failure

#define GNR_NO_VALID_DISK							MKERR(ERROR,	DISK,			OBJECT,				0x00)
// No valid/known disk was found

#define GNR_NO_DRIVE									MKERR(ERROR,	DISK,			OBJECT,				0x02)
// Drive does not exist/could not be found

#define GNR_DRIVE_DETACHED							MKERR(ERROR,	DISK,			OBJECT,				0x03)
// The drive has been detached -> is not available for playback

#define GNR_NO_DVD_DRIVE							MKERR(ERROR,	DISK,			OBJECT,				0x04)
// The drive is not a DVD drive (used on PCs)

#define GNR_INVALID_DRIVE_LETTER					MKERR(ERROR,	DISK,			BOUNDS,				0x01)
// The drive letter specified was not correct/out of range

#define GNR_DISK_READ_ONLY							MKERR(ERROR,	DISK,			FILEIO,				0x00)
// The disk is read-only

#define GNR_DRIVE_LOCK_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x00)
// Unable to lock/unlock the drive

#define GNR_DRIVE_ALREADY_LOCKED					MKERR(WARNING,	DISK,			OPERATION,			0x01)
// The drive was already locked

#define GNR_DRIVE_LOAD_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x02)
// Could not load/unload the drive

#define GNR_DRIVE_NOT_LOADABLE					MKERR(ERROR,	DISK,			OPERATION,			0x03)
// Drive does not support loading/unloading the disk

#define GNR_COPY_PROTECTION_VIOLATION			MKERR(ERROR,	DISK,			COPYPROTECTION,	0x00)

#define GNR_COPY_PROTECTION_FAILED				MKERR(ERROR,	DISK,			COPYPROTECTION,	0x01)


#define GNR_PATH_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,				)
// The path specified was not found

#define GNR_INVALID_PATH							MKERR(ERROR,	FILE,			OBJECT,				)
// The path specified was invalid (e.g. contained invalid letters)

#define GNR_FILE_READ_ONLY							MKERR(ERROR,	FILE,			OPERATION,	,)

#define FILE_IN_USE


//  Navigation in general

#define GNR_UNEXPECTED_NAVIGATION_ERROR				MKERR(ERROR,	NAVIGATION,	INTERNALSTATE,		0x00)
// Some internal error happened

#define GNR_INVALID_PLAYER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x00)
// The player handle is invalid

#define GNR_INVALID_NAV_INFO								MKERR(ERROR,	NAVIGATION,	OBJECT,				0x02)
// The navigation information is invalid (possible causes: wrong authoring, read error from drive, internal error)

#define GNR_LOST_DECODER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x03)
// The decoder has been preempted

#define GNR_OPERATION_NOT_SUPPORTED						MKERR(ERROR,	NAVIGATION, OPERATION,			0x00)
// This operation is (currently) not supported by the player

#define GNR_TITLE_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x01)
// The title specified does not exist

#define GNR_CHAPTER_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x02)
// The chapter specified does not exist

#define GNR_TIME_OUT_OF_RANGE								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x03)
// The time specified (e.g. for a search operation) is out of range

#define GNR_PROGRAM_LINK_NOT_FOUND						MKERR(ERROR,	NAVIGATION,	OPERATION,			0x04)
// The current program does not have a next/prev/upper/etc. program

#define GNR_MENU_DOES_NOT_EXIST							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x05)
// The requested menu does not exist

#define GNR_STREAM_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x06)
// The stream (audio/subpicture) does not exist

#define GNR_FLAGS_NOT_SUPPORTED							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x07)
// The flags specified for this operation are not supported

#define GNR_BUTTON_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x08)
// The specified button does not exist

#define GNR_UNKNOWN_EVENT_TYPE							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x09)
// The event type specified does not exist

#define GNR_BREAKPOINT_NOT_FOUND							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0a)
// The breakpoint to be deleted does not exist

#define GNR_INVALID_UNIQUE_KEY							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0b)
// The unique key could not be created/was invalid

//
//  DVD specific errors
//

#define GNR_UOP_PROHIBITED									MKERR(ERROR,	DVD,			UOP,					0x01)
// The current UOPs do not allow this action

#define GNR_REGIONS_DONT_MATCH							MKERR(ERROR,	DVD,			REGION,				0x00)
// The system and disk regions don't match

#define GNR_REGION_CODE_INVALID							MKERR(ERROR,	DVD,			REGION,				0x01)
// The region code specified was invalid (e.g. multiregion when trying to set region)

#define GNR_NO_MORE_REGION_SETS							MKERR(ERROR,	DVD,			REGION,				0x02)
// The number of region changes is exhausted

#define GNR_REGION_WRITE_ERROR							MKERR(ERROR,	DVD,			REGION,				0x03)
// Unable to write region

#define GNR_REGION_READ_ERROR								MKERR(ERROR,	DVD,			REGION,				0x04)
// Unable to read region

#define GNR_PARENTAL_LEVEL_TOO_LOW						MKERR(ERROR,	DVD,			PARENTAL,			0x03)
// The parental level currently set is too low to play the disc

#define GNR_ILLEGAL_NAVIGATION_COMMAND					MKERR(ERROR,	DVD,			OPERATION,			0x00)
// The DVD contains an illegal navigation command

#define GNR_ILLEGAL_DOMAIN									MKERR(ERROR,	DVD,			OPERATION,			0x01)
// The domain is illegal for this operation

#define GNR_NO_RESUME_INFORMATION						MKERR(ERROR,	DVD,			OPERATION,			0x02)
// No resume information currently available

//
//  VCD specific errors
//

//
//  CDDA specific errors
//


enum DVDPlayerMode
	{
	DPM_STOPPED,
	DPM_PAUSED,
	DPM_STILL,
	DPM_PLAYING,
	DPM_BUSY,
	DPM_SCANNING,
	DPM_INACTIVE,
	DPM_REVERSEPLAY,
	DPM_TRICKPLAY,
	DPM_REVERSESCAN
	};

enum DVDDomain
	{
	FP_DOM,
	VMGM_DOM,
	VTSM_DOM,
	TT_DOM,
	STOP_DOM,
	AMGM_DOM,
	TT_GR_DOM
	};

enum VTSMenuType
	{
	VMT_TITLE_MENU,
	VMT_ROOT_MENU,
	VMT_SUBPICTURE_MENU,
	VMT_AUDIO_MENU,
	VMT_ANGLE_MENU,
	VMT_PTT_MENU,
	VMT_NO_MENU		// Note that this is used in ExtendedPlayerState as array size
	};

enum DisplayPresentationMode
	{
	DPM_4BY3,
	DPM_16BY9,
	DPM_LETTERBOXED,
	DPM_PANSCAN,
	DPM_NONE
	};

enum DVDAudioCodingMode
	{
	DAM_AC3,
	DAM_MPEG1,
	DAM_MPEG2,
	DAM_LPCM,
	DAM_DTS,
	DAM_SDDS
	};

enum DVDAudioApplicationMode
	{
	DAAM_UNDEFINED		= 0,
	DAAM_KARAOKE		= 1,
	DAAM_SURROUND		= 2
	};

enum DVDKaraokeSoloDuetMode
	{
	DKM_SOLO				= 0,
	DKM_DUET				= 1,
	DKM_UNDEFINED		= 2
	};

enum MPEG2PrologicStatus		// Status of the decoder (actually played!)
	{
	MP2PS_OFF,
	MP2PS_ON,
	MP2PS_UNKNOWN
	};

enum MPEG2LFEStatus				// Content, not playing
	{
	MP2LFE_OFF,
	MP2LFE_ON,
	MP2LFE_UNKNOWN
	};

enum DVDDiskType
	{
	DDT_NONE,
	DDT_VIDEO_DVD,
	DDT_AUDIO_DVD,
	DDT_VIDEO_CD,
	DDT_AUDIO_CD,
	DDT_SUPER_AUDIO_CD,
	DDT_DTS_AUDIO_CD,
	DDT_SUPER_VIDEO_CD,
	DDT_MULTI_DISK			// Describes a CD-R or similar with files of different types on it
	};

enum RegionSource
	{
	RGSRC_UNDEFINED	= 0,
	RGSRC_DRIVE			= 1,
	RGSRC_BOARD			= 2
	};

enum VideoCompressionMode
	{
	VCM_UNKNOWN,
	VCM_MPEG1,
	VCM_MPEG2
	};

enum Line21Mode
	{
	L21M_NO_DATA,
	L21M_FIRST_FIELD,
	L21M_SECOND_FIELD,
	L21M_BOTH_FIELDS
	};

//
//  User Operation Bitmasks
//

#define UOP_TIME_PLAY_SEARCH				MKFLAG(0)
#define UOP_PTT_PLAY_SEARCH				MKFLAG(1)
#define UOP_TITLE_PLAY						MKFLAG(2)
#define UOP_STOP								MKFLAG(3)
#define UOP_GO_UP								MKFLAG(4)
#define UOP_TIME_PTT_SEARCH				MKFLAG(5)
#define UOP_PREV_TOP_PG_SEARCH			MKFLAG(6)
#define UOP_NEXT_PG_SEARCH					MKFLAG(7)
#define UOP_FORWARD_SCAN					MKFLAG(8)
#define UOP_BACKWARD_SCAN					MKFLAG(9)
#define UOP_SCAN_OFF							MKFLAG(25)	// additional
#define UOP_MENU_CALL_TITLE				MKFLAG(10)
#define UOP_MENU_CALL_ROOT					MKFLAG(11)
#define UOP_MENU_CALL_SUB_PICTURE		MKFLAG(12)
#define UOP_MENU_CALL_AUDIO				MKFLAG(13)
#define UOP_MENU_CALL_ANGLE				MKFLAG(14)
#define UOP_MENU_CALL_PTT					MKFLAG(15)
#define UOP_RESUME							MKFLAG(16)
#define UOP_BUTTON							MKFLAG(17)
#define UOP_STILL_OFF						MKFLAG(18)
#define UOP_PAUSE_ON							MKFLAG(19)
#define UOP_PAUSE_OFF						MKFLAG(26)	// additional
#define UOP_AUDIO_STREAM_CHANGE			MKFLAG(20)
#define UOP_SUB_PICTURE_STREAM_CHANGE	MKFLAG(21)
#define UOP_ANGLE_CHANGE					MKFLAG(22)
#define UOP_KARAOKE_MODE_CHANGE			MKFLAG(23)
#define UOP_VIDEO_MODE_CHANGE				MKFLAG(24)

//
//  Disc Information Structure
//

class __far DDPDiskInfo
	{
	public:
		DDPDiskInfo(void)			{size = sizeof(DDPDiskInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DVDDiskType		type;				// Type of media inserted
		char				uniqueKey[8];	// Unique identifier of disk
		BYTE				systemRegion;	// System region (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				diskRegion;		// Disk region (only for type == DDT_VIDEO_DVD)
		RegionSource	regionSource;	// Region source (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				availSets;		// Number of region sets left (only for type == DDT_VIDEO_DVD)
	};

//
//  DVD Time Class
//

class __far DVDTime
	{
	private:
		DWORD	stamp;  // Format HHHH HHHH MMMM MMMM SSSS SSSS RR FF FFFF
	public:
		DVDTime(DWORD stamp) {this->stamp = stamp;}
		DVDTime(void) {this->stamp = 0;}
		DVDTime(int hours, int minutes, int seconds, int frames, int frameRate);
		DVDTime(int millisecs, int divider, int frameRate);

		int FrameRate(void)	const {return XTBF(7, stamp) ? 30 : 25;}
		int Frames(void)		const {return (int)(XTBF(0, 4, stamp) + 10 * XTBF(4, 2, stamp));}
		int Seconds(void)		const {return (int)(XTBF(8, 4, stamp) + 10 * XTBF(12, 4, stamp));}
		int Minutes(void)		const {return (int)(XTBF(16, 4, stamp) + 10 * XTBF(20, 4, stamp));}
		int Hours(void)		const {return (int)(XTBF(24, 4, stamp) + 10 * XTBF(28, 4, stamp));}

		DWORD FrameTotal(void)	const	{return (Seconds() + Minutes() * 60 + Hours() * 3600) * FrameRate() + Frames();}

		DWORD Millisecs(void) const {return 1000 * Frames() / FrameRate() +
		                              1000 * Seconds() +
		                              60000 * Minutes() +
		                              3600000 * Hours();}

		friend DVDTime operator+ (const DVDTime u, const DVDTime v);
		friend DVDTime operator- (const DVDTime u, const DVDTime v);

		DVDTime & operator+= (const DVDTime u);
		DVDTime & operator-= (const DVDTime u);

		int Compare(const DVDTime u) const;

		friend BOOL operator==(const DVDTime u, const DVDTime v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const DVDTime u, const DVDTime v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const DVDTime u, const DVDTime v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const DVDTime u, const DVDTime v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const DVDTime u, const DVDTime v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const DVDTime u, const DVDTime v) {return u.Compare(v) >= 0;}

		BOOL IsZero(void)		const {return (stamp & 0xffffff3f) == 0;}
		BOOL IsNotZero(void)	const {return (stamp & 0xffffff3f) != 0;}
	};

//
//  DVD Location
//

class __far DVDLocation
	{
	public:
		DVDDomain	domain;
		WORD			videoTitleSet;
		WORD			title;
		WORD			vtsTitle;
		DVDTime		titleTime;
		WORD			partOfTitle;
		WORD			programChain;
		DVDTime		pgcTime;
		WORD			program;
		WORD			cell;
		DVDTime		cellTime;

		DVDLocation(void) {};
		friend BOOL	NotEqual(const DVDLocation u, const DVDLocation v);
		friend BOOL operator !=(const DVDLocation u, const DVDLocation v) { return (BOOL)memcmp(&u, &v, sizeof(DVDLocation)); }
	};

//
//  Audio Stream Format
//

class __far DVDAudioStreamFormat
	{
	public:
		WORD							languageCode;
		WORD							languageExtension;
		DVDAudioCodingMode		codingMode;
		WORD							bitsPerSample;
		DWORD							samplesPerSecond;
		WORD							channels;
		DVDAudioApplicationMode	applicationMode;
		BYTE							channelAssignment;
		BYTE							mcIntro;
		DVDKaraokeSoloDuetMode	soloDuetMode;

		friend BOOL operator==(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
		friend BOOL operator!=(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
	};

//
//  Video Stream Format
//

class VideoStreamFormat
	{
	public:
		VideoCompressionMode			compressionMode;			// Compression technique used
		VideoStandard					videoStandard;				// Source video standard
		DisplayPresentationMode		sourceAspectRatio;		// Aspect ratio of source picture
		BOOL								panScanOn4By3;				// TRUE if Pan & Scan is allowed on 4 by 3 display
		BOOL								letterboxedOn4By3;		// TRUE if letterboxed is allowed on 4 by 3 display
		Line21Mode						line21Mode;					// Encoded line 21 data
		WORD								sourceWidth;				// Width of source picture
		WORD								sourceHeight;				// Height of source picture
		BOOL								sourceLetterboxed;		// TRUE is source material is letterboxed

		friend BOOL operator==(const VideoStreamFormat & u, const VideoStreamFormat & v);
		friend BOOL operator!=(const VideoStreamFormat & u, const VideoStreamFormat & v);
	};

//
//  Subpicture Stream Format
//

class __far DVDSubPictureStreamFormat
	{
	public:
		WORD						languageCode;
		WORD						languageExtension;

		friend BOOL operator==(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
		friend BOOL operator!=(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
	};

//
//  Button Information
//

#define DBI_MAX_BUTTON_NUMBER 103

class __far DVDButtonInformation
	{
	public:
		WORD	x;
		WORD	y;
		WORD	w;
		WORD	h;
		BOOL	autoAction;
		BYTE	upperButton;
		BYTE	lowerButton;
		BYTE	leftButton;
		BYTE	rightButton;

		friend BOOL operator==(const DVDButtonInformation u, const DVDButtonInformation v);
		friend BOOL operator!=(const DVDButtonInformation u, const DVDButtonInformation v);
	};

//
//  Extended player state
//

// AC3 "acmod" property
enum AC3AudioCodingMode
	{
	AC3ACMOD_DUALMONO,
	AC3ACMOD_1_0,
	AC3ACMOD_2_0,
	AC3ACMOD_3_0,
	AC3ACMOD_2_1,
	AC3ACMOD_3_1,
	AC3ACMOD_2_2,
	AC3ACMOD_3_2,
	AC3ACMOD_UNKNOWN
	};

class __far ExtendedPlayerState
	{
	public:
		DWORD								size;								// Size of the structure passed

		// Request bitmasks

		DWORD								request;							// Bitmask for requested data
		DWORD								valid;							// Bitmask for delivered data
		DWORD								monitor;							// Bitmask indicating the elements to check for changes
		DWORD								changed;							// Bitmask indicating the elements that have changed

		// Player Information (EPS_PLAYERINFO, additions below)

		DVDPlayerMode					playerMode;						// Current player mode
		WORD								playbackSpeed;					// Current playback speed
		WORD								scanSpeed;						// Current scan speed
		DWORD								forbiddenUOPs;					// Forbidden UOPs

		// Hardware Information (EPS_MISC)

		DVDDiskType						diskType;						// Current disk type
		DisplayPresentationMode		displayMode;					// Current display mode
		VideoStandard					videoStandard;					// Current video standard
		DWORD								currentBitRate;				// Current bitrate

		// Audio Stream Information (EPS_AUDIOSTREAMS)

		int								currentAudioStream;			// Current Audio Stream ID
		BYTE								availableAudioStreams;		// Bitmask of audio streams available
		DVDAudioStreamFormat			audioStream[8];				// Audio stream data

		// Sub Picture Stream Information (EPS_SUBPICTURESTREAMS)

		int								currentSubPictureStream;	// Current sub picture Stream ID
		DWORD								availableSubPictureStreams;// Bitmask of sub picture streams available
		DVDSubPictureStreamFormat	subPictureStream[32];		// Subpicture stream data
		BOOL								subPictureEnable;				// Subpicture enabled

		// Title Information (EPS_TITLE)

		DVDLocation						location;						// Current location
		DVDLocation						duration;						// Current duration

		// Menu Information (EPS_MENU)

		WORD								menuLanguage;
		BOOL								menuAvailable[VMT_NO_MENU+1];  // Use a VTSMenuType as index

		// Parental Information (EPS_PARENTAL)

		WORD								parentalCountry;
		WORD								parentalLevel;

		// Angle Information (EPS_ANGLE, addition below)

		WORD								numberOfAngles;
		WORD								currentAngle;

		// Button Information (EPS_BUTTON)

		WORD								numberOfButtons;
		WORD								selectedButton;
		WORD								forcedlyActivatedButton;
		WORD								userButtonOffset;
		WORD								numberOfUserButtons;
		DVDButtonInformation			buttonInfo[DBI_MAX_BUTTON_NUMBER];

		// CDDA Information (EPS_PLAYINGGAP)

		BOOL								playingGap;						// CDDA only: TRUE is gap between titles is played

		// Additional Player Information (EPS_PLAYERINFO)

		BOOL								playingForward;

		// Additional Angle Information (EPS_ANGLE)

		BOOL								isMultiAngleScene;
		WORD								playingAngle;

		// Video stream information (EPS_VIDEOSTREAM, additional to info in EPS_MISC)

		VideoStreamFormat				videoStream;

		// Hardware Information (EPS_MISC, additional)

		BOOL								diskIsEncrypted;				// TRUE if disk is encrypted

		// Additional Audio Information

		MPEG2PrologicStatus			mpeg2PrologicStatus;			// Indicating if Prologic decoding is currently done
		MPEG2LFEStatus					mpeg2LFEStatus;				// Indicates if LFE info is in content
		AC3AudioCodingMode			ac3AudioCodingMode;			// Encoding, not actual output
	};

//
//  Request bitmask defines (00000200 in use)
//

#define EPS_PLAYERINFO				0x00000001
#define EPS_MISC						0x00000002
#define EPS_TITLE						0x00000004
#define EPS_AUDIOSTREAMS			0x00000008
#define EPS_SUBPICTURESTREAMS		0x00000010
#define EPS_ANGLE						0x00000020
#define EPS_MENU						0x00000040
#define EPS_PARENTAL					0x00000080
#define EPS_BUTTON					0x00000100
#define EPS_PLAYINGGAP				0x00000200
#define EPS_VIDEOSTREAM				0x00000400
#define EPS_KARAOKE					0x00000800
//
//  Shortcuts
//

#define EPS_COMMON					EPS_PLAYERINFO | EPS_MISC | EPS_TITLE
#define EPS_DVD						EPS_MENU | EPS_PARENTAL | EPS_BUTTON | EPS_ANGLE | EPS_AUDIOSTREAMS | \
											EPS_SUBPICTURESTREAMS | EPS_VIDEOSTREAM
#define EPS_VCD						EPS_BUTTON | EPS_AUDIOSTREAMS
#define EPS_CDA						EPS_PLAYINGGAP | EPS_AUDIOSTREAMS
#define EPS_ALL						EPS_COMMON | EPS_DVD | EPS_VCD | EPS_CDA

//
//  Disk Navigation Event handling
//

typedef void (WINAPI * DNEEventHandler)(DWORD event, void * userData, DWORD info);

#define DNE_NONE								0
#define DNE_TITLE_CHANGE					1
#define DNE_PART_OF_TITLE_CHANGE			2
#define DNE_VALID_UOP_CHANGE				3
#define DNE_ANGLE_CHANGE					4
#define DNE_AUDIO_STREAM_CHANGE			5
#define DNE_SUBPICTURE_STREAM_CHANGE	6
#define DNE_DOMAIN_CHANGE					7
#define DNE_PARENTAL_LEVEL_CHANGE		8
#define DNE_BITRATE_CHANGE					9
#define DNE_STILL_ON							10
#define DNE_STILL_OFF						11
#define DNE_PLAYBACK_MODE_CHANGE			12
#define DNE_CDA_PLAYING_GAP				13
#define DNE_READ_ERROR						14
#define DNE_DISPLAY_MODE_CHANGE			15
#define DNE_STREAMS_CHANGE					16
#define DNE_SCAN_SPEED_CHANGE				17
#define DNE_PLAYBACK_SPEED_CHANGE		18
#define DNE_VIDEO_STANDARD_CHANGE		19
#define DNE_BREAKPOINT_REACHED			20
#define DNE_DRIVE_DETACHED					21		// OBSOLETE
#define DNE_ERROR								22

#define DNE_EVENT_NUMBER					23

//
//  ERS Breakpoints
//

#define ERS_BREAKPOINT_NONE				0xffffffff	// Defines an invalid breakpoint id

//
//  Flags for DDP_SetBreakpoint()
//

enum ERSBreakpointFlags
	{
	ERS_NONE					=	0x0000,	// No flags, normal breakpoint
	ERS_PAUSE				=	0x0001,	// Go to still mode when reaching breakpoint
	ERS_AUTOCLEAR			=	0x0002,	// Delete breakpoint when it has been reached
	ERS_PAUSEATEND			=	0x0004,	// Trigger at end of title
	};

//
//  Flags for DDP_SetBreakpointExt()
//

enum ERSBreakpointExtFlags
	{
	ERS_ATTIME			=	0x0001,	// Trigger when reaching time in title
	ERS_ENDOFTITLE		=	0x0002,	// Trigger at end of title
	ERS_ENDOFPTT		=	0x0004,	// Trigger at and of part of title
	ERS_FORWARD			=	0x0008,	// Trigger when playing forward
	ERS_BACKWARD		=	0x0010,	// Trigger when playing backward
	ERS_TOSTILL			=	0x0020,	// Go to still when reaching breakpoint
	ERS_CLEAR			=	0x0040,	// Automatically delete breakpoint after triggering
	ERS_BEGINOFPTT		=	0x0080	// Trigger at begin of PTT
	};

// flags for ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

#define DDPEPF_PAUSE_AT_START		1
#define DDPEPF_USE_TIME				2
#define DDPEPF_USE_PTT				4
#define DDPEPF_USE_TITLE			8

// flags for DetachDrive(DWORD flags, DVDTime time);

#define DDPDDF_DETACH_IMMEDIATE				1
#define DDPDDF_DETACH_AT_TIME					2
#define DDPDDF_DETACH_AT_END_OF_CELL		4
#define DDPDDF_DETACH_AT_END_OF_PROGRAM	8
#define DDPDDF_DETACH_AT_END_OF_PGC			16

#define DDPDDF_DETACH_ANY						31

#define DDPDDF_STREAM_PREFETCH				32
#define DDPDDF_PREFETCH_BUFFER_SIZE			64

// Flags for DDP_StartPresentationExt and DDP_DefrostExt

#define DDPSPF_NONE		0
#define DDPSPF_TOPAUSE	1


typedef class CDDiskPlayerClass * DVDDiskPlayer;

extern "C" {

#ifndef DLLCALL
#define DLLCALL __declspec(dllexport)
#endif

#ifdef XSTATIC_LINK

ULONG WINAPI  DDP_CheckDrive(char driveLetter, char __far * id);

ULONG WINAPI  DDP_CheckDriveWithPath(char * drivePath, char __far * id);

ULONG WINAPI  DDP_GetVolumeName(char driveLetter, char * name);

ULONG WINAPI  DDP_GetDiskRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far & regionSource, BYTE & diskRegion);

ULONG WINAPI  DDP_GetRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far &regionSource);

ULONG WINAPI  DDP_SetSystemRegion(UnitSet units, char driveLetter, BYTE region);

ULONG WINAPI  DDP_EjectDiskInDrive(char driveLetter);

ULONG WINAPI  DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed);

ULONG WINAPI  DDP_LoadDiskInDrive(char driveLetter, BOOL wait);

ULONG WINAPI  DDP_OpenPlayer(UnitSet units, char diskLetter, DVDDiskPlayer __far & player);

ULONG WINAPI  DDP_OpenPlayerWithPath(UnitSet units, char * drivePath, DVDDiskPlayer __far & player);

ULONG WINAPI  DDP_OpenPlayerExtended(UnitSet units, char driveLetter, char * drivePath,
													DVDDiskPlayer __far & player, DDPDiskInfo __far & diskInfo);

ULONG WINAPI  DDP_ClosePlayer(DVDDiskPlayer player);

ULONG WINAPI  DDP_StartPresentation(DVDDiskPlayer player);

ULONG WINAPI  DDP_StartPresentationExt(DVDDiskPlayer player, DWORD flags);

DVDDiskType	 WINAPI DDP_GetDiskType(DVDDiskPlayer player);

ULONG WINAPI  DDP_GetCurrentLocation(DVDDiskPlayer player, DVDLocation __far & location);

ULONG WINAPI  DDP_GetCurrentDuration(DVDDiskPlayer player, DVDLocation __far & location);

ULONG WINAPI  DDP_GetTitleDuration(DVDDiskPlayer player, WORD title, DVDTime & duration);

DVDPlayerMode WINAPI DDP_GetPlayerMode(DVDDiskPlayer player);

ULONG WINAPI	 DDP_GetExtendedPlayerState(DVDDiskPlayer player, ExtendedPlayerState & eps);

DWORD WINAPI  DDP_GetForbiddenUserOperations(DVDDiskPlayer player);

WORD  WINAPI  DDP_GetNumberOfTitles(DVDDiskPlayer player);

WORD  WINAPI  DDP_GetNumberOfPartOfTitle(DVDDiskPlayer player, WORD title);

ULONG WINAPI  DDP_GetAvailStreams(DVDDiskPlayer player, BYTE __far & audioMask, DWORD __far & subPictureMask);

ULONG WINAPI  DDP_GetAudioStreamAttributes(DVDDiskPlayer player, WORD stream, DVDAudioStreamFormat __far & format);

ULONG WINAPI  DDP_GetSubPictureStreamAttributes(DVDDiskPlayer player, WORD stream, DVDSubPictureStreamFormat __far & format);

WORD  WINAPI  DDP_GetCurrentAudioStream(DVDDiskPlayer player);

WORD  WINAPI  DDP_GetCurrentSubPictureStream(DVDDiskPlayer player);

BOOL  WINAPI  DDP_IsCurrentSubPictureEnabled(DVDDiskPlayer player);

WORD  WINAPI  DDP_GetNumberOfAngles(DVDDiskPlayer player, WORD title);

WORD  WINAPI  DDP_GetCurrentAngle(DVDDiskPlayer player);

BOOL  WINAPI  DDP_CheckMenuAvail(DVDDiskPlayer player, VTSMenuType menu);

DisplayPresentationMode WINAPI  DDP_GetCurrentDisplayMode(DVDDiskPlayer player);

ULONG WINAPI  DDP_SetDisplayMode(DVDDiskPlayer player, DisplayPresentationMode mode);

ULONG WINAPI  DDP_TitlePlay(DVDDiskPlayer player, WORD title);

ULONG WINAPI  DDP_PTTPlay(DVDDiskPlayer player, WORD title, WORD part);

ULONG WINAPI  DDP_TimePlay(DVDDiskPlayer player, WORD title, DVDTime time);

ULONG WINAPI  DDP_TimePlayForced(DVDDiskPlayer player, WORD title, DVDTime time);

ULONG WINAPI  DDP_ExtendedPlay(DVDDiskPlayer player, DWORD flags, WORD title, WORD ptt, DVDTime time);

ULONG WINAPI  DDP_Stop(DVDDiskPlayer player);

ULONG WINAPI  DDP_GoUp(DVDDiskPlayer player);

ULONG WINAPI  DDP_TimeSearch(DVDDiskPlayer player, DVDTime time);

ULONG WINAPI  DDP_TimeSearchForced(DVDDiskPlayer player, DVDTime time);

ULONG WINAPI  DDP_PTTSearch(DVDDiskPlayer player, WORD part);

ULONG WINAPI  DDP_PrevPGSearch(DVDDiskPlayer player);

ULONG WINAPI  DDP_TopPGSearch(DVDDiskPlayer player);

ULONG WINAPI  DDP_NextPGSearch(DVDDiskPlayer player);

ULONG WINAPI  DDP_ForwardScan(DVDDiskPlayer player, WORD speed);

ULONG WINAPI  DDP_BackwardScan(DVDDiskPlayer player, WORD speed);

ULONG WINAPI  DDP_TrickPlay(DVDDiskPlayer player);

ULONG WINAPI  DDP_StopScan(DVDDiskPlayer player);

ULONG WINAPI  DDP_ReversePlayback(DVDDiskPlayer player);

ULONG WINAPI  DDP_MenuCall(DVDDiskPlayer player, VTSMenuType menu);

ULONG WINAPI  DDP_Resume(DVDDiskPlayer player);

ULONG WINAPI  DDP_UpperButtonSelect(DVDDiskPlayer player);

ULONG WINAPI  DDP_LowerButtonSelect(DVDDiskPlayer player);

ULONG WINAPI  DDP_LeftButtonSelect(DVDDiskPlayer player);

ULONG WINAPI  DDP_RightButtonSelect(DVDDiskPlayer player);

ULONG WINAPI  DDP_ButtonSelectAt(DVDDiskPlayer player, WORD x, WORD y);

ULONG WINAPI  DDP_ButtonActivate(DVDDiskPlayer player);

ULONG WINAPI  DDP_ButtonSelectAndActivate(DVDDiskPlayer player, WORD num);

ULONG WINAPI  DDP_ButtonSelectAndActivateAt(DVDDiskPlayer player, WORD x, WORD y);

BOOL  WINAPI  DDP_IsButtonAt(DVDDiskPlayer player, WORD x, WORD y);

ULONG WINAPI  DDP_StillOff(DVDDiskPlayer player);

ULONG WINAPI  DDP_PauseOn(DVDDiskPlayer player);

ULONG WINAPI  DDP_PauseOff(DVDDiskPlayer player);

ULONG WINAPI  DDP_AdvanceFrame(DVDDiskPlayer player);

ULONG WINAPI  DDP_AdvanceFrameBy(DVDDiskPlayer player, int by);

ULONG WINAPI  DDP_SetPlaybackSpeed(DVDDiskPlayer player, WORD speed);

ULONG WINAPI  DDP_MenuLanguageSelect(DVDDiskPlayer player, WORD language);

ULONG WINAPI  DDP_AudioStreamChange(DVDDiskPlayer player, WORD streamID);

ULONG WINAPI  DDP_SubPictureStreamChange(DVDDiskPlayer player, WORD streamID, BOOL display);

ULONG WINAPI  DDP_AngleChange(DVDDiskPlayer player, WORD angle);

ULONG WINAPI  DDP_ParentalLevelSelect(DVDDiskPlayer player, WORD parentalLevel);

ULONG WINAPI  DDP_ParentalCountrySelect(DVDDiskPlayer player, WORD country);

ULONG WINAPI  DDP_InitialLanguageSelect(DVDDiskPlayer player,
												      WORD audioLanguage,
												      WORD audioExtension,
												      WORD subPictureLanguage,
												      WORD subPictureExtension);

ULONG WINAPI  DDP_InquireCurrentBitRate(DVDDiskPlayer player, DWORD & bitsPerSecond);

ULONG WINAPI  DDP_GetCurrentButtonState(DVDDiskPlayer player, WORD & minButton, WORD & numButtons, WORD & currentButton);

ULONG WINAPI  DDP_Freeze(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

ULONG WINAPI  DDP_Defrost(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

ULONG WINAPI  DDP_DefrostExt(DVDDiskPlayer player, BYTE * buffer, DWORD & length, DWORD flags);

ULONG WINAPI  DDP_InstallEventHandler(DVDDiskPlayer player, DWORD event, DNEEventHandler handler, void * userData);

ULONG WINAPI  DDP_RemoveEventHandler(DVDDiskPlayer player, DWORD event);

ULONG WINAPI  DDP_SetBreakpoint(DVDDiskPlayer player, WORD title, DVDTime time, DWORD flags, DWORD & id);

ULONG WINAPI  DDP_SetBreakpointExt(DVDDiskPlayer player, WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

ULONG WINAPI  DDP_ClearBreakpoint(DVDDiskPlayer player, DWORD id);

ULONG WINAPI  DDP_DetachDrive(DVDDiskPlayer player, DWORD flags, DVDTime time, DWORD bufferSize);

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD  fdwReason, LPVOID lpvReserved);

#else

DLLCALL ULONG WINAPI  DDP_CheckDrive(char driveLetter, char __far * id);

DLLCALL ULONG WINAPI  DDP_CheckDriveWithPath(char * drivePath, char __far * id);

DLLCALL ULONG WINAPI  DDP_GetVolumeName(char driveLetter, char * name);

DLLCALL ULONG WINAPI  DDP_GetDiskRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far & regionSource, BYTE & diskRegion);

DLLCALL ULONG WINAPI  DDP_GetRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far &regionSource);

DLLCALL ULONG WINAPI  DDP_SetSystemRegion(UnitSet units, char driveLetter, BYTE region);

DLLCALL ULONG WINAPI  DDP_EjectDiskInDrive(char driveLetter);

DLLCALL ULONG WINAPI  DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed);

DLLCALL ULONG WINAPI  DDP_LoadDiskInDrive(char driveLetter, BOOL wait);

DLLCALL ULONG WINAPI  DDP_OpenPlayer(UnitSet units, char diskLetter, DVDDiskPlayer __far & player);

DLLCALL ULONG WINAPI  DDP_OpenPlayerWithPath(UnitSet units, char * drivePath, DVDDiskPlayer __far & player);

DLLCALL ULONG WINAPI  DDP_OpenPlayerExtended(UnitSet units, char driveLetter, char * drivePath,
															DVDDiskPlayer __far & player, DDPDiskInfo __far & diskInfo);

DLLCALL ULONG WINAPI  DDP_ClosePlayer(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_StartPresentation(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_StartPresentationExt(DVDDiskPlayer player, DWORD flags);

DLLCALL DVDDiskType	 WINAPI DDP_GetDiskType(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_GetCurrentLocation(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL ULONG WINAPI  DDP_GetCurrentDuration(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL ULONG WINAPI  DDP_GetTitleDuration(DVDDiskPlayer player, WORD title, DVDTime & duration);

DLLCALL DVDPlayerMode WINAPI DDP_GetPlayerMode(DVDDiskPlayer player);

DLLCALL ULONG WINAPI	 DDP_GetExtendedPlayerState(DVDDiskPlayer player, ExtendedPlayerState & eps);

DLLCALL DWORD WINAPI  DDP_GetForbiddenUserOperations(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfTitles(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfPartOfTitle(DVDDiskPlayer player, WORD title);

DLLCALL ULONG WINAPI  DDP_GetAvailStreams(DVDDiskPlayer player, BYTE __far & audioMask, DWORD __far & subPictureMask);

DLLCALL ULONG WINAPI  DDP_GetAudioStreamAttributes(DVDDiskPlayer player, WORD stream, DVDAudioStreamFormat __far & format);

DLLCALL ULONG WINAPI  DDP_GetSubPictureStreamAttributes(DVDDiskPlayer player, WORD stream, DVDSubPictureStreamFormat __far & format);

DLLCALL WORD  WINAPI  DDP_GetCurrentAudioStream(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetCurrentSubPictureStream(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_IsCurrentSubPictureEnabled(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfAngles(DVDDiskPlayer player, WORD title);

DLLCALL WORD  WINAPI  DDP_GetCurrentAngle(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_CheckMenuAvail(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL DisplayPresentationMode WINAPI  DDP_GetCurrentDisplayMode(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_SetDisplayMode(DVDDiskPlayer player, DisplayPresentationMode mode);

DLLCALL ULONG WINAPI  DDP_TitlePlay(DVDDiskPlayer player, WORD title);

DLLCALL ULONG WINAPI  DDP_PTTPlay(DVDDiskPlayer player, WORD title, WORD part);

DLLCALL ULONG WINAPI  DDP_TimePlay(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL ULONG WINAPI  DDP_TimePlayForced(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL ULONG WINAPI  DDP_ExtendedPlay(DVDDiskPlayer player, DWORD flags, WORD title, WORD ptt, DVDTime time);

DLLCALL ULONG WINAPI  DDP_Stop(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_GoUp(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_TimeSearch(DVDDiskPlayer player, DVDTime time);

DLLCALL ULONG WINAPI  DDP_TimeSearchForced(DVDDiskPlayer player, DVDTime time);

DLLCALL ULONG WINAPI  DDP_PTTSearch(DVDDiskPlayer player, WORD part);

DLLCALL ULONG WINAPI  DDP_PrevPGSearch(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_TopPGSearch(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_NextPGSearch(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_ForwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL ULONG WINAPI  DDP_BackwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL ULONG WINAPI  DDP_TrickPlay(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_StopScan(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_ReversePlayback(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_MenuCall(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL ULONG WINAPI  DDP_Resume(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_UpperButtonSelect(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_LowerButtonSelect(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_LeftButtonSelect(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_RightButtonSelect(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_ButtonSelectAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL ULONG WINAPI  DDP_ButtonActivate(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_ButtonSelectAndActivate(DVDDiskPlayer player, WORD num);

DLLCALL ULONG WINAPI  DDP_ButtonSelectAndActivateAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL BOOL  WINAPI  DDP_IsButtonAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL ULONG WINAPI  DDP_StillOff(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_PauseOn(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_PauseOff(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_AdvanceFrame(DVDDiskPlayer player);

DLLCALL ULONG WINAPI  DDP_AdvanceFrameBy(DVDDiskPlayer player, int by);

DLLCALL ULONG WINAPI  DDP_SetPlaybackSpeed(DVDDiskPlayer player, WORD speed);

DLLCALL ULONG WINAPI  DDP_MenuLanguageSelect(DVDDiskPlayer player, WORD language);

DLLCALL ULONG WINAPI  DDP_AudioStreamChange(DVDDiskPlayer player, WORD streamID);

DLLCALL ULONG WINAPI  DDP_SubPictureStreamChange(DVDDiskPlayer player, WORD streamID, BOOL display);

DLLCALL ULONG WINAPI  DDP_AngleChange(DVDDiskPlayer player, WORD angle);

DLLCALL ULONG WINAPI  DDP_ParentalLevelSelect(DVDDiskPlayer player, WORD parentalLevel);

DLLCALL ULONG WINAPI  DDP_ParentalCountrySelect(DVDDiskPlayer player, WORD country);

DLLCALL ULONG WINAPI  DDP_InitialLanguageSelect(DVDDiskPlayer player,
														      WORD audioLanguage,
														      WORD audioExtension,
														      WORD subPictureLanguage,
														      WORD subPictureExtension);

DLLCALL ULONG WINAPI  DDP_InquireCurrentBitRate(DVDDiskPlayer player, DWORD & bitsPerSecond);

DLLCALL ULONG WINAPI  DDP_GetCurrentButtonState(DVDDiskPlayer player, WORD & minButton, WORD & numButtons, WORD & currentButton);

DLLCALL ULONG WINAPI  DDP_Freeze(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL ULONG WINAPI  DDP_Defrost(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL ULONG WINAPI  DDP_DefrostExt(DVDDiskPlayer player, BYTE * buffer, DWORD & length, DWORD flags);

DLLCALL ULONG WINAPI  DDP_InstallEventHandler(DVDDiskPlayer player, DWORD event, DNEEventHandler handler, void * userData);

DLLCALL ULONG WINAPI  DDP_RemoveEventHandler(DVDDiskPlayer player, DWORD event);

DLLCALL ULONG WINAPI  DDP_SetBreakpoint(DVDDiskPlayer player, WORD title, DVDTime time, DWORD flags, DWORD & id);

DLLCALL ULONG WINAPI  DDP_SetBreakpointExt(DVDDiskPlayer player, WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

DLLCALL ULONG WINAPI  DDP_ClearBreakpoint(DVDDiskPlayer player, DWORD id);

DLLCALL ULONG WINAPI  DDP_DetachDrive(DVDDiskPlayer player, DWORD flags, DVDTime time, DWORD bufferSize);

#endif //XSTATIC_LINK
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xapp.rc
//
#define IDI_APP_ICON                    101
#define IDB_FLARE3                      102
#define IDB_FLARE1                      103
#define IDB_FLARE2                      104
#define IDB_FLARE0                      105
#define IDB_PARTICLE                    107
#define IDB_GROUND                      108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Parser.cpp ===
#include "std.h"
#include "xapp.h"
#include "Parser.h"
#include "Node.h"
#include "Runner.h"
#include "DefUse.h"

//#define LOCALTRACE TRACE
#define LOCALTRACE 1 ? (void)0 : ::Trace

CNameSpace* g_classes; // REVIEW:: Kill this hack!

static const TCHAR szParseError [] = _T("");

////////////////////////////////////////////////////////////////////////////

CClassCompiler::CClassCompiler(CClass* pClass)
{
    ASSERT(pClass != NULL);
    m_pClass = pClass;
}

const TCHAR* CClassCompiler::Compile(const TCHAR* pch)
{
    for (;;)
    {
        pch = SkipWhite(pch);

        if (*pch == '\0' || *pch == '}')
            break;

        pch = ParseNode(pch);
    }

    Write(0);

    return pch;
}

const TCHAR* CClassCompiler::ParseNode(const TCHAR* pch)
{
    const TCHAR* pchToken;
    int cchToken;
    pch = Token(pch, pchToken, cchToken);

    if (cchToken == 3 && _tcsncmp(pchToken, _T("DEF"), cchToken) == 0)
    {
        pch = Token(pch, pchToken, cchToken, true); // NOTE: bAllowPaths so '-' works in node names...

        CMember* pMember = new CMember;
        pMember->m_nMember = m_pClass->m_nVarCount++;
        m_pClass->AddMember(pchToken, cchToken, pMember);

        Write(opDefNode);
        WriteInteger(pMember->m_nMember);

        pch = ParseNode(pch);
    }
    else if (cchToken == 3 && _tcsncmp(pchToken, _T("USE"), cchToken) == 0)
    {
        pch = Token(pch, pchToken, cchToken, true); // NOTE: bAllowPaths so '-' works in node names...

        CMember* pMember = (CMember*)m_pClass->GetMember(pchToken, cchToken);
        if (pMember == NULL || pMember->m_obj != objMember)
        {
            TCHAR szBuf [256];
            if (cchToken > 255)
                cchToken = 255;
            CopyChars(szBuf, pchToken, cchToken);
            szBuf[cchToken] = 0;
            SyntaxError(_T("Undefined USE '%s'"), szBuf);
            return szParseError;
        }

        Write(opUseNode);
        WriteInteger(pMember->m_nMember);
    }
    else if (cchToken == 8 && _tcsncmp(pchToken, _T("behavior"), cchToken) == 0)
    {
        CFunction* pFunction;
        pch = ParseFunction(pch, pFunction, true);
        if (pFunction != NULL)
            m_pClass->SetMember(pchToken, cchToken, pFunction);
    }
    else if (cchToken == 8 && _tcsncmp(pchToken, _T("function"), cchToken) == 0)
    {
#ifdef _DEBUG0
        int nStartTime = GetTickCount();
#endif
        pch = Token(pch, pchToken, cchToken);

        if (cchToken == 8 && _tcsncmp(_T("behavior"), pchToken, cchToken) == 0)
        {
            SyntaxError(_T("invalid function name"));
            return szParseError;
        }

        CFunction* pFunction;
        pch = ParseFunction(pch, pFunction);
        if (pFunction != NULL)
        {
#ifdef _DEBUG
            pFunction->m_szName = new TCHAR [cchToken + 1];
            CopyChars(pFunction->m_szName, pchToken, cchToken);
            pFunction->m_szName[cchToken] = 0;
            LOCALTRACE(_T("member function %s\n"), pFunction->m_szName);
#endif
            m_pClass->SetMember(pchToken, cchToken, pFunction);
        }
//      TRACE(_T("\t0x%08x\n"), pFunction);
#ifdef _DEBUG0
        TRACE(_T("%s took %d mS to compile\n"), pFunction->m_szName, GetTickCount() - nStartTime);
#endif
    }
    else if (cchToken == 3 && _tcsncmp(pchToken, _T("var"), cchToken) == 0)
    {
        pch = ParseMemberVar(pch);
    }
    else if (cchToken == 5 && _tcsncmp(pchToken, _T("class"), cchToken) == 0)
    {
        pch = ParseClass(pch);
    }
    else if (cchToken == 6 && _tcsncmp(pchToken, _T("import"), cchToken) == 0)
    {
        pch = Token(pch, pchToken, cchToken);
        pch = SkipWhite(pch);
        if (*pch != ',')
        {
            SyntaxError(_T("Expected ','"));
            return szParseError;
        }

        pch += 1;

        const TCHAR* pchURL;
        int cchURL;
        pch = Token(pch, pchURL, cchURL);

        TCHAR szURL [MAX_PATH];
        CopyChars(szURL, pchURL, cchURL);
        szURL[cchURL] = '\0';

        CClass* pClass = new CClass;

        TRACE(_T("Importing "), szURL);

        if (!pClass->Load(szURL))
        {
            delete pClass;
            return szParseError;
        }

        g_classes->Define(pchToken, cchToken, (CNode*)pClass);
    }
    else
    {
        CNodeClass* pNodeClass = LookupClass(pchToken, cchToken);
        if (pNodeClass == NULL)
            pNodeClass = CNodeClass::FindByName(pchToken, cchToken);

        if (pNodeClass == NULL)
        {
            TCHAR chSav = pchToken[cchToken];
            ((TCHAR*)pchToken)[cchToken] = '\0';
            SyntaxError(_T("Unknown class: %s"), pchToken);
            ((TCHAR*)pchToken)[cchToken] = chSav;
            return szParseError; // cause parsing to end
        }

        Write(opNewNode);
        WriteString(pchToken, cchToken);


        pch = SkipWhite(pch);

        if (*pch == '{')
        {
            pch += 1;

            pch = ParseProps(pch, pNodeClass/*pNode*/);

            if (*pch != '}')
            {
                SyntaxError(_T("Exected a '}'"));
                return szParseError; // cause parsing to end
            }

            pch += 1;
        }

        Write(opEndNode);
    }

    pch = SkipWhite(pch);
    if (*pch == ',')
        pch += 1;

    return pch;
}

const TCHAR* CClassCompiler::ParseChildren(const TCHAR* pch)
{
    pch = SkipWhite(pch);

    if (*pch == '[')
    {
        pch += 1;
        pch = SkipWhite(pch);

        for (;;)
        {
            pch = SkipWhite(pch);

            if (*pch == '\0' || *pch == '}' || *pch == ']')
                break;

            pch = ParseNode(pch);
        }

        if (*pch == ']')
            pch += 1;
        else
            SyntaxError(_T("Exected a ']'"));
    }
    else
    {
        pch = ParseNode(pch);
    }

    return pch;
}

const TCHAR* CClassCompiler::ParseProps(const TCHAR* pch, CNodeClass* pNodeClass)
{
    for (;;)
    {
        pch = SkipWhite(pch);
        if (*pch == '\0' || *pch == '}')
            break;

        const TCHAR* pchToken;
        int cchToken;
        pch = Token(pch, pchToken, cchToken);

        if (cchToken == 8 && _tcsncmp(_T("behavior"), pchToken, cchToken) == 0)
        {
            CFunction* pFunction;
            pch = ParseFunction(pch, pFunction, true);
            if (pFunction != NULL)
            {
                int nFunction = m_pClass->m_instanceFunctions.GetLength();
                m_pClass->m_instanceFunctions.AddNode((CNode*)pFunction);

                Write(opFunction);
                WriteString(pchToken, cchToken);
                WriteInteger(nFunction);
            }
            continue;
        }

        if (cchToken == 8 && _tcsncmp(_T("function"), pchToken, cchToken) == 0)
        {
            // We have an instance function here...
            pch = Token(pch, pchToken, cchToken);

            if (cchToken == 8 && _tcsncmp(_T("behavior"), pchToken, cchToken) == 0)
            {
                SyntaxError(_T("invalid function name"));
                return szParseError;
            }

            CFunction* pFunction;
            pch = ParseFunction(pch, pFunction);
            if (pFunction != NULL)
            {
#ifdef _DEBUG
                pFunction->m_szName = new TCHAR [cchToken + 1];
                CopyChars(pFunction->m_szName, pchToken, cchToken);
                pFunction->m_szName[cchToken] = 0;
                LOCALTRACE(_T("instance function %s\n"), pFunction->m_szName);
#endif
                int nFunction = m_pClass->m_instanceFunctions.GetLength();
                m_pClass->m_instanceFunctions.AddNode((CNode*)pFunction);

                Write(opFunction);
                WriteString(pchToken, cchToken);
                WriteInteger(nFunction);

//              TRACE(_T("\t0x%08x\n"), pFunction);
            }
            continue;
        }

#ifdef _DEBUG_0
        {
            TCHAR chSav = pchToken[cchToken];
            ((TCHAR*)pchToken)[cchToken] = '\0';
            TRACE(_T("property %s\n"), pchToken);
            ((TCHAR*)pchToken)[cchToken] = chSav;
        }
#endif

        const PRD* pprd = pNodeClass->FindProp(pchToken, cchToken);

        if (pprd == NULL)
        {
            TCHAR chSav = pchToken[cchToken];
            ((TCHAR*)pchToken)[cchToken] = '\0';
            SyntaxError(_T("Unknown property: %s"), pchToken);
            ((TCHAR*)pchToken)[cchToken] = chSav;
            return szParseError;
        }
        else
        {
            if (pprd->nType == pt_children || pprd->nType == pt_nodearray)
            {
                Write(opInitArray);
                WriteInteger((int)pprd->pbOffset);

                pch = ParseChildren(pch);

                Write(opEndArray);
            }
            else if (pprd->nType == pt_node)
            {
                Write(opNewNodeProp);
                Write(pprd, sizeof (PRD));

                pch = ParseNode(pch);
            }
            else
            {
                union { bool b; int i; float n; float v [4]; TCHAR* s; /*CNode* p;*/} value;
                BYTE* pbArray = NULL;
                int cbValue = 0;

                switch (pprd->nType)
                {
                case pt_boolean:
                    pch = ParseBoolean(pch, value.b);
                    cbValue = sizeof (bool);
                    break;

                case pt_integer:
                    pch = ParseInteger(pch, value.i);
                    cbValue = sizeof (int);
                    break;

                case pt_number:
                    pch = ParseNumber(pch, value.n);
                    cbValue = sizeof (float);
                    break;

                case pt_string:
                    pch = ParseString(pch, value.s);
                    cbValue = _tcslen(value.s);
                    break;

                case pt_vec3:
                case pt_color:
                    pch = ParseVec3(pch, value.v);
                    cbValue = sizeof (D3DXVECTOR3);
                    break;

                case pt_vec4:
                case pt_quaternion:
                    pch = ParseVec4(pch, value.v);
                    cbValue = sizeof (D3DXVECTOR4);
                    break;

                case pt_intarray:
                    pch = ParseIntArray(pch, pbArray, cbValue);
                    break;

                case pt_numarray:
                    pch = ParseVecArray(pch, pbArray, cbValue, 1);
                    break;

                case pt_vec2array:
                    pch = ParseVecArray(pch, pbArray, cbValue, 2);
                    break;

                case pt_vec3array:
                    pch = ParseVecArray(pch, pbArray, cbValue, 3);
                    break;

                case pt_vec4array:
                    pch = ParseVecArray(pch, pbArray, cbValue, 4);
                    break;
                }

                Write(opInitProp);
                Write(pprd, sizeof (PRD));

                if (pprd->nType == pt_string)
                {
                    WriteString(value.s, cbValue);
                    delete [] value.s;
                }
                else
                {
                    WriteInteger(cbValue);
                    if (pbArray != NULL)
                    {
                        Write(pbArray, cbValue);
                        delete [] pbArray;
                    }
                    else
                    {
                        Write(&value, cbValue);
                    }
                }
            }
        }
    }

    return pch;
}

// Add member variables to the current class...
const TCHAR* CClassCompiler::ParseMemberVar(const TCHAR* pch)
{
    for (;;)
    {
        const TCHAR* pchToken;
        int cchToken;
        pch = Token(pch, pchToken, cchToken);

#ifdef _DEBUG0
        {
            TCHAR chSav = pchToken[cchToken];
            ((TCHAR*)pchToken)[cchToken] = '\0';
            LOCALTRACE(_T("new member variable \"%s\"\n"), pchToken);
            ((TCHAR*)pchToken)[cchToken] = chSav;
        }
#endif

        CMember* pMember = new CMember;
        pMember->m_nMember = m_pClass->m_nVarCount++;
        m_pClass->AddMember(pchToken, cchToken, pMember);

        pch = SkipWhite(pch);

        if (*pch == '=')
        {
            pch += 1;

            // TODO: Initializers -- add init code to class constructor!
            {
                SyntaxError(_T("Sorry, class member initializers have not been implemented yet!"));
                return szParseError;
            }

            pch = SkipWhite(pch);
        }

        if (*pch != ',')
            break;

        pch += 1;
    }

    if (*pch != ';')
        SyntaxError(_T("Expected a ';'"));
    else
        pch += 1;

    return pch;
}


const TCHAR* CClassCompiler::ParseFunction(const TCHAR* pch, CFunction*& pFunction, bool bBehavior)
{
    CFunctionCompiler compiler;
    compiler.m_bBehavior = bBehavior;

    pFunction = NULL;

    pch = SkipWhite(pch);

    if (!bBehavior)
    {
        // ParseParameters

        if (*pch != '(')
        {
            LOCALTRACE(_T("bad function definition: missing (\n"));
            return pch;
        }

        pch += 1;

        for (;;)
        {
            pch = SkipWhite(pch);
            if (*pch == '\0' || *pch == ')')
                break;

            const TCHAR* pchToken;
            int cchToken;
            pch = Token(pch, pchToken, cchToken);

#ifdef _DEBUG_0
            {
                TCHAR chSav = pchToken[cchToken];
                ((TCHAR*)pchToken)[cchToken] = '\0';
                LOCALTRACE(_T("parameter %d \"%s\"\n"), compiler.m_nFrameSize, pchToken);
                ((TCHAR*)pchToken)[cchToken] = chSav;
            }
#endif

            compiler.m_rgstLocal[compiler.m_nFrameSize].pchName = pchToken;
            compiler.m_rgstLocal[compiler.m_nFrameSize].cchName = (short)cchToken;
            compiler.m_nFrameSize += 1;

            pch = SkipWhite(pch);
            if (*pch != ',')
                break;

            pch += 1;
        }

        if (*pch != ')')
        {
            SyntaxError(_T("expected ')'\n"));
            return szParseError;
        }

        pch += 1;

    }

    // ParseStatementBlock
    {
        pch = SkipWhite(pch);

        if (*pch != '{')
        {
            LOCALTRACE(_T("bad function definition: missing {\n"));
            return pch;
        }

        pch = compiler.ParseBlock(pch);
    }

    compiler.Write(opNull);
    LOCALTRACE(_T("%d: opRet\n"), compiler.GetAddress());
    compiler.Write(opRet);

    pFunction = compiler.CreateFunction();

    return pch;
}

const TCHAR* CClassCompiler::ParseClass(const TCHAR* pch)
{
    const TCHAR* pchToken;
    int cchToken;
    pch = Token(pch, pchToken, cchToken);

#ifdef _DEBUG
    {
        TCHAR chSav = pchToken[cchToken];
        ((TCHAR*)pchToken)[cchToken] = '\0';
        TRACE(_T("class %s\n"), pchToken);
        ((TCHAR*)pchToken)[cchToken] = chSav;
    }
#endif

    // TODO: base class? interfaces?

    // Parse Members
    pch = SkipWhite(pch);

    if (*pch != '{')
    {
        SyntaxError(_T("Expected '{'\n"));
        return szParseError;
    }

    pch += 1;

    CClass* pClass = new CClass;
    pch = pClass->ParseClassBody(pch);

    if (*pch != '}')
    {
        SyntaxError(_T("Expected '}'"));
        return szParseError;
    }

    pch += 1;

    // REVIEW: Is the class namespace flat or hierarchical? This assumes flat...
    g_classes->Define(pchToken, cchToken, (CNode*)pClass);

    return pch;
}

void Class_Init()
{
    g_classes = new CNameSpace;
}

void Class_Exit()
{
    delete g_classes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\recovery.cpp ===
////////////////////////////////////////////////////////////////////////////
//

#include "std.h"
#include "xapp.h"
#include "node.h"
#include "runner.h"

////////////////////////////////////////////////////////////////////////////

bool ResetScreenSaver();

extern "C" {
typedef VOID (CALLBACK *PFNRECPROGRESSCALLBACK)(UINT uPercent, ULONG_PTR Context);
ULONG WINAPI DashRecovery(PFNRECPROGRESSCALLBACK pfnCallback, ULONG_PTR Context);
}

////////////////////////////////////////////////////////////////////////////
//
class CRecovery : public CNode
{
    DECLARE_NODE(CRecovery, CNode)

public:
    CRecovery();
    ~CRecovery();
    void StartRecovery();
    void FinishRecovery();
    float m_recoveryProgress;

protected:
    void Advance(float nSeconds);
    DECLARE_NODE_PROPS()
    DECLARE_NODE_FUNCTIONS()

private:
    bool m_done;
    bool m_bRecoverying;
    UINT m_recoveryPercentage;
    UINT m_lastRecoveryPercentage;
    static void CALLBACK RecoveryCallback(UINT percentage, CRecovery* rec);
    static void CALLBACK RecoveryThread(CRecovery* rec);
};

////////////////////////////////////////////////////////////////////////////
//
IMPLEMENT_NODE("Recovery", CRecovery, CNode)

START_NODE_PROPS(CRecovery, CNode)
    NODE_PROP(pt_number, CRecovery, recoveryProgress)
END_NODE_PROPS()

START_NODE_FUN(CRecovery, CNode)
    NODE_FUN_VV(StartRecovery)
    NODE_FUN_VV(FinishRecovery)
END_NODE_FUN()

////////////////////////////////////////////////////////////////////////////

CRecovery::CRecovery() :
    m_done(false),
    m_bRecoverying(false),
    m_recoveryProgress(0.0f),
    m_recoveryPercentage(0),
    m_lastRecoveryPercentage(0)
{
}

CRecovery::~CRecovery()
{
}

void CALLBACK CRecovery::RecoveryThread(CRecovery* rec)
{
    ASSERT(rec);

#ifdef RECOVERY_TESTING
    for (int i=0; i<=10; i++) {
        Sleep(1000);
        RecoveryCallback(i*10, rec);
    }
#else
    DashRecovery((PFNRECPROGRESSCALLBACK)RecoveryCallback, (ULONG_PTR)rec);
#endif

    rec->m_done = true;
}

void CALLBACK CRecovery::RecoveryCallback(UINT percentage, CRecovery* rec)
{
    ASSERT(rec);
    rec->m_recoveryPercentage = percentage;
}

void CRecovery::StartRecovery()
{
    m_done = false;
    m_bRecoverying = true;
    m_lastRecoveryPercentage = m_recoveryPercentage;

    HANDLE hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)RecoveryThread, (LPVOID)this, 0, 0);
    ASSERT(hThread);

    if (hThread) {
        CloseHandle(hThread);
    } else {
        // REVIEW: should we report error to user?
        m_recoveryProgress = 1.0f;
        m_done = true;
    }
}

void CRecovery::FinishRecovery()
{
    HalReturnToFirmware(HalRebootRoutine);
}

void CRecovery::Advance(float nSeconds)
{
    CNode::Advance(nSeconds);

    if (m_bRecoverying) {
        if (m_done) {
            m_bRecoverying = false;
            CallFunction(this, _T("OnRecoveryComplete"));
        } else if (m_lastRecoveryPercentage != m_recoveryPercentage) {
            CallFunction(this, _T("OnRecoveryProgressChanged"));
            m_lastRecoveryPercentage = m_recoveryPercentage;
            m_recoveryProgress = m_recoveryPercentage / 100.0f;
            ResetScreenSaver();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Parser.h ===
class CNodeClass;
class CClass;
class CFunction;

// REVIEW: These should all be in CLexer...
void StartParse(const TCHAR* pch, const TCHAR* szFileName, int nLine = 1);
void EndParse();

enum COMMENT_TYPE
{
	none = 0,
	pound = 1,
	slashslash = 2,
	slashstar = 4,
	any = 0xffffffff
};

const TCHAR* SkipWhite(const TCHAR* pch, COMMENT_TYPE ct = any);
const TCHAR* Token(const TCHAR* pch, const TCHAR*& pchToken, int& cchToken, bool bAllowPaths = false, COMMENT_TYPE ct = any);
extern void SyntaxError(const TCHAR* szMsg, ...);
const TCHAR* ParseBoolean(const TCHAR* pch, bool& b);
const TCHAR* ParseInteger(const TCHAR* pch, int& i);
const TCHAR* ParseNumber(const TCHAR* pch, float& n);
const TCHAR* ParseString(const TCHAR* pch, TCHAR*& sz);
const TCHAR* ParseVec3(const TCHAR* pch, float v[3]);
const TCHAR* ParseVec4(const TCHAR* pch, float v[4]);
const TCHAR* ParseIntArray(const TCHAR* pch, BYTE*& pbArray, int& cbArray);
const TCHAR* ParseVecArray(const TCHAR* pch, BYTE*& pbArray, int& cbArray, int nVecSize);
int ExpandCString(TCHAR* szString, int cchMaxString, const TCHAR* pchToken, int cchToken);


class CParser
{
public:
	CParser(const TCHAR* szFilePath, const TCHAR* pchFile, int cchFile = -1);
	~CParser();

	void SkipWhite();
	bool Token(const TCHAR*& pchToken, int& cchToken, bool bAllowPaths = false);
	void SyntaxError(const TCHAR* szMsg, ...);
	bool AtEnd() const;

	const TCHAR* m_pchFile;
	int m_cchFile;

	const TCHAR* m_szFilePath;

	const TCHAR* m_pch;
	int m_nLine;
};

inline bool CParser::AtEnd() const
{
	return (m_pch >= m_pchFile + m_cchFile);
}



class CCompiler
{
public:
	CCompiler();
	virtual ~CCompiler();

	inline void Write(const void* pv, int cb)
	{
		if (m_nop + cb >= m_opsSize)
			GrowTo(m_nop + cb);
		CopyMemory(&m_ops[m_nop], pv, cb);
		m_nop += cb;
	}

	inline void Write(BYTE b) { Write(&b, 1); }
	inline void WriteInteger(int n) { Write(&n, sizeof (int)); }
	inline void WriteNumber(float n) { Write(&n, sizeof (float)); }
	inline void WriteString(const TCHAR* pch, int cch) { WriteInteger(cch); Write(pch, cch * sizeof (TCHAR)); }

	inline UINT GetAddress() { return m_nop; }

	inline void Fixup(UINT nAddress, UINT nValue)
	{
		ASSERT(nAddress < m_nop);
		CopyMemory(&m_ops[nAddress], &nValue, sizeof (UINT));
	}

	CFunction* CreateFunction();

	void SyntaxError(const TCHAR* szMsg, ...);
	inline void SetError() { m_bError = true; }
	inline bool HadError() const { return m_bError; }

	void GrowTo(int nNewSize);

protected:
	UINT m_nop;
	BYTE* m_ops;
	UINT m_opsSize;
	bool m_bError;
};


struct ST
{
	short cchName;
	const TCHAR* pchName;
};

struct DOPER
{
	TCHAR m_ch1;
	TCHAR m_ch2;
	TCHAR m_ch3;
	TCHAR m_pri;
	BYTE m_op;
};

struct BREAK
{
	BREAK* m_pNext;
	int m_nop;
};

class CFunctionCompiler : public CCompiler
{
public:
	CFunctionCompiler();

	ST m_rgstLocal [100]; // REVIEW: Ack!
	int m_nFrameSize;

	const TCHAR* ParseOperator(const TCHAR* pch, const DOPER*& pdoper);
	const TCHAR* ParseExpression(const TCHAR* pch);
	const TCHAR* ParseStatement(const TCHAR* pch);
	const TCHAR* ParseTerm(const TCHAR* pch);
	const TCHAR* ParseBlock(const TCHAR* pch);
	const TCHAR* ParseLocalVar(const TCHAR* pch);
	const TCHAR* ParseArray(const TCHAR* pch);
	const TCHAR* ParseCall(const TCHAR* pch);
	const TCHAR* ParseExp(const TCHAR* pch, int nPrio);
	const TCHAR* ParseIF(const TCHAR* pch);
	const TCHAR* ParseWHILE(const TCHAR* pch);
	const TCHAR* ParseFOR(const TCHAR* pch);
	const TCHAR* ParseDO(const TCHAR* pch);
	const TCHAR* ParseBREAK(const TCHAR* pch);
	const TCHAR* ParseCONTINUE(const TCHAR* pch);
	const TCHAR* ParseRETURN(const TCHAR* pch);
	const TCHAR* ParseSLEEP(const TCHAR* pch);

	void FixupBreaks();
	BREAK* m_pBreak;
	int m_nBreakables;
	int m_nopTopOfLoop;
	bool m_bBehavior;
};

class CClassCompiler : public CCompiler
{
public:
	CClassCompiler(CClass* pClass);

	const TCHAR* Compile(const TCHAR* pch);

protected:
	const TCHAR* ParseNode(const TCHAR* pch);
	const TCHAR* ParseProps(const TCHAR* pch, CNodeClass* pNodeClass);
	const TCHAR* ParseChildren(const TCHAR* pch);
	const TCHAR* ParseMemberVar(const TCHAR* pch);
	const TCHAR* ParseClass(const TCHAR* pch);
	const TCHAR* ParseFunction(const TCHAR* pch, CFunction*& pFunction, bool bBehavior = false);

	CClass* m_pClass;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Runner.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"
#include "Camera.h"
#include "Parser.h"

#include "..\..\ntos\inc\xlaunch.h"

//#define LOCALTRACE TRACE
#define LOCALTRACE 1 ? (void)0 : ::Trace

CObject* LookupMember(CObject* pThis, const TCHAR* pchName, int cchName);

CObject* g_pThis;
CRunner* g_pRunner;

extern bool g_bInputEnable;

class CVec3Object : public CObject
{
    DECLARE_NODE(CVec3Object, CObject)
public:
    CVec3Object();
    CVec3Object(const D3DXVECTOR3& v);
    CStrObject* ToStr();

    float m_x, m_y, m_z;

    DECLARE_NODE_PROPS()
};

bool ExecuteScript(CObject* pObject, const TCHAR* szScript)
{
    CFunctionCompiler compiler;
    compiler.ParseBlock(szScript);
    if (compiler.HadError())
        return false;

    compiler.Write(opRet);
    CFunction* pFunction = compiler.CreateFunction();

    CRunner runner(pObject);
    runner.SetFunc(pFunction);
    runner.Run();

    delete pFunction;

    return true;
}

bool CallFunction(CObject* pObject, const TCHAR* szFunc, int nParam, CObject** rgParam)
{
    g_pThis = pObject;
    CRunner runner(pObject);
    if (!runner.SetFunc(szFunc))
        return false;

    for (int i = 0; i < nParam; i += 1)
        runner.Push(rgParam[i]);

    runner.Run();
    return true;
}

CObject* Dereference(CObject* pObject)
{
    CObject* pLastObject = pObject;

    while (pObject != NULL)
    {
        pObject = pLastObject->Deref();
        if (pObject == pLastObject)
            break;

        pLastObject = pObject;
    }

    return pObject;
}

////////////////////////////////////////////////////////////////////////////

class CLocalVariable : public CObject
{
public:
    CLocalVariable();
    ~CLocalVariable();

    CObject* Deref();
    void Assign(CObject* pObject);

    CObject* m_pValue;
};

CLocalVariable::CLocalVariable()
{
    m_pValue = NULL;
}

CLocalVariable::~CLocalVariable()
{
    if (m_pValue != NULL)
        m_pValue->Release();
}

void CLocalVariable::Assign(CObject* pObject)
{
    if (m_pValue != NULL)
        m_pValue->Release();

    m_pValue = pObject;

    if (m_pValue != NULL)
        m_pValue->AddRef();
}

CObject* CLocalVariable::Deref()
{
    CObject* pObject = m_pValue;

    if (pObject != NULL)
        pObject->AddRef();

    Release();

    return pObject;
}

////////////////////////////////////////////////////////////////////////////

CRunner::CRunner(CObject* pObject)
{
    ASSERT(pObject != NULL);

    m_nop = 0;
    m_ops = NULL;
    m_sp = 0;
    m_spBase = 0;
    m_spFrame = 0;
    m_pSelf = pObject;
    m_pThis = pObject;
    m_bError = false;
    m_pNextContext = NULL;
    m_wakeup = 0.0f;

    ZeroMemory(m_stack, sizeof (m_stack));

#if defined(_DEBUG)
//  _CrtMemCheckpoint(&m_memState);
#endif
}

CRunner::~CRunner()
{
    ResetFunc();
}

bool CRunner::SetFunc(const TCHAR* szFunc)
{
    ResetFunc();

    m_ops = LookupFunction(szFunc, _tcslen(szFunc), m_pThis);
    return m_ops != NULL;
}

void CRunner::ResetFunc()
{
    while (m_sp > 0)
    {
        m_sp -= 1;
        CObject* pObj = m_stack[m_sp];
        m_stack[m_sp] = NULL;
        if (pObj != NULL)
            pObj->Release();
    }

    m_bError = false;
    m_nop = 0;
    m_sp = 0;
    m_spFrame = 0;
    m_wakeup = 0.0f;

#if defined(_DEBUG)
//  _CrtMemDumpAllObjectsSince(&m_memState);
//  _CrtMemCheckpoint(&m_memState);
#endif
}

// REVIEW: Inline Push and Pop...

void CRunner::Push(float nValue)
{
    CNumObject* pObj = new CNumObject(nValue);
    Push(pObj);
}

void CRunner::Push(int nValue)
{
    CNumObject* pObj = new CNumObject((float)nValue);
    Push(pObj);
}

void CRunner::Push(const TCHAR* szValue, int nLen /*=-1*/)
{
    if (nLen == -1)
        nLen = _tcslen(szValue);

    CStrObject* pObj = new CStrObject(szValue, nLen);
    Push(pObj);
}

void CRunner::Push(CObject* pObject)
{
    m_stack[m_sp] = pObject;
    m_sp += 1;
    ASSERT(m_sp < sizeof (m_stack) / sizeof (CObject*));
}

CObject* CRunner::Pop()
{
    ASSERT(m_sp > 0);
    m_sp -= 1;

    CObject* pObject = m_stack[m_sp];
    m_stack[m_sp] = NULL;

    return pObject;
}



CClass* LookupClass(const TCHAR* pchName, int cchName)
{
    extern CNameSpace* g_classes;

    CObject* pObject = g_classes->Lookup(pchName, cchName);
    if (pObject == NULL || pObject->m_obj != objClass)
        return NULL;

    return (CClass*)pObject;
}


CObject** g_rgParam;
int g_nParam;

CObject* CreateNewObject(const TCHAR* pchClassName, int cchClassName, CObject** rgparam = NULL, int nParam = 0)
{
    g_rgParam = rgparam;
    g_nParam = nParam;

    // BLOCK: Look for class...
    {
        CClass* pClass = LookupClass(pchClassName, cchClassName);
        if (pClass != NULL)
            return pClass->CreateNode();
    }

    // BLOCK: Try a built-in node...
    {
        CObject* pNode = NewNode(pchClassName, cchClassName);
        if (pNode != NULL)
            return pNode;
    }

    return NULL;
}

void CRunner::SetFunc(CFunction* pFunction)
{
    ResetFunc();

    m_nop = 0;
    m_sp = 0;
    m_spFrame = 0;
    m_ops = pFunction->m_rgop;
    m_nLine = 0;
    m_wakeup = 0.0f;
}

void CRunner::Error(const TCHAR* szFmt, ...)
{
    if (m_bError)
        return;

    va_list args;
    va_start(args, szFmt);

    TCHAR szBuffer [512];
    _vsntprintf(szBuffer, countof (szBuffer), szFmt, args);

    TCHAR szMessage [1024];
    if (m_nLine == 0)
        _stprintf(szMessage, _T("Runtime Error\n\n%s"), szBuffer);
    else
        _stprintf(szMessage, _T("Runtime Error\n\nLine: %d\n\n%s"), m_nLine, szBuffer);

    Trace(_T("\001\007%s\n"), szMessage);

#ifdef _DEBUG
    DumpStack();
#endif

#ifdef _WINDOWS
    XAppMessageBox(szMessage);
#endif

    va_end(args);

    m_bError = true;
}

void CRunner::PushContext(UINT nParam)
{
    RUNCONTEXT* pContext = new RUNCONTEXT;

    pContext->m_ops = m_ops;
    pContext->m_nop = m_nop;
    pContext->m_spFrame = m_spFrame;
    pContext->m_pSelf = m_pSelf;
    pContext->m_pThis = m_pThis;
    pContext->m_sp = m_sp - (nParam + 1);

    pContext->m_pNextContext = m_pNextContext;
    m_pNextContext = pContext;
}

void CRunner::PopContext()
{
    RUNCONTEXT* pContext = m_pNextContext;
    ASSERT(pContext != NULL);

    CObject* pRetObject = Dereference(Pop());

    m_ops = pContext->m_ops;
    m_nop = pContext->m_nop;
    m_spFrame = pContext->m_spFrame;
    m_pSelf = pContext->m_pSelf;
    m_pThis = pContext->m_pThis;
    g_pThis = m_pThis;

    for (UINT i = pContext->m_sp; i < m_sp; i += 1)
    {
        if (m_stack[i] != NULL)
        {
            m_stack[i]->Release();
            m_stack[i] = NULL;
        }
    }

    m_sp = pContext->m_sp;

    m_pNextContext = pContext->m_pNextContext;
    delete pContext;

    Push(pRetObject);
}

CObject* CRunner::Run()
{
    m_spBase = m_sp;

    for (;;)
    {
        if (m_bError)
            return NULL;

#ifdef _DEBUG
        // Make sure everything on the stack has been cleaned up!
        {
            for (UINT i = 0; i < 20; i += 1)
                ASSERT(m_stack[m_sp + i] == NULL);
        }
#endif
        CObject* pRetObj = NULL;
        if (!Step(&pRetObj))
            return pRetObj;
    }
}

bool CRunner::Step(CObject** ppRetObj/*=NULL*/)
{
    g_pRunner = this;

    BYTE op = m_ops[m_nop++];
    switch (op)
    {
    default:
        ASSERT(FALSE); // Lost in space!
        return NULL;

    case opSleep:
        {
            CObject* pObj = Dereference(Pop());
            if (pObj == NULL)
            {
                Error(_T("illegal null reference"));
                return false;
            }

            if (pObj->m_obj != objNumber)
            {
                Error(_T("expected a number"));
                return false;
            }

            m_wakeup = XAppGetNow() + ((CNumObject*)pObj)->m_nValue;
            pObj->Release();
            return true;
        }
        break;

    case opStatement:
        {
            m_nLine = FetchInt();
            LOCALTRACE(_T("opStatement: line %d, sp %d\n"), m_nLine, m_sp);
        }
        break;

    case opDrop:
        {
            LOCALTRACE(_T("opDrop\n"));
            CObject* pObject = Pop();
            if (pObject != NULL)
                pObject->Release();
        }
        break;

    case opFrame:
        {
            int nFrameSize = FetchInt();
            LOCALTRACE(_T("opFrame: %d\n"), nFrameSize);

#ifdef _DEBUG
            // Make sure everything on the stack has been cleaned up!
            {
                for (UINT i = m_sp; i < m_sp + nFrameSize; i += 1)
                    ASSERT(m_stack[i] == NULL);
            }
#endif
//          ZeroMemory(&m_stack[m_sp], sizeof (CObject*) * nFrameSize); // REVIEW: Not necessary!
            m_sp += nFrameSize;
            m_spBase = m_sp;
            ASSERT(m_sp < sizeof (m_stack) / sizeof (CObject*));
        }
        break;

    case opEndFrame:
        {
            int nFrameSize = FetchInt();
            LOCALTRACE(_T("opEndFrame: %d\n"), nFrameSize);

            // Remove parameters from the stack...
            while (nFrameSize-- > 0)
            {
                m_sp -= 1;
                if (m_stack[m_sp] != NULL)
                {
                    m_stack[m_sp]->Release();
                    m_stack[m_sp] = NULL;
                }
            }

            m_spBase = m_sp;
        }
        break;

    case opNull:
        {
            Push((CObject*)NULL);
        }
        break;

    case opThis:
        {
            ASSERT(m_pSelf != NULL);
            m_pSelf->AddRef();
            Push(m_pSelf);
        }
        break;

    case opNew: // New: nParam cchClass rgchClass
        {
            LOCALTRACE(_T("opNew\n"));

            int nParam = FetchInt();
            int cch;
            const TCHAR* pch = FetchString(cch);
            CObject** rgparam = &m_stack[m_sp - nParam];

            CObject* pObj = CreateNewObject(pch, cch, rgparam, nParam);

            if (pObj == NULL)
            {
                TCHAR szBuf [256];
                if (cch > 255)
                    cch = 255;
                CopyChars(szBuf, pch, cch);
                szBuf[cch] = '\0';
                Error(_T("Failed to create new object: \"%s\""), szBuf);
                return NULL;
            }

            // Remove parameters from the stack...
            for (int i = 0; i < nParam; i += 1)
            {
                CObject* pObj = rgparam[i];
                if (pObj != NULL)
                {
                    pObj->Release();
                    rgparam[i] = NULL;
                }
            }

            m_sp -= nParam;

            Push(pObj);
        }
        break;

    case opAssign:
        {
            LOCALTRACE(_T("opAssign\n"));

            CObject* pObjRight = Dereference(Pop());
            CObject* pObjLeft = Pop();

            if (pObjLeft == NULL)
            {
                Error(_T("cannot assign to null"));
                return NULL;
            }

            pObjLeft->Assign(pObjRight);
            pObjLeft->Release();

            // Keep the value on the stack...
            Push(pObjRight);
        }
        break;

    case opDot:
    case opArray:
        {
            LOCALTRACE(_T("%d %s: \"%s\"\n"), m_nop - 1, op == opDot ? "opDot" : "opArray");

            CObject* pObjRight = Pop();
            CObject* pObjLeft = Pop();

            if (pObjRight == NULL || pObjLeft == NULL)
            {
                Error(_T("illegal null reference"));
                return NULL;
            }

            if (op == opArray)
                pObjRight = Dereference(pObjRight);

            ASSERT(pObjRight->m_obj == objVariable || pObjRight->m_obj == objNumber || pObjRight->m_obj == objString);

            CObject* pRealLeft = pObjLeft->Deref();
            if (pRealLeft == NULL)
            {
                Error(_T("illegal null reference"));
                return NULL;
            }

            CObject* pDot = pRealLeft->Dot(pObjRight);

            if (pDot == NULL)
            {
                if (pObjRight->m_obj == objVariable)
                {
                    CVarObject* pVar = (CVarObject*)pObjRight;
                    Error(_T("Unknown member: %s"), pVar->m_sz);
                }
                else
                {
                    CStrObject* pStr = pObjRight->ToStr();
                    Error(_T("Unknown member: %s"), pStr->GetSz());
                    pStr->Release();
                }
            }

            Push(pDot);

            pRealLeft->Release();
            pObjRight->Release();
        }
        break;

    case opNeg:
        {
            CObject* pObj = Dereference(Pop());
            if (pObj == NULL || pObj->m_obj != objNumber)
            {
                Error(_T("expected a number"));
                return NULL;
            }

            Push(-((CNumObject*)pObj)->m_nValue);
            pObj->Release();
        }
        break;

    case opAdd:
    case opSub:
    case opMul:
    case opDiv:
    case opMod:
    case opEQ:
    case opNE:
    case opLT:
    case opLE:
    case opGT:
    case opGE:
    case opAnd:
    case opXor:
    case opOr:
    case opSHL:
    case opSHR:
        if (!BinaryOperator(op))
            return NULL;
        break;

    case opCall:
        {
            LOCALTRACE(_T("opCall sp=%d\n"), m_sp);

            CObject* pRetObj = NULL;;
            int nParam = m_ops[m_nop++];
            ASSERT(m_sp >= (UINT)(nParam + 1));
            CObject* pFun = (CVarObject*)m_stack[m_sp - (nParam + 1)];
            CObject** rgparam = &m_stack[m_sp - nParam];

            if (pFun->m_obj == objFunctionRef)
            {
                // This is a member of a built-in class...

                m_stack[m_sp - (nParam + 1)] = NULL;

                CFunctionObject* pFunction = (CFunctionObject*)pFun;
                pRetObj = pFunction->Call(rgparam, nParam);
                pFun->Release();

                for (int i = 0; i < nParam; i += 1)
                {
                    CObject* pObj = rgparam[i];
                    if (pObj != NULL)
                    {
                        pObj->Release();
                        rgparam[i] = NULL;
                    }
                }

                m_sp -= nParam + 1;
                LOCALTRACE(_T("opCall(done) sp=%d\n"), m_sp);

                Push(pRetObj);
            }
            else if (pFun->m_obj == objMemberFunction)
            {
                // This is a member of a scripted class and the script specified the object in the call...

                CMemberFunctionObject* pFunction = (CMemberFunctionObject*)pFun;
                pFunction->AddRef();

#ifdef _DEBUG
                LOCALTRACE(_T("Call2 %s\n"), pFunction->m_pFunction->m_szName);
#endif
                PushContext(nParam);

                m_spFrame = m_sp - nParam;

                ASSERT(pFunction->m_pObject != NULL);
                m_pSelf = pFunction->m_pObject;

                m_ops = pFunction->m_pFunction->m_rgop;
                m_nop = 0;
            }
            else
            {
                CVarObject* pFunction = (CVarObject*)pFun;
                int cch = pFunction->m_nLength;
                const TCHAR* pch = pFunction->m_sz;

                if (ExecuteBuiltIn(pch, cch, nParam, rgparam, pRetObj))
                {
                    // This was an intrinsic...

                    for (int i = 0; i < nParam; i += 1)
                        rgparam[i] = NULL;
                    m_sp -= nParam + 1;
                    Push(pRetObj);
                    pFun->Release();
                }
                else
                {
                    // This is an unqualified member of a scripted class...

                    CObject* pThis;
                    BYTE* pop = LookupFunction(pch, cch, pThis);
                    if (pop == NULL)
                    {
                        TCHAR szFunc [32];
                        if (cch > countof(szFunc) - 1)
                            cch = countof(szFunc) - 1;
                        _tcsncpy(szFunc, pch, cch);
                        szFunc[cch] = 0;
                        Error(_T("unknown function: %s"), szFunc);
                        return NULL;
                    }

                    PushContext(nParam);

                    m_pSelf = pThis;
                    g_pThis = pThis;

                    m_spFrame = m_sp - nParam;
                    m_ops = pop;
                    m_nop = 0;
                }
            }
        }
        break;

    case opRet:
        if (m_pNextContext != NULL)
        {
            PopContext();
        }
        else
        {
            if (ppRetObj != NULL)
                *ppRetObj = m_sp > 0 ? Pop() : NULL;
            return false;
        }
        break;

    case opCond:
        {
            LOCALTRACE(_T("opCond\n"));
            bool bCond = false;
            CObject* pObj = Dereference(Pop());

            if (pObj != NULL)
            {
                CNumObject* pNum = pObj->ToNum();
                if (pNum->m_nValue != 0.0f)
                    bCond = true;

                pNum->Release();
                pObj->Release();
            }

            if (bCond)
                m_nop += sizeof (UINT);
            else
                m_nop = FetchUInt();
        }
        break;

    case opJump:
        LOCALTRACE(_T("opJump\n"));
        m_nop = FetchUInt();
        break;

    case opVar:
        {
            LOCALTRACE(_T("opVar\n"));
            int cch;
            const TCHAR* pch = FetchString(cch);

#ifdef _DEBUG
            {
                TCHAR szBuf [256];
                CopyChars(szBuf, pch, cch);
                szBuf[cch] = '\0';
                LOCALTRACE(_T("opVar: \"%s\"\n"), szBuf);
            }
#endif

            CVarObject* pObj = new CVarObject(pch, cch);
            Push(pObj);
        }
        break;

    case opLocal:
        {
            LOCALTRACE(_T("opLocal\n"));

            int nLocal = FetchInt();

            ASSERT(m_spFrame + nLocal < m_sp);
            CObject* pObject = m_stack[m_spFrame + nLocal];
            if (pObject == NULL)
            {
                pObject = new CLocalVariable;
                m_stack[m_spFrame + nLocal] = pObject;
            }

            pObject->AddRef();
            Push(pObject);
        }
        break;

    case opStr:
        {
            int cch;
            const TCHAR* pch = FetchString(cch);
            Push(pch, cch);
        }
        break;

    case opNum:
        {
            float n = FetchFloat();
            Push(n);
        }
        break;
    }

    return true;
}


bool CRunner::BinaryOperator(BYTE op)
{
    LOCALTRACE(_T("opOperator: %d\n"), op);

    CObject* pObjRight = Dereference(Pop());
    CObject* pObjLeft = Dereference(Pop());

    if (pObjLeft == NULL || pObjRight == NULL || pObjLeft->m_obj == objNode && pObjRight->m_obj == objNode)
    {
        float fValue;

        switch (op)
        {
        default:
            Error(_T("illegal null reference"));
            return false;

        case opEQ:
            fValue = (pObjLeft == pObjRight) ? 1.0f : 0.0f;
            Push(fValue);
            break;

        case opNE:
            fValue = (pObjLeft != pObjRight) ? 1.0f : 0.0f;
            Push(fValue);
            break;
        }

        if (pObjRight != NULL)
            pObjRight->Release();

        if (pObjLeft != NULL)
            pObjLeft->Release();

        return true;
    }

    if (op != opAdd && pObjLeft->m_obj == objString && pObjRight->m_obj == objString)
    {
        const TCHAR* szLeft = ((CStrObject*)pObjLeft)->GetSz();
        const TCHAR* szRight = ((CStrObject*)pObjRight)->GetSz();
        int nCompare = _tcscmp(szLeft, szRight);
        bool bValue;

        switch (op)
        {
        default:
            Error(_T("type mismatch"));
            return false;

        case opEQ:
            bValue = nCompare == 0;
            break;

        case opNE:
            bValue = nCompare != 0;
            break;

        case opLT:
            bValue = nCompare < 0;
            break;

        case opLE:
            bValue = nCompare <= 0;
            break;

        case opGT:
            bValue = nCompare > 0;
            break;

        case opGE:
            bValue = nCompare >= 0;
            break;
        }

        Push(bValue);
    }
    else if (pObjLeft->m_obj == objNumber && pObjRight->m_obj == objNumber)
    {
        float fLeft = ((CNumObject*)pObjLeft)->m_nValue;
        float fRight = ((CNumObject*)pObjRight)->m_nValue;
        float fValue;

#ifdef _DEBUG
        double intptr;
#endif

        switch (op)
        {
        case opEQ:
            fValue = (fLeft == fRight) ? 1.0f : 0.0f;
            break;

        case opNE:
            fValue = (fLeft != fRight) ? 1.0f : 0.0f;
            break;

        case opLT:
            fValue = (fLeft < fRight) ? 1.0f : 0.0f;
            break;

        case opLE:
            fValue = (fLeft <= fRight) ? 1.0f : 0.0f;
            break;

        case opGT:
            fValue = (fLeft > fRight) ? 1.0f : 0.0f;
            break;

        case opGE:
            fValue = (fLeft >= fRight) ? 1.0f : 0.0f;
            break;

        case opAdd:
            fValue = fLeft + fRight;
            break;

        case opSub:
            fValue = fLeft - fRight;
            break;

        case opMul:
            fValue = fLeft * fRight;
            break;

        case opDiv:
            fValue = fLeft / fRight;
            break;

        // REVIEW: need to be more clever about this later

        case opAnd:
#ifdef _DEBUG
            if (modf(fLeft, &intptr) != 0 || modf(fRight, &intptr) != 0)
            {
                Error(_T("type mismatch"));
                return false;
            }
#endif
            fValue = (float)((ULONG)fLeft & (ULONG)fRight);
            break;

        case opXor:
#ifdef _DEBUG
            if (modf(fLeft, &intptr) != 0 || modf(fRight, &intptr) != 0)
            {
                Error(_T("type mismatch"));
                return false;
            }
#endif
            fValue = (float)((ULONG)fLeft ^ (ULONG)fRight);
            break;

        case opOr:
#ifdef _DEBUG
            if (modf(fLeft, &intptr) != 0 || modf(fRight, &intptr) != 0)
            {
                Error(_T("type mismatch"));
                return false;
            }
#endif
            fValue = (float)((ULONG)fLeft | (ULONG)fRight);
            break;

        case opSHL:
            fValue = (float)((ULONG)fLeft << (ULONG)fRight);
            break;

        case opSHR:
            fValue = (float)((ULONG)fLeft >> (ULONG)fRight);
            break;
        }

        Push(fValue);
    }
    else if (op == opAdd)
    {
        // Add strings...
        CStrObject* pStrLeft = pObjLeft->ToStr();
        CStrObject* pStrRight = pObjRight->ToStr();

        CStrObject* pNewStr = pStrLeft->concat(pStrRight->GetSz());

        Push(pNewStr);

        pStrLeft->Release();
        pStrRight->Release();
    }
    else
    {
        // TODO: More should be legal!
        Error(_T("type mismatch error"));
        return false;
    }

    pObjLeft->Release();
    pObjRight->Release();

    return true;
}


BOOL CRunner::ExecuteBuiltIn(const TCHAR* pchName, int cchName, int nParam, CObject** rgParam, CObject*& pRetObj)
{
    pRetObj = NULL;

    if (cchName == 11 && _tcsncmp(pchName, _T("EnableInput"), cchName) == 0)
    {
        if (nParam == 1)
        {
            CObject* pObj = Dereference(rgParam[0]);
            CNumObject* pNum = pObj->ToNum();
            g_bInputEnable = (bool)(pNum->m_nValue != 0.0f);
        }
        else
        {
            Error(_T("Invalid parameter"));
        }

        return TRUE;
    }

    if (cchName == 4 && _tcsncmp(pchName, _T("eval"), cchName) == 0)
    {
        if (nParam == 1)
        {
            CObject* pObject = Dereference(rgParam[0]);
            CStrObject* pStr = pObject->ToStr();
            ExecuteScript(m_pSelf, pStr->GetSz());
            pStr->Release();
            pObject->Release();
        }
        else
        {
            Error(_T("Bad launch"));
        }

        return TRUE;
    }

    if (cchName == 6 && _tcsncmp(pchName, _T("launch"), cchName) == 0)
    {
        if (nParam == 1 || nParam == 2)
        {
            CObject* pObject1 = Dereference(rgParam[0]);
            CStrObject* pStr1 = pObject1->ToStr();
            const TCHAR* sz1 = pStr1->GetSz();

            TCHAR sz2 [MAX_PATH];
            if (nParam == 2)
            {
                CObject* pObject2 = Dereference(rgParam[1]);
                CStrObject* pStr2 = pObject2->ToStr();
                _tcscpy(sz2, pStr2->GetSz());
                pStr2->Release();
                pObject2->Release();
            }
            else
            {
                _tcscpy(sz2, sz1);
                TCHAR* pch = _tcsrchr(sz2, '/');
                if (pch != NULL)
                    *pch = '\\';
                pch = _tcsrchr(sz2, '\\');
                ASSERT(pch != NULL);

                *pch = 0;
            }

            TRACE(_T("Launch title: %s, %s\n"), sz1, sz2);

#if defined(_XBOX)
            FSCHAR ssz1 [MAX_PATH];
            FSCHAR ssz2 [MAX_PATH];
            CleanFilePath(ssz1, sz1);
            CleanFilePath(ssz2, sz2);

            XWriteTitleInfoAndReboot(ssz1, ssz2, LDT_NONE, 0, NULL);
#else
#endif
            pStr1->Release();
            pObject1->Release();
        }
        else
        {
            Error(_T("Bad launch"));
        }

        return TRUE;
    }

    if (cchName == 10 && _tcsncmp(pchName, _T("DebugBreak"), cchName) == 0)
    {
#ifdef _DEBUG
        _CrtDbgBreak();
#endif
        return TRUE;
    }

    if (cchName == 5 && _tcsncmp(pchName, _T("alert"), cchName) == 0)
    {
        if (nParam == 1)
        {
            CObject* pObject = Dereference(rgParam[0]);
            CStrObject* pStr = pObject->ToStr();
            Alert(_T("%s"), pStr->GetSz());
            pStr->Release();
            pObject->Release();
        }
        else
        {
            Error(_T("Bad alert"));
        }

        return TRUE;
    }

    if (cchName == 3 && _tcsncmp(pchName, _T("log"), cchName) == 0)
    {
        if (nParam == 1)
        {
            CObject* pObject = Dereference(rgParam[0]);
            CStrObject* pStr = pObject->ToStr();
            TRACE(_T("%s\n"), pStr->GetSz());
            pStr->Release();
            pObject->Release();
        }
        else
        {
            Error(_T("Bad log!"));
        }

        return TRUE;
    }

    return FALSE;
}

BYTE* CRunner::LookupFunction(const TCHAR* pchName, int cchName, CObject*& pOwner)
{
    pOwner = m_pSelf;

    {
        CFunction* pFunction = m_pSelf->FindMemberFunction(pchName, cchName);
        if (pFunction != NULL)
            return pFunction->m_rgop;
    }
/*
    // BLOCK: Try for an instance function...
    {
        CFunction* pFunction = (CFunction*)m_pSelf->GetMember(pchName, cchName);
        if (pFunction != NULL && pFunction->m_obj == objFunction)
            return pFunction->m_rgop;
    }

    // BLOCK: Try for a class member (all the way up through the base classes...
    {
        CFunction* pFunction = (CFunction*)FindMember(m_pSelf->GetNodeClass(), pchName, cchName);
        if (pFunction != NULL && pFunction->m_obj == objFunction)
            return pFunction->m_rgop;
    }
*/

    // BLOCK: Try the parent's of the object...
    {
        for (CObject* pObject = m_pSelf->m_pParent; pObject != NULL; pObject = pObject->m_pParent)
        {
            CObject* pObj = LookupMember(pObject, pchName, cchName);
            if (pObj != NULL)
            {
                pOwner = pObject;
                if (pObj->m_obj == objFunction)
                    return ((CFunction*)pObj)->m_rgop;

                ASSERT(FALSE);
                return (BYTE*)pObj;
            }
        }
    }

    pOwner = NULL;
    return NULL;
}

CObject* CRunner::LookupVariable(const TCHAR* pchName, int cchName)
{
    CObject* pObject = LookupMember(m_pSelf, pchName, cchName);
    if (pObject != NULL || m_pSelf == m_pThis)
        return pObject;

    return LookupMember(m_pThis, pchName, cchName);
}

#ifdef _DEBUG
void CRunner::DumpStack()
{
    TRACE(_T("\nStack Trace\n{\n"));

    TRACE(_T("ops: 0x%08x\n"), m_ops);
    TRACE(_T("nop: %d\n"), m_nop);
    TRACE(_T("spFrame: %d\n"), m_spFrame);
    TRACE(_T("sp: %d\n"), m_sp);
    TRACE(_T("self:\n")); m_pSelf->Dump();
    TRACE(_T("this:\n")); m_pThis->Dump();

    for (RUNCONTEXT* pContext = m_pNextContext; pContext != NULL; pContext = pContext->m_pNextContext)
    {
        TRACE(_T("{\nContext: 0x%08x\n"), pContext);

        TRACE(_T("ops: 0x%08x\n"), pContext->m_ops);
        TRACE(_T("nop: %d\n"), pContext->m_nop);
        TRACE(_T("spFrame: %d\n"), pContext->m_spFrame);
        TRACE(_T("sp: %d\n"), pContext->m_sp);
        TRACE(_T("self:\n")); pContext->m_pSelf->Dump();
        TRACE(_T("this:\n")); pContext->m_pThis->Dump();

        TRACE(_T("}\n"));
    }

    TRACE(_T("}\n"));
}
#endif


////////////////////////////////////////////////////////////////////////////




CProperty::CProperty(CObject* pNode, const PRD* pprd)
{
    m_pNode = pNode;
    m_pprd = pprd;

    pNode->AddRef();
}

CProperty::~CProperty()
{
    m_pNode->Release();
}

CObject* CProperty::Deref()
{
    void* pvValue = (BYTE*)m_pNode + (int)m_pprd->pbOffset;

    switch (m_pprd->nType)
    {
    case pt_string:
        {
            CStrObject* pStr =  new CStrObject(*(TCHAR**)pvValue);
            Release();
            return pStr;
        }

    case pt_number:
        {
            float n = *(float*)pvValue;
            Release();
            return new CNumObject(n);
        }

    case pt_integer:
        {
            int n = *(int*)pvValue;
            Release();
            return new CNumObject((float)n);
        }

    case pt_boolean:
        {
            bool n = *(bool*)pvValue;
            Release();
            return new CNumObject((float)n);
        }

    case pt_node:
        {
            CNode* pNode = *(CNode**)pvValue;
            if (pNode != NULL)
                pNode->AddRef();
            Release();
            return pNode;
        }

    case pt_vec3:
        {
            D3DXVECTOR3 v = *(D3DXVECTOR3*)pvValue;
            Release();
            return new CVec3Object(v);
        }

    case pt_nodearray:
    case pt_children:
        {
            CNodeArrayObject* pRet = new CNodeArrayObject((CNodeArray*)pvValue);
            Release();
            return pRet;
        }
    }

    g_pRunner->Error(_T("Unknown property type"));

    return NULL;
}

void CProperty::Assign(CObject* pObject)
{
    if (pObject == NULL && m_pprd->nType != pt_node)
    {
        g_pRunner->Error(_T("Illegal null assignement"));
        return;
    }

    switch (m_pprd->nType)
    {
    case pt_string:
        {
            CStrObject* pStrObject = pObject->Deref()->ToStr();

            const TCHAR* sz = pStrObject->GetSz();
            m_pNode->SetProperty(m_pprd, &sz, pStrObject->GetLength());
            pStrObject->Release();
        }
        break;

    case pt_number:
        {
            CNumObject* pNumObject = pObject->Deref()->ToNum();

            m_pNode->SetProperty(m_pprd, &pNumObject->m_nValue, sizeof (float));
            pNumObject->Release();
        }
        break;

    case pt_integer:
        {
            CNumObject* pNumObject = pObject->Deref()->ToNum();

            int n = (int)pNumObject->m_nValue;
            m_pNode->SetProperty(m_pprd, &n, sizeof (int));
            pNumObject->Release();
        }
        break;

    case pt_boolean:
        {
            CNumObject* pNumObject = pObject->Deref()->ToNum();

            bool b = pNumObject->m_nValue != 0.0f;
            m_pNode->SetProperty(m_pprd, &b, sizeof (bool));
            pNumObject->Release();
        }
        break;

    case pt_vec3:
        {
            CVec3Object* pVec3Object = (CVec3Object*)pObject->Deref();
            if (pVec3Object->m_obj != objVec3)
                TRACE(_T("\001Expected a Vector3 object!\n"));
            else
                m_pNode->SetProperty(m_pprd, &pVec3Object->m_x, sizeof (float) * 3);
//          pVec3Object->Release();
        }
        break;

    case pt_node:
        {
            CNode* pNode = NULL;
            if (pObject != NULL)
                pNode = (CNode*)pObject->Deref();
            m_pNode->SetProperty(m_pprd, &pNode, sizeof (CNode*));
        }
        break;
    }
}

CObject* CNode::Dot(CObject* pObj)
{
    return CObject::Dot(pObj);
}

CStrObject* CNode::ToStr()
{
    return new CStrObject(GetNodeClass()->m_szClassName);
}


////////////////////////////////////////////////////////////////////////////


CNumObject::CNumObject()
{
    m_obj = objNumber;
    m_nValue = 0.0f;
}

CNumObject::CNumObject(float nValue)
{
    m_obj = objNumber;
    m_nValue = nValue;
}

CNumObject::CNumObject(const TCHAR* szValue)
{
    m_obj = objNumber;
    m_nValue = (float)_tcstod(szValue, NULL);
}

CStrObject* CNumObject::ToStr()
{
    TCHAR szBuf [20];
    TCHAR* pch = szBuf + _stprintf(szBuf, _T("%f"), m_nValue) - 1;
    while (*pch == '0')
        pch -= 1;
    if (*pch == '.')
        pch -= 1;
    pch += 1;
    *pch = '\0';
    return new CStrObject(szBuf);
}


////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("Vector3", CVec3Object, CObject)

START_NODE_PROPS(CVec3Object, CObject)
    NODE_PROP(pt_number, CVec3Object, x)
    NODE_PROP(pt_number, CVec3Object, y)
    NODE_PROP(pt_number, CVec3Object, z)
END_NODE_PROPS()

CVec3Object::CVec3Object()
{
    m_obj = objVec3;
    m_x = 0.0f;
    m_y = 0.0f;
    m_z = 0.0f;
}

CVec3Object::CVec3Object(const D3DXVECTOR3& v)
{
    m_obj = objVec3;
    m_x = v.x;
    m_y = v.y;
    m_z = v.z;
}

CStrObject* CVec3Object::ToStr()
{
    TCHAR szBuf [60];
    _stprintf(szBuf, _T("%f %f %f"), m_x, m_y, m_z);
    return new CStrObject(szBuf);
}


////////////////////////////////////////////////////////////////////////////


CNodeArrayObject::CNodeArrayObject(CNodeArray* pNodeArray)
{
    m_obj = objNodeArray;
    m_pNodeArray = pNodeArray;
}


CObject* CNodeArrayObject::Call(int nFunction, CObject** rgparam, int nParam)
{
    switch (nFunction)
    {
    case 0:
        {
            int n = m_pNodeArray->GetLength();
            return new CNumObject((float)n);
        }
        break;

    case 1:
        {
            CObject* pObj = rgparam[0]->Deref();
            pObj->AddRef();
            m_pNodeArray->AddNode((CNode*)pObj);
        }
        break;

    case 2:
        {
            CObject* pObj = rgparam[0]->Deref();
            m_pNodeArray->RemoveNode((CNode*)pObj);
            pObj->Release(); // REVIEW: Only if it was in there!
        }
        break;
    }

    return NULL;
}

CObject* CNodeArrayObject::Dot(CObject* pObj)
{
    if (pObj->m_obj == objVariable)
    {
        CVarObject* pVar = (CVarObject*)pObj;

        if (pVar->m_nLength == 6 && _tcsncmp(pVar->m_sz, _T("length"), pVar->m_nLength) == 0)
        {
            CFunctionObject* pFun = new CFunctionObject;
            pFun->m_nFunction = 0;
            pFun->m_pObject = this;
            AddRef();

            return pFun;
        }
        else if (pVar->m_nLength == 3 && _tcsncmp(pVar->m_sz, _T("add"), pVar->m_nLength) == 0)
        {
            CFunctionObject* pFun = new CFunctionObject;
            pFun->m_nFunction = 1;
            pFun->m_pObject = this;
            AddRef();

            return pFun;
        }
        else if (pVar->m_nLength == 6 && _tcsncmp(pVar->m_sz, _T("remove"), pVar->m_nLength) == 0)
        {
            CFunctionObject* pFun = new CFunctionObject;
            pFun->m_nFunction = 2;
            pFun->m_pObject = this;
            AddRef();

            return pFun;
        }
    }
    else
    {
        int n = (int)((CNumObject*)pObj)->m_nValue;
        if (n < 0 || n >= m_pNodeArray->GetLength())
        {
            g_pRunner->Error(_T("Array reference out of bounds"));
            return NULL;
        }

        CNode* pNode = m_pNodeArray->GetNode(n);
        pNode->AddRef();
        return pNode;
    }

    return CObject::Dot(pObj);
}








// A CVarObject is actually just a name without a current scope...
// When one is Deref()'d or Assign()'d, a scope is known and it is resolved within that scope.
//
CVarObject::CVarObject(const TCHAR* pch, int cch)
{
    m_obj = objVariable;
    m_nLength = cch;
    m_nAlloc = cch + 1;
    m_sz = new TCHAR [m_nAlloc];
    CopyChars(m_sz, pch, cch);
    m_sz[cch] = '\0';
}

CVarObject::~CVarObject()
{
    delete [] m_sz;
}



CObject* CVarObject::Deref()
{
    CObject* pObject;

    // REVIEW: This is pretty bogus! We do have a table of classes to look the name up in...
    if (_tcscmp(m_sz, _T("Math")) == 0)
    {
        extern CMathClass g_Math;
        pObject = &g_Math;
    }
    else if (_tcscmp(m_sz, _T("camera")) == 0)
    {
        pObject = &theCamera;
    }
#ifndef _XBOX
    else if (_tcscmp(m_sz, _T("navigator")) == 0)
    {
        pObject = theApp.m_pNavigator;
    }
#endif
    else
    {
        pObject = g_pRunner->LookupVariable(m_sz, _tcslen(m_sz));
        if (pObject == NULL)
        {
            g_pRunner->Error(_T("Unknown object: %s"), m_sz);
            return NULL;
        }

        if (pObject->m_obj == objMember)
        {
            LOCALTRACE(_T("member\n"));
        }
    }

    pObject->AddRef();
    pObject = pObject->Deref();
    Release();

    return pObject;
}

void CVarObject::Assign(CObject* pNewObject)
{
    CObject* pObject;

    pObject = g_pRunner->LookupVariable(m_sz, _tcslen(m_sz));
    if (pObject == NULL)
    {
        g_pRunner->Error(_T("Unknown variable: %s"), m_sz);
        return;
    }

    pObject->Assign(pNewObject);
}





CMemberVarObject::CMemberVarObject(CInstance* pObject, int nMember)
{
    ASSERT(pObject != NULL);
    ASSERT(nMember >= 0 && nMember < pObject->m_vars.GetLength());

    m_obj = objMemberVar;

    m_pObject = pObject;
    m_nMember = nMember;

    m_pObject->AddRef();
}

CMemberVarObject::~CMemberVarObject()
{
    ASSERT(m_pObject != NULL);

    m_pObject->Release();
}


CObject* CMemberVarObject::Deref()
{
    ASSERT(m_nMember >= 0 && m_nMember < m_pObject->m_vars.GetLength());

    CObject* pObj = m_pObject->m_vars.GetNode(m_nMember);
    if (pObj != NULL)
        pObj->AddRef();

    Release();

    return pObj;
}

void CMemberVarObject::Assign(CObject* pNewObject)
{
    ASSERT(m_nMember >= 0 && m_nMember < m_pObject->m_vars.GetLength());

    CObject* pOldObj = m_pObject->m_vars.GetNode(m_nMember);
    if (pOldObj != NULL)
        pOldObj->Release();

    m_pObject->m_vars.SetNode(m_nMember, (CNode*)pNewObject);
    if (pNewObject != NULL)
        pNewObject->AddRef();
}


CMemberFunctionObject::CMemberFunctionObject(CInstance* pInstance, CFunction* pFunction)
{
    m_obj = objMemberFunction;
    m_pObject = pInstance;
    m_pFunction = pFunction;
}

CMemberFunctionObject::~CMemberFunctionObject()
{
}

CObject* CMemberFunctionObject::Deref()
{
    CRunner runner(m_pObject);
    runner.SetFunc(m_pFunction);
    CObject* pObject = runner.Run();
    Release();
    return pObject;
}




void CObject::Assign(CObject* pObject)
{
    g_pRunner->Error(_T("Cannot assign to objects"));
}


CFunctionObject::CFunctionObject()
{
    m_obj = objFunctionRef;
    m_pObject = NULL;
}

CFunctionObject::~CFunctionObject()
{
    if (m_pObject != NULL)
        m_pObject->Release();
}

CObject* CFunctionObject::Call(CObject** rgparam, int nParam)
{
    return m_pObject->Call(m_nFunction, rgparam, nParam);
}



////////////////////////////////////////////////////////////////////////////


CObject* FindMember(CNodeClass* pClass, const TCHAR* pchName, int cchName)
{
    for ( ; pClass != NULL; pClass = pClass->m_pBaseClass)
    {
        CObject* pObj = pClass->GetMember(pchName, cchName);
        if (pObj != NULL)
            return pObj;
    }

    return NULL;
}

CObject* LookupMember(CObject* pThis, const TCHAR* pchName, int cchName)
{
#ifdef _DEBUG0
    TCHAR szBuf [256];
    int cch = cchName;
    if (cch > 255)
        cch = 255;
    CopyChars(szBuf, pchName, cch);
    szBuf[cch] = 0;
    TRACE(_T("LookupMember: 0x%08x '%s'\n"), pThis, szBuf);
#endif

    ASSERT(pThis != NULL);

    g_pThis = pThis;

    if (pThis->m_obj == objNode)
    {
        CNode* pNode = (CNode*)pThis;
        const PRD* pprd = pNode->FindProp(pchName, cchName);
        if (pprd != NULL)
        {
            CObject* pObj = new CProperty(pNode, pprd);
            pObj->m_nRefCount = 0;
            return pObj;
        }
    }

    // BLOCK: Try for an instance member...
    {
        CObject* pObject = pThis->GetMember(pchName, cchName);
        if (pObject != NULL)
            return pObject;
    }

    // BLOCK: Try for a class member (all the way up through the base classes...
    {
        CObject* pObj = FindMember(pThis->GetNodeClass(), pchName, cchName);
        if (pObj != NULL)
            return pObj;
    }

    // BLOCK: Try the parent's of the object...
    {
        for (CObject* pObject = pThis->m_pParent; pObject != NULL; pObject = pObject->m_pParent)
        {
            CObject* pObj = LookupMember(pObject, pchName, cchName);
            if (pObj != NULL)
                return pObj;
        }
    }

    return NULL;
}


////////////////////////////////////////////////////////////////////////////


CFunction::CFunction()
{
    m_obj = objFunction;
    m_cbop = 0;

#ifdef _DEBUG
    m_szName = NULL;
#endif
}

CFunction::~CFunction()
{
#ifdef _DEBUG
    delete [] m_szName;
#endif
}

////////////////////////////////////////////////////////////////////////////


CMember::CMember()
{
    m_obj = objMember;
    m_nMember = -1;
}

CMember::~CMember()
{
}

CObject* CMember::Deref()
{
    ASSERT(g_pThis != NULL);
    ASSERT(g_pThis->m_obj == objInstance);

    CInstance* pThis = (CInstance*)g_pThis;

    ASSERT(m_nMember >= 0 && m_nMember < pThis->m_vars.GetLength());

    CObject* pObj = pThis->m_vars.GetNode(m_nMember);
    if (pObj != NULL)
        pObj->AddRef();
    Release();

    return pObj;
}

void CMember::Assign(CObject* pNewValue)
{
    ASSERT(g_pThis != NULL);
    ASSERT(g_pThis->m_obj == objInstance);

    CInstance* pThis = (CInstance*)g_pThis;

    ASSERT(m_nMember >= 0 && m_nMember < pThis->m_vars.GetLength());

    CObject* pObj = pThis->m_vars.GetNode(m_nMember);
    if (pObj != NULL)
        pObj->Release();

    pThis->m_vars.SetNode(m_nMember, (CNode*)pNewValue);
    if (pNewValue != NULL)
        pNewValue->AddRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\screen.h ===
class CScreen : public CNode
{
	DECLARE_NODE(CScreen, CNode)
public:
	CScreen();
	~CScreen();

	int m_width;
	int m_height;
	bool m_fullScreen;
	TCHAR* m_title;
	TCHAR* m_icon;
	TCHAR* m_border;
	bool m_showFramerate;
	bool m_letterbox;
	bool m_wideScreen;
	float m_brightness;

	bool OnSetProperty(const PRD* pprd, const void* pvValue);
	void Advance(float nSeconds);
	bool m_bSizeDirty;
	bool m_bTitleDirty;

	void SetBrightness(float nBrightness);
	float m_lastBrightness;

	DECLARE_NODE_PROPS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Settings.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"
#include "SettingsFile.h"

class CSettings;
class CSetting;


class CSetting : public CObject
{
public:
	CSetting();
	~CSetting();

	void Assign(CObject* pObject);
	CStrObject* ToStr();
	CObject* Deref();

	CSettings* m_pSettings;
	TCHAR* m_szName;
};


class CSettings : public CNode
{
	DECLARE_NODE(CSettings, CNode)
public:
	CSettings();
	~CSettings();

	CObject* Dot(CObject* pObject);

	TCHAR* m_file;
	TCHAR* m_section;

	void SetValue(const TCHAR* szName, const TCHAR* szValue);
	CStrObject* GetValue(const TCHAR* szName);

protected:
	CSettingsFile m_sfile;

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("Settings", CSettings, CNode)

START_NODE_PROPS(CSettings, CNode)
	NODE_PROP(pt_string, CSettings, file)
	NODE_PROP(pt_string, CSettings, section)
END_NODE_PROPS()

START_NODE_FUN(CSettings, CNode)
	NODE_FUN_SS(GetValue)
	NODE_FUN_VSS(SetValue)
END_NODE_FUN()

CSettings::CSettings()
{
	m_file = NULL;
	m_section = NULL;
}

CSettings::~CSettings()
{
	delete [] m_file;
	delete [] m_section;
}

CObject* CSettings::Dot(CObject* pObj)
{
	CObject* pObject = CNode::Dot(pObj);
	if (pObject != NULL)
		return pObject;

	if (pObj->m_obj == objVariable)
	{
		CVarObject* pVar = (CVarObject*)pObj;

		CSetting* pSetting = new CSetting;
		pSetting->m_pSettings = this;
		int cch = _tcslen(pVar->m_sz) + 1;
		pSetting->m_szName = new TCHAR [cch];
		CopyChars(pSetting->m_szName, pVar->m_sz, cch);
		return pSetting;
	}

	return NULL;
}

void CSettings::SetValue(const TCHAR* szName, const TCHAR* szValue)
{
	if (m_sfile.GetFileName() == NULL || _tcsicmp(m_sfile.GetFileName(), m_file) != 0)
	{
		m_sfile.Close();
		m_sfile.Open(m_file);
	}

	m_sfile.SetValue(m_section, szName, szValue);
}

CStrObject* CSettings::GetValue(const TCHAR* szName)
{
	if (m_sfile.GetFileName() == NULL || _tcsicmp(m_sfile.GetFileName(), m_file) != 0)
	{
		m_sfile.Close();
		if (!m_sfile.Open(m_file))
			return new CStrObject(_T(""));
	}

	TCHAR szBuf [1024];
	m_sfile.GetValue(m_section, szName, szBuf, countof(szBuf));
	return new CStrObject(szBuf);
}

////////////////////////////////////////////////////////////////////////////

CSetting::CSetting()
{
	m_pSettings = NULL;
	m_szName = NULL;
}

CSetting::~CSetting()
{
	delete [] m_szName;
}

void CSetting::Assign(CObject* pObject)
{
	CStrObject* pStrObject = pObject->Deref()->ToStr();
	const TCHAR* sz = pStrObject->GetSz();

	m_pSettings->SetValue(m_szName, sz);
}

CStrObject* CSetting::ToStr()
{
	return m_pSettings->GetValue(m_szName);
}

CObject* CSetting::Deref()
{
	CObject* pObject = m_pSettings->GetValue(m_szName);
	Release();
	return pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ScreenSaver.cpp ===
#include "std.h"
#include "xapp.h"
#include "node.h"

class CScreenSaver : public CNode
{
	DECLARE_NODE(CScreenSaver, CNode)
public:
	CScreenSaver();
	~CScreenSaver();

	bool m_enabled;
	bool m_isActive;
	bool m_isActive2;
	bool m_isActive3;
	float m_delay;
	float m_delay2;
	float m_delay3;
	float m_shortDelay;

	void reset();

	void Advance(float nSeconds);

	XTIME m_timeOfLastEvent;

	static CScreenSaver* c_pTheScreenSaver;
    bool OnSetProperty(const PRD* pprd, const void* pvValue);

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};

IMPLEMENT_NODE("ScreenSaver", CScreenSaver, CNode)

START_NODE_PROPS(CScreenSaver, CNode)
	NODE_PROP(pt_boolean, CScreenSaver, enabled)
	NODE_PROP(pt_boolean, CScreenSaver, isActive)
	NODE_PROP(pt_boolean, CScreenSaver, isActive2)
	NODE_PROP(pt_boolean, CScreenSaver, isActive3)
	NODE_PROP(pt_number, CScreenSaver, delay)
	NODE_PROP(pt_number, CScreenSaver, delay2)
	NODE_PROP(pt_number, CScreenSaver, delay3)
END_NODE_PROPS()

START_NODE_FUN(CScreenSaver, CNode)
	NODE_FUN_VV(reset)
END_NODE_FUN()

CScreenSaver* CScreenSaver::c_pTheScreenSaver = NULL;
XTIME g_timeOfLastEvent;

CScreenSaver::CScreenSaver() :
	m_enabled(true),
	m_isActive(false),
	m_isActive2(false),
	m_isActive3(false),
	m_delay(300.0f),
	m_delay2(0.0f),
	m_delay3(0.0f)
{
	c_pTheScreenSaver = this;
	m_timeOfLastEvent = XAppGetNow();
}

CScreenSaver::~CScreenSaver()
{
	if (this == c_pTheScreenSaver)
		c_pTheScreenSaver = NULL;
}

void CScreenSaver::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	XTIME now = XAppGetNow();

	if (!m_enabled && m_isActive)
	{
		m_isActive = false;
		CallFunction(this, _T("OnEnd"));
	}

	if (m_enabled && !m_isActive && now >= m_timeOfLastEvent + m_delay)
	{
		m_isActive = true;
		CallFunction(this, _T("OnStart"));
	}

	if (m_delay2 > 0.0f && !m_isActive2 && now >= m_timeOfLastEvent + m_delay2)
	{
		m_isActive2 = true;
		CallFunction(this, _T("OnDelay2"));
	}

	if (m_delay3 > 0.0f && !m_isActive3 && now >= m_timeOfLastEvent + m_delay3)
	{
		m_isActive3 = true;
		CallFunction(this, _T("OnDelay3"));
	}
}

void CScreenSaver::reset()
{
	if (m_isActive)
	{
		m_isActive = false;
		CallFunction(this, _T("OnEnd"));
	}

	m_isActive2 = false;
	m_isActive3 = false;

	m_timeOfLastEvent = XAppGetNow();
}

bool CScreenSaver::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_enabled))
    {
        if (*(bool*)pvValue) reset();
		m_enabled = *(bool*)pvValue;
    }
    return true;
}

bool ResetScreenSaver()
{
	g_timeOfLastEvent = XAppGetNow();

	if (CScreenSaver::c_pTheScreenSaver != NULL)
	{
		bool bRet = CScreenSaver::c_pTheScreenSaver->m_isActive;
		CScreenSaver::c_pTheScreenSaver->reset();

#ifdef _XBOX
		XAutoPowerDownResetTimer();
#endif
		return bRet;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\screen.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Screen.h"
#include "Lerper.h"

IMPLEMENT_NODE("Screen", CScreen, CNode)

START_NODE_PROPS(CScreen, CNode)
	NODE_PROP(pt_integer, CScreen, width)
	NODE_PROP(pt_integer, CScreen, height)
	NODE_PROP(pt_boolean, CScreen, fullScreen)
	NODE_PROP(pt_boolean, CScreen, showFramerate)
	NODE_PROP(pt_string, CScreen, title)
	NODE_PROP(pt_string, CScreen, icon)
	NODE_PROP(pt_string, CScreen, border)
	NODE_PROP(pt_boolean, CScreen, letterbox)
	NODE_PROP(pt_boolean, CScreen, wideScreen)
	NODE_PROP(pt_number, CScreen, brightness)
END_NODE_PROPS()


CScreen::CScreen()
{
	m_width = 640;
	m_height = 480;
	m_fullScreen = false;
	m_title = NULL;
	m_icon = NULL;
	m_border = NULL;
	m_showFramerate = false;
	m_letterbox = false;
	m_wideScreen = false;
	m_brightness = 1.0f;
	m_lastBrightness = 1.0f;

	if (theApp.m_pScreen == NULL)
		theApp.m_pScreen = this;

	m_bSizeDirty = false;
	m_bTitleDirty = false;
}

CScreen::~CScreen()
{
	delete [] m_title;
	delete [] m_icon;
	delete [] m_border;

	if (theApp.m_pScreen == this)
		theApp.m_pScreen = NULL;
}

bool CScreen::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_width) ||
		(int)pprd->pbOffset == offsetof(m_height))
	{
		m_bSizeDirty = true;
	}
	else if ((int)pprd->pbOffset == offsetof(m_title))
	{
		m_bTitleDirty = true;
	}
	else if ((int)pprd->pbOffset == offsetof(m_brightness))
	{
		float nBrightness = *(float*)pvValue;
//		SetBrightness(*(float*)pvValue);
		CLerper::RemoveObject(this);

		if (nBrightness != 1.0f)
		{
			new CLerper(this, &m_brightness, nBrightness, 2.0f);
			return false;
		}
	}

	return CNode::OnSetProperty(pprd, pvValue);
}

void CScreen::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_bSizeDirty)
	{
#ifdef _WINDOWS
		if (theApp.m_pScreen == this)
		{
			RECT rect;
			SetRect(&rect, 0, 0, m_width, m_height);

			DWORD dwStyle = GetWindowLong(theApp.m_hWnd, GWL_STYLE);
			DWORD dwExStyle = GetWindowLong(theApp.m_hWnd, GWL_EXSTYLE);
			AdjustWindowRectEx(&rect, dwStyle, false, dwExStyle);

			int nWidth = rect.right - rect.left;
			int nHeight = rect.bottom - rect.top;

			GetWindowRect(theApp.m_hWnd, &rect);
			int nLeft = rect.left;
			int nTop = rect.top;

			int nScreenWidth = GetSystemMetrics(SM_CXSCREEN);
			int nScreenHeight = GetSystemMetrics(SM_CYSCREEN);

			if (nLeft + nWidth > nScreenWidth)
				nLeft = (nScreenWidth - nWidth) / 2;

			if (nTop + nHeight > nScreenHeight)
				nTop = (nScreenHeight - nHeight) / 2;

			SetWindowPos(theApp.m_hWnd, NULL, nLeft, nTop, nWidth, nHeight, SWP_NOZORDER | SWP_NOACTIVATE);
		}
#endif

		m_bSizeDirty = false;
	}

	if (m_bTitleDirty)
	{
#ifdef _WINDOWS
		if (theApp.m_pScreen == this)
		{
			SetWindowText(theApp.m_hWnd, m_title);
		}
#endif

		m_bTitleDirty = false;
	}

	if (m_brightness != m_lastBrightness)
	{
		SetBrightness(m_brightness);
		m_lastBrightness = m_brightness;
	}
}

void CScreen::SetBrightness(float nBrightness)
{
#ifdef _XBOX
    D3DGAMMARAMP ramp;

	for (int i = 0; i < 256; i += 1)
	{
        ramp.red[i] = (BYTE)((float)i * nBrightness);
        ramp.green[i] = (BYTE)((float)i * nBrightness);
        ramp.blue[i] = (BYTE)((float)i * nBrightness);
	}

    XAppGetD3DDev()->SetGammaRamp(0, &ramp);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Runner.h ===
class CInstance;
class CFunction;

// This is an entry in the namespace...
class CMember : public CObject
{
public:
	CMember();
	~CMember();

	void Assign(CObject* pObject);
	CObject* Deref();

	int m_nMember;
//	CObject* m_pValue;
};

// This is a run-time reference to a member variable...
class CMemberVarObject : public CObject
{
public:
	CMemberVarObject(CInstance* pInstance, int m_nMember);
	~CMemberVarObject();

	CInstance* m_pObject;
	int m_nMember;

	CObject* Deref();
	void Assign(CObject* pObject);
};


// This is a run-time reference to a member function...
class CMemberFunctionObject : public CObject
{
public:
	CMemberFunctionObject(CInstance* pInstance, CFunction* pFunction);
	~CMemberFunctionObject();

	CInstance* m_pObject;
	CFunction* m_pFunction;

	CObject* Deref();
};


CClass* LookupClass(const TCHAR* pchName, int cchName);
//CObject* LookupVariable(const TCHAR* pchName, int cchName);

class CVarObject : public CObject
{
public:
	CVarObject(const TCHAR* pch, int cch);
	~CVarObject();

	int m_nLength;
	int m_nAlloc;
	TCHAR* m_sz;

//	CObject* m_pObject;

	CObject* Deref();
	void Assign(CObject* pObject);

private:
    // Need this to prevent the compiler from using default copy ctor
    CVarObject(const CVarObject&);
    CVarObject& operator=(const CVarObject& rhs);
};

class CNumObject : public CObject
{
public:
	CNumObject();
	CNumObject(float n);
	CNumObject(const TCHAR* szNum);

	CStrObject* ToStr();

	CNumObject* ToNum()
	{
		AddRef();
		return this;
	}

	float m_nValue;
};


class CStrObject : public CObject
{
public:
	CStrObject();
	CStrObject(const TCHAR* sz);
	CStrObject(const TCHAR* pch, int cch);
	~CStrObject();

	inline const TCHAR* GetSz()
	{
		if (m_sz == NULL)
			return _T("");
		return m_sz;
	}

	inline GetLength()
	{
		return m_nLength;
	}

	CStrObject* ToStr();
	CNumObject* ToNum();

	TCHAR* SetLength(int nLength);
	void Append(const TCHAR* szAppend);


	// Methods
	//
	int length(); // REVIEW: This should be a property, not a method!
	CStrObject* charAt(int index);
	int charCodeAt(int index);
	CStrObject* concat(const TCHAR* sz);
	CObject* indexOf(CObject** rgparam, int nParam);
	CObject* lastIndexOf(CObject** rgparam, int nParam);
	CStrObject* slice(int start, int end);
	CObject* substr(CObject** rgparam, int nParam);
	CObject* substring(CObject** rgparam, int nParam);
	CStrObject* toLowerCase();
	CStrObject* toUpperCase();

protected:
	int m_nLength;
	int m_nAlloc;
	TCHAR* m_sz;

	DECLARE_NODE_FUNCTIONS()

private:
    // Need this to prevent the compiler from using default copy ctor
    CStrObject(const CStrObject&);
    CStrObject& operator=(const CStrObject& rhs);
};

class CNodeArrayObject : public CObject
{
public:
	CNodeArrayObject(CNodeArray* pNodeArray);

	CObject* Call(int nFunction, CObject** rgparam, int nParam);
	CObject* Dot(CObject* pObject/*const TCHAR* pchFunc, int cchFunc*/);

	CNodeArray* m_pNodeArray;
};

class CFunctionObject : public CObject
{
public:
	CFunctionObject();
	~CFunctionObject();

	int m_nFunction;
	CObject* m_pObject;

	CObject* Call(CObject** rgparam, int nParam);
};


#define opNull		0
#define opNew		1
#define opVar		2
#define opJump		3
#define opCond		4
#define opCall		5
#define opRet		6
#define opStr		7
#define opNum		8
#define opAdd		9
#define opSub		10
#define opMul		11
#define opDiv		12
#define opDot		13
#define opAssign	14
#define opLocal		15
#define opEQ		16
#define opNE		17
#define opLT		18
#define opGT		19
#define opLE		20
#define opGE		21
#define opMod		22
#define opSHL		23
#define opSHR		24
#define opSHRU		25
#define opAnd		26
#define opOr		27
#define opXor		28
#define opLAnd		29
#define opLOr		30
#define opQuest		31
#define opAddAssign	32
#define opSubAssign	33
#define opMulAssign	34
#define opDivAssign	35
#define opModAssign	36
#define opAndAssign	37
#define opOrAssign	38
#define opXorAssign	39
#define opSHLAssign	40
#define opSHRAssign	41
#define opArray		42
#define opThis		43
#define opFrame		44
#define opStatement	45
#define opNeg		46
#define opDrop		47
#define opEndFrame	48
#define opSleep		49


#define opNewNode		100
#define opNewNodeProp	101
#define opDefNode		102
#define opUseNode		103
#define opEndNode		104
#define opInitProp		105
#define opInitArray		106
#define opEndArray		107
#define opFunction		108

struct RUNCONTEXT
{
	RUNCONTEXT* m_pNextContext;

	BYTE* m_ops;
	UINT m_nop;
	UINT m_spFrame;
	CObject* m_pSelf;
	CObject* m_pThis;
	UINT m_sp;
};

class CRunner
{
public:
	CRunner(CObject* pThis);
	~CRunner();

	bool SetFunc(const TCHAR* szFunc);

	void Push(float nValue);
	void Push(int nValue);
	void Push(const TCHAR* szValue, int nLen = -1);

	void Push(CObject* pObject);
	CObject* Pop();

	bool HasFunc() const { return m_ops != NULL; }
	void SetFunc(CFunction* pFunction);
	void ResetFunc();

	CObject* Run();
	bool Step(CObject** ppRetObj = NULL);
	void Error(const TCHAR* szFmt, ...);

	BYTE* LookupFunction(const TCHAR* pchName, int cchName, CObject*& pOwner);
	CObject* LookupVariable(const TCHAR* pchName, int cchName);

	bool IsSleeping()
	{
		if (m_wakeup != 0.0f)
		{
			if (m_wakeup > XAppGetNow())
				return true;

			m_wakeup = 0.0f;
		}

		return false;
	}

#ifdef _DEBUG
	void DumpStack();
#endif

protected:
	XTIME m_wakeup;
	UINT m_nop;
	BYTE* m_ops;
	UINT m_sp;
	CObject* m_stack [100];
	UINT m_spFrame;
	UINT m_spBase;
	CObject* m_pSelf;
	CObject* m_pThis;

	bool m_bError;
	int m_nLine;

	bool BinaryOperator(BYTE op);

	void PushContext(UINT nPopStack);
	void PopContext();
	BOOL ExecuteBuiltIn(const TCHAR* pchName, int cchName, int nParam, CObject** rgParam, CObject*& pRetObj);

	inline int FetchInt()
	{
#if defined(_WIN32_WCE)
		int n;
		CopyMemory(&n, &m_ops[m_nop], sizeof (int));
#else
		int n = *((int*)&m_ops[m_nop]);
#endif
		m_nop += sizeof (int);
		return n;
	}

	inline UINT FetchUInt()
	{
#if defined(_WIN32_WCE)
		UINT n;
		CopyMemory(&n, &m_ops[m_nop], sizeof (UINT));
#else
		UINT n = *((UINT*)&m_ops[m_nop]);
#endif
		m_nop += sizeof (UINT);
		return n;
	}

	inline float FetchFloat()
	{
#if defined(_WIN32_WCE)
		float n;
		CopyMemory(&n, &m_ops[m_nop], sizeof (float));
#else
		float n = *((float*)&m_ops[m_nop]);
#endif
		m_nop += sizeof (float);
		return n;
	}

	inline const TCHAR* FetchString(int& cch)
	{
		cch = FetchInt();
		const TCHAR* pch = (const TCHAR*)&m_ops[m_nop];
		m_nop += cch * sizeof (TCHAR);
		return pch;
	}

	RUNCONTEXT* m_pNextContext;

#ifdef _DEBUG
//	_CrtMemState m_memState;
#endif
};

extern CRunner* g_pRunner;
extern CObject* g_pThis; // REVIEW:: Kill this hack!

extern bool ExecuteScript(CObject* pObject, const TCHAR* szFunc);




#undef min
#undef max

class CMathClass : public CNodeClass
{
public:
	CMathClass();

	void AddRef();
	void Release();

	// These are all "non-members" (static functions)
	//
	float abs(float number);
	float acos(float number);
	float asin(float number);
	float atan(float number);
	float atan2(float y, float x);
	float ceil(float number);
	float cos(float number);
	float exp(float number);
	float floor(float number);
	float log(float number);
	float max(float number1, float number2);
	float min(float number1, float number2);
	float pow(float base, float exponent);
	float random();
	float round(float number);
	float sin(float number);
	float sqrt(float number);
	float tan(float number);

	float m_E;
	float m_LN2;
	float m_LN10;
	float m_LOG2E;
	float m_LOG10E;
	float m_PI;
	float m_SQRT1_2;
	float m_SQRT2;

	DECLARE_NODE_FUNCTIONS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\settingsfile.cpp ===
#include "std.h"
#include "XApp.h"
#include "SettingsFile.h"
#include "ActiveFile.h"
#include "Parser.h"

CSettingsFile::CSettingsFile()
{
	m_szFilePath = NULL;
	m_pSectionList = NULL;
	m_bDirty = false;

#ifdef _UNICODE
	m_bUnicode = false;
#endif
}

CSettingsFile::~CSettingsFile()
{
	Close();
}


bool CSettingsFile::OpenDir(const TCHAR* szDir)
{
	TCHAR szFile [MAX_PATH];
	_stprintf(szFile, _T("%s\\xbox.ini"), szDir);
	return Open(szFile);
}

bool CSettingsFile::Open(const TCHAR* szFile)
{
	CSettingsFileSection* pSection = NULL;

	ASSERT(m_szFilePath == NULL); // Already open?

	m_szFilePath = new TCHAR [_tcslen(szFile) + 1];
	_tcscpy(m_szFilePath, szFile);

	CActiveFile file;
	if (!file.Fetch(m_szFilePath, false, true))
		return false;

#ifdef _UNICODE
	m_bUnicode = file.IsUnicode();
	file.MakeUnicode();
#endif

	const TCHAR* pch = (const TCHAR*)file.GetContent();
	while (*pch != 0)
	{
		pch = SkipWhite(pch, none);

		if (*pch == '[')
		{
			pch += 1;

			TCHAR szSectionName [256];
			TCHAR* pchName = szSectionName;

			while (*pch != 0 && *pch != '\r' && *pch != '\n' && *pch != ']')
			{
				if (pchName >= szSectionName + countof(szSectionName) - 1)
				{
					TRACE(_T("\001Invalid XBX file (section name too long): %s\n"), m_szFilePath);
					Close();
					return false;
				}
				*pchName++ = *pch++;
			}
			*pchName = 0;

			if (*pch == ']')
			{
				pch += 1;
				pSection = FindSection(szSectionName, true);
			}
		}
		else
		{
			TCHAR szName [256];
			TCHAR* pchName = szName;
			TCHAR szValue [1024];
			TCHAR* pchValue = szValue;

			while (*pch != '\0' && *pch != '\r' && *pch != '\n' && *pch != '=')
			{
				if (pchName >= szName + countof(szName) - 1)
				{
					TRACE(_T("\001Invalid XBX file (name too long): %s\n"), m_szFilePath);
					Close();
					return false;
				}
				*pchName++ = *pch++;
			}
			*pchName = 0;

			if (*pch == '=')
			{
				pch += 1;

				while (*pch != '\0' && *pch != '\r' && *pch != '\n')
				{
					if (pchValue >= szValue + countof(szValue) - 1)
					{
						TRACE(_T("\001Invalid XBX file (value too long): %s\n"), m_szFilePath);
						Close();
						return false;
					}
					*pchValue++ = *pch++;
				}
				*pchValue = 0;

				if (pSection == NULL)
					pSection = FindSection(_T("default"), true);

				pSection->SetValue(szName, szValue);
			}
		}
	}

	return true;
}

void CSettingsFile::Cancel()
{
	m_bDirty = false;
	Close();
}

bool CSettingsFile::Save()
{
	if (!m_bDirty)
		return true;

#ifdef _UNICODE
	if (m_bUnicode)
	{
		// Write out Unicode file...

		FILE* pFile = _tfopen(m_szFilePath, _T("w"));
		if (pFile == NULL)
			return false;

		for (CSettingsFileSection* pSection = m_pSectionList; pSection != NULL; pSection = pSection->m_pNextSection)
		{
			_ftprintf(pFile, _T("[%s]\n"), pSection->m_szName);

			for (CSettingsFileValue* pValue = pSection->m_pValueList; pValue != NULL; pValue = pValue->m_pNextValue)
			{
				_ftprintf(pFile, _T("%s=%s\n"), pValue->m_szName, pValue->m_szValue);
			}
		}
	
		fclose(pFile);
	}
	else
	{
		// Convert our Unicode stuff to ANSI on the way out...

		HANDLE hFile = XAppCreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			return false;

		DWORD dw;
		for (CSettingsFileSection* pSection = m_pSectionList; pSection != NULL; pSection = pSection->m_pNextSection)
		{
			char szBuf [1030];
			char* pch = szBuf;
			TCHAR* pwch = pSection->m_szName;
			*pch++ = '[';
			while (*pwch != 0)
				*pch++ = (char)*pwch++;
			*pch++ = ']';
			*pch++ = '\r';
			*pch++ = '\n';
			WriteFile(hFile, szBuf, (DWORD)(pch - szBuf), &dw, NULL);

			for (CSettingsFileValue* pValue = pSection->m_pValueList; pValue != NULL; pValue = pValue->m_pNextValue)
			{
				pch = szBuf;
				pwch = pValue->m_szName;
				while (*pwch != 0)
					*pch++ = (char)*pwch++;
				*pch++ = '=';
				WriteFile(hFile, szBuf, (DWORD)(pch - szBuf), &dw, NULL);

				pch = szBuf;
				pwch = pValue->m_szValue;
				while (*pwch != 0)
					*pch++ = (char)*pwch++;
				*pch++ = '\r';
				*pch++ = '\n';
				WriteFile(hFile, szBuf, (DWORD)(pch - szBuf), &dw, NULL);
			}
		}

		CloseHandle(hFile);
	}
#else
	// Just write out an ANSI file...

	FILE* pFile = fopen(m_szFilePath, "w");
	if (pFile == NULL)
		return false;

	for (CSettingsFileSection* pSection = m_pSectionList; pSection != NULL; pSection = pSection->m_pNextSection)
	{
		fprintf(pFile, "[%s]\n", pSection->m_szName);

		for (CSettingsFileValue* pValue = pSection->m_pValueList; pValue != NULL; pValue = pValue->m_pNextValue)
		{
			fprintf(pFile, "%s=%s\n", pValue->m_szName, pValue->m_szValue);
		}
	}

	fclose(pFile);
#endif

	m_bDirty = false;

	return true;
}

bool CSettingsFile::Close()
{
	if (!Save())
		return false;

	CSettingsFileSection* pNextSection;
	for (CSettingsFileSection* pSection = m_pSectionList; pSection != NULL; pSection = pNextSection)
	{
		pNextSection = pSection->m_pNextSection;
		delete pSection;
	}

	m_pSectionList = NULL;

	delete [] m_szFilePath;
	m_szFilePath = NULL;

	return true;
}

CSettingsFileValue* CSettingsFileSection::FindValue(const TCHAR* szName)
{
	for (CSettingsFileValue* pValue = m_pValueList; pValue != NULL; pValue = pValue->m_pNextValue)
	{
		if (_tcscmp(szName, pValue->m_szName) == 0)
			return pValue;
	}

	return NULL;
}

CSettingsFileSection* CSettingsFile::FindSection(const TCHAR* szSection, bool bCreate/*=false*/)
{
	for (CSettingsFileSection* pSection = m_pSectionList; pSection != NULL; pSection = pSection->m_pNextSection)
	{
		if (_tcscmp(szSection, pSection->m_szName) == 0)
			return pSection;
	}

	if (bCreate)
	{
		pSection = new CSettingsFileSection;
		pSection->m_szName = new TCHAR [_tcslen(szSection) + 1];
		_tcscpy(pSection->m_szName, szSection);
		pSection->m_pNextSection = m_pSectionList;
		m_pSectionList = pSection;
		return pSection;
	}

	return NULL;
}

bool CSettingsFile::GetValue(const TCHAR* szSection, const TCHAR* szName, TCHAR* szValueBuf, int cchValueBuf)
{
	szValueBuf[0] = 0;

	if (szSection == NULL)
		szSection = _T("default");

	CSettingsFileSection* pSection = FindSection(szSection);
	if (pSection == NULL)
	{
		// Also try default...
		pSection = FindSection(_T("default"));
		if (pSection == NULL)
			return false;
	}

	CSettingsFileValue* pValue = pSection->FindValue(szName);
	if (pValue == NULL)
		return false;

	_tcsncpy(szValueBuf, pValue->m_szValue, cchValueBuf);
	szValueBuf[cchValueBuf - 1] = 0;

	return true;
}


void CSettingsFile::SetValue(const TCHAR* szSection, const TCHAR* szName, const TCHAR* szValue)
{
	if (szSection == NULL)
		szSection = _T("default");

	CSettingsFileSection* pSection = FindSection(szSection, true);

	if (pSection->SetValue(szName, szValue))
	{
		m_bDirty = true;
		Save(); // REVIEW: every time???
	}
}

bool CSettingsFileSection::SetValue(const TCHAR* szName, const TCHAR* szValue)
{
	CSettingsFileValue* pValue = FindValue(szName);
	if (pValue == NULL)
	{
		pValue = new CSettingsFileValue;
		pValue->m_szName = new TCHAR [_tcslen(szName) + 1];
		_tcscpy(pValue->m_szName, szName);

		pValue->m_pNextValue = m_pValueList;
		m_pValueList = pValue;
	}

	if (pValue->m_szValue != NULL && _tcscmp(pValue->m_szValue, szValue) == 0)
		return false;

	delete [] pValue->m_szValue;
	pValue->m_szValue = new TCHAR [_tcslen(szValue) + 1];
	_tcscpy(pValue->m_szValue, szValue);

	return true;
}

CSettingsFileSection::CSettingsFileSection()
{
	m_szName = NULL;
	m_pValueList = NULL;
}

CSettingsFileSection::~CSettingsFileSection()
{
	CSettingsFileValue* pNextValue;
	for (CSettingsFileValue* pValue = m_pValueList; pValue != NULL; pValue = pNextValue)
	{
		pNextValue = pValue->m_pNextValue;
		delete pValue;
	}

	delete [] m_szName;
}

CSettingsFileValue::CSettingsFileValue()
{
	m_szName = NULL;
	m_szValue = NULL;
}

CSettingsFileValue::~CSettingsFileValue()
{
	delete [] m_szName;
	delete [] m_szValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\SavedGameGrid.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    savedgamegrid.cpp

Abstract:

    This module implements routine to display and manage saved game grid
    in memory menu.  It also contains routine to copy and delete saved
    games and soundtracks.

--*/

#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "node.h"
#include "runner.h"
#include "Texture.h"
#include "Locale.h"
#include "SettingsFile.h"
#include "TitleCollection.h"
#include "CopyGames.h"

#define VISIBLE_ICON_ROWS 3

extern void MakePath(TCHAR* szBuf, const TCHAR* szDir, const TCHAR* szFile);

extern int GetSoundtrackCount();
extern const TCHAR* GetSoundtrackName(int nSoundtrack);
extern int GetSoundtrackSize(int nSoundtrack, HANDLE hCancelEvent = NULL);
extern void DeleteSoundtrack(int nSoundtrack);
extern void DeleteAllSoundtracks();

extern void FormatDeviceName(int devUnit, TCHAR* szBuf);

extern CNode* GetTextNode(const TCHAR* szText, float nWidth);
extern float g_nEffectAlpha;
extern XTIME g_pulseStartTime;
extern const TCHAR* g_szCurTitleImage;
extern const TCHAR* g_szSelTitleImage;
TCHAR szSelectionBuf [MAX_PATH];

static D3DXMATRIX matrixHack;
static bool bMatrixHackValid;

CGameCopier theGameCopier;

class CSavedGameGrid : public CNode
{
	DECLARE_NODE(CSavedGameGrid, CNode)
public:
	CSavedGameGrid();
	~CSavedGameGrid();

	void Render();
	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	CNode* m_pod;
	CNode* m_podRing;
	CNode* m_podSavePanel;
	CNode* m_podSoundtrackPanel;
	CNode* m_podHilite;
	CNode* m_MUheader;
	CNode* m_MUhiliteHeader;
	CNode* m_firstMURow;
	CNode* m_header;
	CNode* m_hiliteHeader;
	CNode* m_firstRow;
	CNode* m_secondRow;
	CNode* m_otherRow;
	CNode* m_smallIcon;
	CNode* m_SavedIconPanel;
	CNode* m_SoundtrackIconPanel;
	CNode* m_iconRing;
	CNode* m_smallIconHilite;
	CNode* m_moreUp;
	CNode* m_moreDown;
	bool m_renderIcons;
	int m_iconsPerRow;
	float m_scroll;
	int m_curTitle;
    int m_curTitleCache;
	int m_curSavedGame;
	int m_curSavedGameCache;
	int m_iconRowScroll;
	float m_smallIconSpacing;
	bool m_detachIcon;
	int m_curDevUnit;
	float m_copyProgress;
	int m_freeBlocks;
	int m_gameBlocks;
    bool m_isActive;
    bool m_busy;
	int m_nPrefColumn;

	void selectUp();
	void selectDown();
	void selectLeft();
	void selectRight();

	void setSelImage();

	//CStrObject* ReturnSavedGameImage();
	CStrObject* FormatSavedGameName();
	CStrObject* FormatSavedGameTime();
	CStrObject* FormatSavedGameSize();
	CStrObject* FormatTitleSize();
	CStrObject* FormatTotalBlocks();
	CStrObject* FormatFreeBlocks();

    int GetTotalBlocks();

	CStrObject* GetSavedGamePath(int nTitle, int nSavedGame);
	CStrObject* GetUpdateString(void);

	void StartCopy(int destDevUnit);
	void StartDelete();
    int DoesSavedGameExists(int destDevUnit);

	int CanDetachIcon();

	int GetTitleCount();
	int CanCopy();
	int IsSoundtrackSelected();
	int IsDevUnitReady(int nUnit);

protected:
    int m_nLanguage;
	int m_nTotalBlocks;
	float m_nScrollTo;
	XTIME m_timeScroll;
	int m_curTitleLast;
	bool m_bCopying;
    XTIME m_timeCopyingStarted;
	bool m_bCopyError;
	int m_nDeletedTitle;
	XTIME m_timeOfDelete;
	int m_nSoundtrackTitle;
	int m_nSoundtrackCount;

    int m_nCacheTitleSize;
    int m_nCacheSavedGameSize;

	void RenderIconRow(D3DXMATRIX* pMatrix, float y, int nTitle, int nFirstSavedGame, int nSavedGameCount);
	float RenderLoop(bool bRender);
	void SelectTitle(int nTitle, bool bInstantScroll = false);
	bool GetSavedGamePath(TCHAR* szBuf, int nTitle, int nSavedGame);

	int GetSavedGameCount(int nTitle);
	int GetTitleTotalBlocks(int nTitle, HANDLE hCancelEvent);
	const TCHAR* GetTitleID2(int nTitle);
	void GetTitleName2(int nTitle, TCHAR* szBuf);
	const TCHAR* GetSavedGameID2(int nTitle, int nSavedGame);
	FILETIME GetSavedGameTime(int nTitle, int nSavedGame);

	CStrObject* GetTitleID(int nTitle);
	CStrObject* GetTitleName(int nTitle);

	DWORD m_strProgress;
	int m_periodStatus;
	TCHAR m_szStatus[MAX_TRANSLATE_LEN];

	DECLARE_NODE_PROPS();
	DECLARE_NODE_FUNCTIONS();

private:
    HANDLE m_hTitlesEnumThread;
    HANDLE m_hSavedGameEnumThread;
    HANDLE m_hCancelEvent;
    HANDLE m_hStartEvent, m_hStopEvent;
    bool m_bSavedGameQueryPending;
    volatile bool m_bDone;
    XTIME m_timeToSendEnd;
    static void WINAPI TitlesEnumThread(CSavedGameGrid* p);
    static void WINAPI SavedGameEnumThread(CSavedGameGrid* p);

    // Background delete thread and flag
    HANDLE m_hDeleteThread;
    bool m_bDeleting;
    static void WINAPI DeleteThread(CSavedGameGrid* p);
};

IMPLEMENT_NODE("SavedGameGrid", CSavedGameGrid, CNode)

START_NODE_PROPS(CSavedGameGrid, CNode)
	NODE_PROP(pt_node, CSavedGameGrid, pod)
	NODE_PROP(pt_node, CSavedGameGrid, podRing)
	NODE_PROP(pt_node, CSavedGameGrid, podSavePanel)
	NODE_PROP(pt_node, CSavedGameGrid, podSoundtrackPanel)
	NODE_PROP(pt_node, CSavedGameGrid, podHilite)
	NODE_PROP(pt_node, CSavedGameGrid, MUheader)
	NODE_PROP(pt_node, CSavedGameGrid, MUhiliteHeader)
	NODE_PROP(pt_node, CSavedGameGrid, firstMURow)
	NODE_PROP(pt_node, CSavedGameGrid, header)
	NODE_PROP(pt_node, CSavedGameGrid, hiliteHeader)
	NODE_PROP(pt_node, CSavedGameGrid, firstRow)
	NODE_PROP(pt_node, CSavedGameGrid, secondRow)
	NODE_PROP(pt_node, CSavedGameGrid, otherRow)
	NODE_PROP(pt_integer, CSavedGameGrid, renderIcons)
	NODE_PROP(pt_integer, CSavedGameGrid, iconsPerRow)
	NODE_PROP(pt_number, CSavedGameGrid, scroll)
	NODE_PROP(pt_integer, CSavedGameGrid, curTitle)
	NODE_PROP(pt_node, CSavedGameGrid, smallIcon)
	NODE_PROP(pt_node, CSavedGameGrid, SavedIconPanel)
	NODE_PROP(pt_node, CSavedGameGrid, SoundtrackIconPanel)
	NODE_PROP(pt_node, CSavedGameGrid, iconRing)
	NODE_PROP(pt_node, CSavedGameGrid, smallIconHilite)
	NODE_PROP(pt_number, CSavedGameGrid, smallIconSpacing)
	NODE_PROP(pt_integer, CSavedGameGrid, curSavedGame)
	NODE_PROP(pt_integer, CSavedGameGrid, iconRowScroll)
	NODE_PROP(pt_node, CSavedGameGrid, moreUp)
	NODE_PROP(pt_node, CSavedGameGrid, moreDown)
	NODE_PROP(pt_boolean, CSavedGameGrid, detachIcon)
	NODE_PROP(pt_boolean, CSavedGameGrid, isActive)
	NODE_PROP(pt_integer, CSavedGameGrid, curDevUnit)
	NODE_PROP(pt_number, CSavedGameGrid, copyProgress)
	NODE_PROP(pt_integer, CSavedGameGrid, freeBlocks)
	NODE_PROP(pt_integer, CSavedGameGrid, gameBlocks)
	NODE_PROP(pt_integer, CSavedGameGrid, nPrefColumn)
END_NODE_PROPS()

START_NODE_FUN(CSavedGameGrid, CNode)
	NODE_FUN_VV(selectUp)
	NODE_FUN_VV(selectDown)
	NODE_FUN_VV(selectLeft)
	NODE_FUN_VV(selectRight)
	NODE_FUN_VV(setSelImage)
	NODE_FUN_SV(FormatSavedGameName)
	NODE_FUN_SV(FormatSavedGameTime)
	NODE_FUN_SV(FormatSavedGameSize)
	NODE_FUN_SV(FormatTitleSize)
	NODE_FUN_SV(FormatTotalBlocks)
	NODE_FUN_IV(GetTotalBlocks)
	NODE_FUN_SV(FormatFreeBlocks)
	NODE_FUN_IV(CanDetachIcon)
	NODE_FUN_II(GetSavedGameCount)
	NODE_FUN_SI(GetTitleName)
	NODE_FUN_SI(GetTitleID)
	NODE_FUN_VI(StartCopy)
	NODE_FUN_VV(StartDelete)
    NODE_FUN_II(DoesSavedGameExists)
	NODE_FUN_SII(GetSavedGamePath)
	NODE_FUN_IV(CanCopy)
	NODE_FUN_IV(IsSoundtrackSelected)
	NODE_FUN_II(IsDevUnitReady)
	NODE_FUN_IV(GetTitleCount)
	NODE_FUN_SV(GetUpdateString)
END_NODE_FUN()

CSavedGameGrid::CSavedGameGrid() :
    m_nLanguage(0),
	m_pod(NULL),
	m_podRing(NULL),
	m_podSavePanel(NULL),
	m_podSoundtrackPanel(NULL),
	m_podHilite(NULL),
	m_MUheader(NULL),
	m_MUhiliteHeader(NULL),
	m_firstMURow(NULL),
	m_header(NULL),
	m_hiliteHeader(NULL),
	m_firstRow(NULL),
	m_secondRow(NULL),
	m_otherRow(NULL),
	m_moreUp(NULL),
	m_moreDown(NULL),
	m_renderIcons(true),
	m_iconsPerRow(4),
	m_scroll(0.0f),
	m_curTitle(-1),
	m_curTitleCache(-1),
	m_curSavedGame(-1),
	m_curSavedGameCache(-1),
	m_smallIcon(NULL),
	m_SavedIconPanel(NULL),
	m_SoundtrackIconPanel(NULL),
	m_iconRing(NULL),
	m_smallIconHilite(NULL),
	m_smallIconSpacing(1.0f),
	m_detachIcon(false),
    m_isActive(false),
    m_busy(false),
    m_hDeleteThread(NULL),
    m_bDeleting(false),
    m_hTitlesEnumThread(NULL),
    m_hSavedGameEnumThread(NULL),
    m_nCacheSavedGameSize(-1),
    m_nCacheTitleSize(-1),
    m_bSavedGameQueryPending(false),
    m_bDone(false),
    m_bCopying(false),
    m_timeCopyingStarted(0.0f),
	m_curDevUnit(-1),
	m_iconRowScroll(0),
	m_nPrefColumn(-1)
{
	m_nScrollTo = 0.0f;
	m_timeScroll = 0.0f;
	m_curTitleLast = -1;
	m_nTotalBlocks = -1;
	m_freeBlocks = -1;
	m_gameBlocks = -1;
	m_nDeletedTitle = -1;
	m_timeOfDelete = 0.0f;
	m_nSoundtrackTitle = -1;
	m_nSoundtrackCount = 0;

    VERIFY(m_hStartEvent = CreateEvent(0, FALSE, FALSE, 0));
    VERIFY(m_hStopEvent = CreateEvent(0, TRUE, FALSE, 0));
    VERIFY(m_hCancelEvent = CreateEvent(0, TRUE, FALSE, 0));
    VERIFY(m_hSavedGameEnumThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)SavedGameEnumThread, (LPVOID)this, 0, 0));
}

CSavedGameGrid::~CSavedGameGrid()
{
	if (m_pod != NULL)
		m_pod->Release();

	if (m_podRing != NULL)
		m_podRing->Release();

	if (m_podSavePanel != NULL)
		m_podSavePanel->Release();

	if (m_podSoundtrackPanel != NULL)
		m_podSoundtrackPanel->Release();
	
	if (m_podHilite != NULL)
		m_podHilite->Release();

	if (m_MUheader != NULL)
		m_MUheader->Release();

	if (m_MUhiliteHeader != NULL)
		m_MUhiliteHeader->Release();
	
	if (m_firstMURow != NULL)
		m_firstMURow->Release();
	
	if (m_header != NULL)
		m_header->Release();

	if (m_hiliteHeader != NULL)
		m_hiliteHeader->Release();
	
	if (m_firstRow != NULL)
		m_firstRow->Release();
	
	if (m_secondRow != NULL)
		m_secondRow->Release();

	if (m_otherRow != NULL)
		m_otherRow->Release();

	if (m_smallIcon != NULL)
		m_smallIcon->Release();

	if (m_SavedIconPanel != NULL)
		m_SavedIconPanel->Release();

	if (m_SoundtrackIconPanel != NULL)
		m_SoundtrackIconPanel->Release();
	
	if (m_iconRing != NULL)
		m_iconRing->Release();

	if (m_smallIconHilite != NULL)
		m_smallIconHilite->Release();

	if (m_moreUp != NULL)
		m_moreUp->Release();

	if (m_moreDown != NULL)
		m_moreDown->Release();

    // We never should never hit this, the object never gets destroyed
    ASSERT(FALSE);

    if (m_bSavedGameQueryPending)
    {
        m_bDone = true;
        SetEvent(m_hCancelEvent);
    }

    WaitForSingleObject(m_hSavedGameEnumThread, INFINITE);

    VERIFY(CloseHandle(m_hStartEvent));
    VERIFY(CloseHandle(m_hStopEvent));
    VERIFY(CloseHandle(m_hCancelEvent));
    VERIFY(CloseHandle(m_hSavedGameEnumThread));
}

int CSavedGameGrid::GetTitleCount()
{
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	int nTitleCount = g_titles[m_curDevUnit].GetTitleCount();
	if(m_curDevUnit == Dev0)
	{
		m_nSoundtrackCount = GetSoundtrackCount();
		m_nSoundtrackTitle = nTitleCount;
	}
	else
	{
		m_nSoundtrackCount = 0;
		m_nSoundtrackTitle = -1;
	}

	if (m_curDevUnit == Dev0 && m_nSoundtrackCount > 0)
	{
		ASSERT(nTitleCount == m_nSoundtrackTitle);
		nTitleCount += 1;
	}


	return nTitleCount;
}

inline int CSavedGameGrid::GetTitleTotalBlocks(int nTitle, HANDLE hCancelEvent)
{
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	if (nTitle < 0)
		return 0;

	if (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle)
		return g_titles[m_curDevUnit].GetTitleTotalBlocks(nTitle, hCancelEvent);

	return GetSoundtrackSize(-1);
}

inline const TCHAR* CSavedGameGrid::GetTitleID2(int nTitle)
{
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	ASSERT(nTitle >= 0 && (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle));
	return g_titles[m_curDevUnit].GetTitleID(nTitle);
}

inline CStrObject* CSavedGameGrid::GetTitleID(int nTitle)
{
	ASSERT(nTitle >= 0 && (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle));
	return new CStrObject(GetTitleID2(nTitle));
}

void CSavedGameGrid::GetTitleName2(int nTitle, TCHAR* szBuf)
{
    TCHAR sz[MAX_TRANSLATE_LEN];
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	if (nTitle < 0)
	{
		if (m_curDevUnit == Dev0)
			_tcscpy(szBuf, Translate(_T("Xbox Hard Disk"), sz));
		else
		{
			FormatDeviceName(m_curDevUnit, szBuf);
			if(szBuf[0] == 0)
			{
				TCHAR ch = _T('B');

				// Generate a name based on location of slot...
				int nGamePad = (m_curDevUnit + 1) % 2;
				if (nGamePad)
					ch = _T('A');
				
				Translate(_T("memory unit"), sz);
				swprintf(szBuf, _T("%s %d%c"), sz, (m_curDevUnit / 2) + 1, ch);
			}

		}
		return;
	}

	if (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle)
	{
		_tcscpy(szBuf, g_titles[m_curDevUnit].GetTitleName(nTitle));
		return;
	}

	_tcscpy(szBuf, Translate(_T("Soundtracks"), sz));
}

inline CStrObject* CSavedGameGrid::GetTitleName(int nTitle)
{
	TCHAR szBuf [256];
	GetTitleName2(nTitle, szBuf);
	return new CStrObject(szBuf);
}

inline const TCHAR* CSavedGameGrid::GetSavedGameID2(int nTitle, int nSavedGame)
{
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	ASSERT(nTitle >= 0 && (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle));
	return g_titles[m_curDevUnit].GetSavedGameID(nTitle, nSavedGame);
}

inline FILETIME CSavedGameGrid::GetSavedGameTime(int nTitle, int nSavedGame)
{
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	ASSERT(nTitle >= 0 && (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle));
	return g_titles[m_curDevUnit].GetSavedGameTime(nTitle, nSavedGame);
}

void WINAPI CSavedGameGrid::TitlesEnumThread(CSavedGameGrid* p)
{
    p->m_busy = true;

    // Enumerate all titles on current device unit
    g_titles[p->m_curDevUnit].Update();

    // Also enumerate soundtrack if it's a hard disk
	if (p->m_curDevUnit == Dev0 && p->m_nSoundtrackTitle == -1)
	{
		int nSoundtrackCount = GetSoundtrackCount();
		if (nSoundtrackCount > 0)
		{
			p->m_nSoundtrackTitle = p->GetTitleCount();
			p->m_nSoundtrackCount = nSoundtrackCount;
		}
	}

    p->m_busy = false;
}

void WINAPI CSavedGameGrid::SavedGameEnumThread(CSavedGameGrid* p)
{
    while (!p->m_bDone)
    {
        ASSERT(p->m_hStartEvent);
        ASSERT(p->m_hStopEvent);

        SignalObjectAndWait(p->m_hStopEvent, p->m_hStartEvent, INFINITE, FALSE);
        ResetEvent(p->m_hStopEvent);

        ASSERT(!g_titles[p->m_curDevUnit].IsDirty());

        if (p->m_nCacheSavedGameSize < 0 && p->m_curTitle >=0 && p->m_curSavedGame >= 0)
        {
            if (p->m_nSoundtrackTitle < 0 || p->m_curTitle < p->m_nSoundtrackTitle)
            {
                TCHAR szSavedGameDir[MAX_PATH];
                if (p->GetSavedGamePath(szSavedGameDir, p->m_curTitle, p->m_curSavedGame))
                {
                    p->m_nCacheSavedGameSize = GetDirectoryBlocks(szSavedGameDir, BLOCK_SIZE, true, p->m_hCancelEvent);
                }
                else
                {
                    // REVIEW: What should be returned in this case?
                    p->m_nCacheSavedGameSize = 0;
                }
            }
            else
            {
                p->m_nCacheSavedGameSize = GetSoundtrackSize(p->m_curSavedGame);
            }
        }
        else if (p->m_nCacheTitleSize < 0)
        {
            p->m_nCacheTitleSize = p->GetTitleTotalBlocks(p->m_curTitle, p->m_hCancelEvent);
        }
    }
}

void CSavedGameGrid::Advance(float nSeconds)
{
    bool bUpdateSavedGames;

	CNode::Advance(nSeconds);

	if (m_curDevUnit == -1 || !m_isActive)
		return;

	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

    // Enumerating all titles in UDATA
    if (m_hTitlesEnumThread)
    {
        if (XAppGetNow() > m_timeToSendEnd && WaitForSingleObject(m_hTitlesEnumThread, 0) == WAIT_OBJECT_0)
        {
            VERIFY(CallFunction(this, _T("OnUpdatingTitlesEnd")));
            VERIFY(CloseHandle(m_hTitlesEnumThread));
            m_hTitlesEnumThread = NULL;
        }
        else
        {
            return;
        }
    }
    else if (g_titles[m_curDevUnit].IsDirty())
    {
        if (!m_hTitlesEnumThread)
        {
            m_nSoundtrackTitle = -1;
            m_nSoundtrackCount = 0;

            m_timeToSendEnd = XAppGetNow() + 1.0f;
            VERIFY(CallFunction(this, _T("OnUpdatingTitlesBegin")));

            m_hTitlesEnumThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)TitlesEnumThread, (LPVOID)this, 0, 0);

            // If the CreateThread failed, call it directly
            if (!m_hTitlesEnumThread)
            {
                TitlesEnumThread(this);
                VERIFY(CallFunction(this, _T("OnUpdatingTitlesEnd")));
                goto next;
            }
        }
        return;
    }

next:

    //
    //  While copying or deleting is in progress, there is no need to do anything else.
    //  Even (especially?) look for device removal.  In the device removal case, the
    //  delete or file copy will error out, clearing the in progress bits, and then
    //  we will fall through and handle the removal.  With any luck this fixes bug 5212
    //  and a host of related stuff.
    //

    // BLOCK: Copy progress...
	if (m_bCopying)
	{
		if (m_copyProgress != theGameCopier.m_progress)
		{
			m_copyProgress = theGameCopier.m_progress;
			CallFunction(this, _T("OnCopyProgressChanged"));
		}

		if (theGameCopier.m_error)
		{
			m_bCopying = false;
			theGameCopier.Finish();
			TRACE(_T("OnCopyError\n"));
			CallFunction(this, _T("OnCopyError"));
		}
		else if (theGameCopier.m_done && XAppGetNow() >= m_timeCopyingStarted + 0.5f)
		{
			m_bCopying = false;
			theGameCopier.Finish();
			TRACE(_T("OnCopyComplete\n"));
			CallFunction(this, _T("OnCopyComplete"));
		}
        return;
	}

    // BLOCK: Delete notification
    if (m_bDeleting)
    {
        ASSERT(m_hDeleteThread);
        if (WaitForSingleObject(m_hDeleteThread, 0) == WAIT_OBJECT_0)
        {
            CloseHandle(m_hDeleteThread);
            m_hDeleteThread = NULL;
            m_bDeleting = false;
            VERIFY(CallFunction(this, _T("OnDeleteEnd")));
            VERIFY(CallFunction(this, _T("OnSelChange")));
            g_pulseStartTime = XAppGetNow();
        }
        return;
    }

	if (!g_titles[m_curDevUnit].IsValid())
	{
		CallFunction(this, _T("OnDeviceRemoved"));
		m_curDevUnit = -1;
		return;
	}

    if (g_titles[m_curDevUnit].IsDirty())
    {
        return;
    }

    // BLOCK: send notification if saved game query is done
    if (m_bSavedGameQueryPending && WaitForSingleObject(m_hStopEvent, 0) == WAIT_OBJECT_0)
    {
        VERIFY(CallFunction(this, _T("OnSelChange")));
        m_bSavedGameQueryPending = false;
    }

    // BLOCK: check if saved game info needs to be updated
    if (m_curSavedGame != m_curSavedGameCache)
    {
        m_curSavedGameCache = m_curSavedGame;
        m_nCacheSavedGameSize = -1;
        bUpdateSavedGames = true;
    }
    else if (m_curTitle != m_curTitleCache)
    {
        m_curTitleCache = m_curTitle;
        m_nCacheTitleSize = -1;
        m_curSavedGameCache = m_curSavedGame;
        m_nCacheSavedGameSize = -1;
        bUpdateSavedGames = true;
    }
    else if (!m_bSavedGameQueryPending && (m_nCacheTitleSize < 0 || m_nCacheSavedGameSize < 0))
    {
        bUpdateSavedGames = true;
    }
    else
    {
        bUpdateSavedGames = false;
    }

    // BLOCK: start/stop background thread and query saved game as needed
    if (bUpdateSavedGames && m_curTitle >= 0)
    {
        if (m_nCacheTitleSize < 0 || (m_nCacheSavedGameSize < 0 && m_curSavedGame >= 0))
        {
            // Send OnSelChange so that meta panel will be updated to unknown size
            VERIFY(CallFunction(this, _T("OnSelChange")));

            // Cancel previous pending query
            if (m_bSavedGameQueryPending)
            {
                SignalObjectAndWait(m_hCancelEvent, m_hStopEvent, INFINITE, FALSE);
            }

            ResetEvent(m_hCancelEvent);
            SetEvent(m_hStartEvent);
            m_bSavedGameQueryPending = true;
        }
    }

	// BLOCK: Get total/free space info...
	{
#ifdef _XBOX
		FSCHAR szPath [MAX_PATH];
		Ansi(szPath, g_titles[m_curDevUnit].GetUData(), MAX_PATH);
#else
		const FSCHAR* szPath = g_titles[m_curDevUnit].GetUData();
#endif
		ULARGE_INTEGER qwAvailBytes, qwTotalBytes, qwFreeBytes;
		
        if (!GetDiskFreeSpaceEx(szPath, &qwAvailBytes, &qwTotalBytes, &qwFreeBytes))
		{
            qwFreeBytes.QuadPart  = 0;
            qwTotalBytes.QuadPart = BLOCK_SIZE;
            qwFreeBytes.QuadPart  = 0;
			TRACE(_T("GetDiskFreeSpaceEx %s failed: %d\n"), g_titles[m_curDevUnit].GetUData(), GetLastError());
		}

        int totalBlocks = (int)((qwTotalBytes.QuadPart + BLOCK_SIZE - 1) / BLOCK_SIZE);
        int freeBlocks = (int)((qwFreeBytes.QuadPart + BLOCK_SIZE - 1) / BLOCK_SIZE);

        totalBlocks -= 1; // we always have a root dir that uses at least one block...

        if (totalBlocks != m_nTotalBlocks || freeBlocks != m_freeBlocks || g_nCurLanguage != m_nLanguage)
        {
            m_nLanguage = g_nCurLanguage;
            m_nTotalBlocks = totalBlocks;
            m_freeBlocks = freeBlocks;
            CallFunction(this, _T("OnTotalFreeChanged"));
            CallFunction(this, _T("OnSelChange"));
        }
	}

	if (m_timeScroll != 0.0f)
	{
		float t = (float) (XAppGetNow() - m_timeScroll) / 0.25f;
		if (t >= 1.0f)
		{
			m_timeScroll = 0.0f;
			t = 1.0f;
		}

		float t1 = 1.0f - t;
		m_scroll = t1 * m_scroll + t * m_nScrollTo;

		bMatrixHackValid = false;
	}
}

CStrObject* CSavedGameGrid::GetUpdateString(void)
{
	if((GetTickCount() - m_strProgress) > 500)
	{
		m_strProgress = GetTickCount();
		m_periodStatus++;
		if(m_periodStatus > 3)
			m_periodStatus = 0;

		Translate(_T("Copying"), m_szStatus);

		for(int i = 0; i < m_periodStatus; i++)
			_tcscat(m_szStatus, _T("."));
	}

	return new CStrObject(m_szStatus);
}

bool CSavedGameGrid::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_curDevUnit))
	{
		m_curDevUnit = *(int*)pvValue;

		// Set initial focus position
		if(m_curDevUnit < 8)
			SelectTitle(-1, true);
		else if(m_curDevUnit == 8)
			SelectTitle(0, true);

        // Invalidate cache
        m_nCacheSavedGameSize = -1;
        m_nCacheTitleSize = -1;

		return false;
	}
	else if ((int)pprd->pbOffset == offsetof(m_curTitle))
	{
        SelectTitle(*(int*)pvValue);
		return false;
	}
	else if ((int)pprd->pbOffset == offsetof(m_isActive))
	{
        if (*(bool*)pvValue == false && m_bSavedGameQueryPending)
        {
            SignalObjectAndWait(m_hCancelEvent, m_hStopEvent, INFINITE, FALSE);
            m_bSavedGameQueryPending = false;
            m_nCacheTitleSize = -1;
            m_nCacheSavedGameSize = -1;
        }
	}

	return true;
}

static void RenderNodeAt(CNode* pNode, D3DXMATRIX* pMatrix)
{
	if (pNode == NULL)
		return;

	XAppPushWorld();
	XAppMultWorld(pMatrix);

	XAppUpdateWorld();

	pNode->Render();

	XAppPopWorld();
}

void CSavedGameGrid::RenderIconRow(D3DXMATRIX* pMatrix, float y, int nTitle, int nFirstSavedGame, int nSavedGames)
{
	if (m_smallIcon == NULL)
		return;

	if (nTitle < 0)
	{
		// TODO: Render info for device
		return;
	}

	int nLim = nFirstSavedGame + m_iconsPerRow;
	if (nLim > nSavedGames)
		nLim = nSavedGames;

	ASSERT(nFirstSavedGame == 0 || nFirstSavedGame < nLim);

	float x = 0.0f;
	for (int i = nFirstSavedGame; i < nLim; i += 1)
	{
		D3DXMATRIX mat2;
		D3DXMatrixTranslation(&mat2, x, y, 0.0f);
		D3DXMatrixMultiply(&mat2, pMatrix, &mat2);

		// Felt cluttered with the smaller orb on each object
		//RenderNodeAt(m_smallIcon, &mat2);

		TCHAR szBuf [MAX_PATH];
		if (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle)
		{
			g_titles[m_curDevUnit].GetSavedGameImageName(nTitle, i, szBuf);
			g_szCurTitleImage = szBuf;
			RenderNodeAt(m_SavedIconPanel, &mat2);
		}
		else  // is a soundtrack
		{
			_tcscpy(szBuf, _T("soundtracksave64.tga"));
			g_szCurTitleImage = szBuf;
			RenderNodeAt(m_SoundtrackIconPanel, &mat2);
		}
		
		g_szCurTitleImage = NULL;

		if (!m_detachIcon && m_smallIconHilite != NULL && nTitle == m_curTitle && i == m_curSavedGame)
			RenderNodeAt(m_iconRing, &mat2);

		x += m_smallIconSpacing;
	}
}

void CSavedGameGrid::Render()
{
	if (m_header == NULL || m_firstRow == NULL || m_secondRow == NULL || m_otherRow == NULL)
		return;

	if (m_curDevUnit == -1 || !g_titles[m_curDevUnit].IsValid() || g_titles[m_curDevUnit].IsDirty())
		return;

    if (!m_isActive || m_busy)
        return;

	RenderLoop(true);
}

float CSavedGameGrid::RenderLoop(bool bRender)
{
	D3DXMATRIX mat, mat2, scrollMat;
	D3DXVECTOR3 v(-1.0f, 0.0f, 0.0f);
	D3DXMatrixRotationAxis(&mat, &v,  -1.571f);
	D3DXMatrixScaling(&mat2, 0.05942f, 0.05942f, 0.05942f);
	D3DXMatrixMultiply(&mat, &mat, &mat2);

	float y = m_scroll;
	float yLimit = -1.25f;

	int nTitleCount = GetTitleCount();

	int initLoop;
	if(m_curDevUnit == 8)  // do we render the memory panel at the top of the memory list
		initLoop = 0;
	else
		initLoop = -1;

	for (int nTitle = initLoop; nTitle < nTitleCount && (!bRender || y > yLimit); nTitle += 1)
	{
		float nEffectAlphaSave = g_nEffectAlpha;
		int nSavedGames = 0;

		// Check how many saved games (or soundtracks) this title has
		if (nTitle >= 0)
		{
			if (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle)
				nSavedGames = GetSavedGameCount(nTitle);
			else
				nSavedGames = m_nSoundtrackCount;
		}

		int nRowCount = (nSavedGames + m_iconsPerRow - 1) / m_iconsPerRow;

		int nIconRowScroll = 0;
		if (nTitle == m_curTitle)
		{
			// we keep track of the scroll position for the current title
			nIconRowScroll = m_iconRowScroll;
		}
		else if (nTitle < m_curTitle)
		{
			// this title is above the current one; show it scrolled to its bottom
			nIconRowScroll = nRowCount - VISIBLE_ICON_ROWS;
			if (nIconRowScroll < 0)
				nIconRowScroll = 0;
		}

		if (bRender)
		{
			float nSelectedAmount = 0.0f;
			float t = (float) (XAppGetNow() - m_timeScroll) / 0.25f;
			if (t > 1.0f)
				t = 1.0f;

			if (nTitle == m_curTitle)
			{
				if (m_timeScroll != 0.0f)
					nSelectedAmount = t;
				else
					nSelectedAmount = 1.0f;
			}
			else if (nTitle == m_curTitleLast)
			{
				if (m_timeScroll != 0.0f)
					nSelectedAmount = 1.0f - t;
			}

			g_nEffectAlpha *= 0.5f + (0.5f * nSelectedAmount);
		}
		else if (nTitle == m_curTitle)
		{
			return y - m_scroll;
		}

		// Render main Title Pod
		if (bRender && y - 0.25f < 0.5f && m_pod != NULL)
		{
			TCHAR szBuf [MAX_PATH];

			// Determine the texture for the Icon
			if(nTitle == -1) // Memory Unit
			{
				_tcscpy(szBuf, _T("memoryUnit128.tga"));
			}
			else if (nTitle >= 0 && (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle))
			{
				if (nTitle == m_curTitle && m_detachIcon && m_curSavedGame != -1)
				{
					g_titles[m_curDevUnit].GetSavedGameImageName(nTitle, m_curSavedGame, szBuf);
				}
				else
				{
					MakePath(szBuf, g_titles[m_curDevUnit].GetUData(), GetTitleID2(nTitle));
					MakePath(szBuf, szBuf, szTitleImageXBX);

					if (!DoesFileExist(szBuf)) //Title doesn't have an associated image
					{
#ifdef COOL_XDASH
						_tcscpy(szBuf, _T("xboxlogo128.xbx.cool"));
#else
						_tcscpy(szBuf, _T("xboxlogo128.xbx"));
#endif
					}
				}
			}
			else  // title is a soundtrack orb
			{
				_tcscpy(szBuf, _T("soundtracksave3.tga"));
			}

			g_szCurTitleImage = szBuf;

			float nEffectAlphaSave2 = g_nEffectAlpha;

			// Draw pod
			bool bRenderNormalPod = true;
			bool bRenderHackPod = false;
			bool bRenderHilite = false;
			bool bRenderMU = false;
			bool bRenderSoundtrack = false;

			if (nTitle == -1)  // do we render the MU in it's space?
				bRenderMU = true;

			if (nTitle == m_nSoundtrackTitle) // do we render the soundtrack icon?
				bRenderSoundtrack = true;

			if (nTitle == m_curTitle && m_scroll == m_nScrollTo)
			{
				bRenderNormalPod = false;
				bRenderHackPod = true;
				bRenderHilite = !m_detachIcon && m_podHilite != NULL && m_curSavedGame == -1;

				if (nTitle > -1 && nTitle == m_nDeletedTitle)
				{
					float t = (float) (XAppGetNow() - m_timeOfDelete) / 1.0f;

					if (t >= 1.0f)
					{
						m_timeOfDelete = 0.0f;
						m_nDeletedTitle = -1;
						bMatrixHackValid = false;
					}
					else
					{
						g_nEffectAlpha *= 1.0f - t;
						g_szCurTitleImage = NULL;
						bMatrixHackValid = true;
						bRenderHilite = false;
						bRenderNormalPod = true;
					}
				}
			}

			if (bRenderHackPod)
			{
				if (bMatrixHackValid)
				{
					XAppPushWorld();
					XAppIdentityWorld();
					XAppMultWorld(&matrixHack);

					XAppUpdateWorld();

					m_pod->Render();
					if(bRenderSoundtrack)
						m_podSoundtrackPanel->Render();
					else
						m_podSavePanel->Render();

					if (bRenderHilite)
						m_podRing->Render();

					XAppPopWorld();
				}
				else
				{
					D3DXMatrixTranslation(&mat2, -0.3292f, y, -0.0271f);
					D3DXMatrixMultiply(&mat2, &mat, &mat2);

					XAppPushWorld();
					XAppMultWorld(&mat2);
					matrixHack = *XAppGetWorld();
					bMatrixHackValid = true;

					XAppUpdateWorld();

					m_pod->Render();
					if(bRenderSoundtrack)
						m_podSoundtrackPanel->Render();
					else
						m_podSavePanel->Render();

					if (bRenderHilite)
						m_podRing->Render();

					XAppPopWorld();
				}
			}
			
			g_nEffectAlpha = nEffectAlphaSave2;
			g_szCurTitleImage = szBuf;

			if (bRenderNormalPod)
			{
				D3DXMatrixTranslation(&mat2, -0.3292f, y, -0.0271f);
				D3DXMatrixMultiply(&mat2, &mat, &mat2);
				RenderNodeAt(m_pod, &mat2);
				if(bRenderSoundtrack)
					RenderNodeAt(m_podSoundtrackPanel, &mat2);
				else
					RenderNodeAt(m_podSavePanel, &mat2);

			}

			g_szCurTitleImage = NULL;
		}

		// Draw header
		{
			if (bRender && y - 0.25f < 0.5f)
			{
				D3DXMatrixTranslation(&mat2, -0.3292f, y, -0.0271f);
				D3DXMatrixMultiply(&mat2, &mat, &mat2);

				if(nTitle >= 0 && nTitle == m_curTitle)      //is a game title or soundtrack
					RenderNodeAt(m_hiliteHeader, &mat2);
				else if(nTitle >= 0)
					RenderNodeAt(m_header, &mat2);
				else if(nTitle < 0 && nTitle == m_curTitle) // the title is the memory unit
					RenderNodeAt(m_MUhiliteHeader, &mat2);
				else if(nTitle < 0)
					RenderNodeAt(m_MUheader, &mat2);

				// Draw text
				if(m_renderIcons)  // are we on the proper screen?
				{
					XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
					XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
					XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
					XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
					XAppSetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
#ifdef COOL_XDASH
					XAppSetRenderState(D3DRS_TEXTUREFACTOR, (nTitle == m_curTitle) ? D3DCOLOR_RGBA(170, 170, 170, 255) : D3DCOLOR_RGBA(25, 114, 201, 255));
#else
					XAppSetRenderState(D3DRS_TEXTUREFACTOR, (nTitle == m_curTitle) ? D3DCOLOR_RGBA(170, 170, 170, 255) : D3DCOLOR_RGBA(140, 201, 25, 255));
#endif

					D3DXMATRIX mat3;
					//D3DXMatrixScaling(&mat3, 0.05942f, 0.05942f, 0.05942f);
					D3DXMatrixScaling(&mat3, 0.06442f, 0.06442f, 0.06442f);
					D3DXMatrixTranslation(&mat2, -0.3292f - 0.05942f, y + 0.05942f, -0.0271f + (0.6f * 0.05942f));
					D3DXMatrixMultiply(&mat2, &mat3, &mat2);

					TCHAR szBuf [256];
					GetTitleName2(nTitle, szBuf);
					RenderNodeAt(GetTextNode(szBuf, -11.2f), &mat2);
				}

				if (nIconRowScroll > 0)
				{
					// Draw the up arrow
					D3DXMatrixTranslation(&mat2, -0.17f, (y - 0.07f), 0.0f);
					D3DXMatrixMultiply(&mat2, &mat, &mat2);
					scrollMat = mat2;
					//RenderNodeAt(m_moreUp, &mat2);
				}
			}

			y -= 0.0092f;
		}

		// Draw first icon row
		{
			if (bRender && y - 0.25f < 0.5f)
			{
				D3DXMatrixTranslation(&mat2, -0.3292f, y, 0.01144f);
				D3DXMatrixMultiply(&mat2, &mat, &mat2);
				if(nTitle >= 0)  //is a game title or soundtrack
					RenderNodeAt(m_firstRow, &mat2);
				else  // the title is a memory unit
					RenderNodeAt(m_firstMURow, &mat2);

				if (nIconRowScroll > 0)
				{
					// Draw the up arrow
					RenderNodeAt(m_moreUp, &scrollMat);
				}

				RenderIconRow(&mat, y, nTitle, nIconRowScroll * m_iconsPerRow, nSavedGames);
			}

			y -= 0.2455f;
		}

		if (nSavedGames > m_iconsPerRow)
		{
			if (bRender && y - 0.25f < 0.5f)
			{
				D3DXMatrixTranslation(&mat2, -0.3301f, y, 0.01144f);
				D3DXMatrixMultiply(&mat2, &mat, &mat2);
				RenderNodeAt(m_secondRow, &mat2);
				RenderIconRow(&mat, y, nTitle, (nIconRowScroll + 1) * m_iconsPerRow, nSavedGames);
			}

			y -= 0.24499f;

			if (nSavedGames > m_iconsPerRow * 2)
			{
				for (int nRow = 2; nRow < (nRowCount - nIconRowScroll) && nRow < VISIBLE_ICON_ROWS && (!bRender || y > yLimit); nRow += 1)
				{
					if (bRender && y - 0.25f < 0.5f)
					{
						D3DXMatrixTranslation(&mat2, -0.3412f, y, 0.01144f);
						D3DXMatrixMultiply(&mat2, &mat, &mat2);
						RenderNodeAt(m_otherRow, &mat2);
						if (nRow == VISIBLE_ICON_ROWS - 1 && (nIconRowScroll + nRow) < nRowCount - 1)
						{
							D3DXMatrixTranslation(&mat2, -0.17f, (y - 0.015f), 0.0f);
							D3DXMatrixMultiply(&mat2, &mat, &mat2);
							RenderNodeAt(m_moreDown, &mat2);
						}
						RenderIconRow(&mat, y, nTitle, (nIconRowScroll + nRow) * m_iconsPerRow, nSavedGames);
					}

					y -= 0.24499f;
				}
			}
		}

		// Prepare for next title area
		y -= 0.09f;
		g_nEffectAlpha = nEffectAlphaSave;
	}

	return 0.0f;
}

void CSavedGameGrid::SelectTitle(int nTitle, bool bInstantScroll/*=false*/)
{
	m_curTitleLast = m_curTitle;
	m_curTitle = nTitle;

    if (g_titles[m_curDevUnit].IsDirty())
    {
        return;
    }

/*
	if (m_curTitle < 0)
	{
		m_curTitle = -1;
		m_curSavedGame = -1;
		m_nPrefColumn = -1;
		m_nScrollTo = 0.0f;
		m_scroll = 0.0f;
		m_timeScroll = 0.0f;
		m_iconRowScroll = 0;
		m_detachIcon = false;
		m_nTotalBlocks = -1;
		m_freeBlocks = -1;
	}
	else
*/
	{
		int nTitleCount = GetTitleCount();
		if (m_curTitle >= nTitleCount)
			m_curTitle = nTitleCount - 1;

        int nSavedGames = GetSavedGameCount(m_curTitle);
		int nRowCount = (nSavedGames + m_iconsPerRow - 1) / m_iconsPerRow;

		// BLOCK: Make sure the title is scrolled into view
		{
			float y = -RenderLoop(false);

			if (y != m_nScrollTo)
			{
				if (bInstantScroll)
				{
					m_nScrollTo = m_scroll = y;
					m_timeScroll = 0.001f;
				}
				else
				{
					m_nScrollTo = y;
					m_timeScroll = XAppGetNow();
				}
			}
		}

		// Select the right save icon based on the preferred column and
		// the direction the selection moved..
		if ((m_nPrefColumn > -1) && (m_curSavedGame != -1))
		{
			m_nPrefColumn = m_curSavedGame % m_iconsPerRow;
		}
		else if(m_nPrefColumn != -1)
		{
			m_nPrefColumn = 0;
		}
		
		if (m_nPrefColumn == -1)
		{
			m_curSavedGame = -1;
			m_iconRowScroll = 0;
		}
		else
		{
			if (m_curTitle > m_curTitleLast)
			{
				// going down...
				
				//if(m_nPrefColumn == 0)   // pop back out to the first saved game
				m_curSavedGame = m_nPrefColumn;

				if (m_curSavedGame > nSavedGames - 1)
					m_curSavedGame = nSavedGames - 1;

				m_iconRowScroll = 0;
			}
			else
			{
				// going up
				if (nSavedGames == 0)
				{
					m_curSavedGame = -1;
				}
				else
				{
					m_curSavedGame = m_nPrefColumn + (nRowCount - 1) * m_iconsPerRow;
					ASSERT(m_curSavedGame >= 0);
					if (m_curSavedGame > nSavedGames - 1)
						m_curSavedGame = nSavedGames - 1;
				}

				m_iconRowScroll = nRowCount - VISIBLE_ICON_ROWS;
				if (m_iconRowScroll < 0)
					m_iconRowScroll = 0;
			}
		}
	}
}

void CSavedGameGrid::selectUp()
{
	if (m_curSavedGame != -1)
	{
		int nIconRow = m_curSavedGame / m_iconsPerRow;
		if (nIconRow > 0)
		{
			nIconRow -= 1;
			m_curSavedGame = nIconRow * m_iconsPerRow + m_nPrefColumn;

			if (nIconRow < m_iconRowScroll)
				m_iconRowScroll = nIconRow;

			m_nPrefColumn = (m_curSavedGame % m_iconsPerRow);
			CallFunction(this, _T("OnSelChange"));
			g_pulseStartTime = XAppGetNow();
			return;
		}
	}

	// Only allow the user to navigate to the memory unit panels
	int initLoop;
	if(m_curDevUnit == 8)
		initLoop = 0;
	else
		initLoop = -1;

	if (m_curTitle > initLoop)
	{
		SelectTitle(m_curTitle - 1);
		CallFunction(this, _T("OnSelChange"));
		g_pulseStartTime = XAppGetNow();
	}
	m_nPrefColumn = (m_curSavedGame % m_iconsPerRow);
}

void CSavedGameGrid::selectDown()
{
	if (m_curSavedGame != -1)
	{
        int nSavedGameCount = GetSavedGameCount(m_curTitle);
		int nIconRow = m_curSavedGame / m_iconsPerRow;
		int nRowCount = (nSavedGameCount + m_iconsPerRow - 1) / m_iconsPerRow;

		if (nIconRow < nRowCount - 1)
		{
			nIconRow += 1;
			m_curSavedGame += m_iconsPerRow;
			if (m_curSavedGame > nSavedGameCount - 1)
				m_curSavedGame = nSavedGameCount - 1;

			if (nIconRow >= m_iconRowScroll + VISIBLE_ICON_ROWS - 1)
				m_iconRowScroll = nIconRow - (VISIBLE_ICON_ROWS - 1);

			m_nPrefColumn = (m_curSavedGame % m_iconsPerRow);
			CallFunction(this, _T("OnSelChange"));
			g_pulseStartTime = XAppGetNow();
			return;
		}
	}

	int nTitleCount = GetTitleCount();
	if (m_curTitle < nTitleCount - 1)
	{
		SelectTitle(m_curTitle + 1);
		CallFunction(this, _T("OnSelChange"));
		g_pulseStartTime = XAppGetNow();
	}
	m_nPrefColumn = (m_curSavedGame % m_iconsPerRow);
}

void CSavedGameGrid::selectLeft()
{
	int oldTitle = m_curTitle;
	int oldSavedGame = m_curSavedGame;

	if (m_curSavedGame >= 0)
	{
		// if the user is in the left most column, jump to title orb
		if (m_nPrefColumn == 0)
		{
			m_nPrefColumn = -1;
			m_curSavedGame = -1;
			m_iconRowScroll = 0;
		}
		else
		{
			m_curSavedGame -= 1;
			m_nPrefColumn = (m_curSavedGame % m_iconsPerRow);
		}

	}

	if (m_curTitle != oldTitle || m_curSavedGame != oldSavedGame)
	{
		CallFunction(this, _T("OnSelChange"));
		g_pulseStartTime = XAppGetNow();
	}
}

void CSavedGameGrid::selectRight()
{
	int oldTitle = m_curTitle;
	int oldSavedGame = m_curSavedGame;

    int nSavedGameCount = GetSavedGameCount(m_curTitle);
	if ((m_curSavedGame < nSavedGameCount - 1) && (m_nPrefColumn < VISIBLE_ICON_ROWS))
	{
		m_curSavedGame += 1;
		m_nPrefColumn = (m_curSavedGame % m_iconsPerRow);

		if (m_curSavedGame >= (m_iconRowScroll + VISIBLE_ICON_ROWS) * m_iconsPerRow)
			m_iconRowScroll = m_curSavedGame / m_iconsPerRow - (VISIBLE_ICON_ROWS - 1);
	}

	if (m_curTitle != oldTitle || m_curSavedGame != oldSavedGame)
	{
		CallFunction(this, _T("OnSelChange"));
		g_pulseStartTime = XAppGetNow();
	}
}

void CSavedGameGrid::setSelImage()
{
	g_szSelTitleImage = NULL;

	if(m_curTitle == -1) // Memory Unit
	{
		_tcscpy(szSelectionBuf, _T("memoryUnit128.tga"));
	}
	else if(m_curTitle >= 0 && (m_nSoundtrackTitle < 0 || m_curTitle < m_nSoundtrackTitle)) // Game title
	{
		if(m_curSavedGame != -1)
		{
			g_titles[m_curDevUnit].GetSavedGameImageName(m_curTitle, m_curSavedGame, szSelectionBuf);
		}
		else  // Title
		{
			MakePath(szSelectionBuf, g_titles[m_curDevUnit].GetUData(), GetTitleID2(m_curTitle));
			MakePath(szSelectionBuf, szSelectionBuf, szTitleImageXBX);

			if (!DoesFileExist(szSelectionBuf)) //Title doesn't have an associated image
			{
#ifdef COOL_XDASH
				_tcscpy(szSelectionBuf, _T("xboxlogo128.xbx.cool"));
#else
				_tcscpy(szSelectionBuf, _T("xboxlogo128.xbx"));
#endif
			}
		}
	}
	else //soundtrack
	{
		_tcscpy(szSelectionBuf, _T("soundtracksave3.tga"));
	}
	
	g_szSelTitleImage = szSelectionBuf;
}

CStrObject* CSavedGameGrid::FormatSavedGameName()
{
	if (m_curSavedGame < 0)
		return new CStrObject; // empty string

	if (m_nSoundtrackTitle >= 0 && m_curTitle == m_nSoundtrackTitle)
		return new CStrObject(GetSoundtrackName(m_curSavedGame));

	TCHAR szSavedGamePath [MAX_PATH];
	if (!GetSavedGamePath(szSavedGamePath, m_curTitle, m_curSavedGame))
		return new CStrObject; // empty string

	MakePath(szSavedGamePath, szSavedGamePath, szSaveDataXBX);

	TCHAR szSaveName [64];
    TCHAR szLangCode[MAX_LANGUAGE_CODE_LEN];
    TCHAR szTranslate[MAX_TRANSLATE_LEN];
	CSettingsFile settings;
	if (!settings.Open(szSavedGamePath) || !settings.GetValue(GetLanguageCode(szLangCode), _T("Name"), szSaveName, countof(szSaveName)))
		return new CStrObject(Translate(_T("Broken Save"), szTranslate));

	return new CStrObject(szSaveName);
}

CStrObject* CSavedGameGrid::FormatSavedGameTime()
{
	if (m_nSoundtrackTitle >= 0 && m_curTitle == m_nSoundtrackTitle)
		return new CStrObject; // empty string

	TCHAR szPath [MAX_PATH];
	if (m_curSavedGame < 0 || !GetSavedGamePath(szPath, m_curTitle, m_curSavedGame))
		return new CStrObject; // empty string

	HANDLE hFile = XAppCreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return new CStrObject; // empty string

	FILETIME ft;
	VERIFY(GetFileTime(hFile, NULL, NULL, &ft));
	CloseHandle(hFile);

	FILETIME lft;
	VERIFY(FileTimeToLocalFileTime(&ft, &lft));

	SYSTEMTIME st;
	VERIFY(FileTimeToSystemTime(&lft, &st));

	TCHAR szBuf [32];
	FormatTime(szBuf, countof(szBuf), &st);

	return new CStrObject(szBuf);
}

int CSavedGameGrid::GetSavedGameCount(int nTitle)
{
	ASSERT(m_curDevUnit >= 0 && m_curDevUnit <= 8);

	if (nTitle < 0)
		return 0;

    if (g_titles[m_curDevUnit].IsDirty())
    {
        return 0;
    }

	if (m_nSoundtrackTitle < 0 || nTitle < m_nSoundtrackTitle)
        return g_titles[m_curDevUnit].GetSavedGameCount(nTitle);

	return m_nSoundtrackCount;
}

CStrObject* CSavedGameGrid::FormatSavedGameSize()
{
	int nBlocks;

	if (m_nSoundtrackTitle >= 0 && m_curTitle == m_nSoundtrackTitle)
	{
		nBlocks = GetSoundtrackSize(m_curSavedGame);
	}
	else
	{
		TCHAR szSavedGameDir [MAX_PATH];

		if (m_curSavedGame < 0 || !GetSavedGamePath(szSavedGameDir, m_curTitle, m_curSavedGame))
			return new CStrObject; // empty string

        nBlocks = m_nCacheSavedGameSize;
	}

	m_gameBlocks = nBlocks;

	TCHAR szBuf [16];
	FormatInteger(szBuf, nBlocks);
	return new CStrObject(szBuf);
}

CStrObject* CSavedGameGrid::FormatTitleSize()
{
    int nBlocks = m_nCacheTitleSize;

	TCHAR szBuf [16];
	FormatInteger(szBuf, nBlocks);
	return new CStrObject(szBuf);
}

bool CSavedGameGrid::GetSavedGamePath(TCHAR* szBuf, int nTitle, int nSavedGame)
{
    if (!g_titles[m_curDevUnit].IsValid())
    {
        return false;
    }

	MakePath(szBuf, g_titles[m_curDevUnit].GetUData(), GetTitleID2(nTitle));
	MakePath(szBuf, szBuf, GetSavedGameID2(nTitle, nSavedGame));
	return true;
}

CStrObject* CSavedGameGrid::GetSavedGamePath(int nTitle, int nSavedGame)
{
	TCHAR szBuf [MAX_PATH];

	szBuf[0] = (m_curDevUnit == Dev0) ? 'U' : g_titles[m_curDevUnit].GetUData()[0];
	szBuf[1] = ':';
	szBuf[2] = '\\';
	_tcscpy(szBuf + 3, GetSavedGameID2(nTitle, nSavedGame));

	return new CStrObject(szBuf);
}

CStrObject* CSavedGameGrid::FormatFreeBlocks()
{
	TCHAR szBuf [16];
	FormatBlocks (szBuf, m_freeBlocks);
	return new CStrObject(szBuf);
}

CStrObject* CSavedGameGrid::FormatTotalBlocks()
{
	TCHAR szBuf [16];
	FormatBlocks(szBuf, m_nTotalBlocks);
	return new CStrObject(szBuf);
}

int CSavedGameGrid::GetTotalBlocks()
{
	return m_nTotalBlocks;
}

int CSavedGameGrid::CanDetachIcon()
{
	return m_timeScroll == 0.0f && bMatrixHackValid;
}

void CSavedGameGrid::StartCopy(int destDevUnit)
{
	if (m_curSavedGame == -1)
	{
		TRACE(_T("Attempted to copy a title!\n"));
		CallFunction(this, _T("OnCopyComplete"));
		return;
	}

	int nBlocks = 0;

	// REVIEW: If we have muti-select, do this for each item...
	{
		TCHAR szBuf [MAX_PATH];
		VERIFY(GetSavedGamePath(szBuf, m_curTitle, m_curSavedGame));
		nBlocks = GetDirectoryBlocks(szBuf, BLOCK_SIZE, true, NULL);

		// BLOCK: See if we need the title data XBX file...
		{
			MakePath(szBuf, g_titles[destDevUnit].GetUData(), GetTitleID2(m_curTitle));
			MakePath(szBuf, szBuf, szTitleDataXBX);

			if (!DoesFileExist(szBuf))
			{
				MakePath(szBuf, g_titles[m_curDevUnit].GetUData(), GetTitleID2(m_curTitle));
				MakePath(szBuf, szBuf, szTitleDataXBX);
				nBlocks += GetFileBlocks(szBuf, BLOCK_SIZE);
			}
		}

		// BLOCK: See if we need the title image XBX file...
		{
			MakePath(szBuf, g_titles[destDevUnit].GetUData(), GetTitleID2(m_curTitle));
			MakePath(szBuf, szBuf, szTitleImageXBX);

			if (!DoesFileExist(szBuf))
			{
				MakePath(szBuf, g_titles[m_curDevUnit].GetUData(), GetTitleID2(m_curTitle));
				MakePath(szBuf, szBuf, szTitleImageXBX);
				nBlocks += GetFileBlocks(szBuf, BLOCK_SIZE);
			}
		}

		// BLOCK: See if we need the default save image XBX file...
		{
			MakePath(szBuf, g_titles[destDevUnit].GetUData(), GetTitleID2(m_curTitle));
			MakePath(szBuf, szBuf, szSaveImageXBX);

			if (!DoesFileExist(szBuf))
			{
				MakePath(szBuf, g_titles[m_curDevUnit].GetUData(), GetTitleID2(m_curTitle));
				MakePath(szBuf, szBuf, szSaveImageXBX);
				nBlocks += GetFileBlocks(szBuf, BLOCK_SIZE);
			}
		}
	}

	m_bCopying = true;
    m_timeCopyingStarted = XAppGetNow();
	m_copyProgress = 0.0f;
	m_strProgress = GetTickCount();
	m_periodStatus = 0;
	m_szStatus[0] = 0;
	Translate(_T("Copying"), m_szStatus);

	theGameCopier.SetSource(m_curDevUnit);
	theGameCopier.SetDestination(destDevUnit);
	theGameCopier.AddGame(GetTitleID2(m_curTitle), GetSavedGameID2(m_curTitle, m_curSavedGame), GetSavedGameTime(m_curTitle, m_curSavedGame), nBlocks);
	theGameCopier.Start();
}

static DWORD ParseTitleID(const TCHAR* szID)
{
	if (_tcslen(szID) != 8)
		return 0xffffffff; // Invalid ID

	DWORD dw = 0;
	const TCHAR* pch = szID;
	while (*pch != 0)
	{
		DWORD dwDigit;

		if (*pch >= '0' && *pch <= '9')
			dwDigit = *pch - '0';
		else if (*pch >= 'a' && *pch <= 'f')
			dwDigit = 10 + *pch - 'a';
		else if (*pch >= 'A' && *pch <= 'F')
			dwDigit = 10 + *pch - 'A';
		else
			return 0xffffffff; // Invalid ID

		dw = (dw << 4) + dwDigit;

		pch += 1;
	}

	return dw;
}

void WINAPI CSavedGameGrid::DeleteThread(CSavedGameGrid* p)
{
	ASSERT(p->m_curTitle >= 0);

    //
    //  Bug 6120: If we are asked to delete the very
    //  last soundtrack, then switch to the case of
    //  deleting all sound tracks.
    //
	if(p->m_curTitle == p->m_nSoundtrackTitle && 1==p->m_nSoundtrackCount)
    {
        p->m_curSavedGame = -1;
    }

	if (p->m_curSavedGame == -1)
	{
		// Remove an entire title...

		if (p->m_curTitle == p->m_nSoundtrackTitle)
		{
			DeleteAllSoundtracks();
			p->m_nSoundtrackTitle = -1;
			p->m_nSoundtrackCount = 0;
		}
		else
		{
			TCHAR szTitleID[MAX_PATH];
            TCHAR szPublisherID[16];
			TCHAR szBuf [MAX_PATH];

            lstrcpyn(szTitleID, p->GetTitleID2(p->m_curTitle), countof(szTitleID));
            lstrcpyn(szPublisherID, szTitleID, countof(szPublisherID));

            // Strip off low word so that it contains only publisher ID
            szPublisherID[4] = 0;

            g_titles[p->m_curDevUnit].RemoveTitle(p->m_curTitle);

            // Delete shared publisher directory if it was the last title from this publisher
            if (!g_titles[p->m_curDevUnit].IsPublisherExists(szPublisherID))
            {
                lstrcat(szPublisherID, _T("ffff"));
                MakePath(szBuf, g_titles[p->m_curDevUnit].GetTData(), szPublisherID);
                TRACE(_T("Cleaning up shared publisher directory: %s\n"), szBuf);
                theGameCopier.DeleteDirectory(szBuf);
            }

            // Delete saved game
			MakePath(szBuf, g_titles[p->m_curDevUnit].GetUData(), szTitleID);
			theGameCopier.DeleteDirectory(szBuf);

			if (p->m_curDevUnit == Dev0) // only the hard drive...
			{
                // Delete any data in TDATA
				MakePath(szBuf, g_titles[p->m_curDevUnit].GetTData(), szTitleID);
				theGameCopier.DeleteDirectory(szBuf);
				XapiDeleteCachePartition(ParseTitleID(szTitleID));
			}

			if (p->m_nSoundtrackTitle >= 0)
				p->m_nSoundtrackTitle -= 1;
		}

		p->m_timeOfDelete = XAppGetNow();
		p->m_nDeletedTitle = p->m_curTitle;
		ASSERT(bMatrixHackValid);

		// Fixup selection...
		p->SelectTitle(p->m_curTitle, true);
	}
	else
	{
		if (p->m_curTitle == p->m_nSoundtrackTitle)
		{
            DeleteSoundtrack(p->m_curSavedGame);
			p->m_nSoundtrackCount -= 1;
		}
		else
		{
			// Delete a saved game...

			TCHAR szBuf [MAX_PATH];
			VERIFY(p->GetSavedGamePath(szBuf, p->m_curTitle, p->m_curSavedGame));

			theGameCopier.m_error = false;
			theGameCopier.DeleteDirectory(szBuf);

			g_titles[p->m_curDevUnit].RemoveSavedGame(p->m_curTitle, p->m_curSavedGame);
		}

		// Fixup selection...
        int nSavedGameCount = p->GetSavedGameCount(p->m_curTitle);
		if (p->m_curSavedGame > nSavedGameCount - 1)
			p->m_curSavedGame = nSavedGameCount - 1;
		p->m_nPrefColumn = (p->m_curSavedGame % p->m_iconsPerRow);

        // Also fix up the scroll position (Bug 6090)
        // If not at the top and the last visible row
        // would now be empty scroll up.
        if(p->m_iconRowScroll && ((p->m_iconRowScroll + VISIBLE_ICON_ROWS - 1)*p->m_iconsPerRow >= nSavedGameCount))
        {
            p->m_iconRowScroll--;
        }
	}

    // Invalidate cache
    p->m_nCacheTitleSize = -1;
    p->m_nCacheSavedGameSize = -1;
}

void CSavedGameGrid::StartDelete()
{
    ASSERT(m_hDeleteThread == NULL);
    ASSERT(!m_bDeleting);

    // Cancel previous pending query
    if (m_bSavedGameQueryPending)
    {
        SignalObjectAndWait(m_hCancelEvent, m_hStopEvent, INFINITE, FALSE);
    }

    m_hDeleteThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)DeleteThread, this, 0, 0);

    if (!m_hDeleteThread)
    {
        DeleteThread(this);
        VERIFY(CallFunction(this, _T("OnDeleteEnd")));
        VERIFY(CallFunction(this, _T("OnSelChange")));
        g_pulseStartTime = XAppGetNow();
    }
    else
    {
        m_bDeleting = true;
    }
}

int CSavedGameGrid::CanCopy()
{
	if (m_curTitle < 0 || IsSoundtrackSelected())
		return false; // can't copy devices or soundtracks

	TCHAR szSavedGamePath [MAX_PATH];

	if (m_curSavedGame < 0 || !GetSavedGamePath(szSavedGamePath, m_curTitle, m_curSavedGame))
		return false; // can't copy saves when one isn't selected

	MakePath(szSavedGamePath, szSavedGamePath, szSaveDataXBX);

	CSettingsFile settings;
	if (!settings.Open(szSavedGamePath))
		return false; // can't copy broken saves

	TCHAR szSaveName [64];
    TCHAR szLangCode[MAX_LANGUAGE_CODE_LEN];
	if (!settings.GetValue(GetLanguageCode(szLangCode), _T("Name"), szSaveName, countof(szSaveName)))
		return false; // can't copy broken saved game

	if(g_titles[m_curDevUnit].IsBroken(m_curTitle))
		return false; // can't copy a saved game in a broken title

	TCHAR szNoCopy [64];
	if (!settings.GetValue(GetLanguageCode(szLangCode), _T("NoCopy"), szNoCopy, countof(szNoCopy)))
		return true; // can copy if it doesn't say otherwise

	return _ttoi(szNoCopy) == 0;
}

int CSavedGameGrid::IsSoundtrackSelected()
{
	return (m_nSoundtrackTitle >= 0 && m_curTitle == m_nSoundtrackTitle);
}

int CSavedGameGrid::IsDevUnitReady(int nUnit)
{
    return !g_titles[nUnit].IsDirty();
}

int CSavedGameGrid::DoesSavedGameExists(int destDevUnit)
{
    if (m_curSavedGame < 0)
    {
        return false;
    }

	const TCHAR* szRoot = g_titles[destDevUnit].GetUData();
    ASSERT(szRoot[0] != 0);

    TCHAR szBuf[MAX_PATH];
	MakePath(szBuf, g_titles[destDevUnit].GetUData(), GetTitleID2(m_curTitle));
	MakePath(szBuf, szBuf, GetSavedGameID2(m_curTitle, m_curSavedGame));

    return DoesFileExist(szBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\settingsfile.h ===
#pragma once

class CSettingsFileValue
{
public:
	CSettingsFileValue();
	~CSettingsFileValue();

	CSettingsFileValue* m_pNextValue;
	TCHAR* m_szName;
	TCHAR* m_szValue;
};

class CSettingsFileSection
{
public:
	CSettingsFileSection();
	~CSettingsFileSection();

	CSettingsFileValue* FindValue(const TCHAR* szName);
	bool SetValue(const TCHAR* szName, const TCHAR* szValue);

	CSettingsFileSection* m_pNextSection;
	TCHAR* m_szName;
	CSettingsFileValue* m_pValueList;
};

class CSettingsFile
{
public:
	CSettingsFile();
	~CSettingsFile();

	bool OpenDir(const TCHAR* szDir);
	bool Open(const TCHAR* szFile);
	bool Close();
	void Cancel();
	bool Save();

	inline const TCHAR* GetFileName() const
	{
		return m_szFilePath;
	}

	bool GetValue(const TCHAR* szSection, const TCHAR* szName, TCHAR* szValueBuf, int cchValueBuf);
	void SetValue(const TCHAR* szSection, const TCHAR* szName, const TCHAR* szValue);

protected:
	CSettingsFileSection* FindSection(const TCHAR* szSection, bool bCreate = false);

	TCHAR* m_szFilePath;
	CSettingsFileSection* m_pSectionList;
	bool m_bDirty;

#ifdef _UNICODE
	bool m_bUnicode;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Sound.h ===
#pragma once

#include <dsound.h>

class CSoundSource
{
public:
	CSoundSource();
	~CSoundSource();

	HRESULT CreateBuffer(WAVEFORMATEX* pwfx, int nBufferBytes);
	HRESULT LoadBuffer(int nBufferPos, const void* pbSoundData, int nSoundBytes);
	HRESULT ClearBuffer();
	bool CanWrite();
	HRESULT Write(const void* pbSoundData, int nSoundBytes);
	HRESULT Play();
	void Stop();
	void Move(D3DVECTOR* pvPosition, D3DVECTOR* pvVelocity);

	HRESULT RestoreBuffers();

	LPDIRECTSOUNDBUFFER m_pDSBuffer;
	DWORD m_dwBufferBytes;
	DWORD m_dwBufferWrite;
	HANDLE m_hEvent;
	int m_nBuffersInUse;
	bool m_bBuffered;

	DS3DBUFFER m_dsBufferParams;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\smooth.cpp ===
#include "std.h"


inline bool equal(D3DXVECTOR3* a, D3DXVECTOR3* b)
{
	return (a->x == b->x && a->y == b->y && a->z == b->z);
}


static void calcnormvec(D3DXVECTOR3* facenormals, int facenum, int* faces, int fn, float thresh_value, D3DXVECTOR3* vertnormal)
{
	D3DXVECTOR3* facenormal = &facenormals[facenum];
	int currentface, i;
	float skalarpr;

	*vertnormal = *facenormal;

	for (i = 0; i < fn; i++)
	{
		currentface = faces[i];
		if (facenum != currentface)
		{
			skalarpr = D3DXVec3Dot(&facenormals[currentface], facenormal);
			if (skalarpr > thresh_value)
				*vertnormal += facenormals[currentface];
		}
	}
}


inline void normalize(D3DXVECTOR3* normal)
{
	D3DXVec3Normalize(normal, normal);
}

int autosmooth(
	int* coordindex, int numvertinds,  // in: coordIndex, no. of coordindices
	D3DXVECTOR3* facenormals, int numfaces,  // in: face normals (calculated by buildFacenormals), no. of faces
	float creaseAngle,  // in: crease angle
	D3DXVECTOR3* normallist, int* normalindex // out: list of normals and normal index (already allocated)
	)
{
	int* vertinds = coordindex;
	int* normalinds = (int*)normalindex;

	int maxvert = 0, i = numvertinds, fn = 0, same_normal = 0, normal_index = 0;
	int* vi = vertinds;
	int *facespervertex, *numfacespervertex, *normalspervertex, *numnormalspervertex;
	int curindex, j, found;
	float thresh_value = cosf(creaseAngle);

	// find maximum vertexindex
	while (i--)
	{
		if (*vi > maxvert)
			maxvert = *vi;
		vi++;
	}

	// create list of faces containing the vertices
	maxvert += 1;
	facespervertex = new int [numfaces * maxvert];

	numfacespervertex = new int [maxvert];
	ZeroMemory(numfacespervertex, sizeof (int) * maxvert);

	for (i = numvertinds, vi = vertinds; i--; vi++)
	{
		if (*vi >= 0)
		{
			facespervertex[*vi * numfaces + numfacespervertex[*vi]] = fn;
			numfacespervertex[*vi]++;
		}
		else
		{
			fn++;
		}
	}

	// create list of normals and normalindeces
	normalspervertex = new int [numfaces * maxvert];

	numnormalspervertex = new int [maxvert];
	ZeroMemory(numnormalspervertex, sizeof (int) * maxvert);

	fn = 0;
	for (i = 0; i < numvertinds; i++)
	{
		curindex = vertinds[i];
		if (curindex >= 0)
		{
			calcnormvec(facenormals, fn, facespervertex + (curindex * numfaces), numfacespervertex[curindex], thresh_value, &normallist[normal_index]);
			normalize(&normallist[normal_index]);

			found = 0;
			for (j = 0; j < numnormalspervertex[curindex] && !found; j++)
			{
				same_normal = normalspervertex[curindex * numfaces + j];
				found = equal(&normallist[same_normal], &normallist[normal_index]);
			}

			if (found)
			{
				normalinds[i] = same_normal;
			}
			else if ((normal_index > 0) && equal(&normallist[normal_index], &normallist[normal_index - 1]))
			{
				normalinds[i] = normal_index - 1;
			}
			else
			{
				normalinds[i] = normal_index;
				normalspervertex[curindex * numfaces + numnormalspervertex[curindex]] = normal_index;
				numnormalspervertex[curindex]++;
				normal_index++;
			}
		}
		else
		{
			fn++;
			normalinds[i] = -1;
		}
	}

	delete [] facespervertex;
	delete [] numfacespervertex;
	delete [] normalspervertex;
	delete [] numnormalspervertex; 

	return normal_index;
}

#if 0
{
	int ncoordinds = 3 * nTriangles;
	int* normalindex = new int [ncoordinds];
	D3DXVECTOR3 normals = new D3DXVECTOR3 [ncoordinds];
	int numnormals = autosmooth(coordinds, ncoordinds, facenormals, numfaces, creaseAngle, normals, normalindex);

	if (numnormals != ncoordinds)
	{
		// We shrunk the normals array, so reallocate it here...
		D3DXVECTOR3 normallist = new D3DXVECTOR3 [numnormals];
		CopyMemory(normallist, normals, sizeof (D3DXVECTOR3) * numnormals);
		delete [] normals;
		normals = normallist;
	}

	// Now normal [] contains all of the normals and numnormals contains the count of them...
	// normalindex [] contains a normal index per vertex
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Shape.h ===
#pragma once

class CMeshNode : public CNode
{
	DECLARE_NODE(CMeshNode, CNode)
public:
	CMeshNode();
	~CMeshNode();

	void Render();

	TCHAR* m_url;

	void load(const TCHAR* szFile);

	bool Initialize();
	virtual void Init();

	bool m_bDirty;
	XTIME m_renderTime;

	DWORD GetFVF();

	class CMeshCore* m_pMesh;
	bool m_bOwnMesh;

	static CMeshNode* c_pFirst;
	CMeshNode* m_pNext;

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};

class CAppearance : public CNode
{
	DECLARE_NODE(CAppearance, CNode)
public:
	CAppearance();
	~CAppearance();

	CNode* m_material;
	CNode* m_texture;

	void Render();
	void Advance(float nSeconds);

	DECLARE_NODE_PROPS()
};

class CShape : public CNode
{
	DECLARE_NODE(CShape, CNode)
public:
	CShape();
	~CShape();

	CNode* m_appearance;
	CNode* m_geometry;

	void Render();
	void GetBBox(BBox* pBBox);
	float GetRadius();
	void Advance(float nSeconds);

	D3DXVECTOR3 m_position;

	DECLARE_NODE_PROPS()
};

class CMaterial : public CNode
{
	DECLARE_NODE(CMaterial, CNode)
public:
	CMaterial();

	float m_ambientIntensity;
	D3DXVECTOR3 m_diffuseColor;
	D3DXVECTOR3 m_emissiveColor;
	float m_shininess;
	D3DXVECTOR3 m_specularColor;
	float m_transparency;

	D3DMATERIAL8 m_material;

	void Render();

	DECLARE_NODE_PROPS()
};

////////////////////////////////////////////////////////////////////////////


class CTransform : public CGroup
{
	DECLARE_NODE(CTransform, CGroup)
public:
	CTransform();

	D3DXQUATERNION m_rotation; // REVIEW: This is really a axis/angle in a D3DXVECTOR4

	D3DXVECTOR3 m_center;
	D3DXQUATERNION m_scaleOrientation;
	D3DXVECTOR3 m_scale;
	D3DXQUATERNION m_rotationQuat;
	D3DXVECTOR3 m_translation;

	D3DXVECTOR3 m_centerStart;
	D3DXQUATERNION m_scaleOrientationStart;
	D3DXVECTOR3 m_scaleStart;
	D3DXQUATERNION m_rotationStart;
	D3DXVECTOR3 m_translationStart;

	D3DXVECTOR3 m_centerEnd;
	D3DXQUATERNION m_scaleOrientationEnd;
	D3DXVECTOR3 m_scaleEnd;
	D3DXQUATERNION m_rotationEnd;
	D3DXVECTOR3 m_translationEnd;

	float m_alpha;
	float m_alphaStart;
	float m_alphaEnd;

	bool m_moving;

	BOOL m_bDirty;
	D3DXMATRIX m_matrix;

	float m_fade;

	void CalcMatrix();
	void Render();
	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);
	void OnLoad();

	void SetScale(float sx, float sy, float sz);
	void SetScaleOrientation(float x, float y, float z, float a);
	void SetTranslation(float x, float y, float z);
	void SetCenter(float x, float y, float z);
	void SetRotation(float x, float y, float z, float a);
	void SetAlpha(float a);
    void DisappearAfter(float t);

	float m_timeCenterStart;
	float m_timeScaleOrientationStart;
	XTIME m_timeScaleStart;
	XTIME m_timeRotationStart;
	XTIME m_timeTranslationStart;
	XTIME m_timeAlphaStart;
	XTIME m_timeToDisappear;

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Shape.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Shape.h"
#include "Runner.h"
#include "Texture.h"
#include "Level.h"
#include "Mesh.h"

extern class CMeshNode* g_pRenderMeshNode;

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("Shape", CShape, CNode)

START_NODE_PROPS(CShape, CNode)
	NODE_PROP(pt_node, CShape, appearance)
	NODE_PROP(pt_node, CShape, geometry)
END_NODE_PROPS()

CShape::CShape()
{
	m_appearance = NULL;
	m_geometry = NULL;
}

CShape::~CShape()
{
	if (m_appearance != NULL)
		m_appearance->Release();

	if (m_geometry != NULL)
		m_geometry->Release();
}

void CShape::Render()
{
	if (m_geometry == NULL)
		return;

	CMeshNode* pMeshNode = NULL;
	if (m_geometry->IsKindOf(NODE_CLASS(CMeshNode)))
	{
		pMeshNode = (CMeshNode*)m_geometry;
		
		if (pMeshNode->m_bDirty && !pMeshNode->Initialize())
			return;

		DWORD fvf = pMeshNode->GetFVF();
		if (fvf == 0)
			return;

		g_pRenderMeshNode = pMeshNode;

		XAppSetVertexShader(GetFixedFunctionShader(fvf));
	}

	if (m_appearance != NULL)
		m_appearance->Render();

	m_geometry->Render();

	g_pRenderMeshNode = NULL;

	// BLOCK: Cache this objects position in world space...
	{
		D3DXMATRIX mat;
		XAppGetTransform(D3DTS_WORLD, &mat);

		m_position.x = mat.m[3][0];
		m_position.y = mat.m[3][1];
		m_position.z = mat.m[3][2];
	}
}

void CShape::GetBBox(BBox* pBBox)
{
	if (m_geometry != NULL)
		m_geometry->GetBBox(pBBox);
	else
		CNode::GetBBox(pBBox);
}

float CShape::GetRadius()
{
	if (m_geometry == NULL)
		return 0.0f;

	return m_geometry->GetRadius();
}

void CShape::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_geometry != NULL)
		m_geometry->Advance(nSeconds);

	if (m_appearance != NULL)
		m_appearance->Advance(nSeconds);
}

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("Appearance", CAppearance, CNode)

START_NODE_PROPS(CAppearance, CNode)
	NODE_PROP(pt_node, CAppearance, material)
	NODE_PROP(pt_node, CAppearance, texture)
END_NODE_PROPS()

CAppearance::CAppearance()
{
	m_material = NULL;
	m_texture = NULL;
}

CAppearance::~CAppearance()
{
	if (m_material != NULL)
		m_material->Release();

	if (m_texture != NULL)
		m_texture->Release();
}

void CAppearance::Render()
{
	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

	XAppSetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	XAppSetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	XAppSetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
	XAppSetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
	XAppSetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
	XAppSetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

	XAppSetTexture(0, NULL);
	XAppSetTexture(1, NULL);

#ifdef _DEBUG
	XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(255, 0, 0, 255));
#endif

	if (m_texture != NULL)
	{
		m_texture->Render();

		LPDIRECT3DTEXTURE8 pSurface = m_texture->GetTextureSurface();
		if (pSurface != NULL)
		{
			XAppSetTexture(0, pSurface);

			XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
			XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
		}
		else
		{
			XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
			XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
			XAppSetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_COLORVALUE(0.0f, 0.0f, 0.0f, 0.0f));
		}
	}

	if (m_material != NULL)
		m_material->Render();
}

void CAppearance::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_material != NULL)
		m_material->Advance(nSeconds);

	if (m_texture != NULL)
		m_texture->Advance(nSeconds);
}

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("Material", CMaterial, CNode)

START_NODE_PROPS(CMaterial, CNode)
	NODE_PROP(pt_number, CMaterial, ambientIntensity)
	NODE_PROP(pt_color, CMaterial, diffuseColor)
	NODE_PROP(pt_color, CMaterial, emissiveColor)
	NODE_PROP(pt_number, CMaterial, shininess)
	NODE_PROP(pt_color, CMaterial, specularColor)
	NODE_PROP(pt_number, CMaterial, transparency)
END_NODE_PROPS()

CMaterial::CMaterial() :
	m_ambientIntensity(0.2f),
	m_diffuseColor(0.8f, 0.8f, 0.8f),
	m_emissiveColor(0.0f, 0.0f, 0.0f),
	m_shininess(0.2f),
	m_specularColor(0.0f, 0.0f, 0.0f),
	m_transparency(0.0f)
{
}

void CMaterial::Render()
{
	m_material.Diffuse.r = m_diffuseColor.x;
	m_material.Diffuse.g = m_diffuseColor.y;
	m_material.Diffuse.b = m_diffuseColor.z;
	m_material.Diffuse.a = 1.0f - m_transparency;

	m_material.Ambient.r = m_ambientIntensity;
	m_material.Ambient.g = m_ambientIntensity;
	m_material.Ambient.b = m_ambientIntensity;
	m_material.Ambient.a = 1.0f - m_transparency;

	m_material.Specular.r = m_specularColor.x;
	m_material.Specular.g = m_specularColor.y;
	m_material.Specular.b = m_specularColor.z;
	m_material.Specular.a = 1.0f - m_transparency;

	m_material.Emissive.r = m_emissiveColor.x;
	m_material.Emissive.g = m_emissiveColor.y;
	m_material.Emissive.b = m_emissiveColor.z;
	m_material.Emissive.a = 1.0f - m_transparency;

	m_material.Power = m_shininess;

	XAppSetMaterial(&m_material);
}

////////////////////////////////////////////////////////////////////////////

void CreateCube(D3DVERTEX* pVertices, WORD* pIndices, D3DXVECTOR3 size, bool bInside = false)
{
    // Define the normals for the cube
    D3DXVECTOR3 n0( 0.0f, 0.0f,-1.0f ); // Front face
    D3DXVECTOR3 n1( 0.0f, 0.0f, 1.0f ); // Back face
    D3DXVECTOR3 n2( 0.0f, 1.0f, 0.0f ); // Top face
    D3DXVECTOR3 n3( 0.0f,-1.0f, 0.0f ); // Bottom face
    D3DXVECTOR3 n4( 1.0f, 0.0f, 0.0f ); // Right face
    D3DXVECTOR3 n5(-1.0f, 0.0f, 0.0f ); // Left face

    // Set up the vertices for the cube. Note: to prevent tiling problems,
    // the u/v coords are knocked slightly inwards.

	if (bInside)
	{
		// Front face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n0, 0.01f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n0, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n0, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n0, 0.01f, 0.01f);

		// Back face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n1, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n1, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n1, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n1, 0.01f, 0.99f);

		// Top face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n2, 0.01f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n2, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n2, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n2, 0.01f, 0.01f);

		// Bottom face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n3, 0.01f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n3, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n3, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n3, 0.99f, 0.99f);

		// Right face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n4, 0.01f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n4, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n4, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n4, 0.01f, 0.01f);

		// Left face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n5, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n5, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n5, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n5, 0.01f, 0.99f);
	}
	else
	{
		// Front face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n0, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n0, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n0, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n0, 0.01f, 0.99f);

		// Back face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n1, 0.01f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n1, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n1, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n1, 0.99f, 0.99f);

		// Top face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n2, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n2, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n2, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n2, 0.01f, 0.99f);

		// Bottom face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n3, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n3, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n3, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n3, 0.01f, 0.99f);

		// Right face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n4, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n4, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n4, 0.99f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3( 0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n4, 0.01f, 0.99f);

		// Left face
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y, 0.5f * size.z), n5, 0.01f, 0.99f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y, 0.5f * size.z), n5, 0.01f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x,-0.5f * size.y,-0.5f * size.z), n5, 0.99f, 0.01f);
		*pVertices++ = D3DVERTEX(D3DXVECTOR3(-0.5f * size.x, 0.5f * size.y,-0.5f * size.z), n5, 0.99f, 0.99f);
	}

    // Set up the indices for the cube
    *pIndices++ =  0+0;   *pIndices++ =  0+1;   *pIndices++ =  0+2;
    *pIndices++ =  0+2;   *pIndices++ =  0+3;   *pIndices++ =  0+0;
    *pIndices++ =  4+0;   *pIndices++ =  4+1;   *pIndices++ =  4+2;
    *pIndices++ =  4+2;   *pIndices++ =  4+3;   *pIndices++ =  4+0;
    *pIndices++ =  8+0;   *pIndices++ =  8+1;   *pIndices++ =  8+2;
    *pIndices++ =  8+2;   *pIndices++ =  8+3;   *pIndices++ =  8+0;
    *pIndices++ = 12+0;   *pIndices++ = 12+1;   *pIndices++ = 12+2;
    *pIndices++ = 12+2;   *pIndices++ = 12+3;   *pIndices++ = 12+0;
    *pIndices++ = 16+0;   *pIndices++ = 16+1;   *pIndices++ = 16+2;
    *pIndices++ = 16+2;   *pIndices++ = 16+3;   *pIndices++ = 16+0;
    *pIndices++ = 20+0;   *pIndices++ = 20+1;   *pIndices++ = 20+2;
    *pIndices++ = 20+2;   *pIndices++ = 20+3;   *pIndices++ = 20+0;
}

class CBox : public CNode
{
	DECLARE_NODE(CBox, CNode)
public:
	CBox();
	~CBox();

	void Render();
	void GetBBox(BBox* pBBox);
	float GetRadius();


	D3DXVECTOR3 m_size;

	IDirect3DVertexBuffer8* m_pVB;
	IDirect3DIndexBuffer8* m_pIB;

#define NUM_CUBE_VERTICES (4*6)
#define NUM_CUBE_INDICES  (6*6)

	D3DVERTEX m_pCubeVertices [NUM_CUBE_VERTICES];
	WORD m_pCubeIndices [NUM_CUBE_INDICES];

	bool m_bDirty;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Box", CBox, CNode)

START_NODE_PROPS(CBox, CNode)
	NODE_PROP(pt_vec3, CBox, size)
END_NODE_PROPS()

CBox::CBox() :
	m_size(1.0f, 1.0f, 1.0f)
{
	m_bDirty = true;

	m_pVB = NULL;
	m_pIB = NULL;
}

CBox::~CBox()
{
	if (m_pVB != NULL)
		m_pVB->Release();

	if (m_pIB != NULL)
		m_pIB->Release();
}

void CBox::Render()
{
	if (m_bDirty)
	{
		TRACE(_T("Creating a cube...\n"));
		CreateCube(m_pCubeVertices, m_pCubeIndices, m_size);
		m_bDirty = false;
	}

	if (m_pVB == NULL)
	{
		void* pVerts;
		XAppCreateVertexBuffer(NUM_CUBE_VERTICES * sizeof (D3DVERTEX), D3DUSAGE_DYNAMIC, D3DFVF_VERTEX, D3DPOOL_MANAGED, &m_pVB);

		VERIFYHR(m_pVB->Lock(0, NUM_CUBE_VERTICES * sizeof (D3DVERTEX), (BYTE**)&pVerts, 0));
		CopyMemory(pVerts, m_pCubeVertices, NUM_CUBE_VERTICES * sizeof (D3DVERTEX));
		VERIFYHR(m_pVB->Unlock());
	}

	if (m_pIB == NULL)
	{
		void* pIndices;
		XAppCreateIndexBuffer(NUM_CUBE_INDICES * sizeof (WORD), D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pIB);
		VERIFYHR(m_pIB->Lock(0, NUM_CUBE_INDICES * sizeof (WORD), (BYTE**)&pIndices, 0));
		CopyMemory(pIndices, m_pCubeIndices, NUM_CUBE_INDICES * sizeof (WORD));
		VERIFYHR(m_pIB->Unlock());
	}

	if (m_pVB != NULL && m_pIB != NULL)
	{
		XAppSetStreamSource(0, m_pVB, sizeof (D3DVERTEX));
		XAppSetIndices(m_pIB, 0);
		XAppSetVertexShader(D3DFVF_VERTEX);
	    XAppDrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, NUM_CUBE_VERTICES, 0, 12);

//		g_bResetStream = true;
	}
}

void CBox::GetBBox(BBox* pBBox)
{
	pBBox->center.x = 0.0f;
	pBBox->center.y = 0.0f;
	pBBox->center.z = 0.0f;
	pBBox->size = m_size;
}

float CBox::GetRadius()
{
	return D3DXVec3Length(&m_size) / 2.0f;
}

////////////////////////////////////////////////////////////////////////////

extern class CMesh* MakeSphere(float nRadius, int nSlices, int nStacks);

class CSphere : public CMeshNode
{
	DECLARE_NODE(CSphere, CMeshNode)
public:
	CSphere();
	~CSphere();

	float m_radius;
	int m_slices;
	int m_stacks;

	void Init();

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Sphere", CSphere, CMeshNode)

START_NODE_PROPS(CSphere, CMeshNode)
	NODE_PROP(pt_number, CSphere, radius)
	NODE_PROP(pt_integer, CSphere, slices)
	NODE_PROP(pt_integer, CSphere, stacks)
END_NODE_PROPS()

CSphere::CSphere() :
	m_radius(1.0f),
	m_slices(32),
	m_stacks(32)
{
	m_bDirty = true;
}

CSphere::~CSphere()
{
}

void CSphere::Init()
{
	m_pMesh = MakeSphere(m_radius, m_slices, m_stacks);

    if (m_pMesh)
    {
        m_bDirty = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\std.cpp ===
#include "std.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\std.h ===
// Check Configuration Options
#include "stdcfg.h"

#include <new.h>

#if defined(_DEBUG)
#define _CRTDBG_MAP_ALLOC
#include <malloc.h>
#endif

#ifdef _XBOX
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#include <xtl.h>
#include <xgraphics.h>
#include <xboxp.h>
#include <xboxverp.h>
#include <xapip.h>
#include <av.h>
#ifdef __cplusplus
}
#endif // __cplusplus

#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>
#include "vertex8.h"
#endif


////////////////////////////////////////////////////////////////////////////

#ifdef  __cplusplus

#define EXTERN_C extern "C"

#if defined(_DEBUG)
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

#define RELEASENULL(object) { if ((object) != NULL) { (object)->Release(); (object) = NULL; } }

#else // !__cplusplus

#define EXTERN_C extern
#define bool BOOL
#define true TRUE
#define false FALSE
#define inline _inline

#endif

#define CopyChars(dest, src, count) CopyMemory(dest, src, (count) * sizeof (TCHAR))
#define countof(n) (sizeof (n) / sizeof (n[0]))

#define offsetof(member) (((int)&member) - (int)this)

#ifdef _UNICODE
extern void Unicode(TCHAR* wsz, const char* sz, int nMaxChars);
extern void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);
#endif

#undef ASSERT
#undef VERIFY
#undef ASSERTHR
#undef VERIFYHR
#undef TRACE
#undef ALERT

#ifdef _DEBUG

#define ASSERT(f)		if (!(f)) RtlAssert(#f, __FILE__, __LINE__, NULL)
#define VERIFY(f)		ASSERT(f)
#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)
#define TRACE			Trace
#define ALERT			Alert

EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
EXTERN_C void Trace(const TCHAR* szMsg, ...);

#else // !_DEBUG

#define ASSERT(f)		((void)0)
#define VERIFY(f)		((void)(f))
#define ASSERTHR(f)		((void)0)
#define VERIFYHR(f)		((void)(f))
#define TRACE			1 ? (void)0 : Trace
#define ALERT			1 ? (void)0 : Alert

inline void Trace(const TCHAR* szMsg, ...) { }

#endif

EXTERN_C void Alert(const TCHAR* szMsg, ...);


////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#include "xprofp.h"

#ifdef _PROFILE
#define START_PROFILE() XProfpControl(XPROF_START, 0)
#define END_PROFILE() XProfpControl(XPROF_STOP, 0)
#else
#define START_PROFILE()
#define END_PROFILE()
#endif
#else
#define START_PROFILE()
#define END_PROFILE()
#endif

////////////////////////////////////////////////////////////////////////////
// Stuff from Windows that Xbox should have...
//

#ifdef _XBOX
typedef  PVOID           HDEVNOTIFY;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

#define MAX_COMPUTERNAME_LENGTH 15 // REVIEW: What is this really?
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\StarField.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "surfx.h"


class CStarField : public CNode
{
	DECLARE_NODE(CStarField, CNode)
public:
	CStarField();
	~CStarField();

	int m_stars;
	float m_speed;

	void Advance(float nSeconds);
	void RenderDynamicTexture(CSurfx* pSurfx);

protected:
	int m_nAllocStars;
	D3DXVECTOR3* m_rgstar;
	void Update();

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("StarField", CStarField, CNode)

START_NODE_PROPS(CStarField, CNode)
	NODE_PROP(pt_integer, CStarField, stars)
	NODE_PROP(pt_number, CStarField, speed)
END_NODE_PROPS()

CStarField::CStarField() :
	m_stars(20),
	m_speed(1.0f)
{
	m_rgstar = NULL;
	m_nAllocStars = 0;
}

CStarField::~CStarField()
{
	delete [] m_rgstar;
}

void CStarField::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	Update();

	for (int i = 0; i < m_stars; i += 1)
	{
		m_rgstar[i].z -= nSeconds * m_speed;

		if (m_rgstar[i].z <= 0.0f)
		{
			m_rgstar[i].x = rnd(2.0f) - 1.0f;
			m_rgstar[i].y = rnd(2.0f) - 1.0f;
			m_rgstar[i].z = 1.5f + rnd(1.0f);
		}
	}
}

void CStarField::RenderDynamicTexture(CSurfx* pSurfx)
{
	Update();

	float xCenter = (float)pSurfx->m_nWidth / 2.0f;
	float yCenter = (float)pSurfx->m_nHeight / 2.0f;

	for (int i = 0; i < m_stars; i += 1)
	{
		if (m_rgstar[i].z > 0.0f)
		{
			int x = (int)(xCenter + m_rgstar[i].x / m_rgstar[i].z * xCenter);
			int y = (int)(yCenter + m_rgstar[i].y / m_rgstar[i].z * yCenter);

			if (x >= 0 && x < pSurfx->m_nWidth && y >= 0 && y < pSurfx->m_nHeight)
				pSurfx->m_pels[x + y * pSurfx->m_nWidth] = (int)(255.0f * (1.0f - (m_rgstar[i].z - 1.0f)));
			else { /*TRACE("Star error!\n");*/ m_rgstar[i].z = 0.0f; }
		}
	}
}

void CStarField::Update()
{
	if (m_rgstar == NULL || m_stars > m_nAllocStars)
	{
		D3DXVECTOR3* rgstars = new D3DXVECTOR3 [m_stars];
		ZeroMemory(rgstars, m_stars * sizeof (D3DXVECTOR3));

		if (m_rgstar != NULL)
		{
			CopyMemory(rgstars, m_rgstar, m_nAllocStars * sizeof (D3DXVECTOR3));
			delete [] m_rgstar;
		}

		m_rgstar = rgstars;
		m_nAllocStars = m_stars;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\stdcfg.h ===
// Check Configuration Options
//

#if defined(DEBUG) && !defined(_DEBUG)
#define _DEBUG
#endif
#if defined(_DEBUG) && !defined(DEBUG)
#define DEBUG
#endif

#if defined(XBOX) && !defined(_XBOX)
#define _XBOX
#endif
#if defined(_XBOX) && !defined(XBOX)
#define XBOX
#endif

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif
#if defined(_UNICODE) && !defined(UNICODE)
#define UNICODE
#endif

#ifdef _XBOX
#ifndef _UNICODE
#error "Xbox build must use Unicode!"
#endif
#endif

#ifdef _WINDOWS
#define _LOG
#define _JPEG
//#define _LAN
#endif

#ifdef _PROFILE
#undef _DEBUG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\surfx.cpp ===
#include "std.h"
#include "xapp.h"
#include "surfx.h"

int CSurfx::sTempRef = 0;
long CSurfx::sTempSize = 0;
char* CSurfx::sTemp = NULL;

CSurfx::CSurfx(int nWidth, int nHeight)
{
//	m_pSurface = NULL;

//	m_ssd.lPitch = nWidth;
//	m_ssd.lpSurface = new BYTE [nWidth * nHeight];
//	m_pSurface = NULL;
	m_nWidth = nWidth;
	m_nHeight = nHeight;
	m_pels = new BYTE [nWidth * (nHeight + 1)];

	mLineWidth = 1;

	mClipRect.left = 0;
	mClipRect.top = 0;
	mClipRect.right = nWidth;
	mClipRect.bottom = nHeight;

	mBytesPerRow = nWidth;

/*
	m_pSurface = pSurface;

	if (m_pSurface != NULL)
	{
		m_pSurface->AddRef();

		m_ssd.dwSize = sizeof (DDSURFACEDESC2);
		m_pSurface->Lock(NULL, &m_ssd, DDLOCK_WRITEONLY, NULL);
	}
*/
	sTempRef += 1;
}

CSurfx::~CSurfx()
{
/*
	if (m_pSurface != NULL)
	{
		m_pSurface->Unlock(NULL);
		m_pSurface->Release();
	}
	else
	{
		delete [] m_ssd.lpSurface;
	}
*/
	delete [] m_pels;

	sTempRef -= 1;
	if (sTempRef == 0)
	{
		delete [] sTemp;
		sTemp = NULL;
		sTempSize = 0;
	}
}


void CSurfx::Fade(DeltaFieldData* inGrad)
{
	Fade((char*)m_pels/*m_ssd.lpSurface*/, m_nWidth/*m_ssd.lPitch*/, m_nWidth, m_nHeight, inGrad);
}

#define HALFCORD	0x003F  /* 12 bits per cord, 5 bits for fixed decimal, 7 bits for whole number */
#define FIXED_BITS	5


void CSurfx::Fade(const char* inSrce, long inBytesPerSrceRow, char* inDest, long inBytesPerDestRow, long inX, long inY, const char* inGrad)
{
	unsigned long p, x, y, u, v, u1, v1, P1, P2, P3, P4, codedDel, xGrad, yGrad;
	const char* srceMap;


	// Setup the source row base address and offset to allow for negative grad components
	inSrce = inSrce - HALFCORD * inBytesPerSrceRow - HALFCORD;


	// For every pixel in the destination, find it's source via the gradient
	for ( y = 0; y < (unsigned)inY; y++ )
	{
		for ( x = 0; x < (unsigned)inX; x++ )
		{
			// Extract the gradient information
			// Format of a grad short:  ( ( (ddx + 128) * 16 ) << 20 ) | ( (ddy + 128) * 16 ) << 8
			codedDel = *((const unsigned long*) inGrad);	
			inGrad += 3;
			xGrad = 0xFFF & ( codedDel >> 12 );
			yGrad = 0xFFF & ( codedDel );

			// Get the vector to the source pixel
			srceMap = inSrce + ( xGrad >> FIXED_BITS ) + ( yGrad >> FIXED_BITS ) * inBytesPerSrceRow + x;

			u = ( yGrad & 0x1F );		// y - ysrc
			v = ( xGrad & 0x1F );		// x - xsrc

			// P1 - P2
			// |     |
			// P3 - P4
			P1  = ( (unsigned char*) srceMap )[0];
			P2  = ( (unsigned char*) srceMap )[1];

			u1	 = 0x20 - u;
			P1  *= u1;
			P2  *= u1;

			P3  = ( (unsigned char*) srceMap )[ inBytesPerSrceRow ];  
			P4  = ( (unsigned char*) srceMap )[ inBytesPerSrceRow + 1 ];

			v1 	= 0x20 - v;
			P3 *= u;
			P4 *= u;

			// Bilinear interpolation to approximate the source pixel value
			p  = v * ( P2 + P4 ) + v1 * ( P1 + P3 );


			// Store the calculated/dest pixel (rounding the fraction part of the pix value)
			// We divide by (5+5) decimal places because p is units squared (5 places per decimal)
			((unsigned char*) inDest)[ x ] = (unsigned char)(( 31 * p ) >> 15);  // 5 more dec places cuz of the mult by 31
		}

		// Setup the dest row base address		
		inDest += inBytesPerDestRow;		

		// Setup the source row base address, also offset to allow for negative grad components
		inSrce += inBytesPerSrceRow;
	}
}


void CSurfx::Fade(char* inPix, long inBytesPerRow, long inX, long inY, DeltaFieldData* inGrad)
{
	unsigned long p, x, y, u, v, u1, v1, P1, P2, P3, P4, codedDel, xGrad, yGrad, curBufRowNum;
	long bufRows;
	char* srceMap, *curBufRow, *srce, *grad = inGrad->mField;

	// Maintain our temp buf
	bufRows = inGrad->mNegYExtents;
	if (sTempSize < bufRows * inBytesPerRow)
	{
		sTempSize = bufRows * inBytesPerRow;
		delete [] sTemp;
		sTemp = new char [sTempSize];
	}

	// Setup the trailing buffer...
	// To transformation must operate on the orginal pixels, so we can't write over the original pix
	// until the cur pixel is sufficiently far away (> 2^HALFCORD num rows away)

	if (inY <= bufRows)
		bufRows = inY;
	Fade(inPix, inBytesPerRow, sTemp, inBytesPerRow, inX, bufRows, grad);
	inY -= bufRows;
	grad += 3 * inX * bufRows;
	curBufRowNum = 0;

	// Setup the source row base address and offset to allow for negative grad components
	srce = inPix + bufRows * inBytesPerRow - HALFCORD * inBytesPerRow - HALFCORD;

	// For every pixel in the destination, find it's source via the gradient
	for (y = 0; y < (unsigned)inY; y += 1)
	{
		// Calc a loc where the trailing buffer row starts
		curBufRow = sTemp + curBufRowNum * inBytesPerRow;

		for (x = 0; x < (unsigned)inX; x += 1)
		{
			// Extract the gradient information
			// Format of a grad short:  ( ( (ddx + 128) * 16 ) << 20 ) | ( (ddy + 128) * 16 ) << 8
			codedDel = *((const unsigned long*) grad);	
			grad += 3;
			xGrad = 0xFFF & (codedDel >> 12);
			yGrad = 0xFFF & (codedDel);

			// Do something in parallel -- write a pixel from the trailing buf to the pixmap
			inPix[x] = curBufRow[x];

			// Get the vector to the source pixel
			srceMap = srce + (xGrad >> FIXED_BITS) + (yGrad >> FIXED_BITS) * inBytesPerRow + x;

			u = (yGrad & 0x1F);		// y - ysrc
			v = (xGrad & 0x1F);		// x - xsrc

			// P1 - P2
			// |     |
			// P3 - P4
			P1 = ((unsigned char*)srceMap)[0];
			P2 = ((unsigned char*)srceMap)[1];

			u1 = 0x20 - u;
			P1 *= u1;
			P2 *= u1;

			P3 = ((unsigned char*)srceMap)[inBytesPerRow];  
			P4 = ((unsigned char*)srceMap)[inBytesPerRow + 1];

			v1	= 0x20 - v;
			P3 *= u;
			P4 *= u;

			// Bilinear interpolation to approximate the source pixel value
			p  = v * (P2 + P4) + v1 * (P1 + P3);


			// Store the calculated/dest pixel (rounding the fraction part of the pix value)
			// We divide by (5+5) decimal places because p is units squared (5 places per decimal)
			curBufRow[x] = (char)((31 * p) >> 15);  // 5 more dec places cuz of the mult by 31
		}

		// Maintail the row-circular, trailing buffer
		curBufRowNum = (curBufRowNum + 1) % bufRows;
		inPix += inBytesPerRow;
		srce += inBytesPerRow;
	}

	// Flush the the trailing buf to the pixmap
	p = inX >> 2;
	for (y = 0; y < (unsigned)bufRows; y += 1)
	{
		curBufRow = sTemp + ((curBufRowNum + y) % bufRows) * inBytesPerRow;
		for (x = 0; x < p; x += 1)
		{
			((unsigned long*)inPix)[x] = ((unsigned long*)curBufRow)[x];
		}

		inPix	+= inBytesPerRow;
	}
}



int g_nPalette = -1;



inline void SetRGB(int R, int G, int B, DWORD& rgb)
{
	if (R < 0)
		R = 0;
	else if (R > 255)
		R = 255;

	if (G < 0)
		G = 0;
	else if (G > 255)
		G = 255;

	if (B < 0)
		B = 0;
	else if (B > 255)
		B = 255;

	rgb = (R << 16) | (G << 8) | (B);
}

#define __SET_RGB( R, G, B ) 	\
	SetRGB(R, G, B, outRGB); break;

void HSV2RGB(float H, float S, float V, DWORD& outRGB)
{
	// H is given on [0, 1] or WRAPPED. S and V are given on [0, 1]. 
	// RGB are each returned on [0, 1]. 
	long hexQuadrant, m, n, v; 
	H = ( H - floorf( H ) ) * 6.0f;  // Wrap the Hue angle around 1.0, then find quadrant

	hexQuadrant = (long)H; 
	float f = H - hexQuadrant; 

	// Check sat bounds
	if (S < 0.0f)
		S = 0.0f;
	if (S > 1.0f)
		S = 1.0f;

	// Check val bounds
	if (V < 0.0f)
		V = 0.0f;
	if (V > 1.0f)
		V = 1.0f;

	if (!(hexQuadrant & 1))
		f = 1.0f - f; // hexQuadrant i is even 

	V *= 255.0f;
	v = (long)V;
	m = (long)(V * (1.0f - S));
	n = (long)(V * (1.0f - S * f));

	switch ( hexQuadrant ) { 
	case 1: __SET_RGB( n, v, m ); 
	case 2: __SET_RGB( m, v, n ); 
	case 3: __SET_RGB( m, n, v ); 
	case 4: __SET_RGB( n, m, v ); 
	case 5: __SET_RGB( v, m, n ); 
	default: 
	__SET_RGB( v, n, m ); 
	}
} 

void GetHSV(int nPalette, float i, float t, float& H, float& S, float& V)
{
	g_nPalette = nPalette;

	switch (nPalette)
	{
	default:
		g_nPalette = 0;
		// FALL THOUGH

	case 0: // Firestorm
		H = 0.166f * powf(i, 1.9f);
		S = 1;
		V = powf(i, 0.9f);
		break;

	case 1: // Aqua
		H = 0.45f;
		S = powf((1.0f - i), 0.3f);
		V = powf(i, 0.7f);
		break;

	case 2: // Purple & Blues
		H = 0.666f + 0.166f * powf(i, 1.4f);
		S = 0.5f + 0.5f * powf((1.8f * i - 1.0f), 2);
		V = powf(i, 0.4f);
		break;

	case 3: // Color Wheel
		H = wrap(0.03f * t);
		S = 1.0f - 0.6f * powf(i, 2.5f);
		V = i;
		break;

	case 4: // Bizarro Mystery Unveiled
		H = wrap(0.3f - 0.003f * t);
		S = powf(i, 2.9f);
		V = powf(i, 0.9f);
		break;

	case 5: // Bizarro Color Wheel
		H = wrap(0.02f * t);
		S = 1.0f;
		V = 1.0f - powf(i, 1.4f);
		break;

	case 6: // Dark Rainbow
		H = powf(i, 1.6f);
		S = 1.0f;
		V = i;
		break;

	case 7: // Ice Nightshade
		H = wrap(powf((0.7f - 0.4f * i), 0.6f));
		S = 0.9f;
		V = powf(i, 0.9f);
		break;

	case 8: // Mystery Unveiled
		H = wrap(0.002f * t);
		S = powf((1.0f - i), 1.5f);
		V = powf(i, 0.4f);
		break;

	case 9: // Roundabout
		H = wrap(0.2f * (powf(i, 2.0f) + powf(cosf(4.0f * i), 2.0f)) + (0.05f * t));
		S = 0.85f + 0.5f * i;
		V = powf(i, 0.55f);
		break;
	}
}

int g_nBlendPalette;
float g_nBlendPaletteAmount;

#define timeToBlend (2.0f)

void MakePalette(DWORD outPalette [256])
{
	static XTIME nextPaletteChangeTime = 0.0f;
	static XTIME startBlendTime;

	int i;
	float H, S, V, inc = 1.0f / 255.0f;
	float mIntensity = 0.0f;
	XTIME now = XAppGetNow();

	if (now > nextPaletteChangeTime)
	{
		nextPaletteChangeTime = now + 10.0f + rnd(5.0f);
		g_nBlendPalette = g_nPalette;
		g_nPalette += 1;
		g_nBlendPaletteAmount = 0.0f;
		startBlendTime = now;
	}

	if (g_nBlendPalette != -1)
		TRACE(_T("Palette blend: %f\n"), g_nBlendPaletteAmount);

	for (i = 0; i < 256; i++, mIntensity += inc)
	{
		GetHSV(g_nPalette, mIntensity, (float) now, H, S, V);

		if (g_nBlendPalette != -1)
		{
			float H2, S2, V2;

			GetHSV(g_nBlendPalette, mIntensity, (float) now, H2, S2, V2);

			H = g_nBlendPaletteAmount * H + (1.0f - g_nBlendPaletteAmount) * H2;
			S = g_nBlendPaletteAmount * S + (1.0f - g_nBlendPaletteAmount) * S2;
			V = g_nBlendPaletteAmount * V + (1.0f - g_nBlendPaletteAmount) * V2;
		}

		HSV2RGB( H, S, V, outPalette[i]);
	}

	if (g_nBlendPalette != -1)
	{
		g_nBlendPaletteAmount += (float) (now - startBlendTime) / timeToBlend;
		if (g_nBlendPaletteAmount >= 1.0f)
			g_nBlendPalette = -1;
	}
}










#define __doXerr		error_term += dy;				\
						if ( error_term >= dx ) {		\
							error_term -= dx;			\
							basePtr += rowOffset;		\
							ymov--;						\
						}
						
						
#define __doYerr		error_term += dx;				\
						if ( error_term >= dy ) {		\
							error_term -= dy;			\
							basePtr += xDirection;		\
							xmov--;						\
						}

#define __circ( dia, a )	switch ( (dia) )		{									\
								case 2:		a = "\0\0"; break;							\
								case 3:		a = "\1\0\1"; break;						\
								case 4:		a = "\1\0\0\1"; break;						\
								case 5:		a = "\1\0\0\0\1"; break;					\
								case 6:		a = "\1\0\0\0\0\1"; break;					\
								case 7:		a = "\2\1\0\0\0\1\2"; break;				\
								case 8:		a = "\2\1\0\0\0\0\1\2"; break;				\
								case 9:		a = "\3\1\1\0\0\0\1\1\3"; break;			\
								case 10:	a = "\3\1\1\0\0\0\0\1\1\3"; break;			\
								case 11:	a = "\4\2\1\1\0\0\0\1\1\2\4"; break;		\
								case 12:	a = "\4\2\1\1\0\0\0\0\1\1\2\4"; break;		\
							}

void CSurfx::Line(int sx, int sy, int ex, int ey, unsigned char color)
{
	long xDirection, rowOffset, error_term;
	char* basePtr, *center;
	long xmov, ymov, dx, dy, t, j, lw;
	long penExtents;

	// Half the coordinte if it's large (we copy the sign bit in the 2^31 digit)
	// To do: use float clipping
	sx = ( ( (long) (sx & 0x80000000) ) >> 1 ) | ( sx & 0x3FFFFFFF );
	ex = ( ( (long) (ex & 0x80000000) ) >> 1 ) | ( ex & 0x3FFFFFFF );
	sy = ( ( (long) (sy & 0x80000000) ) >> 1 ) | ( sy & 0x3FFFFFFF );
	ey = ( ( (long) (ey & 0x80000000) ) >> 1 ) | ( ey & 0x3FFFFFFF );

	// Modify the line width so that the actual width matches mLineWidth
	lw = mLineWidth;	
	if ( mLineWidth > 3 ) {
		dx = ex - sx;	dx = dx * dx;
		dy = ey - sy;	dy = dy * dy;
		if ( dx > 0 && dx >= dy )
			lw = 128 + 55 * dy / dx; 			// 1/cos( atan( x ) ) is about 1+.43*x^2 from 0 to 1 (55 == .43 * 128)
		else if ( dy > 0 && dy > dx )
			lw = 128 + 55 * dx / dy; 			// 1/cos( atan( x ) ) is about 1+.43*x^2 from 0 to 1 (55 == .43 * 128)
		
		if ( dx > 0 || dy > 0 )
			lw = ( mLineWidth * lw + 64 ) >> 7;		// Add in order to round up
	}
	penExtents = lw >> 1;

	
	
	// Clipping: Set the pen loc to a point that's in and stop drawing once/if the pen moves out
	if ( sx < mClipRect.left + penExtents || sx >= mClipRect.right - penExtents || sy < mClipRect.top + penExtents || sy >= mClipRect.bottom - penExtents ) {

		// Exit if both points are out of bounds (wimpy clipping, eh?)
		if ( ex < mClipRect.left + penExtents || ex >= mClipRect.right - penExtents || ey < mClipRect.top + penExtents || ey >= mClipRect.bottom - penExtents )
			return;

		t = ex; ex = sx; sx = t;
		t = ey; ey = sy; sy = t;
	}
		
	dx = ex - sx;
	dy = ey - sy;

		
	// moving left or right?
	dx = ex - sx;
	xmov = dx;
	if ( dx < 0 ) {
		xmov = -dx;
		if ( sx - xmov < mClipRect.left + penExtents )
			xmov = sx - ( mClipRect.left + penExtents );
		xDirection = - 1;
		dx = -dx; }
	else if ( dx > 0 ) {
		if ( sx + xmov >= mClipRect.right - penExtents )
			xmov = mClipRect.right - penExtents - 1 - sx;
		xDirection = 1;  }
	else 
		xDirection = 0;


	// moving up or down?
	ymov = dy;
	if ( dy < 0 ) {
		ymov = -dy;
		if ( sy - ymov < mClipRect.top + penExtents )
			ymov = sy - ( mClipRect.top + penExtents );
		rowOffset = - mBytesPerRow;
		dy = -dy; }
	else {
		if ( sy + ymov >= mClipRect.bottom - penExtents )
			ymov = mClipRect.bottom - penExtents - sy - 1;
		rowOffset = mBytesPerRow; 
	} 

	// In Win32, everything's upside down
	#if EG_WIN
	sy = mY - sy - 1;
	ey = mY - ey - 1;
	rowOffset = - rowOffset;
	#endif	


	basePtr = (char*)m_pels + sy * mBytesPerRow + sx * 1;
	error_term = 0;
	
	long halfW;

	if ( lw > 1 )
	{
		// Make a circle for the pen
		long c_x, tw = mLineWidth;
		halfW = ( tw ) >> 1;
		
		if ( tw < 12 )
		{
			char* c_shape;
			__circ( tw, c_shape )
			for ( j = 0; j < tw; j++ )
			{
				long tmp = j - halfW;
				c_x = c_shape[ j ];
				center = basePtr + (j-halfW) * mBytesPerRow;
				for ( int k = c_x; k < tw - c_x; k++ )
				{
					((unsigned char*) center)[k-halfW] = color;
				}
			}
		}
		else
		{		
		
			for ( j = 0; j < tw; j++ )
			{
				long tmp = j - halfW;
				c_x = halfW - ( ( long ) sqrt( halfW * halfW - tmp * tmp ) );
				center = basePtr + (j-halfW) * mBytesPerRow;
				for ( int k = c_x; k < tw - c_x; k++ )
				{
					((unsigned char*) center)[k-halfW] = color;
				}
			}
		}
		
		
		halfW = lw >> 1;

		// Draw the line
		if ( dx > dy )
		{
			// Start counting off in x
			for ( ; xmov >= 0 && ymov >= 0; xmov-- )
			{
				// Draw the vertical leading edge of the pen
				center = basePtr - halfW * mBytesPerRow;
				for ( j = 0; j < lw; j++ )
				{
					*((unsigned char*) center) = color;
					center += mBytesPerRow;
				}

				basePtr += xDirection;

				// Check to see if we need to move the pixelOffset in the y direction.
				__doXerr
			}
		}
		else
		{
			// Start counting off in y
			for ( ; ymov >= 0 && xmov >= 0; ymov-- )
			{
				// Draw the horizontal leading edge of the pen
				center = basePtr - ( halfW ) * 1;
				for ( j = 0; j < lw; j++ )
				{
					*((unsigned char*) center) = color;
					center += 1;
				}
				basePtr += rowOffset;

				// Check to see if we need to move the pixelOffset in the y direction.
				__doYerr
			}
		}
	}
	else
	{
		// Draw the (single pixel) line
		if ( dx >= dy )
		{
			// Start counting off in x
			for ( ; xmov >= 0 && ymov >= 0; xmov-- )
			{
				*((unsigned char*) basePtr) = color;
				
				basePtr += xDirection;

				// Check to see if we need to move the pixelOffset in the y direction.
				__doXerr
			}
		}
		else
		{
			// Start counting off in y
			for ( ; ymov >= 0 && xmov >= 0; ymov-- )
			{
			

				*((unsigned char*) basePtr) = color;
				basePtr += rowOffset;

				// Check to see if we need to move the pixelOffset in the y direction.
				__doYerr
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\surfx.h ===
class DeltaFieldData
{
public:
	DeltaFieldData();
	~DeltaFieldData();

	long mNegYExtents;
	char* mField;
};


class CSurfx
{
public:
	CSurfx(int nWidth, int nHeight);
	~CSurfx();

	int m_nWidth;
	int m_nHeight;
	BYTE* m_pels;

	int mBytesPerRow;

	int mLineWidth;
	RECT mClipRect;

	void Fade(DeltaFieldData* inGrad);
	void Fade(char* inPix, long inBytesPerRow, long inX, long inY, DeltaFieldData* inGrad);
	void Fade(const char* inSrce, long inBytesPerSrceRow, char* inDest, long inBytesPerDestRow, long inX, long inY, const char* inGrad);

	void Line(int sx, int sy, int ex, int ey, unsigned char color);

	inline BYTE* Pixel(int x, int y) { return &m_pels[mBytesPerRow * y + x]; }

	static int sTempRef;
	static long sTempSize;
	static char* sTemp;

private:
    // Need this to prevent the compiler from using default copy ctor
    CSurfx(const CSurfx&);
    CSurfx& operator=(const CSurfx& rhs);
};

class DeltaField
{
public:
	DeltaField();

	// Suck in a new grad field.  Note: Resize must be called after Assign()
//bc	void Assign(ArgList& inArgs, UtilStr& inName);
	void Assign();

	// Reinitiate/reset the computation of this grad field.
	void SetSize(long inWidth, long inHeight, bool inForceRegen = false);

	// Compute a small portion of the grad field.  Call GetField() to see if the field finished.
	int CalcSome();

	// See if this delta field is 100% calculated
	bool IsCalculated()
	{
		return mCurrentY == mHeight;
	}

	bool IsCalculating()
	{
		return mCurrentY >= 0 && mCurrentY != mHeight;
	}

	bool IsUninitialized()
	{
		return mCurrentY == -1;
	}

	//  Returns a ptr to the buf of this grad field.
	//	Note:  If the field is not 100% calculated, it will finish calculating and may take a couple seconds.
	DeltaFieldData* GetField();

	void GetXY(float r, float theta, float x, float y, float& X, float& Y, bool& bPolar, bool bInit);
	int m_nStyle;

protected:
	long					mCurrentY;
	long					mNegYExtents;
//	ExpressionDict			mDict;
	float					mX_Cord, mY_Cord, mR_Cord, mT_Cord;
	float					mXScale, mYScale;
//	Expression				mXField, mYField;
	bool					mPolar, mHasRTerm, mHasThetaTerm;
	long					mWidth, mHeight;	
	long					mAspect1to1;
//	ExprArray				mAVars, mDVars;
//	UtilStr					mName;
//	TempMem					mTempMem;
	DeltaFieldData			mFieldData;
};



extern void MakePalette(DWORD outPalette [256]);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\String.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"

START_NODE_FUN(CStrObject, CObject)
	NODE_FUN_IV(length)
	NODE_FUN_II(charCodeAt)
	NODE_FUN_SI(charAt)
	NODE_FUN_SS(concat)
	NODE_FUN(indexOf)
	NODE_FUN(lastIndexOf)
	NODE_FUN(substr)
	NODE_FUN(substring)
	NODE_FUN_SV(toLowerCase)
	NODE_FUN_SV(toUpperCase)
END_NODE_FUN()


CStrObject::CStrObject()
{
	m_obj = objString;
	m_nLength = 0;
	m_nAlloc = 0;
	m_sz = NULL;
}

CStrObject::CStrObject(const TCHAR* sz)
{
	if (sz == NULL)
		sz = _T("");

	m_obj = objString;
	m_nLength = _tcslen(sz);
	m_nAlloc = m_nLength + 1;
	m_sz = new TCHAR [m_nAlloc];
	CopyChars(m_sz, sz, m_nLength);
	m_sz[m_nLength] = '\0';
}

CStrObject::CStrObject(const TCHAR* pch, int cch)
{
	m_obj = objString;
	m_nLength = cch;
	m_nAlloc = cch + 1;
	m_sz = new TCHAR [m_nAlloc];
	CopyChars(m_sz, pch, cch);
	m_sz[cch] = '\0';
}

CStrObject::~CStrObject()
{
	delete [] m_sz;
}

CStrObject* CStrObject::ToStr()
{
	AddRef();
	return this;
}

CNumObject* CStrObject::ToNum()
{
	return new CNumObject(GetSz());
}

TCHAR* CStrObject::SetLength(int nLength)
{
	delete [] m_sz;

	m_nLength = nLength;
	m_nAlloc = nLength + 1;
	m_sz = new TCHAR [m_nAlloc];
	ZeroMemory(m_sz, m_nAlloc * sizeof (TCHAR));
	return m_sz;
}

void CStrObject::Append(const TCHAR* szAppend)
{
	int cchAppend = _tcslen(szAppend);

	if (m_nLength + cchAppend + 1 > m_nAlloc)
	{
		int nAllocNew = m_nLength + cchAppend + 1;
		TCHAR* szNew = new TCHAR [nAllocNew];
		m_nAlloc = nAllocNew;
		CopyChars(szNew, m_sz, m_nLength);
		delete [] m_sz;
		m_sz = szNew;
	}

	CopyChars(m_sz + m_nLength, szAppend, cchAppend);
	m_nLength += cchAppend;
	m_sz[m_nLength] = 0;
}

////////////////////////////////////////////////////////////////////////////
// Scriptable Methods...

int CStrObject::length()
{
	return m_nLength;
}

int CStrObject::charCodeAt(int index)
{
	if (index < 0 || index >= m_nLength)
		return -1; // REVIEW: Should be NaN!

	return m_sz[index];
}

CStrObject* CStrObject::charAt(int index)
{
	if (index < 0 || index >= m_nLength)
		return NULL; // REVIEW: Should be [undefined]!

	return new CStrObject(&m_sz[index], 1);
}

CStrObject* CStrObject::concat(const TCHAR* sz)
{
	int cch = _tcslen(sz);
	
	CStrObject* pNewStr = new CStrObject;
	pNewStr->m_nLength = m_nLength + cch;
	pNewStr->m_nAlloc = pNewStr->m_nLength + 1;
	pNewStr->m_sz = new TCHAR [pNewStr->m_nAlloc];
	CopyChars(pNewStr->m_sz, m_sz, m_nLength);
	CopyChars(pNewStr->m_sz + m_nLength, sz, cch);
	pNewStr->m_sz[pNewStr->m_nLength] = '\0';

	return pNewStr;
}

CObject* CStrObject::indexOf(CObject** rgparam, int nParam)
{
	if (nParam < 1 || nParam > 2)
	{
		g_pRunner->Error(_T("invalid number of parameters"));
		return NULL;
	}

	const TCHAR* szSubstring = rgparam[0]->ToStr()->GetSz();

	int nStartIndex = 0;
	if (nParam == 2)
	{
		nStartIndex = (int)rgparam[1]->ToNum()->m_nValue;

		if (nStartIndex < 0)
			nStartIndex = 0;
		else if (nStartIndex > m_nLength)
			nStartIndex = m_nLength;
	}

	int nRet = -1;

	if (nStartIndex < m_nLength)
	{
		const TCHAR* pch = _tcsstr(m_sz + nStartIndex, szSubstring);
		if (pch != NULL)
			nRet = nStartIndex + (int)(pch - m_sz);
	}

	return new CNumObject((float)nRet);
}

const TCHAR* strrstr(const TCHAR* sz, const TCHAR* szFind, int nStartIndex)
{
	int cchSz = _tcslen(sz);
	int cchFind = _tcslen(szFind);

	if (cchSz < cchFind)
		return NULL;

	const TCHAR* pch = sz + nStartIndex - cchFind;
	while (pch >= sz)
	{
		if (_tcsncmp(pch, szFind, cchFind) == 0)
			return pch;
		pch -= 1;
	}

	return pch;
}

CObject* CStrObject::lastIndexOf(CObject** rgparam, int nParam)
{
	if (nParam < 1 || nParam > 2)
	{
		g_pRunner->Error(_T("invalid number of parameters"));
		return NULL;
	}

	const TCHAR* szSubstring = rgparam[0]->ToStr()->GetSz();

	int nStartIndex = m_nLength;
	if (nParam == 2)
	{
		nStartIndex = (int)rgparam[1]->ToNum()->m_nValue;

		if (nStartIndex < 0)
			nStartIndex = 0;
		else if (nStartIndex > m_nLength)
			nStartIndex = m_nLength;
	}

	const TCHAR* pch = strrstr(m_sz, szSubstring, nStartIndex);
	int nRet = -1;
	if (pch != NULL)
		nRet = (int)(pch - m_sz);

	return new CNumObject((float)nRet);
}

CObject* CStrObject::substr(CObject** rgparam, int nParam)
{
	if (nParam < 1 || nParam > 2)
	{
		g_pRunner->Error(_T("invalid number of parameters"));
		return NULL;
	}

	int nStart = (int)rgparam[0]->ToNum()->m_nValue;

	int nLength = m_nLength - nStart;
	if (nParam == 2)
		nLength = (int)rgparam[1]->ToNum()->m_nValue;

	if (nStart > m_nLength)
		nStart = m_nLength;
	if (nLength <= 0)
		nLength = 0;
	else if (nStart + nLength > m_nLength)
		nLength = m_nLength - nStart;

	return new CStrObject(m_sz + nStart, nLength);
}

CObject* CStrObject::substring(CObject** rgparam, int nParam)
{
	if (nParam != 2)
	{
		g_pRunner->Error(_T("invalid number of parameters"));
		return NULL;
	}

	int nStart = (int)rgparam[0]->ToNum()->m_nValue;
	if (nStart < 0)
		nStart = 0;

	int nEnd = (int)rgparam[1]->ToNum()->m_nValue;
	if (nEnd < 0)
		nEnd = nStart;

	if (nStart > nEnd)
	{
		int t = nStart;
		nStart = nEnd;
		nEnd = t;
	}

	if (nStart > m_nLength)
		nStart = m_nLength;
	if (nEnd > m_nLength)
		nEnd = m_nLength;

	return new CStrObject(m_sz + nStart, nEnd - nStart);
}

CStrObject* CStrObject::toLowerCase()
{
	CStrObject* pStrObject = new CStrObject(m_sz, m_nLength);
#ifdef _WINDOWS
	CharLowerBuff(pStrObject->m_sz, pStrObject->m_nLength);
#else
	_tcslwr(pStrObject->m_sz);
#endif
	return pStrObject;
}

CStrObject* CStrObject::toUpperCase()
{
	CStrObject* pStrObject = new CStrObject(m_sz, m_nLength);
#ifdef _WINDOWS
	CharUpperBuff(pStrObject->m_sz, pStrObject->m_nLength);
#else
	_tcsupr(pStrObject->m_sz);
#endif
	return pStrObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Texture.h ===
extern LPDIRECT3DTEXTURE8 LoadTexture(const TCHAR* szURL, UINT width, UINT height);
extern LPDIRECT3DTEXTURE8 ParseTexture(const TCHAR* szURL, const BYTE* pbContent, int cbContent, UINT width=0, UINT height=0);

class CTexture : public CNode
{
	DECLARE_NODE(CTexture, CNode);
public:
	CTexture();
	~CTexture();

	bool m_repeatS;
	bool m_repeatT;

	D3DFORMAT m_format;
	LPDIRECT3DTEXTURE8 m_pSurface;
	int m_nImageWidth;
	int m_nImageHeight;

	virtual bool Create(int nWidth, int nHeight);

	LPDIRECT3DTEXTURE8 GetTextureSurface();

	DECLARE_NODE_PROPS()
};


class CImageTexture : public CTexture
{
	DECLARE_NODE(CImageTexture, CTexture);
public:
	CImageTexture();
	~CImageTexture();

	TCHAR* m_url;
	bool m_alpha;

	LPDIRECT3DTEXTURE8 GetTextureSurface();
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	void Load(const TCHAR* szURL);
	bool m_bDirty;

	DECLARE_NODE_PROPS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\text.cpp ===
#include "std.h"
#include "XApp.h"
#include "Node.h"
#include "Locale.h"
#include "Parser.h"
#include "Runner.h"

#ifndef LF_FACESIZE
#define LF_FACESIZE 32
#endif

TCHAR* g_szText = NULL;

// Oh what a nasty hack...
int g_nTextChar = -1; // index of char where we want a cursor
int g_nTextCharLast = -1;

struct TEXTVERTEX
{
	float x, y, z;
	float nx, ny, nz;
	DWORD color;
};

struct CGlyphVertex
{
	float x, y;
};

struct CGlyphShape
{
	WORD m_nIndexCount;
	WORD m_nVertexCount;
	WORD* m_indices;
	CGlyphVertex* m_vertices;
	int m_nGlyphIndex;    // added to hold the index of the character
};

struct CGlyphMetrics
{
    float gmfBlackBoxX;
    float gmfBlackBoxY;
    CGlyphVertex gmfptGlyphOrigin;
    float gmfCellIncX;
    float gmfCellIncY;
};

struct CGlyphObject
{
	CGlyphMetrics m_metrics;
	CGlyphShape* m_pGlyphShape; // or DWORD m_dwFileOffsetOfGlyphShape
};

struct CWCRange
{
	WCHAR wcLow;
	USHORT cGlyphs;
};

struct CGlyphSet
{
	DWORD cbThis;
	DWORD flAccel;
	DWORD cGlyphsSupported;
	DWORD cRanges;
	CWCRange ranges [1];
};

class CFont
{
public:
	CFont();
	~CFont();

	bool Open(const TCHAR* szFile);
	void Close();
	bool LoadGlyph(int nGlyphIndex);
	int FindGlyphIndex(WCHAR wch);
	void CreateTextMesh(const TCHAR* pchText, int nChars, LPD3DXMESH* ppMesh, D3DXVECTOR3* pMin, D3DXVECTOR3* pMax, float nFormatWidth, bool bDoNotBreak, float scale);
	void CreateCursorMesh(WORD*& indices, int& nCurIndex, TEXTVERTEX*& verts, int& nCurVertex, float x, float y, bool visible);
    bool IsBreakChar(TCHAR ch);

	HANDLE m_hFile;
	CGlyphSet* m_pGlyphSet;
	CGlyphObject* m_rgGlyphObjects;
	bool* m_rgGlyphLoaded;
};

CFont::CFont()
{
	m_hFile = INVALID_HANDLE_VALUE;
	m_pGlyphSet = NULL;
	m_rgGlyphObjects = NULL;
	m_rgGlyphLoaded = NULL;
}

CFont::~CFont()
{
	Close();
}

void CFont::Close()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
		VERIFY(CloseHandle(m_hFile));

	if (m_pGlyphSet != NULL)
	{
		for (UINT i = 0; i < m_pGlyphSet->cGlyphsSupported; i += 1)
		{
			if (m_rgGlyphLoaded[i])
			{
				CGlyphShape* pGlyphShape = m_rgGlyphObjects[i].m_pGlyphShape;
				delete [] pGlyphShape->m_indices;
				delete [] pGlyphShape->m_vertices;
				delete pGlyphShape;
			}
		}
	}

	delete [] (BYTE*)m_pGlyphSet;
	delete [] m_rgGlyphObjects;
	delete [] m_rgGlyphLoaded;

	m_hFile = INVALID_HANDLE_VALUE;
	m_pGlyphSet = NULL;
	m_rgGlyphObjects = NULL;
	m_rgGlyphLoaded = NULL;
}

bool CFont::Open(const TCHAR* szFile)
{
	ASSERT(m_hFile == INVALID_HANDLE_VALUE);

	m_hFile = XAppCreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (m_hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwRead;

	DWORD dwMagic;
	ReadFile(m_hFile, &dwMagic, 4, &dwRead, NULL);

	if (dwMagic != 0x30465458) // "XTF0"
	{
		TRACE(_T("\001Invalid font file: %s\n"), szFile);

		VERIFY(CloseHandle(m_hFile));
		m_hFile = INVALID_HANDLE_VALUE;

		return false;
	}

	// BLOCK: Skip header...
	{
		DWORD dwHeaderLen;
		VERIFY(ReadFile(m_hFile, &dwHeaderLen, 4, &dwRead, NULL));

		ASSERT(dwHeaderLen == LF_FACESIZE);

		char szFace [LF_FACESIZE];
		VERIFY(ReadFile(m_hFile, szFace, LF_FACESIZE, &dwRead, NULL));

	}

	DWORD cbGlyphSet;
	VERIFY(ReadFile(m_hFile, &cbGlyphSet, 4, &dwRead, NULL));

	m_pGlyphSet = (CGlyphSet*)new BYTE [cbGlyphSet];
	m_pGlyphSet->cbThis = cbGlyphSet;
	VERIFY(ReadFile(m_hFile, ((BYTE*)m_pGlyphSet) + 4, cbGlyphSet - 4, &dwRead, NULL));

	m_rgGlyphObjects = new CGlyphObject [m_pGlyphSet->cGlyphsSupported];
	VERIFY(ReadFile(m_hFile, m_rgGlyphObjects, sizeof (CGlyphObject) * m_pGlyphSet->cGlyphsSupported, &dwRead, NULL));

	m_rgGlyphLoaded = new bool [m_pGlyphSet->cGlyphsSupported];
	ZeroMemory(m_rgGlyphLoaded, sizeof (bool) * m_pGlyphSet->cGlyphsSupported);

	return true;
}

bool CFont::LoadGlyph(int nGlyphIndex)
{
	ASSERT(m_pGlyphSet != NULL);
	ASSERT(nGlyphIndex >= 0 && (UINT)nGlyphIndex < m_pGlyphSet->cGlyphsSupported);

	if (m_rgGlyphLoaded[nGlyphIndex])
		return true;

	VERIFY(SetFilePointer(m_hFile, (DWORD)m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape, 0, FILE_BEGIN) != ~0);
	CGlyphShape* pGlyphShape = new CGlyphShape;
    ASSERT(pGlyphShape);

	DWORD dwRead;
	
	VERIFY(ReadFile(m_hFile, &pGlyphShape->m_nIndexCount, 2, &dwRead, NULL));
	pGlyphShape->m_indices = new WORD [pGlyphShape->m_nIndexCount];

	VERIFY(ReadFile(m_hFile, &pGlyphShape->m_nVertexCount, 2, &dwRead, NULL));
	pGlyphShape->m_vertices = new CGlyphVertex [pGlyphShape->m_nVertexCount];

	VERIFY(ReadFile(m_hFile, pGlyphShape->m_indices, sizeof (WORD) * pGlyphShape->m_nIndexCount, &dwRead, NULL));
	VERIFY(ReadFile(m_hFile, pGlyphShape->m_vertices, sizeof (CGlyphVertex) * pGlyphShape->m_nVertexCount, &dwRead, NULL));

	m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape = pGlyphShape;
	m_rgGlyphLoaded[nGlyphIndex] = true;

	return true;
}

int CFont::FindGlyphIndex(WCHAR wch)
{
	int nIndex = 0;

	for (UINT i = 0; i < m_pGlyphSet->cRanges; i += 1)
	{
		if (wch >= m_pGlyphSet->ranges[i].wcLow && wch < m_pGlyphSet->ranges[i].wcLow + m_pGlyphSet->ranges[i].cGlyphs)
			return nIndex + wch - m_pGlyphSet->ranges[i].wcLow;

		nIndex += m_pGlyphSet->ranges[i].cGlyphs;
	}

	if (wch != 127)
		return FindGlyphIndex(127); // the invalid char box

	return 0; // "invalid char" glyph (it's a space)
}

inline float smoothstep(float a, float b, float x)
{
	if (x < a)
		return 0.0f;

	if (x >= b)
		return 1.0f;

	x = (x - a) / (b - a);

	return (x * x * (3 - 2 * x));
}

// Adjust the alpha value for verts whose x is between nStart and nEnd such that they fade
// from opaque to transparent (bRight==true) or transparent to opaque (bRight==false).
static void HorizontalFade(TEXTVERTEX* verts, int nVertexCount, float nStart, float nEnd, bool bRight)
{
	float nWidth = nEnd - nStart;

	for (int i = 0; i < nVertexCount; i += 1)
	{
		float a = (verts[i].x - nStart) / nWidth;
		a = smoothstep(0.0f, 1.0f, a);

		if (bRight)
			a = 1.0f - a;

		float a0 = (float)(verts[i].color >> 24);
		verts[i].color = (verts[i].color & 0x00ffffff) | (((DWORD)(a0 * a)) << 24);
	}
}

inline void FadeLeftEdge(TEXTVERTEX* verts, int nVertexCount, float nStart, float nEnd)
{
	HorizontalFade(verts, nVertexCount, nStart, nEnd, false);
}

inline void FadeRightEdge(TEXTVERTEX* verts, int nVertexCount, float nStart, float nEnd)
{
	HorizontalFade(verts, nVertexCount, nStart, nEnd, true);
}

static void VerticalFade(TEXTVERTEX* verts, int nVertexCount, float nTop, float nBottom, float nScroll)
{
	for (int i = 0; i < nVertexCount; i += 1)
	{
		float a = 1.0f;
		float y = verts[i].y + nScroll;

		if (y > nTop || y < nBottom)
		{
			a = 0.0f;
		}
		else if (y > nTop - 1.0f)
		{
			a = 1.0f - (y - (nTop - 1.0f));
		}
		else if (y < nBottom + 1.0f)
		{
			a = 1.0f - ((nBottom + 1.0f) - y);
		}
		else //if (y >= nTop + 1.0f && y <= nBottom - 1.0f)
		{
			a = 1.0f;
		}

		ASSERT(a >= 0.0f && a <= 1.0f);

		a = smoothstep(0.0f, 1.0f, a);
//		float a0 = (float)(verts[i].color >> 24);
		verts[i].color = (verts[i].color & 0x00ffffff) | (((DWORD)(255.0f * a)) << 24);
	}
}

bool CFont::IsBreakChar(TCHAR ch)
{
    // Basically, we will break after double byte or single byte Kana
    if (ch == ' ' || (ch >= 0x3040 && ch < 0xF000) || ch >= 0xFF66)
    {
        return true;
    }

    return false;
}

extern void XAppCreateMeshFVF(DWORD NumFaces, DWORD NumVertices, DWORD Options, DWORD FVF, LPD3DXMESH* ppMesh);

void CFont::CreateTextMesh(const TCHAR* pchText, int nChars, LPD3DXMESH* ppMesh, D3DXVECTOR3* pMin, D3DXVECTOR3* pMax, float nFormatWidth, bool bDoNotBreak, float scale)
{
	bool bFade = bDoNotBreak;

	if (nChars == -1)
		nChars = _tcslen(pchText);

	LPD3DXMESH pMesh = NULL;
	int nFaces = 0, nVerts = 0;

	int ich = 0;
	float nMaxCol1Width = 0.0f;
	float nMaxCol2Width = 0.0f;
	bool bSingleLine = true;
	bool bSingleColumn = true;
	bool bAsterisk = false;
	for (int nLine = 0; ich < nChars; nLine += 1)
	{
		int nColumn = 1;
		float nCol1Width = 0.0f;
		float nCol2Width = 0.0f;

		if (pchText[ich] == '*')
		{
			// See if there's a '*' at the end of the line...
			for (int ich2 = ich + 1; ich2 < nChars && pchText[ich2] != '\n' && pchText[ich2] != '\r' && pchText[ich2] != '\t'; ich2 += 1)
				;
			if (ich2 > ich + 1 && pchText[ich2 - 1] == '*')
			{
				// Line starts and ends with a *; don't show the *'s and format as a heading
				bAsterisk = true;
				ich += 1;
			}
		}

		while (ich < nChars)
		{
			TCHAR ch = pchText[ich];
			ich += 1;

			if (ch == '*')
			{
				// Ignore this if it's the last visible char in the column...
				if (bAsterisk && (ich == nChars || pchText[ich] == '\t' || pchText[ich] == '\n' || pchText[ich] == '\r'))
					continue;
			}

			if (bDoNotBreak == false && ch == '\r' && ich < nChars && pchText[ich] == '\n')
            {
				ich += 1;
            }

			if (bDoNotBreak == false && (ch == '\n' || ch == '\r'))
			{
				bSingleLine = false;
				break;
			}

			if (ch == '\t' && bDoNotBreak == false)
			{
				nColumn = 2;
				bSingleColumn = false;
				bAsterisk = false;

				if (ich < nChars && pchText[ich] == '*')
				{
					// See if there's a '*' at the end of the line...
					for (int ich2 = ich + 1; ich2 < nChars && pchText[ich2] != '\n' && pchText[ich2] != '\r' && pchText[ich2] != '\t'; ich2 += 1)
						;
					if (ich2 > ich + 1 && pchText[ich2 - 1] == '*')
					{
						// Column starts and ends with a *; don't show the *'s and format as a heading
						ich += 1;
						bAsterisk = true;
					}
				}
				continue;
			}

			int nGlyphIndex = FindGlyphIndex(ch);
			if (nGlyphIndex == -1)
				continue;

			VERIFY(LoadGlyph(nGlyphIndex));

			CGlyphShape* pGlyphShape = m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape;
			pGlyphShape->m_nGlyphIndex = nGlyphIndex;

			if (nVerts + pGlyphShape->m_nVertexCount > 65535)
			{
				TRACE(_T("CreateTextMesh: too much text!\n"));
				nChars = ich - 1; // truncate string
				break;
			}

			if (nColumn == 1)
				nCol1Width += m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX;
			else
				nCol2Width += m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX;

			nFaces += pGlyphShape->m_nIndexCount / 3;
			nVerts += pGlyphShape->m_nVertexCount;
		}

		if (nCol1Width > nMaxCol1Width)
			nMaxCol1Width = nCol1Width;

		if (nCol2Width > nMaxCol2Width)
			nMaxCol2Width = nCol2Width;
	}

	if (g_nTextChar >= 0 && g_nTextChar <= nChars)
	{
		nFaces += 2;
		nVerts += 4;
	}

	if (nFaces == 0)
		return;

	if (nFormatWidth > 0.0f)
	{
		if (bSingleColumn)
		{
			nMaxCol1Width = nFormatWidth;
		}
		else if (nMaxCol1Width + nMaxCol2Width > nFormatWidth)
		{
			nMaxCol1Width = nFormatWidth - nMaxCol2Width;
			// Adjust the widths proportionately to fit in nFormatWidth
//			float d = nFormatWidth / (nMaxCol1Width + nMaxCol2Width);
//			nMaxCol1Width *= d;
//			nMaxCol2Width *= d;
			bFade = true;
		}
	}
	else
	{
		bFade = false;
	}

//	TRACE(_T("Creating text mesh with %d indices and %d vertices (about %dKB)\n"), nFaces * 3, nVerts, ((nFaces * 3 * sizeof (WORD)) + (nVerts * 6 * sizeof (float)) + 512) / 1024);
//	VERIFYHR(D3DXCreateMeshFVF(nFaces, nVerts, D3DXMESH_MANAGED, D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE, XAppGetD3DDev(), &pMesh));
	XAppCreateMeshFVF(nFaces, nVerts, D3DXMESH_MANAGED, D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE, &pMesh);
	*ppMesh = pMesh;

	WORD* indices;
	pMesh->LockIndexBuffer(D3DLOCK_DISCARD, (BYTE**)&indices);

	TEXTVERTEX* verts;
	pMesh->LockVertexBuffer(D3DLOCK_DISCARD, (BYTE**)&verts);

	float r = 1.0f;
	float g = 1.0f;
	float b = 1.0f;
	bool bTitle = false;
	bool bStartPara = true;
	int nCurIndex = 0;
	int nCurVertex = 0;
	float x = 0.0f;
	float y = 0.0f;
	ich = 0;
	for (nLine = 0; ich < nChars; nLine += 1)
	{
		int nColumn = 1;
		int nFirstColVertex = nCurVertex;
		float nCol2Width = 0.0f;
		float nMaxColWidth = nMaxCol1Width;

		int nBreakChar = -1;
		int nBreakVertex = nCurVertex;
		int nBreakIndex = nCurIndex;

		if (bStartPara && ich < nChars && pchText[ich] == '*')
		{
			// See if there's a '*' at the end of the line...
			for (int ich2 = ich + 1; ich2 < nChars && pchText[ich2] != '\n' && pchText[ich2] != '\r' && pchText[ich2] != '\t'; ich2 += 1)
				;
			if (ich2 > ich + 1 && pchText[ich2 - 1] == '*')
			{
				// Line starts and ends with a *; don't show the *'s and format as a heading
				r = 1.0f;
				g = 1.0f;
				b = 0.5f;
				bTitle = true;

				ich += 1;
			}
		}

		// Skip spaces at the start of lines
//		while (ich < nChars && pchText[ich] == ' ')
//			ich += 1;

		for (;;)
		{
			TCHAR ch = '\r';
			if (ich < nChars)
			{
				ch = pchText[ich];
				ich += 1;

				if (ch == '\r' && ich < nChars && pchText[ich] == '\n')
					ich += 1;
			}

			if (ch == '\n' || ch == '\r')
			{
                if (bDoNotBreak && bFade)
                {
                    FadeRightEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nMaxColWidth - 1, nMaxColWidth);
                    break;
                }

				if (nColumn == 2)
				{
					// Right justify the second column...
					for (int i = nFirstColVertex; i < nCurVertex; i += 1)
						verts[i].x += nMaxCol2Width - nCol2Width;

//					if (bFade)
//						FadeLeftEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nFormatWidth - nMaxCol2Width + 1, nFormatWidth);
				}
				else
				{
					if (bFade)
						FadeRightEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nMaxColWidth - 1, nMaxColWidth);
				}

				if (ich != nChars)
				{
					x = 0.0f;
					if (bTitle || ch == '\r' || !bSingleColumn)
						y -= 1.0f;
					else
						y -= 1.5f;
				}
				bTitle = false;
				bStartPara = true;
				break;
			}

			if (ch == '\t' && bDoNotBreak == false)
			{
				if (bFade)
					FadeRightEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nMaxColWidth - 2, nMaxColWidth);

				nColumn = 2;
				x = nFormatWidth - nMaxCol2Width;
				nFirstColVertex = nCurVertex;
				nMaxColWidth = nMaxCol2Width;
				bTitle = false;
				bStartPara = true;

				if (ich < nChars && pchText[ich] == '*')
				{
					// See if there's a '*' at the end of the line...
					for (int ich2 = ich + 1; ich2 < nChars && pchText[ich2] != '\n' && pchText[ich2] != '\r' && pchText[ich2] != '\t'; ich2 += 1)
						;
					if (ich2 > ich + 1 && pchText[ich2 - 1] == '*')
					{
						// Line starts and ends with a *; don't show the *'s and format as a heading
						r = 1.0f;
						g = 1.0f;
						b = 0.5f;
						bTitle = true;

						ich += 1;
					}
				}

				continue;
			}

			if (bTitle && ch == '*')
			{
				// Ignore this if it's the last visible char in the column...
				if (ich == nChars || pchText[ich] == '\t' || pchText[ich] == '\n' || pchText[ich] == '\r')
				{

					r = 1.0f;
					g = 1.0f;
					b = 1.0f;
					continue;
				}
			}

			bStartPara = false;

			int nGlyphIndex = FindGlyphIndex(ch);
			if (nGlyphIndex == -1)
				continue;

			ASSERT(m_rgGlyphLoaded[nGlyphIndex]);

			if (nFormatWidth > 0.0f)
			{
				if (bDoNotBreak)
				{
					if (x > nFormatWidth)
					{
						// TODO: Don't bother placing these chars in the buffer...
//						continue; // messes up vert count from first pass!
					}
				}
				else
				{
					if (ch != ' ' && nColumn == 1 && x + m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX > nFormatWidth)
					{

						// break line

						if (nBreakChar > -1)
						{
							x = 0.0f;
							y -= 1.0f;

							ich = nBreakChar /*- 1*/;
							nCurVertex = nBreakVertex;
							nCurIndex = nBreakIndex;

							nBreakChar = -1;
							nBreakVertex = nCurVertex;
							nBreakIndex = nCurIndex;

//							while (ich < nChars && pchText[ich] == ' ')
//								ich += 1;

							continue;
						}
						else
						{
							// one word was too long to fit, fade it!
							bFade = true;
						}
					}
				}
			}

			CGlyphShape* pGlyphShape = m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape;

			for (int j = 0; j < pGlyphShape->m_nIndexCount; j += 1)
				indices[nCurIndex++] = nCurVertex + pGlyphShape->m_indices[j];

			//ALERT(_T("GlyphIndex of character: %d"), pGlyphShape->m_nGlyphIndex);
			float fontAdjust = 1.0f;

			if(pGlyphShape->m_nGlyphIndex > 190)   //character is in the japanese font set
			{
				fontAdjust = 0.9f;
			}

			for (j = 0; j < pGlyphShape->m_nVertexCount; j += 1)
			{
				verts[nCurVertex].x = x + (pGlyphShape->m_vertices[j].x * fontAdjust);
				verts[nCurVertex].y = y + (pGlyphShape->m_vertices[j].y * fontAdjust);
				verts[nCurVertex].z = 0.0f;

				verts[nCurVertex].nx = 0.0f;
				verts[nCurVertex].ny = 0.0f;
				verts[nCurVertex].nz = 1.0f;

				verts[nCurVertex].color = D3DCOLOR_COLORVALUE(r, g, b, 1.0f);

				nCurVertex += 1;
			}

			if (ich - 1 == g_nTextChar)
			{
				CreateCursorMesh(indices, nCurIndex, verts, nCurVertex, x, y, true);
			}

			x += (m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX * fontAdjust);

			if (nColumn == 2)
				nCol2Width += m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX;

			if (IsBreakChar(ch))
			{
				nBreakChar = ich;
				nBreakVertex = nCurVertex;
				nBreakIndex = nCurIndex;
			}
		}
	}

	if (g_nTextChar == nChars)
	{
		bool visible = false;
		if(x < 16.556152f)  //value to keep the cursor from extending past the keyboard blank
			visible = true;

		CreateCursorMesh(indices, nCurIndex, verts, nCurVertex, x, y, visible);
	}

	ASSERT(nCurVertex == nVerts);
	ASSERT(nCurIndex == nFaces * 3);

	for (int i = 0; i < nVerts; i += 1)
	{
		verts[i].x *= scale;
		verts[i].y *= scale;
		verts[i].z *= scale;
	}

	if (pMin != NULL && pMax != NULL)
		VERIFYHR(D3DXComputeBoundingBox(verts, nCurVertex, D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE, pMin, pMax));
	
	pMesh->UnlockIndexBuffer();
	pMesh->UnlockVertexBuffer();
}

void CFont::CreateCursorMesh(WORD*& indices, int& nCurIndex, TEXTVERTEX*& verts, int& nCurVertex, float x, float y, bool visible)
{
	float t = (float) (XAppGetNow()) * 2.0f;
	float a = fabsf(sinf(t * D3DX_PI));
	if(!visible)
		a = 0.0f;

	indices[nCurIndex++] = (WORD)nCurVertex;
	indices[nCurIndex++] = (WORD)nCurVertex + 1;
	indices[nCurIndex++] = (WORD)nCurVertex + 2;

	indices[nCurIndex++] = (WORD)nCurVertex;
	indices[nCurIndex++] = (WORD)nCurVertex + 2;
	indices[nCurIndex++] = (WORD)nCurVertex + 3;

	verts[nCurVertex].x = x;
	verts[nCurVertex].y = y - 0.1f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;

	verts[nCurVertex].x = x + 0.1f;
	verts[nCurVertex].y = y - 0.1f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;

	verts[nCurVertex].x = x + 0.1f;
	verts[nCurVertex].y = y + 0.75f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;

	verts[nCurVertex].x = x;
	verts[nCurVertex].y = y + 0.75f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;
}

////////////////////////////////////////////////////////////////////////////

struct CFontTableEntry
{
	CFontTableEntry()
	{
		m_szFaceName = NULL;
		m_szFileName = NULL;
	}

	CFontTableEntry(const TCHAR* szFaceName, const TCHAR* szFileName)
	{
		m_szFaceName = szFaceName;
		m_szFileName = szFileName;
	}

	const TCHAR* m_szFaceName;
	const TCHAR* m_szFileName;
	CFont m_font;
};

#define MAX_FONT_COUNT 10

CFontTableEntry g_fonts [MAX_FONT_COUNT] =
{
	// NOTE: The first font is used as the default when a specified font is not found!
	CFontTableEntry(_T("HGGothicM"), _T("HGGothicM.xtf")),
};

int g_nFontCount = 1;

void InitFontTable()
{
	TCHAR szWild [MAX_PATH];
	WIN32_FIND_DATA fd;
	HANDLE h;

	int cchAppDir = _tcslen(theApp.m_szAppDir);

	_tcscpy(szWild, theApp.m_szAppDir);
	_tcscpy(szWild + cchAppDir, _T("*.xtf"));

#if defined(_XBOX)
	char szWildA [MAX_PATH];
	Ansi(szWildA, szWild, MAX_PATH);
	h = FindFirstFile(szWildA, &fd);
#else
	h = FindFirstFile(szWild, &fd);
#endif

	if (h == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001InitFontTable: No fonts!\n"));
		return;
	}

	do
	{
		TCHAR szFileName [MAX_PATH];

		_tcscpy(szFileName, theApp.m_szAppDir);

#if defined(_XBOX)
		Unicode(szFileName + cchAppDir, fd.cFileName, countof(szFileName));
#else
		_tcscpy(szFileName + cchAppDir, fd.cFileName);
#endif

		if (g_nFontCount >= MAX_FONT_COUNT)
		{
			TRACE(_T("\001InitFontTable: too many fonts!\n"));
			continue;
		}

		HANDLE hFont = XAppCreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFont != INVALID_HANDLE_VALUE)
		{
			DWORD dwRead;
			DWORD cbGlyphSet;
			ReadFile(hFont, &cbGlyphSet, 4, &dwRead, NULL);

			if (cbGlyphSet == 0x30465458)
			{
				DWORD dwHeaderLen;
				ReadFile(hFont, &dwHeaderLen, 4, &dwRead, NULL);

				ASSERT(dwHeaderLen == LF_FACESIZE);

				char szFaceA [LF_FACESIZE];
				ReadFile(hFont, szFaceA, LF_FACESIZE, &dwRead, NULL);

				TCHAR* szFace = new TCHAR [strlen(szFaceA) + 1];
#ifdef _UNICODE
				Unicode(szFace, szFaceA, LF_FACESIZE);
#else
				_tcscpy(szFace, szFaceA);
#endif

				// Don't add the default font twice!
				if (_tcscmp(szFace, g_fonts[0].m_szFaceName) == 0)
				{
					delete [] szFace;
				}
				else
				{
					TCHAR* szFile = new TCHAR [_tcslen(szFileName) + 1];
					_tcscpy(szFile, szFileName);

					g_fonts[g_nFontCount].m_szFaceName = szFace;
					g_fonts[g_nFontCount].m_szFileName = szFile;
					g_nFontCount += 1;

					TRACE(_T("Adding font: %s (%s)\n"), szFace, szFile);
				}
			}

			CloseHandle(hFont);
		}
	}
	while (FindNextFile(h, &fd));

	FindClose(h);
}

CFont* GetFont(const TCHAR* szFaceName)
{
	if (g_nFontCount == 1)
		InitFontTable();

	for (int i = 0; i < g_nFontCount; i += 1)
	{
		if (_tcsicmp(szFaceName, g_fonts[i].m_szFaceName) == 0)
			break;
	}

	if (i == g_nFontCount)
	{
		TRACE(_T("Substituting font '%s' for '%s'\n"), g_fonts[0].m_szFaceName, szFaceName);
		i = 0;
	}

	if (g_fonts[i].m_font.m_hFile == INVALID_HANDLE_VALUE)
	{
		TCHAR szFontPath [MAX_PATH];

		if (_tcschr(g_fonts[i].m_szFileName, ':') == NULL)
			_stprintf(szFontPath, _T("%s%s"), theApp.m_szAppDir, g_fonts[i].m_szFileName);
		else
			_tcscpy(szFontPath, g_fonts[i].m_szFileName);

		if (!g_fonts[i].m_font.Open(szFontPath))
		{
			TRACE(_T("\001Cannot load font: %s\n"), szFaceName);

			if (g_fonts[0].m_font.m_hFile == INVALID_HANDLE_VALUE)
			{
				if (!g_fonts[0].m_font.Open(g_fonts[0].m_szFileName))
				{
					ASSERT(FALSE);
					return NULL;
				}
			}
		}
	}

	return &g_fonts[i].m_font;
}

void Text_Exit()
{
	for (int i = 0; i < g_nFontCount; i += 1)
	{
		if (i > 0)
		{
			delete [] (TCHAR*)g_fonts[i].m_szFaceName;
			delete [] (TCHAR*)g_fonts[i].m_szFileName;
			g_fonts[i].m_szFaceName = NULL;
			g_fonts[i].m_szFileName = NULL;
		}
		g_fonts[i].m_font.Close();
	}
}

////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

class CTextNode : public CNode
{
	DECLARE_NODE(CTextNode, CNode)
public:
	CTextNode();
	~CTextNode();

	void Render();
	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	TCHAR* m_text;
	TCHAR* m_font;
	TCHAR* m_justify;
	float m_deviation;
	float m_extrusion;
	float m_width;
	bool m_translate;
	float m_height;
	float m_scroll;
	float m_scrollRate;
	float m_scrollDelay;

	DECLARE_NODE_PROPS()

	LPD3DXMESH m_pMesh;
	D3DXVECTOR3 m_bboxMin, m_bboxMax;
	int m_nLanguage;
	XTIME m_timeToScroll;
};

static const float nScrollSpace = 1.5f;

IMPLEMENT_NODE("Text", CTextNode, CNode)

START_NODE_PROPS(CTextNode, CNode)
	NODE_PROP(pt_string, CTextNode, text)
	NODE_PROP(pt_string, CTextNode, font)
	NODE_PROP(pt_string, CTextNode, justify)
	NODE_PROP(pt_number, CTextNode, deviation)
	NODE_PROP(pt_number, CTextNode, extrusion)
	NODE_PROP(pt_number, CTextNode, width)
	NODE_PROP(pt_boolean, CTextNode, translate)
	NODE_PROP(pt_number, CTextNode, height)
	NODE_PROP(pt_number, CTextNode, scroll)
	NODE_PROP(pt_number, CTextNode, scrollRate)
	NODE_PROP(pt_number, CTextNode, scrollDelay)
END_NODE_PROPS()

CTextNode::CTextNode() :
	m_text(NULL),
	m_font(NULL),
	m_justify(NULL),
	m_deviation(0.01f),
	m_extrusion(1.0f),
	m_translate(true),
	m_width(0.0f),
	m_height(0.0f),
	m_scroll(0.0f),
	m_scrollRate(0.0f),
	m_scrollDelay(0.0f)
{
	m_pMesh = NULL;
	m_nLanguage = 0;
	m_timeToScroll = 0.0f;
}

CTextNode::~CTextNode()
{
	delete [] m_text;
	delete [] m_font;
	delete [] m_justify;

	if (m_pMesh != NULL)
		m_pMesh->Release();
}

void CTextNode::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_scrollRate > 0.0f && m_pMesh != NULL)
	{
		XTIME now = XAppGetNow();

		if (m_timeToScroll == 0.0f)
			m_timeToScroll = now + m_scrollDelay;

		if (now >= m_timeToScroll)
		{
			float nContentHeight = m_bboxMax.y - m_bboxMin.y;
			if (nContentHeight > m_height)
			{
				m_scroll += m_height * nSeconds * m_scrollRate;
				if (m_scroll >= nContentHeight + nScrollSpace)
					m_scroll -= nContentHeight + nScrollSpace;
			}
		}
	}
}

const TCHAR* FaceFromFont(const TCHAR* szFont)
{
	const TCHAR* szFace = szFont;
/*
	if (nLanguage == LANGUAGE_JAPANESE)
	{
		if (szFont == NULL || _tcsicmp(szFont, _T("body")) == 0)
			szFace = _T("HGSSoEikakuGothicB");
		else if (_tcsicmp(szFont, _T("heading")) == 0)
			szFace = _T("HGMaroGothicMPRO");
	}
	else
*/
	{
		if (szFont == NULL || _tcsicmp(szFont, _T("body")) == 0)
			szFace = _T("XBox Book");
		else if (_tcsicmp(szFont, _T("heading")) == 0)
			szFace = _T("Xbox");
	}

	return szFace;
}

void CTextNode::Render()
{
	bool bInvalidMesh = false;

	if (g_szText != NULL)
	{
		if (m_text == NULL || _tcscmp(m_text, g_szText) != 0 || g_nTextChar != g_nTextCharLast)
		{
			delete [] m_text;
			m_text = new TCHAR [_tcslen(g_szText) + 1];
			_tcscpy(m_text, g_szText);
			g_nTextCharLast = g_nTextChar;
			bInvalidMesh = true;
		}

		g_szText = NULL;
	}

	const TCHAR* szText = m_text;
	if (szText == NULL || szText[0] == 0)
		return;

	if (_tcsncmp(m_text, _T("<clock>"), 7) == 0)
	{
		SYSTEMTIME st;
		GetLocalTime(&st);

		TCHAR szBuf [32];
		FormatTime(szBuf, countof(szBuf), &st);

		if (_tcscmp(m_text + 7, szBuf) != 0)
		{
			delete [] m_text;
			m_text = new TCHAR [7 + _tcslen(szBuf) + 1];
			_stprintf(m_text, _T("<clock>%s"), szBuf);

			bInvalidMesh = true;
		}

		m_translate = false;
		szText = m_text + 7; // look past the <clock>
	}

	if (m_translate && m_nLanguage != g_nCurLanguage)
		bInvalidMesh = true;

	if (m_pMesh != NULL && bInvalidMesh)
	{
		m_pMesh->Release();
		m_pMesh = NULL;
	}

	if (m_pMesh == NULL)
	{
        TCHAR sz[MAX_TRANSLATE_LEN];

		if (m_translate)
			szText = Translate(szText, sz);

		m_nLanguage = g_nCurLanguage;

		CFont* pFont = GetFont(FaceFromFont(m_font));
		pFont->CreateTextMesh(szText, -1, &m_pMesh, &m_bboxMin, &m_bboxMax, fabsf(m_width), m_width < 0.0f, g_nCurLanguage == LANGUAGE_JAPANESE ? 1.0f : 1.0f);
		if (m_pMesh == NULL)
			return;
	}

	float nContentHeight = m_bboxMax.y - m_bboxMin.y;

	float xOffset = 0.0f;
	if (m_justify != NULL)
	{
		float nWidth = m_bboxMax.x - m_bboxMin.x;
		if (m_width != 0.0f)
		{
			float widthLimit = fabsf(m_width);
			if (nWidth > widthLimit)
				nWidth = widthLimit;
		}

		if (_tcsicmp(m_justify, _T("middle")) == 0)
		{
			xOffset = -nWidth / 2.0f;
			if (m_width < 0.0f)
			{
				// TODO: Fade both sides
			}
		}
		else if (_tcsicmp(m_justify, _T("end")) == 0)
		{
			xOffset = -nWidth;
			if (m_width < 0.0f)
			{
				// TODO: Fade left side
			}
		}
	}

	for (int i = 0; i < 2; i += 1)
	{
		if (m_height != 0.0f && nContentHeight > m_height)
		{
			TEXTVERTEX* verts;
			m_pMesh->LockVertexBuffer(0, (BYTE**)&verts);
			float yTop = -m_scroll + 1.0f;
			float yBottom = yTop - m_height - 2.0f;
			if (m_scroll == 0.0f)
				yTop += 1.0f; // don't fade at top when not scrolled...
			VerticalFade(verts, m_pMesh->GetNumVertices(), yTop/* + 0.5f*/, yBottom, i == 0 ? 0 : -(nContentHeight + nScrollSpace));
			m_pMesh->UnlockVertexBuffer();
		}
		else if (i == 1)
		{
			// Don't need second pass if not scrolling...
			break;
		}

		// Don't need second pass unless part of it is visible...
		if (i == 1 && m_scroll + m_height < nContentHeight)
			break;

		XAppPushWorld();
		XAppTranslateWorld(xOffset, (i == 0 ? 0 : -(nContentHeight + nScrollSpace)) + m_scroll, 0.0f);
		XAppUpdateWorld();

		XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
		m_pMesh->DrawSubset(0);
		XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

		XAppPopWorld();
	}
}


bool CTextNode::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_scroll))
		return true; // don't need to invalidate

	if (m_pMesh != NULL)
	{
		m_pMesh->Release();
		m_pMesh = NULL;
	}

	m_scroll = 0;
	m_timeToScroll = 0.0f;

	return true;
}

////////////////////////////////////////////////////////////////////////////

#define MAX_TEXT_CACHE	10

struct CTextCacheEntry
{
	CTextNode* m_pTextNode;
	XTIME m_usage;
};

static CTextCacheEntry textCache [MAX_TEXT_CACHE];


static CTextCacheEntry* FindText(const TCHAR* szText, float nWidth)
{
	CTextCacheEntry* pFreeOne = NULL;
	CTextCacheEntry* pOldOne = NULL;
	for (int i = 0; i < countof(textCache); i += 1)
	{
		if (textCache[i].m_pTextNode != NULL && textCache[i].m_pTextNode->m_text != NULL && _tcscmp(textCache[i].m_pTextNode->m_text, szText) == 0 && textCache[i].m_pTextNode->m_width == nWidth)
		{
//			TRACE(_T("Found %s in image cache\n"), szURL);
			textCache[i].m_usage = XAppGetNow();
			return &textCache[i];
		}

		if (pFreeOne != NULL)
			continue;

		if (textCache[i].m_pTextNode == NULL)
			pFreeOne = &textCache[i];
		else if (pOldOne == NULL || pOldOne->m_usage > textCache[i].m_usage)
			pOldOne = &textCache[i];
	}

	if (pFreeOne == NULL && pOldOne != NULL)
	{
		delete [] pOldOne->m_pTextNode;
		ZeroMemory(pOldOne, sizeof (CTextCacheEntry));
		pFreeOne = pOldOne;
	}

	ASSERT(pFreeOne != NULL);

	pFreeOne->m_pTextNode = new CTextNode;
	pFreeOne->m_pTextNode->m_text = new TCHAR [_tcslen(szText) + 1];
	pFreeOne->m_pTextNode->m_width = nWidth;
	_tcscpy(pFreeOne->m_pTextNode->m_text, szText);

	pFreeOne->m_usage = XAppGetNow();

	return pFreeOne;
}

CNode* GetTextNode(const TCHAR* szText, float nWidth)
{
	CTextCacheEntry* pTextCache = FindText(szText, nWidth);
	pTextCache->m_pTextNode->m_translate = false;
	return pTextCache->m_pTextNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\timezone.h ===
//
// English time zone strings are in english.txt
//

struct TZDATE {
    BYTE month;
    BYTE day;
    BYTE dayofweek;
    BYTE hour;
};

struct TZINFO {
    const TCHAR* dispname;
    SHORT dltflag;
    SHORT bias;
    SHORT stdbias;
    SHORT dltbias;
    const WCHAR* stdname;
    struct TZDATE stddate;
    const WCHAR* dltname;
    struct TZDATE dltdate;
};

#define TIMEZONECOUNT (sizeof(g_timezoneinfo) / sizeof(g_timezoneinfo[0]))

#define NA_DEFAULT_TIMEZONE     11 // Eastern
#define JAPAN_DEFAULT_TIMEZONE  60 // Tokyo
#define ROW_DEFAULT_TIMEZONE    25 // London


static const struct TZINFO g_timezoneinfo[] = {
    {
      _T("GMT-12"), // _T("GMT-12 Tokelau"),
      0,
      720,
      0,
      0,
      L"IDLW", // L"Dateline Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-11"), // _T("GMT-11 Samoa"),
      0,
      660,
      0,
      0,
      L"NT", // L"Samoa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-10"), // _T("GMT-10 Hawaii"),
      0,
      600,
      0,
      0,
      L"HST", // L"Hawaiian Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-09YDT"), // _T("GMT-09 Alaska"),
      1,
      540,
      0,
      -60,
      L"YST", // L"Alaskan Standard Time",
      { 10, 5, 0, 2 },
      L"YDT", // L"Alaskan Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-09PDT"), // _T("GMT-08 Pacific"),
      1,
      480,
      0,
      -60,
      L"PST", // L"Pacific Standard Time",
      { 10, 5, 0, 2 },
      L"PDT", // L"Pacific Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-07MST"), // _T("GMT-07 Arizona"),
      0,
      420,
      0,
      0,
      L"MST", // L"US Mountain Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-07MDT"), // _T("GMT-07 Mountain"),
      1,
      420,
      0,
      -60,
      L"MST", // L"Mountain Standard Time",
      { 10, 5, 0, 2 },
      L"MST", // L"Mountain Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-06CAST"), // _T("GMT-06 Central America"),
      0,
      360,
      0,
      0,
      L"CAST", // L"Central America Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-06CDT"), // _T("GMT-06 Central"),
      1,
      360,
      0,
      -60,
      L"CST", // L"Central Standard Time",
      { 10, 5, 0, 2 },
      L"CDT", // L"Central Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-06MDT"), // _T("GMT-06 Mexico City"),
      1,
      360,
      0,
      -60,
      L"MST", // L"Mexico Standard Time",
      { 10, 5, 0, 2 },
      L"MDT", // L"Mexico Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-06CCST"), // _T("GMT-06 Saskatchewan"),
      0,
      360,
      0,
      0,
      L"CCST", // L"Canada Central Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-05EDT"), // _T("GMT-05 Eastern"),
      1,
      300,
      0,
      -60,
      L"EST", // L"Eastern Standard Time",
      { 10, 5, 0, 2 },
      L"EDT", // L"Eastern Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-05EST"), // _T("GMT-05 Indiana"),
      0,
      300,
      0,
      0,
      L"EST", // L"US Eastern Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-05SPST"), // _T("GMT-05 Bogota"),
      0,
      300,
      0,
      0,
      L"SPST", // L"SA Pacific Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-04ADT"), // _T("GMT-04 Atlantic"),
      1,
      240,
      0,
      -60,
      L"AST", // L"Atlantic Standard Time",
      { 10, 5, 0, 2 },
      L"ADT", // L"Atlantic Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-04SWST"), // _T("GMT-04 Caracas"),
      0,
      240,
      0,
      0,
      L"SWST", // L"SA Western Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-04PSDT"), // _T("GMT-04 Santiago"),
      1,
      240,
      0,
      -60,
      L"PSST", // L"Pacific SA Standard Time",
      {  3, 2, 6, 0 },
      L"PSDT", // L"Pacific SA Daylight Time",
      { 10, 2, 6, 0 },
    },

    {
      _T("GMT-03:30"), // _T("GMT-03:30 Newfoundland"),
      1,
      210,
      0,
      -60,
      L"NST", // L"Newfoundland Standard Time",
      { 10, 5, 0, 2 },
      L"NDT", // L"Newfoundland Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-03ESDT"), // _T("GMT-03 Brasilia"),
      1,
      180,
      0,
      -60,
      L"ESST", // L"E. South America Standard Time",
      {  2, 2, 0, 2 },
      L"ESDT", // L"E. South America Daylight Time",
      { 10, 3, 0, 2 },
    },

    {
      _T("GMT-03SEST"), // _T("GMT-03 Buenos Aires"),
      0,
      180,
      0,
      0,
      L"SEST", // L"SA Eastern Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT-03GDT"), // _T("GMT-03 Greenland"),
      1,
      180,
      0,
      -60,
      L"GST", // L"Greenland Standard Time",
      { 10, 5, 0, 2 },
      L"GDT", // L"Greenland Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _T("GMT-02"), // _T("GMT-02 Mid-Atlantic"),
      1,
      120,
      0,
      -60,
      L"MAST", // L"Mid-Atlantic Standard Time",
      {  9, 5, 0, 2 },
      L"MADT", // L"Mid-Atlantic Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT-01ADT"), // _T("GMT-01 Azores"),
      1,
      60,
      0,
      -60,
      L"AST", // L"Azores Standard Time",
      { 10, 5, 0, 3 },
      L"ADT", // L"Azores Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT-01WAT"), // _T("GMT-01 Cape Verde Is."),
      0,
      60,
      0,
      0,
      L"WAT", // L"Cape Verde Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+00GST"), // _T("GMT+00 Casablanca"),
      0,
      0,
      0,
      0,
      L"GST", // L"Greenwich Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+00BST"), // _T("GMT+00 London"),
      1,
      0,
      0,
      -60,
      L"GMT", // L"GMT Standard Time",
      { 10, 5, 0, 2 },
      L"BST", // L"GMT Daylight Time",
      {  3, 5, 0, 1 },
    },

    {
      _T("GMT+01WEDT"), // _T("GMT+01 Berlin"),
      1,
      -60,
      0,
      -60,
      L"WEST", // L"W. Europe Standard Time",
      { 10, 5, 0, 3 },
      L"WEDT", // L"W. Europe Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+01CEDT"), // _T("GMT+01 Belgrade"),
      1,
      -60,
      0,
      -60,
      L"CEST", // L"Central Europe Standard Time",
      { 10, 5, 0, 3 },
      L"CEDT", // L"Central Europe Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+01RDT"), // _T("GMT+01 Paris"),
      1,
      -60,
      0,
      -60,
      L"RST", // L"Romance Standard Time",
      { 10, 5, 0, 3 },
      L"RDT", // L"Romance Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+01SCDT"), // _T("GMT+01 Sarajevo"),
      1,
      -60,
      0,
      -60,
      L"SCST", // L"Central European Standard Time",
      { 10, 5, 0, 3 },
      L"SCDT", // L"Central European Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+01WDST"), // _T("GMT+01 W. Central Africa"),
      0,
      -60,
      0,
      0,
      L"WAST", // L"W. Central Africa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+02GTDT"), // _T("GMT+02 Athens"),
      1,
      -120,
      0,
      -60,
      L"GTST", // L"GTB Standard Time",
      { 10, 5, 0, 3 },
      L"GTDT", // L"GTB Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+02EEDT"), // _T("GMT+02 Bucharest"),
      1,
      -120,
      0,
      -60,
      L"EEST", // L"E. Europe Standard Time",
      {  9, 5, 0, 1 },
      L"EEDT", // L"E. Europe Daylight Time",
      {  3, 5, 0, 0 },
    },

    {
      _T("GMT+02EDT"), // _T("GMT+02 Cairo"),
      1,
      -120,
      0,
      -60,
      L"EST", // L"Egypt Standard Time",
      {  9, 5, 3, 2 },
      L"EDT", // L"Egypt Daylight Time",
      {  5, 1, 5, 2 },
    },

    {
      _T("GMT+02SAST"), // _T("GMT+02 Pretoria"),
      0,
      -120,
      0,
      0,
      L"SAST", // L"South Africa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+02FLDT"), // _T("GMT+02 Helsinki"),
      1,
      -120,
      0,
      -60,
      L"FLST", // L"FLE Standard Time",
      { 10, 5, 0, 4 },
      L"FLDT", // L"FLE Daylight Time",
      {  3, 5, 0, 3 },
    },

    {
      _T("GMT+02JST"), // _T("GMT+02 Jerusalem"),
      0,
      -120,
      0,
      0,
      L"JST", // L"Jerusalem Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+03ADT"), // _T("GMT+03 Baghdad"),
      1,
      -180,
      0,
      -60,
      L"AST", // L"Arabic Standard Time",
      { 10, 1, 0, 4 },
      L"ADT", // L"Arabic Daylight Time",
      {  4, 1, 0, 3 },
    },

    {
      _T("GMT+03AST"), // _T("GMT+03 Kuwait"),
      0,
      -180,
      0,
      0,
      L"AST", // L"Arab Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+03RDT"), // _T("GMT+03 Moscow"),
      1,
      -180,
      0,
      -60,
      L"RST", // L"Russian Standard Time",
      { 10, 5, 0, 3 },
      L"RDT", // L"Russian Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+03EAST"), // _T("GMT+03 Nairobi"),
      0,
      -180,
      0,
      0,
      L"EAST", // L"E. Africa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+03:30"), // _T("GMT+03:30 Tehran"),
      1,
      -210,
      0,
      -60,
      L"IST", // L"Iran Standard Time",
      {  9, 4, 2, 2 },
      L"IDT", // L"Iran Daylight Time",
      {  3, 1, 0, 2 },
    },

    {
      _T("GMT+04AST"), // _T("GMT+04 Abu Dhabi"),
      0,
      -240,
      0,
      0,
      L"AST", // L"Arabian Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+04CDT"), // _T("GMT+04 Baku"),
      1,
      -240,
      0,
      -60,
      L"CST", // L"Caucasus Standard Time",
      { 10, 5, 0, 3 },
      L"CDT", // L"Caucasus Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+04:30"), // _T("GMT+04:30 Kabul"),
      0,
      -270,
      0,
      0,
      L"AST", // L"Afghanistan Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+05EDT"), // _T("GMT+05 Ekaterinburg"),
      1,
      -300,
      0,
      -60,
      L"EST", // L"Ekaterinburg Standard Time",
      { 10, 5, 0, 3 },
      L"EDT", // L"Ekaterinburg Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+05WAST"), // _T("GMT+05 Islamabad"),
      0,
      -300,
      0,
      0,
      L"WAST", // L"West Asia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+05:30"), // _T("GMT+05:30 New Delhi"),
      0,
      -330,
      0,
      0,
      L"IST", // L"India Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+05:45"), // _T("GMT+05:45 Kathmandu"),
      0,
      -345,
      0,
      0,
      L"NST", // L"Nepal Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+06NCDT"), // _T("GMT+06 Almaty"),
      1,
      -360,
      0,
      -60,
      L"NCST", // L"N. Central Asia Standard Time",
      { 10, 5, 0, 3 },
      L"NCDT", // L"N. Central Asia Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+06CAST"), // _T("GMT+06 Dhaka"),
      0,
      -360,
      0,
      0,
      L"CAST", // L"Central Asia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+06SRST"), // _T("GMT+06 Sri Lanka"),
      0,
      -360,
      0,
      0,
      L"SRST", // L"Sri Lanka Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+06:30"), // _T("GMT+06:30 Yangon"),
      0,
      -390,
      0,
      0,
      L"MST", // L"Myanmar Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+07SAST"), // _T("GMT+07 Bangkok"),
      0,
      -420,
      0,
      0,
      L"SAST", // L"SE Asia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+07NADT"), // _T("GMT+07 Krasnoyarsk"),
      1,
      -420,
      0,
      -60,
      L"NAST", // L"North Asia Standard Time",
      { 10, 5, 0, 3 },
      L"NADT", // L"North Asia Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+08CST"), // _T("GMT+08 Beijing"),
      0,
      -480,
      0,
      0,
      L"CST", // L"China Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+08NEDT"), // _T("GMT+08 Irkutsk"),
      1,
      -480,
      0,
      -60,
      L"NEST", // L"North Asia East Standard Time",
      { 10, 5, 0, 3 },
      L"NEDT", // L"North Asia East Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+08MPST"), // _T("GMT+08 Singapore"),
      0,
      -480,
      0,
      0,
      L"MPST", // L"Malay Peninsula Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+08AWST"), // _T("GMT+08 Perth"),
      0,
      -480,
      0,
      0,
      L"AWST", // L"W. Australia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+08TST"), // _T("GMT+08 Taipei"),
      0,
      -480,
      0,
      0,
      L"TST", // L"Taipei Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+09TST"), // _T("GMT+09 Tokyo"),
      0,
      -540,
      0,
      0,
      L"TST", // L"Tokyo Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+09KST"), // _T("GMT+09 Seoul"),
      0,
      -540,
      0,
      0,
      L"KST", // L"Korea Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+09YDT"), // _T("GMT+09 Yakutsk"),
      1,
      -540,
      0,
      -60,
      L"YST", // L"Yakutsk Standard Time",
      { 10, 5, 0, 3 },
      L"YDT", // L"Yakutsk Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+09:30ACDT"), // _T("GMT+09:30 Adelaide"),
      1,
      -570,
      0,
      -60,
      L"ACST", // L"Cen. Australia Standard Time",
      {  3, 5, 0, 2 },
      L"ACDT", // L"Cen. Australia Daylight Time",
      { 10, 5, 0, 2 },
    },

    {
      _T("GMT+09:30ACST"), // _T("GMT+09:30 Darwin"),
      0,
      -570,
      0,
      0,
      L"ACST", // L"AUS Central Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+10AEST"), // _T("GMT+10 Brisbane"),
      0,
      -600,
      0,
      0,
      L"AEST", // L"E. Australia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+10AEDT"), // _T("GMT+10 Sydney"),
      1,
      -600,
      0,
      -60,
      L"AEST", // L"AUS Eastern Standard Time",
      {  3, 5, 0, 2 },
      L"AEDT", // L"AUS Eastern Daylight Time",
      { 10, 5, 0, 2 },
    },

    {
      _T("GMT+10WPST"), // _T("GMT+10 Guam"),
      0,
      -600,
      0,
      0,
      L"WPST", // L"West Pacific Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+10TDT"), // _T("GMT+10 Hobart"),
      1,
      -600,
      0,
      -60,
      L"TST", // L"Tasmania Standard Time",
      {  3, 5, 0, 2 },
      L"TDT", // L"Tasmania Daylight Time",
      { 10, 1, 0, 2 },
    },

    {
      _T("GMT+10VDT"), // _T("GMT+10 Vladivostok"),
      1,
      -600,
      0,
      -60,
      L"VST", // L"Vladivostok Standard Time",
      { 10, 5, 0, 3 },
      L"VDT", // L"Vladivostok Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _T("GMT+11"), // _T("GMT+11 Solomon Islands"),
      0,
      -660,
      0,
      0,
      L"CPST", // L"Central Pacific Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+12NZDT"), // _T("GMT+12 Auckland"),
      1,
      -720,
      0,
      -60,
      L"NZST", // L"New Zealand Standard Time",
      {  3, 3, 0, 2 },
      L"NZDT", // L"New Zealand Daylight Time",
      { 10, 1, 0, 2 },
    },

    {
      _T("GMT+12FST"), // _T("GMT+12 Fiji Islands"),
      0,
      -720,
      0,
      0,
      L"FST", // L"Fiji Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+13"), // _T("GMT+13 Nuku'alofa"),
      0,
      -780,
      0,
      0,
      L"TST", // L"Tonga Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _T("GMT+14"), // _T("GMT+14 Kiribati"),
      0,
      -840,
      0,
      0,
      L"KST", // L"Kiribati Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Texture.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"
#include "Texture.h"

////////////////////////////////////////////////////////////////////////////

LPDIRECT3DTEXTURE8 CreateTexture(int& nWidth, int& nHeight, D3DFORMAT format)
{
	LPDIRECT3DTEXTURE8 pTexture;

	// REVIEW: usage flags and pool?
	if (FAILED(D3DXCreateTexture(XAppGetD3DDev(), nWidth, nHeight, 1, 0, format, D3DPOOL_MANAGED, &pTexture)))
		return NULL;

	XAppGetTextureSize(pTexture, nWidth, nHeight);

	return pTexture;
}

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("Texture", CTexture, CNode)

START_NODE_PROPS(CTexture, CNode)
	NODE_PROP(pt_boolean, CTexture, repeatS)
	NODE_PROP(pt_boolean, CTexture, repeatT)
END_NODE_PROPS()

CTexture::CTexture() :
	m_repeatS(true),
	m_repeatT(true)
{
	m_pSurface = NULL;
	m_format = D3DFMT_A8R8G8B8;
}

CTexture::~CTexture()
{
	if (m_pSurface != NULL)
		m_pSurface->Release();
}

LPDIRECT3DTEXTURE8 CTexture::GetTextureSurface()
{
	return m_pSurface;
}

bool CTexture::Create(int nWidth, int nHeight)
{
	m_nImageWidth = nWidth;
	m_nImageHeight = nHeight;
	m_pSurface = ::CreateTexture(nWidth, nHeight, m_format);
	if (m_pSurface == NULL)
	{
		TRACE(_T("\001CreateTexture(%d,%d) failed!\n"), nWidth, nHeight);
		return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("ImageTexture", CImageTexture, CTexture)

START_NODE_PROPS(CImageTexture, CTexture)
	NODE_PROP(pt_string, CImageTexture, url)
	NODE_PROP(pt_boolean, CImageTexture, alpha)
END_NODE_PROPS()

CImageTexture::CImageTexture() :
	m_url(NULL),
	m_alpha(false)
{
	m_bDirty = true;
	m_pSurface = NULL;
}

CImageTexture::~CImageTexture()
{
	delete [] m_url;
}


LPDIRECT3DTEXTURE8 CImageTexture::GetTextureSurface()
{
	if (m_bDirty && m_url != NULL)
	{
		m_bDirty = false;

//		TCHAR szURL [1024];
//		MakeAbsoluteURL(szURL, m_url);

		Load(m_url);
	}

	return CTexture::GetTextureSurface();
}

class CBackgroundLoader
{
public:
	CBackgroundLoader();
	virtual ~CBackgroundLoader();

	bool Fetch(const TCHAR* szURL);

	virtual void OnComplete();

	static CBackgroundLoader* c_pFirstLoader;
	CBackgroundLoader* m_pNextLoader;

	HANDLE m_hFile;
    OVERLAPPED m_overlapped;
	BYTE* m_pbContent;
	int m_cbContent;
	TCHAR* m_szURL;
};

CBackgroundLoader::CBackgroundLoader()
{
	ZeroMemory(&m_overlapped, sizeof (m_overlapped));

	m_szURL = NULL;
	m_hFile = INVALID_HANDLE_VALUE;
	m_pbContent = NULL;
	m_cbContent = 0;

	// Stick this one at the end of the list...
	m_pNextLoader = NULL;
	for (CBackgroundLoader** ppLoader = &c_pFirstLoader; *ppLoader != NULL; ppLoader = &(*ppLoader)->m_pNextLoader)
		;
	*ppLoader = this;
}

CBackgroundLoader::~CBackgroundLoader()
{
	for (CBackgroundLoader** ppLoader = &c_pFirstLoader; *ppLoader != NULL; ppLoader = &(*ppLoader)->m_pNextLoader)
	{
		if (*ppLoader == this)
		{
			*ppLoader = m_pNextLoader;
			break;
		}
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);

	delete [] m_szURL;
	delete [] m_pbContent;
}

CBackgroundLoader* CBackgroundLoader::c_pFirstLoader;

bool CBackgroundLoader::Fetch(const TCHAR* szURL)
{
	ASSERT(m_szURL == NULL);

	TCHAR szBuf [MAX_PATH];
	MakeAbsoluteURL(szBuf, szURL);

	m_szURL = new TCHAR [_tcslen(szBuf) + 1];
	_tcscpy(m_szURL, szBuf);

	DWORD dwFlags = 0;
#ifdef _XBOX
	// Overlapped needs FILE_FLAG_NO_BUFFERING for the hard drive, but can't have it on memory units...
	if ((szURL[0] == 'c' || szURL[0] == 'C' || szURL[0] == 'y' || szURL[0] == 'Y') && szURL[1] == ':')
		dwFlags = FILE_FLAG_NO_BUFFERING;
#endif
	m_hFile = XAppCreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN | dwFlags, NULL);
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001CBackgroundLoader::Fetch(%s) failed %d\n"), szURL, GetLastError());
		return false;
	}

	m_cbContent = GetFileSize(m_hFile, NULL);
#ifdef _XBOX
	// Round up to next 512 bytes (sector) or overlapped will fail on xbox...
	m_cbContent = (m_cbContent + 511) & ~511;
#endif
	m_pbContent = new BYTE [m_cbContent];

	ZeroMemory(&m_overlapped, sizeof (m_overlapped));

	if (!ReadFile(m_hFile, m_pbContent, m_cbContent, NULL, &m_overlapped))
	{
		DWORD dwError = GetLastError();
		if (dwError != ERROR_IO_PENDING)
		{
			TRACE(_T("\001CBackgroundLoader::Fetch ReadFile (%s) failed %d\n"), m_szURL, dwError);
			return false;
		}
	}
	else
	{
//		TRACE(_T("Finished loading %s (right away!)\n"), m_szURL);
		OnComplete();
		delete this;
	}

	return true;
}

void CBackgroundLoader::OnComplete()
{
	// override this to find out when the load is done
}

void BackgroundLoader_Frame()
{
	CBackgroundLoader* pNextLoader;
	for (CBackgroundLoader* pLoader = CBackgroundLoader::c_pFirstLoader; pLoader != NULL; pLoader = pNextLoader)
	{
		pNextLoader = pLoader->m_pNextLoader; // in case pLoader is deleted and removed from the list...

		ASSERT(pLoader->m_hFile != INVALID_HANDLE_VALUE);

		if (HasOverlappedIoCompleted(&pLoader->m_overlapped))
		{
//			TRACE(_T("Finished loading %s\n"), pLoader->m_szURL);
			pLoader->OnComplete();
			delete pLoader;
//return; // one at a time for now
		}
	}
}

struct TXTCACHE
{
	TCHAR* m_szURL;
	LPDIRECT3DTEXTURE8 m_pTexture;
	XTIME m_usage;
	bool m_bLoading;
	XTIME m_timeLoaded;
};


class CBackgroundTexture : public CBackgroundLoader
{
public:
	CBackgroundTexture(TXTCACHE* pTxt, UINT width=0, UINT height=0);
	~CBackgroundTexture();

	virtual void OnComplete();
	TXTCACHE* m_pTxt;

private:
    UINT m_width, m_height;
};

CBackgroundTexture::CBackgroundTexture(TXTCACHE* pTxt, UINT width, UINT height)
{
	ASSERT(pTxt != NULL);
	m_pTxt = pTxt;
    m_width = width;
    m_height = height;
}

CBackgroundTexture::~CBackgroundTexture()
{
	if (m_pTxt != NULL)
		m_pTxt->m_bLoading = false;
}

void CBackgroundTexture::OnComplete()
{
	m_pTxt->m_pTexture = ParseTexture(m_szURL, m_pbContent, m_cbContent, m_width, m_height);
	if((m_pTxt->m_pTexture == NULL) && (m_width == 64))
	{
#ifdef COOL_XDASH
		m_pTxt->m_pTexture = LoadTexture(_T("xboxlogo64.xbx.cool"), 64, 64);
#else
		m_pTxt->m_pTexture = LoadTexture(_T("xboxlogo64.xbx"), 64, 64);
#endif
    }
	else if((m_pTxt->m_pTexture == NULL) && (m_width == 128))
	{
#ifdef COOL_XDASH
		m_pTxt->m_pTexture = LoadTexture(_T("xboxlogo128.xbx.cool"), 128, 128);
#else
		m_pTxt->m_pTexture = LoadTexture(_T("xboxlogo128.xbx"), 128, 128);
#endif
	}
	m_pTxt->m_bLoading = false;
	m_pTxt->m_timeLoaded = XAppGetNow();
}




static TXTCACHE TextureCache [100];
static TXTCACHE* pTxtLock;

bool CleanupTextureCache()
{
	TRACE(_T("Looking for a texture to free...\n"));

	TXTCACHE* pOldTxt = NULL;
	for (int i = 0; i < countof(TextureCache); i += 1)
	{
		TXTCACHE* pTxt = &TextureCache[i];
		if (pTxt->m_szURL == NULL || pTxt == pTxtLock || pTxt->m_bLoading)
			continue;

		if (pOldTxt == NULL || pOldTxt->m_usage > pTxt->m_usage)
			pOldTxt = pTxt;
	}

	if (pOldTxt == NULL)
	{
		TRACE(_T("    none left!\n"));
		return false;
	}

	// Free this one up...

	TRACE(_T("    freeing %s\n"), pOldTxt->m_szURL);

	delete [] pOldTxt->m_szURL;

#ifdef _XBOX
	if (pOldTxt->m_pTexture != NULL)
		pOldTxt->m_pTexture->Release();
#endif

	ZeroMemory(pOldTxt, sizeof (TXTCACHE));

	return true;
}

TXTCACHE* FindTexture(const TCHAR* szURL, bool bAsync, UINT width, UINT height, bool binXIP=false)
{
	TXTCACHE* pFreeOne = NULL;
	TXTCACHE* pOldOne = NULL;
	
	for (int i = 0; i < countof(TextureCache); i += 1)
	{
		if (TextureCache[i].m_szURL != NULL && _tcsicmp(TextureCache[i].m_szURL, szURL) == 0)
		{
//			TRACE(_T("Found %s in Texture cache\n"), szURL);
			TextureCache[i].m_usage = XAppGetNow();
			return &TextureCache[i];
		}

		if (pFreeOne != NULL)
			continue;

		if (TextureCache[i].m_bLoading)
			continue;

		if (TextureCache[i].m_szURL == NULL)
			pFreeOne = &TextureCache[i];
		else if (pOldOne == NULL || pOldOne->m_usage > TextureCache[i].m_usage)
			pOldOne = &TextureCache[i];
	}

	if (pFreeOne == NULL && pOldOne != NULL)
	{
//		TRACE(_T("Unloading %s from Texture cache\n"), pOldOne->m_szURL);
		delete [] pOldOne->m_szURL;

#ifdef _XBOX
		if (pOldOne->m_pTexture != NULL)
			pOldOne->m_pTexture->Release();
#endif

		ZeroMemory(pOldOne, sizeof (TXTCACHE));
		pFreeOne = pOldOne;
	}

	ASSERT(pFreeOne != NULL);

//	TRACE(_T("Loading %s into Texture cache...\n"), szURL);

	ASSERT(pTxtLock == NULL);
	pTxtLock = pFreeOne;

	pFreeOne->m_szURL = new TCHAR [_tcslen(szURL) + 1];
	_tcscpy(pFreeOne->m_szURL, szURL);

	pFreeOne->m_usage = XAppGetNow();

	if (bAsync && !binXIP)
	{
		pFreeOne->m_bLoading = true;
		CBackgroundTexture* pLoader = new CBackgroundTexture(pFreeOne, width, height);
		if (!pLoader->Fetch(szURL))
			delete pLoader;
	}
	else
	{
		pFreeOne->m_pTexture = LoadTexture(szURL, width, height);
		pFreeOne->m_timeLoaded = XAppGetNow();
	}
	
	pTxtLock = NULL;

	return pFreeOne;
}

LPDIRECT3DTEXTURE8 GetTexture(const TCHAR* szURL, XTIME* pTimeLoaded, UINT width, UINT height, bool binXIP = false)
{
	TXTCACHE* pTxt = FindTexture(szURL, true, width, height, binXIP);
	ASSERT(pTxt != NULL);
	if (pTxt->m_pTexture == NULL)
		return NULL;

	if (pTimeLoaded != NULL)
		*pTimeLoaded = pTxt->m_timeLoaded;

	return pTxt->m_pTexture;
}


////////////////////////////////////////////////////////////////////////////

//extern bool CreateTextureFromFile(const TCHAR* szFileName, CTexture* pTexture);

void CImageTexture::Load(const TCHAR* szURL)
{
//	TRACE(_T("0x%08x: Loading texture image: \"%s\"\n"), this, szURL);

//#ifdef _DEBUG
//	int nStartTime = GetTickCount();
//#endif

	if (m_pSurface != NULL)
	{
		m_pSurface->Release();
		m_pSurface = NULL;
	}

	TXTCACHE* pTxt = FindTexture(szURL, false, 0, 0);
	ASSERT(pTxt != NULL);
	if (pTxt->m_pTexture == NULL)
		return;

	m_pSurface = pTxt->m_pTexture;
	m_pSurface->AddRef();

//	if (!CreateTextureFromFile(szURL, this))
//		return;

	XAppGetTextureSize(m_pSurface, m_nImageWidth, m_nImageHeight);

/*
	if (m_alpha)
	{
		D3DLOCKED_RECT lr;
		VERIFYHR(m_pSurface->LockRect(0, &lr, NULL, 0));
		BYTE* pDibPels = (BYTE*)lr.pBits;
		INT nDibPitch = lr.Pitch;
		for (int y = 0; y < m_nImageHeight; y += 1)
		{
			BYTE* pbScan = pDibPels + y * nDibPitch;
			for (int x = 0; x < m_nImageWidth; x += 1)
			{
				BYTE b = pbScan[0];
				BYTE g = pbScan[1];
				BYTE r = pbScan[2];
				BYTE a = pbScan[3];

				a = (r + g + b) / 3;
				a = a * 7 / 8;

				pbScan[0] = b;
				pbScan[1] = g;
				pbScan[2] = r;
				pbScan[3] = a;

				pbScan += 4;
			}
		}
		m_pSurface->UnlockRect(0);
	}
*/

//#ifdef _DEBUG
//	TRACE(_T("%s took %d mS to load\n"), szURL, GetTickCount() - nStartTime);
//#endif
}

bool CImageTexture::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_url))
		m_bDirty = true;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\TimeSensor.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"

class CTimeSensor : public CTimeDepNode
{
	DECLARE_NODE(CTimeSensor, CTimeDepNode)
public:
	CTimeSensor();

	float m_cycleInterval;
	bool m_enabled;
	XTIME m_cycleTime;
	float m_fraction_changed;
	XTIME m_time;

	void Advance(float nSeconds);
	void OnIsActiveChanged();
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("TimeSensor", CTimeSensor, CTimeDepNode)

START_NODE_PROPS(CTimeSensor, CTimeDepNode)
	NODE_PROP(pt_number, CTimeSensor, cycleInterval)
	NODE_PROP(pt_boolean, CTimeSensor, enabled)
	NODE_PROP(pt_number, CTimeSensor, cycleTime)
	NODE_PROP(pt_number, CTimeSensor, fraction_changed)
	NODE_PROP(pt_number, CTimeSensor, time)
END_NODE_PROPS()

CTimeSensor::CTimeSensor() :
	m_cycleInterval(1.0f),
	m_enabled(true)
{
}

bool CTimeSensor::OnSetProperty(const PRD* pprd, const void* pvValue)
{
    if ((int)pprd->pbOffset == offsetof(m_time))
    {
        m_time = (XTIME)(*(float*)pvValue);
        return false;
    }

    return true;
}

void CTimeSensor::Advance(float nSeconds)
{
	XTIME now = XAppGetNow();

	CTimeDepNode::Advance(nSeconds);

	if (m_isActive)
	{
		m_time = now;

		if (now >= m_cycleTime + m_cycleInterval)
		{
			if (m_loop)
			{
				m_cycleTime += m_cycleInterval;
			}
			else
			{
				m_isActive = false;
				OnIsActiveChanged();
			}
		}

		float temp = (float) (now - m_startTime) / m_cycleInterval;

		m_fraction_changed = temp - (int)temp;
		if (m_fraction_changed == 0.0f && now > m_startTime)
			m_fraction_changed = 1.0f;
		CallFunction(this, _T("fraction_changed"));
	}
}

void CTimeSensor::OnIsActiveChanged()
{
	if (m_isActive)
	{
		m_cycleTime = XAppGetNow();
	}
	else
	{
		CallFunction(this, _T("OnActiveChanged"));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\vertex8.h ===
typedef float D3DVALUE, *LPD3DVALUE;

#define D3DFVF_VERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 )

#if 0

#define D3DFVF_LVERTEX ( D3DFVF_XYZ | D3DFVF_RESERVED1 | D3DFVF_DIFFUSE | \
                         D3DFVF_SPECULAR | D3DFVF_TEX1 )
#define D3DFVF_TLVERTEX ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | \
                          D3DFVF_TEX1 )

/*
 * Vertex data types supported in an ExecuteBuffer.
 */

/*
 * Homogeneous vertices
 */

typedef struct _D3DHVERTEX {
    DWORD           dwFlags;        /* Homogeneous clipping flags */
    union {
    D3DVALUE    hx;
    D3DVALUE    dvHX;
    };
    union {
    D3DVALUE    hy;
    D3DVALUE    dvHY;
    };
    union {
    D3DVALUE    hz;
    D3DVALUE    dvHZ;
    };
} D3DHVERTEX, *LPD3DHVERTEX;

/*
 * Transformed/lit vertices
 */
typedef struct _D3DTLVERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;        /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    union {
    D3DVALUE    tu;             /* Texture coordinates */
    D3DVALUE    dvTU;
    };
    union {
    D3DVALUE    tv;
    D3DVALUE    dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DTLVERTEX() { }
    _D3DTLVERTEX(const D3DVECTOR& v, float _rhw,
                 D3DCOLOR _color, D3DCOLOR _specular,
                 float _tu, float _tv)
        { sx = v.x; sy = v.y; sz = v.z; rhw = _rhw;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DTLVERTEX, *LPD3DTLVERTEX;

/*
 * Untransformed/lit vertices
 */
typedef struct _D3DLVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    DWORD            dwReserved;
    union {
    D3DCOLOR     color;         /* Vertex color */
    D3DCOLOR     dcColor;
    };
    union {
    D3DCOLOR     specular;      /* Specular component of vertex */
    D3DCOLOR     dcSpecular;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DLVERTEX() { }
    _D3DLVERTEX(const D3DVECTOR& v,
                D3DCOLOR _color, D3DCOLOR _specular,
                float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z; dwReserved = 0;
          color = _color; specular = _specular;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DLVERTEX, *LPD3DLVERTEX;

#endif



/*
 * Untransformed/unlit vertices
 */

typedef struct _D3DVERTEX {
    union {
    D3DVALUE     x;             /* Homogeneous coordinates */
    D3DVALUE     dvX;
    };
    union {
    D3DVALUE     y;
    D3DVALUE     dvY;
    };
    union {
    D3DVALUE     z;
    D3DVALUE     dvZ;
    };
    union {
    D3DVALUE     nx;            /* Normal */
    D3DVALUE     dvNX;
    };
    union {
    D3DVALUE     ny;
    D3DVALUE     dvNY;
    };
    union {
    D3DVALUE     nz;
    D3DVALUE     dvNZ;
    };
    union {
    D3DVALUE     tu;            /* Texture coordinates */
    D3DVALUE     dvTU;
    };
    union {
    D3DVALUE     tv;
    D3DVALUE     dvTV;
    };
#if(DIRECT3D_VERSION >= 0x0500)
#if (defined __cplusplus) && (defined D3D_OVERLOADS)
    _D3DVERTEX() { }
    _D3DVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _tu, float _tv)
        { x = v.x; y = v.y; z = v.z;
          nx = n.x; ny = n.y; nz = n.z;
          tu = _tu; tv = _tv;
        }
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */
} D3DVERTEX, *LPD3DVERTEX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\TitleCollection.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "node.h"
#include "runner.h"
#include "SettingsFile.h"
#include "TitleCollection.h"
#include "Locale.h"

struct CTraceTime
{
	CTraceTime(TCHAR* szMsg)
	{
		m_time = GetTickCount();
		m_szMsg = szMsg;
	}

	~CTraceTime()
	{
		TRACE(_T("TraceTime: %s: %dmS\n"), m_szMsg, GetTickCount() - m_time);
	}

	DWORD m_time;
	TCHAR* m_szMsg;
};


#ifdef _DEBUG0
#define TRACETIME(szMsg) CTraceTime tracetime(szMsg);
#else
#define TRACETIME(szMsg)
#endif


////////////////////////////////////////////////////////////////////////////

CTitleArray g_titles [9];

void TitleArray_Init()
{
	g_titles[8].SetRoot('c', false);
	// NOTE: Memory units will be set as they are mounted...
}

CTitleArray::CTitleArray()
{
    InitializeCriticalSection(&m_RootLock);

	m_szRoot[0] = 0;
	m_szRoot[1] = ':';
	m_szRoot[2] = '\\';
	m_szRoot[3] = 0;

	m_bDirty = true;
	m_nTitleCount = 0;
	m_nTitleAlloc = 0;
	m_rgtitle = NULL;
}

CTitleArray::~CTitleArray()
{
	DeleteAll(false);
}

void CTitleArray::DeleteAll(bool bUpdate /* = true */)
{
	for (int i = 0; i < m_nTitleCount; i += 1)
	{
		delete [] m_rgtitle[i].m_szID;
		delete [] m_rgtitle[i].m_szName;
		delete [] m_rgtitle[i].m_rgsaves;
	}

	delete [] m_rgtitle;
	m_rgtitle = NULL;

	m_nTitleCount = 0;
	m_nTitleAlloc = 0;
	m_bDirty = true;

    if (bUpdate)
    {
        Update();
    }
}

void CTitleArray::SetRoot(TCHAR chNewRoot, bool bUpdate /* = true */)
{
    EnterCriticalSection(&m_RootLock);
	m_szRoot[0] = chNewRoot;
    LeaveCriticalSection(&m_RootLock);
	DeleteAll(bUpdate);
}

static int __cdecl SortTitleCompare(const void *elem1, const void *elem2)
{
	const CTitle* pTitle1 = (const CTitle*)elem1;
	const CTitle* pTitle2 = (const CTitle*)elem2;
	return _tcsicmp(pTitle1->m_szName, pTitle2->m_szName);
}

void CTitleArray::AddTitle(const TCHAR* szTitleID)
{
	TCHAR szXbxFile[MAX_PATH];
    TCHAR szTranslate[MAX_TRANSLATE_LEN];
	MakePath(szXbxFile, GetUData(), szTitleID);
	MakePath(szXbxFile, szXbxFile, szTitleDataXBX);

	TCHAR szTitleName[64];

    TCHAR szLanguageCode[MAX_LANGUAGE_CODE_LEN];
    GetLanguageCode(szLanguageCode);

	CSettingsFile settings;
	bool broken = false;
	if (!settings.Open(szXbxFile) || !settings.GetValue(szLanguageCode, _T("TitleName"), szTitleName, countof(szTitleName)))
	{
		TRACE(_T("\002Broken Game: title id: %s\n"), szTitleID);
		_tcscpy(szTitleName, Translate(_T("Broken Game"), szTranslate));
		broken = true;
	}

	if (m_nTitleCount == m_nTitleAlloc)
	{
		m_nTitleAlloc += 50;

		CTitle* rgtitle = new CTitle [m_nTitleAlloc];
		CopyMemory(rgtitle, m_rgtitle, m_nTitleCount * sizeof (CTitle));
		delete [] m_rgtitle;
		m_rgtitle = rgtitle;
	}

	ASSERT(m_nTitleCount < m_nTitleAlloc);

	int cch = _tcslen(szTitleID) + 1;
	m_rgtitle[m_nTitleCount].m_szID = new TCHAR [cch];
	CopyChars(m_rgtitle[m_nTitleCount].m_szID, szTitleID, cch);

	cch = _tcslen(szTitleName) + 1;
	m_rgtitle[m_nTitleCount].m_szName = new TCHAR [cch];
	CopyChars(m_rgtitle[m_nTitleCount].m_szName, szTitleName, cch);

	m_rgtitle[m_nTitleCount].m_nSavedGameCount = -1;
	m_rgtitle[m_nTitleCount].m_nSavedGameBlocks = -1; // 'unknown'
	m_rgtitle[m_nTitleCount].m_nTotalBlocks = -1; // 'unknown'
	m_rgtitle[m_nTitleCount].m_rgsaves = NULL;
	m_rgtitle[m_nTitleCount].m_bBroken = broken;

	m_nTitleCount += 1;
}

void CTitleArray::Update()
{
	ASSERT(m_bDirty);

    EnterCriticalSection(&m_RootLock);

	if (m_szRoot[0] == 0)
	{
        LeaveCriticalSection(&m_RootLock);
		m_bDirty = false;
		return;
	}

	TCHAR szFileName [MAX_PATH];
	WIN32_FIND_DATA fd;

    MakePath(szFileName, GetUData(), _T("*.*"));
    FSCHAR szBuf [MAX_PATH];
    Ansi(szBuf, szFileName, countof (szBuf));
    HANDLE hFind = FindFirstFile(szBuf, &fd);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        if (ERROR_DEVICE_NOT_CONNECTED != GetLastError())
        {
            m_bDirty = false;
        }
        LeaveCriticalSection(&m_RootLock);
        return;
    }

    do
    {
		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			continue;

		Unicode(szFileName, fd.cFileName, countof(szFileName));

		// Ignore the Xbox default title...
		if (_tcsicmp(szFileName, _T("fffe0000")) == 0)
			continue;

		AddTitle(szFileName);
    }
    while (FindNextFile(hFind, &fd));

    if (ERROR_DEVICE_NOT_CONNECTED == GetLastError())
    {
        FindClose(hFind);
        DeleteAll(false);
        LeaveCriticalSection(&m_RootLock);
        return;
    }

	FindClose(hFind);

	qsort(m_rgtitle, m_nTitleCount, sizeof (CTitle), SortTitleCompare);

    // Enumerate saved game count
    for (int i=0; i<m_nTitleCount; i++)
    {
        ASSERT(m_rgtitle[i].m_nSavedGameCount == -1);

        int nSavedGameCount = 0;
        CSave* rgsaves = new CSave [MAX_SAVED_GAMES];
        nSavedGameCount =

        m_rgtitle[i].m_nSavedGameCount = ScanSavedGames(GetUData(), m_rgtitle[i].m_szID, rgsaves, NULL);
        m_rgtitle[i].m_rgsaves = new CSave [nSavedGameCount];
        CopyMemory(m_rgtitle[i].m_rgsaves, rgsaves, sizeof (CSave) * nSavedGameCount);
        delete [] rgsaves;
    }

    LeaveCriticalSection(&m_RootLock);
	m_bDirty = false;
}

int CTitleArray::GetTitleCount()
{
	if (m_bDirty)
        return 0;

	return m_nTitleCount;
}

bool CTitleArray::IsBroken(int nTitle)
{
    ASSERT(nTitle < m_nTitleCount);
	return m_rgtitle[nTitle].m_bBroken;
}

const TCHAR* CTitleArray::GetTitleID(int nTitle)
{
	const TCHAR* sz = _T("");
	
    if (!m_bDirty && nTitle >= 0 && nTitle < m_nTitleCount)
		sz = m_rgtitle[nTitle].m_szID;

	return sz;
}

const TCHAR* CTitleArray::GetTitleName(int nTitle)
{
	const TCHAR* sz = _T("");
	
    if (!m_bDirty && nTitle >= 0 && nTitle < m_nTitleCount)
		sz = m_rgtitle[nTitle].m_szName;

	return sz;
}

int CTitleArray::GetSavedGameCount(int nTitle, HANDLE hCancelEvent /*= NULL*/)
{
	int nSavedGameCount = 0;

	if (!m_bDirty && nTitle >= 0 && nTitle < m_nTitleCount)
	{
		nSavedGameCount = m_rgtitle[nTitle].m_nSavedGameCount;

		if (nSavedGameCount == -1)
		{
			CSave* rgsaves = new CSave [MAX_SAVED_GAMES];

			nSavedGameCount = ScanSavedGames(GetUData(), m_rgtitle[nTitle].m_szID, rgsaves, hCancelEvent);

			m_rgtitle[nTitle].m_nSavedGameCount = nSavedGameCount;
			m_rgtitle[nTitle].m_rgsaves = new CSave [nSavedGameCount];
			CopyMemory(m_rgtitle[nTitle].m_rgsaves, rgsaves, sizeof (CSave) * nSavedGameCount);

            delete [] rgsaves;
		}
	}

	return nSavedGameCount;
}

bool InitSave(CSave* pSave, const TCHAR* szRoot, const TCHAR* szTitleID, const TCHAR* szSaveDirName, FILETIME saveTime)
{
	ZeroMemory(pSave, sizeof (CSave));

	if (!pSave->SetDirName(szSaveDirName))
	{
		// Invalid ID; must be a private directory...
		TRACE(_T("\002Ignoring %s\\%s: invalid ID\n"), szTitleID, szSaveDirName);
		return false;
	}

	pSave->m_filetime = saveTime;
	pSave->m_dwFlags |= SAVEFLAG_UNKIMAGE;

	return true;
}

int CTitleArray::FindTitle(const TCHAR* szTitleID)
{
	for (int nTitle = 0; nTitle < m_nTitleCount; nTitle += 1)
	{
		if (_tcsicmp(szTitleID, m_rgtitle[nTitle].m_szID) == 0)
			return nTitle;
	}

	return -1;
}

static int __cdecl SortSaveCompare(const void *elem1, const void *elem2)
{
	// Reversed these to go from newest -> oldest
	const CSave* pSave2 = (const CSave*)elem1;
	const CSave* pSave1 = (const CSave*)elem2;
	return CompareFileTime(&pSave1->m_filetime, &pSave2->m_filetime);
}

void CTitleArray::AddSavedGame(const TCHAR* szTitleID, const TCHAR* szDirName, FILETIME saveTime)
{
    if (m_bDirty)
        return;

	int nTitle = FindTitle(szTitleID);
	if (nTitle == -1)
	{
		AddTitle(szTitleID);

		m_rgtitle[m_nTitleCount - 1].m_nSavedGameCount = 0;

		qsort(m_rgtitle, m_nTitleCount, sizeof (CTitle), SortTitleCompare);

		// start search over because of sort...
		nTitle = FindTitle(szTitleID);
		ASSERT(nTitle >= 0);
	}

	ASSERT(nTitle >= 0 && nTitle < m_nTitleCount);
	CTitle* pTitle = &m_rgtitle[nTitle];

	if (pTitle->m_nSavedGameCount == -1)
		GetSavedGameCount(nTitle);

	ASSERT(pTitle->m_nSavedGameCount >= 0);
	ASSERT(pTitle->m_nSavedGameCount < MAX_SAVED_GAMES);

	CSave* rgsaves = new CSave [pTitle->m_nSavedGameCount + 1];
	CopyMemory(rgsaves, pTitle->m_rgsaves, sizeof (CSave) * pTitle->m_nSavedGameCount);
	delete [] pTitle->m_rgsaves;
	pTitle->m_rgsaves = rgsaves;
	
	if (InitSave(&pTitle->m_rgsaves[pTitle->m_nSavedGameCount], GetUData(), pTitle->m_szID, szDirName, saveTime))
	{
		pTitle->m_nSavedGameCount += 1;
		qsort(pTitle->m_rgsaves, pTitle->m_nSavedGameCount, sizeof (CSave), SortSaveCompare);
	}

	pTitle->m_nTotalBlocks = -1; // recalculate this
	pTitle->m_nSavedGameBlocks = -1; // recalculate this
}

void CTitleArray::RemoveTitle(int nTitle)
{
	CTitle* pTitle = &m_rgtitle[nTitle];
	delete [] pTitle->m_szID;
	delete [] pTitle->m_szName;
	delete [] pTitle->m_rgsaves;

	MoveMemory(&m_rgtitle[nTitle], &m_rgtitle[nTitle + 1], sizeof (CTitle) * (m_nTitleCount - nTitle - 1));
	m_nTitleCount -= 1;
}

void CTitleArray::RemoveSavedGame(int nTitle, int nSavedGame)
{
	CTitle* pTitle = &m_rgtitle[nTitle];
	MoveMemory(&pTitle->m_rgsaves[nSavedGame], &pTitle->m_rgsaves[nSavedGame + 1], sizeof (CSave) * (pTitle->m_nSavedGameCount - nSavedGame - 1));
	pTitle->m_nSavedGameCount -= 1;

	pTitle->m_nTotalBlocks = -1; // recalculate this
	pTitle->m_nSavedGameBlocks = -1; // recalculate this
}

void CTitleArray::RemoveSavedGame(const TCHAR* szTitleID, const TCHAR* szDirName)
{
    int nTitle = FindTitle(szTitleID);
    if (nTitle == -1)
    {
        return;
    }

    int i, nSavedGame = -1;
    CTitle* pTitle = &m_rgtitle[nTitle];

    // Search for the matching saved game
    for (int i=0; i<pTitle->m_nSavedGameCount; i++)
    {
        if (_tcsicmp(pTitle->m_rgsaves[i].m_szDirName, szDirName) == 0)
        {
            nSavedGame = i;
            break;
        }
    }

    if (nSavedGame != -1)
    {
        RemoveSavedGame(nTitle, nSavedGame);
    }
}

const TCHAR* CTitleArray::GetSavedGameID(int nTitle, int nSavedGame)
{
	int nSavedGameCount = GetSavedGameCount(nTitle);
	if (nSavedGame < 0 || nSavedGame >= nSavedGameCount)
	{
		TRACE(_T("\001CTitleArray::GetSavedGameID(%d, %d): invalid save index!\n"), nTitle, nSavedGame);
		return _T("");
	}

	return m_rgtitle[nTitle].m_rgsaves[nSavedGame].GetDirName(); // NOTE: Temporary access!
}

FILETIME CTitleArray::GetSavedGameTime(int nTitle, int nSavedGame)
{
	int nSavedGameCount = GetSavedGameCount(nTitle);
	if (nSavedGame < 0 || nSavedGame >= nSavedGameCount)
	{
		TRACE(_T("\001CTitleArray::GetSavedGameTime(%d, %d): invalid save index!\n"), nTitle, nSavedGame);
		static FILETIME filetime;
		return filetime;
	}

	return m_rgtitle[nTitle].m_rgsaves[nSavedGame].m_filetime;
}

/*
int CTitleArray::GetTitleSavedGameBlocks(int nTitle)
{
	if (nTitle < 0 || nTitle >= m_nTitleCount)
		return 0;

	if (m_rgtitle[nTitle].m_nSavedGameBlocks == -1)
		m_rgtitle[nTitle].m_nSavedGameBlocks = ComputeTitleSavedGameBlocks(GetUData(), m_rgtitle[nTitle].m_szID);

	return m_rgtitle[nTitle].m_nSavedGameBlocks;
}
*/

int CTitleArray::GetTitleTotalBlocks(int nTitle, HANDLE hCancelEvent)
{
	if (nTitle < 0 || nTitle >= m_nTitleCount)
		return 0;

	if (m_rgtitle[nTitle].m_nTotalBlocks == -1)
	{
		m_rgtitle[nTitle].m_nTotalBlocks = ComputeTitleTotalBlocks(GetUData(), m_rgtitle[nTitle].m_szID, hCancelEvent);
		if (m_szRoot[0] == 'c' && m_rgtitle[nTitle].m_nTotalBlocks >= 0)
			m_rgtitle[nTitle].m_nTotalBlocks += ComputeTitleTotalBlocks(GetTData(), m_rgtitle[nTitle].m_szID, hCancelEvent);
	}

	return m_rgtitle[nTitle].m_nTotalBlocks;
}

////////////////////////////////////////////////////////////////////////////

/*
int ComputeTitleSavedGameBlocks(const TCHAR* szRoot, const TCHAR* szTitleID)
{
	TCHAR szDir [MAX_PATH];
	MakePath(szDir, szRoot, szTitleID);
	return GetDirectoryBlocks(szDir, BLOCK_SIZE, true);
}
*/

int ComputeTitleTotalBlocks(const TCHAR* szRoot, const TCHAR* szTitleID, HANDLE hCancelEvent)
{
	TCHAR szDir [MAX_PATH];
	MakePath(szDir, szRoot, szTitleID);
	return GetDirectoryBlocks(szDir, BLOCK_SIZE, true, hCancelEvent);
}

/*
static DWORD ParseTitleID(const TCHAR* szID)
{
	if (_tcslen(szID) != 8)
		return 0xffffffff; // Invalid ID

	DWORD dw = 0;
	const TCHAR* pch = szID;
	while (*pch != 0)
	{
		DWORD dwDigit;

		if (*pch >= '0' && *pch <= '9')
			dwDigit = *pch - '0';
		else if (*pch >= 'a' && *pch <= 'f')
			dwDigit = 10 + *pch - 'a';
		else if (*pch >= 'A' && *pch <= 'F')
			dwDigit = 10 + *pch - 'A';
		else
			return 0xffffffff; // Invalid ID

		dw = (dw << 4) + dwDigit;

		pch += 1;
	}

	return dw;
}
*/

bool InitSave(CSave* pSave, const TCHAR* szRoot, const TCHAR* szTitleID, const TCHAR* szSaveDirName, FILETIME saveTime);

int ScanSavedGames(const TCHAR* szRoot, const TCHAR* szTitleID, CSave* rgsaves /*[MAX_SAVED_GAMES]*/, HANDLE hCancelEvent)
{
    if (hCancelEvent && WaitForSingleObject(hCancelEvent, 0) == WAIT_OBJECT_0)
    {
        return -1;
    }

	int nSavedGameCount = 0;
    bool bCancel = false;

	// scan for saves...
	HANDLE hFind;
	WIN32_FIND_DATA fd;

	// BLOCK:
	{
		TCHAR szTitleDirWild [MAX_PATH];
		MakePath(szTitleDirWild, szRoot, szTitleID);
		MakePath(szTitleDirWild, szTitleDirWild, _T("*.*"));

		char szBuf [MAX_PATH];
		Ansi(szBuf, szTitleDirWild, MAX_PATH);
		hFind = FindFirstFile(szBuf, &fd);
	}

	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
            if (hCancelEvent && WaitForSingleObject(hCancelEvent, 0) == WAIT_OBJECT_0)
            {
                bCancel = true;
                break;
            }

			if (nSavedGameCount == MAX_SAVED_GAMES)
			{
				TRACE(_T("\001Too many saved games in title %s!\n"), szTitleID);
				break;
			}

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
				continue;

			TCHAR szFileName [MAX_PATH];
			Unicode(szFileName, fd.cFileName, countof(szFileName));

			if (!InitSave(&rgsaves[nSavedGameCount], szRoot, szTitleID, szFileName, fd.ftLastWriteTime))
				continue;

			nSavedGameCount += 1;
		}
		while (FindNextFile(hFind, &fd));
		FindClose(hFind);
	}

    if (!bCancel)
    {
    	qsort(rgsaves, nSavedGameCount, sizeof (CSave), SortSaveCompare);

#ifdef _DEBUG
    	TRACE(_T("Sorted saved games:\n"));
    	for (int i = 0; i < nSavedGameCount; i += 1)
    	{
    		SYSTEMTIME st;
    		FILETIME local;
    		FileTimeToLocalFileTime(&rgsaves[i].m_filetime, &local);
    		FileTimeToSystemTime(&local, &st);
    		TRACE(_T("%02d/%02d/%04d %02d:%02d:%02d %s\n"), st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, rgsaves[i].m_szDirName);
    	}
#endif
    }

	return bCancel ? -1 : nSavedGameCount;
}

////////////////////////////////////////////////////////////////////////////

const TCHAR* CTitleArray::GetTData() const
{
	ASSERT(m_szRoot[0] != 0);

	if (m_szRoot[0] != 'c')
		return m_szRoot;

	return _T("c:\\tdata");
}

const TCHAR* CTitleArray::GetUData() const
{
	ASSERT(m_szRoot[0] != 0);

	if (m_szRoot[0] != 'c')
		return m_szRoot;

	return _T("c:\\udata");
}

bool CTitleArray::IsValid() const
{
	return m_szRoot[0] != 0;
}

bool CTitleArray::IsDirty() const
{
	return (m_szRoot[0] && m_bDirty);
}

void CTitleArray::GetSavedGameImageName(int nTitle, int nSavedGame, TCHAR* szPath/*[MAX_PATH]*/)
{
	ASSERT(nTitle >= 0 && nTitle < m_nTitleCount);
	ASSERT(nSavedGame >= 0 && nSavedGame < GetSavedGameCount(nTitle));

	if ((m_rgtitle[nTitle].m_rgsaves[nSavedGame].m_dwFlags & SAVEFLAG_UNKIMAGE) != 0)
	{
		m_rgtitle[nTitle].m_rgsaves[nSavedGame].m_dwFlags &= ~SAVEFLAG_UNKIMAGE;

		MakePath(szPath, GetUData(), GetTitleID(nTitle));
		MakePath(szPath, szPath, GetSavedGameID(nTitle, nSavedGame));
		MakePath(szPath, szPath, szSaveImageXBX);

		if (DoesFileExist(szPath))
		{
			m_rgtitle[nTitle].m_rgsaves[nSavedGame].m_dwFlags |= SAVEFLAG_HASIMAGE;
			return;
		}
	}

	MakePath(szPath, GetUData(), GetTitleID(nTitle));

	if ((m_rgtitle[nTitle].m_rgsaves[nSavedGame].m_dwFlags & SAVEFLAG_HASIMAGE) != 0)
	{
		// This save has its own image; use it...
		MakePath(szPath, szPath, GetSavedGameID(nTitle, nSavedGame));
	}

	MakePath(szPath, szPath, szSaveImageXBX);

	if (!DoesFileExist(szPath)) //saved game doesn't have any associated images
	{
#ifdef COOL_XDASH
		_tcscpy(szPath, _T("xboxlogo64.xbx.cool"));
#else
		_tcscpy(szPath, _T("xboxlogo64.xbx"));
#endif
	}
}

bool CTitleArray::IsPublisherExists(const TCHAR* szPublisherID) const
{
	for (int i=0; i<m_nTitleCount; i++)
	{
        if (_tcsnicmp(szPublisherID, m_rgtitle[i].m_szID, 4) == 0)
        {
            return true;
        }
	}

    return false;
}

bool CSave::SetDirName(const TCHAR* szDirName)
{
/*
	m_dwID = ParseTitleID(szDirName);
	return m_dwID != 0xffffffff;
*/
	if (_tcslen(szDirName) + 1 > countof (m_szDirName))
		return false;

	_tcscpy(m_szDirName, szDirName);
	return true;
}

const TCHAR* CSave::GetDirName()
{
/*
	static TCHAR szBuf [10];
	_stprintf(szBuf, _T("%08x"), m_dwID);
	return szBuf; // NOTE: Temporary access!
*/
	return m_szDirName;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\TitleCollection.h ===
#pragma once

#define MAX_SAVED_GAMES 4096

extern const TCHAR szTitleDataXBX [];
extern const TCHAR szTitleImageXBX [];
extern const TCHAR szSaveDataXBX [];
extern const TCHAR szSaveImageXBX [];


#define Dev1Unit1	0
#define Dev1Unit2	1
#define Dev2Unit1	2
#define Dev2Unit2	3
#define Dev3Unit1	4
#define Dev3Unit2	5
#define Dev4Unit1	6
#define Dev4Unit2	7
#define Dev0		8



#define BLOCK_SIZE	16384 // Should be max of hard drive and flash block size...


struct CSave
{
//	DWORD m_dwID;
	TCHAR m_szDirName[16];
	FILETIME m_filetime;
	DWORD m_dwFlags;

	bool SetDirName(const TCHAR* szDirName);
	const TCHAR* GetDirName();
};

#define SAVEFLAG_HASIMAGE	0x00000001
#define SAVEFLAG_UNKIMAGE	0x00000002

class CTitle
{
public:
	TCHAR* m_szID;
	TCHAR* m_szName;
	int m_nSavedGameCount;
	CSave* m_rgsaves;
	int m_nSavedGameBlocks;
	int m_nTotalBlocks;
	bool m_bBroken;
};

class CTitleArray
{
public:
	CTitleArray();
	~CTitleArray();

	void Update();
	void DeleteAll(bool bUpdate = true);

	void SetRoot(TCHAR chNewRoot, bool bUpdate = true);

	int GetTitleCount();
	bool IsBroken(int nTitle);
	const TCHAR* GetTitleID(int nTitle);
	const TCHAR* GetTitleName(int nTitle);
	int GetTitleTotalBlocks(int nTitle, HANDLE hCancelEvent);

	int GetSavedGameCount(int nTitle, HANDLE hCancelEvent = NULL);
	const TCHAR* GetSavedGameID(int nTitle, int nSavedGame);
	void GetSavedGameImageName(int nTitle, int nSavedGame, TCHAR* szPath/*[MAX_PATH]*/);
	FILETIME GetSavedGameTime(int nTitle, int nSavedGame);

	void AddSavedGame(const TCHAR* szTitleID, const TCHAR* szDirName, FILETIME saveTime);

	bool IsValid() const;
	bool IsDirty() const;
	const TCHAR* GetTData() const;
	const TCHAR* GetUData() const;

	void RemoveTitle(int nTitle);
	void RemoveSavedGame(int nTitle, int nSavedGame);
	void RemoveSavedGame(const TCHAR* szTitleID, const TCHAR* szDirName);
    bool IsPublisherExists(const TCHAR* szPublisherID) const;

protected:
	int FindTitle(const TCHAR* szTitleID);
	void AddTitle(const TCHAR* szTitleID);

	TCHAR m_szRoot [4];
	bool m_bDirty;
	int m_nTitleCount;
	int m_nTitleAlloc;
	CTitle* m_rgtitle;

    CRITICAL_SECTION m_RootLock;

	friend class CTitleCollection;
	friend void TitleArray_Init();
};

/*
class CTitleCollection : public CNode
{
	DECLARE_NODE(CTitleCollection, CNode)
public:
	CTitleCollection();
	~CTitleCollection();

	void Advance(float nSeconds);

	void SetLanguage(int nLanguage);
	int GetTitleCount();
	CStrObject* GetTitleID(int nTitle);
	CStrObject* GetTitleName(int nTitle);

	int GetSavedGameCount(int nTitle);
	CStrObject* GetSavedGameID(int nTitle, int nSavedGame);

//	int GetTitleSavedGameBlocks(int nTitle);
	int GetTitleTotalBlocks(int nTitle);

protected:
	int m_nCurLanguage;

	DECLARE_NODE_FUNCTIONS()
};
*/


extern int ScanSavedGames(const TCHAR* szRoot, const TCHAR* szTitleID, CSave* rgsaves /*[MAX_SAVED_GAMES]*/, HANDLE hCancelEvent);
//extern int ComputeTitleSavedGameBlocks(const TCHAR* szRoot, const TCHAR* szTitleID);
extern int ComputeTitleTotalBlocks(const TCHAR* szRoot, const TCHAR* szTitleID, HANDLE hCancelEvent);

extern CTitleArray g_titles [9];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\viewpoint.h ===
#pragma once

class CViewpoint : public CNode
{
	DECLARE_NODE(CViewpoint, CNode)
public:
	CViewpoint();
	~CViewpoint();

	void OnLoad();
	void Bind();

	bool m_isBound;
	float m_fieldOfView;
	bool m_jump;
	D3DXQUATERNION m_orientation;
	D3DXVECTOR3 m_position;
	TCHAR* m_description;

	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	DECLARE_NODE_PROPS()
};

extern void BindViewpoint(CNode* pViewpontNode);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\viewpoint.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Camera.h"
#include "Viewpoint.h"

IMPLEMENT_NODE("Viewpoint", CViewpoint, CNode)

START_NODE_PROPS(CViewpoint, CNode)
	NODE_PROP(pt_number, CViewpoint, fieldOfView)
	NODE_PROP(pt_boolean, CViewpoint, jump)
	NODE_PROP(pt_boolean, CViewpoint, isBound)
	NODE_PROP(pt_vec3, CViewpoint, position)
	NODE_PROP(pt_vec4, CViewpoint, orientation)
	NODE_PROP(pt_string, CViewpoint, description)
END_NODE_PROPS()

CViewpoint::CViewpoint() :
	m_isBound(false),
	m_fieldOfView(0.785398f),
	m_jump(true),
	m_orientation(0.0f, 0.0f, 1.0f, 0.0f),
	m_position(0.0f, 0.0f, 10.0f),
	m_description(NULL)
{
}

CViewpoint::~CViewpoint()
{
	delete [] m_description;

	if (theApp.m_pViewpoint == this)
		theApp.m_pViewpoint = NULL;
}

void CViewpoint::OnLoad()
{
	CNode::OnLoad();

	if (theApp.m_pViewpoint == NULL)
		Bind();
}

void BindViewpoint(CNode* pViewpointNode)
{
	if (pViewpointNode == NULL || !pViewpointNode->IsKindOf(NODE_CLASS(CViewpoint)))
		return;

	((CViewpoint*)pViewpointNode)->Bind();
}

void CViewpoint::Bind()
{
	if (theApp.m_pViewpoint == this)
		return;

	if (theApp.m_pViewpoint != NULL)
		theApp.m_pViewpoint->m_isBound = false;

	theApp.m_pViewpoint = this;

	D3DXQUATERNION q;
	D3DXQuaternionRotationAxis(&q, (D3DXVECTOR3*)&m_orientation, -m_orientation.w);

	D3DXVECTOR3 position = m_position;
	position.z = -position.z;

	theCamera.Set(&position, &q, m_jump ? 0.0f : 1.0f);

#ifndef _XBOX
	if (theApp.m_pNavigator != NULL)
	{
		theApp.m_pNavigator->m_position = position;
		theApp.m_pNavigator->m_orientation = q;
	}
#endif

	theApp.m_bProjectionDirty = true;
}

bool CViewpoint::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_isBound))
	{
		if (*(bool*)pvValue)
			Bind();
	}
	else if ((int)pprd->pbOffset == offsetof(m_fieldOfView))
	{
		theApp.m_bProjectionDirty = true;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xcddefs.h ===
#pragma once


// CD audio type conversions

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000

#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500

// MCI time format conversion macros

#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                        ((WORD)(s)<<8)) | \
                                        (((DWORD)(BYTE)(f))<<16)))

__inline DWORD MsfToFrames(DWORD dwMsf)
{
    return MCI_MSF_MINUTE(dwMsf) * CDAUDIO_FRAMES_PER_MINUTE +
           MCI_MSF_SECOND(dwMsf) * CDAUDIO_FRAMES_PER_SECOND +
           MCI_MSF_FRAME(dwMsf);
}

__inline DWORD FramesToMsf(DWORD dwFrames)
{
    return MCI_MAKE_MSF(
        dwFrames / CDAUDIO_FRAMES_PER_MINUTE,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) / CDAUDIO_FRAMES_PER_SECOND,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) % CDAUDIO_FRAMES_PER_SECOND);
}

__inline DWORD TocValToMsf(LPBYTE ab)
{
    return MCI_MAKE_MSF(ab[1], ab[2], ab[3]);
}

__inline DWORD TocValToFrames(LPBYTE ab)
{
    return MsfToFrames(TocValToMsf(ab));
}

struct XCDROM_TOC
{
public:
	XCDROM_TOC();
	~XCDROM_TOC();

	void Delete();
	int GetTrackFromFrame(DWORD dwPosition) const;

    int LastTrack;
    DWORD TrackAddr [100];

#ifdef _CD_INFO
	void UpdateDiscID();

	TCHAR* rgszTrack [100];
	TCHAR* szTitle;
	TCHAR* szArtist;
	TCHAR* szID;
#endif

protected:
	void Clear();
};

typedef XCDROM_TOC* PXCDROM_TOC;

// FRAMES_PER_CHUNK should be kept small, to maximize granularity. We stop music on
// a chunk boundary.

// Some CD hardware (Thompson, .94 firmware revision) is happiest with 1 second reads.

#define FRAMES_PER_CHUNK (CDAUDIO_FRAMES_PER_SECOND)

#define CD_AUDIO_SEGMENTS_PER_BUFFER ((4*CDAUDIO_FRAMES_PER_SECOND)/FRAMES_PER_CHUNK)

#define BYTES_PER_CHUNK (FRAMES_PER_CHUNK * CDAUDIO_BYTES_PER_FRAME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Xbox.cpp ===
#include "std.h"
#include "xapp.h"
#include "Locale.h"

extern "C"
{
	BOOL WINAPI XapiFormatFATVolume(POBJECT_STRING pcVolume);
	NTSTATUS MU_CreateDeviceObject(ULONG Port, ULONG Slot, POBJECT_STRING DeviceName);
	VOID MU_CloseDeviceObject(ULONG Port, ULONG Slot);
	NTSYSAPI BOOLEAN NTAPI RtlTimeFieldsToTime(TIME_FIELDS* TimeFields, PLARGE_INTEGER Time);
}

bool XboxFormatMemoryUnit(UINT nDevicePort, UINT nMemoryUnit)
{
	ANSI_STRING st;
	char pszMU [MAX_MUNAME];
	st.Length = 0;
	st.MaximumLength = sizeof (pszMU) - 1;
	st.Buffer = pszMU;

	if (MU_CreateDeviceObject(nDevicePort, nMemoryUnit, &st) != NO_ERROR)
		return false;

	if (!XapiFormatFATVolume(&st))
		TRACE(_T("XApiFormatFATVolume failed: %d\n"), GetLastError());

	MU_CloseDeviceObject(nDevicePort, nMemoryUnit);

	return true;
}

OBJECT_STRING c_cDrive = CONSTANT_OBJECT_STRING("\\??\\C:");
OBJECT_STRING c_cPath  = CONSTANT_OBJECT_STRING("\\Device\\Harddisk0\\partition1");
OBJECT_STRING c_yDrive = CONSTANT_OBJECT_STRING("\\??\\Y:");
OBJECT_STRING c_yPath  = CONSTANT_OBJECT_STRING("\\Device\\Harddisk0\\partition2");
OBJECT_STRING c_tDrive = CONSTANT_OBJECT_STRING("\\??\\T:");
OBJECT_STRING c_tPath  = CONSTANT_OBJECT_STRING("\\Device\\Harddisk0\\partition1\\TDATA\\fffe0000");

void Xbox_Init()
{
    // BLOCK: Increase file cache to 1MB
    {
        XSetFileCacheSize(1024 * 1024);
    }

	// BLOCK: Setup some symbolic directory links...
	{
        NTSTATUS Status;

		Status = IoCreateSymbolicLink(&c_cDrive, &c_cPath);
        if (!NT_SUCCESS(Status))
        {
            ALERT(_T("Warning: unable to map C: (0x%x)"), Status);
        }

		VERIFY(NT_SUCCESS(IoCreateSymbolicLink(&c_yDrive, &c_yPath)));

        CreateDirectory( "c:\\tdata", NULL );
        CreateDirectory( "c:\\tdata\\fffe0000", NULL );
        CreateDirectory( "c:\\tdata\\fffe0000\\music", NULL );

		Status = IoCreateSymbolicLink(&c_tDrive, &c_tPath);
        if (!NT_SUCCESS(Status))
        {
            ALERT(_T("Warning: unable to map T: (0x%x)"), Status);
        }
	}

    // BLOCK: Initialize core peripheral port support
	{
	    XInitDevices(0, NULL);
	}

    // BLOCK: Clean up dead PCM file
    {
        if (SetFileAttributesA(XappTempPcmFileA, FILE_ATTRIBUTE_NORMAL))
            DeleteFileA(XappTempPcmFileA);
        if (SetFileAttributesA(XappTempWmaFileA, FILE_ATTRIBUTE_NORMAL))
            DeleteFileA(XappTempWmaFileA);
    }

    // BLOCK: cache game region
    {
        g_nCurRegion = XGetGameRegion();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xcdplay.cpp ===
#include "std.h"
#include "xapp.h"
#include "CDPlayer.h"

XCDPlayer::XCDPlayer() :
	m_streamer(&g_cdrom)
{
	m_dwStartPosition = 0;
	m_dwStopPosition = 0;
    m_pvBuffer = NULL;
}

XCDPlayer::~XCDPlayer()
{
	if (m_hPlayThread != NULL)
	{
		if (m_hTerminate != NULL)
			SetEvent(m_hTerminate);

		WaitForSingleObject(m_hPlayThread, INFINITE);
	}
}

bool XCDPlayer::Initialize(int nTrack, WAVEFORMATEX* pFormat)
{
	TRACE(_T("XCDPlayer::Initialize()\n"));

	if (!g_cdrom.IsOpen())
	{
		TRACE(_T("Cannot open CD player; g_cdrom is not open!\n"));
		return false;
	}

	// BLOCK: Select track
	{
		int nTrackCount = g_cdrom.GetTrackCount();
		ASSERT(nTrackCount > 0);

		if (nTrack < 0 || nTrack >= nTrackCount)
        {
			TRACE(_T("XCDPlayer::Initialize invalid track %d\n"), nTrack);
			return false;
		}

		m_dwStartPosition = g_cdrom.GetTrackFrame(nTrack);
		m_dwStopPosition = g_cdrom.GetTrackFrame(nTrack + 1);

		m_streamer.SetFrame(m_dwStartPosition);
	}

	ZeroMemory(pFormat, sizeof (WAVEFORMATEX));
	pFormat->wFormatTag = WAVE_FORMAT_PCM;
	pFormat->nChannels = 2;
	pFormat->nSamplesPerSec = 44100;
	pFormat->wBitsPerSample = 16;
	pFormat->nBlockAlign = pFormat->wBitsPerSample / 8 * pFormat->nChannels;
	pFormat->nAvgBytesPerSec = pFormat->nSamplesPerSec * pFormat->nBlockAlign;

	if (!CAudioPump::Initialize(0, pFormat, BYTES_PER_CHUNK, CD_AUDIO_SEGMENTS_PER_BUFFER))
	{
		TRACE(_T("XCDPlayer::Initialize CAudioPump::Initialize failed!\n"));
		return false;
	}

    m_pDSBuffer->SetHeadroom(0);

	return true;
}

// NOTE: This is called from a secondary thread!
int XCDPlayer::GetData(BYTE* pbBuffer, int cbBuffer)
{
    const DWORD dwPosition = GetPosition();
    
    if (dwPosition >= m_dwStopPosition)
		return 0; // all done!

    if (dwPosition + ((cbBuffer + CDAUDIO_BYTES_PER_FRAME - 1) / CDAUDIO_BYTES_PER_FRAME) >= m_dwStopPosition)
        cbBuffer = (m_dwStopPosition - dwPosition) * CDAUDIO_BYTES_PER_FRAME;

	int nRead = m_streamer.Read(pbBuffer, cbBuffer);
    if (nRead <= 0)
        return nRead;

    m_pvBuffer = pbBuffer;

    return nRead;
}


/*
void XCDPlayer::Seek(BOOL fForward)
{
	DWORD dwCurPosition;
	dwCurPosition = GetPosition();
	if (fForward)
	{
		dwCurPosition += CDAUDIO_FRAMES_PER_SECOND;

		DWORD dwLastFrame = g_cdrom.GetTrackFrame(g_cdrom.GetTrackCount());
		if (dwCurPosition >= dwLastFrame)
		{
			dwCurPosition -= dwLastFrame - g_cdrom.GetTrackFrame(0);
		}
	}
	else
	{
		dwCurPosition -= CDAUDIO_FRAMES_PER_SECOND;

		if (dwCurPosition < g_cdrom.GetTrackFrame(0))
		{
			dwCurPosition += g_cdrom.GetTrackFrame(g_cdrom.GetTrackCount()) - g_cdrom.GetTrackFrame(0);
		}
	}

	SetPosition(dwCurPosition);
}
*/

void XCDPlayer::Stop()
{
    CAudioPump::Stop();
    m_streamer.SetFrame(m_dwStartPosition);
}

float XCDPlayer::GetPlaybackLength()
{
	DWORD dwLength = m_dwStopPosition - m_dwStartPosition;
	return (float)dwLength / CDAUDIO_FRAMES_PER_SECOND;
}

float XCDPlayer::GetPlaybackTime()
{
    // Keep the UI from displaying playback time past the end of the song, even if we
    // play a little silence after the song.
    float playbackTime = CAudioPump::GetPlaybackTime();
    float length = GetPlaybackLength();
    if(playbackTime > length){
        playbackTime = length;
    }
    return playbackTime;
}

void* XCDPlayer::GetSampleBuffer()
{
	return m_pvBuffer;
}

DWORD XCDPlayer::GetSampleBufferSize()
{
	return BYTES_PER_CHUNK;
}


void XCDPlayer::SetPosition(DWORD dwPosition)
{
	WaitForSingleObject(m_hMutex, INFINITE);
	m_streamer.SetFrame(dwPosition);
	ReleaseMutex(m_hMutex);
}

DWORD XCDPlayer::GetPosition()
{
	WaitForSingleObject(m_hMutex, INFINITE);
	DWORD dw = m_streamer.GetFrame();
	ReleaseMutex(m_hMutex);
	return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\wma8.cpp ===
#include "std.h"
#include "XApp.h"
#include <share.h>

#include "..\wmaenc\wmfencode.h"

#if defined(XBOX) && defined(DBG)
// #define DETECT_MEMORY_LEAKS
// #define COMPILE_MEMORY_LEAK_FUNCTIONS
#else
#endif

#ifdef COMPILE_MEMORY_LEAK_FUNCTIONS
#include <crtdbg.h>
#endif

static HANDLE hFile;
static short* g_NormalizeMap;

DWORD g_dwMusicCompressPos;
DWORD g_dwMusicCompressLength;

DWORD g_dwEncodeReadBufferPos;
DWORD g_dwEncodeReadBufferLength;
LPBYTE g_lpbEncodeReadBuffer;

#ifdef COMPILE_MEMORY_LEAK_FUNCTIONS

typedef struct _MemAlloc {
    long lRequest;
    long size;
    unsigned char bAllocated;
} MemAlloc;

#define MAX_TRACE 100000
MemAlloc gTrace[MAX_TRACE];
long gLastAlloc;
long gAllocationOffset;
long gPassIndex;


// Once you know which allocations are leaking, the gBreakOnList can be used to automatically break when the allocation
// is made. Then you can look at the stack to figure out whos causing the leak.

// #define BREAK_ON_LEAK_ALLOCATION
#ifdef BREAK_ON_LEAK_ALLOCATION
long gBreakOnList[] = {
#if 0
    // Pass 0
    544, // 16820
    545, // 206220
#endif
    // Pass 1
442, // 30
463, // 30
594, // 30
615, // 30

};
#endif


unsigned long GetHeapUsed(){
    MEMORYSTATUS mem;
    GlobalMemoryStatus(&mem);
    return mem.dwTotalPhys - mem.dwAvailPhys;
}

int __cdecl My_CrtDefaultAllocHook(
        int nAllocType,
        void * pvData,
        size_t nSize,
        int nBlockUse,
        long lRequest,
        const unsigned char * szFileName,
        int nLine
        )
{
    const char* sAllocType;
    int blockIndex;
    switch(nAllocType){
    case _HOOK_ALLOC : sAllocType = "alloc"; break;
    case _HOOK_REALLOC : sAllocType = "realloc"; break;
    case _HOOK_FREE : sAllocType = "free";
        lRequest = * (long*) (((char*) pvData) - 0x8); // Recover lRequest number from debug heap header
        break;
    default:  sAllocType = "??"; break;
    }
#if 0
        DbgPrint("%s: %x %d %d %d\n", sAllocType , pvData, nSize, nBlockUse, lRequest);
#endif

    if(gAllocationOffset == -1){
        gAllocationOffset = lRequest;
    }

    blockIndex = lRequest - gAllocationOffset;
    if(0 <= blockIndex && blockIndex < MAX_TRACE){
        MemAlloc* pAlloc = &gTrace[blockIndex];
        switch(nAllocType){
        case _HOOK_ALLOC:
            gLastAlloc = lRequest;
            pAlloc->lRequest = lRequest;
            pAlloc->size = nSize;
            pAlloc->bAllocated = 1;
#ifdef BREAK_ON_LEAK_ALLOCATION
            if(gPassIndex == 1){
                int i;
                for(i = 0; i < sizeof(gBreakOnList) / sizeof(gBreakOnList[0]); i++){
                    if(lRequest-gAllocationOffset == gBreakOnList[i]){
                        DbgPrint("This allocation was leaked in a previous run.\n");
                        _asm int 3;
                    }
                }
            }
#endif
            break;
        case _HOOK_FREE:
            pAlloc->bAllocated = 0;
            break;
        }
    }
    return 1; /* allow all allocs/reallocs/frees */
}

void ReportAllocated(){
    int high;
    if(gAllocationOffset == -1){
        high = 0;
    }
    else {
        high = gLastAlloc - gAllocationOffset;
    }
    DbgPrint("Pass %d alloc was called %d times.\n", gPassIndex, high);
    int i;
    int garbageCount = 0;
    for(i = 0; i <= high; i++){
        MemAlloc* pAlloc = &gTrace[i];
        if(pAlloc->bAllocated){
            DbgPrint("%d, // %d\n", pAlloc->lRequest-gAllocationOffset, pAlloc->size);
            garbageCount++;
        }
    }
    DbgPrint("%d blocks still allocated.\n", garbageCount);
    gPassIndex++;
}

void ResetLeakDetector(){
    int i;
    gAllocationOffset = -1;
    for(i = 0; i < MAX_TRACE; i++){
        gTrace[i].bAllocated = 0;
    }
}

static unsigned long gHeapSizeStart;
static _CRT_ALLOC_HOOK gOldHook;
extern "C" void EndLeakTest();

extern "C" void StartLeakTest(){
    if(gHeapSizeStart){
        EndLeakTest();
    }
    gOldHook = _CrtSetAllocHook(My_CrtDefaultAllocHook);
    ResetLeakDetector();
    gHeapSizeStart = GetHeapUsed();
    DbgPrint("Heap size at start of leak test: %d bytes\n", gHeapSizeStart);
}

extern "C" void EndLeakTest(){
    if(gHeapSizeStart){
        unsigned long heapSizeEnd = GetHeapUsed();
        DbgPrint("Heap size at end: %d bytes. Delta = %d\n", heapSizeEnd, heapSizeEnd - gHeapSizeStart);
        DbgPrint("Still-allocated blocks (possible leaks):\n");
        ReportAllocated();
        _CrtSetAllocHook(gOldHook);
        DbgPrint("End of leak test.\n");
        gHeapSizeStart = 0;
    }
}

#endif // COMPILE_MEMORY_LEAK_FUNCTIONS

bool CompressAudio(DWORD dwSongID, short sMax)
{
#ifdef DETECT_MEMORY_LEAKS
    StartLeakTest();
#endif

    char szSrcPath [MAX_PATH];
    char szDestPath [MAX_PATH];

    strcpy(szSrcPath, XappTempPcmFileA);
    strcpy(szDestPath, XappTempWmaFileA);

    hFile = CreateFileA(szSrcPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        TRACE(_T("CompressAudio: Cannot open source file: %s\n"), szSrcPath);
        return false;
    }

    g_dwMusicCompressLength = GetFileSize(hFile, NULL);

    tWMFEncodeStatus tStatus;
    U32_WMF cbBuffer;
    char szAlteredPath [MAX_PATH];

    HWMFENCODER hWMFEnc = WMFCreateEncoderUsingProfile(&tStatus, szDestPath,
        Profile_AudioOnly_CDAudiophileQuality_128K,
        2, 44100, 16,
        g_dwMusicCompressLength, &cbBuffer, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WMF_NoPreProcess, szAlteredPath);

    if (tStatus != WMF_Succeeded)
    {
        TRACE(_T("\001CompressAudio: WMFCreateEncoderUsingProfile failed (%d)\n"), tStatus);
        g_dwMusicCompressLength = 0;
        return false;
    }

    ASSERT(hWMFEnc != NULL);

    BYTE* pbBuffer = new U8_WMF [cbBuffer];
    if (pbBuffer == NULL)
    {
        TRACE(_T("\001Not enough memory to compress audio!\n"));
        g_dwMusicCompressLength = 0;
        CloseHandle(hFile);
        WMFClose(hWMFEnc);
        return false;
    }

    ASSERT(g_lpbEncodeReadBuffer == NULL);

    g_dwEncodeReadBufferPos = 0;
    g_dwEncodeReadBufferLength = 0;
    g_lpbEncodeReadBuffer = new BYTE [cbBuffer];

    if (g_lpbEncodeReadBuffer == NULL)
    {
        TRACE(_T("\001Not enough memory to compress audio!\n"));
        g_dwMusicCompressLength = 0;
        CloseHandle(hFile);
        WMFClose(hWMFEnc);
        delete [] pbBuffer;
        return false;
    }

    if (sMax > 0 && sMax < 32767)
    {
        g_NormalizeMap = new short [65536];
        if (g_NormalizeMap != NULL)
        {
            float f = 32767.0f / (float)sMax;
            for (int i = 0; i < 65536; i += 1)
            {
                float s = (float)(i - 32768) / 32767.0f;
                g_NormalizeMap[i] = (short)((s * f) * 32767.0f);
            }
        }
    }

    tStatus = WMFEncode(hWMFEnc, pbBuffer, cbBuffer, 0, 0);

    g_dwMusicCompressLength = 0;
    g_dwMusicCompressPos = 0;

    if (g_NormalizeMap != NULL)
    {
        delete [] g_NormalizeMap;
        g_NormalizeMap = NULL;
    }

    if (g_lpbEncodeReadBuffer != NULL)
    {
        delete [] g_lpbEncodeReadBuffer;
        g_lpbEncodeReadBuffer = NULL;
    }

    if (tStatus != WMF_Succeeded)
    {
        TRACE(_T("\001CompressAudio: WMFEncode failed (%d)\n"), tStatus);
        CloseHandle(hFile);
        WMFClose(hWMFEnc);
        delete [] pbBuffer;
        return false;
    }

    CloseHandle(hFile);
    DeleteFile(szSrcPath);
    WMFClose(hWMFEnc);
    delete [] pbBuffer;

#ifdef DETECT_MEMORY_LEAKS
    EndLeakTest();
#endif

//  TRACE(_T("CompressAudio: complete!\n"));

    return true;
}

I32_WMF WMFCBGetAudioData(U8_WMF** ppbAudioDataBuffer, U32_WMF nInputBufferLen, I64_WMF iSampleOffset, I32_WMF iNumSamplesWanted)
{
    DWORD nBytesNeeded;
    DWORD nBytesRead;
    DWORD nThrowAwayBytes;
    LPVOID lpvReadData;

    TRACE(_T("WMFCBGetAudioData: %d %d\n"), (int)iSampleOffset, (int)iNumSamplesWanted);

    g_dwMusicCompressPos = (DWORD)iSampleOffset * sizeof (I16_WMF) * 2;

    //
    // The WMA encoder ends up re-reading the same regions of the file over and
    // over, so to reduce I/O overhead, we add a buffer to keep the portions of
    // the file that we've already read.  The encoder appears to only read the
    // file in increasing sample offsets, so the cache only moves in one
    // direction.
    //

    nBytesNeeded = iNumSamplesWanted * sizeof (I16_WMF) * 2;

    if ((g_dwMusicCompressPos >= g_dwEncodeReadBufferPos) &&
        (g_dwMusicCompressPos < g_dwEncodeReadBufferPos + g_dwEncodeReadBufferLength)) {

        nThrowAwayBytes = g_dwMusicCompressPos - g_dwEncodeReadBufferPos;

        g_dwEncodeReadBufferLength -= nThrowAwayBytes;

        MoveMemory(g_lpbEncodeReadBuffer, g_lpbEncodeReadBuffer + nThrowAwayBytes,
            g_dwEncodeReadBufferLength);

    } else {
        g_dwEncodeReadBufferLength = 0;
    }

    g_dwEncodeReadBufferPos = g_dwMusicCompressPos;

    if (g_dwEncodeReadBufferLength < nBytesNeeded) {

        if (SetFilePointer(hFile, g_dwEncodeReadBufferPos +
            g_dwEncodeReadBufferLength, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
            return 0;
        }

        lpvReadData = g_lpbEncodeReadBuffer + g_dwEncodeReadBufferLength;

        if (!ReadFile(hFile, lpvReadData, nBytesNeeded - g_dwEncodeReadBufferLength,
            &nBytesRead, NULL)) {
            return 0;
        }

        nBytesRead &= ~1;
        g_dwEncodeReadBufferLength += nBytesRead;

        if (g_NormalizeMap != NULL) {

            short* ps = (short*)lpvReadData;
            short* map = &g_NormalizeMap[32768];
            for (UINT i = 0; i < nBytesRead; i += 2, ps += 1)
                *ps = map[*ps];
        }
    }

    nBytesRead = nBytesNeeded;

    if (nBytesRead > g_dwEncodeReadBufferLength) {
        nBytesRead = g_dwEncodeReadBufferLength;
    }

    CopyMemory(*ppbAudioDataBuffer, g_lpbEncodeReadBuffer, nBytesRead);

    return (I32_WMF) nBytesRead;
}

extern "C" HWMFFILE WMFOPEN( const char *filename, const char *mode )
{  FILE * st;
   st = _fsopen(filename, mode, _SH_DENYRW);
   if (st != NULL) {
#ifdef COOL_XDASH
      setvbuf(st, NULL, _IOFBF, 10*1024*1024);
#else
      setvbuf(st, NULL, _IOFBF, 64*1024);
#endif
   }
   return st;
}

extern "C" U32_WMF WMFWRITE(const void *buffer, U32_WMF size, U32_WMF count, HWMFFILE stream )
{  FILE * st;
   st = (FILE *) stream;
   return fwrite(buffer, size, count, st);
}

extern "C" I64_WMF WMFSEEK( HWMFFILE stream, U64_WMF offset, I32_WMF origin )
{  FILE * st;
   st = (FILE *) stream;
   return fseek(st, (long)offset, origin);
}

extern "C" U64_WMF WMFTELL( HWMFFILE stream)
{  FILE * st;
   st = (FILE *) stream;
   return ftell(st);
}

extern "C" I32_WMF WMFCLOSE( HWMFFILE  stream)
{  FILE * st;
   st = (FILE *) stream;
   return fclose(st);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xfont.c ===
//****************************************************************************
//
// XBox true-type font scan converter library
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

#include "std.h"
#if 0
#ifdef XBOX
#include <xtl.h>
#else 
#include <windows.h>
#endif
#endif

#include <assert.h>
#include <d3d8.h>

#include "xfont.h"
#include "xfontformat.h"
#include "font.h"

//****************************************************************************
// Definitions.
//****************************************************************************

//
// Global variables.
//

// The current font.
Font *s_pFont;

//
// Forwards.
//

HRESULT __stdcall GenerateFontMetrics();

HRESULT __fastcall XFONT_GetCharacterData(WCHAR, Glyph **, unsigned *);

// Cache methods.
HRESULT __stdcall InitializeCache(unsigned cbCacheSize);
static BOOL CheckInCache(WCHAR wch, Glyph **ppGlyph, unsigned *pcbGlyphSize);
static void FreeCacheSpace(unsigned cbSizeNeeded);

//****************************************************************************
// The APIs
//****************************************************************************

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h.
//
// This method always allocates ~112 bytes for each font to store the
// font's state.  Additional memory will be allocated depending on the
// value of the uCacheSize parameter:
//
//    0                            - an allocation to hold the bitmap for the 
//                                   last drawn glyph.  The glyph information
//                                   is ready directly out of the file. 
//                                   Very slow.

//    uCacheSize < font file size  - a block of memory of size uCacheSize 
//                                   holds the most recently drawn glyphs.  
//                                   The glyph information is ready directly 
//                                   out of the file.  This can perform 
//                                   reasonably if the cache is sized
//                                   correctly as determined by experimentation.
//
//    uCacheSize >= font file size - a block of memory just large enough to 
//                                   hold the contents of the file will be 
//                                   allocated and the entire font file will 
//                                   be loaded into it.  Very fast.
//
// This automatically sets the opened font as the one that is currently
// active.  The attributes of the font are all set to their defaults.
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFont
(
    LPCWSTR wszFileName,    // [in] The file name of the font
	unsigned uCacheSize,	// [in] The size of the font cache, in bytes.
    XFONT **ppFont          // [out] The font identifier
)
{
	HRESULT hr;
	Font *pOldFont = s_pFont;
	BOOL fUseCache;

	assert(wszFileName);

	// Initialize the true type package.
	hr = BP_OpenBitmapFont(wszFileName, uCacheSize, &s_pFont, &fUseCache);

	if (FAILED(hr))
	{
		goto Error;
	}

    if (fUseCache)
    {
        hr = InitializeCache(uCacheSize);

        if (FAILED(hr))
        {
            goto Error;
        }
    }

	// Reset the font metrics.
	hr = GenerateFontMetrics();

	if (FAILED(hr))
	{
		goto Error;
	}

	// Set the font style defaults.
	s_pFont->uAlignmentMode   = XFONT_TOP | XFONT_LEFT;
	s_pFont->TextColor		  = 0xFFFFFFFF;
	s_pFont->BackgroundColor  = 0x00000000;
	s_pFont->fPaintBackground = FALSE;

	// Return it.
	if (ppFont)
	{
		*ppFont = (XFONT *)s_pFont;
	}

	return NOERROR;

Error:
	XFONT_UnloadFont(s_pFont);
	s_pFont = pOldFont;

	return hr;
}

//============================================================================
// XFONT_OpenTrueTypeFont is defined in 'TrueType.cpp' to make the linker
// happy when "xfont.lib" is consumed without the truetype support.
//============================================================================

//============================================================================
// Change the currently active font.  This does not change any of the
// attributes of the font that were set when it was last active.
//============================================================================

void __stdcall XFONT_SelectFont
(
	XFONT *pFont			// [in] The id of the font
)
{
	s_pFont = (Font *)pFont;
}

//============================================================================
// Unload a font and free all of its memory.  The XFONT identifier will be 
// invalidated.
//============================================================================

void __stdcall XFONT_UnloadFont
(
	XFONT *pXFont		// [in] The id of the font to unload
)
{
    if (pXFont)
    {
	    Font *pFont = (Font *)pXFont;
        BYTE *pbCache = pFont->pbCache;

	    // Let the particular font package clean up.  This will free the
	    // Font structure.
	    //
	    pFont->pfnUnloadFont(pFont);

        // Free the cache.
        free(pbCache);
    }
}

//============================================================================
// Sets the height of the text cell, in pixels, for the current font.
//
// Defaults to 16 pixels high.  This may only be set on a TrueType font.
//============================================================================

HRESULT __stdcall XFONT_SetTextHeight
(
	unsigned uHeight		// [in] The total height of the text cell
)
{
	assert(s_pFont);

	if ((uHeight << 16) != s_pFont->uCellHeight)
	{
		HRESULT hr;

		unsigned uOldCellHeight = s_pFont->uCellHeight;

		// Tell the font engine.
		s_pFont->uCellHeight = uHeight;

		hr = s_pFont->pfnResetTransform(s_pFont);

		if (FAILED(hr))
		{
			s_pFont->uCellHeight = uOldCellHeight;

			return hr;
		}

		// Regenerate the height information.
		hr = GenerateFontMetrics();

		if (FAILED(hr))
		{
			return hr;
		}
	}

	return NOERROR;
}

//============================================================================
// Sets the amount of antialias information to include in the bitmap with
// valid values of 0 (no information), 2, or 4 (lots of information).
//
// The antialiasing works best for larger or bold fonts whose strokes are 
// more the one pixel wide.  
//
// This may only be set on a TrueType font.  Defaults to 0.
//============================================================================

HRESULT __stdcall XFONT_SetTextAntialiasLevel
(
	unsigned uAntialiasLevel
)
{
	assert(s_pFont);

	if (uAntialiasLevel != 0 && uAntialiasLevel != 2 && uAntialiasLevel != 4)
	{
		return E_INVALIDARG;
	}

	if (s_pFont->uAntialiasLevel != uAntialiasLevel)
	{
		HRESULT hr;

		unsigned uOldAntialiasLevel = s_pFont->uAntialiasLevel;

		s_pFont->uAntialiasLevel = uAntialiasLevel;

		hr = s_pFont->pfnResetTransform(s_pFont);

		if (FAILED(hr))
		{
			s_pFont->uAntialiasLevel = uOldAntialiasLevel;
		}

		return hr;
	}
	else
	{
		return NOERROR;
	}
}

//============================================================================
// Sets the size of the RLE packet used to compress the internal bitmaps
// used by the font.  This may effect the number of bitmaps that can fit
// in the internal cache depending on the size and characteristics of your
// font.  May be 2 - 8.
//
// This may only be set on a TrueType font.  Defaults to 2.
//============================================================================

HRESULT __stdcall XFONT_SetRLEWidth
(
	unsigned uRLEWidth
)
{
	assert(s_pFont);

	if (uRLEWidth < 2 || uRLEWidth > 8)
	{
		return E_INVALIDARG;
	}

	if (s_pFont->uRLEWidth != uRLEWidth)
	{
		HRESULT hr;

		unsigned uOldRLEWidth = s_pFont->uRLEWidth;

		s_pFont->uRLEWidth = uRLEWidth;

		hr = s_pFont->pfnResetTransform(s_pFont);

		if (FAILED(hr))
		{
			s_pFont->uRLEWidth = uOldRLEWidth;
		}

		return hr;
	}
	else
	{
		return NOERROR;
	}
}

//============================================================================
// Sets the style for the text, one of NORMAL, BOLD, ITALICS or BOLDITALICS.
// This will cause the TrueType font scaler to simulate these styles when
// generating the bitmaps for the font.  If the font defines the different
// styles in separate TTF files then load each individually instead of 
// using this method.
//
// Defaults to NORMAL.  This may only be set on a TrueType font.
//============================================================================

HRESULT __stdcall XFONT_SetTextStyle
(
	unsigned uStyle
)
{
    assert(s_pFont);

    if (uStyle > XFONT_BOLDITALICS)
    {
        return E_INVALIDARG;
    }

    if (s_pFont->uStyle != uStyle)
    {
        HRESULT hr;

        unsigned uOldStyle = s_pFont->uStyle;

        s_pFont->uStyle = uStyle;

        hr = s_pFont->pfnResetTransform(s_pFont);

        if (FAILED(hr))
        {
            s_pFont->uStyle = uOldStyle;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
    }

//============================================================================
// Sets to what part of the text the coordinates passed to XFONT_TextOut refers.
//
// The only parameter must contain one vertical value ORed with one 
// horizontal value.
//
// The vertical alignment value specifies which part of the text is pointed
// to by the y coordinate:
//
//		XFONT_BASELINE  - the baseline of the text
//		XFONT_BOTTOM	- the bottom of the character cell
//      XFONT_TOP       - the top of the character cell
//
// The horizontal alignment value specifies which part of the text is pointed
// to by the x coordinate:
//
//		XFONT_CENTER	- the center of the text
//		XFONT_LEFT 	    - the leftmost edge of the text
//      XFONT_RIGHT	    - the rightmost edge of the text
//
// Defaults to TA_TOP | TA_LEFT.
//============================================================================

void __stdcall XFONT_SetTextAlignment
(
	unsigned uMode
)
{
	assert(s_pFont);

	// UNDONE: validate this parameter.
	s_pFont->uAlignmentMode = uMode;	
}

//============================================================================
// Sets the color for the text.  
//
// Defaults to 0x00FFFFFF (white)
//============================================================================

void __stdcall XFONT_SetTextColor
(
	D3DCOLOR color			// [in] The color of the text
)
{
	assert(s_pFont);

	s_pFont->TextColor = color;
}

//============================================================================
// Sets the color with which to fill the background of the text.  
//
// Defaults to 0x00000000 (black)
//============================================================================

void __stdcall XFONT_SetBkColor
(
	D3DCOLOR color			// [in] The color of the text
)
{
	assert(s_pFont);

	s_pFont->BackgroundColor = color;
}

//============================================================================
// Sets whether to fill the background of the text cell with the background
// color.
//
// Defaults to XFONT_TRANSPARENT because it is more efficient.
//============================================================================

void __stdcall XFONT_SetBkMode
(
	int iBkMode				// [in] Either XFONT_OPAQUE or XFONTTRANSPARENT
)
{
   	assert(s_pFont);

	s_pFont->fPaintBackground = iBkMode == XFONT_OPAQUE;
}

//============================================================================
// Sets the number of additional pixels to put between each character.
//============================================================================

void __stdcall XFONT_SetIntercharacterSpacing
(
	unsigned uSpaces		// [in] The number of extra pixels between each character
)
{
	assert(s_pFont);

	s_pFont->uIntercharacterSpacing = uSpaces;
}

//============================================================================
// Get the vertical metrics for the current font settings.  
//============================================================================

void __stdcall XFONT_GetFontMetrics
(
	unsigned *puCellHeight,		
	unsigned *puDescent
)
{
	assert(s_pFont);

	if (puCellHeight)
	{
		*puCellHeight = s_pFont->uCellHeight;
	}

	if (puDescent)
	{
		*puDescent = s_pFont->uDescent;
	}
}

//============================================================================
// Sets or clears the suface to which to draw the text via XFONT_TextOut.
//============================================================================
/*
void __stdcall XFONT_SetDrawingSurface
(
	IDirect3DSurface8 *pSurface		// [in] The surface to draw the text on or NULL
	                                //      release the reference count on the last
									//      set surface.
)
{
	assert(s_pFont);

	if (s_pFont->pSurface)
	{
		IDirect3DSurface8_Release(s_pFont->pSurface);
		s_pFont->pSurface = NULL;
	}

	s_pFont->pSurface = pSurface;

	if (pSurface)
	{
		IDirect3DSurface8_AddRef(pSurface);

		(void)IDirect3DSurface8_GetDesc(pSurface, &s_pFont->SurfaceDesc);
	}
}
*/
//============================================================================
// Get the width of a string in pixels. This method applies any 
// intercharacter spacing.
//============================================================================

HRESULT __stdcall XFONT_GetTextExtent
(
	LPCWSTR wstr,			// [in] The string
	unsigned cch,			// [in] The length of the string, -1 for a zero terminated string
	unsigned *puWidth		// [out] The width of the string in pixels
)
{
	HRESULT hr;

	const unsigned uIntercharacterSpacing = s_pFont->uIntercharacterSpacing;

	Glyph *pGlyph;
    unsigned cbGlyphSize;

	unsigned ich = 0;
	unsigned uWidth = 0;
    
	assert(s_pFont);

	for (;;)
	{
		hr = XFONT_GetCharacterData(*wstr, &pGlyph, &cbGlyphSize);

		if (FAILED(hr)) 
		{
			return hr;
		}

		uWidth += pGlyph->uAdvance;

		// Increment.
		ich++;
		wstr++;

		// Stop?
		if (ich == cch || !*wstr)
		{
			break;
		}

		// Add the intercharacter space.
		uWidth += uIntercharacterSpacing;
	}

	*puWidth = uWidth;

	return NOERROR;
}

//============================================================================
// Draw the text on a surface.  See XFONT_SetTextAlignment for the meaning of
// the x and y coordinates.
//============================================================================

HRESULT __stdcall XFONT_TextOut2
(
	D3DLOCKED_RECT* pLock,	// [in] The surface info
	D3DFORMAT Format,		// [in] The surface format
	long cxClip,			// [in] The surface width
	long cyClip,			// [in] The surface height
	LPCWSTR wstr,			// [in] The string
	unsigned cch,			// [in] The length of the string, -1 for a zero terminated string
	long x,					// [in] The x coordinate of the string
	long y					// [in] The y coordinate of the string
)
{
	HRESULT hr;

	long lCharacterX;
	long lCharacterY;

	//
	// Figure out where to start drawing from.  The rendering package
	// always wants the coordinates of the baseline of the glyph
	// so figure out how we need to munge the values.
	//

	unsigned uVerticalMask = XFONT_BASELINE | XFONT_BOTTOM | XFONT_TOP;
	unsigned uHorizontalMask = XFONT_LEFT | XFONT_CENTER | XFONT_RIGHT;

	assert(s_pFont);
//	assert(s_pFont->pSurface);

	// Vertical munging.
	switch(s_pFont->uAlignmentMode & uVerticalMask)
	{
	default:
		assert(FALSE);     // How did this get through our checks?

		// fall through
	case XFONT_TOP:
		lCharacterY = y;
		break;

	case XFONT_BASELINE:
		lCharacterY = y - (s_pFont->uCellHeight - s_pFont->uDescent);
		break;

	case XFONT_BOTTOM:
		lCharacterY = y - s_pFont->uCellHeight;
		break;
	}

	// Horizontal munging.
	if ((s_pFont->uAlignmentMode & uHorizontalMask) == XFONT_LEFT)
	{
		lCharacterX = x;
	}
	else
	{
		unsigned uWidth;

		hr = XFONT_GetTextExtent(wstr, cch, &uWidth);

		if (FAILED(hr))
		{
			return hr;
		}

		if ((s_pFont->uAlignmentMode & uHorizontalMask) == XFONT_CENTER)
		{
			lCharacterX = x - uWidth / 2;
		}
		else if ((s_pFont->uAlignmentMode & uHorizontalMask) == XFONT_RIGHT)
		{
			lCharacterX = x - uWidth;
		}
		else
		{
			assert(FALSE);

			lCharacterX = x;
		}
	}

	// Draw the string. Just clip to the surface size for now.
	hr = PaintText(pLock,
                   Format,
                   s_pFont, 
			       wstr, 
				   cch, 
				   lCharacterX, 
				   lCharacterY, 
				   0,
				   0,
				   cxClip/*s_pFont->SurfaceDesc.Width*/,
				   cyClip/*s_pFont->SurfaceDesc.Height*/);

	return hr;
}

//****************************************************************************
// This method isn't really exposed in the header file.  It isn't static 
// because the makefont utility calls it when building the bitmap glyph
// information.
//****************************************************************************

//============================================================================
// Gets the character data from the current font, regardless of whether 
// it is a TrueType or bitmap font.
//
// The information returned by this method is only guarenteed to be valid
// until the next call to the font package.  This stuff might be stored
// in a cache and get flushed with the next call.
//============================================================================

HRESULT __fastcall XFONT_GetCharacterData
(
	WCHAR wch, 
	Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    assert(ppGlyph);

    // Check the cache first unless we don't have one.
    if (s_pFont->pbCache && CheckInCache(wch, ppGlyph, pcbGlyphSize))
    {
        return NOERROR;
    }

	return s_pFont->pfnGetCharacterData(s_pFont, wch, ppGlyph, pcbGlyphSize);
}

//****************************************************************************
// Implementation
//****************************************************************************

//============================================================================
// Figure out the vertical height information for this font.
//============================================================================

HRESULT __stdcall GenerateFontMetrics()
{
	HRESULT hr;

	Glyph *pGlyph;
    unsigned cbGlyphSize;

	// Figure out the descent, this is defined to be
	// the amount that a lower case 'g' hangs below the baseline.
	// It can be computed by getting the height of the 'g' and
	// subtracting the y component of its bearing.
	//		
	hr = XFONT_GetCharacterData(L'g', &pGlyph, &cbGlyphSize);

	if (FAILED(hr))
	{
		return hr;
	}

	s_pFont->uDescent = pGlyph->uBitmapHeight - pGlyph->iBearingY;

	return NOERROR;
}

//****************************************************************************
// Cache implementation.
//****************************************************************************


//
// The design for the cache errors on the side of simplicitly.  If anybody
// decides to actually use the TrueType package then they will probably
// want to put in something a bit more efficient.
//

//============================================================================
// Initialize the cache.
//============================================================================

HRESULT __stdcall InitializeCache
(
    unsigned cbCacheSize
)
{
    if (cbCacheSize)
    {
        BYTE *pbCache = (BYTE *)malloc(cbCacheSize);

        if (!pbCache)
        {
            return E_OUTOFMEMORY;
        }

	    // Save the cache info.
		s_pFont->pbCache = pbCache;
        s_pFont->pbCacheNext = pbCache;
		s_pFont->pbCacheEnd = pbCache + cbCacheSize;

	    // Initialize the list.
	    s_pFont->CacheHead.pNextEntry = &s_pFont->CacheHead;
	    s_pFont->CacheHead.pPrevEntry = &s_pFont->CacheHead;
    }

    return NOERROR;
}

//============================================================================
// Examines the cache to see if we already have the information for a
// character.
//============================================================================

static BOOL CheckInCache
(
	WCHAR wch, 
	Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
	// This is pretty lame.  We probably have to use a slightly more efficient
	// lookup algorithm.
	//
	CacheEntry *pEntry = s_pFont->CacheHead.pNextEntry;

	while (pEntry->wLength)
	{
		if (pEntry->wch == wch)
		{
			*ppGlyph = (Glyph *)(pEntry + 1);
            *pcbGlyphSize = pEntry->wLength - sizeof(CacheEntry);

			// Move this entry to the front of the list.
			if (s_pFont->CacheHead.pNextEntry != pEntry)
			{
				// Unlink.
				pEntry->pPrevEntry->pNextEntry = pEntry->pNextEntry;
				pEntry->pNextEntry->pPrevEntry = pEntry->pPrevEntry;

				// Relink.
				pEntry->pNextEntry = s_pFont->CacheHead.pNextEntry;
				pEntry->pNextEntry->pPrevEntry = pEntry;
				pEntry->pPrevEntry = &s_pFont->CacheHead;
				s_pFont->CacheHead.pNextEntry = pEntry;
			}

			return TRUE;
		}

		pEntry = pEntry->pNextEntry;
	}

	return FALSE;
}

//============================================================================
// Alloc cache information for a character.
//============================================================================

HRESULT AddToCache
(
	WCHAR wch,
	unsigned cbGlyph,
	Glyph **ppGlyph
)
{
	long cbSizeNeeded = (sizeof(CacheEntry) + sizeof(Glyph) + cbGlyph + 3) & ~3;  // 4 byte aligned
	CacheEntry *pEntry;

	// If the cache isn't big enough, just alloc a block of memory
	// and use that.
	//
	if (cbSizeNeeded > s_pFont->pbCacheEnd - s_pFont->pbCache)
	{
		// We need 1 extra byte for the packer.
		s_pFont->pvOneGlyph = malloc(cbSizeNeeded + 1);

		if (!s_pFont->pvOneGlyph)
		{
			return E_OUTOFMEMORY;
		}

		*ppGlyph = (Glyph *)s_pFont->pvOneGlyph;

		return NOERROR;
	}

	if (cbSizeNeeded > s_pFont->pbCacheEnd - s_pFont->pbCacheNext)
	{
		FreeCacheSpace(cbSizeNeeded);
	}

	// Get the memory.
	pEntry = (CacheEntry *)s_pFont->pbCacheNext;

	// Don't forget about it.
	s_pFont->pbCacheNext += cbSizeNeeded;

	// Link it at the head of the list.
	pEntry->pNextEntry = s_pFont->CacheHead.pNextEntry;
	pEntry->pNextEntry->pPrevEntry = pEntry;
	pEntry->pPrevEntry = &s_pFont->CacheHead;
	s_pFont->CacheHead.pNextEntry = pEntry;

	// Save the cache info.
	pEntry->wch = wch;
	pEntry->wLength = (WORD)cbSizeNeeded;

	// Return it.
	*ppGlyph = (Glyph *)(pEntry + 1);

	return NOERROR;
}

//============================================================================
// Reset the cache back to nothin'.
//============================================================================

void ClearCache()
{
    if (s_pFont)
    {
	    s_pFont->pbCacheNext = s_pFont->pbCache;

	    s_pFont->CacheHead.pNextEntry = &s_pFont->CacheHead;
	    s_pFont->CacheHead.pPrevEntry = &s_pFont->CacheHead;
    }
}

//============================================================================
// Free up enough room in the cache to hold a new entry.
//============================================================================

static void FreeCacheSpace
(
	unsigned cbSizeNeeded
)
{
    unsigned cbSizeFree;
    CacheEntry *pEntry;
    unsigned cbFreed;

    BYTE *pbNext;
	BYTE *pbEnd;

	// Free either the requested size or 1/4 of the cache, whichever is bigger.
	// This won't work well for very small caches with large bitmaps...
	// we'll spend an aweful lot of time freeing.
	//
	cbSizeFree = max(cbSizeNeeded, (unsigned)(s_pFont->pbCacheEnd - s_pFont->pbCache) / 4);

	// We can walk the entries in two ways:
	//
	//  - Through the circularly linked list in either direction.  This list
	//    has the most recently accessed glyph at the front.
	//    
	//  - Through the memory in the order the entries were allocated
	//    via the wLength field.
	//
	// This routine first walks the linked list backwards and "nulls" enough
	// nodes to fit our requirement.  It then walks through memory
	// compressing out those null nodes.  This ruins the whole sense of
	// order in the list...we'll regen that soon enough.
	//
	pEntry = s_pFont->CacheHead.pPrevEntry;
	cbFreed = 0;

	// Free the spaces.
	while (pEntry->wLength && cbFreed < cbSizeFree)
	{
		// Remember the size.
		cbFreed += pEntry->wLength;

		// Mark it as dead by wonking the next field.
		pEntry->pNextEntry = NULL;

		pEntry = pEntry->pPrevEntry;
	}

	// Reset the list.
	s_pFont->CacheHead.pNextEntry = &s_pFont->CacheHead;
	s_pFont->CacheHead.pPrevEntry = &s_pFont->CacheHead;

	// Walk through the memory through the allocations, remove the dead
	// entries and relink the other ones back onto the list.
	//
	pbNext = s_pFont->pbCache;
	pbEnd = s_pFont->pbCacheNext;

	pEntry = (CacheEntry *)pbNext;

	while ((BYTE *)pEntry < pbEnd)
	{
		// Valid entry?
		if (pEntry->pNextEntry)
		{
			CacheEntry *pNewEntry;

			// Move it.
			if ((BYTE *)pEntry != pbNext)
			{
				memmove(pbNext, pEntry, pEntry->wLength);

				pNewEntry = (CacheEntry *)pbNext;
			}
			else
			{
				pNewEntry = pEntry;
			}

			// Relink it onto the end of the list.
			pNewEntry->pPrevEntry = s_pFont->CacheHead.pPrevEntry;
			pNewEntry->pPrevEntry->pNextEntry = pNewEntry;
			pNewEntry->pNextEntry = &s_pFont->CacheHead;
		    s_pFont->CacheHead.pPrevEntry = pNewEntry;

			// The fields in 'pEntry' may have been wonked by the 
			// above move, increment based off the valid field.
			//
			pEntry = (CacheEntry *)((BYTE *)pEntry + pNewEntry->wLength);
			pbNext += pNewEntry->wLength;
		}
		else
		{
			pEntry = (CacheEntry *)((BYTE *)pEntry + pEntry->wLength);
		}
	}

	s_pFont->pbCacheNext = pbNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xapp.h ===
// XApp.h -- Main Declarations for XApp
//

// Represent time values as a 'double' for good fractional precision after
// a large period of time (days).  The really proper fix would be to represent
// time using a DWORD, and convert to floating point after computing an
// age, but we don't have time to do that...
typedef double XTIME;

#define MAX_BLOCKS_TO_SHOW 50000

#define CNode CXAppNode // REVIEW: Name collision with D3DX...
#define classCNode classCXAppNode // REVIEW: Name collision with D3DX...

class CObject;
class CClass;
class CInstance;
class CNode;
class CNodeArray;
class CScreen;
class CViewpoint;
class CNavigationInfo;
class CNavigator;
class CBackground;
class CXApp;

////////////////////////////////////////////////////////////////////////////

class CXApp
{
public:
    CXApp();
    ~CXApp();

	bool InitApp();
	void CleanupApp();
	void GetStartupClassFile(TCHAR* szFileToLoad);

#if defined(_WINDOWS)
	HINSTANCE m_hInstance;
    HWND m_hWnd;
	TCHAR* m_szAppTitle;
	bool m_bFullScreen;
	int m_nCmdShow;
	bool m_bDrawFramerate;

	int m_nVertPerFrame;
	int m_nTriPerFrame;

	LRESULT WndProc(UINT message, WPARAM wParam, LPARAM lParam);

	bool InitWindow();
	void OnSize(int nWidth, int nHeight);
	bool ParseCmdLine();
#endif

	void Advance();
    void Draw();

	D3DPRESENT_PARAMETERS m_pp;
    LPDIRECT3DDEVICE8 m_pD3DDev;
	LPDIRECT3D8 m_pD3D;
	bool InitD3D();
	void ReleaseD3D();

	bool m_bStretchWidescreen;
	float m_nViewWidth;
	float m_nViewHeight;

	bool m_bZBuffer;
	bool m_bProjectionDirty;
	ID3DXMatrixStack* m_worldStack;

	DWORD m_dwStartTick;
	DWORD m_dwFrameTick;
	XTIME m_now;

	// The XApplication Objects...
	CClass* m_pClass;
	CInstance* m_pObject;

	// Bound Nodes...
	CScreen* m_pScreen;
	CViewpoint* m_pViewpoint;
	CNavigationInfo* m_pNavigationInfo;
	CBackground* m_pBackground;

#ifdef _WINDOWS
	CNode* m_pGround;
	CNavigator* m_pNavigator;
#endif

	TCHAR* m_szAppDir;

    // Dashboard launch data
    bool m_bHasLaunchData;
    DWORD m_dwTitleID;
    DWORD m_dwLaunchReason;
    DWORD m_dwLaunchContext;
    DWORD m_dwLaunchParameter1;
    DWORD m_dwLaunchParameter2;

    DWORD m_dwMainThreadId;
};

extern CXApp theApp;

////////////////////////////////////////////////////////////////////////////

inline XTIME XAppGetNow() { return theApp.m_now; }

#ifdef _WINDOWS
inline HINSTANCE XAppGetInstanceHandle() { return theApp.m_hInstance; }
int XAppMessageBox(const TCHAR* szText, UINT uType = MB_OK);
#endif


#ifdef _DEBUG
void XAppGetErrorString(HRESULT hr, TCHAR* szBuf, int cchBuf);
const TCHAR* XAppGetErrorString(HRESULT hr);
void LogComError(HRESULT hr, const char* szFunc = NULL);
void LogError(const char* szFunc);
#else
inline void LogComError(HRESULT hr, const char* szFunc = NULL) {}
inline void LogError(const char* szFunc) {}
#endif


void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL);
void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szURL);
void UpdateCurDirFromFile(const TCHAR* szURL);

void* XAppAllocMemory(int nBytes);
void XAppFreeMemory(void* pv);

#ifdef _XBOX
void* XAppD3D_AllocContiguousMemory(DWORD Size, DWORD Alignment);
void* XAppD3D_AllocNoncontiguousMemory(DWORD Size);
#endif

////////////////////////////////////////////////////////////////////////////
// XApp Direct 3D Device Interfaces

#ifdef _XBOX // REVIEW: Nuke this when GetRenderState is implemented!
extern DWORD xapp_rgdwRenderStateCache [256];
extern bool xapp_rgbRenderStateCache [256];
#endif

inline LPDIRECT3DDEVICE8 XAppGetD3DDev()
{
	return theApp.m_pD3DDev;
}

inline void XAppSetRenderState(D3DRENDERSTATETYPE dwRenderStateType, DWORD dwRenderState)
{
#ifdef _XBOX // REVIEW: Nuke this when GetRenderState is implemented!
	ASSERT((UINT)dwRenderStateType < countof (xapp_rgdwRenderStateCache));
	xapp_rgdwRenderStateCache[(UINT)dwRenderStateType] = dwRenderState;
	xapp_rgbRenderStateCache[(UINT)dwRenderStateType] = true;
#endif

	VERIFYHR(XAppGetD3DDev()->SetRenderState(dwRenderStateType, dwRenderState));
}

inline void XAppGetRenderState(D3DRENDERSTATETYPE dwRenderStateType, LPDWORD lpdwRenderState)
{
#ifdef _XBOX // REVIEW: Nuke this when GetRenderState is implemented!
	ASSERT((UINT)dwRenderStateType < countof (xapp_rgdwRenderStateCache));
	ASSERT(xapp_rgbRenderStateCache[(UINT)dwRenderStateType]); // we don't know the state!
	*lpdwRenderState = xapp_rgdwRenderStateCache[(UINT)dwRenderStateType];
#else
	VERIFYHR(XAppGetD3DDev()->GetRenderState(dwRenderStateType, lpdwRenderState));
#endif
}

inline void XAppSetTextureStageState(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
	VERIFYHR(XAppGetD3DDev()->SetTextureStageState(dwStage, dwState, dwValue));
}

inline void XAppGetTextureStageState(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, LPDWORD lpdwValue)
{
	VERIFYHR(XAppGetD3DDev()->GetTextureStageState(dwStage, dwState, lpdwValue));
}

inline void XAppSetTexture(DWORD dwStage, LPDIRECT3DTEXTURE8 lpTexture)
{
	VERIFYHR(XAppGetD3DDev()->SetTexture(dwStage, lpTexture));
}

inline void XAppSetMaterial(D3DMATERIAL8* lpMaterial)
{
	VERIFYHR(XAppGetD3DDev()->SetMaterial(lpMaterial));
}

inline void XAppSetTransform(D3DTRANSFORMSTATETYPE dtstTransformStateType, D3DMATRIX* lpD3DMatrix)
{
	VERIFYHR(XAppGetD3DDev()->SetTransform(dtstTransformStateType, lpD3DMatrix));
}

inline void XAppGetTransform(D3DTRANSFORMSTATETYPE dtstTransformStateType, D3DMATRIX* lpD3DMatrix)
{
	VERIFYHR(XAppGetD3DDev()->GetTransform(dtstTransformStateType, lpD3DMatrix));
}

#ifndef _XBOX
inline void XAppSetClipPlane(DWORD dwIndex, D3DVALUE* pPlaneEquation)
{
#ifndef _XBOX
	VERIFYHR(XAppGetD3DDev()->SetClipPlane(dwIndex, pPlaneEquation));
#endif
}
#endif // _XBOX

#ifdef _LIGHTS
inline void XAppSetLight(DWORD dwLightIndex, D3DLIGHT8* lpLight)
{
	VERIFYHR(XAppGetD3DDev()->SetLight(dwLightIndex, lpLight));
}

inline void XAppLightEnable(DWORD dwLightIndex, bool bEnable)
{
	VERIFYHR(XAppGetD3DDev()->LightEnable(dwLightIndex, bEnable));
}
#endif

inline void XAppClear(D3DCOLOR color)
{
	DWORD dwFlags = D3DCLEAR_TARGET;

	if (theApp.m_bZBuffer)
		dwFlags |= D3DCLEAR_ZBUFFER;

	VERIFYHR(XAppGetD3DDev()->Clear(0, NULL, dwFlags, color, 1.0f, 0));
}

inline void XAppBeginScene()
{
	VERIFYHR(XAppGetD3DDev()->BeginScene());
}

inline void XAppEndScene()
{
	VERIFYHR(XAppGetD3DDev()->EndScene());
}

inline void XAppPresent()
{
	VERIFYHR(XAppGetD3DDev()->Present(NULL, NULL, NULL, NULL));
}

inline void XAppGetTextureSize(LPDIRECT3DTEXTURE8 pTexture, int& nWidth, int& nHeight)
{
	D3DSURFACE_DESC sd;
	VERIFYHR(pTexture->GetLevelDesc(0, &sd));
	nWidth = (int)sd.Width;
	nHeight = (int)sd.Height;
}

inline void XAppGetTextureSize(LPDIRECT3DTEXTURE8 pTexture, float& nWidth, float& nHeight)
{
	int iWidth, iHeight;
	XAppGetTextureSize(pTexture, iWidth, iHeight);
	nWidth = (float)iWidth;
	nHeight = (float)iHeight;
}

inline void XAppSetVertexShader(DWORD Handle)
{
	VERIFYHR(XAppGetD3DDev()->SetVertexShader(Handle));
}

inline void XAppSetVertexShaderConstant(DWORD Register, const void* pConstantData, DWORD ConstantCount)
{
	VERIFYHR(XAppGetD3DDev()->SetVertexShaderConstant(Register, pConstantData, ConstantCount));
}

inline void XAppSetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer8* pStreamData, UINT Stride)
{
	VERIFYHR(XAppGetD3DDev()->SetStreamSource(StreamNumber, pStreamData, Stride));
}

inline void XAppSetIndices(IDirect3DIndexBuffer8* pIndexData, UINT BaseVertexIndex)
{
	VERIFYHR(XAppGetD3DDev()->SetIndices(pIndexData, BaseVertexIndex));
}

inline void XAppDrawIndexedPrimitive(D3DPRIMITIVETYPE Type, UINT MinIndex, UINT NumVertices, UINT StartIndex, UINT PrimitiveCount)
{
	VERIFYHR(XAppGetD3DDev()->DrawIndexedPrimitive(Type, MinIndex, NumVertices, StartIndex, PrimitiveCount));
}

extern int __cdecl NewFailed(size_t nBytes);

inline void XAppCreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, IDirect3DIndexBuffer8** ppIndexBuffer)
{
	HRESULT hr;

	do
	{
		hr = XAppGetD3DDev()->CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer);
		if (hr != E_OUTOFMEMORY)
			break;
	}
	while (NewFailed(Length) != 0);

	VERIFYHR(hr);
}

inline void XAppCreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, IDirect3DVertexBuffer8** ppVertexBuffer)
{
	HRESULT hr;

	do
	{
		hr = XAppGetD3DDev()->CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer);
		if (hr != E_OUTOFMEMORY)
			break;
	}
	while (NewFailed(Length) != 0);

	VERIFYHR(hr);
}

inline void XAppCreateVertexShader(CONST DWORD* pDeclaration, CONST DWORD* pFunction, DWORD* pHandle, DWORD Usage)
{
	VERIFYHR(XAppGetD3DDev()->CreateVertexShader(pDeclaration, pFunction, pHandle, Usage));
}

////////////////////////////////////////////////////////////////////////////
// World Matrix Stack

inline D3DXMATRIX* XAppGetWorld()
{
	ASSERT(theApp.m_worldStack != NULL);
	return theApp.m_worldStack->GetTop();
}

extern void SetFalloffShaderFrameValues();

inline void XAppUpdateWorld()
{
	ASSERT(theApp.m_worldStack != NULL);
	XAppSetTransform(D3DTS_WORLD, XAppGetWorld());
	SetFalloffShaderFrameValues();
}

inline void XAppPushWorld()
{
	ASSERT(theApp.m_worldStack != NULL);
	VERIFYHR(theApp.m_worldStack->Push());
}

inline void XAppPopWorld()
{
	ASSERT(theApp.m_worldStack != NULL);
	VERIFYHR(theApp.m_worldStack->Pop());
	XAppUpdateWorld();
}

inline void XAppMultWorld(const D3DXMATRIX* pMat)
{
	ASSERT(theApp.m_worldStack != NULL);
	VERIFYHR(theApp.m_worldStack->MultMatrixLocal(pMat));
}

inline void XAppTranslateWorld(float x, float y, float z)
{
	ASSERT(theApp.m_worldStack != NULL);
	VERIFYHR(theApp.m_worldStack->TranslateLocal(x, y, z));
}

inline void XAppRotateWorld(const D3DXVECTOR3* pV, float angle)
{
	ASSERT(theApp.m_worldStack != NULL);
	VERIFYHR(theApp.m_worldStack->RotateAxisLocal(pV, angle));
}

inline void XAppIdentityWorld()
{
	ASSERT(theApp.m_worldStack != NULL);
	VERIFYHR(theApp.m_worldStack->LoadIdentity());
}

#ifndef _XBOX
#undef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

////////////////////////////////////////////////////////////////////////////

inline float pos(float n)
{
	if (n > 0.0f)
		return n;

	return 0.0f;
}

inline float rnd(float n)
{
	return (float)rand() * n / 32767.0f;
}

inline float wrap(float n)
{
	return n - floorf(n);
}

#define trunc(n) ((int)(n))


inline int clamp(int x, int a, int b)
{
	return (x < a ? a : (x > b ? b : x));
}

inline float clampf(float x, float a, float b)
{
	return (x < a ? a : (x > b ? b : x));
}

////////////////////////////////////////////////////////////////////////////

extern bool CallFunction(CObject* pObject, const TCHAR* szFunc, int nParam = 0, CObject** rgParam = NULL);

////////////////////////////////////////////////////////////////////////////

extern TCHAR g_szCurDir [];

class CDirPush
{
public:
	CDirPush(const TCHAR* szFile = NULL)
	{
        ASSERT(theApp.m_dwMainThreadId == GetCurrentThreadId());
		_tcscpy(m_szCurDirSav, g_szCurDir);

		if (szFile != NULL)
		{
			UpdateCurDirFromFile(szFile);
		}
	}

	~CDirPush()
	{
        ASSERT(theApp.m_dwMainThreadId == GetCurrentThreadId());
		_tcscpy(g_szCurDir, m_szCurDirSav);
//		TRACE(_T("Resetting base directory to %s\n"), g_szCurDir);
	}

	TCHAR m_szCurDirSav [1024];
};

////////////////////////////////////////////////////////////////////////////

extern void CleanFilePath(FSCHAR* szPath, const TCHAR* szSrcPath);

inline HANDLE XAppCreateFile(const TCHAR* szFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes = 0, HANDLE hTemplateFile = NULL)
{
	FSCHAR sszFileName [MAX_PATH];
	CleanFilePath(sszFileName, szFileName);
	return CreateFile(sszFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

inline bool XAppCreateDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL)
{
	FSCHAR sszFileName [MAX_PATH];
	CleanFilePath(sszFileName, lpPathName);
	return CreateDirectory(sszFileName, lpSecurityAttributes) != FALSE;
}

////////////////////////////////////////////////////////////////////////////

const CHAR XappTempPcmFileA[]  =  "t:\\tempcda.cda";
const WCHAR XappTempPcmFileW[] = L"t:\\tempcda.cda";
const CHAR XappTempWmaFileA[]  =  "t:\\tempwma.wma";
const WCHAR XappTempWmaFileW[] = L"t:\\tempwma.wma";

#ifdef _UNICODE
#define XappTempPcmFile XappTempPcmFileW
#else  // _UNICODE
#define XappTempPcmFile XappTempPcmFileA
#endif // _UNICODE

////////////////////////////////////////////////////////////////////////////

extern int g_nDiscType;

#define DISC_NONE   0
#define DISC_BAD    1
#define DISC_TITLE  2
#define DISC_AUDIO  3
#define DISC_VIDEO  4

////////////////////////////////////////////////////////////////////////////

extern bool ResetScreenSaver();

////////////////////////////////////////////////////////////////////////////

#define D3DFVF_NORMPACKED3		0x20000000

extern DWORD CompressNormal(float* pvNormal);

////////////////////////////////////////////////////////////////////////////

extern DWORD GetFixedFunctionShader(DWORD fvf);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xcdplay.h ===
#pragma once
#include "cdda.h"
#include "AudioPump.h"

class XCDPlayer : public CAudioPump
{
public:
    XCDPlayer();
    ~XCDPlayer();

    bool Initialize(int nTrack, WAVEFORMATEX* pFormat);
//    void Seek(BOOL fForward);
    void Stop();

	void* GetSampleBuffer();
	DWORD GetSampleBufferSize();

	float GetPlaybackTime();
	float GetPlaybackLength();

private:
   	int GetData(BYTE* pbBuffer, int cbBuffer);

    DWORD GetPosition();
    void SetPosition(DWORD dwPosition);

	DWORD m_dwStartPosition;
	DWORD m_dwStopPosition;
	CCDDAStreamer m_streamer;
    LPVOID m_pvBuffer;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xip.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "xip.h"
#include "Mesh.h"
#include <xcrypt.h>

#ifdef COOL_XDASH
#include "Node.h"
#include "Camera.h"
extern CCamera theCamera;
extern UINT g_uMeshRef;
extern D3DXMATRIX g_matProjection;
#endif

extern BOOL g_bEdgeAntialiasOverride;

#define FILE_BUFFER_SIZE 65536

void FileProtectionError()
{
#ifdef _DEBUG
	ALERT(_T("XIP File Protection Error"));
    __asm int 3;
#else
    HalReturnToFirmware(HalFatalErrorRebootRoutine);
#endif
}

CFileBuffer::CFileBuffer()
{
	m_hFile = INVALID_HANDLE_VALUE;
	m_pbBuffer = NULL;
	m_cbBuffer = 0;
	m_ibRead = 0;
    m_nBlkCur = 0;
	m_XipSigs = NULL;
}

void CFileBuffer::SetFile(PCTSTR Name, HANDLE hFile)
{
	ASSERT(m_hFile == INVALID_HANDLE_VALUE);
	m_hFile = hFile;
	
    if (m_XipSigs)
    {
        VERIFY(XFreeSectionByHandle(XGetSectionHandle("XIPS")));
    }

	m_XipSigs = (PXIP_PROTECTION)XLoadSection("XIPS");

	if (!m_XipSigs)
    {
		//
		// No Xip Signatures in the XBE.
		//
		ALERT(_T("No XIP section in XBE."));
		FileProtectionError();
	}
	else
    {	
		while (m_XipSigs->SignatureCount != 0 && lstrcmpi(Name + 3, m_XipSigs->Name))
        {
			m_XipSigs = (PXIP_PROTECTION)((PBYTE)(m_XipSigs + 1) +
                (m_XipSigs->SignatureCount * sizeof (XIP_SIG)));
		}

		if (m_XipSigs->SignatureCount == 0)
        {
			//
			// Did not find this XIP file in the XIP section.
			//
			ALERT(_T("File %s not found in XBE Xip section."), Name);
			FileProtectionError();
		}
	}
}

CFileBuffer::~CFileBuffer()
{
	FreeBuffer();

    // Keep the section load counts valid
    if (m_XipSigs)
    {
        VERIFY(XFreeSectionByHandle(XGetSectionHandle("XIPS")));
    }
}

void CFileBuffer::FreeBuffer()
{
	if (m_pbBuffer != NULL)
	{
		VERIFY(VirtualFree(m_pbBuffer, 0, MEM_RELEASE));
		m_pbBuffer = NULL;
	}
}

void CFileBuffer::VerifyXipSignature(PBYTE Buffer, DWORD DataSize)
{
	UCHAR digest[XC_DIGEST_LEN];

	//
	// Check the signature of this 64k block.
	//
	XCCalcDigest(Buffer, DataSize, digest);

	if (!m_XipSigs || (ULONG)m_nBlkCur >= m_XipSigs->SignatureCount ||
        memcmp (digest, ((PXIP_SIG)(m_XipSigs + 1))[m_nBlkCur].Signature,
        XIP_DIGEST_LENGTH))
    {
		TRACE(_T("File modified or corrupt!\n"));
		FileProtectionError();
	}
}

bool CFileBuffer::Seek(int nPos)
{
#if DBG
    static int nLastPos;
    nLastPos = nPos;
#endif

	int nBlock = nPos / FILE_BUFFER_SIZE;

	if (m_pbBuffer == NULL)
	{
        for (;;)
        {
            m_pbBuffer = (BYTE*)VirtualAlloc(NULL, FILE_BUFFER_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            if (m_pbBuffer)
            {
                break;
            }
            NewFailed(FILE_BUFFER_SIZE);
        }
		m_nBlkCur = -1;
	}

	if (nBlock != m_nBlkCur)
	{
        ASSERT(m_XipSigs == NULL || (ULONG)nBlock < m_XipSigs->SignatureCount);

		VERIFY(SetFilePointer(m_hFile, nBlock * FILE_BUFFER_SIZE, NULL, FILE_BEGIN) != ~0);
        m_nBlkCur = nBlock;

		DWORD dwRead;
		if (!ReadFile(m_hFile, m_pbBuffer, FILE_BUFFER_SIZE, &dwRead, NULL) || dwRead == 0)
        {
			return false;
        }

        VerifyXipSignature(m_pbBuffer, dwRead);
        ++m_nBlkCur;

		m_cbBuffer = (int)dwRead;
	}

	m_ibRead = nPos % FILE_BUFFER_SIZE;

	return true;
}

int CFileBuffer::Read(void* pv, int cb)
{
	if (m_pbBuffer == NULL)
	{
        for (;;)
        {
    		m_pbBuffer = (BYTE*)VirtualAlloc(NULL, FILE_BUFFER_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            if (m_pbBuffer)
            {
                break;
            }
            NewFailed(FILE_BUFFER_SIZE);
        }
	}

	int cbTotalRead = 0;
	int cbRead = 0;
	BYTE* pb = (BYTE*)pv;

	while (cb > 0)
	{
		if (m_ibRead < m_cbBuffer)
		{
			cbRead = m_cbBuffer - m_ibRead;
			if (cbRead > cb)
				cbRead = cb;

			CopyMemory(pb, m_pbBuffer + m_ibRead, cbRead);

			pb += cbRead;
			cb -= cbRead;
			ASSERT(cb >= 0);

			m_ibRead += cbRead;
			cbTotalRead += cbRead;
		}

		if (m_ibRead == m_cbBuffer)
		{
			DWORD dwRead = 0;
			if (!ReadFile(m_hFile, m_pbBuffer, FILE_BUFFER_SIZE, &dwRead, NULL))
            {
                ASSERT(FALSE && "Unable to read from XIP!");
                FileProtectionError();
                return -1;
            }

            if (dwRead == 0)
            {
                return -1;
            }
				
            VerifyXipSignature(m_pbBuffer, dwRead);
            ++m_nBlkCur;

			m_cbBuffer = (int)dwRead;
			m_ibRead = 0;
		}
	}

	return cbTotalRead;
}

CXipFile c_rgXipFile[20];
int c_nXipFileCount = 0;

CXipFile* LoadXIP(const TCHAR* szURL, bool bSync/*=false*/)
{
	TCHAR szBuf [MAX_PATH];

    if (szURL[0] && szURL[1] != ':')
    {
        // REVIEW: all xip files must be on y:\ if szURL is relative
        _tcscpy(szBuf, _T("y:/"));
    }
    else
    {
        szBuf[0] = 0;
    }

    _tcscat(szBuf, szURL);

	{
		char szDirPath [MAX_PATH];
		CleanFilePath(szDirPath, szBuf);
		char* pch = strrchr(szDirPath, '.');
		ASSERT(pch != NULL);
		*pch = 0;

		for (int i = 0; i < c_nXipFileCount; i += 1)
		{
			if (_stricmp(szDirPath, c_rgXipFile[i].m_szDirPath) == 0)
			{
//				TRACE(_T("\002XIP %s is already loaded!\n"), szURL);
				
				c_rgXipFile[i].m_cacheTime = XAppGetNow();
				if (c_rgXipFile[i].m_bLoaded && c_rgXipFile[i].m_nVertexBufferCount > 0 && c_rgXipFile[i].m_rgMeshBuffer[0].m_pVertexBuffer == NULL)
					c_rgXipFile[i].ReloadMeshBuffers();

				return &c_rgXipFile[i];
			}
		}
	}

//	TRACE(_T("\003LoadXIP: %s\n"), szURL);

	ASSERT(c_nXipFileCount < countof(c_rgXipFile));
	CXipFile* pXipFile = &c_rgXipFile[c_nXipFileCount];

	if (!pXipFile->Open(szBuf))
    {
		return NULL;
    }

	c_nXipFileCount += 1;

	if (bSync)
	{
		pXipFile->Load();
	}
	else
	{
		DWORD dwThreadID;
		HANDLE hThread = CreateThread(NULL, 0, CXipFile::StartLoadThread, pXipFile, 0, &dwThreadID);
		if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            CXipFile::StartLoadThread(pXipFile);
        }
	}

	return pXipFile;
}

bool FindInXIPAndDetach(const TCHAR* szURL, BYTE*& pbContent, DWORD& cbContent)
{
	char szFilePath [MAX_PATH];
	CleanFilePath(szFilePath, szURL);

	for (int i = c_nXipFileCount - 1; i >= 0; i -= 1)
	{
		if (c_rgXipFile[i].m_bLocked || !c_rgXipFile[i].m_bLoaded)
			continue;

		int nObject = c_rgXipFile[i].Find(szFilePath);
		if (nObject >= 0 && c_rgXipFile[i].m_objects[nObject] != NULL)
		{
			pbContent = (BYTE*)c_rgXipFile[i].m_objects[nObject];
			cbContent = c_rgXipFile[i].m_filedata[nObject].m_dwSize;
			c_rgXipFile[i].m_objects[nObject] = NULL;
			return true;
		}
	}

	return false;
}

void* FindObjectInXIP(const TCHAR* szURL, const TCHAR* szFilename, int nType/*=-1*/)
{
	char szFilePath [MAX_PATH];
	CleanFilePath(szFilePath, szURL);

	for (int i = c_nXipFileCount - 1; i >= 0; i -= 1)
	{
		if (c_rgXipFile[i].m_bLocked || !c_rgXipFile[i].m_bLoaded)
        {
			continue;
        }

		if(i == 0 && nType == XIP_TYPE_TEXTURE)
		{
			TCHAR szBuf [MAX_PATH];
			TCHAR szBufName [MAX_PATH];
			_tcscpy(szBufName, szFilename);
#ifdef COOL_XDASH
			_tcscpy(_tcsrchr(szBufName, '.') + 1, _T("xbx.cool"));
#else
			_tcscpy(_tcsrchr(szBufName, '.') + 1, _T("xbx"));
#endif
			_tcscpy(szBuf, theApp.m_szAppDir);
			_tcscat(szBuf, szBufName);
			CleanFilePath(szFilePath, szBuf);
			void* pObject = c_rgXipFile[i].FindObject(szFilePath, nType);

			if (pObject != NULL)
				return pObject;
		}
		else
		{
			void* pObject = c_rgXipFile[i].FindObject(szFilePath, nType);

			if (pObject != NULL)
				return pObject;
		}
	}

	return NULL;
}

////////////////////////////////////////////////////////////////////////////

CXipFile::CXipFile()
{
	m_szXipFileName = NULL;
	m_szDirPath = NULL;
	m_bLoaded = false;
	m_bLocked = false;
	m_bReloading = false;

	ZeroMemory(m_rgMeshBuffer, sizeof (m_rgMeshBuffer));
	m_nVertexBufferCount = 0;
	m_nIndexBufferCount = 0;
}

CXipFile::~CXipFile()
{
	delete [] m_szXipFileName;
	m_szXipFileName = NULL;

	delete [] m_szDirPath;
	m_szDirPath = NULL;

	delete [] m_filedata;
	m_filedata = NULL;

	delete [] m_directory;
	m_directory = NULL;

	delete [] m_names;
	m_names = NULL;

	DeleteMeshBuffers();

	ZeroMemory(m_rgMeshBuffer, sizeof (m_rgMeshBuffer));
	m_nVertexBufferCount = 0;
	m_nIndexBufferCount = 0;
}

bool CXipFile::Open(const TCHAR* szXipFileName)
{
/*
	HANDLE hFile;
	if ((hFile = XAppCreateFile(szXipFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL)) == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001CXipFile::Open (%s) failed %d\n"), szXipFileName, GetLastError());
		return false;
	}

	m_file.SetFile(hFile);
*/
	m_szXipFileName = new TCHAR [_tcslen(szXipFileName) + 1];
	_tcscpy(m_szXipFileName, szXipFileName);

	char szDirPath [MAX_PATH];
	CleanFilePath(szDirPath, szXipFileName);

	char* pch = strrchr(szDirPath, '.');
	ASSERT(pch != NULL);
	*pch = 0;

	pch = strrchr(szDirPath, '\\');
	if (pch == NULL)
		pch = szDirPath;
	else
		pch += 1;

	if (_stricmp(pch, "default") == 0)
	{
		if (pch > szDirPath)
			pch -= 1;
		*pch = 0;
	}

	m_szDirPath = new char [strlen(szDirPath) + 1];
	strcpy(m_szDirPath, szDirPath);

	return true;
}

DWORD CALLBACK CXipFile::StartLoadThread(LPVOID pvContext)
{
	START_PROFILE();
	CXipFile *pThis = (CXipFile*)pvContext;

	if (pThis->m_bReloading)
		pThis->ReloadMeshBuffers();
	else
		VERIFY(pThis->Load());

	END_PROFILE();
	
	return 0;
}

bool CXipFile::Load()
{
#ifdef _DEBUG
	TCHAR szDirPath [MAX_PATH];
	Unicode(szDirPath, m_szDirPath, MAX_PATH);
	DWORD ticks = GetTickCount ();
#endif

	HANDLE hFile;
	XCALCSIG_SIGNATURE sig;
	

	if ((hFile = XAppCreateFile(m_szXipFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL)) == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001CXipFile::Open (%s) failed %d\n"), m_szXipFileName, GetLastError());
		return false;
	}



	m_file.SetFile(m_szXipFileName, hFile);
	if (!m_file.Read(&m_header, sizeof (XIPHEADER)))
		return false;

	if (m_header.m_dwMagic != XIP_MAGIC)
	{
#ifdef _DEBUG
		TRACE(_T("\001CXipFile::Open (%s.xip) not a valid XIP file!\n"), szDirPath);
#endif
		return false;
	}

	m_filedata = new FILEDATA [m_header.m_wFileCount];
	if (!m_file.Read(m_filedata, m_header.m_wFileCount * sizeof (FILEDATA)))
		return false;
	m_directory = new FILENAME [m_header.m_wNameCount];
	if (!m_file.Read(m_directory, m_header.m_wNameCount * sizeof (FILENAME)))
		return false;


	{
		int cbNames = m_header.m_dwDataStart - (sizeof (XIPHEADER) + m_header.m_wFileCount * sizeof (FILEDATA) + m_header.m_wNameCount * sizeof (FILENAME));
		m_names = new char [cbNames];
		if (!m_file.Read(m_names, cbNames))
			return false;


	}

	ASSERT(GetFileSize(m_file.m_hFile, NULL) == m_header.m_dwDataStart + m_header.m_dwDataSize);

	CreateObjects();

	m_bLoaded = true;

	return true;
}

LPDIRECT3DTEXTURE8 ReadTexture(CFileBuffer& file, int nBytes)
{
	BYTE* pbContent = new BYTE[nBytes];
	file.Read(pbContent, nBytes);

	const XPR_HEADER* pxprh = (const XPR_HEADER*)pbContent;
	if (pxprh->dwMagic == XPR_MAGIC_VALUE)
	{
		int cbHeaders = pxprh->dwHeaderSize - sizeof (XPR_HEADER);
		int cbData = pxprh->dwTotalSize - pxprh->dwHeaderSize;

		IDirect3DTexture8* pTexture = (IDirect3DTexture8*)XAppD3D_AllocNoncontiguousMemory(sizeof (D3DBaseTexture));
		if (pTexture == NULL)
		{
			TRACE(_T("Not enough memory to load XBX image file!\n"));
			return NULL;
		}

		CopyMemory(pTexture, pbContent + sizeof (XPR_HEADER), sizeof (IDirect3DTexture8));

		BYTE* pbData = (BYTE*)XAppD3D_AllocContiguousMemory(cbData, D3DTEXTURE_ALIGNMENT);
		if (pbData == NULL)
		{
			// TODO: Leaking pTexture!
			TRACE(_T("Not enough memory to load XBX image file!\n"));
			return NULL;
		}

		CopyMemory(pbData, pbContent + pxprh->dwHeaderSize, cbData);
		D3D_CopyContiguousMemoryToVideo(pbData);

		pTexture->Data = NULL;
		pTexture->Register(pbData);
		pTexture->Common |= D3DCOMMON_D3DCREATED;

		return pTexture;
	}
	else
	{
		ALERT(_T("Unable to load XBX file for scene!"));
		return NULL;
	}
}

void CXipFile::CreateObjects()
{
	m_bLocked = true;

	m_objects = new void* [m_header.m_wFileCount];
	ZeroMemory(m_objects, sizeof (void*) * m_header.m_wFileCount);

	for (UINT i = 0; i < m_header.m_wFileCount; i += 1)
	{
		switch (m_filedata[i].m_dwType)
		{
		default:
			m_objects[i] = XAppAllocMemory(m_filedata[i].m_dwSize);
			m_file.Read(m_objects[i], m_filedata[i].m_dwSize);			
			
			break;

		case XIP_TYPE_MESH:
			ASSERT(FALSE); // Obsolete...
//			m_objects[i] = CreateMesh(m_hFile);
			break;

		case XIP_TYPE_MESH_REFERENCE:
			{
				CMeshRef* pMeshRef = new CMeshRef;
				pMeshRef->m_pXipFile = this;
				pMeshRef->m_nMeshBuffer = m_filedata[i].m_dwDataOffset >> 24;
				ASSERT(pMeshRef->m_nMeshBuffer < MAX_MESHBUFFER);
				pMeshRef->m_nFirstIndex = m_filedata[i].m_dwDataOffset & 0x00ffffff;
				pMeshRef->m_nPrimitiveCount = m_filedata[i].m_dwSize;
				m_objects[i] = pMeshRef;
			}
			break;

		case XIP_TYPE_TEXTURE:
			m_objects[i] = ReadTexture(m_file, m_filedata[i].m_dwSize);
			
			break;

		case XIP_TYPE_INDEXBUFFER:
			ASSERT(m_nIndexBufferCount < MAX_MESHBUFFER);
			ReadIndexBuffer(i, m_nVertexBufferCount);
			m_nIndexBufferCount += 1;
			break;

		case XIP_TYPE_VERTEXBUFFER:
			ASSERT(m_nVertexBufferCount < MAX_MESHBUFFER);
			ReadVertexBuffer(i, m_nVertexBufferCount);
			m_nVertexBufferCount += 1;
			break;
		}
	}

	ASSERT(m_nVertexBufferCount == m_nIndexBufferCount);

	m_bLocked = false;
}

struct SEARCHXIP
{
	SEARCHXIP(CXipFile* pXipFile, const char* szFind)
	{
		m_names = pXipFile->m_names;
		m_szFind = szFind;
	}

	const char* m_names;
	const char* m_szFind;
};

static int __cdecl SearchXipCompare(const void *elem1, const void *elem2)
{
	const SEARCHXIP* pSearch = (const SEARCHXIP*)elem1;
	const FILENAME* pName = (const FILENAME*)elem2;
	return _stricmp(pSearch->m_szFind, pSearch->m_names + pName->m_wNameOffset);
}

int CXipFile::Find(const char* szURL)
{
	int cchDirPath = strlen(m_szDirPath);

    if (_strnicmp(szURL, m_szDirPath, cchDirPath) != 0)
        return -1;

    const char* szFile = szURL + cchDirPath;

    if (*szFile != '\\')
        return -1;

    szFile += 1;

	SEARCHXIP searchxip(this, szFile);
	FILENAME* pFileName = (FILENAME*)bsearch(&searchxip, m_directory, m_header.m_wNameCount, sizeof (FILENAME), SearchXipCompare);

	if (pFileName == NULL)
		return -1;

	return m_directory[(int)((BYTE*)pFileName - (BYTE*)m_directory) / sizeof (FILENAME)].m_wFileDataIndex;
}

void* CXipFile::FindObject(const char* szURL, int nType/*=-1*/)
{
	int nObject = Find(szURL);
    if (nObject == -1)
	{
        return NULL;
	}

    if (nType != -1 && m_filedata[nObject].m_dwType != (DWORD)nType)
	{
        return NULL;
	}

    //
    //  Bug 7092 - AddRef Textures when we give them out
    //             such that they don't get deleted
    //             when the caller is done with them.
    if(XIP_TYPE_TEXTURE == nType)
    {
        ((LPDIRECT3DTEXTURE8)m_objects[nObject])->AddRef();
    }

    return m_objects[nObject];
}

void CXipFile::DeleteMeshBuffers()
{
	ASSERT(!m_bLocked); // thread synchronization issue!

//#ifdef _DEBUG
//	TCHAR szDirPath [MAX_PATH];
//	Unicode(szDirPath, m_szDirPath, MAX_PATH);
//	TRACE(_T("\002DeleteMeshBuffers: %s.xip\n"), szDirPath);
//#endif

	for (int i = 0; i < MAX_MESHBUFFER; i += 1)
	{
		if (m_rgMeshBuffer[i].m_pVertexBuffer != NULL)
		{
            m_rgMeshBuffer[i].m_pVertexBuffer->Release();
            m_rgMeshBuffer[i].m_pVertexBuffer = NULL;
		}

		if (m_rgMeshBuffer[i].m_pIndexBuffer != NULL)
		{
            m_rgMeshBuffer[i].m_pIndexBuffer->Release();
            m_rgMeshBuffer[i].m_pIndexBuffer = NULL;
		}
	}
}

bool CleanupMeshCache()
{
//	TRACE(_T("\002CleanupMeshCache\n"));

	CXipFile* pOldOne = NULL;

	for (int i = 0; i < c_nXipFileCount; i += 1)
	{
//#ifdef _DEBUG
//		TCHAR szDirPath [MAX_PATH];
//		Unicode(szDirPath, c_rgXipFile[i].m_szDirPath, MAX_PATH);
//		TRACE(_T("\002\tchecking: %s.xip (%f)\n"), szDirPath, c_rgXipFile[i].m_cacheTime);
//#endif
		if (c_rgXipFile[i].m_bLocked)
		{
//			TRACE(_T("\002\t\tlocked\n"));
			continue;
		}

		if (!c_rgXipFile[i].m_bLoaded)
		{
//			TRACE(_T("\002\t\tnot loaded\n"));
			continue;
		}

		if (c_rgXipFile[i].m_nVertexBufferCount == 0)
		{
//			TRACE(_T("\002\t\tno vertex buffers\n"));
			continue;
		}

		if (c_rgXipFile[i].m_rgMeshBuffer[0].m_pVertexBuffer == NULL)
		{
//			TRACE(_T("\002\t\tunloaded\n"));
			continue;
		}

		if (pOldOne == NULL || c_rgXipFile[i].m_cacheTime < pOldOne->m_cacheTime)
			pOldOne = &c_rgXipFile[i];
	}

	if (pOldOne == NULL)
		return false;

	pOldOne->DeleteMeshBuffers();

	return true;
}

void CXipFile::ReadIndexBuffer(int nFileIndex, int nIndexBuffer)
{
	CMeshBuffer* pMeshBuffer = &m_rgMeshBuffer[nIndexBuffer];

	XAppCreateIndexBuffer(m_filedata[nFileIndex].m_dwSize, D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &pMeshBuffer->m_pIndexBuffer);

	BYTE* indices;
#ifdef _XBOX
	const DWORD dwLockFlags = D3DLOCK_DISCARD | D3DLOCK_NOFLUSH;
#else
	const DWORD dwLockFlags = D3DLOCK_DISCARD;
#endif
	VERIFYHR(pMeshBuffer->m_pIndexBuffer->Lock(0, m_filedata[nFileIndex].m_dwSize, (BYTE**)&indices, dwLockFlags));
	m_file.Read(indices, m_filedata[nFileIndex].m_dwSize);
	VERIFYHR(pMeshBuffer->m_pIndexBuffer->Unlock());

	pMeshBuffer->m_nIndexCount = m_filedata[nFileIndex].m_dwSize /  sizeof (WORD);
}

void CXipFile::ReadVertexBuffer(int nFileIndex, int nVertexBuffer)
{
	CMeshBuffer* pMeshBuffer = &m_rgMeshBuffer[nVertexBuffer];

	int nVertexCount;
	DWORD fvf;

	m_file.Read(&nVertexCount, sizeof (int));
	m_file.Read(&fvf, sizeof (DWORD));
	
	pMeshBuffer->m_nVertexStride = (m_filedata[nFileIndex].m_dwSize - 8) / nVertexCount;

	XAppCreateVertexBuffer(m_filedata[nFileIndex].m_dwSize - 8, D3DUSAGE_DYNAMIC, fvf, D3DPOOL_DEFAULT, &pMeshBuffer->m_pVertexBuffer);

	
	BYTE* verts;
#ifdef _XBOX
	const DWORD dwLockFlags = D3DLOCK_DISCARD | D3DLOCK_NOFLUSH;
#else
	const DWORD dwLockFlags = D3DLOCK_DISCARD;
#endif
	VERIFYHR(pMeshBuffer->m_pVertexBuffer->Lock(0, 0, &verts, dwLockFlags));
	m_file.Read(verts, m_filedata[nFileIndex].m_dwSize - 8);
	VERIFYHR(pMeshBuffer->m_pVertexBuffer->Unlock());

	pMeshBuffer->m_fvf = fvf;
	pMeshBuffer->m_nVertexCount = nVertexCount;
}

void CXipFile::ReloadMeshBuffers()
{
//#ifdef _DEBUG
//	TCHAR szDirPath [MAX_PATH];
//	Unicode(szDirPath, m_szDirPath, MAX_PATH);
//	TRACE(_T("\002ReloadMeshBuffers: %s.xip\n"), szDirPath);
//#endif

	ASSERT(!m_bLocked);
	m_bLocked = true;

	int nIndexBuffer = 0;
	int nVertexBuffer = 0;

	for (UINT i = 0; i < m_header.m_wFileCount; i += 1)
	{
		switch (m_filedata[i].m_dwType)
		{
		case XIP_TYPE_INDEXBUFFER:
			ASSERT(nIndexBuffer < m_nIndexBufferCount);
			m_file.Seek(m_header.m_dwDataStart + m_filedata[i].m_dwDataOffset);
			ReadIndexBuffer(i, nIndexBuffer);
			nIndexBuffer += 1;
			break;

		case XIP_TYPE_VERTEXBUFFER:
			ASSERT(nVertexBuffer < m_nVertexBufferCount);
			m_file.Seek(m_header.m_dwDataStart + m_filedata[i].m_dwDataOffset);
			ReadVertexBuffer(i, nVertexBuffer);
			nVertexBuffer += 1;
			break;
		}
	}

	ASSERT(nIndexBuffer == m_nIndexBufferCount);
	ASSERT(nVertexBuffer == m_nVertexBufferCount);

	m_bLocked = false;
	m_bReloading = false;
}

void CXipFile::Reload()
{
	ASSERT(!m_bReloading);

	m_bReloading = true;
	DWORD dwThreadID;
	HANDLE hThread = CreateThread(NULL, 0, CXipFile::StartLoadThread, this, 0, &dwThreadID);
    if (hThread)
    {
        CloseHandle(hThread);
    }
    else
    {
        StartLoadThread(this);
    }
}

bool CXipFile::IsUnloaded() const
{
	if (!m_bLoaded)
		return false;

	if (m_bReloading)
		return false;

	if (m_nVertexBufferCount == 0)
		return false;

	if (m_rgMeshBuffer[0].m_pVertexBuffer != NULL)
		return false;

	return true;
}

bool CXipFile::IsReloading() const
{
	return m_bReloading;
}

void CMeshRef::Render(bool bSetFVF/*=true*/)
{
	ASSERT(m_nMeshBuffer < m_pXipFile->m_nVertexBufferCount);
	CMeshBuffer* pMeshBuffer = &m_pXipFile->m_rgMeshBuffer[m_nMeshBuffer];

	m_pXipFile->m_cacheTime = XAppGetNow();

	if (m_pXipFile->IsReloading())
		return;

	if (pMeshBuffer->m_pVertexBuffer == NULL)
	{
		m_pXipFile->Reload();
		return;
	}

	if (bSetFVF)
		XAppSetVertexShader(GetFixedFunctionShader(pMeshBuffer->m_fvf));

	if (m_nPrimitiveCount > 800 && !g_bEdgeAntialiasOverride) {
		XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
		XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
		//XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN);
	}

#ifdef COOL_XDASH

    if (g_uMeshRef++ == 0) {

        // Turn off breathing for the background sphere in the ugliest way imaginable...

        D3DXMATRIX matPosition, matView, mat, worldView;
	    D3DXMatrixAffineTransformation(&matPosition, 1.0f, NULL, &theCamera.m_orientation, &theCamera.m_position);
	    D3DXMatrixInverse(&matView, NULL, &matPosition);
	    matView._31 = -matView._31;
	    matView._32 = -matView._32;
	    matView._33 = -matView._33;
	    matView._34 = -matView._34;

	    D3DXMatrixMultiply(&worldView, XAppGetWorld(), &matView);

	    // World/View/Projection
	    D3DXMatrixMultiply(&mat, &worldView, &g_matProjection);
	    D3DXMatrixTranspose(&mat, &mat);
	    XAppSetVertexShaderConstant(0, &mat(0,0), 4);

	    // Position Transform
	    D3DXMatrixTranspose(&mat, &worldView);
	    XAppSetVertexShaderConstant(10, &mat(0,0), 4);

	    // Normal Transform
	    D3DXMatrixInverse(&mat, NULL, &worldView);
	    XAppSetVertexShaderConstant(5, &mat(0,0), 4);

	    D3DXVECTOR4 lightDir(1.0f, 1.0f, -1.0f, 0.0f);
	    D3DXVec4Normalize(&lightDir, &lightDir);
	    D3DXMatrixTranspose(&mat, &worldView);
	    D3DXVec3TransformNormal((D3DXVECTOR3*)&lightDir, (D3DXVECTOR3*)&lightDir, &mat);
	    D3DXVec4Normalize(&lightDir, &lightDir);
	    XAppSetVertexShaderConstant(4, &lightDir, 1);
    }

#endif

	XAppSetStreamSource(0, pMeshBuffer->m_pVertexBuffer, pMeshBuffer->m_nVertexStride);
	XAppSetIndices(pMeshBuffer->m_pIndexBuffer, 0);

	XAppDrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, pMeshBuffer->m_nVertexCount, m_nFirstIndex, m_nPrimitiveCount);
}

DWORD CMeshRef::GetFVF() const
{
	ASSERT(m_nMeshBuffer < m_pXipFile->m_nVertexBufferCount);
	return m_pXipFile->m_rgMeshBuffer[m_nMeshBuffer].m_fvf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\xip.h ===
#pragma once

#define XIP_MAGIC 0x30504958
#define XIP_DIGEST_LENGTH 20


struct XIPHEADER
{
	DWORD m_dwMagic;
	DWORD m_dwDataStart;
	WORD m_wFileCount;
	WORD m_wNameCount;
	DWORD m_dwDataSize;
};

struct FILEDATA
{
	DWORD m_dwDataOffset;
	DWORD m_dwSize;
	DWORD m_dwType;
	DWORD m_dwTimestamp;
};

struct FILENAME
{
	WORD m_wFileDataIndex;
	WORD m_wNameOffset;
};


typedef struct {

	UCHAR Signature[XIP_DIGEST_LENGTH];

} XIP_SIG, *PXIP_SIG;

typedef struct {

	WCHAR Name[MAX_PATH];
	UINT SignatureCount;

} XIP_PROTECTION, *PXIP_PROTECTION;



#define XIP_TYPE_GENERIC			0
#define XIP_TYPE_MESH				1
#define XIP_TYPE_TEXTURE			2
#define XIP_TYPE_WAVE				3
#define XIP_TYPE_MESH_REFERENCE		4 // m_dwDataOffset is MESHID; m_dwSize is nPrimitiveCount
#define XIP_TYPE_INDEXBUFFER		5
#define XIP_TYPE_VERTEXBUFFER		6

#ifndef BUILD_XIPSIGN

#define MAX_MESHBUFFER 10

struct CMeshBuffer
{
	DWORD m_fvf;
	int m_nVertexStride;
	int m_nVertexCount;
	int m_nIndexCount;
	IDirect3DVertexBuffer8* m_pVertexBuffer;
	IDirect3DIndexBuffer8* m_pIndexBuffer;
};

class CFileBuffer
{
public:
	CFileBuffer();
	~CFileBuffer();

	void SetFile(PCTSTR Name, HANDLE hFile);
	int Read(void* pv, int cb);
	bool Seek(int nPos);
	void FreeBuffer();
	void StartSignature (VOID);
	void EndSignature (XCALCSIG_SIGNATURE * Signature);



	HANDLE m_hFile;
	PXIP_PROTECTION m_XipSigs;
	BYTE* m_pbBuffer;
	int m_cbBuffer;
	int m_ibRead;
    int m_nBlkCur;
private:
    void VerifyXipSignature(PBYTE Buffer, DWORD DataSize);
};

class CXipFile
{
public:
	CXipFile();
	~CXipFile();

	bool Open(const TCHAR* szXipFileName);
	void Reload();
	int Find(const char* szURL);
//	bool Find(const char* szURL, BYTE*& pbContent, DWORD& cbContent);
	void* FindObject(const char* szURL, int nType = -1);

	char* m_szDirPath;
	TCHAR* m_szXipFileName;

	XIPHEADER m_header;
	FILEDATA* m_filedata;
	FILENAME* m_directory;
	char* m_names;

	void** m_objects;
	bool m_bLoaded;

	CMeshBuffer m_rgMeshBuffer [MAX_MESHBUFFER];
	int m_nVertexBufferCount;
	int m_nIndexBufferCount;

	void DeleteMeshBuffers();

	XTIME m_cacheTime;

	bool m_bLocked;

	bool IsUnloaded() const;
	bool IsReloading() const;
	inline bool IsReady() const
		{ return m_bLoaded && !m_bReloading; }

protected:
	CFileBuffer m_file;
	bool m_bReloading;

	bool Load();
	void CreateObjects();
	void ReloadMeshBuffers();
	void ReadIndexBuffer(int nFileIndex, int nIndexBuffer);
	void ReadVertexBuffer(int nFileIndex, int nVertexBuffer);

	static DWORD CALLBACK StartLoadThread(LPVOID pvContext);
	friend CXipFile* LoadXIP(const TCHAR* szURL, bool bSync);
};

extern CXipFile* LoadXIP(const TCHAR* szURL, bool bSync = false);
extern bool FindInXIPAndDetach(const TCHAR* szURL, BYTE*& pbContent, DWORD& cbContent);
extern void* FindObjectInXIP(const TCHAR* szURL, const TCHAR* szFilename, int nType = -1);

#endif // BUILD_XIPSIGN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ddk\Ntddcdrm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntddcdrm.h

Abstract:

    This module contains structures and definitions
    associated with CDROM IOCTls.

Author:

    Mike Glass

Revision History:

--*/

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_CDROM_BASE                 FILE_DEVICE_CD_ROM

#define IOCTL_CDROM_UNLOAD_DRIVER        CTL_CODE(IOCTL_CDROM_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// CDROM Audio Device Control Functions
//

#define IOCTL_CDROM_READ_TOC         CTL_CODE(IOCTL_CDROM_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_CONTROL      CTL_CODE(IOCTL_CDROM_BASE, 0x000D, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_PLAY_AUDIO_MSF   CTL_CODE(IOCTL_CDROM_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SEEK_AUDIO_MSF   CTL_CODE(IOCTL_CDROM_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_STOP_AUDIO       CTL_CODE(IOCTL_CDROM_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_PAUSE_AUDIO      CTL_CODE(IOCTL_CDROM_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RESUME_AUDIO     CTL_CODE(IOCTL_CDROM_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_VOLUME       CTL_CODE(IOCTL_CDROM_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_VOLUME       CTL_CODE(IOCTL_CDROM_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_READ_Q_CHANNEL   CTL_CODE(IOCTL_CDROM_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_LAST_SESSION CTL_CODE(IOCTL_CDROM_BASE, 0x000E, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RAW_READ         CTL_CODE(IOCTL_CDROM_BASE, 0x000F, METHOD_OUT_DIRECT,  FILE_READ_ACCESS)
#define IOCTL_CDROM_DISK_TYPE        CTL_CODE(IOCTL_CDROM_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CDROM_GET_DRIVE_GEOMETRY CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future with the IOCTL_STORAGE
// codes included below
//

#define IOCTL_CDROM_CHECK_VERIFY    CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_MEDIA_REMOVAL   CTL_CODE(IOCTL_CDROM_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_EJECT_MEDIA     CTL_CODE(IOCTL_CDROM_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_LOAD_MEDIA      CTL_CODE(IOCTL_CDROM_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RESERVE         CTL_CODE(IOCTL_CDROM_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RELEASE         CTL_CODE(IOCTL_CDROM_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_FIND_NEW_DEVICES CTL_CODE(IOCTL_CDROM_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctl definitions
//

#include "ntddstor.h"

//
// The following device control code is for the SIMBAD simulated bad
// sector facility. See SIMBAD.H in this directory for related structures.
//

#define IOCTL_CDROM_SIMBAD        CTL_CODE(IOCTL_CDROM_BASE, 0x1003, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Maximum CD Rom size
//

#define MAXIMUM_NUMBER_TRACKS 100
#define MAXIMUM_CDROM_SIZE 804

//
// CD ROM Table OF Contents (TOC)
//
// Format 0 - Get table of contents
//

typedef struct _TRACK_DATA {
    UCHAR Reserved;
    UCHAR Control : 4;
    UCHAR Adr : 4;
    UCHAR TrackNumber;
    UCHAR Reserved1;
    UCHAR Address[4];
} TRACK_DATA, *PTRACK_DATA;

typedef struct _CDROM_TOC {

    //
    // Header
    //

    UCHAR Length[2];
    UCHAR FirstTrack;
    UCHAR LastTrack;

    //
    // Track data
    //

    TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
} CDROM_TOC, *PCDROM_TOC;

#define CDROM_TOC_SIZE sizeof(CDROM_TOC)

//
// Play audio starting at MSF and ending at MSF
//

typedef struct _CDROM_PLAY_AUDIO_MSF {
    UCHAR StartingM;
    UCHAR StartingS;
    UCHAR StartingF;
    UCHAR EndingM;
    UCHAR EndingS;
    UCHAR EndingF;
} CDROM_PLAY_AUDIO_MSF, *PCDROM_PLAY_AUDIO_MSF;

//
// Seek to MSF
//

typedef struct _CDROM_SEEK_AUDIO_MSF {
    UCHAR M;
    UCHAR S;
    UCHAR F;
} CDROM_SEEK_AUDIO_MSF, *PCDROM_SEEK_AUDIO_MSF;


//
//  Flags for the disk type
//

typedef struct _CDROM_DISK_DATA {

    ULONG DiskData;

} CDROM_DISK_DATA, *PCDROM_DISK_DATA;

#define CDROM_DISK_AUDIO_TRACK      (0x00000001)
#define CDROM_DISK_DATA_TRACK       (0x00000002)

//
// CD ROM Data Mode Codes, used with IOCTL_CDROM_READ_Q_CHANNEL
//

#define IOCTL_CDROM_SUB_Q_CHANNEL    0x00
#define IOCTL_CDROM_CURRENT_POSITION 0x01
#define IOCTL_CDROM_MEDIA_CATALOG    0x02
#define IOCTL_CDROM_TRACK_ISRC       0x03

typedef struct _CDROM_SUB_Q_DATA_FORMAT {
    UCHAR Format;
    UCHAR Track;
} CDROM_SUB_Q_DATA_FORMAT, *PCDROM_SUB_Q_DATA_FORMAT;


//
// CD ROM Sub-Q Channel Data Format
//

typedef struct _SUB_Q_HEADER {
    UCHAR Reserved;
    UCHAR AudioStatus;
    UCHAR DataLength[2];
} SUB_Q_HEADER, *PSUB_Q_HEADER;

typedef struct _SUB_Q_CURRENT_POSITION {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Control : 4;
    UCHAR ADR : 4;
    UCHAR TrackNumber;
    UCHAR IndexNumber;
    UCHAR AbsoluteAddress[4];
    UCHAR TrackRelativeAddress[4];
} SUB_Q_CURRENT_POSITION, *PSUB_Q_CURRENT_POSITION;

typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Reserved[3];
    UCHAR Reserved1 : 7;
    UCHAR Mcval : 1;
    UCHAR MediaCatalog[15];
} SUB_Q_MEDIA_CATALOG_NUMBER, *PSUB_Q_MEDIA_CATALOG_NUMBER;

typedef struct _SUB_Q_TRACK_ISRC {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Reserved0;
    UCHAR Track;
    UCHAR Reserved1;
    UCHAR Reserved2 : 7;
    UCHAR Tcval : 1;
    UCHAR TrackIsrc[15];
} SUB_Q_TRACK_ISRC, *PSUB_Q_TRACK_ISRC;

typedef union _SUB_Q_CHANNEL_DATA {
    SUB_Q_CURRENT_POSITION CurrentPosition;
    SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog;
    SUB_Q_TRACK_ISRC TrackIsrc;
} SUB_Q_CHANNEL_DATA, *PSUB_Q_CHANNEL_DATA;

//
// Audio Status Codes
//

#define AUDIO_STATUS_NOT_SUPPORTED  0x00
#define AUDIO_STATUS_IN_PROGRESS    0x11
#define AUDIO_STATUS_PAUSED         0x12
#define AUDIO_STATUS_PLAY_COMPLETE  0x13
#define AUDIO_STATUS_PLAY_ERROR     0x14
#define AUDIO_STATUS_NO_STATUS      0x15

//
// ADR Sub-channel Q Field
//

#define ADR_NO_MODE_INFORMATION     0x0
#define ADR_ENCODES_CURRENT_POSITION 0x1
#define ADR_ENCODES_MEDIA_CATALOG   0x2
#define ADR_ENCODES_ISRC            0x3

//
// Sub-channel Q Control Bits
//

#define AUDIO_WITH_PREEMPHASIS      0x0
#define DIGITAL_COPY_PERMITTED      0x2
#define AUDIO_DATA_TRACK            0x4
#define TWO_FOUR_CHANNEL_AUDIO      0x8

//
// Get Audio control parameters
//

typedef struct _CDROM_AUDIO_CONTROL {
    UCHAR LbaFormat;
    USHORT LogicalBlocksPerSecond;
} CDROM_AUDIO_CONTROL, *PCDROM_AUDIO_CONTROL;

//
// Volume control - Volume takes a value between 1 and 0xFF.
// SCSI-II CDROM audio suppports up to 4 audio ports with
// Independent volume control.
//

typedef struct _VOLUME_CONTROL {
    UCHAR PortVolume[4];
} VOLUME_CONTROL, *PVOLUME_CONTROL;

typedef enum _TRACK_MODE_TYPE {
    YellowMode2,
    XAForm2,
    CDDA
} TRACK_MODE_TYPE, *PTRACK_MODE_TYPE;

//
// Passed to cdrom to describe the raw read, ie. Mode 2, Form 2, CDDA...
//

typedef struct __RAW_READ_INFO {
    LARGE_INTEGER DiskOffset;
    ULONG    SectorCount;
    TRACK_MODE_TYPE TrackMode;
} RAW_READ_INFO, *PRAW_READ_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ddk\NTDDSTOR.H ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntddstor.h

Abstract:

    This is the include file that defines all common constants and types
    accessing the storage class drivers

Author:

    Peter Wieland 19-Jun-1996

Revision History:

--*/

// begin_winioctl

#ifndef _NTDDSTOR_H_
#define _NTDDSTOR_H_

// end_winioctl

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_STORAGE_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile

// begin_winioctl

//
// IoControlCode values for disk devices.
//

#define IOCTL_STORAGE_BASE                FILE_DEVICE_MASS_STORAGE

// end_winioctl

// begin_winioctl
//
// The following device control codes are common for all class drivers.  They
// should be used in place of the older IOCTL_DISK, IOCTL_CDROM and IOCTL_TAPE
// common codes
//

#define IOCTL_STORAGE_CHECK_VERIFY     CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_MEDIA_REMOVAL    CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECT_MEDIA      CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA       CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RESERVE          CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RELEASE          CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_FIND_NEW_DEVICES CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_STORAGE_MEDIA_REMOVAL disables the mechanism
// on a storage device that ejects media. This function
// may or may not be supported on storage devices that
// support removable media.
//
// TRUE means prevent media from being removed.
// FALSE means allow media removal.
//

typedef struct _PREVENT_MEDIA_REMOVAL {
    BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;

#endif // _NTDDSTOR_H_
// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ddk\NTDDDISK.H ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ntdddisk.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Disk device.

Author:

    Steve Wood (stevewo) 27-May-1990

Revision History:

--*/

#ifndef _NTDDDISK_H_
#define _NTDDDISK_H_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_DISK_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile

// begin_winioctl

//
// IoControlCode values for disk devices.
//

#define IOCTL_DISK_BASE                 FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY   CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY               CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS        CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS      CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE          CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE          CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING              CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS_EX     CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_HISTOGRAM_STRUCTURE  CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_DATA       CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_RESET      CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_STRUCTURE    CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_DATA         CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if(_WIN32_WINNT >= 0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER    CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL support for SMART drive fault prediction.
//

#define SMART_GET_VERSION               CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA            CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */


// end_winioctl

//
// Internal disk driver device controls to maintain the verify status bit
// for the device object.
//

#define IOCTL_DISK_INTERNAL_SET_VERIFY   CTL_CODE(IOCTL_DISK_BASE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_CLEAR_VERIFY CTL_CODE(IOCTL_DISK_BASE, 0x0101, METHOD_NEITHER, FILE_ANY_ACCESS)

// begin_winioctl
//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future by equivalent
// IOCTL_STORAGE codes
//

#define IOCTL_DISK_CHECK_VERIFY     CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL    CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA      CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA       CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE          CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE          CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_GET_MEDIA_TYPES CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

// end_winioctl

//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

// begin_winioctl
//
// Define the partition types returnable by known disk drivers.
//

#define PARTITION_ENTRY_UNUSED          0x00      // Entry unused
#define PARTITION_FAT_12                0x01      // 12-bit FAT entries
#define PARTITION_XENIX_1               0x02      // Xenix
#define PARTITION_XENIX_2               0x03      // Xenix
#define PARTITION_FAT_16                0x04      // 16-bit FAT entries
#define PARTITION_EXTENDED              0x05      // Extended partition entry
#define PARTITION_HUGE                  0x06      // Huge partition MS-DOS V4
#define PARTITION_IFS                   0x07      // IFS Partition
#define PARTITION_FAT32                 0x0B      // FAT32
#define PARTITION_FAT32_XINT13          0x0C      // FAT32 using extended int13 services
#define PARTITION_XINT13                0x0E      // Win95 partition using extended int13 services
#define PARTITION_XINT13_EXTENDED       0x0F      // Same as type 5 but uses extended int13 services
#define PARTITION_PREP                  0x41      // PowerPC Reference Platform (PReP) Boot Partition
#define PARTITION_UNIX                  0x63      // Unix

#define VALID_NTFT                      0xC0      // NTFT uses high order bits

//
// The high bit of the partition type code indicates that a partition
// is part of an NTFT mirror or striped array.
//

#define PARTITION_NTFT                  0x80     // NTFT partition

//
// The following macro is used to determine which partitions should be
// assigned drive letters.
//

//++
//
// BOOLEAN
// IsRecognizedPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partitions drive letters
//     should be assigned.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is recognized,
//     otherwise FALSE is returned.
//
//--

#define IsRecognizedPartition( PartitionType ) (       \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT_12)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT_16)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_IFS)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_HUGE)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT32)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13)) ||  \
     ((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0) == PARTITION_XINT13)) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT_12) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT_16) ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_IFS)    ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_HUGE)    ||  \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT32)  || \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_FAT32_XINT13) || \
     ((PartitionType & ~PARTITION_NTFT) == PARTITION_XINT13) )

//++
//
// BOOLEAN
// IsContainerPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partition types are actually
//     containers for other partitions (ie, extended partitions).
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is a container,
//     otherwise FALSE is returned.
//
//--

#define IsContainerPartition( PartitionType ) \
    ((PartitionType == PARTITION_EXTENDED) || (PartitionType == PARTITION_XINT13_EXTENDED))

//
// Define the media types supported by the driver.
//

typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia,             // Fixed hard disk media
    F3_120M_512             // 3.5", 120M Floppy
} MEDIA_TYPE, *PMEDIA_TYPE;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS.
//

typedef struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType;
   ULONG StartCylinderNumber;
   ULONG EndCylinderNumber;
   ULONG StartHeadNumber;
   ULONG EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

//
// Define the BAD_TRACK_NUMBER type. An array of elements of this type is
// returned by the driver on IOCTL_DISK_FORMAT_TRACKS requests, to indicate
// what tracks were bad during formatting. The length of that array is
// reported in the `Information' field of the I/O Status Block.
//

typedef USHORT BAD_TRACK_NUMBER;
typedef USHORT *PBAD_TRACK_NUMBER;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS_EX.
//

typedef struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType;
   ULONG StartCylinderNumber;
   ULONG EndCylinderNumber;
   ULONG StartHeadNumber;
   ULONG EndHeadNumber;
   USHORT FormatGapLength;
   USHORT SectorsPerTrack;
   USHORT SectorNumber[1];
} FORMAT_EX_PARAMETERS, *PFORMAT_EX_PARAMETERS;

//
// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY
// request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES
// request.
//

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    ULONG TracksPerCylinder;
    ULONG SectorsPerTrack;
    ULONG BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;

//
// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO
// and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request
// to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
//

typedef struct _PARTITION_INFORMATION {
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    ULONG HiddenSectors;
    ULONG PartitionNumber;
    UCHAR PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

//
// The following structure is used to change the partition type of a
// specified disk partition using an IOCTL_DISK_SET_PARTITION_INFO
// request.
//

typedef struct _SET_PARTITION_INFORMATION {
    UCHAR PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

//
// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT
// request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
//

typedef struct _DRIVE_LAYOUT_INFORMATION {
    ULONG PartitionCount;
    ULONG Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_VERIFY request.
// The offset and length parameters are both given in bytes.
//

typedef struct _VERIFY_INFORMATION {
    LARGE_INTEGER StartingOffset;
    ULONG Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_REASSIGN_BLOCKS
// request.
//

typedef struct _REASSIGN_BLOCKS {
    USHORT Reserved;
    USHORT Count;
    ULONG BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

#if(_WIN32_WINNT >= 0x0400)
//
// IOCTL_DISK_CONTROLLER_NUMBER returns the controller and disk
// number for the handle.  This is used to determine if a disk
// is attached to the primary or secondary IDE controller.
//

typedef struct _DISK_CONTROLLER_NUMBER {
    ULONG ControllerNumber;
    ULONG DiskNumber;
} DISK_CONTROLLER_NUMBER, *PDISK_CONTROLLER_NUMBER;
#endif /* _WIN32_WINNT >= 0x0400 */

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk performance  //
// statistics: specifically the locations of all the //
// reads and writes which have occured on the disk.  //
//                                                   //
// To use these structures, you must issue an IOCTL_ //
// DISK_HIST_STRUCTURE (with a DISK_HISTOGRAM) to    //
// obtain the basic histogram information. The       //
// number of buckets which must allocated is part of //
// this structure. Allocate the required number of   //
// buckets and call an IOCTL_DISK_HIST_DATA to fill  //
// in the data                                       //
//                                                   //
///////////////////////////////////////////////////////

#define HIST_NO_OF_BUCKETS  24

typedef struct _HISTOGRAM_BUCKET {
    ULONG       Reads;
    ULONG       Writes;
} HISTOGRAM_BUCKET, *PHISTOGRAM_BUCKET;

#define HISTOGRAM_BUCKET_SIZE   sizeof(HISTOGRAM_BUCKET)

typedef struct _DISK_HISTOGRAM {
    LARGE_INTEGER   DiskSize;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    LARGE_INTEGER   Average;
    LARGE_INTEGER   AverageRead;
    LARGE_INTEGER   AverageWrite;
    ULONG           Granularity;
    ULONG           Size;
    ULONG           ReadCount;
    ULONG           WriteCount;
    PHISTOGRAM_BUCKET  Histogram;
} DISK_HISTOGRAM, *PDISK_HISTOGRAM;

#define DISK_HISTOGRAM_SIZE sizeof(DISK_HISTOGRAM)

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk debugging    //
// capabilities. The IOCTLs are directed to one of   //
// the two disk filter drivers.                      //
//                                                   //
// DISKPERF is a utilty for collecting disk request  //
// statistics.                                       //
//                                                   //
// SIMBAD is a utility for injecting faults in       //
// IO requests to disks.                             //
//                                                   //
///////////////////////////////////////////////////////

//
// The following structure is exchanged on an IOCTL_DISK_GET_PERFORMANCE
// request. This ioctl collects summary disk request statistics used
// in measuring performance.
//

typedef struct _DISK_PERFORMANCE {
        LARGE_INTEGER BytesRead;
        LARGE_INTEGER BytesWritten;
        LARGE_INTEGER ReadTime;
        LARGE_INTEGER WriteTime;
        ULONG ReadCount;
        ULONG WriteCount;
        ULONG QueueDepth;
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

//
// This structure defines the disk logging record. When disk logging
// is enabled, one of these is written to an internal buffer for each
// disk request.
//

typedef struct _DISK_RECORD {
   LARGE_INTEGER ByteOffset;
   LARGE_INTEGER StartTime;
   LARGE_INTEGER EndTime;
   PVOID VirtualAddress;
   ULONG NumberOfBytes;
   UCHAR DeviceNumber;
   BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

//
// The following structure is exchanged on an IOCTL_DISK_LOG request.
// Not all fields are valid with each function type.
//

typedef struct _DISK_LOGGING {
    UCHAR Function;
    PVOID BufferAddress;
    ULONG BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

//
// Disk logging functions
//
// Start disk logging. Only the Function and BufferSize fields are valid.
//

#define DISK_LOGGING_START    0

//
// Stop disk logging. Only the Function field is valid.
//

#define DISK_LOGGING_STOP     1

//
// Return disk log. All fields are valid. Data will be copied from internal
// buffer to buffer specified for the number of bytes requested.
//

#define DISK_LOGGING_DUMP     2

//
// DISK BINNING
//
// DISKPERF will keep counters for IO that falls in each of these ranges.
// The application determines the number and size of the ranges.
// Joe Lin wanted me to keep it flexible as possible, for instance, IO
// sizes are interesting in ranges like 0-4096, 4097-16384, 16385-65536, 65537+.
//

#define DISK_BINNING          3

//
// Bin types
//

typedef enum _BIN_TYPES {
    RequestSize,
    RequestLocation
} BIN_TYPES;

//
// Bin ranges
//

typedef struct _BIN_RANGE {
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
} BIN_RANGE, *PBIN_RANGE;

//
// Bin definition
//

typedef struct _PERF_BIN {
    ULONG NumberOfBins;
    ULONG TypeOfBin;
    BIN_RANGE BinsRanges[1];
} PERF_BIN, *PPERF_BIN ;

//
// Bin count
//

typedef struct _BIN_COUNT {
    BIN_RANGE BinRange;
    ULONG BinCount;
} BIN_COUNT, *PBIN_COUNT;

//
// Bin results
//

typedef struct _BIN_RESULTS {
    ULONG NumberOfBins;
    BIN_COUNT BinCounts[1];
} BIN_RESULTS, *PBIN_RESULTS;

#if(_WIN32_WINNT >= 0x0400)
//
// Data structures for SMART drive fault prediction.
//
// GETVERSIONINPARAMS contains the data returned from the
// Get Driver Version function.
//

#pragma pack(1)
typedef struct _GETVERSIONINPARAMS {
        UCHAR    bVersion;               // Binary driver version.
        UCHAR    bRevision;              // Binary driver revision.
        UCHAR    bReserved;              // Not used.
        UCHAR    bIDEDeviceMap;          // Bit map of IDE devices.
        ULONG   fCapabilities;          // Bit mask of driver capabilities.
        ULONG   dwReserved[4];          // For future use.
} GETVERSIONINPARAMS, *PGETVERSIONINPARAMS, *LPGETVERSIONINPARAMS;
#pragma pack()

//
// Bits returned in the fCapabilities member of GETVERSIONINPARAMS
//

#define CAP_ATA_ID_CMD          1       // ATA ID command supported
#define CAP_ATAPI_ID_CMD        2       // ATAPI ID command supported
#define CAP_SMART_CMD           4       // SMART commannds supported

//
// IDE registers
//

#pragma pack(1)
typedef struct _IDEREGS {
        UCHAR    bFeaturesReg;           // Used for specifying SMART "commands".
        UCHAR    bSectorCountReg;        // IDE sector count register
        UCHAR    bSectorNumberReg;       // IDE sector number register
        UCHAR    bCylLowReg;             // IDE low order cylinder value
        UCHAR    bCylHighReg;            // IDE high order cylinder value
        UCHAR    bDriveHeadReg;          // IDE drive/head register
        UCHAR    bCommandReg;            // Actual IDE command.
        UCHAR    bReserved;                      // reserved for future use.  Must be zero.
} IDEREGS, *PIDEREGS, *LPIDEREGS;
#pragma pack()

//
// Valid values for the bCommandReg member of IDEREGS.
//

#define ATAPI_ID_CMD    0xA1            // Returns ID sector for ATAPI.
#define ID_CMD          0xEC            // Returns ID sector for ATA.
#define SMART_CMD       0xB0            // Performs SMART cmd.
                                        // Requires valid bFeaturesReg,
                                        // bCylLowReg, and bCylHighReg

//
// Cylinder register defines for SMART command
//

#define SMART_CYL_LOW   0x4F
#define SMART_CYL_HI    0xC2


//
// SENDCMDINPARAMS contains the input parameters for the
// Send Command to Drive function.
//

#pragma pack(1)
typedef struct _SENDCMDINPARAMS {
        ULONG   cBufferSize;            // Buffer size in bytes
        IDEREGS irDriveRegs;            // Structure with drive register values.
        UCHAR    bDriveNumber;           // Physical drive number to send
                                                                // command to (0,1,2,3).
        UCHAR    bReserved[3];           // Reserved for future expansion.
        ULONG   dwReserved[4];          // For future use.
        UCHAR    bBuffer[1];                     // Input buffer.
} SENDCMDINPARAMS, *PSENDCMDINPARAMS, *LPSENDCMDINPARAMS;
#pragma pack()

//
// Status returned from driver
//

#pragma pack(1)
typedef struct _DRIVERSTATUS {
        UCHAR    bDriverError;           // Error code from driver,
                                                                // or 0 if no error.
        UCHAR    bIDEError;                      // Contents of IDE Error register.
                                                                // Only valid when bDriverError
                                                                // is SMART_IDE_ERROR.
        UCHAR    bReserved[2];           // Reserved for future expansion.
        ULONG   dwReserved[2];          // Reserved for future expansion.
} DRIVERSTATUS, *PDRIVERSTATUS, *LPDRIVERSTATUS;
#pragma pack()

//
// bDriverError values
//

#define SMART_NO_ERROR          0       // No error
#define SMART_IDE_ERROR         1       // Error from IDE controller
#define SMART_INVALID_FLAG      2       // Invalid command flag
#define SMART_INVALID_COMMAND   3       // Invalid command byte
#define SMART_INVALID_BUFFER    4       // Bad buffer (null, invalid addr..)
#define SMART_INVALID_DRIVE     5       // Drive number not valid
#define SMART_INVALID_IOCTL     6       // Invalid IOCTL
#define SMART_ERROR_NO_MEM      7       // Could not lock user's buffer
#define SMART_INVALID_REGISTER  8       // Some IDE Register not valid
#define SMART_NOT_SUPPORTED     9       // Invalid cmd flag set
#define SMART_NO_IDE_DEVICE     10      // Cmd issued to device not present
                                        // although drive number is valid

#pragma pack(1)
typedef struct _SENDCMDOUTPARAMS {
        ULONG                   cBufferSize;            // Size of bBuffer in bytes
        DRIVERSTATUS            DriverStatus;           // Driver status structure.
        UCHAR                   bBuffer[1];             // Buffer of arbitrary length in which to store the data read from the                                                                                  // drive.
} SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;
#pragma pack()


#define READ_ATTRIBUTE_BUFFER_SIZE  512
#define IDENTIFY_BUFFER_SIZE        512
#define READ_THRESHOLD_BUFFER_SIZE  512

//
// Feature register defines for SMART "sub commands"
//

#define READ_ATTRIBUTES         0xD0
#define READ_THRESHOLDS         0xD1
#define ENABLE_DISABLE_AUTOSAVE 0xD2
#define SAVE_ATTRIBUTE_VALUES   0xD3
#define EXECUTE_OFFLINE_DIAGS   0xD4
#define ENABLE_SMART            0xD8
#define DISABLE_SMART           0xD9
#define RETURN_SMART_STATUS     0xDA
#endif /* _WIN32_WINNT >= 0x0400 */


// end_winioctl

//
// The following device control code is for the SIMBAD simulated bad
// sector facility. See SIMBAD.H in this directory for related structures.
//

#define IOCTL_DISK_SIMBAD               CTL_CODE(IOCTL_DISK_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Queue link for mapped addresses stored for unmapping.
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID MappedAddress;
    ULONG NumberOfBytes;
    LARGE_INTEGER IoAddress;
    ULONG BusNumber;
} MAPPED_ADDRESS, *PMAPPED_ADDRESS;

#endif // _NTDDDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ddk\DEVIOCTL.H ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    devioctl.h

Abstract:

    This module contains

Author:

    Andre Vachon (andreva) 21-Feb-1992


Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\wmav\wmaudio.h ===
/*
 * Windows Media Audio (WMA) Decoder API
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#ifndef _WMAUDIO_API_H_
#define _WMAUDIO_API_H_

#define PACKED
/*
#ifdef _MSC_VER
#define USE_PACK_HEADERS
#define PACKED
#else
#undef USE_PACK_HEADERS
#define PACKED  __packed
#endif

#ifdef USE_PACK_HEADERS
#include <pshpack1.h>
#endif
*/

/* ...........................................................................
 *
 * Types and Constants
 * ===================
 */

#define CHECK_NONSDMI_LIC	1
#define CHECK_SDMI_LIC		2
#define CHECK_ALL_LICENSE	3

#define WMA_MAX_DATA_REQUESTED  128


/* 16-bit signed type  */
#ifndef _WMAI16_DEFINED
#define _WMAI16_DEFINED
typedef short tWMA_I16;
#endif /* _WMAI16_DEFINED */

/* 16-bit unsigned type  */
#ifndef _WMAU16_DEFINED
#define _WMAU16_DEFINED
typedef short tWMA_U16;
#endif /* _WMAU16_DEFINED */

/* 32-bit unsigned type  */
#ifndef _WMAU32_DEFINED
#define _WMAU32_DEFINED
typedef unsigned long tWMA_U32;
#endif /* _WMAU32_DEFINED */

#ifndef _QWORD_DEFINED
#define _QWORD_DEFINED
typedef PACKED struct tQWORD
{
    tWMA_U32   dwLo;
    tWMA_U32   dwHi;

}   QWORD;
#endif /* _QWORD_DEFINED */

typedef struct _MarkerEntry {
    QWORD   m_qOffset;
    QWORD   m_qtime;
    tWMA_U16    m_wEntryLen;
    tWMA_U32   m_dwSendTime;
    tWMA_U32   m_dwFlags;
    tWMA_U32   m_dwDescLen;
    tWMA_U16   *m_pwDescName;
} MarkerEntry;

/* status */
#ifndef _WMAFILESTATUS_DEFINED
#define _WMAFILESTATUS_DEFINED
typedef enum tagWMAFileStatus
{
    cWMA_NoErr,                 /* -> always first entry */
                                /* remaining entry order is not guaranteed */
    cWMA_Failed,
    cWMA_BadArgument,
    cWMA_BadAsfHeader,
    cWMA_BadPacketHeader,
    cWMA_BrokenFrame,
    cWMA_NoMoreFrames,
    cWMA_BadSamplingRate,
    cWMA_BadNumberOfChannels,
    cWMA_BadVersionNumber,
    cWMA_BadWeightingMode,
    cWMA_BadPacketization,

    cWMA_BadDRMType,
    cWMA_DRMFailed,
    cWMA_DRMUnsupported,

    cWMA_DemoExpired,

    cWMA_BadState,
    cWMA_Internal               /* really bad */

} tWMAFileStatus;
#endif /* _WMAFILESTATUS_DEFINED */

/* versions */
#ifndef _WMAFILEVERSION_DEFINED
#define _WMAFILEVERSION_DEFINED
typedef enum tagWMAFileVersion
{
    cWMA_V1 = 1,
    cWMA_V2 = 2

} tWMAFileVersion;
#endif /* _WMAFILEVERSION_DEFINED */

/* sample rates */
#ifndef _WMAFILESAMPLERATE_DEFINED
#define _WMAFILESAMPLERATE_DEFINED
typedef enum tagWMAFileSampleRate
{
    cWMA_SR_48kHz,
    cWMA_SR_44_1kHz,
    cWMA_SR_32kHz,
    cWMA_SR_22_05kHz,
    cWMA_SR_16kHz,
    cWMA_SR_11_025kHz,
    cWMA_SR_08kHz
} tWMAFileSampleRate;
#endif /* _WMAFILESAMPLERATE_DEFINED */

/* channels */
#ifndef _WMAFILECHANNELS_DEFINED
#define _WMAFILECHANNELS_DEFINED
typedef enum tagWMAFileChannels
{
    cWMA_C_Mono = 1,
    cWMA_C_Stereo = 2

} tWMAFileChannels;
#endif /* _WMAFILECHANNELS_DEFINED */


/* ...........................................................................
 *
 * Structures
 * ==========
 */

#ifdef _LINUX_x86
#pragma pack (1)
#endif

/* header */
#ifndef _WMAFILEHEADER_DEFINED
#define _WMAFILEHEADER_DEFINED
typedef PACKED struct tagWMAFileHeader
{
    tWMAFileVersion version;         /* version of the codec */
    tWMAFileSampleRate sample_rate;  /* sampling rate */
    tWMAFileChannels num_channels;   /* number of audio channels */
    tWMA_U32 duration;               /* of the file in milliseconds */
    tWMA_U32 packet_size;            /* size of an ASF packet */
    tWMA_U32 first_packet_offset;    /* byte offset to the first ASF packet */
    tWMA_U32 last_packet_offset;     /* byte offset to the last ASF packet */

    tWMA_U32 has_DRM;                /* does it have DRM encryption? */

    tWMA_U32 bitrate;                /* bit-rate of the WMA bitstream */

    /* HongCho: what else? */

} tWMAFileHeader;
#endif /* _WMAFILEHEADER_DEFINED */


/* content description */
#ifndef _WMAFILECONTDESC_DEFINED
#define _WMAFILECONTDESC_DEFINED
typedef PACKED struct tagWMAFileContDesc
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    tWMA_U16 title_len;
    tWMA_U16 author_len;
    tWMA_U16 copyright_len;
    tWMA_U16 description_len;   /* rarely used */
    tWMA_U16 rating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    unsigned char *pTitle;
    unsigned char *pAuthor;
    unsigned char *pCopyright;
    unsigned char *pDescription;
    unsigned char *pRating;

} tWMAFileContDesc;
#endif /* _WMAFILECONTDESC_DEFINED */

/* license params */
#ifndef _WMAFILELICPARAMS_DEFINED
#define _WMAFILELICPARAMS_DEFINED
typedef PACKED struct tagWMAFileLicParams
{
    unsigned char *pPMID;       /* portable media id */
    tWMA_U32 cbPMID;            /* length of the pPMID buffer */

} tWMAFileLicParams;
#endif /* _WMAFILELICPARAMS_DEFINED */


typedef void * tHWMAFileState;

/* another internal state */
#ifndef _WMAFILEHDRSTATE_DEFINED
#define _WMAFILEHDRSTATE_DEFINED
typedef PACKED struct tagWMAFileHdrState
{
    unsigned char internal[188];

} tWMAFileHdrState;
#endif /* _WMAFILEHDRSTATE_DEFINED */

#ifdef _LINUX_x86
#pragma pack ()
#endif

/* ........................................................................... 
 *
 * Functions
 * =========
 */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/*
 *        WMAFileIsWMA
 *        ============
 *
 * Description
 * -----------
 * Checks to see if the file is decodable.  Uses WMAFileCBGetData(),
 * but the first argument to it is not really of type tHWMAFileState,
 * but tWMAFileIdState.
 *
 * To decode the file, the app should call WMAFileDecodeInit()
 * instead.
 *
 * This function was added in case the app wants to determine the
 * type of the file without fully allocating tHWMAFileState.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileIsWMA(tWMAFileHdrState *state);
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                yes, it's a WMA file
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus __stdcall WMAFileIsWMA (tWMAFileHdrState *state);

/*
 *        WMAGetMarkers
 *        ============
 *
 * Description
 * -----------
 * Get the marker list so the main program can seek the file freely.
 *
 * Syntax
 * ------
 * int WMAGetMarkers(tWMAFileHdrState *state,MarkerEntry **ppEntry);
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   ppEntry        Address of the poitner to store the array of MarkerEntry
 *
 * Return Value
 * ------------
 * number of Marker Entries
 *
 */
int __stdcall WMAGetMarkers(tWMAFileHdrState *state,MarkerEntry **ppEntry);

/*
 *        WMAGetLicenseStore
 *        ============
 *
 * Description
 * -----------
 * Get the marker list so the main program can seek the file freely.
 *
 * Syntax
 * ------
 * BYTE * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen)
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pLen           Address of the poitner to store the size of license.
 *
 * Return Value
 * ------------
 * Pointer of data chunck
 *
 */
unsigned char * __cdecl WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen);

/*
 *        WMAFileCBGetData
 *        ================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio decoder.  Not implemented by
 * the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio library needs more data to process (both to parse
 * informatio and to decode the actual data bitstream), the library
 * will call this function.
 *
 * Called by WMAFileDecodeInit(), WMAFileContentDesc() and
 * WMAFileDecodeData().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetData(tHWMAFileState hstate,
 *                             tWMA_U32 offset,
 *                             tWMA_U32 num_bytes,
 *                             unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the WMA file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *                  The WMA library may over-write this buffer
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */

/*
extern tWMA_U32 __stdcall WMAFileCBGetData (
    tHWMAFileState hstate,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);
*/

/*
 *        WMAFileCBGetLicenseData
 *        =======================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio DRM decryption function.  Not
 * implemented by the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio's DRM decryption library needs more data to process
 * the library will call this function.
 *
 * Called by WMAFileLicenseInit().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetLicenseData(tHWMAFileState *state,
 *                                    tWMA_U32 offset,
 *                                    tWMA_U32 num_bytes,
 *                                    unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the license file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */

/*
extern tWMA_U32 WMAFileCBGetLicenseData (
    tHWMAFileState *pstate,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);
*/

/*
 *        WMAFileDecodeInit
 *        =================
 *
 * Description
 * -----------
 * Initializes the WMAudio decoder.
 *
 * Must be called before starting to decode a WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInit(tHWMAFileState *state);
 *
 * where:
 *
 *   phstate        pointer to the handle that holds the internal
 *                  state of the WMAudio decoder
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                decoder initialised
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *   cWMA_BadSamplingRate      invalid or unsupported sampling rate
 *   cWMA_BadNumberOfChannels  invalid or unsupported number of channels
 *   cWMA_BadVersionNumber     invalid or unsupported version number
 *   cWMA_BadWeightingMode     invalid or unsupported weighting mode
 *   cWMA_BadPacketisation     invalid or unsupported packetisation
 *   cWMA_BadDRMType           unknown encryption type
 *   cWMA_DRMFailed            DRM failed
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus __stdcall WMAFileDecodeInit (tHWMAFileState* phstate);


tWMAFileStatus __stdcall WMAFileDecodeClose (tHWMAFileState* phstate);

/*
 *       WMAFileDecodeInfo
 *       =================
 *
 * Description
 * -----------
 * Retrieves the header information for the WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInfo(tHWMAFileState hstate,
 *                                    tWMAFileHeader *hdr);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   hdr            pointer to the structure that holds the WMA file
 *                  header info
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                header retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *
 */

tWMAFileStatus __stdcall WMAFileDecodeInfo (tHWMAFileState hstate, tWMAFileHeader *hdr);


/*
 *       WMAFileContentDesc
 *       ==================
 *
 * Description
 * -----------
 * Retrieves the content description for the WMA file.  Content
 * descriptions are such as the song title, the author, the
 * copyright info, the song description, and the rating info.
 * All these are part of the standard ASF description.
 *
 * Not all songs have content descriptions.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileContentDesc(tHWMAFileState hstate,
 *                                     tWMAFileContDesc *desc);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   desc           pointer to the structure that holds the WMA file
 *                  content description info
 *                  as [in], must provide the buffer(s) and the size(s)
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                description retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus __stdcall WMAFileContentDesc (tHWMAFileState hstate, tWMAFileContDesc *desc);


/*
 *       WMAFileLicenseInit
 *       ==================
 *
 * Description
 * -----------
 * Reads the DRM license file and check the license for the file.
 *
 * Uses WMAFileCBGetLicenseData to retrieve the license file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileLicenseInit(tHWMAFileState hstate,
 *                                     tWMAFileLicParams *lic_params);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   lic_params     pointer to the structure that passes in the
 *                  parameters for the license initialization.
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                license checked ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_DRMFailed            no license
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileLicenseInit (tHWMAFileState hstate, tWMAFileLicParams *lic_params, tWMA_U16 CheckLicTypes);


/*
 *       WMAFileDecodeData
 *       =================
 *
 * Description
 * -----------
 * Decodes WMAudio bitstream.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeData(tHWMAFileState hstate);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                frame decoded ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_BrokenFrame          data is inconsistent
 *   cWMA_NoMoreFrames         no more data to decode
 *
 */
tWMAFileStatus __stdcall WMAFileDecodeData (tHWMAFileState hstate);


/*
 *       WMAFileGetPCM
 *       =============
 *
 * Description
 * -----------
 * Write PCM samples from the WMAudio bitstream previously decoded by
 * WMAFileDecodeData().
 *
 * WMAFileGetPCM() may have to be called more than once to obtain all
 * of the samples for the frame. The frame is complete when the number
 * of samples written is less than the number of samples requested.
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileGetPCM(tHWMAFileState hstate,
 *                          tWMA_I16 *left, tWMA_I16 *right,
 *                          tWMA_U32 max_nsamples);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   pi16Channel0   pointer to output buffer for left-channel PCM, or the entire PCM output if it is inter-leaved form
 *   pi16Channel1   pointer to output buffer for right-channel PCM, NULL if the output PCM is in parallel form
 *   max_nsamples   maximum number of samples to write per channel
 *
 * Return Value
 * ------------
 *   tWMA_U32       number of samples written
 *                  < max_nsamples when frame complete
 *
 */
tWMA_U32 __stdcall WMAFileGetPCM (
    tHWMAFileState hstate,
    tWMA_I16 *pi16Channel0, tWMA_I16 *pi16Channel1,
    tWMA_U32 max_nsamples);


/*
 *       WMAFileSeek
 *       ===========
 *
 * Description
 * -----------
 * Seek to a time into the WMA file.  It seeks to the nearest seek
 * point.
 *
 * Syntax
 * ------
 *   tWMA_32 WMAFileSeek(tHWMAFileState hstate,
 *                       tWMA_U32 msSeek);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   msSeek         time position to seek from the beginning of the
 *                  clip, in milliseconds
 *
 * Return Value
 * ------------
 *   tWMA_32        actual time position from the beginning of the
 *                  clip, in milliseconds
 *
 */
tWMA_U32 WMAFileSeek (tHWMAFileState hstate, tWMA_U32 msSeek);


#ifdef __cplusplus
}
#endif /* __cplusplus */

/*
#ifdef USE_PACK_HEADERS
#include <poppack.h>
#endif
*/

#endif /* _WMAUDIO_API_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ravisent\dvdcpl32.h ===
#ifndef DVDFPL32_H
#define DVDFPL32_H

#define ONLY_EXTERNAL_VISIBLE


#undef UNICODE
#undef TCHAR
#define TCAHR char

#if   LINUX
////////////////////////////////////////////////////////////////////
//
//	LINUX
//
////////////////////////////////////////////////////////////////////

// #define NULL	0

#define __far
#define __huge
#define __cdecl
#define __pascal
#define __export
#define __loadds
#define FAR
#define cdecl
#define WINAPI

typedef unsigned int HANDLE;
typedef signed long LONG;

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;


#include <stdlib.h>
#include <malloc.h>
#include <string.h>

enum POOL_TYPE
	{
	NonPagedPool, PagedPool
	};

void * operator new (unsigned int nSize, POOL_TYPE iType);
void * operator new (unsigned int nSize);
void operator delete (void *p);

#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#define _fmemcpy  memcpy
#define _fmalloc	malloc
#define _ffree		free

/* just like below in the #ifdef MMXMEMORY section */
inline void * __cdecl operator new(unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

inline void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

inline void __cdecl operator delete(void* p, POOL_TYPE iType)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

inline void __cdecl operator delete(void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

inline void __cdecl operator delete[](void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}


#elif MACINTOSH
////////////////////////////////////////////////////////////////////
//
//	Apple Macintosh
//
////////////////////////////////////////////////////////////////////

//	You should manually define MACINTOSH and also one of:
//	TARGET_API_MAC_OS8 ||TARGET_API_MAC_OSX ||TARGET_API_MAC_CARBON
//	TARGET_CPU_PPC is default


//	undefine Windows-isms
#define __far
#define __huge
#define __cdecl
#define __pascal
#define __export
#define __loadds


//	Memory management

typedef unsigned long	size_t;

enum POOL_TYPE
	{
	NonPagedPool, PagedPool
	};

void *  operator new(size_t nSize);
void *  operator new(size_t nSize, POOL_TYPE iType);
void	operator delete(void* p);

void *  operator new[](size_t nSize);
void *  operator new[](size_t nSize, POOL_TYPE iType);
void	operator delete[](void* p);

//	core MacOS includes
#include <ConditionalMacros.h>


#else
////////////////////////////////////////////////////////////////////
//
//	The OTHER Operating System
//
////////////////////////////////////////////////////////////////////

//
// Disable warnings for "inline assembler", "lost debugging information"
// and "inline functions".
//
#pragma warning(disable : 4505)
#pragma warning(disable : 4704)
#pragma warning(disable : 4791)


/*



#include <stdlib.h>
#include <malloc.h>

enum POOL_TYPE
	{
	PagedPool = 0,
	NonPagedPool = 1
	};


inline void * __cdecl operator new(unsigned int nSize)
	{
	return malloc(nSize);
	}

inline void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	return malloc(nSize);
	}

inline void __cdecl operator delete(void* p, POOL_TYPE iType)
	{
	if (p)
		{
		free(p);
		}
	}



*/


#endif // not ST20LITE branch


////////////////////////////////////////////////////////////////////
//
//	SECOND PART: Common definitions
//
////////////////////////////////////////////////////////////////////



#include <windows.h>
#include <winnt.h>

// THIS WAS EXPERIMENTALLY REMOVED BECAUSE NOONE KNOWS WHAT IT IS GOOD FOR
//#include "resource.h"

#define __far
#define __huge
#define __loadds

#define _fmemcpy	memcpy
#if UNICODE
#define _fstrcpy	wcscpy
#define _fstrcat	wcscat
#define _fstrlen  wcslen
#define _fstrcmp	wcscmp
#else
#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#endif
#define _fmalloc	malloc
#define _ffree		free
#define _halloc(x,y)	new BYTE[x*y]
#define _hfree(x) delete[] x

typedef int			BOOL;
typedef char	 * LPSTR;

typedef unsigned char		BYTE;
typedef unsigned short		WORD;
typedef unsigned long		DWORD;

typedef unsigned __int64	QWORD;

typedef unsigned int		UINT;
typedef signed long		LONG;


#ifndef LOBYTE
#define LOBYTE(w)	    	((BYTE)(w))
#endif

#ifndef HIBYTE
#define HIBYTE(w)     	((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif

#ifndef LOWORD
#define LOWORD(l)     	((WORD)(DWORD)(l))
#endif

#ifndef HIWORD
#define HIWORD(l)     	((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif

#ifndef MAKELONG
#define MAKELONG(low, high) ((DWORD)(WORD)(low) | ((DWORD)(WORD)(high) << 16))
#endif

#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif









//
// Some extended definitions for word/dword arithmetic
//
#ifndef MAKEWORD
#define MAKEWORD(low, high) ((WORD)(BYTE)(low) | ((WORD)(BYTE)(high) << 8))
#endif

#define MAKELONG4(low, lmid, hmid, high) ((DWORD)(BYTE)(low) | ((DWORD)(BYTE)(lmid) << 8) | ((DWORD)(BYTE)(hmid) << 16) | ((DWORD)(BYTE)(high) << 24))
#define LBYTE0(w) ((BYTE)((w) & 0xff))
#define LBYTE1(w) ((BYTE)(((DWORD)(w) >> 8) & 0xff))
#define LBYTE2(w) ((BYTE)(((DWORD)(w) >> 16) & 0xff))
#define LBYTE3(w) ((BYTE)(((DWORD)(w) >> 24) & 0xff))

inline DWORD FLIPENDIAN(DWORD x)
	{
	return MAKELONG4(LBYTE3(x), LBYTE2(x), LBYTE1(x), LBYTE0(x));
	}

//
// Some standard pointer types
//

typedef void 		 	*	APTR;			// local pointer
typedef void __far	*	FPTR;			// far pointer
typedef void __huge	*	HPTR;			//	huge pointer
typedef BYTE __huge 	*	HBPTR;		// huge byte pointer



//
// We need a memory copy for huge memory; will use the windows version
// when available.
//



#define _hmemcpy memcpy





//
// Some more stuff
//
typedef BOOL				BIT;

#define HIGH				TRUE
#define LOW					FALSE

#ifndef FP_OFF
#define FP_OFF(x)			LOWORD(x)
#define FP_SEG(x)			HIWORD(x)
#endif



//
// Flag construction macro
//
#define MKFLAG(x)		(1UL << x)

//
// DWORD Bitfield construction and extraction functions
//
inline DWORD MKBF(int bit, int num, DWORD val) {return (((DWORD)val & ((1UL << num) -1)) << bit);}
inline DWORD MKBF(int bit, BOOL val) {return (val ? (1UL << bit) : 0);}
inline DWORD XTBF(int bit, int num, DWORD bf) {return ((bf >> bit) & ((1UL << num) -1));}
inline BOOL XTBF(int bit, DWORD bf) {return ((bf & (1UL << bit)) != 0);}
inline DWORD WRBF(DWORD bf, int bit, int num, DWORD val)
	{
	DWORD mask = ((1UL << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline DWORD WRBF(DWORD bf, int bit, BOOL val) {return (val ? (bf | (1UL << bit)) : (bf & ~(1UL << bit)));}

//
// WORD Bitfield construction and extraction functions
//
inline WORD MKBFW(int bit, int num, WORD val) {return (((WORD)val & ((1 << num) -1)) << bit);}
inline WORD MKBFW(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline WORD XTBFW(int bit, int num, WORD bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFW(int bit, WORD bf) {return ((bf & (1 << bit)) != 0);}
inline WORD WRBFW(WORD bf, int bit, int num, WORD val)
	{
	WORD mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline WORD WRBFW(WORD bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// BYTE Bitfield construction and extraction functions
//
inline BYTE MKBFB(int bit, int num, BYTE val) {return (((BYTE)val & ((1 << num) -1)) << bit);}
inline BYTE MKBFB(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline BYTE XTBFB(int bit, int num, BYTE bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFB(int bit, BYTE bf) {return ((bf & (1 << bit)) != 0);}
inline BYTE WRBFB(BYTE bf, int bit, int num, BYTE val)
	{
	BYTE mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline BYTE WRBFB(BYTE bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// Find the most significate one bit or the least significant one bit in a double word
//
inline int FindMSB(DWORD bf) {int i; for(i=31; i>=0; i--) {if (XTBF(31, bf)) return i; bf <<= 1;} return -1;}
inline int FindLSB(DWORD bf) {int i; for(i=0; i<=31; i++) {if (XTBF( 0, bf)) return i; bf >>= 1;} return 32;}



//
// Scaling of values of WORD range to values of WORD range
//
inline WORD ScaleWord(WORD op, WORD from, WORD to) {return (WORD)((DWORD)op * (DWORD) to / (DWORD) from);}
	DWORD ScaleDWord(DWORD op, DWORD from, DWORD to);
	long ScaleLong(long op, long from, long to);
	void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower);
	DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op);
//
// Most values in drivers etc. are scaled in a range from 0 to 10000, this functions transfer from and
// to this range
//
inline WORD ScaleFrom10k(WORD op, WORD to) {return ScaleWord(op, 10000, to);}
inline BYTE ScaleByteFrom10k(WORD op, BYTE to) {return (BYTE)ScaleWord(op, 10000, to);}
inline WORD ScaleTo10k(WORD op, WORD from) {return ScaleWord(op, from, 10000);}







class GenericHook;


extern "C" {
#define DLLCALL __declspec(dllexport)
DLLCALL	void	WINAPI VDR_RegisterCallback(GenericHook * hook);
DLLCALL	void	WINAPI VDR_UnregisterCallback(GenericHook * hook);
#define H20_RegisterCallback	VDR_RegisterCallback
}


#if !VIDEO_MINIPORT_DRIVER
#endif

typedef unsigned long Error;

//
// The last error, that was raised, is not only returned, but preserved in
// this variable.
//
//extern Error LastError;

//
// Error numbers are composed of four parts, an severity level, that
// tells how hard the error hit; a unit id, describing the unit that
// failed; an error type giving some general reasons and an unique
// id (unique for the module, not all error messages).
//
//                  SS-UUUUUUUU-TTTTTTTT-IIIIIIIIIIIIII
//


#define GNR_SEVERITY_BITS	(2)
#define GNR_SEVERITY_SHIFT	(30)
#define GNR_SEVERITY_MASK	(0xC0000000)

#define GNR_UNIT_BITS		(8)
#define GNR_UNIT_SHIFT		(22)
#define GNR_UNIT_MASK		(0x3FC00000)

#define GNR_TYPE_BITS		(8)
#define GNR_TYPE_SHIFT		(14)
#define GNR_TYPE_MASK	   (0x003FC000)

#define GNR_UNIQUE_BITS		(14)
#define GNR_UNIQUE_SHIFT	(0)
#define GNR_UNIQUE_MASK		(0x00003FFF)


//
// The severity level describes how hard this error affected the operation.
//
// As the severity level is the most significant part of an error message,
// it can be tested with a simple compare (not the Error is defined as
// unsigned, so no special sign effects can occur).
//
#define GNR_OK					(0x0L << GNR_SEVERITY_SHIFT)
	// everything did well; The neat side effect of defining the OK level as
	// 0, is that the check for an error can be done with a simple not
	// 0 compare like "if (error) { ... }".

#define GNR_WARNING			(0x1L << GNR_SEVERITY_SHIFT)
	// something not quite perfect happened, but the action was performed

#define GNR_ERROR				(0x2L << GNR_SEVERITY_SHIFT)
	// an error accured, that kept the routine from doing its job

#define GNR_DEADLY			(0x3L << GNR_SEVERITY_SHIFT)
	// something happened, that will keep the program from working correct,
	// it would be better to exit gracefully

//
// The error unit specifies the module where this error was defined
//
#define GNR_UNIT_COMMON		(0x0L << GNR_UNIT_SHIFT)
	// defined in gnerrors.H

#define GNR_UNIT_GENERAL	(0x1L << GNR_UNIT_SHIFT)
	// define in ..\general\*.h

#define GNR_UNIT_MEMMPDIO	(0x2L << GNR_UNIT_SHIFT)
	// define in memmpdio.h

#define GNR_UNIT_I2C			(0x3L << GNR_UNIT_SHIFT)
	// defined in viperi2c.h

#define GNR_UNIT_INTERRUPT	(0x4L << GNR_UNIT_SHIFT)
   // defined in intrctrl.h

#define GNR_UNIT_PARSER		(0x5L << GNR_UNIT_SHIFT)
	// defined in mpgparse.h

#define GNR_UNIT_PCI					(0x6L << GNR_UNIT_SHIFT)
	// define in pci.h

#define GNR_UNIT_DMA					(0x7L << GNR_UNIT_SHIFT)
	// define in dma*.h

#define GNR_UNIT_VDECODER			(0x8L << GNR_UNIT_SHIFT)
	// defined in viddec.h

#define GNR_UNIT_VENCODER			(0x9L << GNR_UNIT_SHIFT)
	// defined in videnc.h

#define GNR_UNIT_JPEG				(0xCL << GNR_UNIT_SHIFT)
	// defined in core.h

#define GNR_UNIT_MPEG				(0xDL << GNR_UNIT_SHIFT)
	// defined in library\hardware\mpeg2dec\mp2eldec.h

#define GNR_UNIT_TVTUNER			(0xEL << GNR_UNIT_SHIFT)
	// defined in tvtuner.h

#define GNR_UNIT_VESA20				(0xFL << GNR_UNIT_SHIFT)
	// defined in vesa20.h

#define GNR_UNIT_GFC					(0x10L << GNR_UNIT_SHIFT)
	// defined in gfxconfig.h

#define GNR_UNIT_PIP					(0x11L << GNR_UNIT_SHIFT)
	// defined in *pip*.h

#define GNR_UNIT_DMAMEM				(0x12L << GNR_UNIT_SHIFT)
	//	defined in ctdmamem.h

#define GNR_UNIT_CD					(0x13L << GNR_UNIT_SHIFT)
	// defined in cdifs.h

#define GNR_UNIT_PROFILES			(0x14L << GNR_UNIT_SHIFT)
	// defined in profiles.h

#define GNR_UNIT_AUDIO				(0x15L << GNR_UNIT_SHIFT)
	// defined in audio

#define GNR_UNIT_PCICONTROLLER	(0x16L << GNR_UNIT_SHIFT)

#define GNR_UNIT_AC3					(0x17L << GNR_UNIT_SHIFT)

#define GNR_UNIT_VTX					(0x18L << GNR_UNIT_SHIFT)
	// defined in vtxdll.h

#define GNR_UNIT_MPEG2				(0x19L << GNR_UNIT_SHIFT)

#define GNR_UNIT_MP2PARSER			(0x1AL << GNR_UNIT_SHIFT)

#define GNR_UNIT_VXD					(0x1BL << GNR_UNIT_SHIFT)
	// Error messages from PnP VxD interfaces

#define GNR_UNIT_DISK				(0x1CL << GNR_UNIT_SHIFT)
	// General disk errors (library\hardware\drives\generic\diskerrors.h)

#define GNR_UNIT_NAVIGATION		(0x1DL << GNR_UNIT_SHIFT)
	// Navigation errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DVD					(0x1EL << GNR_UNIT_SHIFT)
	// DVD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_VCD					(0x1FL << GNR_UNIT_SHIFT)
	// VCD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_CDA					(0x20L << GNR_UNIT_SHIFT)
	// CDA specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DECRYPTION		(0x21L << GNR_UNIT_SHIFT)
	// Decryption errors (library\hardware\mpeg2dec\generic\mp2dcryp.h)

#define GNR_UNIT_FILE				(0x22L << GNR_UNIT_SHIFT)
	// File errors (library\files\fileerrors.h)

#define GNR_UNIT_UNITS				(0x21L << GNR_UNIT_SHIFT)
	// in virtunit.h

#define GNR_UNIT_SUBPICTURE		(0x22L << GNR_UNIT_SHIFT)

#define GNR_UNIT_FRONTPANEL             (0x23L << GNR_UNIT_SHIFT)

//
// The error type gives a general hint, what caused the malfunction
//
#define GNR_TYPE_GENERAL			(0x00L << GNR_TYPE_SHIFT)
	// no special info

#define GNR_TYPE_FILEIO				(0x01L << GNR_TYPE_SHIFT)
	// some file specific error occured

#define GNR_TYPE_HARDWARE			(0x02L << GNR_TYPE_SHIFT)
	// it was a general hardware problem

#define GNR_TYPE_PARAMS				(0x03L << GNR_TYPE_SHIFT)
	// illegal parameters were used

#define GNR_TYPE_TIMEOUT			(0x04L << GNR_TYPE_SHIFT)
	// a timeout happened

#define GNR_TYPE_BUSY				(0x05L << GNR_TYPE_SHIFT)
	// the requested unit is currently busy

#define GNR_TYPE_NOACK				(0x06L << GNR_TYPE_SHIFT)
	// the requested unit did not respond

#define GNR_TYPE_INACTIVE			(0x07L << GNR_TYPE_SHIFT)
	// the requested unit is currently not active, or in an illegal
	// state for the type of the requested operation

#define GNR_TYPE_MEMORY				(0x08L << GNR_TYPE_SHIFT)
	// there was no sufficient free store left

#define GNR_TYPE_UNIMPLEMENTED 	(0x09L << GNR_TYPE_SHIFT)
	// the called function is not yet completely implemented

#define GNR_TYPE_FORMAT				(0x0aL << GNR_TYPE_SHIFT)
	// the examined object was in the wrong format

#define GNR_TYPE_OBJECT				(0x0bL << GNR_TYPE_SHIFT)

#define GNR_TYPE_BOUNDS				(0x0cL << GNR_TYPE_SHIFT)

#define GNR_TYPE_ILLEGALACCESS	(0x0dL << GNR_TYPE_SHIFT)

#define GNR_TYPE_REGION				(0x0eL << GNR_TYPE_SHIFT)

#define GNR_TYPE_PARENTAL			(0x0fL << GNR_TYPE_SHIFT)

#define GNR_TYPE_UOP					(0x10L << GNR_TYPE_SHIFT)

#define GNR_TYPE_OPERATION			(0x11L << GNR_TYPE_SHIFT)

#define GNR_TYPE_INTERNALSTATE	(0x12L << GNR_TYPE_SHIFT)

#define GNR_TYPE_COPYPROTECTION	(0x13L << GNR_TYPE_SHIFT)

//
// Macros to build and decompose error numbers
//
#define MKERR(level, unit, type, unique) ((Error)(GNR_##level | GNR_UNIT_##unit | GNR_TYPE_##type | unique))
	// build an error number from its parts

#define GNR_SEVERITY(err) (err & GNR_SEVERITY_MASK)
	// extracts the severity of the error number

#define GNR_UNIT(err) (err & GNR_UNIT_MASK)
	// extracts the unit of the error number

#define GNR_TYPE(err) (err & GNR_TYPE_MASK)
	// extracts the type of the error number

#define GNR_UNIQUE(err) (err & GNR_UNIQUE_MASK)
	// extracts the unique id of the error number

#ifndef IS_ERROR
	//
	// sidenote, the original definition of IS_ERROR in <winerror.h> is
	// #define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
	// this is functional identical to our definition, so no need to redefine it
	// here.  In any case a new define is added, which is to be used in all future
	// tests.
	//
#define IS_ERROR(err) ((err) >= GNR_ERROR)
#endif
#define IS_GNERROR(err) ((err) >= GNR_ERROR)

#define IS_WARNING(err) (GNR_SEVERITY(err) == GNR_WARNING)

//
// Some default error messages
//
#define GNR_FILE_NOT_FOUND			MKERR(ERROR, COMMON, FILEIO, 0x00)
	// general file not found error

#define GNR_FILE_IN_USE 			MKERR(ERROR, COMMON, FILEIO, 0x01)
	// the file is currently in use

#define GNR_FILE_WRONG_FORMAT 	MKERR(ERROR, COMMON, FILEIO, 0x02)
	// the file is in the wrong file format

#define GNR_END_OF_FILE 			MKERR(ERROR, COMMON, FILEIO, 0x03)
	// attempt to read behind the end of a file

#define GNR_NOT_ENOUGH_MEMORY 	MKERR(ERROR, COMMON, MEMORY, 0x04)
	// general not enough memory left

#define GNR_MEM_NOT_ALLOCATED 	MKERR(WARNING, COMMON, MEMORY, 0x05)
	// the memory that was requested to be freed was not allocated
	// before.

#define GNR_MEM_ALLOCATED_BEFORE MKERR(WARNING, COMMON, MEMORY, 0x06)
	// the memory was allocated before


#define GNR_UNIMPLEMENTED 			MKERR(ERROR, COMMON, UNIMPLEMENTED, 0x07)
	// the function is not yet implemented, and will never be


#define GNR_OBJECT_NOT_FOUND		MKERR(ERROR, COMMON, OBJECT, 0x08)
	// the requested object could not be found

#define GNR_OBJECT_EXISTS			MKERR(ERROR, COMMON, OBJECT, 0x09)
	// the object requested to be created does already exist

#define GNR_OBJECT_IN_USE			MKERR(ERROR, COMMON, OBJECT, 0x0a)
	// an operation that needs exclusive access to an object, found the object
	// already in use

#define GNR_OBJECT_FOUND			MKERR(ERROR, COMMON, OBJECT, 0x0b)
	// an object that was to be inserted in a data structure with unique objects
	// was already in there

#define GNR_RANGE_VIOLATION		MKERR(ERROR, COMMON, BOUNDS, 0x0c)
	// a given parameter was out of bounds


#define GNR_INVALID_CONFIGURE_STATE		MKERR(ERROR, COMMON, INACTIVE, 0x0d)
	// the unit was in an invalid state for configuration

#define GNR_OBJECT_FULL				MKERR(ERROR, COMMON, BOUNDS, 0x0e)

#define GNR_OBJECT_EMPTY			MKERR(ERROR, COMMON, BOUNDS, 0x0f)

#define GNR_OBJECT_NOT_ALLOCATED	MKERR(ERROR, COMMON, INACTIVE, 0x10)

#define GNR_OBJECT_READ_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x11)

#define GNR_OBJECT_WRITE_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x12)

#define GNR_OPERATION_PROHIBITED	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x13)

#define GNR_OBJECT_INVALID			MKERR(ERROR, COMMON, OBJECT, 0x14)

#define GNR_INSUFFICIENT_RIGHTS	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x15)

#define GNR_TIMEOUT					MKERR(ERROR, COMMON, NOACK, 0x16)

#define GNR_FILE_READ_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x17)

#define GNR_FILE_WRITE_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x18)

#define GNR_INVALID_PARAMETERS	MKERR(ERROR, COMMON, PARAMS, 0x19)

#define GNR_CONNECTION_LOST		MKERR(ERROR, COMMON, INACTIVE, 0x1a)

#define GNR_OPERATION_ABORTED		MKERR(ERROR, COMMON, TIMEOUT, 0x1b)

//
// Error invocation macros, to be used to standardize erroneous returns
//
#define GNRAISE(e) return (e)
	// raise an error, store it into the global error variable, and
	// return with the error number.

#define GNRAISE_OK return GNR_OK
	// raise the OK error, all did well

//#define GNRAISE_AGAIN return LastError
	// raise the last error again

#define GNASSERT(cond, except) if (cond) GNRAISE(except); else	0
	// if the condition evaluates to true, the exception is raised

#define GNREASSERT(cond) if (1) {Error e; if (e = (cond)) GNRAISE(e);} else 0
	// if the condition evaluates to not OK, the error is raised again

#define GNREASSERTMAP(cond, ne) if (1) {Error e; if (e = (cond)) GNRAISE(ne);} else 0
	// if the condition evaluates to not OK, the error ne is returned





// In order to be flexible, we use tags for setting and getting data and query
// module capabilities. Tag pairs consist of the tag itself and a data item.
// The tag tells which variable shall be set or retrieved. The data item is
// the value written to the variable or a pointer to the location where the
// retrieved value is to be stored.
// Tags have 32 bits and are built the following way:
//
// iccc uuuu uuuu uuuu rsss ssss ssss ssss
//
// "cc" is the tag command get, set or query. The tagging unit follows. The
// tag specifier itself is contained in the lowest 15 bits.
// Internal tags are marked with an i=1, external tags marked with an i=0.
// The difference between internal and external tagunits is, that external
// units have a type bit each, internal units only have numbers.
// Tags are type checked. Tags are constructed by the MKTAG_* macros and
// terminated by TAGDONE. The inline functions below do the type checking and
// are optimized to NOPs.  The r bit is used for reference tags.  These tags
// do not carry a value, but a reference to a more extendet structure;
//

#define TAG_VAL  0x00000000
#define TAG_GET  0x10000000
#define TAG_SET  0x20000000
#define TAG_QRY  0x30000000

#define TAG_REF  0x00008000

#define TAG_TYPE(x)	(x & 0x30000000)

#define ANYUNIT	0x4fff0000
#define MAIN_UNIT	0x00000000

#define MKTAGUNIT(unit, id)	\
	static const WORD unit##_ID	=	id;	\
	static const DWORD unit =  MKFLAG(16 + id);

#define GETTAGUNITS(tag)   XTBF(16, 12, tag)
#define USESTAGUNIT(tag, id) XTBF(16+id, tag)

#define MKITAGUNIT(unit, id)	\
	static const DWORD unit = 0x80000000L | (id << 16);

struct __far TAG {
	DWORD	id;
	DWORD	data;
	TAG (DWORD _id, DWORD _data) { data = _data; id = _id; };
	TAG() {};
#if !__EDG__ || __EDG_VERSION__<240
	~TAG() {}	// This is mainly used as a workaround for a certain C++ frontend compiler bug.
#endif
	};

inline BOOL __far & QRY_TAG(TAG __far * tag) {return *((BOOL __far *)(tag->data));}

	//
	// TAG terminator
	//
#define TAGDONE TAG(0,0)

DWORD FilterTags(TAG __far * tags, DWORD id, DWORD def);


#define MKTAG(name, unit, val, type)	\
	inline TAG SET_##name(type x) {return TAG(val | unit | TAG_SET, (DWORD)(x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET, (DWORD)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return (type)(tag->data);}	\
	inline type FVAL_##name(TAG __far * tags, type def) {return (type)(FilterTags(tags, val | unit | TAG_GET, (DWORD)def));}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET;	\
	static const DWORD CGET_##name = val | unit | TAG_GET;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY;

#define MKRTG(name, unit, val, type)	\
	inline TAG SET_##name(type __far &x) {return TAG(val | unit | TAG_SET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY | TAG_REF, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET | TAG_REF;	\
	static const DWORD CGET_##name = val | unit | TAG_GET | TAG_REF;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY | TAG_REF;


#if UNICODE

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

struct UnicodeBoardVersionInfo
	{
	TCHAR boardName[100];
	DWORD boardVersion;
	};

MKRTG(BOARD_VERSION_UNICODE, MAIN_UNIT, 2, UnicodeBoardVersionInfo)

#else

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

#endif

MKRTG(BOARD_VERSION,						MAIN_UNIT, 1,		BoardVersionInfo)
// 2 is used above!

MKRTG(BOARD_REGION_CODE,				MAIN_UNIT,	0x10,	BYTE)
MKRTG(BOARD_REGION_COUNT,				MAIN_UNIT,	0x11,	WORD)

MKRTG(BOARD_SPLIT_STREAM_SUPPORT,	MAIN_UNIT,	0x20, BOOL)

struct SoftwareVersionInfo
	{
	DWORD softwareVersion, softwareRevision;
	DWORD buildNumber;
	};

MKRTG(SOFTWARE_VERSION,		MAIN_UNIT,	0x30, SoftwareVersionInfo)

//
// Macros for easy access to TAG lists during parsing
//
// GETSET     : Simple get and set of a variable
// GETSETV    : Calls a function when the variable is changed
// GETSETVC   : Like GETSETV, but only calls on real changes
// GETSETC    : Sets a variable "changed" to TRUE when a variable is changed
// GETSETP    : Allows changing only when the virtual unit is passivated
// GETSETCF   : Ors a variable "changed" with a flag when the variable is changed
// GETONLY    : Allows only reading of a value
// GETINQUIRE : Calls an inquire function, the result is to be placed
//              in the pseudo variable "data".
//
// A typical TAG parsing routine will look like this
//
//	Error VirtualMPEGDecoder::Configure(TAG *tags)
//		{
//		PARSE_TAGS_START(tags)
//			GETSETP(MPEG_AUDIO_BITRATE,  params.audioBitRate);
//			GETSETP(MPEG_AUDIO_STREAMID, params.audioStreamID);
//			GETSETP(MPEG_VIDEO_STREAMID, params.videoStreamID);
//			GETSETP(MPEG_VIDEO_WIDTH,    params.videoWidth);
//			GETSETP(MPEG_VIDEO_HEIGHT,   params.videoHeight);
//			GETSETP(MPEG_VIDEO_FPS,      params.videoFPS);
//			GETSETP(MPEG_STREAM_TYPE,    params.streamType);
//
//			GETSET(MPEG_STREAM_HOOK, streamHook);
//
//			GETSETV(MPEG_LEFT_VOLUME,  leftVolume,  GNREASSERT(decoder->SetLeftVolume(leftVolume)));
//			GETSETV(MPEG_RIGHT_VOLUME, rightVolume, GNREASSERT(decoder->SetRightVolume(rightVolume)));
//			GETSETV(MPEG_AUDIO_MUTE,   audioMute,   GNREASSERT(decoder->MuteAudio(audioMute)));
//		PARSE_TAGS_END
//
//		GNRAISE_OK;
//		}
//




MKTAGUNIT(PIP_UNIT,            0)
MKTAGUNIT(VIDEO_ENCODER_UNIT,  1)
MKTAGUNIT(VIDEO_DECODER_UNIT,  2)
MKTAGUNIT(MPEG_DECODER_UNIT,   3)
MKTAGUNIT(TV_TUNER_UNIT,       4)
MKTAGUNIT(AUDIO_MIXER_UNIT,    5)
MKTAGUNIT(AUDIO_DECODER_UNIT,  6)
MKTAGUNIT(AUDIO_ENCODER_UNIT,  7)
MKTAGUNIT(JPEG_CODEC_UNIT,     8)
MKTAGUNIT(OSD_UNIT,				 9)
MKTAGUNIT(PANEL_UNIT,         10)
MKTAGUNIT(COMMUNICATION_UNIT, 11)
// DO NOT USE 12 or 13 due to contention with tag type
MKTAGUNIT(MPEG_ENCODER_UNIT,  14)

#define VIDEO_CHIP_UNIT			(VIDEO_ENCODER_UNIT | VIDEO_DECODER_UNIT)
#define AUDIO_STREAMDEV_UNIT	(AUDIO_ENCODER_UNIT | AUDIO_DECODER_UNIT)

#define NUM_UNITS		12




//
// A hook is a generalized callback.  The receiver of the callback
// gets two parameters, first the hook itself (this may be used for
// caller specific data), and a hook specific data element.
//
// The callback function is _NOT_ a virtual function, but a function
// pointer.  This has been done, to avoid incompatibilities with
// traditional 'C'.
//
// A typical use for a hook would be a refill request for a buffer
// in a buffer based stream:
//
// typedef struct RefillMsgStruct
//    {void __far * data, long num, long actual} RefillMsg;
//
// MKHOOK(Refill, RefillMsg);
//
// The implementor of the hook may then add some additional data,
// to customize the hook:
//
// class FileRefillHook : public RefillHook {
//		private:
//			Error Refill(void __far * data, long num, long &actual);
//			friend Error Refill(RefillHook * me, RefillMsg data);
//			FILE 	*	file;
//    public:
//       FileRefillHook(FILE * file) : RefillHook(Refill);
//		};
//
//	Error Refill(RefillHook * me, RefillMsg data)
//		{
//		return (FileRefillHook *)me->Refill(data.data, data.num, data.actual);
//		};
//
//
// Note that you have to do a MakeProcInstance if your callback function is not
// inside a DLL.
//


class KWorkerQueue;

class GenericHook
	{
	protected:
		KWorkerQueue	*	queue;
	public:
		void Register(KWorkerQueue * queue) {this->queue = queue;}
	};



extern "C" {
__declspec(dllexport) void  WINAPI VDR_RegisterCallback(GenericHook * hook);
}

#define MKHOOK(name, type) \
	class __far name##Hook : public GenericHook { \
		public: \
			typedef Error (WINAPI * CallType)(name##Hook __far * me, type & data); \
		private: \
			CallType	call; \
			class KWorkerQueue	*	queue;	\
		public: \
			name##Hook(CallType call) {this->call = call;VDR_RegisterCallback(this);} \
	};





enum VideoStandard
	{
	VIDEOSTANDARD_MIN,
		VSTD_NTSC	 = 0,
		VSTD_PAL		 = 1,
		VSTD_SECAM	 = 2,
		VSTD_HDTV	 = 3,
		VSTD_UNKNOWN = 4,
	VIDEOSTANDARD_MAX = VSTD_UNKNOWN
	};

enum PALVideoSubStandard
	{
	PALVIDEOSUBSTANDARD_MIN	= 0,
		PALVSSTD_DEFAULT		= 0,
		PALVSSTD_BDGHI			= 1,
		PALVSSTD_N				= 2,
		PALVSSTD_NC				= 3,
	PALVIDEOSUBSTANDARD_MAX	= PALVSSTD_NC
	};

enum NTSCVideoSubStandard
	{
	NTSCVIDEOSUBSTANDARD_MIN	= 0,
		NTSCVSSTD_DEFAULT			= 0,
		NTSCVSSTD_NORMAL			= 1,
		NTSCVSSTD_PALM				= 2,
		NTSCVSSTD_443				= 3,
		NTSCVSSTD_JAPAN			= 4,
		NTSCVSSTD_PAL60			= 5,
	NTSCVIDEOSUBSTANDARD_MAX	= NTSCVSSTD_PAL60
	};

enum VideoSource
	{
	VIDEOSOURCE_MIN			= 0,
		VSRC_COMPOSITE			= 0,
		VSRC_SVIDEO				= 1,
		VSRC_SERIAL_DIGITAL	= 2,
	VIDEOSOURCE_MAX	= VSRC_SVIDEO
	};

enum VideoFormat
	{
	VIDEOFORMAT_MIN = 0,
		VFMT_YUV_422 = 0,
		VFMT_YUV_411 = 1,
		VFMT_YUV_420 = 2,
		VFMT_YUV_444 = 3,
		VFMT_RGB_444 = 4,
	VIDEOFORMAT_MAX = VFMT_RGB_444
	};

enum VideoBusFormat
	{
	VIDEOBUSFORMAT_MIN = 0,
		FBFM_YC16 = 0,
		FBFM_YC8  = 1,
	VIDEOBUSFORMAT_MAX = FBFM_YC8
	};


enum VideoLineMode
	{
	VIDEOLINEMODE_MIN		= 0,
		VLM_PROGRESSIVE	= 0,
		VLM_INTERLACED		= 1,
	VIDEOLINEMODE_MAX		= VLM_INTERLACED
	};

enum VideoMode
	{
	VIDEOMODE_MIN = 0,
		VMOD_RESET    = 0,
		VMOD_PATTERN  = 1,
		VMOD_CAPTURE  = 2,
		VMOD_PLAYBACK = 3,
		VMOD_PATTERNSYNC = 4,
	VIDEOMODE_MAX = VMOD_PATTERNSYNC
//	ModeForceReprogramming   // this one internal use only
	};

enum VideoSampleMode
	{
	VIDEOSAMPLEMODE_MIN = 0,
		VSAMOD_CCIR	= 0,
		VSAMOD_SQP	= 1,
	VIDEOSAMPLEMODE_MAX = VSAMOD_SQP
	};

enum VideoField
	{
	VIDEOFIELD_MIN = 0,
		VFLD_SINGLE = 0,
		VFLD_ODD    = 1,
		VFLD_EVEN   = 2,
	VIDEOFIELD_MAX = VFLD_EVEN
	};

enum VideoMuxSource
	{
	VIDEOMUXSRC_MIN = 0,
		VIDEOMUXSRC_INTERNAL = 0,
		VIDEOMUXSRC_NONE = 1,
		VIDEOMUXSRC_EXTERNAL = 2,
	VIDEOMUXSRC_MAX = VIDEOMUXSRC_EXTERNAL
	};

enum VideoPixClockMode
	{
	VIDEOPIXCLK_MIN = 0,
		VIDEOPIXCLK_INTERNAL = 0,
		VIDEOPIXCLK_EXTERNAL = 1,
	VIDEOPIXCLK_MAX = VIDEOPIXCLK_EXTERNAL
	};


// The values of the following two enums are hardware-independent.

enum GrabFormat
	{
	GRABFORMAT_MIN = 0,
		VGRB_MJPEG    = 0,
		VGRB_RGB_888x = 1,
		VGRB_RGB_888  = 2,
		VGRB_RGB_565  = 3,
		VGRB_RGB_555  = 4,
		VGRB_YUV_422  = 5,
	GRABFORMAT_MAX = VGRB_YUV_422
	};

enum PIPFormat
	{
	PIPFORMAT_MIN = 0,
		PFMT_RGB_888x	= 0,
		PFMT_RGB_888	= 1,
		PFMT_RGB_565	= 2,
		PFMT_RGB_555	= 3,
		PFMT_YUV_422	= 4,
		PFMT_UVY_422	= 5,
		PFMT_PALETTE_8	= 6,
		PFMT_OTHER		= 7,
	PIPFORMAT_MAX = PFMT_OTHER
	};


struct HardVideoParams
	{
	int totalWidth,
	    totalHeight,
	    activeWidth,
	    activeHeight;   // activeHeight must be even (interlace)
	BIT hsPol,          // can be 0 or 1
	    vsPol;          // can be 0 or 1
	int hStart,
	    hEnd,           // hEnd = hStart + activeWidth - 1
	    vStart,
	    vEnd;           // vEnd = vStart + activeHeight/2 - 1
	BIT oddFirst;
	};


// These are defines for TV standard (CCIR) dependent sizes.

const HardVideoParams NTSCParams =
	{
	858, 525,
	720, 480,
	0,   0,
	123, 123+720-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALParams =
	{
	864, 625,
	720, 576,
	0,   0,
	133, 133+720-1,
	46,  46+576-1,
	FALSE
	};


// These are defines for TV standard (square pixel) dependent sizes.

const HardVideoParams NTSCSquareParams =
	{
	780, 525,
	640, 480,
	1,   1,
	75,  75+640-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALSquareParams =
	{
	944, 625,
	768, 576,
	1,   1,
	83,  83+768-1,
	34,  34+576-1,
	FALSE
	};


// Video Port specific definitions

// Possible video formats on video port (format field in VideoPortCaps struct)
#define VP_FMT_RGB_555		MKFLAG(0)
#define VP_FMT_RGB_565		MKFLAG(1)
#define VP_FMT_CCIR_422		MKFLAG(2)
#define VP_FMT_YUV_411		MKFLAG(3)
#define VP_FMT_YUV_420		MKFLAG(4)
#define VP_FMT_YONLY_400	MKFLAG(5)
#define VP_FMT_RGB_888_24	MKFLAG(6)
#define VP_FMT_RGB_888_32	MKFLAG(7)
#define VP_FMT_RGB_332		MKFLAG(8)
#define VP_FMT_ACCUPAK		MKFLAG(9)
#define VP_FMT_DYUV			MKFLAG(10)

// Protocols
#define VP_PORT_DI_8A		MKFLAG(0)
#define VP_PORT_DIV_8A		MKFLAG(1)
#define VP_PORT_DE_8A		MKFLAG(2)
#define VP_PORT_SI_8A		MKFLAG(3)
#define VP_PORT_SIV_8A		MKFLAG(4)
#define VP_PORT_SE_8A		MKFLAG(5)
#define VP_PORT_16A			MKFLAG(6)
#define VP_PORT_V_16A		MKFLAG(7)
#define VP_PORT_FIREWIRE	MKFLAG(8)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_PORT_DUMMY		MKFLAG(9)

// generate from the ones above!
//#define VP_PROT_BROOKTREE
//#define VP_PROT_PHILIPS

// Special connection features
#define VP_FEAT_INVERTPOLARITY	MKFLAG(0)
#define VP_FEAT_INTERLACED			MKFLAG(1)
#define VP_FEAT_TELETEXT			MKFLAG(2)
#define VP_FEAT_CLOSEDCAPTION		MKFLAG(3)
#define VP_FEAT_E_HREFH_VREFH		MKFLAG(4)
#define VP_FEAT_E_HREFH_VREFL		MKFLAG(5)
#define VP_FEAT_E_HREFL_VREFH		MKFLAG(6)
#define VP_FEAT_E_HREFL_VREFL		MKFLAG(7)
#define VP_FEAT_COLORCONTROL		MKFLAG(8)
#define VP_FEAT_BOB					MKFLAG(9)
#define VP_FEAT_WEAVE				MKFLAG(10)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_FEAT_DUMMY					MKFLAG(11)

struct VideoPortCaps
	{
	DWORD	videoFormat;		// Video format on port connection

	DWORD	protocol;			// Communication protocol(s)
	DWORD	connFeatures;		// Special features for the connection

	DWORD	fieldWidth;			// Maximum total transfer width of one field
	DWORD	vbiWidth;			// Maximum transfer width for VBI information
	DWORD	fieldHeight;		// Maximum total transfer height of one field

	DWORD	usPerField;			// Shortest possible time between two VREFs in microseconds
	DWORD	pixelsPerSecond;	// Number of pixels per second

	DWORD	displayOnly;		// The VGA can only display, but not capture.

	DWORD	clrControls;		// Will contain possible color controls
	};




MKTAG(PIP_VIDEOSTANDARD,	PIP_UNIT,	0x00000001, VideoStandard)
MKTAG(PIP_WINDOW,				PIP_UNIT,	0x00000002, HWND)

	//
	// Source region, relative to active display
	//
MKTAG(PIP_SOURCE_LEFT,		PIP_UNIT,	0x00000003, int)
MKTAG(PIP_SOURCE_TOP,		PIP_UNIT,	0x00000004, int)
MKTAG(PIP_SOURCE_WIDTH,		PIP_UNIT,   0x00000005, int)
MKTAG(PIP_SOURCE_HEIGHT,	PIP_UNIT,   0x00000006, int)

	//
	// Destination region, relative to current window
	//
MKTAG(PIP_DEST_LEFT,			PIP_UNIT,	0x00000007, int)
MKTAG(PIP_DEST_TOP,			PIP_UNIT,	0x00000008, int)
MKTAG(PIP_DEST_WIDTH,		PIP_UNIT,   0x00000009, int)
MKTAG(PIP_DEST_HEIGHT,		PIP_UNIT,   0x0000000A, int)

MKTAG(PIP_ADAPT_CLIENT_SIZE, PIP_UNIT, 0x0000000B, BOOL)
MKTAG(PIP_ADAPT_SOURCE_SIZE, PIP_UNIT, 0x0000000C, BOOL)
MKTAG(PIP_SCREEN_DEST,     PIP_UNIT,   0x0000000D, BOOL)
MKTAG(PIP_SAMPLEMODE,		PIP_UNIT,	0x0000000E, VideoSampleMode)
MKTAG(PIP_HOFFSET,			PIP_UNIT,	0x0000000F, int)
MKTAG(PIP_VOFFSET,			PIP_UNIT,	0x00000010, int)
MKTAG(PIP_ALWAYS_OVERLAY,	PIP_UNIT,	0x00000011, BOOL)
MKTAG(PIP_COLORKEY_COLOR,	PIP_UNIT,	0x00000012, DWORD)
MKTAG(PIP_COLORKEYED,		PIP_UNIT,	0x00000013, BOOL)

	//
	// Display region, relative to the destination rectangle
	//
MKTAG(PIP_DISPLAY_LEFT,		PIP_UNIT,	0x00000014, short)
MKTAG(PIP_DISPLAY_TOP,		PIP_UNIT,	0x00000015, short)
MKTAG(PIP_DISPLAY_WIDTH,	PIP_UNIT,	0x00000016, short)
MKTAG(PIP_DISPLAY_HEIGHT,	PIP_UNIT,	0x00000017, short)

MKTAG(PIP_COLORKEY_INDEX,	PIP_UNIT,	0x00000018, DWORD)

// Make sure to set physical, bytesPerRow and pixelFormat at the same time when enabling this:
MKTAG (PIP_OFFSCREEN_OVERRIDE,		PIP_UNIT, 0x00000019, BOOL)
MKTAG (PIP_OFFSCREEN_BASE,				PIP_UNIT, 0x0000001a, void __far *)
MKTAG (PIP_OFFSCREEN_BASE_LINEAR,	PIP_UNIT, 0x0000001b, DWORD)		// Use a 32bit flat pointer
MKTAG (PIP_OFFSCREEN_BYTES_PER_ROW,	PIP_UNIT, 0x0000001c, WORD)
MKTAG (PIP_OFFSCREEN_PIXEL_FORMAT,	PIP_UNIT, 0x0000001d, PIPFormat)

struct FieldDisplayMsg
	{
	DWORD	fieldCnt;
	};

MKHOOK(FieldDisplay, FieldDisplayMsg);

MKTAG (PIP_FIELD_DISPLAY_HOOK,		PIP_UNIT, 0x0000001e, FieldDisplayHook *)

MKTAG (PIP_IS_POSSIBLE,					PIP_UNIT, 0x0000001f, BOOL)



#define PCCF_BRIGHTNESS					0x00000001l
#define PCCF_CONTRAST					0x00000002l
#define PCCF_HUE							0x00000004l
#define PCCF_SATURATION					0x00000008l
#define PCCF_SHARPNESS					0x00000010l
#define PCCF_GAMMA						0x00000020l
#define PCCF_RED_BRIGHTNESS			0x00001000l
#define PCCF_BLUE_BRIGHTNESS			0x00002000l
#define PCCF_GREEN_BRIGHTNESS			0x00004000l



MKTAG (PIP_COLORCONTROL,				PIP_UNIT, 0x00000020, WORD)			// Get only tag to query color control support
MKTAG (PIP_BRIGHTNESS,					PIP_UNIT, 0x00000021, WORD)
MKTAG (PIP_CONTRAST,						PIP_UNIT, 0x00000022, WORD)
MKTAG (PIP_SATURATION,					PIP_UNIT, 0x00000023, WORD)
MKTAG (PIP_HUE,							PIP_UNIT, 0x00000024, WORD)
MKTAG (PIP_GAMMA,							PIP_UNIT, 0x00000025, WORD)			// Gamma correction
MKTAG (PIP_SHARPNESS,					PIP_UNIT, 0x00000026, WORD)
MKTAG (PIP_COLORENABLE,					PIP_UNIT, 0x00000027, BOOL)			// Used to toggle between B/W and color

// Use these to adjust brightness individually for R/G/B (only works with special VGAs)
MKTAG (PIP_RED_BRIGHTNESS,				PIP_UNIT, 0x00000028, WORD)
MKTAG (PIP_BLUE_BRIGHTNESS,			PIP_UNIT, 0x00000029, WORD)
MKTAG (PIP_GREEN_BRIGHTNESS,			PIP_UNIT, 0x0000002a, WORD)

// Used to crop the source rectangle when ADAPT_SOURCE_SIZE is TRUE
MKTAG (PIP_SOURCE_CROP_LEFT,			PIP_UNIT, 0x0000002b, WORD)
MKTAG (PIP_SOURCE_CROP_TOP,			PIP_UNIT, 0x0000002c, WORD)
MKTAG (PIP_SOURCE_CROP_RIGHT,			PIP_UNIT, 0x0000002d, WORD)
MKTAG (PIP_SOURCE_CROP_BOTTOM,		PIP_UNIT, 0x0000002e, WORD)



// Error definitions.
#define GNR_DMA_PIP_NOT_POSSIBLE			MKERR(ERROR, PIP, GENERAL, 0x01)		// Current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED		MKERR(ERROR, PIP, GENERAL, 0x02)		// Desired video standard (e.g. SECAM) not supported.
#define GNR_PIP_NOT_RUNNING				MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX				MKERR(ERROR, PIP, GENERAL, 0x04)		// No optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE					MKERR(ERROR, PIP, GENERAL, 0x05)		// Destination rectangle too small or too big.
#define GNR_WRONG_GRAB_SIZE				MKERR(ERROR, PIP, GENERAL, 0x06)		// Dimensions of frame to grab are too big.
#define GNR_NO_VBLANK_IRQ					MKERR(ERROR, PIP, GENERAL, 0x07)		// An expected VBlank IRQ did not occur.
#define GNR_GRAB_TIMEOUT					MKERR(ERROR, PIP, GENERAL, 0x08)		// A timeout occurred during grabbing a frame.
#define GNR_WRONG_GRAB_FORMAT				MKERR(ERROR, PIP, GENERAL, 0x09)		// An unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// Desired video sample mode not supported
#define GNR_VP_ERROR							MKERR(ERROR, PIP, GENERAL, 0x0b)		// General error with Video Port
#define GNR_VP_NO_PORT_MATCH				MKERR(ERROR, PIP, GENERAL, 0x0c)		// Video source does not match Video Port
#define GNR_VP_HARDWARE_IN_USE			MKERR(ERROR, PIP, GENERAL, 0x0d)		// Video Port Hardware in use
#define GNR_VPM_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0e)		// General error with VPM services
#define GNR_VPE_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0f)		// General error with DirectX5/VPE services
#define GNR_NOT_ENOUGH_VIDEO_MEMORY		MKERR(ERROR, PIP, MEMORY,  0x10)
#define GNR_NO_OVERLAY_HARDWARE			MKERR(ERROR, PIP, GENERAL, 0x11)
#define GNR_OVERLAY_BUSY					MKERR(ERROR, PIP, BUSY,    0x12)
#define GNR_PRIMARY_NOT_AVAILABLE		MKERR(ERROR, PIP, BUSY,		0x13)






typedef struct StreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	DWORD captureTime;
	} StreamCaptureMsg;

MKHOOK(StreamCapture, StreamCaptureMsg);



typedef struct YStreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	WORD yCaptureCounter;
	} YStreamCaptureMsg;

MKHOOK(YStreamCapture, YStreamCaptureMsg);









MKTAG (VID_VIDEOSTANDARD,				VIDEO_CHIP_UNIT, 0x0001, VideoStandard)
MKTAG (VID_MODE,							VIDEO_CHIP_UNIT, 0x0002, VideoMode    )
MKTAG (VID_EXTSYNC,						VIDEO_CHIP_UNIT, 0x0003, BOOL         )
MKTAG (VID_PAL_VIDEOSUBSTANDARD,		VIDEO_CHIP_UNIT, 0x0004, PALVideoSubStandard)
MKTAG (VID_NTSC_VIDEOSUBSTANDARD,	VIDEO_CHIP_UNIT, 0x0005, NTSCVideoSubStandard)














MKTAG (ENC_SAMPLEMODE,  VIDEO_ENCODER_UNIT, 0x0001001, VideoSampleMode)
MKTAG (ENC_HOFFSET,     VIDEO_ENCODER_UNIT, 0x0001002, int)
MKTAG (ENC_VOFFSET,     VIDEO_ENCODER_UNIT, 0x0001003, int)

// The idle screen mapping depends on the specific video encoder. First ask
// for the number of entries via GET_ENC_IDLE_NUMBER, then allocate enough
// space to hold ENC_IDLE_NUMBER times a struct VideoEncoderIdleEntry,
// then call GET_ENC_IDLE_ENTRY to get an array of these structs filled
// with ENC_IDLE_NUMBER entries.

#define VIDENC_IdleNameMaxSize  40

struct __far VideoEncoderIdleEntry
	{
	int number;   // in increasing order
	TCHAR name[VIDENC_IdleNameMaxSize];
	};

MKTAG (ENC_IDLESCREEN,  VIDEO_ENCODER_UNIT, 0x0001004, int)   // global for all units
MKTAG (ENC_IDLE_NUMBER, VIDEO_ENCODER_UNIT, 0x0001005, int)   // global for all units
MKTAG (ENC_IDLE_ENTRY,  VIDEO_ENCODER_UNIT, 0x0001006, VideoEncoderIdleEntry __far *)   // global for all units

MKTAG (ENC_COPY_PROTECTION, VIDEO_ENCODER_UNIT, 0x00001007, int)

MKTAG (ENC_CHROMA_FILTER, VIDEO_ENCODER_UNIT, 0x00001008, DWORD)

MKTAG (ENC_SVIDEO_ACTIVE, VIDEO_ENCODER_UNIT, 0x00001009, BOOL)

MKTAG (ENC_ACTIVE_MUX_SRC, VIDEO_ENCODER_UNIT, 0x0003000, VideoMuxSource)
	// VIDEOMUXSRC_INTERNAL or VIDEOMUXSRC_EXTERNAL
MKTAG (ENC_LINE_MODE, VIDEO_ENCODER_UNIT, 0x0003001, VideoLineMode)
	// VLM_PROGRESSIVE or VLM_INTERLACED
MKTAG (ENC_PIXCLK_MODE, VIDEO_ENCODER_UNIT, 0x0003002, VideoPixClockMode)
	// VIDEOPIXCLK_INTERNAL or VIDEOPIXCLK_EXTERNAL
MKTAG (ENC_EMBEDDED_SYNC, VIDEO_ENCODER_UNIT, 0x0003003, BOOL)
MKTAG (ENC_HSYNC_POLARITY, VIDEO_ENCODER_UNIT, 0x0003005, BOOL)
MKTAG (ENC_VSYNC_POLARITY, VIDEO_ENCODER_UNIT, 0x0003006, BOOL)
MKTAG (ENC_STARTACTIVEPIXEL_DELAY, VIDEO_ENCODER_UNIT, 0x0003007, int)


// Errors from the video encoder.

#define GNR_VENC_PARAMS						MKERR(ERROR, VENCODER, PARAMS,  0x01)
	// illegal parameters
#define GNR_MACROVISION_NOT_SUPPORTED	MKERR(ERROR, VENCODER, GENERAL, 0x02)

#define GNR_CC_NOT_SUPPORTED				MKERR(ERROR, VENCODER, GENERAL, 0x03)




class KernelStringBuffer;

class __far KernelString
	{
	private:
		KernelStringBuffer	*	buffer;
	public:
		KernelString(void);
		KernelString(const TCHAR __far * str);
		KernelString(const TCHAR ch);
		KernelString(const KernelString & str);
		KernelString(DWORD value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		KernelString(int value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		~KernelString();

		// returns the length of the string EXCLUDING the succeeding zero...
		int Length() const;

		long ToInt(int base = 10);
		DWORD ToUnsigned(int base = 10);


		BOOL Get(TCHAR __far * str, int len);

		KernelString & operator = (const TCHAR __far * str);
		KernelString & operator = (const KernelString str);

		friend KernelString operator+ (const KernelString u, const KernelString v);
		KernelString & operator+= (const KernelString u);
		friend KernelString operator* (const KernelString u, const int num);
		KernelString & operator*= (const int num);

		int Compare(const KernelString str);

		friend BOOL operator==(const KernelString u, const KernelString v);
		friend BOOL operator!=(const KernelString u, const KernelString v);
		friend BOOL operator<(const KernelString u, const KernelString v);
		friend BOOL operator>(const KernelString u, const KernelString v);
		friend BOOL operator<=(const KernelString u, const KernelString v);
		friend BOOL operator>=(const KernelString u, const KernelString v);

		friend KernelString operator << (const KernelString u, int index);
		friend KernelString operator >> (const KernelString u, int index);
		KernelString & operator <<= (int index);
		KernelString & operator >>= (int index);

		KernelString Seg(int start, int num) const;	// Extract seqment of string
		KernelString Caps(void);
		KernelString Head(int num) const;				// Return the first num characters
		KernelString Tail(int num) const;				// Return the last num characters

		int First(KernelString str) const;				// Find first occurrence of str
		int Next(KernelString str, int pos) const;	// Find next occurrence of str
		int Last(KernelString str) const;				// Find last occurrence of str
		int Prev(KernelString str, int pos) const;	// Find previous occurrence of str

		int First(TCHAR c) const;							// Find first occurrence of c (-1 if not found)
		int Next(TCHAR c, int pos) const;				// Find next occurrence of c (-1 if not found)
		int Last(TCHAR c) const;							// Find last occurrence of c (-1 if not found)
		int Prev(TCHAR c, int pos) const;				// Find prevoius occurrence of c (-1 if not found)
		BOOL Contains(TCHAR c) const;						// Test if character occurs in string

		// deletes spaces (and tabs) at beginning or end of string...
		KernelString Trim();

		TCHAR& operator[] (const int index);
		const TCHAR& operator[] (const int index) const;

//
// Unsafe functions
//
		operator TCHAR * (void);
	};



//
// REMARK:
// This class is passed through DLLs.
// So please:
//        - insert member variables only at the end of the class declaration
//			 - do not append virutal methods
//
// occures in krnlint.h


class __far KernelInt64
	{
	private:
		unsigned long lower;
		signed long upper;
	public:
		KernelInt64(void) {lower = 0; upper = 0;}
		KernelInt64(DWORD val) {lower = val; upper = 0;}
		KernelInt64(long val) {lower = val; upper = val < 0 ? -1 : 0;}
		KernelInt64(int val) {lower = val; upper = val < 0 ? -1 : 0;}
		KernelInt64(unsigned int val) {lower = val; upper =  0;}
      KernelInt64(const KernelInt64 & val) {lower = val.lower; upper = val.upper;}
      KernelInt64 & operator= (const KernelInt64 val) {lower = val.lower; upper = val.upper; return *this;}

		KernelInt64(unsigned long lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, signed long upper) {this->lower = lower; this->upper = upper;}

		KernelInt64(KernelString str, int base = 10);
		KernelString ToString(int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));

		long ToLong(void)
			{
			if      (upper == 0x00000000 && !(lower & 0x80000000)) return lower;
			else if (upper == 0xffffffff &&  (lower & 0x80000000)) return lower;
			else if (upper < 0) return 0x8000000;
			else return 0x7fffffff;
			}

		DWORD ToDWORD(void)
			{
			if (upper < 0) return 0;
			else if (upper > 0) return 0xffffffff;
			else return lower;
			}

		int ToInt(void)
			{
			if (*this < -32768) return -32768;
			else if (*this > 32767) return 32767;
			else return (int)lower;
			}


		DWORD Lower(void) {return lower;}
		long Upper(void) {return upper;}

		inline int operator! (void) const {return !lower && !upper;}
		inline KernelInt64 operator- (void) const;
		inline KernelInt64 operator~ (void) const {return KernelInt64(~lower, ~upper);}

		inline friend KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const KernelInt64 u, const long v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const long v);
		friend KernelInt64 operator* (const KernelInt64 u, const KernelInt64 v);
		friend KernelInt64 operator/ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator% (const KernelInt64 u, const KernelInt64 v);

		inline KernelInt64 & operator+= (const KernelInt64 u);
		inline KernelInt64 & operator-= (const KernelInt64 u);
		inline KernelInt64 & operator+= (const long u);
		inline KernelInt64 & operator-= (const long u);
		inline KernelInt64 & operator*= (const KernelInt64 u);
		inline KernelInt64 & operator/= (const KernelInt64 u);
		inline KernelInt64 & operator%= (const KernelInt64 u);

		inline KernelInt64 & operator++ (void);
		inline KernelInt64 & operator-- (void);

		inline friend KernelInt64 operator << (const KernelInt64 u, const int shl);
		inline friend KernelInt64 operator >> (const KernelInt64 u, const int shl);

		inline KernelInt64 & operator <<= (const int shl);
		inline KernelInt64 & operator >>= (const int shl);

		inline int Compare(const KernelInt64 u) const;

		friend BOOL operator==(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) >= 0;}

		friend KernelInt64 operator& (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower & v.lower, u.upper & v.upper);}
		friend KernelInt64 operator| (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower | v.lower, u.upper | v.upper);}

		KernelInt64 & operator&= (const KernelInt64 u) {lower &= u.lower; upper &= u.upper; return *this;}
		KernelInt64 & operator|= (const KernelInt64 u) {lower |= u.lower; upper |= u.upper; return *this;}
	};

inline KernelInt64 & KernelInt64::operator+= (const KernelInt64 u)
	{
	lower += u.lower;
	if (lower < u.lower)
		upper += u.upper+1;
	else
		upper += u.upper;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const KernelInt64 u)
	{
	unsigned long sum = lower - u.lower;
	if (sum > lower)
		upper -= u.upper+1;
	else
		upper -= u.upper;
	lower = sum;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator+= (const long u)
	{
	if (u < 0)
		*this -= -u;
	else
		{
		lower += u;
		if (lower < (DWORD)u)
			upper += 1;
		}
	return *this;
	}

inline KernelInt64 & KernelInt64::operator++ (void)
	{
	lower ++;
	if (!lower)
		upper ++;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-- (void)
	{
	if (!lower)
		upper --;
	lower --;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const long u)
	{
	if (u < 0)
		*this += -u;
	else
		{
		unsigned long sum = lower - u;
		if (sum > lower)
			upper -= 1;
		lower = sum;
		}
	return *this;
	}

inline KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v)
	{
	unsigned long sum = u.lower + v.lower;
	if (sum < u.lower)
		return KernelInt64(sum, u.upper + v.upper + 1);
	else
		return KernelInt64(sum, u.upper + v.upper);
	}

inline KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v)
	{
	unsigned long sum = u.lower - v.lower;
	if (sum > u.lower)
		return KernelInt64(sum, u.upper - v.upper - 1);
	else
		return KernelInt64(sum, u.upper - v.upper);
	}

inline KernelInt64 operator+ (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u - -v;
	else
		{
		unsigned long sum = u.lower + v;
		if (sum < u.lower)
			return KernelInt64(sum, u.upper + 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}

inline KernelInt64 operator- (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u + -v;
	else
		{
		unsigned long sum = u.lower - v;
		if (sum > u.lower)
			return KernelInt64(sum, u.upper - 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}


inline KernelInt64 operator+ (const long u, const KernelInt64 v)
	{
	if (u < 0)
		return v - -u;
	else
		{
		unsigned long sum = u + v.lower;
		if (sum < v.lower)
			return KernelInt64(sum, v.upper + 1);
		else
			return KernelInt64(sum, v.upper);
		}
	}

inline KernelInt64 operator- (const long u, const KernelInt64 v)
	{
	return u + -v;
	}

inline KernelInt64 KernelInt64::operator- (void) const
	{
	if (lower == 0)
		return KernelInt64(0, -upper);
	else
		return KernelInt64((DWORD)-(long)lower, ~upper);
	}

inline int KernelInt64::Compare(const KernelInt64 u) const
	{
	if (upper < u.upper) return -1;
	else if (upper > u.upper) return 1;
	else if (lower < u.lower) return -1;
	else if (lower > u.lower) return 1;
	else return 0;
	}

inline KernelInt64 operator<< (const KernelInt64 u, const int shl)
	{
	KernelInt64 v = u;
	v <<= shl;
	return v;
	}

inline KernelInt64 operator>> (const KernelInt64 u, const int shl)
	{
	KernelInt64 v = u;
	v >>= shl;
	return v;
	}

inline KernelInt64 & KernelInt64::operator*= (const KernelInt64 u)
	{
	*this = *this * u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator/= (const KernelInt64 u)
	{
	*this = *this / u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator%= (const KernelInt64 u)
	{
	*this = *this % u;
	return *this;
	}

inline KernelInt64 operator % (const KernelInt64 u, const KernelInt64 v)
	{
	return u - (u / v) * v;
	}

inline KernelInt64 & KernelInt64::operator<<= (const int shl)
	{
	int s = shl;

	while (s > 0)
		{
		upper <<= 1;
		if (lower & 0x80000000) upper |= 1;
		lower <<= 1;
		s--;
		}

	return *this;
	}

inline KernelInt64 & KernelInt64::operator>>= (const int shl)
	{
	int s = shl;

	while (s > 0)
		{
		lower >>= 1;
		if (upper & 0x00000001) lower |= 0x80000000;
		upper >>= 1;
		s--;
		}

	return *this;
	}


enum MPEGCommand {mpc_none, 	  		// 0x0
                  mpc_start,    		// 0x1
                  mpc_play,     		// 0x2
                  mpc_seek,     		// 0x3
                  mpc_stop,     		// 0x4
                  mpc_step,     		// 0x5
                  mpc_freeze,   		// 0x6
                  mpc_resync,   		// 0x7
                  mpc_resyncue, 		// 0x8
                  mpc_cue,				// 0x9
                  mpc_end,				// 0xA
                  mpc_params,			// 0xB
                  mpc_stepkey,		// 0xC
                  mpc_scan,			// 0xD
						mpc_reverse,		// 0xE
						mpc_trickplay,		// 0xF
						mpc_seekaudio,		// 0x10
						mpc_resyncaudio,	// 0x11
						mpc_audio_test		// 0x12	Audio tests : pink noise, test tone
						};

enum MPEGState   {mps_reset, mps_preempted, mps_initial,
                  mps_frozen, mps_playing, mps_stepping,
                  mps_seeking, mps_resyncing, mps_stopped,
                  mps_scanning, mps_trickplaying, mps_testing,
						mps_capturing};

enum MPEGElementaryStreamType
	{
	MST_VIDEO,
	MST_AUDIO,
	MST_SUBPICTURE
	};




//
// Commands and parameters:
//
//		none                  : do nothing
//    start                 : start the operation
//    play([1..1000] speed) : play at specific speed (1000 = normal)
//    seek                  : stop playback, go standby
//    stop                  : stop playback
//    step(int frames)      : step some frames
//    freeze                : freeze current frame
//    resync                : resync after seek
//    end                   : end the operation
//
// State transition diagram
//
//	INITIAL:		reset
//
//	SRCSTATE		COMMAND/EVENT		DSTSTATE		ACTION
//
//	reset			start					initial		Init MPEG Decoder, start transfering data
// 				default				reset
//
//	initial		play					playing		Start playing the MPEG Stream
//					...					frozen		Freeze after first I-Frame
//
//	frozen		play					playing		Continue playing from current location
//					seek					seeking		Complete operation, and stop playback
//       		step					stepping		Go to step mode
//					end					reset
//					stop					stopped
//					default				frozen
//
//	playing		play					leaping		Adjust playback speed if required
//											playing
//					seek					seeking		Complete operation and stop playback
//					end					reset
//					stop					stopped
//					default				playing
//
// leaping     default           playing
//
//	stepping		play					playing
//					seek					seeking
//					end					reset
//					stop					stopped
//					default				stepping
//											frozen
//
//	seeking		resync				resyncing
//					resyncue				cued
//					end					reset
//
//	resyncing	play					playing
//					...					frozen
//
//	stopped		play					initial
//					end					reset
//					default				stopped
//

struct MPEGStreamMsg {
	DWORD		size;
	};

struct MPEGSignalMsg {
	DWORD		position;
	};

struct MPEGIdleMsg {
	};

MKHOOK(MPEGStream, MPEGStreamMsg)
MKHOOK(MPEGSignal, MPEGSignalMsg)
MKHOOK(MPEGIdle,   MPEGIdleMsg)

typedef MPEGStreamHook	__far *	MPEGStreamHookPtr;
typedef MPEGSignalHook	__far *	MPEGSignalHookPtr;
typedef MPEGIdleHook		__far *	MPEGIdleHookPtr;

enum MPEGStreamType {audioOnly, videoOnly, multiplexed};

enum MPEGStreamMode {singleStream, dualStream};

enum MPEGAudioLayer
	{
	MPAUDLAYER_1,
	MPAUDLAYER_2,
	MPAUDLAYER_3							// = MP3
	};

enum MPEGStereoMode
	{
	MPSS_NORMAL,							// Select output of first (normal) stereo program
	MPSS_DEFAULT = MPSS_NORMAL,
	MPSS_SECOND_STEREO					// Select output of second stereo program
	};

MKTAG(MPEG_AUDIO_BITRATE,					MPEG_DECODER_UNIT,	0x0001, DWORD)
MKTAG(MPEG_AUDIO_STREAMID,					MPEG_DECODER_UNIT,	0x0002, BYTE)
MKTAG(MPEG_VIDEO_STREAMID,					MPEG_DECODER_UNIT,	0x0003, BYTE)
MKTAG(MPEG_VIDEO_WIDTH,						MPEG_DECODER_UNIT,	0x0004, WORD)
MKTAG(MPEG_VIDEO_HEIGHT,   				MPEG_DECODER_UNIT,   0x0005, WORD)
MKTAG(MPEG_VIDEO_FPS,      				MPEG_DECODER_UNIT,   0x0006, WORD)
MKTAG(MPEG_STREAM_TYPE,						MPEG_DECODER_UNIT,	0x0007, MPEGStreamType)
MKTAG(MPEG_STREAM_HOOK,						MPEG_DECODER_UNIT,	0x0008, MPEGStreamHookPtr)
MKTAG(MPEG_LEFT_VOLUME,    				MPEG_DECODER_UNIT,   0x0009, WORD)
MKTAG(MPEG_RIGHT_VOLUME,   				MPEG_DECODER_UNIT,   0x000A, WORD)
MKTAG(MPEG_AUDIO_MUTE,     				MPEG_DECODER_UNIT,   0x000B, BOOL)
MKTAG(MPEG_SIGNAL_HOOK,						MPEG_DECODER_UNIT,	0x000C, MPEGSignalHookPtr)
MKTAG(MPEG_SIGNAL_POSITION,				MPEG_DECODER_UNIT,	0x000D, DWORD)
MKTAG(MPEG_DONE_HOOK,						MPEG_DECODER_UNIT,	0x000E, MPEGSignalHookPtr)
MKTAG(MPEG_VIDEO_BITRATE,					MPEG_DECODER_UNIT,   0x000F, DWORD)
MKTAG(MPEG_STREAM_BITRATE,					MPEG_DECODER_UNIT,   0x0010, DWORD)
MKTAG(MPEG_INTRA_QUANTIZER_MATRIX,		MPEG_DECODER_UNIT,	0x0011, BYTE __far *)
MKTAG(MPEG_NON_INTRA_QUANTIZER_MATRIX,	MPEG_DECODER_UNIT,	0x0012, BYTE __far *)
MKTAG(MPEG_VIDEOSTANDARD,					MPEG_DECODER_UNIT,	0x0013, VideoStandard)

MKTAG(MPEG_STREAM_MODE,						MPEG_DECODER_UNIT,	0x0014, MPEGStreamMode)

MKTAG(MPEG_DISPLAY_WIDTH,					MPEG_DECODER_UNIT,	0x0020, WORD)
MKTAG(MPEG_DISPLAY_HEIGHT,					MPEG_DECODER_UNIT,	0x0021, WORD)

MKTAG(MPEG_VIDEO_BRIGHTNESS,				MPEG_DECODER_UNIT,	0x0022, WORD)
MKTAG(MPEG_VIDEO_CONTRAST,					MPEG_DECODER_UNIT,	0x0023, WORD)

MKTAG(MPEG_AUDIO_SAMPLERATE,				MPEG_DECODER_UNIT,	0x0024, WORD)
MKTAG(MPEG_IDLE_HOOK,						MPEG_DECODER_UNIT,	0x0025, MPEGIdleHookPtr)

MKTAG(MPEG_ASPECT_RATIO,					MPEG_DECODER_UNIT,	0x0026, WORD)
MKTAG(MPEG_SUPPORTS_HIRES_STILL,			MPEG_DECODER_UNIT,	0x0027, BOOL)

MKTAG(MPEG_CURRENT_STREAM_SEGMENT,		MPEG_DECODER_UNIT,	0x0028, DWORD)
MKTAG(MPEG_FIRST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x0029, DWORD)
MKTAG(MPEG_LAST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x002a, DWORD)

MKTAG(MPEG_DISPLAY_MODE,					MPEG_DECODER_UNIT,   0x0030, VideoMode)

// Determines the audio layer contained in the MPEG data/to be decoded
MKTAG(MPEG_AUDIO_LAYER,						MPEG_DECODER_UNIT,	0x0031, MPEGAudioLayer)

// CRC check enable/disable for MPEG (e.g. MP3) decoding (default: FALSE (off))
MKTAG(MPEG_CRC_CHECK,						MPEG_DECODER_UNIT,	0x0032, BOOL)

// Controls second stereo mode for MPEG audio material
MKTAG(MPEG_AUDIO_STEREO_MODE,				MPEG_DECODER_UNIT,	0x0033, MPEGStereoMode)



enum AC3BassConfig
	{
	AC3BC_NO_REDIRECTION,
	AC3BC_REDIRECT_CENTER_BASS_TO_LEFT_AND_RIGHT,
	AC3BC_REDIRECT_LEFT_RIGHT_CENTER_BASS_TO_SUBWOOFER,
	AC3BC_REDIRECT_CENTER_BASS_TO_SUBWOOFER
	};

enum AC3SpeakerConfig
	{
	AC3SC_20_SURROUND_COMPATIBLE,
	AC3SC_10,
	AC3SC_20_NORMAL,
	AC3SC_30,
	AC3SC_21,
	AC3SC_31,
	AC3SC_22,
	AC3SC_32,
	AC3SC_KARAOKE		// This may only be available for MPEG-2 audio, but it is
							// added to the AC3 settings to avoid introducing new tags
	};

enum AC3DualModeConfig
	{
	AC3DMDM_DEFAULT,	// default is stereo
	AC3DMDM_STEREO = AC3DMDM_DEFAULT,
	AC3DMDM_CHANNEL1,	// channel 1 on both L/R
	AC3DMDM_CHANNEL2, // channel 2 on both L/R
	AC3DMDM_MIX			// mix channel 1 and 2 to mono, output on both L/R
	};

enum AC3KaraokeConfig
	{
	AC3KARA_AWARE,
	AC3KARA_DEFAULT,
	AC3KARA_OFF = AC3KARA_DEFAULT,
	AC3KARA_MULTICHANNEL	= 3,
	AC3KARA_CAPABLE_NO_VOCAL,
	AC3KARA_CAPABLE_V1,
	AC3KARA_CAPABLE_V2,
	AC3KARA_CAPABLE_BOTH_VOCAL
	};

enum DolbyProLogicConfig
	{
	DPLCFG_OFF,
	DPLCFG_DEFAULT = DPLCFG_OFF,
	DPLCFG_3_0 = 3,	// LCR three stereo
	DPLCFG_2_1,			// LRS phantom (= center not used)
	DPLCFG_3_1,			// LCRS
	DPLCFG_2_2,			// LRSS phantom
	DPLCFG_3_2			// LCRSS
	};

enum DolbyProLogicMode
	{
	DPLMODE_AUTOMATIC,	// Decoding depends on input fed into the PL decoder
	DPLMODE_DEFAULT = DPLMODE_AUTOMATIC,
	DPLMODE_ON,				// force it always on
	DPLMODE_OFF				// always off
	};

enum AC3DynamicRange
	{
	AC3DYNRG_DEFAULT,
	AC3DYNRG_COMPRESSED = AC3DYNRG_DEFAULT,	// Dynamic range sclae factor taken from MPEG-2 AC3 stream
	AC3DYNRG_MAXIMUM									// Always use full dynamic range
	};

// AC3 "acmod" property
enum AC3AudioCodingMode
	{
	AC3ACMOD_DUALMONO,
	AC3ACMOD_1_0,
	AC3ACMOD_2_0,
	AC3ACMOD_3_0,
	AC3ACMOD_2_1,
	AC3ACMOD_3_1,
	AC3ACMOD_2_2,
	AC3ACMOD_3_2,
	AC3ACMOD_UNKNOWN
	};

enum KaraokeVoiceEffectType
	{
	KARAOKE_VOICE_EFFECT_NONE = 0,
	KARAOKE_VOICE_EFFECT_ECHO = 1,
	KARAOKE_VOICE_EFFECT_CHORUS = 2,
	KARAOKE_VOICE_EFFECT_REVERB = 3
	};


enum KaraokeWordSizeType
	{
	KARAOKE_WORD_SIZE_16bit = 0,
	KARAOKE_WORD_SIZE_18bit = 1,
	KARAOKE_WORD_SIZE_20bit = 2,
	KARAOKE_WORD_SIZE_24bit = 3
	};

enum KaraokeJustificationType
	{
	KARAOKE_START_JUSTIFIED = 0,
	KARAOKE_END_JUSITIFIED  = 1
	};

enum KaraokePCMOutputModeType
	{
	KARAOKE_PCM_OUTPUT_MODE_2Channel = 0,
	KARAOKE_PCM_OUTPUT_MODE_6Channel = 1
	};

enum KaraokePCMByteOrderType
	{
	KARAOKE_PCM_BYTE_ORDER_LSB_FIRST = 0,
	KARAOKE_PCM_BYTE_ORDER_MSB_FIRST = 1
	};

enum KaraokeVoiceSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_12kHz = 0,
	KARAOKE_SAMPLING_FREQUENCY_11_025KHz = 1,
	KARAOKE_SAMPLING_FREQUENCY_10kHz = 2
	};

enum KaraokeMusicSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_48kHz = 0,
	KARAOKE_SAMPLING_FREQUENCY_44_1KHz = 1,
	KARAOKE_SAMPLING_FREQUENCY_32kHz = 2
	};

enum KaraokeSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_256Fs = 0,
	KARAOKE_SAMPLING_FREQUENCY_384Fs = 1
	};






enum SPUButtonState
	{
	SBS_DISABLED,
	SBS_SELECTED,
	SBS_ACTIVATED
	};

struct MPEG2SPUCommandMsg {
	DWORD		pts;
	int		command;
	};

MKHOOK(MPEG2SPUCommand, MPEG2SPUCommandMsg)

typedef MPEG2SPUCommandHook	__far *	MPEG2SPUCommandHookPtr;

//
//  Error definitions
//

#define GNR_DISPLAY_MODE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x00)
// The display mode could not be set

#define GNR_AUDIO_TYPE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x01)
// The audio format is not supported

#define GNR_NO_SPDIF_HARDWARE								MKERR(ERROR, MPEG, HARDWARE, 0x02)
// We do not SPDIF hardware

#define GNR_FRAME_ADVANCE_BOUNDARY_REACHED			MKERR(WARNING, MPEG, BOUNDS, 0x03)

enum MPEG2PresentationMode
	{
	MPM_FULLSIZE,
	MPM_LETTERBOXED,
	MPM_PANSCAN,
	MPM_FULLSIZE16by9
	};

enum SPDIFHandling
	{
	SPDIFH_DEFAULT,			// On when playback is running, off in all other cases
	SPDIFH_ON,					// Always physically on
	SPDIFH_OFF					// Always physically off (line idle)
	};

// This can be specified for each audio type
enum SPDIFOutputMode
	{
	SPDIFOM_DEFAULT,			// AC3: compressed, LPCM: decompressed, idle: NULL output
	SPDIFOM_DECOMPRESSED,	// Force decompressed output, even for AC3
	SPDIFOM_MUTE_NULL,		// Force mute with NULL output, if SPDIF_ON
	SPDIFOM_OFF					// Physically off
	};

enum SPDIFCopyMode
	{
	SPDIFCM_DEFAULT,			// Use system's default (transfer rights from source material to output)
	SPDIFCM_NO_COPIES,		// do not allow any copies
	SPDIFCM_ONE_GENERATION,	// allow one generation of copies
	SPDIFCM_UNRESTRICTED		// no copy restrictions
	};

enum MPEG2SplitStreamType
	{
	MP2SST_DVD_ENCRYPTED,
	MP2SST_PROGRAM,
	MP2SST_PES,
	MP2SST_ELEMENTARY
	};

enum MPEG2PESType
	{
	MP2PES_ELEMENTARY,
	MP2PES_DVD,
	MP2PES_MPEG
	};

// Basic Audio Source Type
enum MPEG2AudioType
	{
	MP2AUDTYP_DEFAULT,		// means: use MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM tags to determine audio type
	MP2AUDTYP_MPEG,			// MPEG(-1) all layers
	MP2AUDTYP_MPEG2,
	MP2AUDTYP_AC3,
	MP2AUDTYP_LPCM,			// includes CDDA (set # of bits and sample rate accordingly)
	MP2AUDTYP_DTS,
	MP2AUDTYP_SDDS,
	MP2AUDTYP_DTS_CDDA,		// CDDA with DTS information

	MP2AUDTYP_NUMBER_OF_TYPES
	};

// Virtual Surround ("Spatializer") modes
enum MPEG2AudioSpatializer
	{
	MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_NONE = MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_SRS_TS_3D			// SRS True Surround or 3D sound, depending on source material
	};

// PCM Output Configurations (= Bass Redirection Schemes)
enum PCMOutputConfig
	{
	PCMOCFG_DEFAULT,	// ALL, scaled, is default
	PCMOCFG_ALL = PCMOCFG_DEFAULT,
	PCMOCFG_LSW,
	PCMOCFG_LLR,
	PCMOCFG_SLP,
	PCMOCFG_SUM,		// subwoofer = sum of all input channels
	PCMOCFG_BYP			// Bypass
	};

// Downsample mode for 96kHz LPCM
enum PCM96DownsampleMode
	{
	PCM96DWNS_DEFAULT,
	PCM96DWNS_DOWN_48KHZ = PCM96DWNS_DEFAULT,	// sample down to 48kHz by default
	PCM96DWNS_NONE										// no downsampling, play back using 96kHz
	};


// Program Format Flags for tag MPEG2_AUDIO_PROGRAM_FORMAT
#define AUDPF_PROLOGIC			MKFLAG(0)	// Indicates if Pro Logic Decoding is active or not
#define AUDPF_LEFT				MKFLAG(1)	// Shows if program contains
#define AUDPF_RIGHT				MKFLAG(2)
#define AUDPF_CENTER				MKFLAG(3)
#define AUDPF_LFE					MKFLAG(4)
#define AUDPF_LEFT_SURROUND	MKFLAG(5)
#define AUDPF_RIGHT_SURROUND	MKFLAG(6)
#define AUDPF_MONO_SURROUND	MKFLAG(7)


//
//  CDDA Data Format
//  Describes formats supported by decoder
//

#define CDDADF_AUDIO_ONLY			MKFLAG(0)			// Only audio data (corresponds to LPCM, 2 ch, 16 Bit, 44.1 kHz), default
#define CDDADF_AUDIO_SUBCHANNEL	MKFLAG(1)			// For each block first audio data (2352 bytes), then subchannel (98 bytes)
#define CDDADF_SUBCHANNEL_AUDIO	MKFLAG(2)			// For each block first subchannel (98 bytes), then audio data (2352 bytes)
#define CDDADF_DEFAULT				CDDADF_AUDIO_ONLY

struct AudioTypeConfig
	{
	union
		{
		struct
			{
			SPDIFOutputMode	spdifOutMode : 3;
			// ...can be expanded up to size of a DWORD...
			} config;

		DWORD	dummy;
		};

	friend BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b);
	friend BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b);

	operator DWORD (void) {return dummy;}

	AudioTypeConfig(DWORD arg) {dummy = arg;}
	AudioTypeConfig(void) {dummy = 0;}
	AudioTypeConfig(SPDIFOutputMode initMode)
		{
		config.spdifOutMode = initMode;
		// ...
		}
	};

inline BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy == b.dummy);
	}

//static inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy != b.dummy);
	}

struct MPEGDataSizePair
	{
	HBPTR		data;
	DWORD		size;
	int		timeStamp;
	DWORD		pad0;
	};


enum ForcedAspectRatio
	{
	FORCED_AR_DEFAULT	= 0,
	// 1 left out. Do not change the following two assignments:
	FORCED_AR_4_BY_3	= 2,
	FORCED_AR_16_BY_9	= 3
	};

enum FrameRateValue
	{
	FRV_23976 = 1,
	FRV_24000 = 2,
	FRV_25000 = 3,
	FRV_29970 = 4,
	FRV_30000 = 5,
	FRV_50000 = 6,
	FRV_59940 = 7,
	FRV_60000 = 8
	};

#define MP2SR_SCALE_BITS		0x80000L
#define MP2SR_SCALE_BYTES		0x10000L
#define MP2SR_SCALE_WORDS		0x08000L
#define MP2SR_SCALE_DWORDS		0x04000L
#define MP2SR_SCALE_DVDPES		0x00020L


// Bits for audio speaker test bitfield (MPEG2_AUDIO_TEST_SPEAKER_SELECT)
#define AUDIO_TEST_LEFT_SPEAKER				0x01
#define AUDIO_TEST_RIGHT_SPEAKER				0x02
#define AUDIO_TEST_CENTER_SPEAKER			0x04
#define AUDIO_TEST_SUBWOOFER_SPEAKER		0x08
#define AUDIO_TEST_LEFT_SURROUND_SPEAKER	0x10
#define AUDIO_TEST_RIGHT_SURROUND_SPEAKER	0x20



MKTAG(MPEG2_AUDIO_AC3,						MPEG_DECODER_UNIT,	0x1001, BOOL)
MKTAG(MPEG2_AUDIO_AC3_STREAMID,			MPEG_DECODER_UNIT,	0x1002, BYTE)
MKTAG(MPEG2_CODING_STANDARD,	  		   MPEG_DECODER_UNIT,	0x1003, BOOL)

MKTAG(MPEG2_AC3_BASS_CONFIG,				MPEG_DECODER_UNIT,	0x1004, AC3BassConfig)
MKTAG(MPEG2_AC3_SPEAKER_CONFIG,			MPEG_DECODER_UNIT,	0x1005, AC3SpeakerConfig)
MKTAG(MPEG2_AC3_CENTER_DELAY,				MPEG_DECODER_UNIT,	0x1006, WORD)
MKTAG(MPEG2_AC3_SURROUND_DELAY,			MPEG_DECODER_UNIT,	0x1007, WORD)

MKTAG(MPEG2_AC3_CENTER_VOLUME,			MPEG_DECODER_UNIT,	0x1008, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_VOLUME,  MPEG_DECODER_UNIT,	0x1009, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_VOLUME,	MPEG_DECODER_UNIT,	0x100a, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_VOLUME,		MPEG_DECODER_UNIT,	0x100b, WORD)

MKTAG(MPEG2_AC3_DUAL_MODE_CONFIG,		MPEG_DECODER_UNIT,	0x100c, AC3DualModeConfig)
MKTAG(MPEG2_AC3_KARAOKE_CONFIG,			MPEG_DECODER_UNIT,	0x100d, AC3KaraokeConfig)

MKTAG(MPEG2_SPU_STREAMID,					MPEG_DECODER_UNIT,	0x1010, BYTE)
MKTAG(MPEG2_SPU_ENABLE,						MPEG_DECODER_UNIT,	0x1011, BOOL)

MKTAG(MPEG2_SPU_BUTTON_STATE,				MPEG_DECODER_UNIT,	0x1012, SPUButtonState)
MKTAG(MPEG2_SPU_BUTTON_LEFT,				MPEG_DECODER_UNIT,	0x1013, WORD)
MKTAG(MPEG2_SPU_BUTTON_TOP,				MPEG_DECODER_UNIT,	0x1014, WORD)
MKTAG(MPEG2_SPU_BUTTON_WIDTH,				MPEG_DECODER_UNIT,	0x1015, WORD)
MKTAG(MPEG2_SPU_BUTTON_HEIGHT,			MPEG_DECODER_UNIT,	0x1016, WORD)
MKTAG(MPEG2_SPU_BUTTON_SELECT_COLOR,	MPEG_DECODER_UNIT,	0x1017, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ACTIVE_COLOR,	MPEG_DECODER_UNIT,	0x1018, DWORD)
MKTAG(MPEG2_SPU_PALETTE_ENTRY,			MPEG_DECODER_UNIT,	0x1019, DWORD)
	// Palette Bits 0..7 Pen, 8..15 V, 16..23 U, 24..31 Y
MKTAG(MPEG2_SPU_COMMAND_HOOK,				MPEG_DECODER_UNIT,	0x101a, MPEG2SPUCommandHookPtr)
MKTAG(MPEG2_SPU_BUTTON_ID,					MPEG_DECODER_UNIT,	0x101b, WORD)
MKTAG(MPEG2_SPU_BUTTON_STARTTIME,		MPEG_DECODER_UNIT,	0x101c, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ENDTIME,			MPEG_DECODER_UNIT,	0x101d, DWORD)

MKTAG(MPEG2_AUDIO_LPCM,						MPEG_DECODER_UNIT,	0x1021, BOOL)
MKTAG(MPEG2_AUDIO_LPCM_STREAMID,			MPEG_DECODER_UNIT,	0x1022, BYTE)
MKTAG(MPEG2_LPCM_BITSPERSAMPLE,			MPEG_DECODER_UNIT,	0x1023, WORD)
MKTAG(MPEG2_LPCM_CHANNELS,					MPEG_DECODER_UNIT,	0x1024, WORD)

MKTAG(MPEG2_AUDIO_DTS_STREAMID,			MPEG_DECODER_UNIT,	0x1028, BYTE)

MKTAG(MPEG2_PRESENTATION_MODE,			MPEG_DECODER_UNIT,	0x1030, MPEG2PresentationMode)

MKTAG(MPEG2_DVD_STREAM_DEMUX,				MPEG_DECODER_UNIT,	0x1031, BOOL)
MKTAG(MPEG2_DVD_STREAM_ENCRYPTED,		MPEG_DECODER_UNIT,	0x1032, BOOL)


// Use this for overriding the default handling of switching ON/OFF SPDIF output
// (on decoders that can control SPDIF out)
MKTAG(MPEG2_SPDIF_HANDLING,				MPEG_DECODER_UNIT,	0x1034, SPDIFHandling)
MKTAG(MPEG2_SPDIF_OUTPUT_MODE,			MPEG_DECODER_UNIT,	0x1035, SPDIFOutputMode)
MKTAG(MPEG2_SPDIF_COPY_MODE,				MPEG_DECODER_UNIT,	0x1036, SPDIFCopyMode)

// This supercedes tags MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM, if available
MKTAG(MPEG2_AUDIO_TYPE,						MPEG_DECODER_UNIT,	0x103a, MPEG2AudioType)

// Specifies audio spatializing algorithm (e.g. SRS True Surround)
MKTAG(MPEG2_AUDIO_SPATIALIZER,			MPEG_DECODER_UNIT,	0x103b, MPEG2AudioSpatializer)

MKTAG(MPEG2_POSITION_SCALE,				MPEG_DECODER_UNIT,	0x1040, DWORD)

// Tags for downscaling the MPEG image and positioning it at an offset.
MKTAG(MPEG2_DOWNSCALE_FACTOR,				MPEG_DECODER_UNIT,	0x1050, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET,			MPEG_DECODER_UNIT,	0x1051, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET,			MPEG_DECODER_UNIT,	0x1052, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1053, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1054, int)


MKTAG(MPEG2_AC3_EQUALIZER_FRONT_ENABLE,MPEG_DECODER_UNIT,	0x1100, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_BACK_ENABLE,	MPEG_DECODER_UNIT,	0x1101, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_FRONT,			MPEG_DECODER_UNIT,	0x1104, DWORD)
MKTAG(MPEG2_AC3_EQUALIZER_BACK,			MPEG_DECODER_UNIT,	0x1105, DWORD)
MKTAG(MPEG2_STILL_FRAME_SEQUENCE,		MPEG_DECODER_UNIT,	0x1106, BOOL)
MKTAG(MPEG2_CURRENT_PLAYBACK_TIME,		MPEG_DECODER_UNIT,	0x1107, LONG)
MKTAG(MPEG2_AC3_VIRTUAL_3D_AUDIO,		MPEG_DECODER_UNIT,	0x1108, BOOL)

// Tags for split stream playback configuration
MKTAG(MPEG2_VIDEO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1109, MPEG2SplitStreamType)
MKTAG(MPEG2_AUDIO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1110, MPEG2SplitStreamType)
MKTAG(MPEG2_SPU_SPLIT_STREAM_TYPE,		MPEG_DECODER_UNIT,	0x1111, MPEG2SplitStreamType)

MKTAG(MPEG2_FORCED_SOURCE_ASPECT_RATIO, MPEG_DECODER_UNIT,	0x1120, ForcedAspectRatio)
// Switch to WDM playback (meaning: no navpacks in DVD data streams)
MKTAG(MPEG2_WDM_PLAYBACK,					MPEG_DECODER_UNIT,	0x1122, BOOL)
// Returns current value of the decoder's STC
MKTAG(MPEG2_CURRENT_STC,					MPEG_DECODER_UNIT,	0x1123, LONG)

MKTAG(MPEG2_REQUESTED_PLAYBACK_TIME,   MPEG_DECODER_UNIT,   0x1130, LONG)

// Closed Caption output on/off
MKTAG(MPEG2_CC_ENABLE,						MPEG_DECODER_UNIT,	0x1140, BOOL)

// Additional delay tags
MKTAG(MPEG2_AC3_LEFT_DELAY,				MPEG_DECODER_UNIT,	0x1200, WORD)
MKTAG(MPEG2_AC3_RIGHT_DELAY,				MPEG_DECODER_UNIT,	0x1201, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1202, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1203, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_DELAY,			MPEG_DECODER_UNIT,	0x1204, WORD)

// Dolby Pro Logic Decoder config and mode
MKTAG(MPEG2_PRO_LOGIC_CONFIG,				MPEG_DECODER_UNIT,	0x1210, DolbyProLogicConfig)
MKTAG(MPEG2_PRO_LOGIC_MODE,				MPEG_DECODER_UNIT,	0x1211, DolbyProLogicMode)

// Low Frequency Enable (LFE). Applicable for AC3, MPEG2-MC and DTS stream playback
MKTAG(MPEG2_DECODE_LFE,						MPEG_DECODER_UNIT,	0x1220, BOOL)

// GET only tag that returns whether a LFE channel is present (and being decoded) or not
MKTAG(MPEG2_LFE_STATUS,						MPEG_DECODER_UNIT,	0x1221, BOOL)

// AC3 Audio Coding Mode (acmod property). GET only.
MKTAG(MPEG2_AC3_AUDIO_CODING_MODE,		MPEG_DECODER_UNIT,	0x1225, AC3AudioCodingMode)

// Returns TRUE if Pro Logic decoding is active
MKTAG(MPEG2_PROLOGIC_STATUS,				MPEG_DECODER_UNIT,	0x1226, BOOL)

// PCM output configuration
MKTAG(MPEG2_PCM_OUTPUT_CONFIG,			MPEG_DECODER_UNIT,	0x1230, PCMOutputConfig)

// Dynamic range
MKTAG(MPEG2_AC3_DYNAMIC_RANGE,			MPEG_DECODER_UNIT,	0x1236, AC3DynamicRange)
MKTAG(MPEG2_AC3_HIGH_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1237, WORD)
MKTAG(MPEG2_AC3_LOW_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1238, WORD)

// Audio type specific configurations
MKTAG(MPEG2_AC3_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1240, AudioTypeConfig)
MKTAG(MPEG2_LPCM_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1241, AudioTypeConfig)
MKTAG(MPEG2_DTS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1242, AudioTypeConfig)
MKTAG(MPEG2_MPEG_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1243, AudioTypeConfig)
MKTAG(MPEG2_MPEG2_AUDIO_TYPE_CONFIG,	MPEG_DECODER_UNIT,	0x1244, AudioTypeConfig)
MKTAG(MPEG2_SDDS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1245, AudioTypeConfig)
MKTAG(MPEG2_CDDA_DTS_AUDIO_TYPE_CONFIG,MPEG_DECODER_UNIT,	0x1246, AudioTypeConfig)

MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_DAC,		MPEG_DECODER_UNIT,	0x1300, PCM96DownsampleMode)
MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_SPDIF,	MPEG_DECODER_UNIT,	0x1301, PCM96DownsampleMode)

MKTAG(MPEG2_VIDEO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1330, WORD)
MKTAG(MPEG2_VIDEO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1331, WORD)

MKTAG(MPEG2_AUDIO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1334, WORD)
MKTAG(MPEG2_AUDIO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1335, WORD)

MKTAG(MPEG2_VIDEO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1340, WORD)
MKTAG(MPEG2_VIDEO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1341, WORD)

MKTAG(MPEG2_AUDIO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1344, WORD)
MKTAG(MPEG2_AUDIO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1345, WORD)

// Speaker selection for audio tests (e.g. pink noise test). Bitfield defined above.
MKTAG(MPEG2_AUDIO_TEST_SPEAKER_SELECT,	MPEG_DECODER_UNIT,	0x1350, WORD)

// Data format for CDDA decoder, should be Get/Set
MKTAG(CDDA_DATA_FORMAT,						MPEG_DECODER_UNIT,	0x1400, DWORD)

MKTAG(UNITS_TIMEOUT_MSG,					MPEG_DECODER_UNIT,	0x1500, WORD)


// Karaoke control tags
#define KARAOKE_TAGVALUE_BASE  0x2000

MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE,								MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  0, BOOL)
MKTAG(MPEG2_AUDIO_KARAOKE_LEFT_CHANNEL_MUSIC_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  1, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_RIGHT_CHANNEL_MUSIC_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  2, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_MUSIC_CHANNEL_MUTE,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  3, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_LEFT_CHANNEL_VOICE_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  4, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_RIGHT_CHANNEL_VOICE_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  5, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_VOICE_CHANNEL_MUTE,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  6, BOOL)


MKTAG(MPEG2_AUDIO_KARAOKE_PITCH_SHIFT,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  7, int)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_PITCH_SHIFT,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  8, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_CANCELLATION,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  9, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_VOICE_CANCELLATION,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 10, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_DUET_THRESHOLD,						MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 11, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_DUET,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 12, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT,						MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 13, KaraokeVoiceEffectType )
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT_DELAY,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 14, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT_BALANCE,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 15, WORD)







#define GNR_CSS_NOT_SUPPORTED			MKERR(ERROR, DECRYPTION, OPERATION, 0x00)
#define GNR_AUTHENTICATION_FAILED	MKERR(ERROR, DECRYPTION, OPERATION, 0x00)

enum MPEG2DVDAuthenticationCommand
	{
	M2D_CHECK_DISK_KEY,				// 0
	M2D_CHECK_TITLE_KEY,          // 1
	M2D_START_AUTHENTICATION,     // 2
	M2D_READ_CHALLENGE_KEY,       // 3
	M2D_WRITE_BUS_KEY,            // 4
	M2D_WRITE_CHALLENGE_KEY,      // 5
	M2D_READ_BUS_KEY,             // 6
	M2D_WRITE_DISK_KEY,           // 7
	M2D_WRITE_TITLE_KEY,          // 8
	M2D_COMPLETE_AUTHENTICATION,  // 9
	M2D_CANCEL_AUTHENTICATION     // 10
	};





#if BOARD_HAS_MPEG2_ENCODER


#if LINUX
#include <stdio.h>
#define _export    /* FN: should be corrected in prelude.h.. */
#endif

void __cdecl MDebugPrint(const TCHAR * szFormat, ...);
#define RDP MDebugPrint

	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif LINUX
		inline void DebugPrintEmpty(const TCHAR * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
		#define DPF while(0) DebugPrintEmpty
		#define DPR while(0) DebugPrintEmpty
		inline void InitializeDebugRecording (void) {}
		inline void GetDebugRecordingParameters (BYTE * & array, int & size) {array=NULL; size=0;}
#else
		inline void __cdecl DebugPrintEmpty(const TCHAR __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
	#endif


#define BREAKPOINT



#define GNR_CAN_NOT_PASSIVATE_IDLE_UNIT			MKERR(ERROR,	UNITS,	OBJECT,	0x01)

#define GNR_OBJECT_NOT_CURRENT						MKERR(ERROR,	UNITS,	OBJECT,	0x02)

#define GNR_OBJECT_ALREADY_JOINED					MKERR(ERROR,	UNITS,	OBJECT,	0x03)

#define GNR_UNITS_BUSY									MKERR(ERROR,	UNITS,	BUSY,		0x04)

#define GNR_INVALID_UNITS								MKERR(ERROR,	UNITS,	PARAMS,	0x05)




struct MPEGTransferDoneMsg {
	};

struct MPEGEncoderBufferStarvingMsg {
	};


MKHOOK(MPEGTransferDone, MPEGTransferDoneMsg)
MKHOOK(MPEGEncoderBufferStarving, MPEGEncoderBufferStarvingMsg)


typedef MPEGTransferDoneHook	__far *	MPEGTransferDoneHookPtr;
typedef MPEGEncoderBufferStarvingHook __far *  MPEGEncoderBufferStarvingHookPtr;


enum MPEGEncoderStreamType
	{
	MST_UNKNOWN					= 0x00,
	MST_AUDIO_ELEMENTARY		= 0x01,
	MST_VIDEO_ELEMENTARY		= 0x02,
	MST_PROGRAM					= 0x03,
	MST_TRANSPORT				= 0x04,
	MST_PACKET_ELEMENTARY	= 0x05,
	MST_PACKET_VIDEO_ES		= 0x06,
	MST_PACKET_AUDIO_ES		= 0x07,
	MST_MPEG1					= 0x08
	};


MKTAG(MPEG_TRANSFER_DONE_HOOK,		MPEG_ENCODER_UNIT,	0x0001, MPEGTransferDoneHookPtr)
MKTAG(MPEG_ENCODER_BUFFER_STARVING, MPEG_ENCODER_UNIT,   0x0002, MPEGEncoderBufferStarvingHookPtr)
MKTAG(MPEG_ENC_OUTPUT_TYPE,			MPEG_ENCODER_UNIT,   0x0003, MPEGEncoderStreamType)
MKTAG(MPEG_ENC_VIDEO_SOURCE,			MPEG_ENCODER_UNIT,	0x0004, VideoSource)
MKTAG(MPEG_ENC_VIDEOSTANDARD,			MPEG_ENCODER_UNIT,	0x0005, VideoStandard)
//MKTAG(MPEG_ENC_VIDEO_WIDTH,	MPEG_ENCODER_UNIT,	0x0002, WORD)
//MKTAG(MPEG_ENC_VIDEO_HEIGHT,  MPEG_ENCODER_UNIT,   0x0003, WORD)

//
// Previous definition conflicted with decoder definition.
// Should move shared defines to hardware\mpgcodec\generic\mpgcodec.h"
//
//#include "library\hardware\mpegdec\generic\mpegdec.h"








#endif



typedef class __far UnitSetClass __far *UnitSet;
typedef class __far VDRHandleClass __far *VDRHandle;

extern "C" {

DLLCALL void VDR_ServiceProcess(void);

DLLCALL Error WINAPI VDR_OpenDriver(char * name, DWORD boardID, VDRHandle __far & handle);
DLLCALL Error WINAPI VDR_CloseDriver(VDRHandle handle);

DLLCALL DWORD WINAPI VDR_AvailUnits(VDRHandle handle);

DLLCALL Error WINAPI VDR_ReconfigureDriver(VDRHandle handle);

DLLCALL Error WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet &units);
DLLCALL Error WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet &units);
DLLCALL Error WINAPI VDR_CloseUnits(UnitSet units);


DLLCALL Error WINAPI VDR_ConfigureUnits(UnitSet units, TAG * tags);
inline Error __cdecl VDR_ConfigureUnitsTags(UnitSet units, TAG tags, ...) {return VDR_ConfigureUnits(units, &tags);}

DLLCALL Error WINAPI VDR_LockUnits(UnitSet units);
DLLCALL Error WINAPI VDR_UnlockUnits(UnitSet units);
DLLCALL Error WINAPI VDR_ActivateUnits(UnitSet units);
DLLCALL Error WINAPI VDR_PassivateUnits(UnitSet units);


DLLCALL Error WINAPI VDR_EnablePIP(UnitSet units, BOOL enable);
DLLCALL Error WINAPI VDR_UpdatePIP(UnitSet units);
DLLCALL Error WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                                   WORD width, WORD height,
                                   WORD stride,
                                   GrabFormat fmt);

DLLCALL Error WINAPI VDR_OptimizeBuffer(UnitSet units, WORD __far & minPixVal);


//
// MPEG Functions
//
DLLCALL DWORD	WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size);
DLLCALL void	WINAPI VDR_CompleteMPEGData(UnitSet units);
DLLCALL DWORD	WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size);

DLLCALL DWORD	WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, LONG timeStamp);
DLLCALL void	WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);
DLLCALL DWORD  WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size, int timeStamp);
DLLCALL void	WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

DLLCALL Error	WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag);
DLLCALL Error	WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL Error	WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag);
DLLCALL BOOL	WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag);

DLLCALL DWORD	WINAPI VDR_CurrentMPEGLocation(UnitSet units);
DLLCALL DWORD	WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units);
DLLCALL MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units);

DLLCALL Error	WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg);
DLLCALL Error	WINAPI VDR_RemoveMPEGWinHooks(UnitSet units);
DLLCALL Error	WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units);



#if BOARD_HAS_MPEG2_ENCODER

DLLCALL Error  WINAPI VDR_DoCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL Error	WINAPI VDR_PutBuffer(UnitSet units, HPTR data, DWORD size);
DLLCALL Error  WINAPI VDR_InstallMPEGTransferDoneHook(UnitSet units, HWND hwnd, WORD transferDoneMsg);
DLLCALL Error  WINAPI VDR_RemoveMPEGTransferDoneHook(UnitSet units);
DLLCALL Error  WINAPI VDR_InstallMPEGEncoderBufferStarvingHook(UnitSet units, HWND hwnd, WORD bufferStarvingMsg);
DLLCALL Error  WINAPI VDR_RemoveMPEGEncoderBufferStarvingHook(UnitSet units);

#endif



	}



#define GNR_DRIVE_FAILURE							MKERR(ERROR,	DISK,			HARDWARE,			0x00)
// General drive failure

#define GNR_DRIVE_FATAL_ERROR						MKERR(ERROR,	DISK,			HARDWARE,			0x01)
// Drive firmware is not responding any more

#define GNR_NO_VALID_DISK							MKERR(ERROR,	DISK,			OBJECT,				0x00)
// No valid/known disk was found

#define GNR_NO_DRIVE									MKERR(ERROR,	DISK,			OBJECT,				0x02)
// Drive does not exist/could not be found

#define GNR_DRIVE_DETACHED							MKERR(ERROR,	DISK,			OBJECT,				0x03)
// The drive has been detached -> is not available for playback

#define GNR_NO_DVD_DRIVE							MKERR(ERROR,	DISK,			OBJECT,				0x04)
// The drive is not a DVD drive (used on PCs)

#define GNR_BLOCK_ALREADY_LOCKED					MKERR(ERROR,	DISK,			OBJECT,				0x05)
// A block was already locked in a different mode (read/write)

#define GNR_BLOCK_NOT_LOCKED						MKERR(ERROR,	DISK,			OBJECT,				0x06)
// The block not be unlocked is not locked

#define GNR_INVALID_DRIVE_LETTER					MKERR(ERROR,	DISK,			BOUNDS,				0x01)
// The drive letter specified was not correct/out of range

#define GNR_DISK_READ_ONLY							MKERR(ERROR,	DISK,			FILEIO,				0x00)
// The disk is read-only

#define GNR_DRIVE_LOCK_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x00)
// Unable to lock/unlock the drive

#define GNR_DRIVE_ALREADY_LOCKED					MKERR(WARNING,	DISK,			OPERATION,			0x01)
// The drive was already locked

#define GNR_DRIVE_LOAD_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x02)
// Could not load/unload the drive

#define GNR_DRIVE_NOT_LOADABLE					MKERR(ERROR,	DISK,			OPERATION,			0x03)
// Drive does not support loading/unloading the disk

#define GNR_READ_ERROR								MKERR(ERROR,	DISK,			OPERATION,			0x04)
// Some read error occurred

#define GNR_WRITE_ERROR								MKERR(ERROR,	DISK,			OPERATION,			0x05)
// Some write error occurred

#define GNR_COPY_PROTECTION_VIOLATION			MKERR(ERROR,	DISK,			COPYPROTECTION,	0x00)

#define GNR_COPY_PROTECTION_FAILED				MKERR(ERROR,	DISK,			COPYPROTECTION,	0x01)

#define GNR_READ_ERROR_SECTOR_ENCRYPTED		MKERR(ERROR,	DISK,			COPYPROTECTION,	0x02)
// A sector was requested which happened to be encrypted, but the authentication process was not completed


#define GNR_PATH_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,			0x00)
// The path specified was not found

#define GNR_INVALID_PATH							MKERR(ERROR,	FILE,			OBJECT,			0x01)
// The path specified was invalid (e.g. contained invalid letters)

#define GNR_NO_FILE_SYSTEM							MKERR(ERROR,	FILE,			OBJECT,			0x02)
// There is no file system to execute operation

#define GNR_NO_VOLUME								MKERR(ERROR,	FILE,			OBJECT,			0x03)
// There is no volume to execute operation

#define GNR_VOLUME_INVALID							MKERR(ERROR,	FILE,			OBJECT,			0x04)
// Volume is invalid for some reason, e.g. not supported

#define GNR_ITEM_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,			0x05)
// The item was not found or there is no more file in the directory

#define GNR_NOT_A_DIRECTORY						MKERR(ERROR,	FILE,			OBJECT,			0x06)
// Disk item is not a directory

#define GNR_ITEM_INVALID							MKERR(ERROR,	FILE,			OBJECT,			0x07)
// Item is invalid (e.g. for an operation)

#define GNR_FILE_READ_ONLY							MKERR(ERROR,	FILE,			OPERATION,		0x00)
// The file is read only

//#define GNR_FILE_IN_USE


//  Navigation in general

#define GNR_UNEXPECTED_NAVIGATION_ERROR				MKERR(ERROR,	NAVIGATION,	INTERNALSTATE,		0x00)
// Some internal error happened

#define GNR_INVALID_PLAYER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x00)
// The player handle is invalid

#define GNR_INVALID_NAV_INFO								MKERR(ERROR,	NAVIGATION,	OBJECT,				0x02)
// The navigation information is invalid (possible causes: wrong authoring, read error from drive, internal error)

#define GNR_LOST_DECODER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x03)
// The decoder has been preempted

#define GNR_OPERATION_NOT_SUPPORTED						MKERR(ERROR,	NAVIGATION, OPERATION,			0x00)
// This operation is (currently) not supported by the player

#define GNR_TITLE_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x01)
// The title specified does not exist

#define GNR_CHAPTER_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x02)
// The chapter specified does not exist

#define GNR_TIME_OUT_OF_RANGE								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x03)
// The time specified (e.g. for a search operation) is out of range

#define GNR_PROGRAM_LINK_NOT_FOUND						MKERR(ERROR,	NAVIGATION,	OPERATION,			0x04)
// The current program does not have a next/prev/upper/etc. program

#define GNR_MENU_DOES_NOT_EXIST							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x05)
// The requested menu does not exist

#define GNR_STREAM_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x06)
// The stream (audio/subpicture) does not exist

#define GNR_FLAGS_NOT_SUPPORTED							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x07)
// The flags specified for this operation are not supported

#define GNR_BUTTON_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x08)
// The specified button does not exist

#define GNR_UNKNOWN_EVENT_TYPE							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x09)
// The event type specified does not exist

#define GNR_BREAKPOINT_NOT_FOUND							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0a)
// The breakpoint to be deleted does not exist

#define GNR_INVALID_UNIQUE_KEY							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0b)
// The unique key could not be created/was invalid

//
//  DVD specific errors
//

#define GNR_UOP_PROHIBITED									MKERR(ERROR,	DVD,			UOP,					0x01)
// The current UOPs do not allow this action

#define GNR_REGIONS_DONT_MATCH							MKERR(ERROR,	DVD,			REGION,				0x00)
// The system and disk regions don't match

#define GNR_REGION_CODE_INVALID							MKERR(ERROR,	DVD,			REGION,				0x01)
// The region code specified was invalid (e.g. multiregion when trying to set region)

#define GNR_NO_MORE_REGION_SETS							MKERR(ERROR,	DVD,			REGION,				0x02)
// The number of region changes is exhausted

#define GNR_REGION_WRITE_ERROR							MKERR(ERROR,	DVD,			REGION,				0x03)
// Unable to write region

#define GNR_REGION_READ_ERROR								MKERR(ERROR,	DVD,			REGION,				0x04)
// Unable to read region

#define GNR_PARENTAL_LEVEL_TOO_LOW						MKERR(ERROR,	DVD,			PARENTAL,			0x03)
// The parental level currently set is too low to play the disc

#define GNR_ILLEGAL_NAVIGATION_COMMAND					MKERR(ERROR,	DVD,			OPERATION,			0x00)
// The DVD contains an illegal navigation command

#define GNR_ILLEGAL_DOMAIN									MKERR(ERROR,	DVD,			OPERATION,			0x01)
// The domain is illegal for this operation

#define GNR_NO_RESUME_INFORMATION						MKERR(ERROR,	DVD,			OPERATION,			0x02)
// No resume information currently available

//
//  VCD specific errors
//

//
//  CDDA specific errors
//


enum DVDPlayerMode
	{
	DPM_STOPPED,
	DPM_PAUSED,
	DPM_STILL,
	DPM_PLAYING,
	DPM_BUSY,
	DPM_SCANNING,
	DPM_INACTIVE,
	DPM_REVERSEPLAY,
	DPM_TRICKPLAY,
	DPM_REVERSESCAN
	};

enum DVDDomain
	{
	FP_DOM,
	VMGM_DOM,
	VTSM_DOM,
	TT_DOM,
	STOP_DOM
	};

enum VTSMenuType
	{
	VMT_TITLE_MENU,
	VMT_ROOT_MENU,
	VMT_SUBPICTURE_MENU,
	VMT_AUDIO_MENU,
	VMT_ANGLE_MENU,
	VMT_PTT_MENU,
	VMT_NO_MENU		// Note that this is used in ExtendedPlayerState as array size
	};

enum DisplayPresentationMode
	{
	DPM_4BY3,
	DPM_16BY9,
	DPM_LETTERBOXED,
	DPM_PANSCAN,
	DPM_NONE
	};

enum DVDAudioCodingMode
	{
	DAM_AC3,
	DAM_MPEG1,
	DAM_MPEG2,
	DAM_LPCM,
	DAM_DTS,
	DAM_SDDS
	};

enum DVDAudioApplicationMode
	{
	DAAM_UNDEFINED		= 0,
	DAAM_KARAOKE		= 1,
	DAAM_SURROUND		= 2
	};

enum MPEG2PrologicStatus		// Status of the decoder (actually played!)
	{
	MP2PS_OFF,
	MP2PS_ON,
	MP2PS_UNKNOWN
	};

enum MPEG2LFEStatus				// Content, not playing
	{
	MP2LFE_OFF,
	MP2LFE_ON,
	MP2LFE_UNKNOWN
	};

enum DVDDiskType
	{
	DDT_NONE,
	DDT_VIDEO_DVD,
	DDT_AUDIO_DVD,
	DDT_VIDEO_CD,
	DDT_AUDIO_CD,
	DDT_SUPER_AUDIO_CD,
	DDT_DTS_AUDIO_CD,
	DDT_SUPER_VIDEO_CD,
	DDT_MULTI_DISK
	};

enum RegionSource
	{
	RGSRC_UNDEFINED	= 0,
	RGSRC_DRIVE			= 1,
	RGSRC_BOARD			= 2
	};

enum VideoCompressionMode
	{
	VCM_UNKNOWN,
	VCM_MPEG1,
	VCM_MPEG2
	};

enum Line21Mode
	{
	L21M_NO_DATA,
	L21M_FIRST_FIELD,
	L21M_SECOND_FIELD,
	L21M_BOTH_FIELDS
	};

//
//  User Operation Bitmasks
//

#define UOP_TIME_PLAY_SEARCH				MKFLAG(0)
#define UOP_PTT_PLAY_SEARCH				MKFLAG(1)
#define UOP_TITLE_PLAY						MKFLAG(2)
#define UOP_STOP								MKFLAG(3)
#define UOP_GO_UP								MKFLAG(4)
#define UOP_TIME_PTT_SEARCH				MKFLAG(5)
#define UOP_PREV_TOP_PG_SEARCH			MKFLAG(6)
#define UOP_NEXT_PG_SEARCH					MKFLAG(7)
#define UOP_FORWARD_SCAN					MKFLAG(8)
#define UOP_BACKWARD_SCAN					MKFLAG(9)
#define UOP_SCAN_OFF							MKFLAG(25)	// additional
#define UOP_MENU_CALL_TITLE				MKFLAG(10)
#define UOP_MENU_CALL_ROOT					MKFLAG(11)
#define UOP_MENU_CALL_SUB_PICTURE		MKFLAG(12)
#define UOP_MENU_CALL_AUDIO				MKFLAG(13)
#define UOP_MENU_CALL_ANGLE				MKFLAG(14)
#define UOP_MENU_CALL_PTT					MKFLAG(15)
#define UOP_RESUME							MKFLAG(16)
#define UOP_BUTTON							MKFLAG(17)
#define UOP_STILL_OFF						MKFLAG(18)
#define UOP_PAUSE_ON							MKFLAG(19)
#define UOP_PAUSE_OFF						MKFLAG(26)	// additional
#define UOP_AUDIO_STREAM_CHANGE			MKFLAG(20)
#define UOP_SUB_PICTURE_STREAM_CHANGE	MKFLAG(21)
#define UOP_ANGLE_CHANGE					MKFLAG(22)
#define UOP_KARAOKE_MODE_CHANGE			MKFLAG(23)
#define UOP_VIDEO_MODE_CHANGE				MKFLAG(24)

//
//  Disc Information Structure
//

class __far DDPDiskInfo
	{
	public:
		DDPDiskInfo(void)			{size = sizeof(DDPDiskInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DVDDiskType		type;				// Type of media inserted
		char				uniqueKey[8];	// Unique identifier of disk
		BYTE				systemRegion;	// System region (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				diskRegion;		// Disk region (only for type == DDT_VIDEO_DVD)
		RegionSource	regionSource;	// Region source (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				availSets;		// Number of region sets left (only for type == DDT_VIDEO_DVD)
	};

//
//  DVD Time Class
//

class __far DVDTime
	{
	private:
		DWORD	stamp;  // Format HHHH HHHH MMMM MMMM SSSS SSSS RR FF FFFF
	public:
		DVDTime(DWORD stamp) {this->stamp = stamp;}
		DVDTime(void) {this->stamp = 0;}
		DVDTime(int hours, int minutes, int seconds, int frames, int frameRate);
		DVDTime(int millisecs, int divider, int frameRate);

		int FrameRate(void)	const {return XTBF(7, stamp) ? 30 : 25;}
		int Frames(void)		const {return (int)(XTBF(0, 4, stamp) + 10 * XTBF(4, 2, stamp));}
		int Seconds(void)		const {return (int)(XTBF(8, 4, stamp) + 10 * XTBF(12, 4, stamp));}
		int Minutes(void)		const {return (int)(XTBF(16, 4, stamp) + 10 * XTBF(20, 4, stamp));}
		int Hours(void)		const {return (int)(XTBF(24, 4, stamp) + 10 * XTBF(28, 4, stamp));}

		DWORD FrameTotal(void)	const	{return (Seconds() + Minutes() * 60 + Hours() * 3600) * FrameRate() + Frames();}

		DWORD Millisecs(void) const {return 1000 * Frames() / FrameRate() +
		                              1000 * Seconds() +
		                              60000 * Minutes() +
		                              3600000 * Hours();}

		friend DVDTime operator+ (const DVDTime u, const DVDTime v);
		friend DVDTime operator- (const DVDTime u, const DVDTime v);

		DVDTime & operator+= (const DVDTime u);
		DVDTime & operator-= (const DVDTime u);

		int Compare(const DVDTime u) const;

		friend BOOL operator==(const DVDTime u, const DVDTime v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const DVDTime u, const DVDTime v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const DVDTime u, const DVDTime v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const DVDTime u, const DVDTime v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const DVDTime u, const DVDTime v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const DVDTime u, const DVDTime v) {return u.Compare(v) >= 0;}

		BOOL IsZero(void)		const {return (stamp & 0xffffff3f) == 0;}
		BOOL IsNotZero(void)	const {return (stamp & 0xffffff3f) != 0;}
	};

//
//  DVD Location
//

class __far DVDLocation
	{
	public:
		DVDDomain	domain;
		WORD			videoTitleSet;
		WORD			title;
		WORD			vtsTitle;
		DVDTime		titleTime;
		WORD			partOfTitle;
		WORD			programChain;
		DVDTime		pgcTime;
		WORD			program;
		WORD			cell;
		DVDTime		cellTime;

		DVDLocation(void) {};
		friend BOOL	NotEqual(const DVDLocation u, const DVDLocation v);
		friend BOOL operator !=(const DVDLocation u, const DVDLocation v) { return (BOOL)memcmp(&u, &v, sizeof(DVDLocation)); }
	};

//
//  Audio Stream Format
//

class __far DVDAudioStreamFormat
	{
	public:
		WORD						languageCode;
		WORD						languageExtension;
		DVDAudioCodingMode	codingMode;
		WORD						bitsPerSample;
		DWORD						samplesPerSecond;
		WORD						channels;

		friend BOOL operator==(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
		friend BOOL operator!=(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
	};

//
//  Video Stream Format
//

class VideoStreamFormat
	{
	public:
		VideoCompressionMode			compressionMode;			// Compression technique used
		VideoStandard					videoStandard;				// Source video standard
		DisplayPresentationMode		sourceAspectRatio;		// Aspect ratio of source picture
		BOOL								panScanOn4By3;				// TRUE if Pan & Scan is allowed on 4 by 3 display
		BOOL								letterboxedOn4By3;		// TRUE if letterboxed is allowed on 4 by 3 display
		Line21Mode						line21Mode;					// Encoded line 21 data
		WORD								sourceWidth;				// Width of source picture
		WORD								sourceHeight;				// Height of source picture
		BOOL								sourceLetterboxed;		// TRUE is source material is letterboxed

		friend BOOL operator==(const VideoStreamFormat & u, const VideoStreamFormat & v);
		friend BOOL operator!=(const VideoStreamFormat & u, const VideoStreamFormat & v);
	};

//
//  Subpicture Stream Format
//

class __far DVDSubPictureStreamFormat
	{
	public:
		WORD						languageCode;
		WORD						languageExtension;

		friend BOOL operator==(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
		friend BOOL operator!=(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
	};

//
//  Button Information
//

#define DBI_MAX_BUTTON_NUMBER 103

class __far DVDButtonInformation
	{
	public:
		WORD	x;
		WORD	y;
		WORD	w;
		WORD	h;
		BOOL	autoAction;
		BYTE	upperButton;
		BYTE	lowerButton;
		BYTE	leftButton;
		BYTE	rightButton;

		friend BOOL operator==(const DVDButtonInformation u, const DVDButtonInformation v);
		friend BOOL operator!=(const DVDButtonInformation u, const DVDButtonInformation v);
	};

//
//  Extended player state
//

class __far ExtendedPlayerState
	{
	public:
		DWORD								size;								// Size of the structure passed

		// Request bitmasks

		DWORD								request;							// Bitmask for requested data
		DWORD								valid;							// Bitmask for delivered data
		DWORD								monitor;							// Bitmask indicating the elements to check for changes
		DWORD								changed;							// Bitmask indicating the elements that have changed

		// Player Information (EPS_PLAYERINFO, additions below)

		DVDPlayerMode					playerMode;						// Current player mode
		WORD								playbackSpeed;					// Current playback speed
		WORD								scanSpeed;						// Current scan speed
		DWORD								forbiddenUOPs;					// Forbidden UOPs

		// Hardware Information (EPS_MISC)

		DVDDiskType						diskType;						// Current disk type
		DisplayPresentationMode		displayMode;					// Current display mode
		VideoStandard					videoStandard;					// Current video standard
		DWORD								currentBitRate;				// Current bitrate

		// Audio Stream Information (EPS_AUDIOSTREAMS, additional info below)

		int								currentAudioStream;			// Current Audio Stream ID
		BYTE								availableAudioStreams;		// Bitmask of audio streams available
		DVDAudioStreamFormat			audioStream[8];				// Audio stream data

		// Sub Picture Stream Information (EPS_SUBPICTURESTREAMS)

		int								currentSubPictureStream;	// Current sub picture Stream ID
		DWORD								availableSubPictureStreams;// Bitmask of sub picture streams available
		DVDSubPictureStreamFormat	subPictureStream[32];		// Subpicture stream data

		// Title Information (EPS_TITLE)

		DVDLocation						location;						// Current location
		DVDLocation						duration;						// Current duration

		// Menu Information (EPS_MENU)

		WORD								menuLanguage;
		BOOL								menuAvailable[VMT_NO_MENU+1];  // Use a VTSMenuType as index

		// Parental Information (EPS_PARENTAL)

		WORD								parentalCountry;
		WORD								parentalLevel;

		// Angle Information (EPS_ANGLE, addition below)

		WORD								numberOfAngles;
		WORD								currentAngle;

		// Button Information (EPS_BUTTON)

		WORD								numberOfButtons;
		WORD								selectedButton;
		WORD								forcedlyActivatedButton;
		WORD								userButtonOffset;
		WORD								numberOfUserButtons;
		DVDButtonInformation			buttonInfo[DBI_MAX_BUTTON_NUMBER];

		// CDDA Information (EPS_PLAYINGGAP)

		BOOL								playingGap;						// CDDA only: TRUE if gap between titles is played

		// Additional Player Information (EPS_PLAYERINFO)

		BOOL								playingForward;

		// Additional Angle Information (EPS_ANGLE)

		BOOL								isMultiAngleScene;
		WORD								playingAngle;

		// Video stream information (EPS_VIDEOSTREAM, additional to info in EPS_MISC)

		VideoStreamFormat				videoStream;

		// Hardware Information (EPS_MISC, additional)

		BOOL								diskIsEncrypted;				// TRUE if disk is encrypted

		// Additional Audio Information

		MPEG2PrologicStatus			mpeg2PrologicStatus;			// Indicating if Prologic decoding is currently done
		MPEG2LFEStatus					mpeg2LFEStatus;				// Indicates if LFE info is in content
		AC3AudioCodingMode			ac3AudioCodingMode;			// Encoding, not actual output

		// Karaoke information (EPS_KARAOKE)

		BYTE								applicationMode[8];			// contains Karaoke information for each audio stream
	};

//
//  Request bitmask defines (00000200 in use)
//

#define EPS_PLAYERINFO				0x00000001
#define EPS_MISC						0x00000002
#define EPS_TITLE						0x00000004
#define EPS_AUDIOSTREAMS			0x00000008
#define EPS_SUBPICTURESTREAMS		0x00000010
#define EPS_ANGLE						0x00000020
#define EPS_MENU						0x00000040
#define EPS_PARENTAL					0x00000080
#define EPS_BUTTON					0x00000100
#define EPS_PLAYINGGAP				0x00000200
#define EPS_VIDEOSTREAM				0x00000400
#define EPS_KARAOKE					0x00000800

//
//  Shortcuts
//

#define EPS_COMMON					EPS_PLAYERINFO | EPS_MISC | EPS_TITLE
#define EPS_DVD						EPS_MENU | EPS_PARENTAL | EPS_BUTTON | EPS_ANGLE | EPS_AUDIOSTREAMS | \
											EPS_SUBPICTURESTREAMS | EPS_VIDEOSTREAM
#define EPS_VCD						EPS_BUTTON | EPS_AUDIOSTREAMS
#define EPS_CDA						EPS_PLAYINGGAP | EPS_AUDIOSTREAMS
#define EPS_ALL						EPS_COMMON | EPS_DVD | EPS_VCD | EPS_CDA

//
//  Disk Navigation Event handling
//

typedef void (WINAPI * DNEEventHandler)(DWORD event, void * userData, DWORD info);

#define DNE_NONE								0
#define DNE_TITLE_CHANGE					1
#define DNE_PART_OF_TITLE_CHANGE			2
#define DNE_VALID_UOP_CHANGE				3
#define DNE_ANGLE_CHANGE					4
#define DNE_AUDIO_STREAM_CHANGE			5
#define DNE_SUBPICTURE_STREAM_CHANGE	6
#define DNE_DOMAIN_CHANGE					7
#define DNE_PARENTAL_LEVEL_CHANGE		8
#define DNE_BITRATE_CHANGE					9
#define DNE_STILL_ON							10
#define DNE_STILL_OFF						11
#define DNE_PLAYBACK_MODE_CHANGE			12
#define DNE_CDA_PLAYING_GAP				13
#define DNE_READ_ERROR						14
#define DNE_DISPLAY_MODE_CHANGE			15
#define DNE_STREAMS_CHANGE					16
#define DNE_SCAN_SPEED_CHANGE				17
#define DNE_PLAYBACK_SPEED_CHANGE		18
#define DNE_VIDEO_STANDARD_CHANGE		19
#define DNE_BREAKPOINT_REACHED			20
#define DNE_DRIVE_DETACHED					21
#define DNE_ERROR								22

#define DNE_EVENT_NUMBER					23

//
//  ERS Breakpoints
//

#define ERS_BREAKPOINT_NONE				0xffffffff	// Defines an invalid breakpoint id

//
//  Flags for DDP_SetBreakpoint()
//

enum ERSBreakpointFlags
	{
	ERS_NONE					=	0x0000,	// No flags, normal breakpoint
	ERS_PAUSE				=	0x0001,	// Go to still mode when reaching breakpoint
	ERS_AUTOCLEAR			=	0x0002,	// Delete breakpoint when it has been reached
	ERS_PAUSEATEND			=	0x0004	// Trigger at end of title
	};

//
//  Flags for DDP_SetBreakpointExt()
//

enum ERSBreakpointExtFlags
	{
	ERS_ATTIME			=	0x0001,	// Trigger when reaching time in title
	ERS_ENDOFTITLE		=	0x0002,	// Trigger at end of title
	ERS_ENDOFPTT		=	0x0004,	// Trigger at and of part of title
	ERS_FORWARD			=	0x0008,	// Trigger when playing forward
	ERS_BACKWARD		=	0x0010,	// Trigger when playing backward
	ERS_TOSTILL			=	0x0020,	// Go to still when reaching breakpoint
	ERS_CLEAR			=	0x0040,	// Automatically delete breakpoint after triggering
	ERS_BEGINOFPTT		=	0x0080	// Trigger at begin of PTT
	};

// flags for ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

#define DDPEPF_PAUSE_AT_START		1
#define DDPEPF_USE_TIME				2
#define DDPEPF_USE_PTT				4
#define DDPEPF_USE_TITLE			8

// flags for DetachDrive(DWORD flags, DVDTime time);

#define DDPDDF_DETACH_IMMEDIATE				1
#define DDPDDF_DETACH_AT_TIME					2
#define DDPDDF_DETACH_AT_END_OF_CELL		4
#define DDPDDF_DETACH_AT_END_OF_PROGRAM	8
#define DDPDDF_DETACH_AT_END_OF_PGC			16

#define DDPDDF_DETACH_ANY						31

#define DDPDDF_STREAM_PREFETCH				32
#define DDPDDF_PREFETCH_BUFFER_SIZE			64

// Flags for DDP_StartPresentationExt and DDP_DefrostExt

#define DDPSPF_NONE		0
#define DDPSPF_TOPAUSE	1


typedef class CDDiskPlayerClass * DVDDiskPlayer;

extern "C" {

#ifndef DLLCALL
#define DLLCALL __declspec(dllexport)
#endif


DLLCALL Error WINAPI  DDP_CheckDrive(char driveLetter, char __far * id);

DLLCALL Error WINAPI  DDP_CheckDriveWithPath(char * drivePath, char __far * id);

DLLCALL Error WINAPI  DDP_GetVolumeName(char driveLetter, char * name);

DLLCALL Error WINAPI  DDP_GetDiskRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far & regionSource, BYTE & diskRegion);

DLLCALL Error WINAPI  DDP_GetRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far &regionSource);

DLLCALL Error WINAPI  DDP_SetSystemRegion(UnitSet units, char driveLetter, BYTE region);

DLLCALL Error WINAPI  DDP_EjectDiskInDrive(char driveLetter);

DLLCALL Error WINAPI  DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed);

DLLCALL Error WINAPI  DDP_LoadDiskInDrive(char driveLetter, BOOL wait);

DLLCALL Error WINAPI  DDP_OpenPlayer(UnitSet units, char diskLetter, DVDDiskPlayer __far & player);

DLLCALL Error WINAPI  DDP_OpenPlayerWithPath(UnitSet units, char * drivePath, DVDDiskPlayer __far & player);

DLLCALL Error WINAPI  DDP_OpenPlayerExtended(UnitSet units, char driveLetter, char * drivePath,
															DVDDiskPlayer __far & player, DDPDiskInfo __far & diskInfo);

DLLCALL Error WINAPI  DDP_ClosePlayer(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StartPresentation(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StartPresentationExt(DVDDiskPlayer player, DWORD flags);

DLLCALL DVDDiskType	 WINAPI DDP_GetDiskType(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_GetCurrentLocation(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL Error WINAPI  DDP_GetCurrentDuration(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL Error WINAPI  DDP_GetTitleDuration(DVDDiskPlayer player, WORD title, DVDTime & duration);

DLLCALL DVDPlayerMode WINAPI DDP_GetPlayerMode(DVDDiskPlayer player);

DLLCALL Error WINAPI	 DDP_GetExtendedPlayerState(DVDDiskPlayer player, ExtendedPlayerState & eps);

DLLCALL DWORD WINAPI  DDP_GetForbiddenUserOperations(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfTitles(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfPartOfTitle(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_GetAvailStreams(DVDDiskPlayer player, BYTE __far & audioMask, DWORD __far & subPictureMask);

DLLCALL Error WINAPI  DDP_GetAudioStreamAttributes(DVDDiskPlayer player, WORD stream, DVDAudioStreamFormat __far & format);

DLLCALL Error WINAPI  DDP_GetSubPictureStreamAttributes(DVDDiskPlayer player, WORD stream, DVDSubPictureStreamFormat __far & format);

DLLCALL WORD  WINAPI  DDP_GetCurrentAudioStream(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetCurrentSubPictureStream(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_IsCurrentSubPictureEnabled(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfAngles(DVDDiskPlayer player, WORD title);

DLLCALL WORD  WINAPI  DDP_GetCurrentAngle(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_CheckMenuAvail(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL DisplayPresentationMode WINAPI  DDP_GetCurrentDisplayMode(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_SetDisplayMode(DVDDiskPlayer player, DisplayPresentationMode mode);

DLLCALL Error WINAPI  DDP_TitlePlay(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_PTTPlay(DVDDiskPlayer player, WORD title, WORD part);

DLLCALL Error WINAPI  DDP_TimePlay(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL Error WINAPI  DDP_TimePlayForced(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL Error WINAPI  DDP_ExtendedPlay(DVDDiskPlayer player, DWORD flags, WORD title, WORD ptt, DVDTime time);

DLLCALL Error WINAPI  DDP_Stop(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_GoUp(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_TimeSearch(DVDDiskPlayer player, DVDTime time);

DLLCALL Error WINAPI  DDP_TimeSearchForced(DVDDiskPlayer player, DVDTime time);

DLLCALL Error WINAPI  DDP_PTTSearch(DVDDiskPlayer player, WORD part);

DLLCALL Error WINAPI  DDP_PrevPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_TopPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_NextPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ForwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_BackwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_TrickPlay(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StopScan(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ReversePlayback(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_MenuCall(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL Error WINAPI  DDP_Resume(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_UpperButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_LowerButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_LeftButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_RightButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ButtonSelectAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL Error WINAPI  DDP_ButtonActivate(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ButtonSelectAndActivate(DVDDiskPlayer player, WORD num);

DLLCALL Error WINAPI  DDP_ButtonSelectAndActivateAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL BOOL  WINAPI  DDP_IsButtonAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL Error WINAPI  DDP_StillOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PauseOn(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PauseOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_AdvanceFrame(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_AdvanceFrameBy(DVDDiskPlayer player, int by);

DLLCALL Error WINAPI  DDP_SetPlaybackSpeed(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_MenuLanguageSelect(DVDDiskPlayer player, WORD language);

DLLCALL Error WINAPI  DDP_AudioStreamChange(DVDDiskPlayer player, WORD streamID);

DLLCALL Error WINAPI  DDP_SubPictureStreamChange(DVDDiskPlayer player, WORD streamID, BOOL display);

DLLCALL Error WINAPI  DDP_AngleChange(DVDDiskPlayer player, WORD angle);

DLLCALL Error WINAPI  DDP_ParentalLevelSelect(DVDDiskPlayer player, WORD parentalLevel);

DLLCALL Error WINAPI  DDP_ParentalCountrySelect(DVDDiskPlayer player, WORD country);

DLLCALL Error WINAPI  DDP_InitialLanguageSelect(DVDDiskPlayer player,
														      WORD audioLanguage,
														      WORD audioExtension,
														      WORD subPictureLanguage,
														      WORD subPictureExtension);

DLLCALL Error WINAPI  DDP_InquireCurrentBitRate(DVDDiskPlayer player, DWORD & bitsPerSecond);

DLLCALL Error WINAPI  DDP_GetCurrentButtonState(DVDDiskPlayer player, WORD & minButton, WORD & numButtons, WORD & currentButton);

DLLCALL Error WINAPI  DDP_Freeze(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL Error WINAPI  DDP_Defrost(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL Error WINAPI  DDP_DefrostExt(DVDDiskPlayer player, BYTE * buffer, DWORD & length, DWORD flags);

DLLCALL Error WINAPI  DDP_InstallEventHandler(DVDDiskPlayer player, DWORD event, DNEEventHandler handler, void * userData);

DLLCALL Error WINAPI  DDP_RemoveEventHandler(DVDDiskPlayer player, DWORD event);

DLLCALL Error WINAPI  DDP_SetBreakpoint(DVDDiskPlayer player, WORD title, DVDTime time, DWORD flags, DWORD & id);

DLLCALL Error WINAPI  DDP_SetBreakpointExt(DVDDiskPlayer player, WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

DLLCALL Error WINAPI  DDP_ClearBreakpoint(DVDDiskPlayer player, DWORD id);

DLLCALL Error WINAPI  DDP_DetachDrive(DVDDiskPlayer player, DWORD flags, DVDTime time, DWORD bufferSize);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\wmav\wma_dec_win32_x86.h ===
/*
 * Windows Media Audio (WMA) Decoder API
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#ifndef _WMAUDIO_API_H_
#define _WMAUDIO_API_H_

#define PACKED
/*
#ifdef _MSC_VER
#define USE_PACK_HEADERS
#define PACKED
#else
#undef USE_PACK_HEADERS
#define PACKED  __packed
#endif

#ifdef USE_PACK_HEADERS
#include <pshpack1.h>
#endif
*/

/* ...........................................................................
 *
 * Types and Constants
 * ===================
 */

#define CHECK_NONSDMI_LIC	1
#define CHECK_SDMI_LIC		2
#define CHECK_ALL_LICENSE	3

#define WMA_MAX_DATA_REQUESTED  128

#if defined(_Embedded_x86)
#pragma pack (1)
#endif

/* 16-bit signed type  */
#ifndef _WMAI16_DEFINED
#define _WMAI16_DEFINED
typedef short tWMA_I16;
#endif /* _WMAI16_DEFINED */

/* 16-bit unsigned type  */
#ifndef _WMAU16_DEFINED
#define _WMAU16_DEFINED
typedef short tWMA_U16;
#endif /* _WMAU16_DEFINED */

/* 32-bit unsigned type  */
#ifndef _WMAU32_DEFINED
#define _WMAU32_DEFINED
typedef unsigned long tWMA_U32;
#endif /* _WMAU32_DEFINED */

#ifndef _QWORD_DEFINED
#define _QWORD_DEFINED
typedef PACKED struct tQWORD
{
    tWMA_U32   dwLo;
    tWMA_U32   dwHi;

}   QWORD;
#endif /* _QWORD_DEFINED */

#define DESC_NAME_MAX_LENGTH   64
typedef struct _MarkerEntry {
    QWORD   m_qOffset;
    QWORD   m_qtime;
    tWMA_U16    m_wEntryLen;
    tWMA_U32   m_dwSendTime;
    tWMA_U32   m_dwFlags;
    tWMA_U32   m_dwDescLen;
    tWMA_U16   m_pwDescName[DESC_NAME_MAX_LENGTH];
} MarkerEntry;


/* status */
#ifndef _WMAFILESTATUS_DEFINED
#define _WMAFILESTATUS_DEFINED
typedef enum tagWMAFileStatus
{
    cWMA_NoErr,                 /* -> always first entry */
                                /* remaining entry order is not guaranteed */
    cWMA_Failed,
    cWMA_BadArgument,
    cWMA_BadAsfHeader,
    cWMA_BadPacketHeader,
    cWMA_BrokenFrame,
    cWMA_NoMoreFrames,
    cWMA_BadSamplingRate,
    cWMA_BadNumberOfChannels,
    cWMA_BadVersionNumber,
    cWMA_BadWeightingMode,
    cWMA_BadPacketization,

    cWMA_BadDRMType,
    cWMA_DRMFailed,
    cWMA_DRMUnsupported,

    cWMA_DemoExpired,

    cWMA_BadState,
    cWMA_Internal,               /* really bad */
	cWMA_NoMoreDataThisTime
} tWMAFileStatus;
#endif /* _WMAFILESTATUS_DEFINED */

/* versions */
#ifndef _WMAFILEVERSION_DEFINED
#define _WMAFILEVERSION_DEFINED
typedef enum tagWMAFileVersion
{
    cWMA_V1 = 1,
    cWMA_V2 = 2

} tWMAFileVersion;
#endif /* _WMAFILEVERSION_DEFINED */

/* sample rates */
#ifndef _WMAFILESAMPLERATE_DEFINED
#define _WMAFILESAMPLERATE_DEFINED
typedef enum tagWMAFileSampleRate
{
    cWMA_SR_48kHz,
    cWMA_SR_44_1kHz,
    cWMA_SR_32kHz,
    cWMA_SR_22_05kHz,
    cWMA_SR_16kHz,
    cWMA_SR_11_025kHz,
    cWMA_SR_08kHz
} tWMAFileSampleRate;
#endif /* _WMAFILESAMPLERATE_DEFINED */

/* channels */
#ifndef _WMAFILECHANNELS_DEFINED
#define _WMAFILECHANNELS_DEFINED
typedef enum tagWMAFileChannels
{
    cWMA_C_Mono = 1,
    cWMA_C_Stereo = 2

} tWMAFileChannels;
#endif /* _WMAFILECHANNELS_DEFINED */


/* ...........................................................................
 *
 * Structures
 * ==========
 */

/* header */
#ifndef _WMAFILEHEADER_DEFINED
#define _WMAFILEHEADER_DEFINED
typedef PACKED struct tagWMAFileHeader
{
    tWMAFileVersion version;         /* version of the codec */
    tWMAFileSampleRate sample_rate;  /* sampling rate */
    tWMAFileChannels num_channels;   /* number of audio channels */
    tWMA_U32 duration;               /* of the file in milliseconds */
    tWMA_U32 packet_size;            /* size of an ASF packet */
    tWMA_U32 first_packet_offset;    /* byte offset to the first ASF packet */
    tWMA_U32 last_packet_offset;     /* byte offset to the last ASF packet */

    tWMA_U32 has_DRM;                /* does it have DRM encryption? */
 
    tWMA_U32 LicenseLength;          /* License Length in the header */

    tWMA_U32 bitrate;                /* bit-rate of the WMA bitstream */

    /* HongCho: what else? */

} tWMAFileHeader;
#endif /* _WMAFILEHEADER_DEFINED */


/* content description */
#ifndef _WMAFILECONTDESC_DEFINED
#define _WMAFILECONTDESC_DEFINED
typedef PACKED struct tagWMAFileContDesc
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    tWMA_U16 title_len;
    tWMA_U16 author_len;
    tWMA_U16 copyright_len;
    tWMA_U16 description_len;   /* rarely used */
    tWMA_U16 rating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    unsigned char *pTitle;
    unsigned char *pAuthor;
    unsigned char *pCopyright;
    unsigned char *pDescription;
    unsigned char *pRating;

} tWMAFileContDesc;
#endif /* _WMAFILECONTDESC_DEFINED */

/* license params */
#ifndef _WMAFILELICPARAMS_DEFINED
#define _WMAFILELICPARAMS_DEFINED
typedef PACKED struct tagWMAFileLicParams
{
    unsigned char *pPMID;       /* portable media id */
    tWMA_U32 cbPMID;            /* length of the pPMID buffer */

} tWMAFileLicParams;
#endif /* _WMAFILELICPARAMS_DEFINED */


typedef void * tHWMAFileState;

/* another internal state */
#ifndef _WMAFILEHDRSTATE_DEFINED
#define _WMAFILEHDRSTATE_DEFINED
typedef PACKED struct tagWMAFileHdrState
{
    unsigned char internal[188];

} tWMAFileHdrState;
#endif /* _WMAFILEHDRSTATE_DEFINED */

#ifdef _Embedded_x86
#pragma pack ()
#endif

/* ........................................................................... 
 *
 * Functions
 * =========
 */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/*
 *        WMAFileIsWMA
 *        ============
 *
 * Description
 * -----------
 * Checks to see if the file is decodable.  Uses WMAFileCBGetData(),
 * but the first argument to it is not really of type tHWMAFileState,
 * but tWMAFileIdState.
 *
 * To decode the file, the app should call WMAFileDecodeInit()
 * instead.
 *
 * This function was added in case the app wants to determine the
 * type of the file without fully allocating tHWMAFileState.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileIsWMA(tWMAFileHdrState *state);
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                yes, it's a WMA file
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus WMAFileIsWMA (tWMAFileHdrState *state);


/*
 *        WMAGetNumberOfMarkers
 *        ============
 *
 * Description
 * -----------
 * Return the total number of Markers in the asf file
 *
 * Syntax
 * ------
 *  int WMAGetNumberOfMarkers(tWMAFileHdrState *state);  
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   total number of Markers in the asf file
 *
 */

int WMAGetNumberOfMarkers(tWMAFileHdrState *state);  



/*
 *        WMAGetMarker
 *        ============
 *
 * Description
 * -----------
 * WMAGetMarker(...) is designed to return the Marker specified by an index integer iIndex
 * If the total number of Markers returned by WMAGetNumberOfMarkers is total_num_of_markers, 
 * all the Markers are indexed from 0 to total_num_of_markers - 1.  
 * When a Marker structure MarkerEntry is allocated by the application
 * and the pointer to that Marker structure is passed in WMAGetMarker(...) with pEntry,
 * succesful calling of WMAGetMarker(...) will fill up the Marker structure *pEntry
 * with the Marker identified by the index iIndex.
 *
 * Syntax
 * ------
 *   int WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry); 
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pEntry         pointer to the Marker structure MarkerEntryEx 
 *                  allocated by the application  
 *   iIndex         index to specify which Marker to return
 *
 * Return Value
 * ------------
 * return the total number of Markers in the asf file 
 *      if WMAGetMarker(...) succeed in returning the Marker specified by iIndex.            
 * return 0 
 *      if WMAGetMarker(...) failed in returning the Marker specified by iIndex.  
 */

int WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry); 



/*
 *        WMAGetLicenseStore
 *        ============
 *
 * Description
 * -----------
 * Get the marker list so the main program can seek the file freely.
 *
 * Syntax
 * ------
 * BYTE * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen)
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pLen           Address of the poitner to store the size of license.
 *
 * Return Value
 * ------------
 * Pointer of data chunck
 *
 */
unsigned char * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen);

/*
 *        WMAFileCBGetData
 *        ================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio decoder.  Not implemented by
 * the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio library needs more data to process (both to parse
 * informatio and to decode the actual data bitstream), the library
 * will call this function.
 *
 * Called by WMAFileDecodeInit(), WMAFileContentDesc() and
 * WMAFileDecodeData().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetData(tHWMAFileState hstate,
 *                             tWMA_U32 offset,
 *                             tWMA_U32 num_bytes,
 *                             unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the WMA file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *                  The WMA library may over-write this buffer
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */
extern tWMA_U32 WMAFileCBGetData (
    tHWMAFileState hstate,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);


/*
 *        WMAFileCBGetLicenseData
 *        =======================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio DRM decryption function.  Not
 * implemented by the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio's DRM decryption library needs more data to process
 * the library will call this function.
 *
 * Called by WMAFileLicenseInit().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetLicenseData(tHWMAFileState *state,
 *                                    tWMA_U32 offset,
 *                                    tWMA_U32 num_bytes,
 *                                    unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the license file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */
extern tWMA_U32 WMAFileCBGetLicenseData (
    tHWMAFileState *pstate,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);


/*
 *        WMAFileDecodeInit
 *        =================
 *
 * Description
 * -----------
 * Initializes the WMAudio decoder.
 *
 * Must be called before starting to decode a WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInit(tHWMAFileState *state);
 *
 * where:
 *
 *   phstate        pointer to the handle that holds the internal
 *                  state of the WMAudio decoder
 *                  This memory should be cleared before the first call
 *                  to WMAFileDecodeInit
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                decoder initialised
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *   cWMA_BadSamplingRate      invalid or unsupported sampling rate
 *   cWMA_BadNumberOfChannels  invalid or unsupported number of channels
 *   cWMA_BadVersionNumber     invalid or unsupported version number
 *   cWMA_BadWeightingMode     invalid or unsupported weighting mode
 *   cWMA_BadPacketisation     invalid or unsupported packetisation
 *   cWMA_BadDRMType           unknown encryption type
 *   cWMA_DRMFailed            DRM failed
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileDecodeInit (tHWMAFileState* phstate);


tWMAFileStatus WMAFileDecodeClose (tHWMAFileState* phstate);

/*
 *       WMAFileDecodeInfo
 *       =================
 *
 * Description
 * -----------
 * Retrieves the header information for the WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInfo(tHWMAFileState hstate,
 *                                    tWMAFileHeader *hdr);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   hdr            pointer to the structure that holds the WMA file
 *                  header info
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                header retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *
 */

tWMAFileStatus WMAFileDecodeInfo (tHWMAFileState hstate, tWMAFileHeader *hdr);


/*
 *       WMAFileContentDesc
 *       ==================
 *
 * Description
 * -----------
 * Retrieves the content description for the WMA file.  Content
 * descriptions are such as the song title, the author, the
 * copyright info, the song description, and the rating info.
 * All these are part of the standard ASF description.
 *
 * Not all songs have content descriptions.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileContentDesc(tHWMAFileState hstate,
 *                                     tWMAFileContDesc *desc);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   desc           pointer to the structure that holds the WMA file
 *                  content description info
 *                  as [in], must provide the buffer(s) and the size(s)
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                description retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus WMAFileContentDesc (tHWMAFileState hstate, tWMAFileContDesc *desc);


/*
 *       WMAFileLicenseInit
 *       ==================
 *
 * Description
 * -----------
 * Reads the DRM license file and check the license for the file.
 *
 * Uses WMAFileCBGetLicenseData to retrieve the license file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileLicenseInit(tHWMAFileState hstate,
 *                                     tWMAFileLicParams *lic_params);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   lic_params     pointer to the structure that passes in the
 *                  parameters for the license initialization.
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                license checked ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_DRMFailed            no license
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileLicenseInit (tHWMAFileState hstate, tWMAFileLicParams *lic_params, tWMA_U16 CheckLicTypes);


/*
 *       WMAFileDecodeData
 *       =================
 *
 * Description
 * -----------
 * Decodes WMAudio bitstream.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeData(tHWMAFileState hstate);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                frame decoded ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_BrokenFrame          data is inconsistent
 *   cWMA_NoMoreFrames         no more data to decode
 *
 */
tWMAFileStatus WMAFileDecodeData (tHWMAFileState hstate);


/*
 *       WMAFileGetPCM
 *       =============
 *
 * Description
 * -----------
 * Write PCM samples from the WMAudio bitstream previously decoded by
 * WMAFileDecodeData().
 *
 * WMAFileGetPCM() may have to be called more than once to obtain all
 * of the samples for the frame. The frame is complete when the number
 * of samples written is less than the number of samples requested.
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileGetPCM(tHWMAFileState hstate,
 *                          tWMA_I16 *left, tWMA_I16 *right,
 *                          tWMA_U32 max_nsamples);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   pi16Channel0   pointer to output buffer for left-channel PCM, or the entire PCM output if it is inter-leaved form
 *   pi16Channel1   pointer to output buffer for right-channel PCM, NULL if the output PCM is in parallel form
 *   max_nsamples   maximum number of samples to write per channel
 *
 * Return Value
 * ------------
 *   tWMA_U32       number of samples written
 *                  < max_nsamples when frame complete
 *
 */
tWMA_U32 WMAFileGetPCM (
    tHWMAFileState hstate,
    tWMA_I16 *pi16Channel0, tWMA_I16 *pi16Channel1,
    tWMA_U32 max_nsamples);


/*
 *       WMAFileSeek
 *       ===========
 *
 * Description
 * -----------
 * Seek to a time into the WMA file.  It seeks to the nearest seek
 * point.
 *
 * Syntax
 * ------
 *   tWMA_32 WMAFileSeek(tHWMAFileState hstate,
 *                       tWMA_U32 msSeek);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   msSeek         time position to seek from the beginning of the
 *                  clip, in milliseconds
 *
 * Return Value
 * ------------
 *   tWMA_32        actual time position from the beginning of the
 *                  clip, in milliseconds
 *
 */
tWMA_U32 WMAFileSeek (tHWMAFileState hstate, tWMA_U32 msSeek);


/*
 *       WMADebugMessage
 *       ===============
 *
 * Description
 * -----------
 * Display a debugging message. This function needs to be implemented by the app that calls WMEPAK.
 * These messages are meant for the device/application developer, not the end user.
 * Display the message using fprintf, messagebox, or whatever method is suitable to your platform.
 * See the sample code for an example implementation.
 * Make it a empty-body function if the intent is to skip this operation.
 *
 * Syntax
 * ------
 *		WMADebugMessage(const char* pszFmt,
 *						...);
 *
 * where:
 *
 *   pszFmt		    pointer to a null terminated printf like format string
 *   ...			variable number of arguments referenced by the format string
 *
 * Return Value
 * ------------
 *   none
 *
 */
extern void WMADebugMessage (const char*pszFmt, ...);



#ifdef __cplusplus
}
#endif /* __cplusplus */

/*
#ifdef USE_PACK_HEADERS
#include <poppack.h>
#endif
*/

#endif /* _WMAUDIO_API_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\wmav\wmf_types.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 2000

Module Name:

    wmfencode.h

Abstract:

    API's for light WMF SDK Encoder.

Revision History:


*************************************************************************/

#ifndef _WMF_TYPES_H_
#define _WMF_TYPES_H_

/*********  Basic type Definitions  *************/

#ifndef WMF_TYPE_DEFINED
#define WMF_TYPE_DEFINED

typedef void Void_WMF;
typedef long I32_WMF;
typedef unsigned long U32_WMF;
typedef short I16_WMF;
typedef unsigned short U16_WMF;
#if defined(macintosh) || defined(_Embedded_x86)
typedef wchar_t U16Char_WMF;
#else
typedef unsigned short U16Char_WMF;
#endif
typedef char I8_WMF;
typedef unsigned char U8_WMF;
typedef long Bool_WMF;
typedef double Double_WMF;
typedef float Float_WMF;
typedef struct tQWORD_WMF
{
    U32_WMF   dwLo;
    U32_WMF   dwHi;

}   QWORD_WMF;


#if defined(macintosh) || defined(_Embedded_x86)
typedef unsigned long long  U64_WMF;
typedef long long  I64_WMF;
#elif defined(HITACHI)
typedef struct tU64_WMF
{
    U32_WMF   dwLo;
    U32_WMF   dwHi;
}   U64_WMF;
typedef struct tI64_WMF
{
    I32_WMF   dwLo;
    I32_WMF   dwHi;
}   I64_WMF;
#else
typedef unsigned __int64    U64_WMF;
typedef __int64    I64_WMF;
#endif


#define TRUE_WMF    1
#define FALSE_WMF   0

#endif // WMF_TYPE_DEFINED


/************************************************/


// GUID definiton

#ifndef MAKEFOURCC_WMF
#define MAKEFOURCC_WMF(ch0, ch1, ch2, ch3) \
        ((U32_WMF)(U8_WMF)(ch0) | ((U32_WMF)(U8_WMF)(ch1) << 8) |   \
        ((U32_WMF)(U8_WMF)(ch2) << 16) | ((U32_WMF)(U8_WMF)(ch3) << 24 ))

#define mmioFOURCC_WMF(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMF(ch0, ch1, ch2, ch3)
#endif


/******* video output type guids, in preference order  *****/

#define FOURCC_WMV2     mmioFOURCC_WMF('W','M','V','2')
#define FOURCC_WMV1     mmioFOURCC_WMF('W','M','V','1')
#define FOURCC_M4S2     mmioFOURCC_WMF('M','4','S','2')
#define FOURCC_MP43     mmioFOURCC_WMF('M','P','4','3')
#define FOURCC_mp43     mmioFOURCC_WMF('m','m','4','3')
#define FOURCC_MP4S     mmioFOURCC_WMF('M','P','4','S')
#define FOURCC_mp4s     mmioFOURCC_WMF('m','p','4','s')
#define FOURCC_MP42     mmioFOURCC_WMF('M','P','4','2')
#define FOURCC_mp42     mmioFOURCC_WMF('m','m','4','2')
#define FOURCC_MSS1     mmioFOURCC_WMF('M','S','S','1')

/***********************************************************/


/******* video intput type guids, in preference order  *****/

#define FOURCC_I420		        0x30323449
#define FOURCC_IYUV		        0x56555949
#define FOURCC_YV12		        0x32315659
#define FOURCC_YUY2		        0x32595559
#define FOURCC_UYVY		        0x59565955
#define FOURCC_YVYU		        0x55595659
#define FOURCC_YVU9		        0x39555659
#define FOURCC_BI_RGB   	    0x00000000
#define FOURCC_BI_BITFIELDS	    0x00000003

/***********************************************************/

typedef struct tagWMFContentDescription
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    U16_WMF uiTitle_len;
    U16_WMF uiAuthor_len;
    U16_WMF uiCopyright_len;
    U16_WMF uiDescription_len;   /* rarely used */
    U16_WMF uiRating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    U16Char_WMF *pchTitle;
    U16Char_WMF *pchAuthor;
    U16Char_WMF *pchCopyright;
    U16Char_WMF *pchDescription;
    U16Char_WMF *pchRating;

} WMFContentDescription;

/******************************************************************
**   Extended content description types:
**   ECD_STRING -- wchar string
**   ECD_BINARY -- binary (byte) data
**   ECD_BOOL   -- BOOL (int) data
**   ECD_WORD  -- contains one word,
**   ECD_DWORD  -- contains one dword,
**   ECD_QWORD  -- contains one qword,
*******************************************************************/

enum {
    ECD_STRING = 0,
    ECD_BINARY = 1,
    ECD_BOOL = 2,
    ECD_DWORD = 3,
    ECD_QWORD = 4,
    ECD_WORD = 5
};

#pragma pack (1)
typedef struct _CommandEntry {
    U32_WMF         time;
    U16_WMF         type;
    U16Char_WMF     *param;
} CommandEntry;


typedef struct _ECD_DESCRIPTOR {
    U16_WMF         cbName;
    U16Char_WMF     *pwszName;
    U16_WMF         data_type;
    U16_WMF         cbValue;
    union {
        U16Char_WMF *pwszString;
        U8_WMF *pbBinary;
        Bool_WMF *pfBool;
        U32_WMF *pdwDword;
        U64_WMF *pqwQword;
        U16_WMF  *pwWord;
    } uValue;
} ECD_DESCRIPTOR;

typedef struct _MarkerEntry {
    U64_WMF     m_qOffset;
    U64_WMF     m_qtime;
    U16_WMF     m_wEntryLen;
    U32_WMF     m_dwSendTime;
    U32_WMF     m_dwFlags;
    U32_WMF     m_dwDescLen;
    U16Char_WMF *m_pwDescName;
} MarkerEntry;


#pragma pack ()



#pragma pack (1)
#pragma pack ()
#endif // _WMF_TYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\game\game.cpp ===
//=============================================================================
// File: XDemos.cpp
//
// Desc: This is the main module for the XDemos project
// Created: 07/02/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================
#include <xtl.h>
#include <assert.h>
#include "XDemos\Image\XImage.h"


//=============================================================================
//=============================================================================
#define WIDTH	640
#define HEIGHT	480

//=============================================================================
// Global variables
//=============================================================================
LPDIRECT3D8				g_pD3D			= NULL;
LPDIRECT3DDEVICE8		g_pd3dDevice	= NULL;
LPDIRECT3DTEXTURE8		g_pTexture		= NULL;
HANDLE					g_hInput[12]	= {0};
XImage					g_Background;
DWORD					g_dwDeviceState	= 0;

//=============================================================================
//=============================================================================
HRESULT InitD3D()
{
    // Create the D3D object, which is used to create the D3DDevice.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory( &d3dpp, sizeof(d3dpp) );

    // Set fullscreen 640x480x32 mode
    d3dpp.BackBufferWidth        = WIDTH;
    d3dpp.BackBufferHeight       = HEIGHT;
    d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;

    // Create one backbuffer and a zbuffer
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Set up how the backbuffer is "presented" to the frontbuffer each frame
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device. Hardware vertex processing is specified
    // since all vertex processing takes place on Xbox hardware.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // After creating the device, initial state would normally be set

    return S_OK;
}



//=============================================================================
//=============================================================================
HRESULT InitBackground(void)
{
	DWORD dwLaunchType;
	LAUNCH_DATA ld;

	// were we launched by XDemos?
	if (XGetLaunchInfo(&dwLaunchType, &ld) == ERROR_SUCCESS)
	{
		if ((dwLaunchType == LDT_TITLE) && (!strcmp((char *)ld.Data, "XDEMOS")))
			g_Background.Load(g_pd3dDevice, "D:\\game2.png");
		else
			g_Background.Load(g_pd3dDevice, "D:\\game.png");
	}
	else
		g_Background.Load(g_pd3dDevice, "D:\\game.png");


	return S_OK;
}

//=============================================================================
//=============================================================================
void HandleDeviceChanges(XPP_DEVICE_TYPE *pxdt, DWORD dwInsert, DWORD dwRemove)
{

	return;
}

//=============================================================================
//=============================================================================
HANDLE GetController(bool bFirst, int *pnum=NULL)
{
	static int i=0;

	if (bFirst)
		i=0;

	for ( ; i<12 ; i++)
	{
		if (g_dwDeviceState & (1<<i))
		{
			if (pnum)
			{
				*pnum = i;
			}
			return g_hInput[i++];
		}
	}

	return NULL;
}

//=============================================================================
//=============================================================================
void HandleInput(void)
{
	DWORD				dwInsert;
	DWORD				dwRemove;
	XINPUT_STATE		xis;
	static XINPUT_STATE	xis_old[12] = {0};

	if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsert, &dwRemove))
	{
		HandleDeviceChanges(XDEVICE_TYPE_GAMEPAD, dwInsert, dwRemove);

		g_dwDeviceState &= ~dwRemove;
		g_dwDeviceState |= dwInsert;

		for( DWORD i=0; i < XGetPortCount(); i++ )
		{
			// Handle removed devices.
			if( dwRemove & (1<<i) ) 
			{
				XInputClose( g_hInput[i] );
				g_hInput[i] = NULL;
			}

			if( dwInsert & (1<<i) ) 
			{
				g_hInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
			}

		}

	}


	HANDLE hPad;

	int n;
	hPad=GetController(true, &n);

	while (hPad)
	{

		XInputGetState(hPad, &xis);

		// only process messages if they're different

		if ((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y]))
		{
			// launch XDemos here
			LAUNCH_DATA ld;
			XLaunchNewImage("d:\\XDemos\\XDemos.xbe", &ld);
		}

		if ((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]))
		{
			// launch XDemos here
			LAUNCH_DATA ld;
			XLaunchNewImage("d:\\XDemos\\XDemos.xbe", &ld);
		}

		xis_old[n] = xis;

		hPad=GetController(false, &n);

	}
}

//=============================================================================
//=============================================================================
HRESULT InitInput(void)
{
	XDEVICE_PREALLOC_TYPE xdpt[] = {
		{XDEVICE_TYPE_GAMEPAD, 4},
	};

	XInitDevices(sizeof(xdpt)/sizeof(xdpt[0]), xdpt);

	g_dwDeviceState = XGetDevices(XDEVICE_TYPE_GAMEPAD);

	g_hInput[0]		= XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
	g_hInput[1]		= XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT1, XDEVICE_NO_SLOT, NULL);
	g_hInput[2]		= XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT2, XDEVICE_NO_SLOT, NULL);
	g_hInput[3]		= XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT3, XDEVICE_NO_SLOT, NULL);

	return S_OK;
}


//=============================================================================
//=============================================================================
VOID Render()
{
	// Cycle through some colors to clear the screen (just to show some output)
	static FLOAT r = 0.0f; if( (r+=1.3f) > 255.0f ) r = 0.0f;
	static FLOAT g = 0.0f; if( (g+=1.7f) > 255.0f ) g = 0.0f;
	static FLOAT b = 0.0f; if( (b+=1.5f) > 255.0f ) b = 0.0f;

	// Clear the backbuffer to a changing color
	//g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( (int)r, (int)g, (int)b ), 1.0f, 0L );
	g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

	// Begin the scene
	g_pd3dDevice->BeginScene();

	g_Background.Blt();

    // End the scene
    g_pd3dDevice->EndScene();
}


//=============================================================================
//=============================================================================
void __cdecl main()
{
    if (FAILED(InitD3D()))
        return;

	if (FAILED(InitBackground()))
		return;

	if (FAILED(InitInput()))
		return;

    while (true)
    {
		HandleInput();
        Render();
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\DemoLegal\demolegal.h ===
#ifndef DEMOLEGAL_H
#define DEMOLEGAL_H

#include "gamepad.h"

#define SCREEN_WIDTH   640
#define SCREEN_HEIGHT  480

#define TEXTUREWIDTH  1024
#define TEXTUREHEIGHT 1024

extern LPDIRECT3D8             g_pD3D;		 // Used to create the D3DDevice
extern LPDIRECT3DDEVICE8       g_pd3dDevice; // Our rendering device
extern LPDIRECT3DVERTEXBUFFER8 g_pVB;		 // Buffer to hold vertices

//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: structure for holding emulator vertex data
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; 
    DWORD color;        
	FLOAT tu, tv;
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)

static const CUSTOMVERTEX g_Vertices[] =
{
    { 0.0f,   0.0f,    0.5f, 1.0f, 0xffffffff, 0.0f, 0.0f}, // x, y, z, rhw, color, tu, tv
    { 640.0f, 0.0f,    0.5f, 1.0f, 0xffffffff, 1.0f, 0.0f},
    { 0.0f,   480.0f,  0.5f, 1.0f, 0xffffffff, 0.0f, 1.0f},
	{ 640.0f, 480.0f,  0.5f, 1.0f, 0xffffffff, 1.0f, 1.0f},
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\DemoLegal\gamepad.cpp ===
#include "gamepad.h"

XBGAMEPAD g_Gamepads[4];

HRESULT InitInput(void)
{
	XDEVICE_PREALLOC_TYPE deviceTypes[] =
	{
	   {XDEVICE_TYPE_GAMEPAD, 4},
	   {XDEVICE_TYPE_MEMORY_UNIT, 2}
	};
	XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes );

   // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    return S_OK;
}

//
// Poll controllers for input, if we detect any, we should return true;
//
bool PollControllers(void)
{
	// check to make sure a controller is unplugged
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i = 0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        g_Gamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( g_Gamepads[i].bRemoved )
        {
            XInputClose( g_Gamepads[i].hDevice );
            g_Gamepads[i].hDevice = NULL;
            g_Gamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            g_Gamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        g_Gamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( g_Gamepads[i].bInserted ) 
        {
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( g_Gamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( g_Gamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            memcpy( &g_Gamepads[i], &xiState.Gamepad, sizeof(XINPUT_STATE) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (g_Gamepads[i].sThumbLX+0.5f)/32767.5f;
            g_Gamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (g_Gamepads[i].sThumbLY+0.5f)/32767.5f;
            g_Gamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (g_Gamepads[i].sThumbRX+0.5f)/32767.5f;
            g_Gamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (g_Gamepads[i].sThumbRY+0.5f)/32767.5f;
            g_Gamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            g_Gamepads[i].wPressedButtons = ( g_Gamepads[i].wLastButtons ^ g_Gamepads[i].wButtons ) & g_Gamepads[i].wButtons;
            g_Gamepads[i].wLastButtons    = g_Gamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b = 0; b < 8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( g_Gamepads[i].bAnalogButtons[b] > 0 );

                if( bPressed )
                    g_Gamepads[i].bPressedAnalogButtons[b] = !g_Gamepads[i].bLastAnalogButtons[b];
                else
                    g_Gamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                g_Gamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }

	//
	// For all the joysticks
	//
	for(int n = 0; n < 4; n++)
	{
		if(g_Gamepads[n].wButtons & XINPUT_GAMEPAD_DPAD_UP)			return true;
		if(g_Gamepads[n].wButtons & XINPUT_GAMEPAD_DPAD_DOWN)		return true;
		if(g_Gamepads[n].wButtons & XINPUT_GAMEPAD_DPAD_LEFT)		return true;
		if(g_Gamepads[n].wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)		return true;
		if(g_Gamepads[n].wButtons & XINPUT_GAMEPAD_BACK)			return true;
		if(g_Gamepads[n].wButtons & XINPUT_GAMEPAD_START)			return true;
		if(g_Gamepads[n].bAnalogButtons[XINPUT_GAMEPAD_A] > XBINPUT_DEADZONE)	return true;
		if(g_Gamepads[n].bAnalogButtons[XINPUT_GAMEPAD_B] > XBINPUT_DEADZONE)	return true;
		if(g_Gamepads[n].bAnalogButtons[XINPUT_GAMEPAD_X] > XBINPUT_DEADZONE)	return true;
		if(g_Gamepads[n].bAnalogButtons[XINPUT_GAMEPAD_Y] > XBINPUT_DEADZONE)	return true;
		if(g_Gamepads[n].bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XBINPUT_DEADZONE)	return true;
		if(g_Gamepads[n].bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XBINPUT_DEADZONE)	return true;

		if(g_Gamepads[n].fX1 > 0.0f) return true;
		if(g_Gamepads[n].fX1 < 0.0f) return true;
		if(g_Gamepads[n].fY1 > 0.0f) return true;
		if(g_Gamepads[n].fY1 < 0.0f) return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\DemoLegal\demolegal.cpp ===
#include <xtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <xgraphics.h>
#include "demolegal.h"

//-----------------------------------------------------------------------------
struct DEMO_LAUNCH_DATA
{
	DWORD	dwID;				// I don't know what I'll use this for, yet...
	DWORD	dwRunmode;
	DWORD	dwTimeout;
	char	szLauncherXBE[64];	// name of XBE to launch to return
	char	szLaunchedXBE[64];	// name of your XBE, useful to get path info from
	char	szDemoInfo[MAX_LAUNCH_DATA_SIZE - (128 * sizeof(char)) - (3 * sizeof(DWORD))];
								// set in XDI file, additional info/parameters/whatever
};

#define RUNMODE_KIOSKMODE		0x01
#define RUNMODE_USERSELECTED	0x02

//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D = NULL;		 // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device
LPDIRECT3DVERTEXBUFFER8 g_pVB = NULL;		 // Buffer to hold vertices
LPDIRECT3DTEXTURE8		g_ptexture;			 // The texture surface to hold the warning


//
// XB texture variables
//
#define resource_NUM_RESOURCES 1UL
#define resource_background_OFFSET 0UL
BYTE*	g_pResourceSysMemData = NULL; // Sysmem data for the packed resource
BYTE*   g_pResourceVidMemData = NULL; // Vidmem data for the packed resource

//
// Timer to exit
//
#define EXIT_TIME 10  // 10 seconds
int g_nStarttime;

DEMO_LAUNCH_DATA		g_ld;
char *					g_pszDirectory;

void DbgPrint(char *str)
{
	OutputDebugString(str);	
}

//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D(void)
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Get the current desktop display mode, so we can set up a back
    // buffer of the same format
    D3DDISPLAYMODE d3ddm;
    if( FAILED( g_pD3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &d3ddm ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory( &d3dpp, sizeof(d3dpp) );

    d3dpp.Windowed						  = FALSE;
    d3dpp.SwapEffect					  = D3DSWAPEFFECT_DISCARD;
	d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
	d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
	d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount                 = 1;
	d3dpp.MultiSampleType				  = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN ;
	d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;

    // Create the D3DDevice
    if( FAILED( g_pD3D->CreateDevice( D3DADAPTER_DEFAULT,
									  D3DDEVTYPE_HAL, 
									  NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, 
									  &g_pd3dDevice ) ) )
    {
		DbgPrint( "Initialize():Failed to CreateDevice!\n" );
        return E_FAIL;
    }

	g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    return S_OK;
}

HRESULT InitVB()
{

    // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 4 * sizeof(CUSTOMVERTEX),
                                                  0, 
												  D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, 
												  &g_pVB ) ) )
    {
        return E_FAIL;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
    VOID* pVertices;
    if( FAILED( g_pVB->Lock( 0, sizeof(g_Vertices), (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    memcpy( pVertices, g_Vertices, sizeof(g_Vertices) );
    g_pVB->Unlock();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LoadPackedResource()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT LoadPackedResource()
{
	char legalTexture[MAX_PATH];

	strcpy(legalTexture, g_pszDirectory);
	strcat(legalTexture, "legaltext.xbx");

    // Open the fileto read the XPR headers
    FILE* file = fopen( legalTexture, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugStringA( "ERROR: Invalid Xbox Packed Resource (.xpr) file" );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    g_pResourceSysMemData = new BYTE[dwSysMemDataSize];
    g_pResourceVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( g_pResourceSysMemData, dwSysMemDataSize, 1, file );
    fread( g_pResourceVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = g_pResourceSysMemData;

    for( DWORD i = 0; i < resource_NUM_RESOURCES; i++ )
    {
        // Get the resource
        LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;

        // Register the resource
        pResource->Register( g_pResourceVidMemData );
    
        // Advance the pointer
        switch( pResource->GetType() )
        {
            case D3DRTYPE_TEXTURE:       pData += sizeof(D3DTexture);       break;
            case D3DRTYPE_VOLUMETEXTURE: pData += sizeof(D3DVolumeTexture); break;
            case D3DRTYPE_CUBETEXTURE:   pData += sizeof(D3DCubeTexture);   break;
            case D3DRTYPE_VERTEXBUFFER:  pData += sizeof(D3DVertexBuffer);  break;
            case D3DRTYPE_INDEXBUFFER:   pData += sizeof(D3DIndexBuffer);   break;
            case D3DRTYPE_PALETTE:       pData += sizeof(D3DPalette);       break;
            default:                     return E_FAIL;
        }
    }

    return S_OK;
}

void InitTexture(void)
{
	LoadPackedResource();

	//
    // Access the menu background texture from the xbx file
	//
    g_ptexture = (LPDIRECT3DTEXTURE8)&g_pResourceSysMemData[ resource_background_OFFSET ];

	if( FAILED( g_pd3dDevice->SetTexture( 0, g_ptexture )))
    {
        DbgPrint( "InitTexture():Failed to set texture!!\n" );
    }
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
}

//-----------------------------------------------------------------------------
// Name: DrawScreen()
// Desc: Renders the texture to the screen
//-----------------------------------------------------------------------------

bool DrawScreen (void)
{
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );

    //
	// Begin the scene
	//
    g_pd3dDevice->BeginScene();
	g_pd3dDevice->SetTexture( 0, g_ptexture );
    g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

	//
    // End the scene
	//
    g_pd3dDevice->EndScene();

    //
	// Present the backbuffer contents to the display
	//
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	return (TRUE);
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Releases all previously initialized objects
//-----------------------------------------------------------------------------
VOID Cleanup()
{
    if( g_pVB != NULL )        
        g_pVB->Release();

    if( g_pd3dDevice != NULL ) 
        g_pd3dDevice->Release();

    if( g_pD3D != NULL )       
        g_pD3D->Release();	 
}

//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
	static char string[256];
	DWORD dwLaunchInfo;

	if ((XGetLaunchInfo(&dwLaunchInfo, (LAUNCH_DATA *)&g_ld)==ERROR_SUCCESS) && ((dwLaunchInfo&3) == LDT_TITLE))
	{
		// we were probably launched from XDemos, so get the path from it
		strcpy(string, g_ld.szLaunchedXBE);
		char *p=string;
		for ( ; *p ; p++);
		for ( ; *p != '\\' && p>string ; p--);
		strcpy(p, "\\media\\");
		g_pszDirectory = string;
	}
	else
	{
		g_ld.szLauncherXBE[0]=0;
		g_pszDirectory = "d:\\Media\\";
	}

	//
    // Initialize Direct3D
	//
    if( SUCCEEDED( InitD3D() ) )
    {
		//
        // Create the vertex buffer
		//
        if( SUCCEEDED( InitVB() ) )
        {
			//
			// Initalize the texture canvas
			//
			InitTexture();
			InitInput();

			g_nStarttime = GetTickCount();
			
			while (1)
			{
				DrawScreen();

				//
				// Exit if controller input
				//
				if(PollControllers())
					break;

				//
				// Exit if longer than 10 seconds
				//
				if(((GetTickCount() - g_nStarttime) / 1000) > EXIT_TIME)
					break;
				
			}

        }
    }

	//
    // Clean up everything and exit the app
	//
    Cleanup();

	XLaunchNewImage(g_ld.szLauncherXBE, (LAUNCH_DATA *)&g_ld);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\DemoLegal\gamepad.h ===
#ifndef GAMEPAD_H
#define GAMEPAD_H

#include <xtl.h>

//
// Deadzone for thumbsticks
//
#define XBINPUT_DEADZONE 0.24f

//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};

//
// Global instance of gamepad devices
//
extern XBGAMEPAD g_Gamepads[4];

HRESULT InitInput(void);
bool PollControllers(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\wmav\wma_enc_win32_x86.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 2000

Module Name:

    wmfencode.h

Abstract:

    API's for light WMF SDK Encoder.

Revision History:


*************************************************************************/


#ifndef _WMF_ENCODE_H_
#define _WMF_ENCODE_H_

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include "wmf_types.h"
typedef void* HWMFENCODER;

/*********  Return status code  *********/
#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else 
#define EXTERN_C extern 
#endif
#endif

typedef enum tagWMFEncodeStatus
{
    WMF_Succeeded = 0,
    WMF_Failed,
    WMF_BadMemory,
    WMF_InValidArguments,
    WMF_EncPacketsDone,

    WMA_Failed,
    WMA_BadMemory,
    WMA_EncodeFailed,
    WMA_UnSupportedInputFormat,
    WMA_UnSupportedCompressedFormat,
    WMA_InValidArguments,
    WMA_BadSource,

    WMV_Failed,
    WMV_BadMemory,
    WMV_EncodeFailed,
    WMV_UnSupportedInputFormat,
    WMV_UnSupportedCompressedFormat,
    WMV_InValidArguments,
    WMV_BadSource
} tWMFEncodeStatus;

/*****************************************/


/*********  Encoding profiles  ***********/

typedef enum tagWMFEncodeProfile
{
    Profile_AudioVideo_Modem_28K = 0, // 20K actual bitrate
    Profile_AudioVideo_Modem_56K, // 32K actual bitrate
    Profile_AudioVideo_LAN_100K,
    Profile_AudioVideo_LAN_256K, // 225K 
    Profile_AudioVideo_LANDSL_384K, // 350K
    Profile_AudioVideo_LANDSL_768K, // 450K
    Profile_AudioVideo_NearBroadCast_700K,
    Profile_AudioVideo_NearBroadCast_1400K,
    Profile_AudioOnly_FMRadioMono_28K, // for 288 modem
    Profile_AudioOnly_FMRadioStereo_28K, // for 288 modem
    Profile_AudioOnly_Modem_56K, // for 56K modem
    Profile_AudioOnly_NearCDQuality_64K,
    Profile_AudioOnly_CDQuality_96K,
    Profile_AudioOnly_CDTransparency_128K,
    Profile_AudioOnly_HighestQuality_192K,
    Profile_VideoOnly_Modem_28K, // 20K
    Profile_VideoOnly_Modem_56K // 32K actual bitrate
} WMFEncodeProfile;

/*****************************************/

/***************************  Call back functions  *******************************/

/*
 *        WMFGetAudioData
 *        ===============
 *
 * Description
 * -----------
 * Call back funtion from the SDK to get the requested audio data from the app.
 * The app is responsible for implementing this funtion. SDK calls this funtion to get the audio data while encoding.
 *
 * Arguments
 * ---------
 *
 *   ppbAudioDataBuffer     The memory buffer that the app should write the audio data to. The app can change the pointer if necessary.
 *   nInputBufferLen        Length  of the buffer space (in bytes).
 *   iSampleOffset          Offset (from the beginning, in number of samples) that the requested audio data starts.
 *   iNumSamplesWanted      Number of audio samples requested to be filled in pbAudioDataBuffer.
 *
 * Return Value
 * ------------
 *   Int                    Number of samples returned from app.
 *
 */

EXTERN_C I32_WMF WMFGetAudioData (U8_WMF **pbAudioDataBuffer, U32_WMF nInputBufferLen, I32_WMF iSampleOffset, I32_WMF iNumSamplesWanted);


/*
 *        WMFGetVideoData
 *        ===============
 *
 * Description
 * -----------
 * Call back funtion from the SDK to get the requested video data from the app.
 * The app is responsible for implementing this funtion. SDK calls this funtion to get the video data while encoding.
 *
 * Arguments
 * ---------
 *
 *   ppbVideoDataBuffer     The memory buffer that the app should write the video data to. The app can change the pointer if necessary.
 *   nInputBufferLen        Length  of the buffer space (in bytes).
 *   iFrameOffset           Offset (from the beginning, in number of frames) that the requested video data starts.
 *   iNumFramesWanted      Number of video frames requested to be filled in pbVidioDataBuffer.
 *
 * Return Value
 * ------------
 *   Int                    Number of number of bytes returned from app.
 *
 */

EXTERN_C I32_WMF WMFGetVideoData (U8_WMF **ppbVideoDataBuffer, U32_WMF nInputBufferLen, I32_WMF iFrameOffset, I32_WMF iNumFramesWanted);


/*********************************************************************************/

/***************************  FUNCTIONS  *******************************/

/*
 *        WMFGetRecommendedVideoFrameRate
 *        ===============================
 *
 * Description
 * -----------
 * Get a recommended frame rate (frames per second) from the SDK. This is an OPTIONAL funtion call.
 * This function is expected to be called before WMFCreateEncoderUsingCustom of WMFCreateEncoderUsingProfile.
 *
 * Arguments
 * ---------
 *
 *   piRecommendedFPS       Pointer to the value recommended (set) by SDK.
 *   dwVideoBitRate         Bitrate for video to be encoded.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMV_InValidArguments   Bad argument passed in (bitrate out of range).
 *
 */

tWMFEncodeStatus WMFGetRecommendedVideoFrameRate (I32_WMF *piRecommendedFPS, I32_WMF dwVideoBitRate);

/*
 *        WMFIsThereAudioStream
 *        =====================
 *
 * Description
 * -----------
 * Return the property of the encoder event. Return if the event contains an audio stream.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   bIsThereAudio          Pointer to the value set by SDK.
 *                          * TRUE: There is an audio stream.
 *                          * FALSE: There is no audio stream.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMF_BadMemory          hWMFEnc is bad.
 *
 */

tWMFEncodeStatus WMFIsThereAudioStream (Bool_WMF *bIsThereAudio, HWMFENCODER hWMFEnc);

/*
 *        WMFIsThereVideoStream
 *        =====================
 *
 * Description
 * -----------
 * Return the property of the encoder event. Return if the event contains a video stream.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   bIsThereVideo          Pointer to the value set by SDK.
 *                          * TRUE: There is a video stream.
 *                          * FALSE: There is no video stream.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMF_BadMemory          hWMFEnc is bad.
 *
 */

tWMFEncodeStatus WMFIsThereVideoStream (Bool_WMF *bIsThereVideo, HWMFENCODER hWMFEnc);

/*
 *        WMFCreateEncoderUsingCustom
 *        ===========================
 *
 * Description
 * -----------
 * Create the WMF encoder using the specified custom settings for audio and video.
 *
 * Arguments
 * ---------
 *
 *   ptStatus               Pointer to the status of encoder creation.  It can be one of the value in tagWMFEncodeStatus.
 *   pchOutFilename         Pointer to the name of the encoded ASF file.
 *
 *********  The following are the audio properties.
 *
 *   dwAudioBitRate         Bitrate for the audio (in bits per second).
 *                          * The SDK enumerates this rate and pick the closest one in the list.
 *                          * Value 0 is for video only (no audio) ASF file. The properties (arguments) for audio will be ignored.
 *   nSrcChannels           Number of channels in the source file (valid number: 1 or 2).
 *   nSrcSamplesPerSec      Sampling rate in the source file.  The SDK enumerates this rate and pick the closest one in the list.
 *   wSrcBitsPerSample      Bits per PCM sample (resolution) in the source file.  The SDK only accepts 16-bit input.
 *   nSrcDataLen            Data length (in bytes) of the source audio file.
 *   puiAudioSrcSizeNeeded  Pointer to the value that SDK returns to app for the source size needed to encode audio. 
 *                          The app is recommended to use this value to allocate a memory space for audio source data.
 *   nDstChannels           Number of channels for the encoded (destination) output (valid number: 1 or 2).
 *   nDstSamplesPerSec      Sampling rate for the encoded output.  The SDK enumerates this rate and pick the closest one in the list.
 *
 *********  The following are the video properties.
 *
 *   dwVideoBitRate         Bitrate for the video (in bits per second).
 *                          * Value 0 is for audio only (no vidio) ASF file.
 *                          * dwAudioBitRate and dwVideoBitRate can't be zero at the same time.
 *   dbSrcFrameRate         Frame rate of the source video.
 *   biSrcWidth             Width of the source bitmap.
 *   biSrcHeight            Height of the source bitmap.
 *   biSrcBitCount          Bits per pixel of the source bitmap.
 *   biSrcCompression       The pixel (color) format of the source bitmap.  The SDK accepts the following types (in preference order). (See definitions above for the types.)
 *                          * FOURCC_I420		        
 *                          * FOURCC_IYUV		        
 *                          * FOURCC_YV12		        
 *                          * FOURCC_YUY2		        
 *                          * FOURCC_UYVY		        
 *                          * FOURCC_YVYU		        
 *                          * FOURCC_YVU9
 *                          * FOURCC_BI_RGB   	    
 *                          * FOURCC_BI_BITFIELDS	    
 *   nFrames                Total number of frames in the source video.
 *   nColor                 Number of colors in palette, Used for 8 bits case only.
 *   pbColors               Pointer to the start of Palette. Used for 8 bits case only. 			
 *   puiVideoSrcSizeNeeded  Pointer to the value that SDK returns to app for the source size needed to encode video. 
 *                          The app is recommended to use this value to allocate a memory space for video source data.
 *   nDstFrameRate          Encoded (output) frame rate. It is recommended to call WMFGetRecommendedVideoFrameRate to get a proper rate.
 *   biDstWidth             Width of the encoded bitmap.
 *   biDstHeight            Height of the encoded bitmap.
 *   biDstCompression       Compression type of the encoded video.  The SDK encoded to one of the following types (in preference order). (See definitions above for the types.)
 *                          * FOURCC_WMV1   	    
 *                          * FOURCC_MP43
 *                          * FOURCC_MP4S
 *   uiSmoothness           The degree of smoothness of the encoded video. This is a tradeoff between the individual image frame and number of encoded frames.
 *                          The valid range of uiSmoothness is 0 to 100, 0 being the smoothest. 0 is recommended for most of the cases unless image quality is specifically emphasized.
 *   uiKeyFrameDistance     The maximum key frame distance of the encoded video.  The unit is in seconds.
 *                          Note that this is the maximum distance since the encoder might decide to add key frames anytime.
 *                          But it is guaranteed that there must be a key frame in 8s.
 *   uiDelayBuffer          The delay/buffer time of the video.  The unit is in milliseconds.
 *                          This determines the pre-roll time when playing back the file in an ASF player.

 *
 * Return Value
 * ------------
 *   HWMFENCODER            Handle to the encoder. NULL if anything goes wrong during the creation.
 *
 */


HWMFENCODER WMFCreateEncoderUsingCustom (
        tWMFEncodeStatus*      ptStatus,
        I8_WMF                 *pchOutFilename,
// audio properties
        I32_WMF                dwAudioBitRate,
        U32_WMF                nSrcChannels,
        U32_WMF                nSrcSamplesPerSec,  
        U32_WMF                wSrcBitsPerSample,  
        U32_WMF                nSrcDataLen,
        U32_WMF*               puiAudioSrcSizeNeeded,
        U32_WMF                nDstChannels,
        U32_WMF                nDstSamplesPerSec,  
// video properties
    // source/input
        I32_WMF                dwVideoBitRate,
        Double_WMF             dbSrcFrameRate,
        U32_WMF                biSrcWidth,
        U32_WMF                biSrcHeight,
        U32_WMF                biSrcBitCount,
        U32_WMF                biSrcCompression,
        U32_WMF                nFrames,
        U32_WMF                nColors,
        U8_WMF                 *pbColors,
        U32_WMF                *puiVideoSrcSizeNeeded,
    // destination (output)
        U32_WMF                nDstFrameRate,
        U32_WMF                biDstWidth,
        U32_WMF                biDstHeight,
        U32_WMF                biDstCompression,

        U32_WMF                uiSmoothness, // 0 to 100, 0 being the smoothest
        U32_WMF                uiKeyFrameDistance, // in seconds
        U32_WMF                uiDelayBuffer, // in milliseconds
// source is interlaced
        U32_WMF                biDeInterlace // DeInterlace

);


/*
 *        WMFCreateEncoderUsingProfile
 *        ============================
 *
 * Description
 * -----------
 * Create the WMF encoder using one of the profiles specified in tagWMFEncodeProfile.
 *
 * Arguments
 * ---------
 *
 *   ptStatus               Pointer to the status of encoder creation.  It can be one of the value in tagWMFEncodeStatus.
 *   pchOutFilename         Pointer to the name of the encoded ASF file.
 *   tProfile               One of the encoding profile specified in tagWMFEncodeProfile
 *
 *********  The following are the audio properties.
 *
 *   nSrcChannels           Number of channels in the source file (valid number: 1 or 2).
 *   nSrcSamplesPerSec      Sampling rate in the source file.  The SDK enumerates this rate and pick the closest one in the list.
 *   wSrcBitsPerSample      Bits per PCM sample (resolution) in the source file.  The SDK only accepts 16-bit input.
 *   nSrcDataLen            Data length (in bytes) of the source audio file.
 *   puiAudioSrcSizeNeeded  Pointer to the value (in bytes) that SDK sets for the app for the source size needed to encode audio.
 *
 *********  The following are the video properties.
 *
 *   dbSrcFrameRate         Frame rate of the source video.
 *   biSrcWidth             Width of the source bitmap.
 *   biSrcHeight            Height of the source bitmap.
 *   biSrcBitCount          Bits per pixel of the source bitmap.
 *   biSrcCompression       The pixel (color) format of the source bitmap.  The SDK accepts the following types (in preference order). (See definitions above for the types.)
 *                          * FOURCC_I420		        
 *                          * FOURCC_IYUV		        
 *                          * FOURCC_YV12		        
 *                          * FOURCC_YUY2		        
 *                          * FOURCC_UYVY		        
 *                          * FOURCC_YVYU		        
 *                          * FOURCC_YVU9
 *                          * FOURCC_BI_RGB   	    
 *                          * FOURCC_BI_BITFIELDS	    
 *   nFrames                Total number of frames in the source video.
 *   puiVideoSrcSizeNeeded  Pointer to the value that SDK returns to app for the source size needed to encode video. 
 *                          The app is recommended to use this value to allocate a memory space for video source data.
 *
 *
 * Return Value
 * ------------
 *   HWMFENCODER            Handle to the encoder. NULL if anything goes wrong during the creation.
 *
 */

HWMFENCODER WMFCreateEncoderUsingProfile (
        tWMFEncodeStatus     *ptStatus,
        I8_WMF               *pchOutFilename,
        WMFEncodeProfile     tProfile,

// audio input source properties
        U32_WMF              nSrcChannels,
        U32_WMF              nSrcSamplesPerSec,  
        U32_WMF              wSrcBitsPerSample,  
        U32_WMF              nSrcDataLen,
        U32_WMF              *puiAudioSrcSizeNeeded,

// video properties
        Double_WMF           dbSrcFrameRate,
        U32_WMF              biSrcWidth,
        U32_WMF              biSrcHeight,
        U32_WMF              biSrcBitCount,
        U32_WMF              biSrcCompression,
        U32_WMF              nFrames,
        U32_WMF              *puiVideoSrcSizeNeeded,
        U32_WMF              biDeInterlace
);

/*
 *        WMFPutContentDescriptions
 *        =========================
 *
 * Description
 * -----------
 * Put content descriptions in the encoded ASF file (in overhead).
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   pchTitle               Title info.
 *   nLengthTitle           Length of title info.
 *   pchAuthor              Author info,
 *   nLengthAuthor          Length of author info.
 *   pchDescription         Description info,
 *   nLengthDescription     Length of Description info.
 *   pchCopyrigtht          Copyrigtht info,
 *   nLengthCopyrigtht      Length of Copyrigtht info.
 *   pchRating              Rating info,
 *   nLengthRating          Length of Rating info.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_Failed            Function fails.
 *
 */

tWMFEncodeStatus WMFPutContentDescriptions (
        HWMFENCODER hWMFEnc, 
//        const WMFContentDescription* pContentDesc
        const U16Char_WMF *pchTitle, U32_WMF nLengthTitle,
        const U16Char_WMF *pchAuthor, U32_WMF nLengthAuthor,
        const U16Char_WMF *pchDescription, U32_WMF nLengthDescription,
        const U16Char_WMF *pchCopyrigtht, U32_WMF nLengthCopyrigtht,
        const U16Char_WMF *pchRating, U32_WMF nLengthRating
);

/*            WMFPutScriptCommands
 * Description
 * -----------
 * Put script commands in the encoded ASF file
 * arguments:
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   nCommands              number of commands
 *   nTypes                 number of types of commands, such as URL
 *   ppTypeNames            type names
 *   CommandEntry           command entries

 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_InValidArgument    Function fails due to invalid arguments
 */

tWMFEncodeStatus WMFPutScriptCommands (				  
        HWMFENCODER         hWMFEnc,
        U16_WMF             nCommands,
        U16_WMF             nTypes,
        U16Char_WMF         **ppTypeNames,
        const CommandEntry  *pCommands
);

/*
 *        WMFPutExtendedContentDesc
 *        =========================
 *
 * Description
 * -----------
 * Put extended content descriptions in the encoded ASF file (in overhead).
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   nDescriptors           number of descriptors
 *   pDescriptors           pointer to the descriptor structure

 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_InValidArguments   Invalid arguments
 *   WMF_BadMemory          memory allocation problem
 */

tWMFEncodeStatus WMFPutExtendedContentDesc(
        HWMFENCODER         hWMFEnc,
        U16_WMF             nDescriptors,
        ECD_DESCRIPTOR      *pDescriptors
);

/*
 *        WMFPutMarkers
 *        =============
 *
 * Description
 * -----------
 * Put Markers in the encoded ASF file (in overhead).
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                    Handle of the encoder created in WMFCreateEncoder.
 *   wNumMarkers                number of MarkerEntry
 *   WORD  wNameLen             length of marker object name in wchar unit includeing terminating zero  
 *   const wchar *pchMarkerName pointer to the name of this Marker object
 *   pMarkers                   pointer to the MarkerEntry structure
 *                              For MarkerEntry,  You just need to fill in the following fields
 *      m_qtime                 Presentation time (Unit 1/10000000 sec)
 *      m_dwDescLen             Length of Description name in wchar unit includeing terminating zero
 *      m_pwDescName            Description name
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_InValidArguments   Invalid arguments
 *   WMF_BadMemory          memory allocation problem
 */

tWMFEncodeStatus WMFPutMarkers(
    HWMFENCODER hWMFEnc, 
    U32_WMF dwNumMarkers,  
    U16_WMF  wNameLen,
    const U16Char_WMF *pchMarkerName,
    MarkerEntry *pMarkers
);

/*
 *        WMFEncode
 *        =========
 *
 * Description
 * -----------
 * Encode the input audio and video data to ASF file using the specified settings in WMFCreateEncoderUsingCustom.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   pbAudioBuffer          Pointer to the memory allocated by the app to hold the audio data to be encoded.
 *                          The SDK has a call back function to the app to request to fill in this memory with audio data to be encoded.
 *   pnAudioBufferSize      Size (in bytes) of the pbAudioBuffer.
 *   pbVideoBuffer          Pointer to the memory allocated by the app to hold the video data to be encoded.
 *                          The SDK has a call back function to the app to request to fill in this memory with video data to be encoded.
 *   pnVideoBufferSize      Size (in bytes) of the pbVideoBuffer.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Encode succeeds.
 *   
 *   WMA_Failed             Audio fails.
 *   WMA_BadMemory          Audio part has bad memory.
 *   WMA_EncodeFailed       Audio encode fails.
 *   WMA_InValidArguments   Audio part has invalid arguments.
 *   WMA_BadSource          Audio source data is bad.

 *   WMV_Failed             Video fails.
 *   WMV_BadMemory          Video part has bad memory.
 *   WMV_EncodeFailed       Video encode fails.
 *   WMV_InValidArguments   Video part has invalid arguments.
 *   WMV_BadSource          Video source data is bad.
 *
 */

tWMFEncodeStatus WMFEncode (
    HWMFENCODER hWMFEnc, 
    U8_WMF* pbAudioBuffer, U32_WMF pnAudioBufferSize, 
    U8_WMF* pbVideoBuffer, U32_WMF pnVideoBufferSize
);


/*
 *        WMFClose
 *        ========
 *
 * Description
 * -----------
 * Close the encoder.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Close succeeds.
 *   WMF_BadMemory          Memory is bad.
 *
 */

tWMFEncodeStatus WMFClose (HWMFENCODER hWMFEnc);


#ifdef __cplusplus
}
#endif

#endif // _WMF_ENCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XbFont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XbResource.Cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Under UMA emulation, we copy the data from AGP memory to video memory.
    // This will not be necessary with final hardware
    D3D_CopyContiguousMemoryToVideo( m_pVidMemData );

    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\DemoLegal\xbresource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Audio.cpp ===
//=============================================================================
// File: Audio.cpp
//
// Desc: This is the audio module for the XDemos project
// Created: 07/23/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================
#include "XDemos.h"


//=============================================================================
//=============================================================================
#define WMASTRM_LOOKAHEAD_SIZE			65536
#define WMASTRM_PACKET_COUNT			8
#define WMASTRM_SOURCE_PACKET_BYTES		8192


//=============================================================================
// Global variables
//=============================================================================
IDirectSound8 *			g_pDSnd			= NULL;
IDirectSoundBuffer8 *	g_pMenuSnd		= NULL;
IDirectSoundBuffer8 *	g_pLaunchSnd	= NULL;
IDirectSoundStream *	g_pAmbient		= NULL;
XFileMediaObject *		g_pSourceFilter	= NULL;
DWORD					g_adwPacketStatus[WMASTRM_PACKET_COUNT]; // Packet status array
BYTE					g_SndBuffer[WMASTRM_PACKET_COUNT][WMASTRM_SOURCE_PACKET_BYTES] = {0};





//==============================================================================================
//==============================================================================================
typedef struct tagWAVEHDR
{
	DWORD			sRIFF;			// 'RIFF'
	DWORD			dwRIFFSize;		// rest of file size
	DWORD			sWAVE;			// 'WAVE'
	DWORD			sFMT;			// 'fmt '
	DWORD			dwFMTSize;		// rest of format size
	WAVEFORMATEX	wf;			// format
	DWORD			dwDATASize;
} WAVEHEADER;


//=============================================================================
//=============================================================================
IDirectSoundBuffer8 * LoadSound(char *szFileName)
{
	IDirectSoundBuffer8 *pSnd = NULL;

	HANDLE hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return NULL;

	DWORD dwSize = GetFileSize(hFile, NULL);
	DWORD dwRead;

	DSBUFFERDESC	dsbd;
	WAVEHEADER		wf;

	SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
	ReadFile(hFile, &wf, sizeof(wf), &dwRead, NULL);

	dsbd.dwSize				= sizeof(dsbd);
	dsbd.dwFlags			= 0;
	dsbd.dwBufferBytes		= wf.dwDATASize;
	dsbd.lpwfxFormat		= &wf.wf;
	dsbd.dwMixBinMask		= 0;
	dsbd.dwInputMixBinMask	= 0;

	if (FAILED(DirectSoundCreateBuffer(&dsbd, &pSnd)))
	{
		CloseHandle(hFile);
		return NULL;
	}

	LPVOID	lpvWrite;
	DWORD	dwLength;

	if (FAILED(pSnd->Lock(0, 0, &lpvWrite, &dwLength, NULL, NULL, DSBLOCK_ENTIREBUFFER)))
	{
		CloseHandle(hFile);
		pSnd->Release();
		return NULL;
	}

	ReadFile(hFile, lpvWrite, dwLength, &dwSize, NULL);
	CloseHandle(hFile);
	pSnd->Unlock(lpvWrite, dwLength, NULL, 0);

	return pSnd;
}

//=============================================================================
//=============================================================================
HRESULT InitAudio(void)
{
	if (FAILED(DirectSoundCreate(NULL, &g_pDSnd, NULL)))
		return -1;

	g_pMenuSnd = LoadSound(FindPath(g_pszMenuSound));
	g_pLaunchSnd = LoadSound(FindPath(g_pszLaunchSound));

	if (true)
	{
		WAVEFORMATEX wf;
		DSSTREAMDESC dss;

		WmaCreateDecoder(FindPath(g_pszAmbientSound), NULL, FALSE, WMASTRM_LOOKAHEAD_SIZE, WMASTRM_PACKET_COUNT, 0, &wf, &g_pSourceFilter);

		if (!g_pSourceFilter)
			return S_OK;

		dss.dwFlags					= 0;
		dss.dwMaxAttachedPackets	= WMASTRM_PACKET_COUNT;
		dss.lpwfxFormat				= &wf;
		dss.lpfnCallback			= 0;
		dss.lpvContext				= 0;
		dss.dwMixBinMask			= 0;

		if (FAILED(DirectSoundCreateStream(&dss, &g_pAmbient)))
			return -1;

		XMEDIAINFO xmi;
		g_pSourceFilter->GetInfo(&xmi);

		g_pAmbient->GetInfo(&xmi);


	}

	return S_OK;
}

//=============================================================================
//=============================================================================
BOOL FindFreePacket( DWORD* pdwPacketIndex )
{
    for (DWORD dwPacketIndex = 0 ; dwPacketIndex < WMASTRM_PACKET_COUNT ; dwPacketIndex++ )
    {
        if (XMEDIAPACKET_STATUS_PENDING != g_adwPacketStatus[dwPacketIndex])
        {
            if (pdwPacketIndex)
                (*pdwPacketIndex) = dwPacketIndex;

            return TRUE;
        }
    }

    return FALSE;
}


//=============================================================================
//=============================================================================
void ProcessSource(DWORD dwPacketIndex)
{
	XMEDIAPACKET xmp = {0};
	DWORD dwSourceUsed;
	DWORD dwTotalSourceUsed = 0;

    xmp.pvBuffer			= g_SndBuffer[dwPacketIndex];
    xmp.dwMaxSize			= WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwCompletedSize	= &dwSourceUsed;

    while( dwTotalSourceUsed < WMASTRM_SOURCE_PACKET_BYTES )
    {
        // Read from the source
        if (FAILED(g_pSourceFilter->Process(NULL, &xmp)))
            return;

        // Add the amount read to the total
        dwTotalSourceUsed += dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
            if (FAILED(g_pSourceFilter->Flush()))
                return;
        };
    }
}


//=============================================================================
//=============================================================================
void ProcessRenderer(DWORD dwPacketIndex)
{
    XMEDIAPACKET xmp = {0};

    xmp.pvBuffer		= g_SndBuffer[dwPacketIndex];
    xmp.dwMaxSize		= WMASTRM_SOURCE_PACKET_BYTES;
    xmp.pdwStatus		= &g_adwPacketStatus[dwPacketIndex];

    g_pAmbient->Process( &xmp, NULL );
}

//=============================================================================
//=============================================================================
void UpdateAudio(void)
{
	if (!g_pSourceFilter)
		return;

	DirectSoundDoWork();

    DWORD   dwPacketIndex;
    
    while( FindFreePacket( &dwPacketIndex ) )
    {
         ProcessSource(dwPacketIndex);
         ProcessRenderer(dwPacketIndex);
    }
}

//=============================================================================
//=============================================================================
void PlayLaunchSound(void)
{
	g_pLaunchSnd->Play(0, 0, 0);

	while (true)
	{
		DWORD dwStatus;

		g_pLaunchSnd->GetStatus(&dwStatus);

		if ((dwStatus & DSBSTATUS_PLAYING) == 0)
			break;
	}
}

//=============================================================================
//=============================================================================
void PlayMenuSound(void)
{
	g_pMenuSnd->Play(0, 0, 0);
}


//=============================================================================
//=============================================================================
void StopAudio(void)
{
	if (!g_pSourceFilter)
		return;

	g_pAmbient->Pause(DSSTREAMPAUSE_PAUSE);
}

//=============================================================================
//=============================================================================
void StartAudio(void)
{
	if (!g_pSourceFilter)
		return;

	g_pAmbient->Pause(DSSTREAMPAUSE_RESUME);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Input.cpp ===
//=============================================================================
// File: Input.cpp
//
// Desc: This is the input module for the XDemos project
// Created: 07/23/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================
#include "XDemos.h"

#define STICK_THRESHHOLD	15000
//=============================================================================
DWORD					g_dwDeviceState	= 0;
HANDLE					g_hInput[12]	= {0};
static XINPUT_STATE		xis_old[12] = {0};
static bool				xis_received[12] = {0};

//=============================================================================
//=============================================================================
void HandleDeviceChanges(XPP_DEVICE_TYPE *pxdt, DWORD dwInsert, DWORD dwRemove)
{

	return;
}

//=============================================================================
//=============================================================================
HANDLE GetController(bool bFirst, int *pnum=NULL)
{
	static int i=0;

	if (bFirst)
		i=0;

	for ( ; i<12 ; i++)
	{
		if (g_dwDeviceState & (1<<i))
		{
			if (pnum)
			{
				*pnum = i;
			}
			return g_hInput[i++];
		}
	}

	return NULL;
}

//=============================================================================
//=============================================================================
void SaveState(int dw1, int dw2, int dw3)
{
	HANDLE hFile = CreateFile(g_pszSettingsFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwSize;

		WriteFile(hFile, &dw1, sizeof(dw1), &dwSize, NULL);
		WriteFile(hFile, &dw2, sizeof(dw2), &dwSize, NULL);
		WriteFile(hFile, &dw3, sizeof(dw3), &dwSize, NULL);

		CloseHandle(hFile);
		return;
	}

	return;
}

//=============================================================================
//=============================================================================
void GetState(int &dw1, int &dw2, int &dw3)
{
	HANDLE hFile = CreateFile(g_pszSettingsFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwSize;

		ReadFile(hFile, &dw1, sizeof(dw1), &dwSize, NULL);
		ReadFile(hFile, &dw2, sizeof(dw2), &dwSize, NULL);
		ReadFile(hFile, &dw3, sizeof(dw3), &dwSize, NULL);

		CloseHandle(hFile);
		return;
	}

	dw1=0;
	dw2=0;
}

//=============================================================================
//=============================================================================
void HandleInput(void)
{
	DWORD				dwInsert;
	DWORD				dwRemove;
	XINPUT_STATE		xis;

	if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsert, &dwRemove))
	{
		HandleDeviceChanges(XDEVICE_TYPE_GAMEPAD, dwInsert, dwRemove);

		g_dwDeviceState &= ~dwRemove;
		g_dwDeviceState |= dwInsert;

		for( DWORD i=0; i < XGetPortCount(); i++ )
		{
			// Handle removed devices.
			if( dwRemove & (1<<i) )
			{
				if (g_hInput[i])
				{
					XInputClose( g_hInput[i] );
					g_hInput[i] = NULL;
				}
			}

			if( dwInsert & (1<<i) )
			{
				if (!g_hInput[i])
					g_hInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );

				int err;
				if (g_hInput[i] == NULL)
				{
					err=GetLastError();
				}
				assert(g_hInput[i]);
			}

		}

	}


	HANDLE hPad;

	int n;
	hPad=GetController(true, &n);
	bool bButton=false;

	while (hPad)
	{

		XInputGetState(hPad, &xis);

		// now, make the analog thumb sticks either all or nothing
		if (xis.Gamepad.sThumbLY > STICK_THRESHHOLD)
			xis.Gamepad.sThumbLY = STICK_THRESHHOLD;
		else if (xis.Gamepad.sThumbLY < -STICK_THRESHHOLD)
			xis.Gamepad.sThumbLY = -STICK_THRESHHOLD;
		else
			xis.Gamepad.sThumbLY = 0;

		if (xis.Gamepad.sThumbRY > STICK_THRESHHOLD)
			xis.Gamepad.sThumbRY = STICK_THRESHHOLD;
		else if (xis.Gamepad.sThumbRY < -STICK_THRESHHOLD)
			xis.Gamepad.sThumbRY = -STICK_THRESHHOLD;
		else
			xis.Gamepad.sThumbRY = 0;

		// make sure we've received input from this controller before,
		// if not, don't process the input yet!
		if (xis_received[n])
		{
			// only process messages if they're different
			if (
				((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]))
				||
				((xis.Gamepad.wButtons & XINPUT_GAMEPAD_START) && !((xis_old[n].Gamepad.wButtons & XINPUT_GAMEPAD_START)))
				)
			{
				Input();
				ButtonA();
			}

			if ((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]))
			{
				Input();
				ButtonB();
			}

			if (xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
			{
				bButton = true;
				Input();
				ButtonUp();
			}

			if (xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
			{
				bButton = true;
				Input();
				ButtonDn();
			}

			if (xis.Gamepad.sThumbLY == STICK_THRESHHOLD)
			{
				bButton = true;
				Input();
				ButtonUp();
			}

			if (xis.Gamepad.sThumbLY == -STICK_THRESHHOLD)
			{
				bButton = true;
				Input();
				ButtonDn();
			}

			if (xis.Gamepad.sThumbRY == STICK_THRESHHOLD)
			{
				bButton = true;
				Input();
				ButtonUp();
			}

			if (xis.Gamepad.sThumbRY == -STICK_THRESHHOLD)
			{
				bButton = true;
				Input();
				ButtonDn();
			}

		}
		else
		{
			xis_received[n] = true;
		}

		xis_old[n] = xis;

		hPad=GetController(false, &n);
	}

	if (!bButton)
		ButtonMiddle();

}

//=============================================================================
//=============================================================================
HRESULT InitInput(void)
{
	XDEVICE_PREALLOC_TYPE xdpt[] = {
		{XDEVICE_TYPE_GAMEPAD, 4},
	};

	XInitDevices(sizeof(xdpt)/sizeof(xdpt[0]), xdpt);

	g_dwDeviceState = XGetDevices(XDEVICE_TYPE_GAMEPAD);

	for( DWORD i=0; i<4 ; i++ )
	{
		if( g_dwDeviceState & (1<<i) )
		{
			if (!g_hInput[i])
				g_hInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
		}
	}

	return S_OK;
}



//=============================================================================
//=============================================================================
bool CheckForInput(void)
{
	DWORD				dwInsert;
	DWORD				dwRemove;
	XINPUT_STATE		xis;

	if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsert, &dwRemove))
	{
		HandleDeviceChanges(XDEVICE_TYPE_GAMEPAD, dwInsert, dwRemove);

		g_dwDeviceState &= ~dwRemove;
		g_dwDeviceState |= dwInsert;

		for( DWORD i=0; i < XGetPortCount(); i++ )
		{
			// Handle removed devices.
			if( dwRemove & (1<<i) )
			{
				if (g_hInput[i])
				{
					XInputClose( g_hInput[i] );
					g_hInput[i] = NULL;
				}
			}

			if( dwInsert & (1<<i) )
			{
				if (!g_hInput[i])
					g_hInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );

				int err;
				if (g_hInput[i] == NULL)
				{
					err=GetLastError();
				}
				assert(g_hInput[i]);
			}

		}

	}


	HANDLE hPad;

	int n;
	hPad=GetController(true, &n);

	while (hPad)
	{
		XInputGetState(hPad, &xis);

		// now, make the analog thumb sticks either all or nothing
		if (xis.Gamepad.sThumbLY > STICK_THRESHHOLD)
			xis.Gamepad.sThumbLY = STICK_THRESHHOLD;
		else if (xis.Gamepad.sThumbLY < -STICK_THRESHHOLD)
			xis.Gamepad.sThumbLY = -STICK_THRESHHOLD;
		else
			xis.Gamepad.sThumbLY = 0;

		if (xis.Gamepad.sThumbRY > STICK_THRESHHOLD)
			xis.Gamepad.sThumbRY = STICK_THRESHHOLD;
		else if (xis.Gamepad.sThumbRY < -STICK_THRESHHOLD)
			xis.Gamepad.sThumbRY = -STICK_THRESHHOLD;
		else
			xis.Gamepad.sThumbRY = 0;



		// only process messages if they're different

		if (
			((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]))
			||
			((xis.Gamepad.wButtons & XINPUT_GAMEPAD_START) && !((xis_old[n].Gamepad.wButtons & XINPUT_GAMEPAD_START)))
			)
		{
			xis_old[n] = xis;
			return true;
		}

		if ((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]))
		{
		}

		xis_old[n] = xis;

		hPad=GetController(false, &n);
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\DemoLegal\xbresource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XbFont.Cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XbResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Bink\BINK.H ===
#ifndef BINKH
#define BINKH

#define BINKMAJORVERSION 1
#define BINKMINORVERSION 1
#define BINKSUBVERSION 3
#define BINKVERSION "1.1d"
#define BINKDATE    "2001-08-21"

#ifndef __RADRES__

#include "rad.h"

RADDEFSTART

typedef struct BINK PTR4* HBINK;

struct BINKIO;
typedef s32  (RADLINK PTR4* BINKIOOPEN)         (struct BINKIO PTR4* Bnkio, const char PTR4 *name, u32 flags);
typedef u32  (RADLINK PTR4* BINKIOREADHEADER)   (struct BINKIO PTR4* Bnkio, s32 Offset, void PTR4* Dest,u32 Size);
typedef u32  (RADLINK PTR4* BINKIOREADFRAME)    (struct BINKIO PTR4* Bnkio, u32 Framenum,s32 origofs,void PTR4* dest,u32 size);
typedef u32  (RADLINK PTR4* BINKIOGETBUFFERSIZE)(struct BINKIO PTR4* Bnkio, u32 Size);
typedef void (RADLINK PTR4* BINKIOSETINFO)      (struct BINKIO PTR4* Bnkio, void PTR4* Buf,u32 Size,u32 FileSize,u32 simulate);
typedef u32  (RADLINK PTR4* BINKIOIDLE)         (struct BINKIO PTR4* Bnkio);
typedef void (RADLINK PTR4* BINKIOCLOSE)        (struct BINKIO PTR4* Bnkio);

typedef void (RADLINK PTR4* BINKCBSUSPEND)    (struct BINKIO PTR4* Bnkio);
typedef s32  (RADLINK PTR4* BINKCBTRYSUSPEND) (struct BINKIO PTR4* Bnkio);
typedef void (RADLINK PTR4* BINKCBRESUME)     (struct BINKIO PTR4* Bnkio);
typedef void (RADLINK PTR4* BINKCBIDLE)       (struct BINKIO PTR4* Bnkio);

typedef struct BINKIO {
  BINKIOREADHEADER ReadHeader;
  BINKIOREADFRAME  ReadFrame;
  BINKIOGETBUFFERSIZE GetBufferSize;
  BINKIOSETINFO SetInfo;
  BINKIOIDLE Idle;
  BINKIOCLOSE Close;
  HBINK bink;
  volatile u32 ReadError;
  volatile u32 DoingARead;
  volatile u32 BytesRead;
  volatile u32 Working;
  volatile u32 TotalTime;
  volatile u32 ForegroundTime;
  volatile u32 IdleTime;
  volatile u32 ThreadTime;
  volatile u32 BufSize;
  volatile u32 BufHighUsed;
  volatile u32 CurBufSize;
  volatile u32 CurBufUsed;
  volatile u8 iodata[128];

  // filled in by the caller
  BINKCBSUSPEND suspend_callback;
  BINKCBTRYSUSPEND try_suspend_callback;
  BINKCBRESUME resume_callback;
  BINKCBIDLE idle_on_callback;
  volatile u32 callback_control[8];  // buffer for background IO callback
} BINKIO;

struct BINKSND;
typedef s32  (RADLINK PTR4* BINKSNDOPEN)     (struct BINKSND PTR4* BnkSnd, u32 freq, s32 bits, s32 chans, u32 flags, HBINK bink);
typedef s32  (RADLINK PTR4* BINKSNDREADY)    (struct BINKSND PTR4* BnkSnd);
typedef s32  (RADLINK PTR4* BINKSNDLOCK)     (struct BINKSND PTR4* BnkSnd, u8 PTR4* PTR4* addr, u32 PTR4* len);
typedef s32  (RADLINK PTR4* BINKSNDUNLOCK)   (struct BINKSND PTR4* BnkSnd, u32 filled);
typedef void (RADLINK PTR4* BINKSNDVOLUME)   (struct BINKSND PTR4* BnkSnd, s32 volume);
typedef void (RADLINK PTR4* BINKSNDPAN)      (struct BINKSND PTR4* BnkSnd, s32 pan);
typedef s32  (RADLINK PTR4* BINKSNDONOFF)    (struct BINKSND PTR4* BnkSnd, s32 status);
typedef s32  (RADLINK PTR4* BINKSNDPAUSE)    (struct BINKSND PTR4* BnkSnd, s32 status);
typedef void (RADLINK PTR4* BINKSNDCLOSE)    (struct BINKSND PTR4* BnkSnd);

typedef BINKSNDOPEN  (RADLINK PTR4* BINKSNDSYSOPEN) (u32 param);

typedef struct BINKSND {
  BINKSNDREADY Ready;
  BINKSNDLOCK Lock;
  BINKSNDUNLOCK Unlock;
  BINKSNDVOLUME Volume;
  BINKSNDPAN Pan;
  BINKSNDPAUSE Pause;
  BINKSNDONOFF SetOnOff;
  BINKSNDCLOSE Close;
  u32 BestSizeIn16;
  u32 SoundDroppedOut;
  s32 OnOff;
  u32 Latency;
  u32 VideoScale;
  u32 freq;
  s32 bits,chans;
  u8 snddata[128];
} BINKSND;

typedef struct BINKRECT {
  s32 Left,Top,Width,Height;
} BINKRECT;

#define BINKMAXDIRTYRECTS 8

typedef struct BUNDLEPOINTERS {
  void* typeptr;
  void* type16ptr;
  void* colorptr;
  void* bits2ptr;
  void* motionXptr;
  void* motionYptr;
  void* dctptr;
  void* mdctptr;
  void* patptr;
} BUNDLEPOINTERS;


typedef struct BINK {
  u32 Width;             // Width (1 based, 640 for example)
  u32 Height;            // Height (1 based, 480 for example)
  u32 Frames;            // Number of frames (1 based, 100 = 100 frames)
  u32 FrameNum;          // Frame to *be* displayed (1 based)
  u32 LastFrameNum;      // Last frame decompressed or skipped (1 based)

  u32 FrameRate;         // Frame Rate Numerator
  u32 FrameRateDiv;      // Frame Rate Divisor (frame rate=numerator/divisor)

  u32 ReadError;         // Non-zero if a read error has ocurred
  u32 OpenFlags;         // flags used on open
  u32 BinkType;          // Bink flags

  u32 Size;              // size of file
  u32 FrameSize;         // The current frame's size in bytes
  u32 SndSize;           // The current frame sound tracks' size in bytes

  BINKRECT FrameRects[BINKMAXDIRTYRECTS];// Dirty rects from BinkGetRects
  s32 NumRects;

  u32 PlaneNum;          // which set of planes is current
  void PTR4* YPlane[2];  // pointer to the uncompressed Y (Cr and Cr follow)
  void PTR4* APlane[2];  // decompressed alpha plane (if present)
  u32 YWidth;            // widths and heights of the video planes
  u32 YHeight;
  u32 UVWidth;
  u32 UVHeight;

  void PTR4* MaskPlane;  // pointer to the mask plane (Ywidth/16*Yheight/16)
  u32 MaskPitch;         // Mask Pitch
  u32 MaskLength;        // total length of the mask plane

  u32 LargestFrameSize;  // Largest frame size
  u32 InternalFrames;    // how many frames were potentially compressed

  s32 NumTracks;         // how many tracks

  u32 Highest1SecRate;   // Highest 1 sec data rate
  u32 Highest1SecFrame;  // Highest 1 sec data rate starting frame

  s32 Paused;            // is the bink movie paused?

  u32 BackgroundThread;  // handle to background thread

  // everything below is for internal Bink use

  void PTR4* compframe;       // compressed frame data
  void PTR4* preloadptr;      // preloaded compressed frame data
  u32* frameoffsets;          // offsets of each of the frames

  BINKIO bio;                 // IO structure
  u8 PTR4* ioptr;             // io buffer ptr
  u32 iosize;                 // io buffer size
  u32 decompwidth;            // width not include scaling
  u32 decompheight;           // height not include scaling

  s32 trackindex;             // track index
  u32 PTR4* tracksizes;       // largest single frame of track
  u32 PTR4* tracktypes;       // type of each sound track
  s32 PTR4* trackIDs;         // external track numbers

  u32 numrects;               // number of rects from BinkGetRects

  u32 playedframes;           // how many frames have we played
  u32 firstframetime;         // very first frame start
  u32 startframetime;         // start frame start
  u32 startblittime;          // start of blit period
  u32 startsynctime;          // start of synched time
  u32 startsyncframe;         // frame of startsynctime
  u32 twoframestime;          // two frames worth of time
  u32 entireframetime;        // entire frame time

  u32 slowestframetime;       // slowest frame in ms
  u32 slowestframe;           // slowest frame number
  u32 slowest2frametime;      // second slowest frame in ms
  u32 slowest2frame;          // second slowest frame

  u32 soundon;                // sound turned on?
  u32 videoon;                // video turned on?

  u32 totalmem;               // total memory used
  u32 timevdecomp;            // total time decompressing video
  u32 timeadecomp;            // total time decompressing audio
  u32 timeblit;               // total time blitting
  u32 timeopen;               // total open time

  u32 fileframerate;          // frame rate originally in the file
  u32 fileframeratediv;

  u32 runtimeframes;          // max frames for runtime analysis
  u32 runtimemoveamt;         // bytes to move each frame
  u32 PTR4* rtframetimes;     // start times for runtime frames
  u32 PTR4* rtadecomptimes;   // decompress times for runtime frames
  u32 PTR4* rtvdecomptimes;   // decompress times for runtime frames
  u32 PTR4* rtblittimes;      // blit times for runtime frames
  u32 PTR4* rtreadtimes;      // read times for runtime frames
  u32 PTR4* rtidlereadtimes;  // idle read times for runtime frames
  u32 PTR4* rtthreadreadtimes;// thread read times for runtime frames

  u32 lastblitflags;          // flags used on last blit
  u32 lastdecompframe;        // last frame number decompressed

  u32 sndbufsize;             // sound buffer size
  u8 PTR4* sndbuf;            // sound buffer
  u8 PTR4* sndend;            // end of the sound buffer
  u8 PTR4* sndwritepos;       // current write position
  u8 PTR4* sndreadpos;        // current read position
  u32 sndcomp;                // sound compression handle
  u32 sndamt;                 // amount of sound currently in the buffer
  u32 sndconvert8;            // convert back to 8-bit sound at runtime
  BINKSND bsnd;               // SND structure
  u32 skippedlastblit;        // skipped last frame?
  u32 skippedblits;           // how many blits were skipped
  u32 soundskips;             // number of sound stops
  u32 sndendframe;            // frame number that the sound ends on
  u32 sndprime;               // amount of data to prime the playahead
  u32 sndpad;                 // padded this much audio

  BUNDLEPOINTERS bunp;        // pointers to internal temporary memory
  u32 skipped_in_a_row;       // how many frames have we skipped in a row
  u32 big_sound_skip_adj;     // adjustment for large skips
  u32 big_sound_skip_reduce;  // amount to reduce large skips by each frame
  u32 last_time_almost_empty; // time of last almost empty IO buffer
  u32 last_read_count;        // counter to keep track of the last bink IO
  u32 last_sound_count;       // counter to keep track of the last bink sound
  u32 snd_callback_buffer[8]; // buffer for background sound callback
} BINK;


typedef struct BINKSUMMARY {
  u32 Width;                  // Width of frames
  u32 Height;                 // Height of frames
  u32 TotalTime;              // total time (ms)
  u32 FileFrameRate;          // frame rate
  u32 FileFrameRateDiv;       // frame rate divisor
  u32 FrameRate;              // frame rate
  u32 FrameRateDiv;           // frame rate divisor
  u32 TotalOpenTime;          // Time to open and prepare for decompression
  u32 TotalFrames;            // Total Frames
  u32 TotalPlayedFrames;      // Total Frames played
  u32 SkippedFrames;          // Total number of skipped frames
  u32 SkippedBlits;           // Total number of skipped blits
  u32 SoundSkips;             // Total number of sound skips
  u32 TotalBlitTime;          // Total time spent blitting
  u32 TotalReadTime;          // Total time spent reading
  u32 TotalVideoDecompTime;   // Total time spent decompressing video
  u32 TotalAudioDecompTime;   // Total time spent decompressing audio
  u32 TotalIdleReadTime;      // Total time spent reading while idle
  u32 TotalBackReadTime;      // Total time spent reading in background
  u32 TotalReadSpeed;         // Total io speed (bytes/second)
  u32 SlowestFrameTime;       // Slowest single frame time (ms)
  u32 Slowest2FrameTime;      // Second slowest single frame time (ms)
  u32 SlowestFrameNum;        // Slowest single frame number
  u32 Slowest2FrameNum;       // Second slowest single frame number
  u32 AverageDataRate;        // Average data rate of the movie
  u32 AverageFrameSize;       // Average size of the frame
  u32 HighestMemAmount;       // Highest amount of memory allocated
  u32 TotalIOMemory;          // Total extra memory allocated
  u32 HighestIOUsed;          // Highest extra memory actually used
  u32 Highest1SecRate;        // Highest 1 second rate
  u32 Highest1SecFrame;       // Highest 1 second start frame
} BINKSUMMARY;


typedef struct BINKREALTIME {
  u32 FrameNum;               // Current frame number
  u32 FrameRate;              // frame rate
  u32 FrameRateDiv;           // frame rate divisor
  u32 Frames;                 // frames in this sample period
  u32 FramesTime;             // time is ms for these frames
  u32 FramesVideoDecompTime;  // time decompressing these frames
  u32 FramesAudioDecompTime;  // time decompressing these frames
  u32 FramesReadTime;         // time reading these frames
  u32 FramesIdleReadTime;     // time reading these frames at idle
  u32 FramesThreadReadTime;   // time reading these frames in background
  u32 FramesBlitTime;         // time blitting these frames
  u32 ReadBufferSize;         // size of read buffer
  u32 ReadBufferUsed;         // amount of read buffer currently used
  u32 FramesDataRate;         // data rate for these frames
} BINKREALTIME;

#define BINKMARKER1 'fKIB'
#define BINKMARKER2 'gKIB'    // new Bink files use this tag
#define BINKMARKER3 'hKIB'    // newer Bink files use this tag
#define BINKMARKER4 'iKIB'    // even newer Bink files use this tag

typedef struct BINKHDR {
  u32 Marker;                 // Bink marker
  u32 Size;                   // size of the file-8
  u32 Frames;                 // Number of frames (1 based, 100 = 100 frames)
  u32 LargestFrameSize;       // Size in bytes of largest frame
  u32 InternalFrames;         // Number of internal frames

  u32 Width;                  // Width (1 based, 640 for example)
  u32 Height;                 // Height (1 based, 480 for example)
  u32 FrameRate;              // frame rate
  u32 FrameRateDiv;           // frame rate divisor (framerate/frameratediv=fps)

  u32 Flags;                  // height compression options
  u32 NumTracks;              // number of tracks
} BINKHDR;


//=======================================================================
#define BINKFRAMERATE         0x00001000L // Override fr (call BinkFrameRate first)
#define BINKPRELOADALL        0x00002000L // Preload the entire animation
#define BINKSNDTRACK          0x00004000L // Set the track number to play
#define BINKOLDFRAMEFORMAT    0x00008000L // using the old Bink frame format (internal use only)
#define BINKRBINVERT          0x00010000L // use reversed R and B planes (internal use only)
#define BINKGRAYSCALE         0x00020000L // Force Bink to use grayscale
#define BINKNOMMX             0x00040000L // Don't use MMX
#define BINKNOSKIP            0x00080000L // Don't skip frames if falling behind
#define BINKALPHA             0x00100000L // Decompress alpha plane (if present)
#define BINKNOFILLIOBUF       0x00200000L // Fill the IO buffer in SmackOpen
#define BINKSIMULATE          0x00400000L // Simulate the speed (call BinkSim first)
#define BINKFILEHANDLE        0x00800000L // Use when passing in a file handle
#define BINKIOSIZE            0x01000000L // Set an io size (call BinkIOSize first)
#define BINKIOPROCESSOR       0x02000000L // Set an io processor (call BinkIO first)
#define BINKFROMMEMORY        0x04000000L // Use when passing in a pointer to the file
#define BINKNOTHREADEDIO      0x08000000L // Don't use a background thread for IO

#define BINKSURFACEFAST       0x00000000L
#define BINKSURFACESLOW       0x08000000L
#define BINKSURFACEDIRECT     0x04000000L

#define BINKCOPYALL           0x80000000L // copy all pixels (not just changed)
#define BINKCOPY2XH           0x10000000L // Force doubling height scaling
#define BINKCOPY2XHI          0x20000000L // Force interleaving height scaling
#define BINKCOPY2XW           0x30000000L // copy the width zoomed by two
#define BINKCOPY2XWH          0x40000000L // copy the width and height zoomed by two
#define BINKCOPY2XWHI         0x50000000L // copy the width and height zoomed by two
#define BINKCOPY1XI           0x60000000L // copy the width and height zoomed by two
#define BINKCOPYNOSCALING     0x70000000L // Force scaling off

//#define BINKALPHA           0x00100000L // Decompress alpha plane (if present)
//#define BINKNOSKIP          0x00080000L // don't skip the blit if behind in sound
//#define BINKNOMMX           0x00040000L // Don't skip frames if falling behind
//#define BINKGRAYSCALE       0x00020000L // force Bink to use grayscale
//#define BINKRBINVERT        0x00010000L // use reversed R and B planes

#define BINKSURFACE8P          0
#define BINKSURFACE24          1
#define BINKSURFACE24R         2
#define BINKSURFACE32          3
#define BINKSURFACE32R         4
#define BINKSURFACE32A         5
#define BINKSURFACE32RA        6
#define BINKSURFACE4444        7
#define BINKSURFACE5551        8
#define BINKSURFACE555         9
#define BINKSURFACE565        10
#define BINKSURFACE655        11
#define BINKSURFACE664        12
#define BINKSURFACEYUY2       13
#define BINKSURFACEUYVY       14
#define BINKSURFACEYV12       15
#define BINKSURFACEMASK       15

#define BINKGOTOQUICK          1

#define BINKGETKEYPREVIOUS     0
#define BINKGETKEYNEXT         1
#define BINKGETKEYCLOSEST      2
#define BINKGETKEYNOTEQUAL   128

//=======================================================================

#ifdef __RADMAC__
  #include <files.h>

  #pragma export on

  RADEXPFUNC HBINK RADEXPLINK BinkMacOpen(FSSpec* fsp,u32 flags);
#endif

RADEXPFUNC void PTR4* RADEXPLINK BinkLogoAddress(void);

RADEXPFUNC void RADEXPLINK BinkSetError(const char PTR4* err);
RADEXPFUNC char PTR4* RADEXPLINK BinkGetError(void);

RADEXPFUNC HBINK RADEXPLINK BinkOpen(const char PTR4* name,u32 flags);

RADEXPFUNC s32  RADEXPLINK BinkDoFrame(HBINK bnk);
RADEXPFUNC void RADEXPLINK BinkNextFrame(HBINK bnk);
RADEXPFUNC s32  RADEXPLINK BinkWait(HBINK bnk);
RADEXPFUNC void RADEXPLINK BinkClose(HBINK bnk);
RADEXPFUNC s32  RADEXPLINK BinkPause(HBINK bnk,s32 pause);
RADEXPFUNC s32  RADEXPLINK BinkCopyToBuffer(HBINK bnk,void* dest,s32 destpitch,u32 destheight,u32 destx,u32 desty,u32 flags);
RADEXPFUNC s32  RADEXPLINK BinkGetRects(HBINK bnk,u32 flags);
RADEXPFUNC void RADEXPLINK BinkGoto(HBINK bnk,u32 frame,s32 flags);  // use 1 for the first frame
RADEXPFUNC u32  RADEXPLINK BinkGetKeyFrame(HBINK bnk,u32 frame,s32 flags);

RADEXPFUNC s32  RADEXPLINK BinkSetVideoOnOff(HBINK bnk,s32 onoff);
RADEXPFUNC s32  RADEXPLINK BinkSetSoundOnOff(HBINK bnk,s32 onoff);
RADEXPFUNC void RADEXPLINK BinkSetVolume(HBINK bnk,s32 volume);
RADEXPFUNC void RADEXPLINK BinkSetPan(HBINK bnk,s32 pan);
RADEXPFUNC void RADEXPLINK BinkService(HBINK bink);

typedef struct BINKTRACK PTR4* HBINKTRACK;

typedef struct BINKTRACK
{
  u32 Frequency;
  u32 Bits;
  u32 Channels;
  u32 MaxSize;

  HBINK bink;
  u32 sndcomp;
  s32 trackindex;
} BINKTRACK;


RADEXPFUNC HBINKTRACK RADEXPLINK BinkOpenTrack(HBINK bnk,u32 trackindex);
RADEXPFUNC void RADEXPLINK BinkCloseTrack(HBINKTRACK bnkt);
RADEXPFUNC u32  RADEXPLINK BinkGetTrackData(HBINKTRACK bnkt,void PTR4* dest);

RADEXPFUNC u32  RADEXPLINK BinkGetTrackType(HBINK bnk,u32 trackindex);
RADEXPFUNC u32  RADEXPLINK BinkGetTrackMaxSize(HBINK bnk,u32 trackindex);
RADEXPFUNC u32  RADEXPLINK BinkGetTrackID(HBINK bnk,u32 trackindex);
RADEXPFUNC u32  RADEXPLINK BinkGetTrackLargest(HBINK bnk,u32 trackindex);

RADEXPFUNC void RADEXPLINK BinkGetSummary(HBINK bnk,BINKSUMMARY PTR4* sum);
RADEXPFUNC void RADEXPLINK BinkGetRealtime(HBINK bink,BINKREALTIME PTR4* run,u32 frames);

#define BINKNOSOUND 0xffffffff

RADEXPFUNC void RADEXPLINK BinkSetSoundTrack(u32 track);
RADEXPFUNC void RADEXPLINK BinkSetIO(BINKIOOPEN io);
RADEXPFUNC void RADEXPLINK BinkSetFrameRate(u32 forcerate,u32 forceratediv);
RADEXPFUNC void RADEXPLINK BinkSetSimulate(u32 sim);
RADEXPFUNC void RADEXPLINK BinkSetIOSize(u32 iosize);

RADEXPFUNC s32  RADEXPLINK BinkSetSoundSystem(BINKSNDSYSOPEN open, u32 param);

#ifdef __RADWIN__

  RADEXPFUNC BINKSNDOPEN RADEXPLINK BinkOpenDirectSound(u32 param); // don't call directly
  #define BinkSoundUseDirectSound(lpDS) BinkSetSoundSystem(BinkOpenDirectSound,(u32)lpDS)

  RADEXPFUNC BINKSNDOPEN RADEXPLINK BinkOpenWaveOut(u32 param); // don't call directly
  #define BinkSoundUseWaveOut() BinkSetSoundSystem(BinkOpenWaveOut,0)

  #ifndef __RADXBOX__
  #define INCLUDE_MMSYSTEM_H
  #include <windows.h>
  #include <windowsx.h>
  #endif
  #ifdef __RADNT__          // to combat WIN32_LEAN_AND_MEAN
    #include <mmsystem.h>
  #endif

#endif


#ifndef __RADMAC__

  RADEXPFUNC BINKSNDOPEN RADEXPLINK BinkOpenMiles(u32 param); // don't call directly
  #define BinkSoundUseMiles(hdigdriver) BinkSetSoundSystem(BinkOpenMiles,(u32)hdigdriver)

#endif


#ifdef __RADMAC__

  RADEXPFUNC BINKSNDOPEN RADEXPLINK BinkOpenSoundManager(u32 param); // don't call directly
  #define BinkSoundUseSoundManager() BinkSetSoundSystem(BinkOpenSoundManager,0)

#endif


// The BinkBuffer API isn't currently implemented on DOS
#if !defined(__RADDOS__)

//=========================================================================
typedef struct BINKBUFFER * HBINKBUFFER;

#define BINKBUFFERSTRETCHXINT    0x80000000
#define BINKBUFFERSTRETCHX       0x40000000
#define BINKBUFFERSHRINKXINT     0x20000000
#define BINKBUFFERSHRINKX        0x10000000
#define BINKBUFFERSTRETCHYINT    0x08000000
#define BINKBUFFERSTRETCHY       0x04000000
#define BINKBUFFERSHRINKYINT     0x02000000
#define BINKBUFFERSHRINKY        0x01000000
#define BINKBUFFERSCALES         0xff000000
#define BINKBUFFERRESOLUTION     0x00800000

#ifdef __RADMAC__

#include <windows.h>
#include <palettes.h>
#include <qdoffscreen.h>

typedef struct BINKBUFFER {
  u32 Width;
  u32 Height;
  u32 WindowWidth;
  u32 WindowHeight;
  u32 SurfaceType;
  void* Buffer;
  s32 BufferPitch;
  u32 ScreenWidth;
  u32 ScreenHeight;
  u32 ScreenDepth;
  u32 ScaleFlags;

  s32 destx,desty;
  s32 wndx,wndy;
  u32 wnd;

  s32 noclipping;
  u32 type;
  s32 issoftcur;
  u32 cursorcount;

} BINKBUFFER;


#define BINKBUFFERAUTO                0
#define BINKBUFFERDIRECT              1
#define BINKBUFFERGWORLD              2
#define BINKBUFFERTYPEMASK           31

RADEXPFUNC HBINKBUFFER RADEXPLINK BinkBufferOpen( WindowPtr wnd, u32 width, u32 height, u32 bufferflags);
RADEXPFUNC s32 RADEXPLINK BinkGDSurfaceType( GDHandle gd );
RADEXPFUNC s32 RADEXPLINK BinkIsSoftwareCursor(GDHandle gd);
RADEXPFUNC s32 RADEXPLINK BinkCheckCursor(WindowPtr wp,s32 x,s32 y,s32 w,s32 h);

#else

RADEXPFUNC s32 RADEXPLINK BinkDX8SurfaceType(void* lpD3Ds);

#ifndef __RADXBOX__

typedef struct BINKBUFFER {
  u32 Width;
  u32 Height;
  u32 WindowWidth;
  u32 WindowHeight;
  u32 SurfaceType;
  void* Buffer;
  s32 BufferPitch;
  s32 ClientOffsetX;
  s32 ClientOffsetY;
  u32 ScreenWidth;
  u32 ScreenHeight;
  u32 ScreenDepth;
  u32 ExtraWindowWidth;
  u32 ExtraWindowHeight;
  u32 ScaleFlags;
  u32 StretchWidth;
  u32 StretchHeight;

  s32 surface;
  void* ddsurface;
  void* ddclipper;
  s32 destx,desty;
  s32 wndx,wndy;
  u32 wnd;
  s32 ddoverlay;
  s32 ddoffscreen;
  s32 lastovershow;

  s32 issoftcur;
  u32 cursorcount;
  void* buffertop;
  u32 type;
  s32 noclipping;

  s32 loadeddd;
  s32 loadedwin;

  void* dibh;
  void* dibbuffer;
  s32 dibpitch;
  void* dibinfo;
  u32 dibdc;
  u32 diboldbitmap;

} BINKBUFFER;


#define BINKBUFFERAUTO                0
#define BINKBUFFERPRIMARY             1
#define BINKBUFFERDIBSECTION          2
#define BINKBUFFERYV12OVERLAY         3
#define BINKBUFFERYUY2OVERLAY         4
#define BINKBUFFERUYVYOVERLAY         5
#define BINKBUFFERYV12OFFSCREEN       6
#define BINKBUFFERYUY2OFFSCREEN       7
#define BINKBUFFERUYVYOFFSCREEN       8
#define BINKBUFFERRGBOFFSCREENVIDEO   9
#define BINKBUFFERRGBOFFSCREENSYSTEM 10
#define BINKBUFFERLAST               10
#define BINKBUFFERTYPEMASK           31

RADEXPFUNC HBINKBUFFER RADEXPLINK BinkBufferOpen( HWND wnd, u32 width, u32 height, u32 bufferflags);
RADEXPFUNC s32 RADEXPLINK BinkBufferSetHWND( HBINKBUFFER buf, HWND newwnd);
RADEXPFUNC s32 RADEXPLINK BinkDDSurfaceType(void PTR4* lpDDS);
RADEXPFUNC s32 RADEXPLINK BinkIsSoftwareCursor(void PTR4* lpDDSP,HCURSOR cur);
RADEXPFUNC s32 RADEXPLINK BinkCheckCursor(HWND wnd,s32 x,s32 y,s32 w,s32 h);
RADEXPFUNC s32 RADEXPLINK BinkBufferSetDirectDraw(void PTR4* lpDirectDraw, void PTR4* lpPrimary);

#endif

#endif

#ifndef __RADXBOX__

RADEXPFUNC void RADEXPLINK BinkBufferClose( HBINKBUFFER buf);
RADEXPFUNC s32 RADEXPLINK BinkBufferLock( HBINKBUFFER buf);
RADEXPFUNC s32 RADEXPLINK BinkBufferUnlock( HBINKBUFFER buf);
RADEXPFUNC void RADEXPLINK BinkBufferSetResolution( s32 w, s32 h, s32 bits);
RADEXPFUNC void RADEXPLINK BinkBufferCheckWinPos( HBINKBUFFER buf, s32 PTR4* NewWindowX, s32 PTR4* NewWindowY);
RADEXPFUNC s32 RADEXPLINK BinkBufferSetOffset( HBINKBUFFER buf, s32 destx, s32 desty);
RADEXPFUNC void RADEXPLINK BinkBufferBlit( HBINKBUFFER buf, BINKRECT PTR4* rects, u32 numrects );
RADEXPFUNC s32 RADEXPLINK BinkBufferSetScale( HBINKBUFFER buf, u32 w, u32 h);
RADEXPFUNC char PTR4* RADEXPLINK BinkBufferGetDescription( HBINKBUFFER buf);
RADEXPFUNC char PTR4* RADEXPLINK BinkBufferGetError();
RADEXPFUNC s32 RADEXPLINK BinkBufferClear(HBINKBUFFER buf, u32 RGB);

RADEXPFUNC void RADEXPLINK BinkRestoreCursor(s32 checkcount);

#endif

#endif

#ifdef __RADMAC__

#pragma export off

#endif

RADDEFEND

#endif

// @cdep pre $set(INCs,$INCs /I$clipfilename($file)) $ignore(TakeCPP)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XbUtil.Cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 5, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 6 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\XImage.cpp ===
//=============================================================================
// File: XImage.cpp
//
// Desc: 
// Created: 07/12/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================

#include "XImage.h"
#include <xgraphics.h>
#include "PNG\png.h"

//=============================================================================
//=============================================================================
#define RELEASE(x) if (x) { (x)->Release(); (x)=NULL; }

//=============================================================================
//=============================================================================
XIMAGEVERTEX XImage::m_ScreenVertices[] = {
	{   0.0f,   0.0f, 0.0f, 1.0f,   0.0f-0.5f,   0.0f-0.5f },
	{ 640.0f,   0.0f, 0.0f, 1.0f, 640.0f-0.5f,   0.0f-0.5f },
	{ 640.0f, 480.0f, 0.0f, 1.0f, 640.0f-0.5f, 480.0f-0.5f },
	{   0.0f, 480.0f, 0.0f, 1.0f,   0.0f-0.5f, 480.0f-0.5f },
};

//=============================================================================
//=============================================================================
XImage::XImage() :
	m_pTexture(NULL),
	m_pDevice(NULL),
	m_iWidth(0),
	m_iHeight(0)
{
		return;
}

//=============================================================================
//=============================================================================
template <class T> void __forceinline SWAP(T &v1, T &v2)
{
	*(int *)(&v1) ^= *(int *)(&v2);
	*(int *)(&v2) ^= *(int *)(&v1);
	*(int *)(&v1) ^= *(int *)(&v2);
}

//========================================================================
//========================================================================
void PNGAPI user_error_fn(png_structp a, png_const_charp b)
{
}

//========================================================================
//========================================================================
void PNGAPI user_warning_fn(png_structp a, png_const_charp b)
{
}

//========================================================================
//========================================================================
void * user_malloc_fn(png_structp png, size_t size)
{
	return malloc(size);
}

//========================================================================
//========================================================================
void user_free_fn(png_structp png, void * p)
{
	free(p);
}

//=============================================================================
//=============================================================================
bool XImage::Load(IDirect3DDevice8 *pDevice, char *szFileName)
{
	m_pDevice = pDevice;
	m_pDevice->AddRef();

#if 0
    if (FAILED(D3DXCreateTextureFromFileExA( m_pDevice, szFileName,
		D3DX_DEFAULT,
		D3DX_DEFAULT,
		1,
		0,
		D3DFMT_LIN_A8R8G8B8,
		0,
		D3DX_DEFAULT,
		D3DX_DEFAULT,
		0xFF000000,
		NULL,
		NULL,
		&m_pTexture)))
		return false;

	D3DSURFACE_DESC ld;

	m_pTexture->GetLevelDesc(0, &ld);

	m_iWidth = ld.Width;
	m_iHeight = ld.Height;

	if (ld.Format != D3DFMT_LIN_X8R8G8B8)
	{
		IDirect3DTexture8 *pTexture;

		m_pDevice->CreateTexture(ld.Width, ld.Height, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &pTexture);

		SWAP(pTexture, m_pTexture);

		D3DLOCKED_RECT lr1, lr2;

		pTexture->LockRect(0, &lr1, NULL, 0);
		m_pTexture->LockRect(0, &lr2, NULL, 0);

		XGUnswizzleRect(lr1.pBits, ld.Width, ld.Height, NULL, lr2.pBits, 0, NULL, 4);

		pTexture->UnlockRect(0);
		m_pTexture->UnlockRect(0);

		pTexture->Release();
	}

#else

	if (true)
	{
		FILE *fp=fopen(szFileName, "rb");
		if (fp)
		{
			png_structp	png_ptr;
			png_infop	info_ptr;
			png_infop	end_info;

			// read in the PNG header info
			if (true)
			{
				png_ptr = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL, user_error_fn, user_warning_fn, NULL, user_malloc_fn, user_free_fn);
				if (!png_ptr)
				{
					fclose(fp);
					return false;
				}

				info_ptr = png_create_info_struct(png_ptr);
				if (!info_ptr)
				{
					png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
					fclose(fp);
					return false;
				}

				end_info = png_create_info_struct(png_ptr);
				if (!end_info)
				{
					png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
					fclose(fp);
					return false;
				}

				png_init_io(png_ptr, fp);
				png_set_sig_bytes(png_ptr, 0);

				png_read_info(png_ptr, info_ptr);

				png_set_bgr(png_ptr);

				if (info_ptr->channels == 3)
				{
					png_set_filler(png_ptr, 0xFF, PNG_FILLER_AFTER);
				}

			}

			// create the texture and blit it
			if (true)
			{
				m_iWidth	= info_ptr->width;
				m_iHeight	= info_ptr->height;

				m_pDevice->CreateTexture(m_iWidth, m_iHeight, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pTexture);

				D3DLOCKED_RECT lr;
				BYTE **row_pointers = (BYTE **)malloc(sizeof(BYTE *) * info_ptr->height);

				m_pTexture->LockRect(0, &lr, NULL, 0);

				unsigned int y;
				for (y=0 ; y<info_ptr->height ; y++)
				{
					row_pointers[y] = (BYTE *)lr.pBits + y*lr.Pitch;
				}

				png_read_image(png_ptr, row_pointers);

				m_pTexture->UnlockRect(0);
			}

			// load the bits
			if (true)
			{

			}

			// free the texture
			if (true)
			{
				png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
			}


			fclose(fp);
		}
	}

#endif



	return true;
}

//=============================================================================
//=============================================================================
bool XImage::Blt(RECT *r)
{
	if (r)
	{
		m_ScreenVertices[0].x = (float)r->left;
		m_ScreenVertices[0].y = (float)r->top;

		m_ScreenVertices[1].x = (float)r->right;
		m_ScreenVertices[1].y = (float)r->top;

		m_ScreenVertices[2].x = (float)r->right;
		m_ScreenVertices[2].y = (float)r->bottom;

		m_ScreenVertices[3].x = (float)r->left;
		m_ScreenVertices[3].y = (float)r->bottom;
	}
	else
	{
		m_ScreenVertices[0].x = 0;
		m_ScreenVertices[0].y = 0;

		m_ScreenVertices[1].x = 640;
		m_ScreenVertices[1].y = 0;

		m_ScreenVertices[2].x = 640;
		m_ScreenVertices[2].y = 480;

		m_ScreenVertices[3].x = 0;
		m_ScreenVertices[3].y = 480;
	}

	if (true)
	{
		m_ScreenVertices[0].u =      0.0f - 0.5f;
		m_ScreenVertices[0].v =      0.0f - 0.5f;
		m_ScreenVertices[1].u =  m_iWidth - 0.5f;
		m_ScreenVertices[1].v =      0.0f - 0.5f;
		m_ScreenVertices[2].u =  m_iWidth - 0.5f;
		m_ScreenVertices[2].v = m_iHeight - 0.5f;
		m_ScreenVertices[3].u =      0.0f - 0.5f;
		m_ScreenVertices[3].v = m_iHeight - 0.5f;
	}


    m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
    m_pDevice->SetRenderState( D3DRS_ALPHATESTENABLE,	TRUE );
    m_pDevice->SetRenderState( D3DRS_ALPHAFUNC,			D3DCMP_GREATER );

    m_pDevice->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_SRCALPHA );
    m_pDevice->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_INVSRCALPHA );


	// Rendering of scene objects happens here
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,					D3DTOP_SELECTARG1 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,				D3DTA_TEXTURE );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2,				0 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,					D3DTOP_SELECTARG1 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1,				D3DTA_TEXTURE );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,				D3DTADDRESS_CLAMP );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,				D3DTADDRESS_CLAMP );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER,				D3DTEXF_POINT );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER,				D3DTEXF_POINT );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER,				D3DTEXF_POINT );

    m_pDevice->SetTexture(0, m_pTexture);
    m_pDevice->SetVertexShader( D3DFVF_XIMAGEVERTEX );

	m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_ScreenVertices, sizeof(m_ScreenVertices[0]));


	return true;
}

//=============================================================================
//=============================================================================
bool XImage::Blt(int x, int y, int w, int h)
{
	if (true)
	{
		m_ScreenVertices[0].x = (float)x;
		m_ScreenVertices[0].y = (float)y;

		m_ScreenVertices[1].x = (float)(x+w);
		m_ScreenVertices[1].y = (float)y;

		m_ScreenVertices[2].x = (float)(x+w);
		m_ScreenVertices[2].y = (float)(y+h);

		m_ScreenVertices[3].x = (float)x;
		m_ScreenVertices[3].y = (float)(y+h);
	}

	if (true)
	{
		m_ScreenVertices[0].u =      0.0f - 0.5f;
		m_ScreenVertices[0].v =      0.0f - 0.5f;
		m_ScreenVertices[1].u =  m_iWidth - 0.5f;
		m_ScreenVertices[1].v =      0.0f - 0.5f;
		m_ScreenVertices[2].u =  m_iWidth - 0.5f;
		m_ScreenVertices[2].v = m_iHeight - 0.5f;
		m_ScreenVertices[3].u =      0.0f - 0.5f;
		m_ScreenVertices[3].v = m_iHeight - 0.5f;
	}


    m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
    m_pDevice->SetRenderState( D3DRS_ALPHATESTENABLE,	TRUE );
    m_pDevice->SetRenderState( D3DRS_ALPHAFUNC,			D3DCMP_GREATER );

    m_pDevice->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_SRCALPHA );
    m_pDevice->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_INVSRCALPHA );


	// Rendering of scene objects happens here
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,					D3DTOP_SELECTARG1 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,				D3DTA_TEXTURE );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2,				0 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,					D3DTOP_SELECTARG1 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1,				D3DTA_TEXTURE );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,				D3DTADDRESS_CLAMP );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,				D3DTADDRESS_CLAMP );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER,				D3DTEXF_POINT );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER,				D3DTEXF_POINT );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER,				D3DTEXF_POINT );

    m_pDevice->SetTexture(0, m_pTexture);
    m_pDevice->SetVertexShader( D3DFVF_XIMAGEVERTEX );

	m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_ScreenVertices, sizeof(m_ScreenVertices[0]));


	return true;
}

//=============================================================================
//=============================================================================
bool XImage::FillArea(int x, int y, int w, int h, DWORD dwColor)
{
	if (true)
	{
		m_ScreenVertices[0].x = (float)x;
		m_ScreenVertices[0].y = (float)y;

		m_ScreenVertices[1].x = (float)(x+w);
		m_ScreenVertices[1].y = (float)y;

		m_ScreenVertices[2].x = (float)(x+w);
		m_ScreenVertices[2].y = (float)(y+h);

		m_ScreenVertices[3].x = (float)x;
		m_ScreenVertices[3].y = (float)(y+h);
	}

    //m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    //m_pDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );

    m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );



	// Rendering of scene objects happens here
	m_pDevice->SetRenderState( D3DRS_TEXTUREFACTOR,						dwColor );
	m_pDevice->SetRenderState( D3DRS_ZENABLE,							FALSE );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,					D3DTOP_SELECTARG1 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,				D3DTA_TFACTOR);
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2,				0 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2,				0 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,					D3DTOP_SELECTARG1 );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1,				D3DTA_TFACTOR );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,				D3DTADDRESS_CLAMP );
	m_pDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,				D3DTADDRESS_CLAMP );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER,				D3DTEXF_POINT );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER,				D3DTEXF_POINT );
	m_pDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER,				D3DTEXF_POINT );

    m_pDevice->SetTexture(0, m_pTexture);
    m_pDevice->SetVertexShader( D3DFVF_XIMAGEVERTEX );

	m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_ScreenVertices, sizeof(m_ScreenVertices[0]));


	return true;
}

//=============================================================================
//=============================================================================
bool XImage::Free(void)
{
	RELEASE(m_pTexture);
	RELEASE(m_pDevice);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\CountDown\CountDown.cpp ===
//=============================================================================
//=============================================================================
#include <xtl.h>
#include <assert.h>
#include "..\xbfont.h"
#include "..\Image\XImage.h"
#include <xgraphics.h>

//=============================================================================
//=============================================================================
struct DEMO_LAUNCH_DATA
{
	DWORD	dwID;				// I don't know what I'll use this for, yet...
	DWORD	dwRunmode;
	DWORD	dwTimeout;
	char	szLauncherXBE[64];	// name of XBE to launch to return
	char	szLaunchedXBE[64];	// name of your XBE, useful to get path info from
	char	szDemoInfo[MAX_LAUNCH_DATA_SIZE - (128 * sizeof(char)) - (3 * sizeof(DWORD))];
								// set in XDI file, additional info/parameters/whatever
};

#define RUNMODE_KIOSKMODE		0x01
#define RUNMODE_USERSELECTED	0x02

//=============================================================================
//=============================================================================
#define WIDTH		640
#define HEIGHT		480
#define MAKE_RGBA(r,g,b,a) ((((a)<<24)&0xFF000000) | (((r)<<16)&0x00FF0000) | (((g)<<8)&0x0000FF00) | (((b)<<0)&0x000000FF))

//=============================================================================
// function prototypes
//=============================================================================
extern HRESULT InitInput(void);
extern void HandleInput(void);

//=============================================================================
// Global variables
//=============================================================================
LPDIRECT3D8				g_pD3D					= NULL;
LPDIRECT3DDEVICE8		g_pd3dDevice			= NULL;
LPDIRECT3DTEXTURE8		g_pTexture				= NULL;
CXBFont *				g_pFont					= NULL;
XImage					g_Background;
char *					g_pszDirectory;
DEMO_LAUNCH_DATA		g_ld;
DWORD					g_dwTimeout				= 0;

//=============================================================================
// hard-coded file names
//=============================================================================


#define STICK_THRESHHOLD	15000
//=============================================================================
DWORD					g_dwDeviceState	= 0;
HANDLE					g_hInput[12]	= {0};

//=============================================================================
//=============================================================================
void HandleDeviceChanges(XPP_DEVICE_TYPE *pxdt, DWORD dwInsert, DWORD dwRemove)
{

	return;
}

//=============================================================================
//=============================================================================
char *FindPath(const char *szRelPath)
{
	static char szPath[256];

	strcpy(szPath, g_pszDirectory);
	strcat(szPath, szRelPath);

	return szPath;
}


//=============================================================================
//=============================================================================
HANDLE GetController(bool bFirst, int *pnum=NULL)
{
	static int i=0;

	if (bFirst)
		i=0;

	for ( ; i<12 ; i++)
	{
		if (g_dwDeviceState & (1<<i))
		{
			if (pnum)
			{
				*pnum = i;
			}
			return g_hInput[i++];
		}
	}

	return NULL;
}

//=============================================================================
//=============================================================================
void Input(void)
{
	XLaunchNewImage(g_ld.szLauncherXBE, (LAUNCH_DATA *)&g_ld);
}

//=============================================================================
//=============================================================================
void HandleInput(void)
{
	DWORD				dwInsert;
	DWORD				dwRemove;
	XINPUT_STATE		xis;
	static XINPUT_STATE	xis_old[12] = {0};

	if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsert, &dwRemove))
	{
		HandleDeviceChanges(XDEVICE_TYPE_GAMEPAD, dwInsert, dwRemove);

		g_dwDeviceState &= ~dwRemove;
		g_dwDeviceState |= dwInsert;

		for( DWORD i=0; i < XGetPortCount(); i++ )
		{
			// Handle removed devices.
			if( dwRemove & (1<<i) )
			{
				if (g_hInput[i])
				{
					XInputClose( g_hInput[i] );
					g_hInput[i] = NULL;
				}
			}

			if( dwInsert & (1<<i) )
			{
				if (!g_hInput[i])
					g_hInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );

				int err;
				if (g_hInput[i] == NULL)
				{
					err=GetLastError();
				}
				assert(g_hInput[i]);
			}

		}

	}


	HANDLE hPad;

	int n;
	hPad=GetController(true, &n);

	while (hPad)
	{
		XInputGetState(hPad, &xis);

		// now, make the analog thumb sticks either all or nothing
		if (xis.Gamepad.sThumbLY > STICK_THRESHHOLD)
			xis.Gamepad.sThumbLY = STICK_THRESHHOLD;
		else if (xis.Gamepad.sThumbLY < -STICK_THRESHHOLD)
			xis.Gamepad.sThumbLY = -STICK_THRESHHOLD;
		else
			xis.Gamepad.sThumbLY = 0;

		if (xis.Gamepad.sThumbRY > STICK_THRESHHOLD)
			xis.Gamepad.sThumbRY = STICK_THRESHHOLD;
		else if (xis.Gamepad.sThumbRY < -STICK_THRESHHOLD)
			xis.Gamepad.sThumbRY = -STICK_THRESHHOLD;
		else
			xis.Gamepad.sThumbRY = 0;

		if (
			((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]))
			||
			((xis.Gamepad.wButtons & XINPUT_GAMEPAD_START) && !((xis_old[n].Gamepad.wButtons & XINPUT_GAMEPAD_START)))
			)
		{
			Input();
		}

		if ((xis.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]) && (!xis_old[n].Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]))
		{
			Input();
		}

		if ((xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) && !((xis_old[n].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)))
		{
			Input();
		}

		if ((xis.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) && !((xis_old[n].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)))
		{
			Input();
		}

		if ((xis.Gamepad.sThumbLY == STICK_THRESHHOLD) && ((xis_old[n].Gamepad.sThumbLY != STICK_THRESHHOLD)))
		{
			Input();
		}

		if ((xis.Gamepad.sThumbLY == -STICK_THRESHHOLD) && ((xis_old[n].Gamepad.sThumbLY != -STICK_THRESHHOLD)))
		{
			Input();
		}

		if ((xis.Gamepad.sThumbRY == STICK_THRESHHOLD) && ((xis_old[n].Gamepad.sThumbRY != STICK_THRESHHOLD)))
		{
			Input();
		}

		if ((xis.Gamepad.sThumbRY == -STICK_THRESHHOLD) && ((xis_old[n].Gamepad.sThumbRY != -STICK_THRESHHOLD)))
		{
			Input();
		}



		xis_old[n] = xis;

		hPad=GetController(false, &n);
	}

	if (g_ld.dwRunmode & RUNMODE_KIOSKMODE)
	{
		if (g_dwTimeout < timeGetTime())
			Input();
	}
}

//=============================================================================
//=============================================================================
HRESULT InitInput(void)
{
	XDEVICE_PREALLOC_TYPE xdpt[] = {
		{XDEVICE_TYPE_GAMEPAD, 4},
	};

	XInitDevices(sizeof(xdpt)/sizeof(xdpt[0]), xdpt);

	g_dwDeviceState = XGetDevices(XDEVICE_TYPE_GAMEPAD);

	for( DWORD i=0; i<4 ; i++ )
	{
		if( g_dwDeviceState & (1<<i) )
		{
			if (!g_hInput[i])
				g_hInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
		}
	}

	return S_OK;
}


//=============================================================================
//=============================================================================
HRESULT InitD3D(void)
{
    // Create the D3D object, which is used to create the D3DDevice.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory( &d3dpp, sizeof(d3dpp) );

    // Set fullscreen 640x480x32 mode
    d3dpp.BackBufferWidth        = WIDTH;
    d3dpp.BackBufferHeight       = HEIGHT;
    d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;

    // Create one backbuffer and a zbuffer
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Set up how the backbuffer is "presented" to the frontbuffer each frame
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device. Hardware vertex processing is specified
    // since all vertex processing takes place on Xbox hardware.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // After creating the device, initial state would normally be set

    return S_OK;
}



//=============================================================================
//=============================================================================
HRESULT InitBackground(void)
{
//#ifdef _DEBUG
//	g_Background.Load(g_pd3dDevice, "d:\\media\\screen.png");
//#else
	g_Background.Load(g_pd3dDevice, FindPath("screen.png"));
//#endif

	return S_OK;
}

//=============================================================================
//=============================================================================
#pragma optimize("", off)
void AsciiToUnicode(char *s, WCHAR *w)
{
	while (*s)
	{
		((char *)w)[0] = *s;
		((char *)w)[1] = 0;

		w++;
		s++;

		//*w++ = (WCHAR)*s++;
	}
	*w = 0;
}

//=============================================================================
//=============================================================================
VOID Render()
{
	// Cycle through some colors to clear the screen (just to show some output)
	static FLOAT r = 0.0f; if( (r+=1.3f) > 255.0f ) r = 0.0f;
	static FLOAT g = 0.0f; if( (g+=1.7f) > 255.0f ) g = 0.0f;
	static FLOAT b = 0.0f; if( (b+=1.5f) > 255.0f ) b = 0.0f;

	WCHAR wstring[64];
	float x;

	if (true)
	{
		FILETIME ft;
		FILETIME ft2;
		GetSystemTimeAsFileTime(&ft);

		SYSTEMTIME st;

		st.wYear			= 2001;
		st.wMonth			= 11;
		st.wDay				= 8;

		st.wHour			= 0;
		st.wMinute			= 0;
		st.wSecond			= 0;
		st.wMilliseconds	= 0;

		SystemTimeToFileTime(&st, &ft2);

		char string[64];

		__int64 diff = (*(__int64 *)&ft2)-(*(__int64 *)&ft);

		assert((diff/10000000) > 10);

		int ms	= (int)((diff/10000) % 1000);
		int sec	= (int)((diff/10000000) % 60);
		int min	= (int)((diff/600000000) % 60);
		int hr	= (int)((diff/36000000000) % 24);
		int days= (int)((diff/(36000000000*24)));

		wsprintf(string, "%d days, %3d:%02d:%02d", days, hr, min, sec);
	//	wsprintf(string, "%d", (unsigned int)(diff/10000000));

		//strcpy(string, "2503:30:12.523");

		//OutputDebugString(string);
		//OutputDebugString("   ");

		AsciiToUnicode(string, wstring);
		//UnicodeToAscii(wstring, string);

		//OutputDebugString(string);
		//OutputDebugString("\n");

		float width, height;
		g_pFont->GetTextExtent(wstring, &width, &height);

		x=320 - (width/2);

	}

	// Clear the backbuffer to a changing color
	//g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( (int)r, (int)g, (int)b ), 1.0f, 0L );
	g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

	// Begin the scene
	g_pd3dDevice->BeginScene();

	g_Background.Blt();
	//g_pFont->DrawText( x, 60, MAKE_RGBA(112, 188, 31, 0xFF), wstring);
	g_pFont->DrawText( x, 60, MAKE_RGBA(56, 94, 16, 0xFF), wstring);
    g_pd3dDevice->EndScene();
}
#pragma optimize("", on)


//=============================================================================
// main()
//
// The main function that runs the program
//=============================================================================
void __cdecl main()
{
#ifdef _DEBUG
//	__asm int 3;
#endif

	if (true)
	{
		static char string[256];
		DWORD dwLaunchInfo;

		if ((XGetLaunchInfo(&dwLaunchInfo, (LAUNCH_DATA *)&g_ld)==ERROR_SUCCESS) && ((dwLaunchInfo&3) == LDT_TITLE))
		{
			// we were probably launched from XDemos, so get the path from
			// it
			strcpy(string, g_ld.szLaunchedXBE);
			char *p=string;
			for ( ; *p ; p++);
			for ( ; *p != '\\' && p>string ; p--);
			strcpy(p, "\\media\\");

			g_pszDirectory = string;

			if (g_ld.dwRunmode & RUNMODE_KIOSKMODE)
			{
#ifdef _DEBUG
				g_dwTimeout = timeGetTime() + 15000;
#else
				g_dwTimeout = timeGetTime() + g_ld.dwTimeout;
#endif
			}
		}
		else
		{
			g_ld.szLauncherXBE[0]=0;
			g_pszDirectory = "d:\\Media\\";
		}
	}

	// various initialization
    if (FAILED(InitD3D()))
        return;

	if (FAILED(InitBackground()))
		return;

	if (FAILED(InitInput()))
		return;

	// create the fonts that we will use
	g_pFont = new CXBFont;
	g_pFont->Create(g_pd3dDevice, FindPath("Font.xpr"));

	// the main loop
    while (true)
    {
		HandleInput();
        Render();
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XDemos.h ===
//=============================================================================
// File: XDemos.h
//
// Desc: This is the main header for the XDemos project
// Created: 07/02/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================

#pragma once


//=============================================================================
// include files
//=============================================================================
#include <xtl.h>
#include <assert.h>
#include "xbfont.h"
#include "bink\bink.h"
#include "wmv\wmvplay.h"
#include "XDIFile\XDIFile.h"

//=============================================================================
// Global variables
//=============================================================================
extern LPDIRECT3D8			g_pD3D;
extern LPDIRECT3DDEVICE8	g_pd3dDevice;


//=============================================================================
// Global Functions
//=============================================================================
extern HRESULT InitAudio(void);
extern void UpdateAudio(void);
extern void StopAudio(void);
extern void StartAudio(void);
extern char *FindPath(const char *szRelPath);
extern void PlayLaunchSound(void);
extern void PlayMenuSound(void);
extern HRESULT InitInput(void);
extern void SaveState(int dw1, int dw2, int dw3);
extern void GetState(int &dw1, int &dw2, int &dw3);
extern void HandleInput(void);
extern bool PlayMovie(char *szFileName);

extern void ButtonUp(void);
extern void ButtonDn(void);
extern void ButtonMiddle(void);
extern void ButtonA(void);
extern void ButtonB(void);
extern void Input(void);
extern bool CheckForInput(void);


//=============================================================================
//=============================================================================
extern const char *			g_pszMenuSound;
extern const char *			g_pszLaunchSound;
extern const char *			g_pszAmbientSound;
extern const char *			g_pszSettingsFile;
extern const char *			g_pszBackground;
extern const char *			g_pszWait;
extern const char *			g_pszUp;
extern const char *			g_pszDn;
extern const char *			g_pszXDI1;
extern const char *			g_pszXDI2;
extern const char *			g_pszFontN;
extern const char *			g_pszFontB;
extern DWORD                g_dwNextButton;

//=============================================================================
//=============================================================================
struct DEMO_LAUNCH_DATA
{
	DWORD	dwID;				// I don't know what I'll use this for, yet...
	DWORD	dwRunmode;
	DWORD	dwTimeout;
	char	szLauncherXBE[64];	// name of XBE to launch to return
	char	szLaunchedXBE[64];	// name of your XBE, useful to get path info from
	char	szDemoInfo[MAX_LAUNCH_DATA_SIZE - (128 * sizeof(char)) - (3 * sizeof(DWORD))];
								// set in XDI file, additional info/parameters/whatever
};

#define RUNMODE_KIOSKMODE		0x01
#define RUNMODE_USERSELECTED	0x02

//=============================================================================
//=============================================================================
typedef struct tagCUSTOMVERTEX
{
    float x,y,z,w;
    float u,v;
} CUSTOMVERTEX;

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)



//========================================================================
//========================================================================
template<class T> __forceinline void AllocString(T * &ptr, size_t len)
{
	ptr = (T *)malloc(len * sizeof(T));
}

//========================================================================
//========================================================================
__forceinline WCHAR * DuplicateAsciiToUnicode(const char *src)
{
	WCHAR *dst;

	//
	// now, get the size of the buffer required, and allocate it
	//
	int iSize;

	iSize=(strlen(src) + 1)*2;

	if (!iSize)
		return NULL;
	
	AllocString(dst, iSize);
	if (!dst)
		return NULL;

	WCHAR *d = dst;
	while (*src)
	{
		*d++ = (WCHAR)*src++;
	}
	*d = 0;

	return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Bink\RAD.H ===
#ifndef __RAD__
#define __RAD__

#define RADCOPYRIGHT "Copyright (C) 1994-2001, RAD Game Tools, Inc."

#ifndef __RADRES__

//  __RAD16__ means 16 bit code (Win16)
//  __RAD32__ means 32 bit code (DOS, Win386, Win32s, Mac)

//  __RADDOS__ means DOS code (16 or 32 bit)
//  __RADWIN__ means Windows code (Win16, Win386, Win32s)
//  __RADWINEXT__ means Windows 386 extender (Win386)
//  __RADNT__ means Win32s code
//  __RADMAC__ means Macintosh
//  __RADXBOX__ means the XBox console

//  __RADX86__ means Intel x86
//  __RADMMX__ means Intel x86 MMX instructions are allowed
//  __RAD68K__ means 68K
//  __RADPPC__ means PowerPC

// __RADLITTLEENDIAN__ means processor is little-endian (x86)
// __RADBIGENDIAN__ means processor is big-endian (680x0, PPC)

// __RADALLOWINLINES__ means this compiler allows inline function declarations
//                     use RADINLINE for the appropriate keyword


#if (defined(__MWERKS__) && !defined(__INTEL__)) || defined(__MRC__) || defined(THINK_C) || defined(powerc) || defined(macintosh) || defined(__powerc)

  #define __RADMAC__
  #if defined(powerc) || defined(__powerc)
    #define __RADPPC__
  #else
    #define __RAD68K__
  #endif

  #define __RAD32__

  #define __RADBIGENDIAN__

  #if defined(__MWERKS__)
    #if (defined(__cplusplus) || ! __option(only_std_keywords))
      #define __RADALLOWINLINES__
      #define RADINLINE inline
    #endif
  #elif defined(__MRC__)
    #if defined(__cplusplus)
      #define __RADALLOWINLINES__
      #define RADINLINE inline
    #endif
  #endif

#else

  #define __RADX86__
  #define __RADMMX__

  #ifdef __MWERKS__
    #define _WIN32
  #endif

  #ifdef __DOS__
    #define __RADDOS__
  #endif

  #ifdef __386__
    #define __RAD32__
  #endif

  #ifdef _Windows    //For Borland
    #ifdef __WIN32__
      #define WIN32
    #else
      #define __WINDOWS__
    #endif
  #endif

  #ifdef _WINDOWS    //For MS
    #ifndef _WIN32
      #define __WINDOWS__
    #endif
  #endif

  #ifdef _WIN32
    #ifdef _XBOX
      #define __RADXBOX__
    #else
      #define __RADNT__
    #endif
    #define __RADWIN__
    #define __RAD32__
  #else
    #ifdef __NT__
      #ifdef _XBOX
        #define __RADXBOX__
      #else
        #define __RADNT__
      #endif
      #define __RADWIN__
      #define __RAD32__
    #else
      #ifdef __WINDOWS_386__
        #define __RADWIN__
        #define __RADWINEXT__
        #define __RAD32__
      #else
        #ifdef __WINDOWS__
          #define __RADWIN__
          #define __RAD16__
        #else
          #ifdef WIN32
            #ifdef _XBOX
              #define __RADXBOX__
            #else
              #define __RADNT__
            #endif
            #define __RADWIN__
            #define __RAD32__
          #endif
        #endif
      #endif
    #endif
  #endif

  #define __RADLITTLEENDIAN__

  // TODO - make sure these are set correctly for non-Mac versions
  #define __RADALLOWINLINES__
  #define RADINLINE __inline

#endif

#ifndef __RADALLOWINLINES__
  #define RADINLINE
#endif

#if (!defined(__RADDOS__) && !defined(__RADWIN__) && !defined(__RADMAC__))
  #error RAD.H did not detect your platform.  Define __DOS__, __WINDOWS__, WIN32, macintosh, or powerc.
#endif

#ifdef __RADMAC__

  // this define is for CodeWarrior 11's stupid new libs (even though
  //   we don't use longlong's).

  #define __MSL_LONGLONG_SUPPORT__

  #define RADLINK
  #define RADEXPLINK

  #ifdef __CFM68K__
    #ifdef __RADINDLL__
      #define RADEXPFUNC RADDEFFUNC __declspec(export)
    #else
      #define RADEXPFUNC RADDEFFUNC __declspec(import)
    #endif
  #else
    #define RADEXPFUNC RADDEFFUNC
  #endif
  #define RADASMLINK

#else

  #ifdef __RADNT__
    #ifndef _WIN32
      #define _WIN32
    #endif
    #ifndef WIN32
      #define WIN32
    #endif
  #endif

  #ifdef __RADWIN__
    #ifdef __RAD32__
      #ifdef __RADXBOX__
         
         #define RADLINK __stdcall
         #define RADEXPLINK __stdcall
         #define RADEXPFUNC RADDEFFUNC

      #else
        #ifdef __RADNT__

          #define RADLINK __stdcall
          #define RADEXPLINK __stdcall

          #ifdef __RADINEXE__
            #define RADEXPFUNC RADDEFFUNC
          #else
            #ifndef __RADINDLL__
              #define RADEXPFUNC RADDEFFUNC __declspec(dllimport)
              #ifdef __BORLANDC__
                #if __BORLANDC__<=0x460
                  #undef RADEXPFUNC
                  #define RADEXPFUNC RADDEFFUNC
                #endif
              #endif
            #else
              #define RADEXPFUNC RADDEFFUNC __declspec(dllexport)
            #endif
          #endif
        #else
          #define RADLINK __pascal
          #define RADEXPLINK __far __pascal
          #define RADEXPFUNC RADDEFFUNC
        #endif
      #endif
    #else
      #define RADLINK __pascal
      #define RADEXPLINK __far __pascal __export
      #define RADEXPFUNC RADDEFFUNC
    #endif
  #else
    #define RADLINK __pascal
    #define RADEXPLINK __pascal
    #define RADEXPFUNC RADDEFFUNC
  #endif

  #define RADASMLINK __cdecl

#endif

#ifdef __RADWIN__
  #ifndef _WINDOWS
    #define _WINDOWS
  #endif
#endif

#ifndef RADDEFFUNC

#ifdef __cplusplus
  #define RADDEFFUNC extern "C"
  #define RADDEFSTART extern "C" {
  #define RADDEFEND }
#else
  #define RADDEFFUNC
  #define RADDEFSTART
  #define RADDEFEND
#endif

#endif

RADDEFSTART

#define s8 signed char
#define u8 unsigned char
#define u32 unsigned long
#define s32 signed long
#define f32 float
#define f64 double

#if defined(__MWERKS__) || defined(__MRC__)
#define u64 unsigned long long
#define s64 signed long long
#else
#define u64 unsigned __int64
#define s64 signed __int64
#endif

/* 32 bit implementations */

#ifdef __RAD32__
  #define PTR4

  #define u16 unsigned short
  #define s16 signed short

  #ifdef __RADMAC__

    #include <string.h>
    #include <MacTypes.h>
    #include <Memory.h>
    #include <OSUtils.h>
    #ifdef __MRC__
      #include "intrinsics.h"    
    #endif

    void radconv32a(void* p, u32 n);

    u32 radloadu32(u32 a);

    u32 radloadu32ptr(u32* p);

    #define radstrcpy strcpy

    #define radstrcat strcat

    #define radmemcpy(dest,source,size) BlockMoveData((Ptr)(source),(Ptr)(dest),size)

    #define radmemcpydb(dest,source,size) BlockMoveData((Ptr)(source),(Ptr)(dest),size)

    #define radmemcmp memcmp

    #define radmemset memset

    #define radstrlen strlen

    #define radstrchr strchr

    #define radtoupper toupper

    #define radstru32(s) ((u32)atol(s))

    //s8 radstricmp(const void* s1,const void* s2);

    #define radstrcmp strcmp

    //char* radstrupr(void* s1);

    //char* radstrlwr(void* s1);

    u32 radsqr(u32 a);

    u32 mult64anddiv(u32 mt1,u32 mt2,u32 d);

    s32 radabs(s32 ab);

    #define radabs32 radabs

    //char* radstpcpy(void* dest,const void* source);

    //char* radstpcpyrs(void* dest,const void* source);

    void radmemset16(void* dest,u16 value,u32 size);

    //void radmemset32(void* dest,u32 value,u32 size);

    #define BreakPoint() DebugStr("\pBreakPoint() was called")

    //u8 radinp(u16 p);

    //void radoutp(u16 p,u8 v);

    //u32 RADsqrt(u32 sq);

    u32 RADCycleTimerAvail(void);

    void RADCycleTimerStartAddr(u32* addr);

    u32 RADCycleTimerDeltaAddr(u32* addr);

    void RADCycleTimerStartAddr64(u64* addr);

    void RADCycleTimerDeltaAddr64(u64* addr);

    #define RADCycleTimerStart(var) RADCycleTimerStartAddr(&var)

    #define RADCycleTimerDelta(var) RADCycleTimerDeltaAddr(&var)

    #define RADCycleTimerStart64(var) RADCycleTimerStartAddr64(&var)

    #define RADCycleTimerDelta64(var) RADCycleTimerDeltaAddr64(&var)


    #ifdef __RAD68K__
      #pragma parameter radconv32a(__A0,__D0)
      void radconv32a(void* p,u32 n) ={0x4A80,0x600C,0x2210,0xE059,0x4841,0xE059,0x20C1,0x5380,0x6EF2};
      // tst.l d0  bra.s @loope  @loop:  move.l (a0),d1  ror.w #8,d1  swap d1 ror.w #8,d1  move.l d1,(a0)+  sub.l #1,d0  bgt.s @loop  @loope:
    #endif

    #ifdef __RADALLOWINLINES__
      #if defined __RADPPC__ && defined(__MWERKS__) && (__MWERKS__ >= 0x2301) && 0
        u32 RADINLINE radloadu32(register u32 x) {
          register u32 t1, t2;
          asm {                   // x  = aa bb cc dd
            rlwinm t1,x,24,0,23   // t1 = dd aa bb 00
            rlwinm t2,x,8,24,31   // t2 = 00 00 00 aa
            rlwimi t1,x,8, 8,15   // t1 = dd cc bb 00
            or x,t1,t2            // x  = dd cc bb aa
          }
          return x;
        }
      #else
        u32 RADINLINE radloadu32(register u32 x) {
          return (((x << 24) & 0xFF000000) |
                  ((x <<  8) & 0x00FF0000) |
                  ((x >>  8) & 0x0000FF00) |
                  ((x >> 24) & 0x000000FF));
        }
      #endif
    #endif

    #if defined(__RADPPC__) && (defined(__MWERKS__) || defined(__MRC__))
      #define radloadu32ptr(p) (u32) __lwbrx((p),0)
    #else
      #define radloadu32ptr(p) radloadu32(*(u32*)(p));
    #endif

    #ifdef __RADALLOWINLINES__
      u32 RADINLINE radsqr(u32 a) {  return(a*a);  }
    #endif

    #ifdef __RAD68K__
      #pragma parameter __D0 mult64anddiv(__D0,__D1,__D2)
      u32 mult64anddiv(u32 mt1,u32 mt2,u32 d) ={0x4C01,0x0C01,0x4C42,0x0C01};
      //  muls.l d1,d1:d0  divs.l d2,d1:d0
    #endif

    #if defined(__RADPPC__) && (defined(__MWERKS__) || defined(__MRC__))
      #define radabs(ab) __abs((s32)(ab))
    #elif defined(__RADALLOWINLINES__)
      s32 RADINLINE radabs(s32 ab) { return (ab < 0) ? -ab : ab; }
    #endif

  #else

    #define radconv32a(p,n) ((void)0)

    #define radloadu32(a) ((u32)(a))

    #define radloadu32ptr(p) *((u32*)(p))

    #ifdef __WATCOMC__

      u32 radsqr(s32 a);
      #pragma aux radsqr = "mul eax" parm [eax] modify [EDX eax];

      u32 mult64anddiv(u32 mt1,u32 mt2,u32 d);
      #pragma aux mult64anddiv = "mul ecx" "div ebx" parm [eax] [ecx] [ebx] modify [EDX eax];

      s32 radabs(s32 ab);
      #pragma aux radabs = "test eax,eax" "jge skip" "neg eax" "skip:" parm [eax];

      #define radabs32 radabs

      u32 DOSOut(const char* str);
      #pragma aux DOSOut = "cld" "mov ecx,0xffffffff" "xor eax,eax" "mov edx,edi" "repne scasb" "not ecx" "dec ecx" "mov ebx,1" "mov ah,0x40" "int 0x21" parm [EDI] modify [EAX EBX ECX EDX EDI] value [ecx];
    
      void DOSOutNum(const char* str,u32 len);
      #pragma aux DOSOutNum = "mov ah,0x40" "mov ebx,1" "int 0x21" parm [edx] [ecx] modify [eax ebx];

      u32 ErrOut(const char* str);
      #pragma aux ErrOut = "cld" "mov ecx,0xffffffff" "xor eax,eax" "mov edx,edi" "repne scasb" "not ecx" "dec ecx" "xor ebx,ebx" "mov ah,0x40" "int 0x21" parm [EDI] modify [EAX EBX ECX EDX EDI] value [ecx];
    
      void ErrOutNum(const char* str,u32 len);
      #pragma aux ErrOutNum = "mov ah,0x40" "xor ebx,ebx" "int 0x21" parm [edx] [ecx] modify [eax ebx];

      void radmemset16(void* dest,u16 value,u32 size);
      #pragma aux radmemset16 = "cld" "mov bx,ax" "shl eax,16" "mov ax,bx" "mov bl,cl" "shr ecx,1" "rep stosd" "mov cl,bl" "and cl,1" "rep stosw" parm [EDI] [EAX] [ECX] modify [EAX EDX EBX ECX EDI];
    
      void radmemset(void* dest,u8 value,u32 size);
      #pragma aux radmemset = "cld" "mov ah,al" "mov bx,ax" "shl eax,16" "mov ax,bx" "mov bl,cl" "shr ecx,2" "and bl,3" "rep stosd" "mov cl,bl" "rep stosb" parm [EDI] [AL] [ECX] modify [EAX EDX EBX ECX EDI];

      void radmemset32(void* dest,u32 value,u32 size);
      #pragma aux radmemset32 = "cld" "rep stosd" parm [EDI] [EAX] [ECX] modify [EAX EDX EBX ECX EDI];

      void radmemcpy(void* dest,const void* source,u32 size);
      #pragma aux radmemcpy = "cld" "mov bl,cl" "shr ecx,2" "rep movsd" "mov cl,bl" "and cl,3" "rep movsb" parm [EDI] [ESI] [ECX] modify [EBX ECX EDI ESI];

      void __far *radfmemcpy(void __far* dest,const void __far* source,u32 size);
      #pragma aux radfmemcpy = "cld" "push es" "push ds" "mov es,cx" "mov ds,dx" "mov ecx,eax" "shr ecx,2" "rep movsd" "mov cl,al" "and cl,3" "rep movsb" "pop ds" "pop es" parm [CX EDI] [DX ESI] [EAX] modify [ECX EDI ESI] value [CX EDI];

      void radmemcpydb(void* dest,const void* source,u32 size);  //Destination bigger
      #pragma aux radmemcpydb = "std" "mov bl,cl" "lea esi,[esi+ecx-4]" "lea edi,[edi+ecx-4]" "shr ecx,2" "rep movsd" "and bl,3" "jz dne" "add esi,3" "add edi,3" "mov cl,bl" "rep movsb" "dne:" "cld" parm [EDI] [ESI] [ECX] modify [EBX ECX EDI ESI];

      char* radstrcpy(void* dest,const void* source);
      #pragma aux radstrcpy = "cld" "mov edx,edi" "lp:" "mov al,[esi]" "inc esi" "mov [edi],al" "inc edi" "cmp al,0" "jne lp" parm [EDI] [ESI] modify [EAX EDX EDI ESI] value [EDX];

      char __far* radfstrcpy(void __far* dest,const void __far* source);
      #pragma aux radfstrcpy = "cld" "push es" "push ds" "mov es,cx" "mov ds,dx" "mov edx,edi" "lp:" "lodsb" "stosb" "test al,0xff" "jnz lp" "pop ds" "pop es" parm [CX EDI] [DX ESI] modify [EAX EDX EDI ESI] value [CX EDX];

      char* radstpcpy(void* dest,const void* source);
      #pragma aux radstpcpy = "cld" "lp:" "mov al,[esi]" "inc esi" "mov [edi],al" "inc edi" "cmp al,0" "jne lp" "dec edi" parm [EDI] [ESI] modify [EAX EDI ESI] value [EDI];

      char* radstpcpyrs(void* dest,const void* source);
      #pragma aux radstpcpyrs = "cld" "lp:" "mov al,[esi]" "inc esi" "mov [edi],al" "inc edi" "cmp al,0" "jne lp" "dec esi" parm [EDI] [ESI] modify [EAX EDI ESI] value [ESI];

      u32 radstrlen(const void* dest);
      #pragma aux radstrlen = "cld" "mov ecx,0xffffffff" "xor eax,eax" "repne scasb" "not ecx" "dec ecx" parm [EDI] modify [EAX ECX EDI] value [ECX];
    
      char* radstrcat(void* dest,const void* source);
      #pragma aux radstrcat = "cld" "mov ecx,0xffffffff" "mov edx,edi" "xor eax,eax" "repne scasb" "dec edi" "lp:" "lodsb" "stosb" "test al,0xff" "jnz lp" \
      parm [EDI] [ESI] modify [EAX ECX EDI ESI] value [EDX];

      char* radstrchr(const void* dest,char chr);
      #pragma aux radstrchr = "cld" "lp:" "lodsb" "cmp al,dl" "je fnd" "cmp al,0" "jnz lp" "mov esi,1" "fnd:" "dec esi" parm [ESI] [DL] modify [EAX ESI] value [esi];

      s8 radmemcmp(const void* s1,const void* s2,u32 len);
      #pragma aux radmemcmp = "cld" "rep cmpsb" "setne al" "jbe end" "neg al" "end:"  parm [EDI] [ESI] [ECX] modify [ECX EDI ESI];

      s8 radstrcmp(const void* s1,const void* s2);
      #pragma aux radstrcmp = "lp:" "mov al,[esi]" "mov ah,[edi]" "cmp al,ah" "jne set" "cmp al,0" "je set" "inc esi" "inc edi" "jmp lp" "set:" "setne al" "jbe end" "neg al" "end:" \
      parm [EDI] [ESI] modify [EAX EDI ESI];

      s8 radstricmp(const void* s1,const void* s2);
      #pragma aux radstricmp = "lp:" "mov al,[esi]" "mov ah,[edi]" "cmp al,'a'" "jb c1" "cmp al,'z'" "ja c1" "sub al,32" "c1:" "cmp ah,'a'" "jb c2" "cmp ah,'z'" "ja c2" "sub ah,32" "c2:" "cmp al,ah" "jne set" "cmp al,0" "je set" \
     "inc esi" "inc edi" "jmp lp" "set:" "setne al" "jbe end" "neg al" "end:" \
      parm [EDI] [ESI] modify [EAX EDI ESI];

      s8 radstrnicmp(const void* s1,const void* s2,u32 len);
      #pragma aux radstrnicmp = "lp:" "mov al,[esi]" "mov ah,[edi]" "cmp al,'a'" "jb c1" "cmp al,'z'" "ja c1" "sub al,32" "c1:" "cmp ah,'a'" "jb c2" "cmp ah,'z'" "ja c2" "sub ah,32" "c2:" "cmp al,ah" "jne set" "cmp al,0" "je set" \
      "dec ecx" "jz set" "inc esi" "inc edi" "jmp lp" "set:" "setne al" "jbe end" "neg al" "end:" \
      parm [EDI] [ESI] [ECX] modify [EAX ECX EDI ESI];

      char* radstrupr(void* s1);
      #pragma aux radstrupr = "mov ecx,edi" "lp:" "mov al,[edi]" "cmp al,'a'" "jb c1" "cmp al,'z'" "ja c1" "sub [edi],32" "c1:" "inc edi" "cmp al,0" "jne lp" parm [EDI] modify [EAX EDI] value [ecx];

      char* radstrlwr(void* s1);
      #pragma aux radstrlwr = "mov ecx,edi" "lp:" "mov al,[edi]" "cmp al,'A'" "jb c1" "cmp al,'Z'" "ja c1" "add [edi],32" "c1:" "inc edi" "cmp al,0" "jne lp" parm [EDI] modify [EAX EDI] value [ecx];

      u32 radstru32(const void* dest);
        #pragma aux radstru32 = "cld" "xor ecx,ecx" "xor ebx,ebx" "xor edi,edi" "lodsb" "cmp al,45" "jne skip2" "mov edi,1" "jmp skip" "lp:" "mov eax,10" "mul ecx" "lea ecx,[eax+ebx]" \
        "skip:" "lodsb" "skip2:" "cmp al,0x39" "ja dne" "cmp al,0x30" "jb dne" "mov bl,al" "sub bl,0x30" "jmp lp" "dne:" "test edi,1" "jz pos" "neg ecx" "pos:" \
        parm [ESI] modify [EAX EBX EDX EDI ESI] value [ecx];

      u16 GetDS();
      #pragma aux GetDS = "mov ax,ds" value [ax];

      #ifdef __RADWINEXT__

        #define _16To32(ptr16) ((void*)(((GetSelectorBase((u16)(((u32)(ptr16))>>16))+((u16)(u32)(ptr16)))-GetSelectorBase(GetDS()))))

      #endif

      #ifndef __RADWIN__
        #define int86 int386
        #define int86x int386x
      #endif

      #define u32regs x
      #define u16regs w

    #else

      #define radstrcpy strcpy
      #define radstrcat strcat
      #define radmemcpy memcpy
      #define radmemcpydb memmove
      #define radmemcmp memcmp
      #define radmemset memset
      #define radstrlen strlen
      #define radstrchr strchr
      #define radtoupper toupper
      #define radstru32(s) ((u32)atol(s))
      #define radstricmp _stricmp
      #define radstrcmp strcmp
      #define radstrupr _strupr
      #define radstrlwr _strlwr
      #define BreakPoint() __asm {int 3}
      #define DOSOut(str)

      #ifdef _MSC_VER

        #pragma warning( disable : 4035)

        typedef char* RADPCHAR;

        u32 __inline radsqr(u32 m) {
          __asm {
            mov eax,[m]
            mul eax
          }
        }

        u32 __inline mult64anddiv(u32 mt1,u32 mt2, u32 d) {
          __asm {
            mov eax,[mt1]
            mov ecx,[mt2]
            mul ecx
            mov ecx,[d]
            div ecx
          }
        }

        s32 __inline radabs(s32 ab) {
          __asm {
            mov eax,[ab]
            test eax,eax
            jge skip
            neg eax
           skip:
          }
        }

        u8 __inline radinp(u16 p) {
          __asm {
            mov dx,[p] 
            in al,dx 
          } 
        }

        void __inline radoutp(u16 p,u8 v) {
          __asm {
            mov dx,[p]
            mov al,[v]
            out dx,al 
          }
        }

        RADPCHAR __inline radstpcpy(char* p1, char* p2) { 
          __asm {
             mov edx,[p1] 
             mov ecx,[p2]
             cld
            lp:
             mov al,[ecx] 
             inc ecx 
             mov [edx],al 
             inc edx
             cmp al,0 
             jne lp 
             dec edx
             mov eax,edx
          } 
        }

        RADPCHAR __inline radstpcpyrs(char* p1, char* p2) { 
          __asm {
            mov edx,[p1]
            mov ecx,[p2]
            cld
           lp:
            mov al,[ecx]
            inc ecx
            mov [edx],al
            inc edx
            cmp al,0 
            jne lp
            dec ecx
            mov eax,ecx 
          }
        }

        void __inline radmemset16(void* dest,u16 value,u32 sizeb) {
          __asm {
            mov edi,[dest]
            mov ax,[value] 
            mov ecx,[sizeb]
            shl eax,16 
            cld 
            mov ax,[value] 
            mov bl,cl 
            shr ecx,1 
            rep stosd
            mov cl,bl 
            and cl,1 
            rep stosw
          }
        }

        void __inline radmemset32(void* dest,u32 value,u32 sizeb) {
          __asm {
            mov edi,[dest]
            mov eax,[value]
            mov ecx,[sizeb]
            cld
            rep stosd
          }
        }

        u32 __inline __stdcall RADsqrt(u32 sq) {
          __asm {
            fild dword ptr [sq]
            fsqrt
            fistp word ptr [sq]
            movzx eax,word ptr [sq]
          }
        }

        u32 __inline RADCycleTimerAvail(void)
        {
          u32 rdtscavail=(u32)-1;
          __try
          {
            __asm
            {
#ifdef __MWERKS__
              rdtsc
#else
#if _MSC_VER<=1100
              __emit 0xf
              __emit 0x31
#else
              rdtsc
#endif
#endif
            }
            rdtscavail=1;
          }
          __except (1)
          {
            rdtscavail=(u32)-1;
          }
          return rdtscavail;
        }

        void __inline RADCycleTimerStartAddr(u32* addr)
        {
          __asm {
            mov ecx,[addr]
#ifdef __MWERKS__
            rdtsc
#else
#if _MSC_VER<=1100
            __emit 0xf
            __emit 0x31
#else
            rdtsc
#endif
#endif
            mov [ecx],eax
          }
        }

        u32 __inline RADCycleTimerDeltaAddr(u32* addr)
        {
          __asm {
#ifdef __MWERKS__
            rdtsc
#else
#if _MSC_VER<=1100
            __emit 0xf
            __emit 0x31
#else
            rdtsc
#endif
#endif
            mov ecx,[addr]
            mov edx,eax
            sub eax,[ecx]
            mov [ecx],eax
          }
        }

        void __inline RADCycleTimerStartAddr64(u64* addr)
        {
          __asm {
            mov ecx,[addr]
#ifdef __MWERKS__
            rdtsc
#else
#if _MSC_VER<=1100
            __emit 0xf
            __emit 0x31
#else
            rdtsc
#endif
#endif
            mov [ecx],eax
            mov [ecx+4],edx
          }
        }

        void __inline RADCycleTimerDeltaAddr64(u64* addr)
        {
          __asm {
#ifdef __MWERKS__
            rdtsc
#else
#if _MSC_VER<=1100
            __emit 0xf
            __emit 0x31
#else
            rdtsc
#endif
#endif
            mov ecx,[addr]
            sub eax,[ecx]
            sbb edx,[ecx+4]
            mov [ecx],eax
            mov [ecx+4],edx
          }
        }

        #define RADCycleTimerStart(var) RADCycleTimerStartAddr(&var)
        #define RADCycleTimerDelta(var) RADCycleTimerDeltaAddr(&var)

        #define RADCycleTimerStart64(var) RADCycleTimerStartAddr64(&var)
        #define RADCycleTimerDelta64(var) RADCycleTimerDeltaAddr64(&var)

        #pragma warning( default : 4035)

      #endif

    #endif

  #endif

#else

  #define PTR4 __far

  #define u16 unsigned int
  #define s16 signed int

  #ifdef __WATCOMC__

    u32 radsqr(s32 a);
    #pragma aux radsqr = "shl edx,16" "mov dx,ax" "mov eax,edx" "xor edx,edx" "mul eax" "shld edx,eax,16" parm [dx ax] modify [DX ax] value [dx ax];

    s16 radabs(s16 ab);
    #pragma aux radabs = "test ax,ax" "jge skip" "neg ax" "skip:" parm [ax] value [ax];

    s32 radabs32(s32 ab);
    #pragma aux radabs32 = "test dx,dx" "jge skip" "neg dx" "neg ax" "sbb dx,0" "skip:" parm [dx ax] value [dx ax];
    
    u32 DOSOut(const char far* dest);
    #pragma aux DOSOut = "cld" "and edi,0xffff" "mov dx,di" "mov ecx,0xffffffff" "xor eax,eax" 0x67 "repne scasb" "not ecx" "dec ecx" "mov bx,1" "push ds" "push es" "pop ds" "mov ah,0x40" "int 0x21" "pop ds" "movzx eax,cx" "shr ecx,16" \
       parm [ES DI] modify [AX BX CX DX DI ES] value [CX AX];
    
    void DOSOutNum(const char far* str,u16 len);
    #pragma aux DOSOutNum = "push ds" "mov ds,cx" "mov cx,bx" "mov ah,0x40" "mov bx,1" "int 0x21" "pop ds" parm [cx dx] [bx] modify [ax bx cx];

    u32 ErrOut(const char far* dest);
    #pragma aux ErrOut = "cld" "and edi,0xffff" "mov dx,di" "mov ecx,0xffffffff" "xor eax,eax" 0x67 "repne scasb" "not ecx" "dec ecx" "xor bx,bx" "push ds" "push es" "pop ds" "mov ah,0x40" "int 0x21" "pop ds" "movzx eax,cx" "shr ecx,16" \
       parm [ES DI] modify [AX BX CX DX DI ES] value [CX AX];

    void ErrOutNum(const char far* str,u16 len);
    #pragma aux ErrOutNum = "push ds" "mov ds,cx" "mov cx,bx" "mov ah,0x40" "xor bx,bx" "int 0x21" "pop ds" parm [cx dx] [bx] modify [ax bx cx];

    void radmemset(void far *dest,u8 value,u32 size);
    #pragma aux radmemset = "cld" "and edi,0ffffh" "shl ecx,16" "mov cx,bx" "mov ah,al" "mov bx,ax" "shl eax,16" "mov ax,bx" "mov bl,cl" "shr ecx,2" 0x67 "rep stosd" "mov cl,bl" "and cl,3" "rep stosb" parm [ES DI] [AL] [CX BX];

    void radmemset16(void far* dest,u16 value,u32 size);
    #pragma aux radmemset16 = "cld" "and edi,0ffffh" "shl ecx,16" "mov cx,bx" "mov bx,ax" "shl eax,16" "mov ax,bx" "mov bl,cl" "shr ecx,1" "rep stosd" "mov cl,bl" "and cl,1" "rep stosw" parm [ES DI] [AX] [CX BX];

    void radmemcpy(void far* dest,const void far* source,u32 size);
    #pragma aux radmemcpy = "cld" "push ds" "mov ds,dx" "and esi,0ffffh" "and edi,0ffffh" "shl ecx,16" "mov cx,bx" "shr ecx,2" 0x67 "rep movsd" "mov cl,bl" "and cl,3" "rep movsb" "pop ds" parm [ES DI] [DX SI] [CX BX] modify [CX SI DI ES];

    s8 radmemcmp(const void far* s1,const void far* s2,u32 len);
    #pragma aux radmemcmp = "cld" "push ds" "mov ds,dx" "shl ecx,16" "mov cx,bx" "rep cmpsb" "setne al" "jbe end" "neg al" "end:" "pop ds"  parm [ES DI] [DX SI] [CX BX] modify [CX SI DI ES];

    char far* radstrcpy(void far* dest,const void far* source);
    #pragma aux radstrcpy = "cld" "push ds" "mov ds,dx" "and esi,0xffff" "and edi,0xffff" "mov dx,di" "lp:" "lodsb" "stosb" "test al,0xff" "jnz lp" "pop ds" parm [ES DI] [DX SI] modify [AX DX DI SI ES] value [es dx];

    char far* radstpcpy(void far* dest,const void far* source);
    #pragma aux radstpcpy = "cld" "push ds" "mov ds,dx" "and esi,0xffff" "and edi,0xffff" "lp:" "lodsb" "stosb" "test al,0xff" "jnz lp" "dec di" "pop ds" parm [ES DI] [DX SI] modify [DI SI ES] value [es di];

    u32 radstrlen(const void far* dest);
    #pragma aux radstrlen = "cld" "and edi,0xffff" "mov ecx,0xffffffff" "xor eax,eax" 0x67 "repne scasb" "not ecx" "dec ecx" "movzx eax,cx" "shr ecx,16" parm [ES DI] modify [AX CX DI ES] value [CX AX];
    
    char far* radstrcat(void far* dest,const void far* source);
    #pragma aux radstrcat = "cld" "and edi,0xffff" "mov ecx,0xffffffff" "and esi,0xffff" "push ds" "mov ds,dx" "mov dx,di" "xor eax,eax" 0x67 "repne scasb" "dec edi" "lp:" "lodsb" "stosb" "test al,0xff" "jnz lp" "pop ds" \
      parm [ES DI] [DX SI] modify [AX CX DI SI ES] value [es dx];
    
    char far* radstrchr(const void far* dest,char chr);
    #pragma aux radstrchr = "cld" "lp:" 0x26 "lodsb" "cmp al,dl" "je fnd" "cmp al,0" "jnz lp" "xor ax,ax" "mov es,ax" "mov si,1" "fnd:" "dec si" parm [ES SI] [DL] modify [AX SI ES] value [es si];

    s8 radstricmp(const void far* s1,const void far* s2);
    #pragma aux radstricmp = "and edi,0xffff" "push ds" "mov ds,dx" "and esi,0xffff" "lp:" "mov al,[esi]" "mov ah,[edi]" "cmp al,'a'" "jb c1" "cmp al,'z'" "ja c1" "sub al,32" "c1:" \
      "cmp ah,'a'" "jb c2" "cmp ah,'z'" "ja c2" "sub ah,32" "c2:" "cmp al,ah" "jne set" "cmp al,0" "je set" \
      "inc esi" "inc edi" "jmp lp" "set:" "setne al" "jbe end" "neg al" "end:" "pop ds" \
      parm [ES DI] [DX SI] modify [AX DI SI];

    u32 radstru32(const void far* dest);
    #pragma aux radstru32 = "cld" "xor ecx,ecx" "xor ebx,ebx" "xor edi,edi" 0x26 "lodsb" "cmp al,45" "jne skip2" "mov edi,1" "jmp skip" "lp:" "mov eax,10" "mul ecx" "lea ecx,[eax+ebx]" \
      "skip:" 0x26 "lodsb" "skip2:" "cmp al,0x39" "ja dne" "cmp al,0x30" "jb dne" "mov bl,al" "sub bl,0x30" "jmp lp" "dne:" "test edi,1" "jz pos" "neg ecx" "pos:" \
      "movzx eax,cx" "shr ecx,16" parm [ES SI] modify [AX BX DX DI SI] value [cx ax];

    u32 mult64anddiv(u32 mt1,u32 mt2,u32 d);
    #pragma aux mult64anddiv = "shl ecx,16" "mov cx,ax" "shrd eax,edx,16" "mov ax,si" "mul ecx" "shl edi,16" "mov di,bx" "div edi" "shld edx,eax,16" "and edx,0xffff" "and eax,0xffff" parm [cx ax] [dx si] [di bx] \
      modify [ax bx cx dx si di] value [dx ax];

  #endif

#endif

RADDEFEND

#define u32neg1 ((u32)(s32)-1)
#define RAD_align(var) var; u8 junk##var[4-(sizeof(var)&3)];
#define RAD_align_after(var) u8 junk##var[4-(sizeof(var)&3)]={0};
#define RAD_align_init(var,val) var=val; u8 junk##var[4-(sizeof(var)&3)]={0};
#define RAD_align_array(var,num) var[num]; u8 junk##var[4-(sizeof(var)&3)];
#define RAD_align_string(var,str) char var[]=str; u8 junk##var[4-(sizeof(var)&3)]={0};


typedef void PTR4* (RADLINK PTR4* RADMEMALLOC) (u32 bytes);
typedef void       (RADLINK PTR4* RADMEMFREE)  (void PTR4* ptr);

#ifdef __RADMAC__
  #pragma export on
#endif
RADEXPFUNC void RADEXPLINK RADSetMemory(RADMEMALLOC a,RADMEMFREE f);
#ifdef __RADMAC__
  #pragma export off
#endif

RADEXPFUNC void PTR4* RADEXPLINK radmalloc(u32 numbytes);
RADEXPFUNC void RADEXPLINK radfree(void PTR4* ptr);

#ifdef __RADDOS__

  RADDEFSTART
  extern void* RADTimerSetupAddr;
  extern void* RADTimerReadAddr;
  extern void* RADTimerDoneAddr;
  RADDEFEND

  typedef void RADEXPLINK (*RADTimerSetupType)(void);
  typedef u32 RADEXPLINK (*RADTimerReadType)(void);
  typedef void RADEXPLINK (*RADTimerDoneType)(void);

  #define RADTimerSetup() ((RADTimerSetupType)(RADTimerSetupAddr))()
  #define RADTimerRead() ((RADTimerReadType)(RADTimerReadAddr))()
  #define RADTimerDone() ((RADTimerDoneType)(RADTimerDoneAddr))()

#else

  #define RADTimerSetup()
  #define RADTimerDone()

  #if (defined(__RAD16__) || defined(__RADWINEXT__))

    #define RADTimerRead timeGetTime

  #else

    RADEXPFUNC u32 RADEXPLINK RADTimerRead(void);

  #endif

#endif


#ifdef __WATCOMC__

  char bkbhit();
  #pragma aux bkbhit = "mov ah,1" "int 0x16" "lahf" "shr eax,14" "and eax,1" "xor al,1" ;

  char bgetch();
  #pragma aux bgetch = "xor ah,ah" "int 0x16" "test al,0xff" "jnz done" "mov al,ah" "or al,0x80" "done:" modify [AX];

  void BreakPoint();
  #pragma aux BreakPoint = "int 3";

  u8 radinp(u16 p);
  #pragma aux radinp = "in al,dx" parm [DX];

  u8 radtoupper(u8 p);
  #pragma aux radtoupper = "cmp al,'a'" "jb c1" "cmp al,'z'" "ja c1" "sub al,32" "c1:" parm [al] value [al];

  void radoutp(u16 p,u8 v);
  #pragma aux radoutp = "out dx,al" parm [DX] [AL];

#else

// for multi-processor machines

#ifdef __RADNT__
  #define LockedIncrement(var) __asm { lock inc [var] }
  #define LockedDecrement(var) __asm { lock dec [var] }
  void __inline LockedIncrementFunc(void PTR4* var) {
    __asm {
      mov eax,[var]
      lock inc [eax]
    }
  }

  void __inline LockedDecrementFunc(void PTR4* var) {
    __asm {
       mov eax,[var]
       lock dec [eax]
    }
  }

  void __inline LockedAddFunc(void PTR4* var,u32 val) {
    __asm {
      mov eax,[var]
      mov edx,[val]
      lock add [eax],edx
    }
  }

#else

  #ifdef __RADMAC__

    #define LockedIncrement(var) {++(var);}
    #define LockedDecrement(var) {--(var);}

    #define LockedIncrementFunc(ptr) {++(*((u32*)(ptr)));}
    #define LockedDecrementFunc(ptr) {--(*((u32*)(ptr)));}
    
    #define LockedIncrementFunc(ptr,val) {(*((u32*)(ptr)))+=(val);}

  #else

    #define LockedIncrement(var) __asm { inc [var] }
    #define LockedDecrement(var) __asm { dec [var] }
    void __inline LockedIncrementFunc(void PTR4* var) { __asm { mov eax,[var]
                                                                inc [eax] } }
    void __inline LockedDecrementFunc(void PTR4* var) { __asm { mov eax,[var]
                                                                dec [eax] } }
    void __inline LockedAddFunc(void PTR4* var,u32 val) {
      __asm {
        mov eax,[var]
        mov edx,[val]
        add [eax],edx
      }
    }

  #endif

#endif

#endif

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XbUtil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\xdemos.cpp ===
//=============================================================================
// File: XDemos.cpp
//
// Desc: This is the main module for the XDemos project
// Created: 07/02/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================
#include "XDemos.h"
#include "Image\XImage.h"
#include <xgraphics.h>
#ifdef _DEBUG
#include <xbdm.h>
#endif
#ifdef PROFILE
#include <xbdm.h>
#include <d3d8perf.h>
#pragma comment(lib, "xbdm.lib")
#endif

//=============================================================================
//=============================================================================
#define WIDTH		640
#define HEIGHT		480

#ifdef _DEBUG
#define VIDEO_DELAY	75000
#else
//#define VIDEO_DELAY	5000
#define VIDEO_DELAY	75000
#endif

#define MAX_PRIORITY	100

#define MAKE_RGBA(r,g,b,a) ((((a)<<24)&0xFF000000) | (((r)<<16)&0x00FF0000) | (((g)<<8)&0x0000FF00) | (((b)<<0)&0x000000FF))


#define TEXT_START_X			87//70
#define TEXT_START_Y			145//108
#define TEXT_SECOND_OFFSET		10
#define TEXT_LINE_SEP			24
#define TEXT_DEMO_SEP			49
#define FILL_START_X			82//68
#define FILL_START_Y			147//110
#define FILL_WIDTH				227//(291-67)
#define FILL_HEIGHT				50
#define FILL_SEP				49
#define TEASER_X				335//335
#define TEASER_Y				130//120
#define TEASER_W				(594-335)
#define TEASER_H				(311-120)

#define BUTTON_DELAY			500
#define BUTTON_REPEAT			175

#define ARROW_X					178//153
#define ARROW_UP				133//100
#define ARROW_DN				346//310
#define ARROW_W					32//46
#define ARROW_H					16//12


//=============================================================================
// function prototypes
//=============================================================================
void UpdateBackgroundMovie(void);

//=============================================================================
//=============================================================================
class DEMO
{
public:
	XImage *		m_Teaser;
	XImage *		m_PleaseWait;
	DIB *			m_pDib;
	WCHAR *			m_Title;
	WCHAR *			m_Type;
	char *			m_szFile;
};

//=============================================================================
// Global variables
//=============================================================================
LPDIRECT3D8				g_pD3D					= NULL;
LPDIRECT3DDEVICE8		g_pd3dDevice			= NULL;
LPDIRECT3DTEXTURE8		g_pTexture				= NULL;
CXBFont *				g_pFontN				= NULL;
CXBFont *				g_pFontB				= NULL;
XImage					g_Background;
XImage					g_PleaseWait;
XImage					g_UpArrow;
XImage					g_DnArrow;
XImage *				g_ReturnToGamePleaseWait = NULL;

int						g_iListChoice			= 0;
int						g_iListOffset			= 0;
XDIHEADER *				g_pXDIHeader;
DEMO *					g_pDemos				= NULL;
char *					g_pszDirectory			= NULL;

IDirect3DTexture8 *		g_pBkgndTexture			= NULL;
HBINK					g_hBkgndMovie			= NULL;
DWORD					g_dwNextButton			= 0;


// timing mode variables
bool					g_bTimingMode			= false;
int						g_iNextVideo			= 0;
DWORD					g_dwVideoTime			= 0;



//=============================================================================
// hard-coded file names
//=============================================================================
const char *			g_pszSettingsFile	= "t:\\XDemos.ini";
const char *			g_pszXDI1			= "d:\\XDemos\\XDemos.xdi";
const char *			g_pszXDI2			= "d:\\XDemos.xdi";
const char *			g_pszAmbientSound	= "media\\ambient.wma";
const char *			g_pszDn				= "media\\dn.png";
const char *			g_pszMenuSound		= "media\\menu.wav";
const char *			g_pszLaunchSound	= "media\\launch.wav";
const char *			g_pszBackground		= "media\\screen.png";
const char *			g_pszBackgroundT	= "media\\screenT.png";
const char *			g_pszWait			= "media\\wait.png";
const char *			g_pszUp				= "media\\up.png";
const char *			g_pszFontN			= "media\\fontN.xpr";
const char *			g_pszFontB			= "media\\fontB.xpr";
const char *			g_pszBackgroundMovie= "media\\bkgnd.bik";



//=============================================================================
//=============================================================================
char *FindPath(const char *szRelPath)
{
	static char szPath[256];

	strcpy(szPath, g_pszDirectory);
	strcat(szPath, szRelPath);

	return szPath;
}


//=============================================================================
//=============================================================================
bool ExecuteDemo(DEMO &demo, bool bTimingMode)
{
	// verify the file exists
	if (true)
	{
		HANDLE hFile;

		hFile=CreateFile(demo.m_szFile, 0, 0, 0, OPEN_EXISTING, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			return false;

	 	CloseHandle(hFile);
	}


	if (demo.m_pDib->m_dwFlags & DIBFLAGS_MOVIE)
	{
		return PlayMovie(demo.m_szFile);
	}
	else
	{
		//
		// save the state
		//
		SaveState(g_iListChoice, g_iListOffset, g_iNextVideo);
		DEMO_LAUNCH_DATA ld;

		ld.dwID = 0;
		ld.dwTimeout = 60000;
		strcpy(ld.szLaunchedXBE, demo.m_szFile);

		if (g_bTimingMode)
			strcpy(ld.szLauncherXBE, "d:\\XDemos.xbe");
		else
			strcpy(ld.szLauncherXBE, "d:\\XDemos\\XDemos.xbe");

		if (bTimingMode)
			ld.dwRunmode = RUNMODE_KIOSKMODE;
		else
			ld.dwRunmode = RUNMODE_USERSELECTED;

		demo.m_PleaseWait->Blt();
		g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
		g_pd3dDevice->PersistDisplay();

		XLaunchNewImage(demo.m_szFile, (LAUNCH_DATA *)&ld);
	}

	return false;
}

//=============================================================================
//=============================================================================
void Input(void)
{
	g_dwVideoTime = timeGetTime() + VIDEO_DELAY;
}

//=============================================================================
//=============================================================================
void ButtonUp(void)
{
	DWORD time=timeGetTime();

	if (g_dwNextButton == 0)
		g_dwNextButton = time + BUTTON_DELAY;
	else if (time > g_dwNextButton)
		g_dwNextButton += BUTTON_REPEAT;
	else
		return;

	g_iListChoice--;
	if (g_iListChoice < 0)
		g_iListChoice = 0;
	else
		PlayMenuSound();

	if ((g_iListChoice - g_iListOffset) > 2)
	{
		g_iListOffset = g_iListChoice - 2;
	}

	if ((g_iListChoice - g_iListOffset) < 1)
	{
		g_iListOffset = g_iListChoice - 1;
	}

	if (g_iListOffset == g_pXDIHeader->m_lNumDemos - 1)
		g_iListOffset = g_pXDIHeader->m_lNumDemos - 2;

	if (g_iListOffset < 0)
		g_iListOffset = 0;
}

//=============================================================================
//=============================================================================
void ButtonDn(void)
{
	DWORD time=timeGetTime();

	if (g_dwNextButton == 0)
		g_dwNextButton = time + BUTTON_DELAY;
	else if (time > g_dwNextButton)
		g_dwNextButton += BUTTON_REPEAT;
	else
		return;

	g_iListChoice++;
	if (g_iListChoice == g_pXDIHeader->m_lNumDemos)
		g_iListChoice = g_pXDIHeader->m_lNumDemos-1;
	else
		PlayMenuSound();

	if ((g_iListChoice - g_iListOffset) > 2)
	{
		if (g_iListChoice != g_pXDIHeader->m_lNumDemos - 1)
			g_iListOffset = g_iListChoice - 2;
	}

	if ((g_iListChoice - g_iListOffset) < 1)
	{
		g_iListOffset = g_iListChoice - 1;
	}

	if (g_iListOffset == g_pXDIHeader->m_lNumDemos - 1)
		g_iListOffset = g_pXDIHeader->m_lNumDemos - 2;

	if (g_iListOffset < 0)
		g_iListOffset = 0;
}

//=============================================================================
//=============================================================================
void ButtonMiddle(void)
{
	g_dwNextButton = 0;
	return;
}


//=============================================================================
//=============================================================================
void ButtonA(void)
{
	PlayLaunchSound();

	ExecuteDemo(g_pDemos[g_iListChoice], false);

}

//=============================================================================
//=============================================================================
void ButtonB(void)
{
	if (g_bTimingMode)
		return;

	g_ReturnToGamePleaseWait->Blt();
	g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	g_pd3dDevice->PersistDisplay();
	LAUNCH_DATA ld;

	ld.Data[0]='X';
	ld.Data[1]='D';
	ld.Data[2]='E';
	ld.Data[3]='M';
	ld.Data[4]='O';
	ld.Data[5]='S';
	ld.Data[6]=0;

	SaveState(0, 0, 0);

	PlayLaunchSound();
	XLaunchNewImage(g_pXDIHeader->m_szGameName, &ld);
	// exit!!
}

//=============================================================================
//=============================================================================
HRESULT InitD3D(void)
{
    // Create the D3D object, which is used to create the D3DDevice.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory( &d3dpp, sizeof(d3dpp) );

    // Set fullscreen 640x480x32 mode
    d3dpp.BackBufferWidth        = WIDTH;
    d3dpp.BackBufferHeight       = HEIGHT;
    d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;

    // Create one backbuffer and a zbuffer
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Set up how the backbuffer is "presented" to the frontbuffer each frame
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device. Hardware vertex processing is specified
    // since all vertex processing takes place on Xbox hardware.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // After creating the device, initial state would normally be set

    return S_OK;
}



//=============================================================================
//=============================================================================
HRESULT InitBackground(void)
{
	if (g_bTimingMode)
		g_Background.Load(g_pd3dDevice, FindPath(g_pszBackgroundT));
	else
		g_Background.Load(g_pd3dDevice, FindPath(g_pszBackground));

	g_PleaseWait.Load(g_pd3dDevice, FindPath(g_pszWait));
	g_UpArrow.Load(g_pd3dDevice, FindPath(g_pszUp));
	g_DnArrow.Load(g_pd3dDevice, FindPath(g_pszDn));

	return S_OK;

}

//=============================================================================
//=============================================================================
bool PlayBinkFile(char *szFileName)
{
	bool bReturn = false;

	StopAudio();

	CheckForInput();

	IDirect3DTexture8 *pTexture = NULL;
	HBINK hBink = BinkOpen(szFileName, 0);
	if (!hBink)
		return false;
	
	g_pd3dDevice->CreateTexture(hBink->Width, hBink->Height, 1, 0, D3DFMT_LIN_X8R8G8B8, 0, &pTexture);

	int fs=0;

	while (true)
	{
		BinkDoFrame(hBink);
		if (CheckForInput())
		{
			bReturn = true;
			g_dwNextButton = (DWORD)-1;
			break;
		}

		if (true)
		{
			D3DLOCKED_RECT lr;

			if (true)
			{
				pTexture->LockRect(0, &lr, NULL, 0);
				BinkCopyToBuffer(hBink, lr.pBits, lr.Pitch, hBink->Height, 0, 0, BINKCOPYALL | BINKSURFACE32);
				pTexture->UnlockRect(0);
			}

			static struct {
				float	x,y,z,w;
				float	u,v;
			} vertices[4] = {
				{ 0,0,0,1,0,0 },
				{ 0,0,0,1,0,0 },
				{ 0,0,0,1,0,0 },
				{ 0,0,0,1,0,0 },
			};

			if (true)
			{
				if (true)
				{
					vertices[0].x	= 0.0f;
					vertices[0].y	= 0.0f;

					vertices[1].x	= WIDTH;
					vertices[1].y	= 0.0f;

					vertices[2].x	= 0.0f;
					vertices[2].y	= HEIGHT;

					vertices[3].x	= WIDTH;
					vertices[3].y	= HEIGHT;
				}

				if (true)
				{
					vertices[0].u	= -.5f + 0.0f;
					vertices[0].v	= -.5f + 0.0f;

					vertices[1].u	= -.5f + (float)hBink->Width-10;
					vertices[1].v	= -.5f + 0.0f;

					vertices[2].u	= -.5f + 0.0f;
					vertices[2].v	= -.5f + (float)hBink->Height-10;

					vertices[3].u	= -.5f + (float)hBink->Width-10;
					vertices[3].v	= -.5f + (float)hBink->Height-10;
				}
			}

			g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( 0, 0, 255 ), 1.0f, 0L );
			g_pd3dDevice->BeginScene();
			g_pd3dDevice->SetTexture(0, pTexture);
			g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_TEX1);
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, vertices, sizeof(vertices[0]));

			// End the scene
			g_pd3dDevice->EndScene();

		    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
		}
		
		// blit the frame onto the screen here (platform specific)
		if (hBink->FrameNum == (hBink->Frames-1))
			break;	// done at the point
		else
			BinkNextFrame(hBink);  // skip to the next frame
		
		while (BinkWait(hBink));
	}

	pTexture->Release();

	BinkClose(hBink);

	StartAudio();

	return bReturn;
}

//=============================================================================
//=============================================================================
bool PlayMovie(char *szFileName)
{
#ifdef WMV
	char *pExtension = strrchr(szFileName, '.');

	if (pExtension && _stricmp(pExtension, ".wmv") == 0)
	{
		return PlayWMVFile(szFileName);
	}
	else
	{
		return PlayBinkFile(szFileName);
	}
#else
	return PlayBinkFile(szFileName);
#endif
}

//=============================================================================
//=============================================================================
VOID Render()
{
	// Cycle through some colors to clear the screen (just to show some output)
	static FLOAT r = 0.0f; if( (r+=1.3f) > 255.0f ) r = 0.0f;
	static FLOAT g = 0.0f; if( (g+=1.7f) > 255.0f ) g = 0.0f;
	static FLOAT b = 0.0f; if( (b+=1.5f) > 255.0f ) b = 0.0f;

	// Clear the backbuffer to a changing color
	//g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( (int)r, (int)g, (int)b ), 1.0f, 0L );
	g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, MAKE_RGBA(0x30, 0xA0, 0x00, 0x00), 1.0f, 0L );

	// Begin the scene
	g_pd3dDevice->BeginScene();

	UpdateBackgroundMovie();

	g_Background.Blt();
	if (g_pDemos)
		g_pDemos[g_iListChoice].m_Teaser->Blt(TEASER_X, TEASER_Y, TEASER_W, TEASER_H);
	else
	{
		g_pFontN->DrawText(TEXT_START_X, TEXT_START_Y, MAKE_RGBA(0xC6, 0xFF, 0x00, 0xFF), L"Corrupt XDI file");
	}

	const float period=8.0f;
	const float twopi = 6.283185307179586476925286766559f;
	const float halfpi = 1.5707963267948966192313216916398f;
	float time = (float)(timeGetTime())/1000.0f;

	for (int i = g_iListOffset ; i < g_iListOffset + 4 ; i++)
	{
		int offset = i - g_iListOffset;
		//int opacity = (int)(((float)sin((twopi * time / period) + (-i * halfpi)) * 100.0f) + 255.0f - 60.0f);
		//if (opacity > 204)
		//	opacity=204;
		int opacity = 255;

		if (i == g_pXDIHeader->m_lNumDemos)
			break;


		DWORD dwTextColor;
		DWORD dwAltTextColor;

		if (i == g_iListChoice)
		{
			dwTextColor = MAKE_RGBA(37, 77, 16, opacity);
			dwAltTextColor = MAKE_RGBA(57, 97, 36, opacity);
			//dwTextColor = MAKE_RGBA(0xD6, 0xE1, 0x0B, opacity);

			//g_Background.FillArea(FILL_START_X, FILL_START_Y + FILL_SEP * offset, FILL_WIDTH, FILL_HEIGHT, MAKE_RGBA(0xC6, 0xFF, 0x00, opacity));
			g_Background.FillArea(FILL_START_X, FILL_START_Y + FILL_SEP * offset, FILL_WIDTH, FILL_HEIGHT, MAKE_RGBA(187, 213, 98, opacity));
		}
		else
		{
			dwTextColor = MAKE_RGBA(108, 203, 53, opacity);
			dwAltTextColor = MAKE_RGBA(68, 153, 13, opacity);
			//dwTextColor = MAKE_RGBA(0xC6, 0xFF, 0x00, opacity);
		}


		g_pFontB->DrawText(TEXT_START_X, (float)(TEXT_START_Y + TEXT_DEMO_SEP * offset), dwTextColor, g_pDemos[i].m_Title);
		g_pFontN->DrawText(TEXT_START_X+TEXT_SECOND_OFFSET, (float)(TEXT_START_Y + TEXT_LINE_SEP + TEXT_DEMO_SEP * offset), dwAltTextColor, g_pDemos[i].m_Type);
	}

	if (g_iListOffset > 0)
	{
		// show up arrow
		g_UpArrow.Blt(ARROW_X, ARROW_UP, ARROW_W, ARROW_H);
	}

	if (g_pXDIHeader->m_lNumDemos > (g_iListOffset+4))
	{
		// show down arrow
		g_DnArrow.Blt(ARROW_X, ARROW_DN, ARROW_W, ARROW_H);
	}

    // End the scene
    g_pd3dDevice->EndScene();

#ifdef PROFILE
	if (true)
	{
		static DWORD dwLastTime=0;
		DWORD dwTime=timeGetTime();
		WORD string[64];

		wsprintfW(string, L"%d ms/f", dwTime-dwLastTime);
		g_pFontB->DrawText(400, 30, 0xFFFFFFFF, string);

		float fps=1000.0f / (dwTime-dwLastTime);

		wsprintfW(string, L"%.2f fps", fps);
		g_pFontB->DrawText(400, 55, 0xFFFFFFFF, string);

		dwLastTime=dwTime;
	}
#endif
}


//=============================================================================
// InitXDI
//
// This function reads in the XDI file, sorts the demos according to priority,
// and loads in each demo's teaser image.
//=============================================================================
HRESULT InitXDI(void)
{
	bool bRoot=false;

	DWORD dwSize;

	// try to read the XDI file in the XDemos directory (as if we're launched from a game
    dwSize = XDIReadFile(g_pszXDI1, NULL, 0);
	if (dwSize == -1)
	{
		// okay, then try to load it in the root directory, as if we're launched in Kiosk
		// mode
	    dwSize = XDIReadFile(g_pszXDI2, NULL, 0);
		g_pXDIHeader = (XDIHEADER *)calloc(dwSize, 1);
		if (XDIReadFile(g_pszXDI2, g_pXDIHeader, dwSize) == -1)
		{
			// error reading XDI file!!
			g_pXDIHeader->m_fKiosk			= true;
			g_pXDIHeader->m_lNumDemos		= 0;
			g_pXDIHeader->m_szGameName[0]	= 0;
			g_pXDIHeader->m_szPersist[0]	= 0;
			g_pXDIHeader->m_lVerMajor		= VERMAJOR;
			g_pXDIHeader->m_lVerMinor		= VERMINOR;

			if (true)
			{
				HANDLE hFile;

				hFile=CreateFile("d:\\XDemos.xdi", 0, 0, 0, OPEN_EXISTING, 0, NULL);
				if (hFile == INVALID_HANDLE_VALUE)
				{
					g_pszDirectory = "d:\\XDemos\\";
				}
				else
				{
					bRoot=true;
					g_pszDirectory = "d:\\";
					CloseHandle(hFile);
				}
			}
		}
		else
			bRoot=true;
	}
	else
	{
		g_pXDIHeader = (XDIHEADER *)calloc(dwSize, 1);
		if (XDIReadFile(g_pszXDI1, g_pXDIHeader, dwSize) == -1)
		{
			// error reading XDI file!!
			g_pXDIHeader->m_fKiosk			= true;
			g_pXDIHeader->m_lNumDemos		= 0;
			g_pXDIHeader->m_szGameName[0]	= 0;
			g_pXDIHeader->m_szPersist[0]	= 0;
			g_pXDIHeader->m_lVerMajor		= VERMAJOR;
			g_pXDIHeader->m_lVerMinor		= VERMINOR;

			if (true)
			{
				HANDLE hFile;

				hFile=CreateFile("d:\\XDemos.xdi", 0, 0, 0, OPEN_EXISTING, 0, NULL);
				if (hFile == INVALID_HANDLE_VALUE)
				{
					g_pszDirectory = "d:\\XDemos\\";
				}
				else
				{
					bRoot=true;
					g_pszDirectory = "d:\\";
					CloseHandle(hFile);
				}
			}
		}
	}

	if (!g_pszDirectory)
	{
		if (g_pXDIHeader->m_szGameName[0])
		{
			g_bTimingMode = false;
			if (bRoot)
				g_pszDirectory = "d:\\";
			else
				g_pszDirectory = "d:\\XDemos\\";
		}
		else
		{
			g_bTimingMode = true;
			g_dwVideoTime = timeGetTime() + VIDEO_DELAY;
			g_pszDirectory = "d:\\";
		}
	}

	if (g_pXDIHeader->m_lNumDemos)
		g_pDemos = (DEMO *)malloc(sizeof(DEMO) * g_pXDIHeader->m_lNumDemos);

	g_ReturnToGamePleaseWait = &g_PleaseWait;
	if (g_pXDIHeader->m_szPersist && g_pXDIHeader->m_szPersist[0])
	{
		g_ReturnToGamePleaseWait = new XImage;
		g_ReturnToGamePleaseWait->Load(g_pd3dDevice, g_pXDIHeader->m_szPersist);
	}

	int pri;
	int i=0;

	for (pri=0 ; pri<MAX_PRIORITY ; pri++)
	{
		DIB *pdib = (DIB *)((int)g_pXDIHeader + sizeof(XDIHEADER));

		for (int n=0 ; n<g_pXDIHeader->m_lNumDemos ; n++)
		{
			if (pdib->m_dwPriority == pri)
			{
				g_pDemos[i].m_pDib = pdib;

				//
				// do images
				//
				g_pDemos[i].m_Teaser = new XImage;
				g_pDemos[i].m_Teaser->Load(g_pd3dDevice, FindPath(pdib->m_pszTeaser));

				if (pdib->m_pszPersist)
				{
					g_pDemos[i].m_PleaseWait = new XImage;
					g_pDemos[i].m_PleaseWait->Load(g_pd3dDevice, pdib->m_pszPersist);
				}
				else
				{
					g_pDemos[i].m_PleaseWait = &g_PleaseWait;
				}

				//
				// do text
				//
				if (true)
				{
					g_pDemos[i].m_Title = DuplicateAsciiToUnicode(pdib->m_pszTitle);
				}

				if (true)
				{
					if ((pdib->m_pszDemoType) && (pdib->m_pszDemoType[0]))
						g_pDemos[i].m_Type = DuplicateAsciiToUnicode(pdib->m_pszDemoType);
					else
						g_pDemos[i].m_Type = DuplicateAsciiToUnicode((pdib->m_dwFlags & DIBFLAGS_MOVIE) ? "Non-Interactive Movie" : "Interactive Demo");
				}

				if (true)
				{
					char *p = FindPath(pdib->m_pszXBE);

					g_pDemos[i].m_szFile = new char[strlen(p) + 1];
					strcpy(g_pDemos[i].m_szFile, p);
				}

				i++;
			}

			pdib = pdib->m_pNext;
		}
	}

	return S_OK;
}

//=============================================================================
// HandleTimingMode()
//
// If we're in timing mode, this function checks to see if enough time
// has elapsed since the last user input, and if so, plays the next movie
// that it's supposed to.
//=============================================================================
void HandleTimingMode(void)
{
	if (g_bTimingMode && g_pDemos)
	{
		// is it time to play a movie?
		if (timeGetTime() >= g_dwVideoTime)
		{
			while (true)
			{
				int iDemo=g_iNextVideo;
				g_iNextVideo++;

				if (g_iNextVideo >= g_pXDIHeader->m_lNumDemos)
					g_iNextVideo = 0;

				// make sure we found a movie
				if (g_pDemos[iDemo].m_pDib->m_dwFlags & DIBFLAGS_KIOSK)
				{
					if (ExecuteDemo(g_pDemos[iDemo], true))
					{
						g_dwVideoTime = timeGetTime() + VIDEO_DELAY;
						return;
					}

					// reset the timer
					Input();
				}

				if (g_iNextVideo==0)
					break;
			}

			g_dwVideoTime = timeGetTime() + VIDEO_DELAY;
		}
	}
}

//=============================================================================
//=============================================================================
HRESULT InitBackgroundMovie(void)
{
	g_hBkgndMovie = BinkOpen(FindPath(g_pszBackgroundMovie), 0);
	if (!g_hBkgndMovie)
		return S_OK;
	
	g_pd3dDevice->CreateTexture(g_hBkgndMovie->Width, g_hBkgndMovie->Height, 1, 0, D3DFMT_LIN_X8R8G8B8, 0, &g_pBkgndTexture);

	return S_OK;

}

//=============================================================================
//=============================================================================
void UpdateBackgroundMovie(void)
{
	static bool bFirst=true;

	if (bFirst)
	{
		bFirst=false;
		return;
	}

	if (g_hBkgndMovie)
	{
		if (BinkWait(g_hBkgndMovie))
		{
			// we don't need a new frame yet
		}
		else
		{
			// we need a new frame!!
			BinkDoFrame(g_hBkgndMovie);

			D3DLOCKED_RECT lr;

			if (true)
			{
				g_pBkgndTexture->LockRect(0, &lr, NULL, 0);
				BinkCopyToBuffer(g_hBkgndMovie, lr.pBits, lr.Pitch, g_hBkgndMovie->Height, 0, 0, BINKCOPYALL | BINKSURFACE32);
				g_pBkgndTexture->UnlockRect(0);
			}

			if (g_hBkgndMovie->FrameNum == (g_hBkgndMovie->Frames-1))
			{
				BinkGoto(g_hBkgndMovie, 1, 0);
			}
			else
				BinkNextFrame(g_hBkgndMovie);  // skip to the next frame
		}

		// Blt the image

		static struct {
			float	x,y,z,w;
			float	u,v;
		} vertices[4] = {
			{ 0,0,0,1,0,0 },
			{ 0,0,0,1,0,0 },
			{ 0,0,0,1,0,0 },
			{ 0,0,0,1,0,0 },
		};

		if (true)
		{
			if (true)
			{
				vertices[0].x	= 0.0f;
				vertices[0].y	= 0.0f;

				vertices[1].x	= WIDTH;
				vertices[1].y	= 0.0f;

				vertices[2].x	= 0.0f;
				vertices[2].y	= HEIGHT;

				vertices[3].x	= WIDTH;
				vertices[3].y	= HEIGHT;
			}

			if (true)
			{
				vertices[0].u	= -.5f + 0.0f;
				vertices[0].v	= -.5f + 0.0f;

				vertices[1].u	= -.5f + (float)g_hBkgndMovie->Width-10;
				vertices[1].v	= -.5f + 0.0f;

				vertices[2].u	= -.5f + 0.0f;
				vertices[2].v	= -.5f + (float)g_hBkgndMovie->Height-10;

				vertices[3].u	= -.5f + (float)g_hBkgndMovie->Width-10;
				vertices[3].v	= -.5f + (float)g_hBkgndMovie->Height-10;
			}
		}

		g_pd3dDevice->SetTexture(0, g_pBkgndTexture);
		g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_TEX1);
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, vertices, sizeof(vertices[0]));
	}
}

//=============================================================================
//=============================================================================
LONG XDemosUnhandledExceptionFilter(LPEXCEPTION_POINTERS*)
{
	XLaunchNewImage("d:\\default.xbe", NULL);
	return 0;
}

//=============================================================================
// main()
//
// The main function that runs the program
//=============================================================================
void __cdecl main()
{
#ifdef _DEBUG
//	__asm int 3;
#endif

#ifdef PROFILE
	DmEnableGPUCounter(TRUE);
#endif

	// various initialization
    if (FAILED(InitD3D()))
        return;

	if (FAILED(InitXDI()))
		return;

	if (FAILED(InitBackground()))
		return;

	if (FAILED(InitInput()))
		return;

	if (FAILED(InitAudio()))
		return;

	if (FAILED(InitBackgroundMovie()))
		return;

	SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)XDemosUnhandledExceptionFilter);
#ifdef WMV
	TextureBufferQueue::InitializeD3D();
#endif

	// default 64K cache size is too low, set to 1MB
	XSetFileCacheSize(1024*1024);

	// get the state of the listbox (i.e., the last choice the user made
	GetState(g_iListChoice, g_iListOffset, g_iNextVideo);

	// error checking (this should never be necessary, as the XDI file
	// can't change on the DVD!
	if (g_iListChoice >= g_pXDIHeader->m_lNumDemos)
	{
		g_iListChoice = 0;
		g_iListOffset = 0;
	}

	// create the fonts that we will use
	g_pFontN = new CXBFont;
	g_pFontN->Create(g_pd3dDevice, FindPath(g_pszFontN));
	g_pFontB = new CXBFont;
	g_pFontB->Create(g_pd3dDevice, FindPath(g_pszFontB));

	// the main loop
    while (true)
    {
		HandleTimingMode();

		UpdateAudio();
		HandleInput();
        Render();
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\XImage.h ===
//=============================================================================
// File: XImage.h
//
// Desc: 
// Created: 07/12/2001 by Michael Lyons (mlyons@microsoft.com)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================

#pragma once


//=============================================================================
// include files
//=============================================================================
#include <xtl.h>
#include <assert.h>

//=============================================================================
//=============================================================================
typedef struct tagXIMAGEVERTEX
{
    float x,y,z,w;
    float u,v;
} XIMAGEVERTEX;

#define D3DFVF_XIMAGEVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)

//=============================================================================
//=============================================================================
class XImage
{
public:
	XImage();

	IDirect3DTexture8 *		m_pTexture;
	IDirect3DDevice8 *		m_pDevice;
	int						m_iWidth;
	int						m_iHeight;

	bool					Load(IDirect3DDevice8 *pDevice, char *szFileName);
	bool					Blt(RECT *r=NULL);
	bool					Blt(int x, int y);
	bool					Blt(int x, int y, int w, int h);
	bool					FillArea(int x, int y, int w, int h, DWORD color);
	bool					Free(void);

	static XIMAGEVERTEX		m_ScreenVertices[4];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\png.h ===
/* png.h - header file for PNG reference library
 *
 * libpng version 1.0.11 - April 27, 2001
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * Authors and maintainers:
 *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
 *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
 *  libpng versions 0.97, January 1998, through 1.0.11 - April 27, 2001: Glenn
 *  See also "Contributing Authors", below.
 *
 * Note about libpng version numbers:
 *
 *    Due to various miscommunications, unforeseen code incompatibilities
 *    and occasional factors outside the authors' control, version numbering
 *    on the library has not always been consistent and straightforward.
 *    The following table summarizes matters since version 0.89c, which was
 *    the first widely used release:
 *
 *    source                 png.h  png.h  shared-lib
 *    version                string   int  version
 *    -------                ------ -----  ----------
 *    0.89c "1.0 beta 3"     0.89      89  1.0.89
 *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
 *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
 *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
 *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
 *    0.97c                  0.97      97  2.0.97
 *    0.98                   0.98      98  2.0.98
 *    0.99                   0.99      98  2.0.99
 *    0.99a-m                0.99      99  2.0.99
 *    1.00                   1.00     100  2.1.0 [100 should be 10000]
 *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
 *    1.0.1       png.h string is   10001  2.1.0
 *    1.0.1a-e    identical to the  10002  from here on, the shared library
 *    1.0.2       source version)   10002  is 2.V where V is the source code
 *    1.0.2a-b                      10003  version, except as noted.
 *    1.0.3                         10003
 *    1.0.3a-d                      10004
 *    1.0.4                         10004
 *    1.0.4a-f                      10005
 *    1.0.5 (+ 2 patches)           10005
 *    1.0.5a-d                      10006
 *    1.0.5e-r                      10100 (not source compatible)
 *    1.0.5s-v                      10006 (not binary compatible)
 *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
 *    1.0.6d-f                      10007 (still binary incompatible)
 *    1.0.6g                        10007
 *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
 *    1.0.6i                        10007  10.6i
 *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
 *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
 *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
 *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
 *    1.0.7                    1    10007  (still compatible)
 *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4
 *    1.0.8rc1                 1    10008  2.1.0.8rc1
 *    1.0.8                    1    10008  2.1.0.8
 *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6
 *    1.0.9rc1                 1    10009  2.1.0.9rc1
 *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10
 *    1.0.9rc2                 1    10009  2.1.0.9rc2
 *    1.0.9                    1    10009  2.1.0.9
 *    1.0.10beta1              1    10010  2.1.0.10beta1
 *    1.0.10rc1                1    10010  2.1.0.10rc1
 *    1.0.10                   1    10010  2.1.0.10
 *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3
 *    1.0.11rc1                1    10011  2.1.0.11rc1
 *    1.0.11                   1    10011  2.1.0.11
 *
 *    Henceforth the source version will match the shared-library major
 *    and minor numbers; the shared-library major version number will be
 *    used for changes in backward compatibility, as it is intended.  The
 *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
 *    for applications, is an unsigned integer of the form xyyzz corresponding
 *    to the source version x.y.z (leading zeros in y and z).  Beta versions
 *    were given the previous public release number plus a letter, until
 *    version 1.0.6j; from then on they were given the upcoming public
 *    release number plus "betaNN" or "rcN".
 *
 *    Binary incompatibility exists only when applications make direct access
 *    to the info_ptr or png_ptr members through png.h, and the compiled
 *    application is loaded with a different version of the library.
 *
 *    DLLNUM will change each time there are forward or backward changes
 *    in binary compatibility (e.g., when a new feature is added).
 *
 * See libpng.txt or libpng.3 for more information.  The PNG specification
 * is available as RFC 2083 <ftp://ftp.uu.net/graphics/png/documents/>
 * and as a W3C Recommendation <http://www.w3.org/TR/REC.png.html>
 */

/*
 * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
 *
 * If you modify libpng you may insert additional notices immediately following
 * this sentence.
 *
 * libpng versions 1.0.7, July 1, 2000, through  1.0.11, April 27, 2001, are
 * Copyright (c) 2000, 2001 Glenn Randers-Pehrson, and are
 * distributed according to the same disclaimer and license as libpng-1.0.6
 * with the following individuals added to the list of Contributing Authors
 *
 *    Simon-Pierre Cadieux
 *    Eric S. Raymond
 *    Gilles Vollant
 *
 * and with the following additions to the disclaimer:
 *
 *    There is no warranty against interference with your enjoyment of the
 *    library or against infringement.  There is no warranty that our
 *    efforts or the library will fulfill any of your particular purposes
 *    or needs.  This library is provided with all faults, and the entire
 *    risk of satisfactory quality, performance, accuracy, and effort is with
 *    the user.
 *
 * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
 * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson
 * Distributed according to the same disclaimer and license as libpng-0.96,
 * with the following individuals added to the list of Contributing Authors:
 *
 *    Tom Lane
 *    Glenn Randers-Pehrson
 *    Willem van Schaik
 *
 * libpng versions 0.89, June 1996, through 0.96, May 1997, are
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Distributed according to the same disclaimer and license as libpng-0.88,
 * with the following individuals added to the list of Contributing Authors:
 *
 *    John Bowler
 *    Kevin Bracey
 *    Sam Bushell
 *    Magnus Holmgren
 *    Greg Roelofs
 *    Tom Tanner
 *
 * libpng versions 0.5, May 1995, through 0.88, January 1996, are
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * For the purposes of this copyright and license, "Contributing Authors"
 * is defined as the following set of individuals:
 *
 *    Andreas Dilger
 *    Dave Martindale
 *    Guy Eric Schalnat
 *    Paul Schmidt
 *    Tim Wegner
 *
 * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
 * and Group 42, Inc. disclaim all warranties, expressed or implied,
 * including, without limitation, the warranties of merchantability and of
 * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
 * assume no liability for direct, indirect, incidental, special, exemplary,
 * or consequential damages, which may result from the use of the PNG
 * Reference Library, even if advised of the possibility of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute this
 * source code, or portions hereof, for any purpose, without fee, subject
 * to the following restrictions:
 *
 * 1. The origin of this source code must not be misrepresented.
 *
 * 2. Altered versions must be plainly marked as such and
 * must not be misrepresented as being the original source.
 *
 * 3. This Copyright notice may not be removed or altered from
 *    any source or altered source distribution.
 *
 * The Contributing Authors and Group 42, Inc. specifically permit, without
 * fee, and encourage the use of this source code as a component to
 * supporting the PNG file format in commercial products.  If you use this
 * source code in a product, acknowledgment is not required but would be
 * appreciated.
 */

/*
 * A "png_get_copyright" function is available, for convenient use in "about"
 * boxes and the like:
 *
 * printf("%s",png_get_copyright(NULL));
 *
 * Also, the PNG logo (in PNG format, of course) is supplied in the
 * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 */

/*
 * Libpng is OSI Certified Open Source Software.  OSI Certified is a
 * certification mark of the Open Source Initiative.
 */

/*
 * The contributing authors would like to thank all those who helped
 * with testing, bug fixes, and patience.  This wouldn't have been
 * possible without all of you.
 *
 * Thanks to Frank J. T. Wojcik for helping with the documentation.
 */

/*
 * Y2K compliance in libpng:
 * =========================
 *
 *    April 27, 2001
 *
 *    Since the PNG Development group is an ad-hoc body, we can't make
 *    an official declaration.
 *
 *    This is your unofficial assurance that libpng from version 0.71 and
 *    upward through 1.0.11 are Y2K compliant.  It is my belief that earlier
 *    versions were also Y2K compliant.
 *
 *    Libpng only has three year fields.  One is a 2-byte unsigned integer
 *    that will hold years up to 65535.  The other two hold the date in text
 *    format, and will hold years up to 9999.
 *
 *    The integer is
 *        "png_uint_16 year" in png_time_struct.
 *
 *    The strings are
 *        "png_charp time_buffer" in png_struct and
 *        "near_time_buffer", which is a local character string in png.c.
 *
 *    There are seven time-related functions:
 *        png.c: png_convert_to_rfc_1123() in png.c
 *          (formerly png_convert_to_rfc_1152() in error)
 *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
 *        png_convert_from_time_t() in pngwrite.c
 *        png_get_tIME() in pngget.c
 *        png_handle_tIME() in pngrutil.c, called in pngread.c
 *        png_set_tIME() in pngset.c
 *        png_write_tIME() in pngwutil.c, called in pngwrite.c
 *
 *    All handle dates properly in a Y2K environment.  The
 *    png_convert_from_time_t() function calls gmtime() to convert from system
 *    clock time, which returns (year - 1900), which we properly convert to
 *    the full 4-digit year.  There is a possibility that applications using
 *    libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
 *    function, or that they are incorrectly passing only a 2-digit year
 *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
 *    but this is not under our control.  The libpng documentation has always
 *    stated that it works with 4-digit years, and the APIs have been
 *    documented as such.
 *
 *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
 *    integer to hold the year, and can hold years as large as 65535.
 *
 *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
 *    no date-related code.
 *
 *       Glenn Randers-Pehrson
 *       libpng maintainer
 *       PNG Development Group
 */

#ifndef PNG_H
#define PNG_H

/* This is not the place to learn how to use libpng.  The file libpng.txt
 * describes how to use libpng, and the file example.c summarizes it
 * with some code on which to build.  This file is useful for looking
 * at the actual function definitions and structure components.
 */

/* Version information for png.h - this should match the version in png.c */
#define PNG_LIBPNG_VER_STRING "1.0.11"

#define PNG_LIBPNG_VER_SONUM   2
#define PNG_LIBPNG_VER_DLLNUM  %DLLNUM%

/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
#define PNG_LIBPNG_VER_MAJOR   1
#define PNG_LIBPNG_VER_MINOR   0
#define PNG_LIBPNG_VER_RELEASE 11
/* This should match the numeric part of the final component of
 * PNG_LIBPNG_VER_STRING, omitting any leading zero: */

#define PNG_LIBPNG_VER_BUILD  0

#define PNG_LIBPNG_BUILD_ALPHA    1
#define PNG_LIBPNG_BUILD_BETA     2
#define PNG_LIBPNG_BUILD_RC       3
#define PNG_LIBPNG_BUILD_STABLE   4
#define PNG_LIBPNG_BUILD_TYPEMASK 7
#define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with STABLE only */
#define PNG_LIBPNG_BUILD_TYPE 4

/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
 * We must not include leading zeros.
 * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
 * version 1.0.0 was mis-numbered 100 instead of 10000).  From
 * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release */
#define PNG_LIBPNG_VER 10011 /* 1.0.11 */

#ifndef PNG_VERSION_INFO_ONLY

/* include the compression library's header */
#include "zlib.h"

/* include all user configurable info, including optional assembler routines */
#include "pngconf.h"

/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* This file is arranged in several sections.  The first section contains
 * structure and type definitions.  The second section contains the external
 * library functions, while the third has the internal library functions,
 * which applications aren't expected to use directly.
 */

/* variables declared in png.c - only it needs to define PNG_NO_EXTERN */
#if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
/* Version information for C files, stored in png.c.  This had better match
 * the version above.
 */
#ifdef PNG_USE_GLOBAL_ARRAYS
PNG_EXPORT_VAR (const char) png_libpng_ver[18];
  /* need room for 99.99.99beta99z*/
#else
#define png_libpng_ver png_get_header_ver(NULL)
#endif

#ifdef PNG_USE_GLOBAL_ARRAYS
/* This was removed in version 1.0.5c */
/* Structures to facilitate easy interlacing.  See png.c for more details */
PNG_EXPORT_VAR (const int FARDATA) png_pass_start[7];
PNG_EXPORT_VAR (const int FARDATA) png_pass_inc[7];
PNG_EXPORT_VAR (const int FARDATA) png_pass_ystart[7];
PNG_EXPORT_VAR (const int FARDATA) png_pass_yinc[7];
PNG_EXPORT_VAR (const int FARDATA) png_pass_mask[7];
PNG_EXPORT_VAR (const int FARDATA) png_pass_dsp_mask[7];
#ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
PNG_EXPORT_VAR (const int FARDATA) png_pass_width[7];
#endif
/* This isn't currently used.  If you need it, see png.c for more details.
PNG_EXPORT_VAR (const int FARDATA) png_pass_height[7];
*/
#endif

#endif /* PNG_NO_EXTERN */

/* Three color definitions.  The order of the red, green, and blue, (and the
 * exact size) is not important, although the size of the fields need to
 * be png_byte or png_uint_16 (as defined below).
 */
typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color FAR * png_colorp;
typedef png_color FAR * FAR * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;    /* used for palette files */
   png_uint_16 red;   /* for use in red green blue files */
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;  /* for use in grayscale files */
} png_color_16;
typedef png_color_16 FAR * png_color_16p;
typedef png_color_16 FAR * FAR * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;   /* for use in red green blue files */
   png_byte green;
   png_byte blue;
   png_byte gray;  /* for use in grayscale files */
   png_byte alpha; /* for alpha channel files */
} png_color_8;
typedef png_color_8 FAR * png_color_8p;
typedef png_color_8 FAR * FAR * png_color_8pp;

/*
 * The following two structures are used for the in-core representation
 * of sPLT chunks.
 */
typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry FAR * png_sPLT_entryp;
typedef png_sPLT_entry FAR * FAR * png_sPLT_entrypp;

/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
 *  occupy the LSB of their respective members, and the MSB of each member
 *  is zero-filled.  The frequency member always occupies the full 16 bits.
 */

typedef struct png_sPLT_struct
{
   png_charp name;           /* palette name */
   png_byte depth;           /* depth of palette samples */
   png_sPLT_entryp entries;  /* palette entries */
   png_int_32 nentries;      /* number of palette entries */
} png_sPLT_t;
typedef png_sPLT_t FAR * png_sPLT_tp;
typedef png_sPLT_t FAR * FAR * png_sPLT_tpp;

#ifdef PNG_TEXT_SUPPORTED
/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
 * and whether that contents is compressed or not.  The "key" field
 * points to a regular zero-terminated C string.  The "text", "lang", and
 * "lang_key" fields can be regular C strings, empty strings, or NULL pointers.
 * However, the * structure returned by png_get_text() will always contain
 * regular zero-terminated C strings (possibly empty), never NULL pointers,
 * so they can be safely used in printf() and other string-handling functions.
 */
typedef struct png_text_struct
{
   int  compression;       /* compression value:
                             -1: tEXt, none
                              0: zTXt, deflate
                              1: iTXt, none
                              2: iTXt, deflate  */
   png_charp key;          /* keyword, 1-79 character description of "text" */
   png_charp text;         /* comment, may be an empty string (ie "")
                              or a NULL pointer */
   png_size_t text_length; /* length of the text string */
#ifdef PNG_iTXt_SUPPORTED
   png_size_t itxt_length; /* length of the itxt string */
   png_charp lang;         /* language code, 0-79 characters
                              or a NULL pointer */
   png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
                              chars or a NULL pointer */
#endif
} png_text;
typedef png_text FAR * png_textp;
typedef png_text FAR * FAR * png_textpp;
#endif

/* Supported compression types for text in PNG files (tEXt, and zTXt).
 * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
#define PNG_TEXT_COMPRESSION_NONE_WR -3
#define PNG_TEXT_COMPRESSION_zTXt_WR -2
#define PNG_TEXT_COMPRESSION_NONE    -1
#define PNG_TEXT_COMPRESSION_zTXt     0
#define PNG_ITXT_COMPRESSION_NONE     1
#define PNG_ITXT_COMPRESSION_zTXt     2
#define PNG_TEXT_COMPRESSION_LAST     3  /* Not a valid value */

/* png_time is a way to hold the time in an machine independent way.
 * Two conversions are provided, both from time_t and struct tm.  There
 * is no portable way to convert to either of these structures, as far
 * as I know.  If you know of a portable way, send it to me.  As a side
 * note - PNG has always been Year 2000 compliant!
 */
typedef struct png_time_struct
{
   png_uint_16 year; /* full year, as in, 1995 */
   png_byte month;   /* month of year, 1 - 12 */
   png_byte day;     /* day of month, 1 - 31 */
   png_byte hour;    /* hour of day, 0 - 23 */
   png_byte minute;  /* minute of hour, 0 - 59 */
   png_byte second;  /* second of minute, 0 - 60 (for leap seconds) */
} png_time;
typedef png_time FAR * png_timep;
typedef png_time FAR * FAR * png_timepp;

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
/* png_unknown_chunk is a structure to hold queued chunks for which there is
 * no specific support.  The idea is that we can use this to queue
 * up private chunks for output even though the library doesn't actually
 * know about their semantics.
 */
typedef struct png_unknown_chunk_t
{
    png_byte name[5];
    png_byte *data;
    png_size_t size;

    /* libpng-using applications should NOT directly modify this byte. */
    png_byte location; /* mode of operation at read time */
}
png_unknown_chunk;
typedef png_unknown_chunk FAR * png_unknown_chunkp;
typedef png_unknown_chunk FAR * FAR * png_unknown_chunkpp;
#endif

/* png_info is a structure that holds the information in a PNG file so
 * that the application can find out the characteristics of the image.
 * If you are reading the file, this structure will tell you what is
 * in the PNG file.  If you are writing the file, fill in the information
 * you want to put into the PNG file, then call png_write_info().
 * The names chosen should be very close to the PNG specification, so
 * consult that document for information about the meaning of each field.
 *
 * With libpng < 0.95, it was only possible to directly set and read the
 * the values in the png_info_struct, which meant that the contents and
 * order of the values had to remain fixed.  With libpng 0.95 and later,
 * however, there are now functions that abstract the contents of
 * png_info_struct from the application, so this makes it easier to use
 * libpng with dynamic libraries, and even makes it possible to use
 * libraries that don't have all of the libpng ancillary chunk-handing
 * functionality.
 *
 * In any case, the order of the parameters in png_info_struct should NOT
 * be changed for as long as possible to keep compatibility with applications
 * that use the old direct-access method with png_info_struct.
 *
 * The following members may have allocated storage attached that should be
 * cleaned up before the structure is discarded: palette, trans, text,
 * pcal_purpose, pcal_units, pcal_params, hist, iccp_name, iccp_profile,
 * splt_palettes, scal_unit, row_pointers, and unknowns.   By default, these
 * are automatically freed when the info structure is deallocated, if they were
 * allocated internally by libpng.  This behavior can be changed by means
 * of the png_data_freer() function.
 *
 * More allocation details: all the chunk-reading functions that
 * change these members go through the corresponding png_set_*
 * functions.  A function to clear these members is available: see
 * png_free_data().  The png_set_* functions do not depend on being
 * able to point info structure members to any of the storage they are
 * passed (they make their own copies), EXCEPT that the png_set_text
 * functions use the same storage passed to them in the text_ptr or
 * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns
 * functions do not make their own copies.
 */
typedef struct png_info_struct
{
   /* the following are necessary for every PNG file */
   png_uint_32 width;       /* width of image in pixels (from IHDR) */
   png_uint_32 height;      /* height of image in pixels (from IHDR) */
   png_uint_32 valid;       /* valid chunk data (see PNG_INFO_ below) */
   png_uint_32 rowbytes;    /* bytes needed to hold an untransformed row */
   png_colorp palette;      /* array of color values (valid & PNG_INFO_PLTE) */
   png_uint_16 num_palette; /* number of color entries in "palette" (PLTE) */
   png_uint_16 num_trans;   /* number of transparent palette color (tRNS) */
   png_byte bit_depth;      /* 1, 2, 4, 8, or 16 bits/channel (from IHDR) */
   png_byte color_type;     /* see PNG_COLOR_TYPE_ below (from IHDR) */
   /* The following three should have been named *_method not *_type */
   png_byte compression_type; /* must be PNG_COMPRESSION_TYPE_BASE (IHDR) */
   png_byte filter_type;    /* must be PNG_FILTER_TYPE_BASE (from IHDR) */
   png_byte interlace_type; /* One of PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */

   /* The following is informational only on read, and not used on writes. */
   png_byte channels;       /* number of data channels per pixel (1, 2, 3, 4)*/
   png_byte pixel_depth;    /* number of bits per pixel */
   png_byte spare_byte;     /* to align the data, and for future use */
   png_byte signature[8];   /* magic bytes read by libpng from start of file */

   /* The rest of the data is optional.  If you are reading, check the
    * valid field to see if the information in these are valid.  If you
    * are writing, set the valid field to those chunks you want written,
    * and initialize the appropriate fields below.
    */

#if defined(PNG_gAMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
   /* The gAMA chunk describes the gamma characteristics of the system
    * on which the image was created, normally in the range [1.0, 2.5].
    * Data is valid if (valid & PNG_INFO_gAMA) is non-zero.
    */
   float gamma; /* gamma value of image, if (valid & PNG_INFO_gAMA) */
#endif

#if defined(PNG_sRGB_SUPPORTED)
    /* GR-P, 0.96a */
    /* Data valid if (valid & PNG_INFO_sRGB) non-zero. */
   png_byte srgb_intent; /* sRGB rendering intent [0, 1, 2, or 3] */
#endif

#if defined(PNG_TEXT_SUPPORTED)
   /* The tEXt, and zTXt chunks contain human-readable textual data in
    * uncompressed, compressed, and optionally compressed forms, respectively.
    * The data in "text" is an array of pointers to uncompressed,
    * null-terminated C strings. Each chunk has a keyword that describes the
    * textual data contained in that chunk.  Keywords are not required to be
    * unique, and the text string may be empty.  Any number of text chunks may
    * be in an image.
    */
   int num_text; /* number of comments read/to write */
   int max_text; /* current size of text array */
   png_textp text; /* array of comments read/to write */
#endif /* PNG_TEXT_SUPPORTED */

#if defined(PNG_tIME_SUPPORTED)
   /* The tIME chunk holds the last time the displayed image data was
    * modified.  See the png_time struct for the contents of this struct.
    */
   png_time mod_time;
#endif

#if defined(PNG_sBIT_SUPPORTED)
   /* The sBIT chunk specifies the number of significant high-order bits
    * in the pixel data.  Values are in the range [1, bit_depth], and are
    * only specified for the channels in the pixel data.  The contents of
    * the low-order bits is not specified.  Data is valid if
    * (valid & PNG_INFO_sBIT) is non-zero.
    */
   png_color_8 sig_bit; /* significant bits in color channels */
#endif

#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_EXPAND_SUPPORTED) || \
defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* The tRNS chunk supplies transparency data for paletted images and
    * other image types that don't need a full alpha channel.  There are
    * "num_trans" transparency values for a paletted image, stored in the
    * same order as the palette colors, starting from index 0.  Values
    * for the data are in the range [0, 255], ranging from fully transparent
    * to fully opaque, respectively.  For non-paletted images, there is a
    * single color specified that should be treated as fully transparent.
    * Data is valid if (valid & PNG_INFO_tRNS) is non-zero.
    */
   png_bytep trans; /* transparent values for paletted image */
   png_color_16 trans_values; /* transparent color for non-palette image */
#endif

#if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* The bKGD chunk gives the suggested image background color if the
    * display program does not have its own background color and the image
    * is needs to composited onto a background before display.  The colors
    * in "background" are normally in the same color space/depth as the
    * pixel data.  Data is valid if (valid & PNG_INFO_bKGD) is non-zero.
    */
   png_color_16 background;
#endif

#if defined(PNG_oFFs_SUPPORTED)
   /* The oFFs chunk gives the offset in "offset_unit_type" units rightwards
    * and downwards from the top-left corner of the display, page, or other
    * application-specific co-ordinate space.  See the PNG_OFFSET_ defines
    * below for the unit types.  Valid if (valid & PNG_INFO_oFFs) non-zero.
    */
   png_int_32 x_offset; /* x offset on page */
   png_int_32 y_offset; /* y offset on page */
   png_byte offset_unit_type; /* offset units type */
#endif

#if defined(PNG_pHYs_SUPPORTED)
   /* The pHYs chunk gives the physical pixel density of the image for
    * display or printing in "phys_unit_type" units (see PNG_RESOLUTION_
    * defines below).  Data is valid if (valid & PNG_INFO_pHYs) is non-zero.
    */
   png_uint_32 x_pixels_per_unit; /* horizontal pixel density */
   png_uint_32 y_pixels_per_unit; /* vertical pixel density */
   png_byte phys_unit_type; /* resolution type (see PNG_RESOLUTION_ below) */
#endif

#if defined(PNG_hIST_SUPPORTED)
   /* The hIST chunk contains the relative frequency or importance of the
    * various palette entries, so that a viewer can intelligently select a
    * reduced-color palette, if required.  Data is an array of "num_palette"
    * values in the range [0,65535]. Data valid if (valid & PNG_INFO_hIST)
    * is non-zero.
    */
   png_uint_16p hist;
#endif

#ifdef PNG_cHRM_SUPPORTED
   /* The cHRM chunk describes the CIE color characteristics of the monitor
    * on which the PNG was created.  This data allows the viewer to do gamut
    * mapping of the input image to ensure that the viewer sees the same
    * colors in the image as the creator.  Values are in the range
    * [0.0, 0.8].  Data valid if (valid & PNG_INFO_cHRM) non-zero.
    */
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float x_white;
   float y_white;
   float x_red;
   float y_red;
   float x_green;
   float y_green;
   float x_blue;
   float y_blue;
#endif
#endif

#if defined(PNG_pCAL_SUPPORTED)
   /* The pCAL chunk describes a transformation between the stored pixel
    * values and original physical data values used to create the image.
    * The integer range [0, 2^bit_depth - 1] maps to the floating-point
    * range given by [pcal_X0, pcal_X1], and are further transformed by a
    * (possibly non-linear) transformation function given by "pcal_type"
    * and "pcal_params" into "pcal_units".  Please see the PNG_EQUATION_
    * defines below, and the PNG-Group's PNG extensions document for a
    * complete description of the transformations and how they should be
    * implemented, and for a description of the ASCII parameter strings.
    * Data values are valid if (valid & PNG_INFO_pCAL) non-zero.
    */
   png_charp pcal_purpose;  /* pCAL chunk description string */
   png_int_32 pcal_X0;      /* minimum value */
   png_int_32 pcal_X1;      /* maximum value */
   png_charp pcal_units;    /* Latin-1 string giving physical units */
   png_charpp pcal_params;  /* ASCII strings containing parameter values */
   png_byte pcal_type;      /* equation type (see PNG_EQUATION_ below) */
   png_byte pcal_nparams;   /* number of parameters given in pcal_params */
#endif

#ifdef PNG_FREE_ME_SUPPORTED
   png_uint_32 free_me;     /* flags items libpng is responsible for freeing */
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
   /* storage for unknown chunks that the library doesn't recognize. */
   png_unknown_chunkp unknown_chunks;
   png_size_t unknown_chunks_num;
#endif

#if defined(PNG_iCCP_SUPPORTED)
   /* iCCP chunk data. */
   png_charp iccp_name;     /* profile name */
   png_charp iccp_profile;  /* International Color Consortium profile data */
                            /* Note to maintainer: should be png_bytep */
   png_uint_32 iccp_proflen;  /* ICC profile data length */
   png_byte iccp_compression; /* Always zero */
#endif

#if defined(PNG_sPLT_SUPPORTED)
   /* data on sPLT chunks (there may be more than one). */
   png_sPLT_tp splt_palettes;
   png_uint_32 splt_palettes_num;
#endif

#if defined(PNG_sCAL_SUPPORTED)
   /* The sCAL chunk describes the actual physical dimensions of the
    * subject matter of the graphic.  The chunk contains a unit specification
    * a byte value, and two ASCII strings representing floating-point
    * values.  The values are width and height corresponsing to one pixel
    * in the image.  This external representation is converted to double
    * here.  Data values are valid if (valid & PNG_INFO_sCAL) is non-zero.
    */
   png_byte scal_unit;         /* unit of physical scale */
#ifdef PNG_FLOATING_POINT_SUPPORTED
   double scal_pixel_width;    /* width of one pixel */
   double scal_pixel_height;   /* height of one pixel */
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_charp scal_s_width;     /* string containing height */
   png_charp scal_s_height;    /* string containing width */
#endif
#endif

#if defined(PNG_INFO_IMAGE_SUPPORTED)
   /* Memory has been allocated if (valid & PNG_ALLOCATED_INFO_ROWS) non-zero */
   /* Data valid if (valid & PNG_INFO_IDAT) non-zero */
   png_bytepp row_pointers;        /* the image bits */
#endif

#if defined(PNG_FIXED_POINT_SUPPORTED) && defined(PNG_gAMA_SUPPORTED)
   png_fixed_point int_gamma; /* gamma of image, if (valid & PNG_INFO_gAMA) */
#endif

#if defined(PNG_cHRM_SUPPORTED) && defined(PNG_FIXED_POINT_SUPPORTED)
   png_fixed_point int_x_white;
   png_fixed_point int_y_white;
   png_fixed_point int_x_red;
   png_fixed_point int_y_red;
   png_fixed_point int_x_green;
   png_fixed_point int_y_green;
   png_fixed_point int_x_blue;
   png_fixed_point int_y_blue;
#endif

} png_info;

typedef png_info FAR * png_infop;
typedef png_info FAR * FAR * png_infopp;

/* Maximum positive integer used in PNG is (2^31)-1 */
#define PNG_MAX_UINT ((png_uint_32)0x7fffffffL)

/* These describe the color_type field in png_info. */
/* color type masks */
#define PNG_COLOR_MASK_PALETTE    1
#define PNG_COLOR_MASK_COLOR      2
#define PNG_COLOR_MASK_ALPHA      4

/* color types.  Note that not all combinations are legal */
#define PNG_COLOR_TYPE_GRAY 0
#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
/* aliases */
#define PNG_COLOR_TYPE_RGBA  PNG_COLOR_TYPE_RGB_ALPHA
#define PNG_COLOR_TYPE_GA  PNG_COLOR_TYPE_GRAY_ALPHA

/* This is for compression type. PNG 1.0-1.2 only define the single type. */
#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
#define PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE

/* This is for filter type. PNG 1.0-1.2 only define the single type. */
#define PNG_FILTER_TYPE_BASE      0 /* Single row per-byte filtering */
#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
#define PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE

/* These are for the interlacing type.  These values should NOT be changed. */
#define PNG_INTERLACE_NONE        0 /* Non-interlaced image */
#define PNG_INTERLACE_ADAM7       1 /* Adam7 interlacing */
#define PNG_INTERLACE_LAST        2 /* Not a valid value */

/* These are for the oFFs chunk.  These values should NOT be changed. */
#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
#define PNG_OFFSET_MICROMETER     1 /* Offset in micrometers (1/10^6 meter) */
#define PNG_OFFSET_LAST           2 /* Not a valid value */

/* These are for the pCAL chunk.  These values should NOT be changed. */
#define PNG_EQUATION_LINEAR       0 /* Linear transformation */
#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
#define PNG_EQUATION_HYPERBOLIC   3 /* Hyperbolic sine transformation */
#define PNG_EQUATION_LAST         4 /* Not a valid value */

/* These are for the sCAL chunk.  These values should NOT be changed. */
#define PNG_SCALE_UNKNOWN         0 /* unknown unit (image scale) */
#define PNG_SCALE_METER           1 /* meters per pixel */
#define PNG_SCALE_RADIAN          2 /* radians per pixel */
#define PNG_SCALE_LAST            3 /* Not a valid value */

/* These are for the pHYs chunk.  These values should NOT be changed. */
#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
#define PNG_RESOLUTION_METER      1 /* pixels/meter */
#define PNG_RESOLUTION_LAST       2 /* Not a valid value */

/* These are for the sRGB chunk.  These values should NOT be changed. */
#define PNG_sRGB_INTENT_PERCEPTUAL 0
#define PNG_sRGB_INTENT_RELATIVE   1
#define PNG_sRGB_INTENT_SATURATION 2
#define PNG_sRGB_INTENT_ABSOLUTE   3
#define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */

/* This is for text chunks */
#define PNG_KEYWORD_MAX_LENGTH     79

/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
#define PNG_MAX_PALETTE_LENGTH	   256

/* These determine if an ancillary chunk's data has been successfully read
 * from the PNG header, or if the application has filled in the corresponding
 * data in the info_struct to be written into the output file.  The values
 * of the PNG_INFO_<chunk> defines should NOT be changed.
 */
#define PNG_INFO_gAMA 0x0001
#define PNG_INFO_sBIT 0x0002
#define PNG_INFO_cHRM 0x0004
#define PNG_INFO_PLTE 0x0008
#define PNG_INFO_tRNS 0x0010
#define PNG_INFO_bKGD 0x0020
#define PNG_INFO_hIST 0x0040
#define PNG_INFO_pHYs 0x0080
#define PNG_INFO_oFFs 0x0100
#define PNG_INFO_tIME 0x0200
#define PNG_INFO_pCAL 0x0400
#define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
#define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
#define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
#define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
#define PNG_INFO_IDAT 0x8000L  /* ESR, 1.0.6 */

/* This is used for the transformation routines, as some of them
 * change these values for the row.  It also should enable using
 * the routines for other purposes.
 */
typedef struct png_row_info_struct
{
   png_uint_32 width; /* width of row */
   png_uint_32 rowbytes; /* number of bytes in row */
   png_byte color_type; /* color type of row */
   png_byte bit_depth; /* bit depth of row */
   png_byte channels; /* number of channels (1, 2, 3, or 4) */
   png_byte pixel_depth; /* bits per pixel (depth * channels) */
} png_row_info;

typedef png_row_info FAR * png_row_infop;
typedef png_row_info FAR * FAR * png_row_infopp;

/* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.
 */
typedef struct png_struct_def png_struct;
typedef png_struct FAR * png_structp;

typedef void (PNGAPI *png_error_ptr) PNGARG((png_structp, png_const_charp));
typedef void (PNGAPI *png_rw_ptr) PNGARG((png_structp, png_bytep, png_size_t));
typedef void (PNGAPI *png_flush_ptr) PNGARG((png_structp));
typedef void (PNGAPI *png_read_status_ptr) PNGARG((png_structp, png_uint_32,
   int));
typedef void (PNGAPI *png_write_status_ptr) PNGARG((png_structp, png_uint_32,
   int));

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
typedef void (PNGAPI *png_progressive_info_ptr) PNGARG((png_structp, png_infop));
typedef void (PNGAPI *png_progressive_end_ptr) PNGARG((png_structp, png_infop));
typedef void (PNGAPI *png_progressive_row_ptr) PNGARG((png_structp, png_bytep,
   png_uint_32, int));
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
typedef void (PNGAPI *png_user_transform_ptr) PNGARG((png_structp,
    png_row_infop, png_bytep));
#endif

#if defined(PNG_USER_CHUNKS_SUPPORTED)
typedef int (PNGAPI *png_user_chunk_ptr) PNGARG((png_structp, png_unknown_chunkp));
#endif
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
typedef void (PNGAPI *png_unknown_chunk_ptr) PNGARG((png_structp));
#endif

/* Transform masks for the high-level interface */
#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* WRITE only */

/* Flags for MNG supported features */
#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
#define PNG_FLAG_MNG_FILTER_64      0x04
#define PNG_ALL_MNG_FEATURES        0x05

typedef png_voidp (*png_malloc_ptr) PNGARG((png_structp, png_size_t));
typedef void (*png_free_ptr) PNGARG((png_structp, png_voidp));

/* The structure that holds the information to read and write PNG files.
 * The only people who need to care about what is inside of this are the
 * people who will be modifying the library for their own special needs.
 * It should NOT be accessed directly by an application, except to store
 * the jmp_buf.
 */

struct png_struct_def
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf jmpbuf;            /* used in png_error */
#endif
   png_error_ptr error_fn;    /* function for printing errors and aborting */
   png_error_ptr warning_fn;  /* function for printing warnings */
   png_voidp error_ptr;       /* user supplied struct for error functions */
   png_rw_ptr write_data_fn;  /* function for writing output data */
   png_rw_ptr read_data_fn;   /* function for reading input data */
   png_voidp io_ptr;          /* ptr to application struct for I/O functions*/

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   png_user_transform_ptr read_user_transform_fn; /* user read transform */
#endif

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   png_user_transform_ptr write_user_transform_fn; /* user write transform */
#endif

/* These were added in libpng-1.0.2 */
#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   png_voidp user_transform_ptr; /* user supplied struct for user transform */
   png_byte user_transform_depth;    /* bit depth of user transformed pixels */
   png_byte user_transform_channels; /* channels in user transformed pixels */
#endif
#endif

   png_uint_32 mode;          /* tells us where we are in the PNG file */
   png_uint_32 flags;         /* flags indicating various things to libpng */
   png_uint_32 transformations; /* which transformations to perform */

   z_stream zstream;          /* pointer to decompression structure (below) */
   png_bytep zbuf;            /* buffer for zlib */
   png_size_t zbuf_size;      /* size of zbuf */
   int zlib_level;            /* holds zlib compression level */
   int zlib_method;           /* holds zlib compression method */
   int zlib_window_bits;      /* holds zlib compression window bits */
   int zlib_mem_level;        /* holds zlib compression memory level */
   int zlib_strategy;         /* holds zlib compression strategy */

   png_uint_32 width;         /* width of image in pixels */
   png_uint_32 height;        /* height of image in pixels */
   png_uint_32 num_rows;      /* number of rows in current pass */
   png_uint_32 usr_width;     /* width of row at start of write */
   png_uint_32 rowbytes;      /* size of row in bytes */
   png_uint_32 irowbytes;     /* size of current interlaced row in bytes */
   png_uint_32 iwidth;        /* width of current interlaced row in pixels */
   png_uint_32 row_number;    /* current row in interlace pass */
   png_bytep prev_row;        /* buffer to save previous (unfiltered) row */
   png_bytep row_buf;         /* buffer to save current (unfiltered) row */
   png_bytep sub_row;         /* buffer to save "sub" row when filtering */
   png_bytep up_row;          /* buffer to save "up" row when filtering */
   png_bytep avg_row;         /* buffer to save "avg" row when filtering */
   png_bytep paeth_row;       /* buffer to save "Paeth" row when filtering */
   png_row_info row_info;     /* used for transformation routines */

   png_uint_32 idat_size;     /* current IDAT size for read */
   png_uint_32 crc;           /* current chunk CRC value */
   png_colorp palette;        /* palette from the input file */
   png_uint_16 num_palette;   /* number of color entries in palette */
   png_uint_16 num_trans;     /* number of transparency values */
   png_byte chunk_name[5];    /* null-terminated name of current chunk */
   png_byte compression;      /* file compression type (always 0) */
   png_byte filter;           /* file filter type (always 0) */
   png_byte interlaced;       /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
   png_byte pass;             /* current interlace pass (0 - 6) */
   png_byte do_filter;        /* row filter flags (see PNG_FILTER_ below ) */
   png_byte color_type;       /* color type of file */
   png_byte bit_depth;        /* bit depth of file */
   png_byte usr_bit_depth;    /* bit depth of users row */
   png_byte pixel_depth;      /* number of bits per pixel */
   png_byte channels;         /* number of channels in file */
   png_byte usr_channels;     /* channels at start of write */
   png_byte sig_bytes;        /* magic bytes read/written from start of file */

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
#ifdef PNG_LEGACY_SUPPORTED
   png_byte filler;           /* filler byte for pixel expansion */
#else
   png_uint_16 filler;           /* filler bytes for pixel expansion */
#endif
#endif

#if defined(PNG_bKGD_SUPPORTED)
   png_byte background_gamma_type;
#  ifdef PNG_FLOATING_POINT_SUPPORTED
   float background_gamma;
#  endif
   png_color_16 background;   /* background color in screen gamma space */
#  if defined(PNG_READ_GAMMA_SUPPORTED)
     png_color_16 background_1; /* background normalized to gamma 1.0 */
#  endif /* PNG_READ_GAMMA && PNG_bKGD_SUPPORTED */
#endif /* PNG_bKGD_SUPPORTED */

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
   png_flush_ptr output_flush_fn;/* Function for flushing output */
   png_uint_32 flush_dist;    /* how many rows apart to flush, 0 - no flush */
   png_uint_32 flush_rows;    /* number of rows written since last flush */
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   int gamma_shift;      /* number of "insignificant" bits 16-bit gamma */
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float gamma;          /* file gamma value */
   float screen_gamma;   /* screen gamma value (display_exponent) */
#endif
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   png_bytep gamma_table;     /* gamma table for 8-bit depth files */
   png_bytep gamma_from_1;    /* converts from 1.0 to screen */
   png_bytep gamma_to_1;      /* converts from file to 1.0 */
   png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */
   png_uint_16pp gamma_16_from_1; /* converts from 1.0 to screen */
   png_uint_16pp gamma_16_to_1; /* converts from file to 1.0 */
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
   png_color_8 sig_bit;       /* significant bits in each available channel */
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
   png_color_8 shift;         /* shift for significant bit tranformation */
#endif

#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
 || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   png_bytep trans;           /* transparency values for paletted files */
   png_color_16 trans_values; /* transparency values for non-paletted files */
#endif

   png_read_status_ptr read_row_fn;   /* called after each row is decoded */
   png_write_status_ptr write_row_fn; /* called after each row is encoded */
#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
   png_progressive_info_ptr info_fn; /* called after header data fully read */
   png_progressive_row_ptr row_fn;   /* called after each prog. row is decoded */
   png_progressive_end_ptr end_fn;   /* called after image is complete */
   png_bytep save_buffer_ptr;        /* current location in save_buffer */
   png_bytep save_buffer;            /* buffer for previously read data */
   png_bytep current_buffer_ptr;     /* current location in current_buffer */
   png_bytep current_buffer;         /* buffer for recently used data */
   png_uint_32 push_length;          /* size of current input chunk */
   png_uint_32 skip_length;          /* bytes to skip in input data */
   png_size_t save_buffer_size;      /* amount of data now in save_buffer */
   png_size_t save_buffer_max;       /* total size of save_buffer */
   png_size_t buffer_size;           /* total amount of available input data */
   png_size_t current_buffer_size;   /* amount of data now in current_buffer */
   int process_mode;                 /* what push library is currently doing */
   int cur_palette;                  /* current push library palette index */

#  if defined(PNG_TEXT_SUPPORTED)
     png_size_t current_text_size;   /* current size of text input data */
     png_size_t current_text_left;   /* how much text left to read in input */
     png_charp current_text;         /* current text chunk buffer */
     png_charp current_text_ptr;     /* current location in current_text */
#  endif /* PNG_PROGRESSIVE_READ_SUPPORTED && PNG_TEXT_SUPPORTED */

#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */

#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
/* for the Borland special 64K segment handler */
   png_bytepp offset_table_ptr;
   png_bytep offset_table;
   png_uint_16 offset_table_number;
   png_uint_16 offset_table_count;
   png_uint_16 offset_table_count_free;
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
   png_bytep palette_lookup;         /* lookup table for dithering */
   png_bytep dither_index;           /* index translation for palette files */
#endif

#if defined(PNG_READ_DITHER_SUPPORTED) || defined(PNG_hIST_SUPPORTED)
   png_uint_16p hist;                /* histogram */
#endif

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_byte heuristic_method;        /* heuristic for row filter selection */
   png_byte num_prev_filters;        /* number of weights for previous rows */
   png_bytep prev_filters;           /* filter type(s) of previous row(s) */
   png_uint_16p filter_weights;      /* weight(s) for previous line(s) */
   png_uint_16p inv_filter_weights;  /* 1/weight(s) for previous line(s) */
   png_uint_16p filter_costs;        /* relative filter calculation cost */
   png_uint_16p inv_filter_costs;    /* 1/relative filter calculation cost */
#endif

#if defined(PNG_TIME_RFC1123_SUPPORTED)
   png_charp time_buffer;            /* String to hold RFC 1123 time text */
#endif

#ifdef PNG_USER_MEM_SUPPORTED
   png_voidp mem_ptr;                /* user supplied struct for mem functions */
   png_malloc_ptr malloc_fn;         /* function for allocating memory */
   png_free_ptr free_fn;             /* function for freeing memory */
#endif

/* New members added in libpng-1.0.6 */

#ifdef PNG_FREE_ME_SUPPORTED
   png_uint_32 free_me;       /* flags items libpng is responsible for freeing */
#endif

#if defined(PNG_USER_CHUNKS_SUPPORTED)
   png_voidp user_chunk_ptr;
   png_user_chunk_ptr read_user_chunk_fn; /* user read chunk handler */
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
   int num_chunk_list;
   png_bytep chunk_list;
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   png_byte rgb_to_gray_status;
   png_uint_16 rgb_to_gray_red_coeff;
   png_uint_16 rgb_to_gray_green_coeff;
   png_uint_16 rgb_to_gray_blue_coeff;
#endif

#if defined(PNG_MNG_FEATURES_SUPPORTED) || \
    defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
    defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
/* Note to maintainer: change this to png_uint_32 at next opportunity */
   png_byte mng_features_permitted;
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   png_fixed_point int_gamma;
#endif

   png_byte filter_type;

   png_uint_32 row_buf_size;

};


/* This prevents a compiler error in png_get_copyright() in png.c if png.c
and png.h are both at * version 1.0.11
 */
typedef png_structp version_1_0_11;

typedef png_struct FAR * FAR * png_structpp;

/* Here are the function definitions most commonly used.  This is not
 * the place to find out how to use libpng.  See libpng.txt for the
 * full explanation, see example.c for the summary.  This just provides
 * a simple one line description of the use of each function.
 */

/* Returns the version number of the library */
extern PNG_EXPORT(png_uint_32,png_access_version_number) PNGARG((void));

/* Tell lib we have already handled the first <num_bytes> magic bytes.
 * Handling more than 8 bytes from the beginning of the file is an error.
 */
extern PNG_EXPORT(void,png_set_sig_bytes) PNGARG((png_structp png_ptr,
   int num_bytes));

/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
 * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
 * signature, and non-zero otherwise.  Having num_to_check == 0 or
 * start > 7 will always fail (ie return non-zero).
 */
extern PNG_EXPORT(int,png_sig_cmp) PNGARG((png_bytep sig, png_size_t start,
   png_size_t num_to_check));

/* Simple signature checking function.  This is the same as calling
 * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
 */
extern PNG_EXPORT(int,png_check_sig) PNGARG((png_bytep sig, int num));

/* Allocate and initialize png_ptr struct for reading, and any other memory. */
extern PNG_EXPORT(png_structp,png_create_read_struct)
   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn));

/* Allocate and initialize png_ptr struct for writing, and any other memory */
extern PNG_EXPORT(png_structp,png_create_write_struct)
   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn));

extern PNG_EXPORT(png_uint_32,png_get_compression_buffer_size)
   PNGARG((png_structp png_ptr));

extern PNG_EXPORT(void,png_set_compression_buffer_size)
   PNGARG((png_structp png_ptr, png_uint_32 size));

/* Reset the compression stream */
extern PNG_EXPORT(int,png_reset_zstream) PNGARG((png_structp png_ptr));

#ifdef PNG_USER_MEM_SUPPORTED
extern PNG_EXPORT(png_structp,png_create_read_struct_2)
   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
   png_malloc_ptr malloc_fn, png_free_ptr free_fn));
extern PNG_EXPORT(png_structp,png_create_write_struct_2)
   PNGARG((png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
   png_malloc_ptr malloc_fn, png_free_ptr free_fn));
#endif

/* Write a PNG chunk - size, type, (optional) data, CRC. */
extern PNG_EXPORT(void,png_write_chunk) PNGARG((png_structp png_ptr,
   png_bytep chunk_name, png_bytep data, png_size_t length));

/* Write the start of a PNG chunk - length and chunk name. */
extern PNG_EXPORT(void,png_write_chunk_start) PNGARG((png_structp png_ptr,
   png_bytep chunk_name, png_uint_32 length));

/* Write the data of a PNG chunk started with png_write_chunk_start(). */
extern PNG_EXPORT(void,png_write_chunk_data) PNGARG((png_structp png_ptr,
   png_bytep data, png_size_t length));

/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
extern PNG_EXPORT(void,png_write_chunk_end) PNGARG((png_structp png_ptr));

/* Allocate and initialize the info structure */
extern PNG_EXPORT(png_infop,png_create_info_struct)
   PNGARG((png_structp png_ptr));

/* Initialize the info structure (old interface - NOT DLL EXPORTED) */
extern void png_info_init PNGARG((png_infop info_ptr));

/* Writes all the PNG information before the image. */
extern PNG_EXPORT(void,png_write_info_before_PLTE) PNGARG((png_structp png_ptr,
   png_infop info_ptr));
extern PNG_EXPORT(void,png_write_info) PNGARG((png_structp png_ptr,
   png_infop info_ptr));

/* read the information before the actual image data. */
extern PNG_EXPORT(void,png_read_info) PNGARG((png_structp png_ptr,
   png_infop info_ptr));

#if defined(PNG_TIME_RFC1123_SUPPORTED)
extern PNG_EXPORT(png_charp,png_convert_to_rfc1123)
   PNGARG((png_structp png_ptr, png_timep ptime));
#endif

#if !defined(_WIN32_WCE)
/* "time.h" functions are not supported on WindowsCE */
#if defined(PNG_WRITE_tIME_SUPPORTED)
/* convert from a struct tm to png_time */
extern PNG_EXPORT(void,png_convert_from_struct_tm) PNGARG((png_timep ptime,
   struct tm FAR * ttime));

/* convert from time_t to png_time.  Uses gmtime() */
extern PNG_EXPORT(void,png_convert_from_time_t) PNGARG((png_timep ptime,
   time_t ttime));
#endif /* PNG_WRITE_tIME_SUPPORTED */
#endif /* _WIN32_WCE */

#if defined(PNG_READ_EXPAND_SUPPORTED)
/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
extern PNG_EXPORT(void,png_set_expand) PNGARG((png_structp png_ptr));
extern PNG_EXPORT(void,png_set_gray_1_2_4_to_8) PNGARG((png_structp png_ptr));
extern PNG_EXPORT(void,png_set_palette_to_rgb) PNGARG((png_structp png_ptr));
extern PNG_EXPORT(void,png_set_tRNS_to_alpha) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* Use blue, green, red order for pixels. */
extern PNG_EXPORT(void,png_set_bgr) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
/* Expand the grayscale to 24-bit RGB if necessary. */
extern PNG_EXPORT(void,png_set_gray_to_rgb) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
/* Reduce RGB to grayscale. */
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_rgb_to_gray) PNGARG((png_structp png_ptr,
   int error_action, double red, double green ));
#endif
extern PNG_EXPORT(void,png_set_rgb_to_gray_fixed) PNGARG((png_structp png_ptr,
   int error_action, png_fixed_point red, png_fixed_point green ));
extern PNG_EXPORT(png_byte,png_get_rgb_to_gray_status) PNGARG((png_structp
   png_ptr));
#endif

extern PNG_EXPORT(void,png_build_grayscale_palette) PNGARG((int bit_depth,
   png_colorp palette));

#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
extern PNG_EXPORT(void,png_set_strip_alpha) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
extern PNG_EXPORT(void,png_set_swap_alpha) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
extern PNG_EXPORT(void,png_set_invert_alpha) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte to 24-bit RGB images. */
extern PNG_EXPORT(void,png_set_filler) PNGARG((png_structp png_ptr,
   png_uint_32 filler, int flags));
/* The values of the PNG_FILLER_ defines should NOT be changed */
#define PNG_FILLER_BEFORE 0
#define PNG_FILLER_AFTER 1
#endif /* PNG_READ_FILLER_SUPPORTED || PNG_WRITE_FILLER_SUPPORTED */

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* Swap bytes in 16-bit depth files. */
extern PNG_EXPORT(void,png_set_swap) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
extern PNG_EXPORT(void,png_set_packing) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED) || defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* Swap packing order of pixels in bytes. */
extern PNG_EXPORT(void,png_set_packswap) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
/* Converts files to legal bit depths. */
extern PNG_EXPORT(void,png_set_shift) PNGARG((png_structp png_ptr,
   png_color_8p true_bits));
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* Have the code handle the interlacing.  Returns the number of passes. */
extern PNG_EXPORT(int,png_set_interlace_handling) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
/* Invert monochrome files */
extern PNG_EXPORT(void,png_set_invert_mono) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED)
/* Handle alpha and tRNS by replacing with a background color. */
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_background) PNGARG((png_structp png_ptr,
   png_color_16p background_color, int background_gamma_code,
   int need_expand, double background_gamma));
#endif
#define PNG_BACKGROUND_GAMMA_UNKNOWN 0
#define PNG_BACKGROUND_GAMMA_SCREEN  1
#define PNG_BACKGROUND_GAMMA_FILE    2
#define PNG_BACKGROUND_GAMMA_UNIQUE  3
#endif

#if defined(PNG_READ_16_TO_8_SUPPORTED)
/* strip the second byte of information from a 16-bit depth file. */
extern PNG_EXPORT(void,png_set_strip_16) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
/* Turn on dithering, and reduce the palette to the number of colors available. */
extern PNG_EXPORT(void,png_set_dither) PNGARG((png_structp png_ptr,
   png_colorp palette, int num_palette, int maximum_colors,
   png_uint_16p histogram, int full_dither));
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED)
/* Handle gamma correction. Screen_gamma=(display_exponent) */
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_gamma) PNGARG((png_structp png_ptr,
   double screen_gamma, double default_file_gamma));
#endif
#endif

#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
    defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
/* Permit or disallow empty PLTE (0: not permitted, 1: permitted) */
/* Deprecated and will be removed.  Use png_permit_mng_features() instead. */
extern PNG_EXPORT(void,png_permit_empty_plte) PNGARG((png_structp png_ptr,
   int empty_plte_permitted));
#endif

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
/* Set how many lines between output flushes - 0 for no flushing */
extern PNG_EXPORT(void,png_set_flush) PNGARG((png_structp png_ptr, int nrows));
/* Flush the current PNG output buffer */
extern PNG_EXPORT(void,png_write_flush) PNGARG((png_structp png_ptr));
#endif

/* optional update palette with requested transformations */
extern PNG_EXPORT(void,png_start_read_image) PNGARG((png_structp png_ptr));

/* optional call to update the users info structure */
extern PNG_EXPORT(void,png_read_update_info) PNGARG((png_structp png_ptr,
   png_infop info_ptr));

/* read a one or more rows of image data.*/
extern PNG_EXPORT(void,png_read_rows) PNGARG((png_structp png_ptr,
   png_bytepp row, png_bytepp display_row, png_uint_32 num_rows));

/* read a row of data.*/
extern PNG_EXPORT(void,png_read_row) PNGARG((png_structp png_ptr,
   png_bytep row,
   png_bytep display_row));

/* read the whole image into memory at once. */
extern PNG_EXPORT(void,png_read_image) PNGARG((png_structp png_ptr,
   png_bytepp image));

/* write a row of image data */
extern PNG_EXPORT(void,png_write_row) PNGARG((png_structp png_ptr,
   png_bytep row));

/* write a few rows of image data */
extern PNG_EXPORT(void,png_write_rows) PNGARG((png_structp png_ptr,
   png_bytepp row, png_uint_32 num_rows));

/* write the image data */
extern PNG_EXPORT(void,png_write_image) PNGARG((png_structp png_ptr,
   png_bytepp image));

/* writes the end of the PNG file. */
extern PNG_EXPORT(void,png_write_end) PNGARG((png_structp png_ptr,
   png_infop info_ptr));

/* read the end of the PNG file. */
extern PNG_EXPORT(void,png_read_end) PNGARG((png_structp png_ptr,
   png_infop info_ptr));

/* free any memory associated with the png_info_struct */
extern PNG_EXPORT(void,png_destroy_info_struct) PNGARG((png_structp png_ptr,
   png_infopp info_ptr_ptr));

/* free any memory associated with the png_struct and the png_info_structs */
extern PNG_EXPORT(void,png_destroy_read_struct) PNGARG((png_structpp
   png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));

/* free all memory used by the read (old method - NOT DLL EXPORTED) */
extern void png_read_destroy PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_infop end_info_ptr));

/* free any memory associated with the png_struct and the png_info_structs */
extern PNG_EXPORT(void,png_destroy_write_struct)
   PNGARG((png_structpp png_ptr_ptr, png_infopp info_ptr_ptr));

/* free any memory used in info_ptr struct (old method - NOT DLL EXPORTED) */
extern void png_write_destroy_info PNGARG((png_infop info_ptr));

/* free any memory used in png_ptr struct (old method - NOT DLL EXPORTED) */
extern void png_write_destroy PNGARG((png_structp png_ptr));

/* set the libpng method of handling chunk CRC errors */
extern PNG_EXPORT(void,png_set_crc_action) PNGARG((png_structp png_ptr,
   int crit_action, int ancil_action));

/* Values for png_set_crc_action() to say how to handle CRC errors in
 * ancillary and critical chunks, and whether to use the data contained
 * therein.  Note that it is impossible to "discard" data in a critical
 * chunk.  For versions prior to 0.90, the action was always error/quit,
 * whereas in version 0.90 and later, the action for CRC errors in ancillary
 * chunks is warn/discard.  These values should NOT be changed.
 *
 *      value                       action:critical     action:ancillary
 */
#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */

/* These functions give the user control over the scan-line filtering in
 * libpng and the compression methods used by zlib.  These functions are
 * mainly useful for testing, as the defaults should work with most users.
 * Those users who are tight on memory or want faster performance at the
 * expense of compression can modify them.  See the compression library
 * header file (zlib.h) for an explination of the compression functions.
 */

/* set the filtering method(s) used by libpng.  Currently, the only valid
 * value for "method" is 0.
 */
extern PNG_EXPORT(void,png_set_filter) PNGARG((png_structp png_ptr, int method,
   int filters));

/* Flags for png_set_filter() to say which filters to use.  The flags
 * are chosen so that they don't conflict with real filter types
 * below, in case they are supplied instead of the #defined constants.
 * These values should NOT be changed.
 */
#define PNG_NO_FILTERS     0x00
#define PNG_FILTER_NONE    0x08
#define PNG_FILTER_SUB     0x10
#define PNG_FILTER_UP      0x20
#define PNG_FILTER_AVG     0x40
#define PNG_FILTER_PAETH   0x80
#define PNG_ALL_FILTERS (PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP | \
                         PNG_FILTER_AVG | PNG_FILTER_PAETH)

/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
 * These defines should NOT be changed.
 */
#define PNG_FILTER_VALUE_NONE  0
#define PNG_FILTER_VALUE_SUB   1
#define PNG_FILTER_VALUE_UP    2
#define PNG_FILTER_VALUE_AVG   3
#define PNG_FILTER_VALUE_PAETH 4
#define PNG_FILTER_VALUE_LAST  5

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED) /* EXPERIMENTAL */
/* The "heuristic_method" is given by one of the PNG_FILTER_HEURISTIC_
 * defines, either the default (minimum-sum-of-absolute-differences), or
 * the experimental method (weighted-minimum-sum-of-absolute-differences).
 *
 * Weights are factors >= 1.0, indicating how important it is to keep the
 * filter type consistent between rows.  Larger numbers mean the current
 * filter is that many times as likely to be the same as the "num_weights"
 * previous filters.  This is cumulative for each previous row with a weight.
 * There needs to be "num_weights" values in "filter_weights", or it can be
 * NULL if the weights aren't being specified.  Weights have no influence on
 * the selection of the first row filter.  Well chosen weights can (in theory)
 * improve the compression for a given image.
 *
 * Costs are factors >= 1.0 indicating the relative decoding costs of a
 * filter type.  Higher costs indicate more decoding expense, and are
 * therefore less likely to be selected over a filter with lower computational
 * costs.  There needs to be a value in "filter_costs" for each valid filter
 * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't
 * setting the costs.  Costs try to improve the speed of decompression without
 * unduly increasing the compressed image size.
 *
 * A negative weight or cost indicates the default value is to be used, and
 * values in the range [0.0, 1.0) indicate the value is to remain unchanged.
 * The default values for both weights and costs are currently 1.0, but may
 * change if good general weighting/cost heuristics can be found.  If both
 * the weights and costs are set to 1.0, this degenerates the WEIGHTED method
 * to the UNWEIGHTED method, but with added encoding time/computation.
 */
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_filter_heuristics) PNGARG((png_structp png_ptr,
   int heuristic_method, int num_weights, png_doublep filter_weights,
   png_doublep filter_costs));
#endif
#endif /*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */

/* Heuristic used for row filter selection.  These defines should NOT be
 * changed.
 */
#define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently "UNWEIGHTED" */
#define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */
#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
#define PNG_FILTER_HEURISTIC_LAST       3  /* Not a valid value */

/* Set the library compression level.  Currently, valid values range from
 * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
 * (0 - no compression, 9 - "maximal" compression).  Note that tests have
 * shown that zlib compression levels 3-6 usually perform as well as level 9
 * for PNG images, and do considerably fewer caclulations.  In the future,
 * these values may not correspond directly to the zlib compression levels.
 */
extern PNG_EXPORT(void,png_set_compression_level) PNGARG((png_structp png_ptr,
   int level));

extern PNG_EXPORT(void,png_set_compression_mem_level)
   PNGARG((png_structp png_ptr, int mem_level));

extern PNG_EXPORT(void,png_set_compression_strategy)
   PNGARG((png_structp png_ptr, int strategy));

extern PNG_EXPORT(void,png_set_compression_window_bits)
   PNGARG((png_structp png_ptr, int window_bits));

extern PNG_EXPORT(void,png_set_compression_method) PNGARG((png_structp png_ptr,
   int method));

/* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng.txt for
 * more information.
 */

#if !defined(PNG_NO_STDIO)
/* Initialize the input/output for the PNG file to the default functions. */
extern PNG_EXPORT(void,png_init_io) PNGARG((png_structp png_ptr, png_FILE_p fp));
#endif

/* Replace the (error and abort), and warning functions with user
 * supplied functions.  If no messages are to be printed you must still
 * write and use replacement functions. The replacement error_fn should
 * still do a longjmp to the last setjmp location if you are using this
 * method of error handling.  If error_fn or warning_fn is NULL, the
 * default function will be used.
 */

extern PNG_EXPORT(void,png_set_error_fn) PNGARG((png_structp png_ptr,
   png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn));

/* Return the user pointer associated with the error functions */
extern PNG_EXPORT(png_voidp,png_get_error_ptr) PNGARG((png_structp png_ptr));

/* Replace the default data output functions with a user supplied one(s).
 * If buffered output is not used, then output_flush_fn can be set to NULL.
 * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
 * output_flush_fn will be ignored (and thus can be NULL).
 */
extern PNG_EXPORT(void,png_set_write_fn) PNGARG((png_structp png_ptr,
   png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));

/* Replace the default data input function with a user supplied one. */
extern PNG_EXPORT(void,png_set_read_fn) PNGARG((png_structp png_ptr,
   png_voidp io_ptr, png_rw_ptr read_data_fn));

/* Return the user pointer associated with the I/O functions */
extern PNG_EXPORT(png_voidp,png_get_io_ptr) PNGARG((png_structp png_ptr));

extern PNG_EXPORT(void,png_set_read_status_fn) PNGARG((png_structp png_ptr,
   png_read_status_ptr read_row_fn));

extern PNG_EXPORT(void,png_set_write_status_fn) PNGARG((png_structp png_ptr,
   png_write_status_ptr write_row_fn));

#ifdef PNG_USER_MEM_SUPPORTED
/* Replace the default memory allocation functions with user supplied one(s). */
extern PNG_EXPORT(void,png_set_mem_fn) PNGARG((png_structp png_ptr,
   png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn));
/* Return the user pointer associated with the memory functions */
extern PNG_EXPORT(png_voidp,png_get_mem_ptr) PNGARG((png_structp png_ptr));
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
extern PNG_EXPORT(void,png_set_read_user_transform_fn) PNGARG((png_structp
   png_ptr, png_user_transform_ptr read_user_transform_fn));
#endif

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
extern PNG_EXPORT(void,png_set_write_user_transform_fn) PNGARG((png_structp
   png_ptr, png_user_transform_ptr write_user_transform_fn));
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
extern PNG_EXPORT(void,png_set_user_transform_info) PNGARG((png_structp
   png_ptr, png_voidp user_transform_ptr, int user_transform_depth,
   int user_transform_channels));
/* Return the user pointer associated with the user transform functions */
extern PNG_EXPORT(png_voidp,png_get_user_transform_ptr)
   PNGARG((png_structp png_ptr));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
extern PNG_EXPORT(void,png_set_read_user_chunk_fn) PNGARG((png_structp png_ptr,
   png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn));
extern PNG_EXPORT(png_voidp,png_get_user_chunk_ptr) PNGARG((png_structp
   png_ptr));
#endif

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
/* Sets the function callbacks for the push reader, and a pointer to a
 * user-defined structure available to the callback functions.
 */
extern PNG_EXPORT(void,png_set_progressive_read_fn) PNGARG((png_structp png_ptr,
   png_voidp progressive_ptr,
   png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
   png_progressive_end_ptr end_fn));

/* returns the user pointer associated with the push read functions */
extern PNG_EXPORT(png_voidp,png_get_progressive_ptr)
   PNGARG((png_structp png_ptr));

/* function to be called when data becomes available */
extern PNG_EXPORT(void,png_process_data) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_bytep buffer, png_size_t buffer_size));

/* function that combines rows.  Not very much different than the
 * png_combine_row() call.  Is this even used?????
 */
extern PNG_EXPORT(void,png_progressive_combine_row) PNGARG((png_structp png_ptr,
   png_bytep old_row, png_bytep new_row));
#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */

extern PNG_EXPORT(png_voidp,png_malloc) PNGARG((png_structp png_ptr,
   png_uint_32 size));

/* frees a pointer allocated by png_malloc() */
extern PNG_EXPORT(void,png_free) PNGARG((png_structp png_ptr, png_voidp ptr));

/* Free data that was allocated internally */
extern PNG_EXPORT(void,png_free_data) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 free_me, int num));
#ifdef PNG_FREE_ME_SUPPORTED
/* Reassign responsibility for freeing existing data, whether allocated
 * by libpng or by the application */
extern PNG_EXPORT(void,png_data_freer) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int freer, png_uint_32 mask));
#endif
/* assignments for png_data_freer */
#define PNG_DESTROY_WILL_FREE_DATA 1
#define PNG_SET_WILL_FREE_DATA 1
#define PNG_USER_WILL_FREE_DATA 2
/* Flags for png_ptr->free_me and info_ptr->free_me */
#define PNG_FREE_HIST 0x0008
#define PNG_FREE_ICCP 0x0010
#define PNG_FREE_SPLT 0x0020
#define PNG_FREE_ROWS 0x0040
#define PNG_FREE_PCAL 0x0080
#define PNG_FREE_SCAL 0x0100
#define PNG_FREE_UNKN 0x0200
#define PNG_FREE_LIST 0x0400
#define PNG_FREE_PLTE 0x1000
#define PNG_FREE_TRNS 0x2000
#define PNG_FREE_TEXT 0x4000
#define PNG_FREE_ALL  0x7fff
#define PNG_FREE_MUL  0x4220 /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */

#ifdef PNG_USER_MEM_SUPPORTED
extern PNG_EXPORT(png_voidp,png_malloc_default) PNGARG((png_structp png_ptr,
   png_uint_32 size));
extern PNG_EXPORT(void,png_free_default) PNGARG((png_structp png_ptr,
   png_voidp ptr));
#endif

extern PNG_EXPORT(png_voidp,png_memcpy_check) PNGARG((png_structp png_ptr,
   png_voidp s1, png_voidp s2, png_uint_32 size));

extern PNG_EXPORT(png_voidp,png_memset_check) PNGARG((png_structp png_ptr,
   png_voidp s1, int value, png_uint_32 size));

#if defined(USE_FAR_KEYWORD)  /* memory model conversion function */
extern void *png_far_to_near PNGARG((png_structp png_ptr,png_voidp ptr,
   int check));
#endif /* USE_FAR_KEYWORD */

/* Fatal error in PNG image of libpng - can't continue */
extern PNG_EXPORT(void,png_error) PNGARG((png_structp png_ptr,
   png_const_charp error));

/* The same, but the chunk name is prepended to the error string. */
extern PNG_EXPORT(void,png_chunk_error) PNGARG((png_structp png_ptr,
   png_const_charp error));

/* Non-fatal error in libpng.  Can continue, but may have a problem. */
extern PNG_EXPORT(void,png_warning) PNGARG((png_structp png_ptr,
   png_const_charp message));

/* Non-fatal error in libpng, chunk name is prepended to message. */
extern PNG_EXPORT(void,png_chunk_warning) PNGARG((png_structp png_ptr,
   png_const_charp message));

/* The png_set_<chunk> functions are for storing values in the png_info_struct.
 * Similarly, the png_get_<chunk> calls are used to read values from the
 * png_info_struct, either storing the parameters in the passed variables, or
 * setting pointers into the png_info_struct where the data is stored.  The
 * png_get_<chunk> functions return a non-zero value if the data was available
 * in info_ptr, or return zero and do not change any of the parameters if the
 * data was not available.
 *
 * These functions should be used instead of directly accessing png_info
 * to avoid problems with future changes in the size and internal layout of
 * png_info_struct.
 */
/* Returns "flag" if chunk data is valid in info_ptr. */
extern PNG_EXPORT(png_uint_32,png_get_valid) PNGARG((png_structp png_ptr,
png_infop info_ptr, png_uint_32 flag));

/* Returns number of bytes needed to hold a transformed row. */
extern PNG_EXPORT(png_uint_32,png_get_rowbytes) PNGARG((png_structp png_ptr,
png_infop info_ptr));

#if defined(PNG_INFO_IMAGE_SUPPORTED)
/* Returns row_pointers, which is an array of pointers to scanlines that was
returned from png_read_png(). */
extern PNG_EXPORT(png_bytepp,png_get_rows) PNGARG((png_structp png_ptr,
png_infop info_ptr));
/* Set row_pointers, which is an array of pointers to scanlines for use
by png_write_png(). */
extern PNG_EXPORT(void,png_set_rows) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_bytepp row_pointers));
#endif

/* Returns number of color channels in image. */
extern PNG_EXPORT(png_byte,png_get_channels) PNGARG((png_structp png_ptr,
png_infop info_ptr));

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* Returns image width in pixels. */
extern PNG_EXPORT(png_uint_32, png_get_image_width) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image height in pixels. */
extern PNG_EXPORT(png_uint_32, png_get_image_height) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image bit_depth. */
extern PNG_EXPORT(png_byte, png_get_bit_depth) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image color_type. */
extern PNG_EXPORT(png_byte, png_get_color_type) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image filter_type. */
extern PNG_EXPORT(png_byte, png_get_filter_type) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image interlace_type. */
extern PNG_EXPORT(png_byte, png_get_interlace_type) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image compression_type. */
extern PNG_EXPORT(png_byte, png_get_compression_type) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns image resolution in pixels per meter, from pHYs chunk data. */
extern PNG_EXPORT(png_uint_32, png_get_pixels_per_meter) PNGARG((png_structp
png_ptr, png_infop info_ptr));
extern PNG_EXPORT(png_uint_32, png_get_x_pixels_per_meter) PNGARG((png_structp
png_ptr, png_infop info_ptr));
extern PNG_EXPORT(png_uint_32, png_get_y_pixels_per_meter) PNGARG((png_structp
png_ptr, png_infop info_ptr));

/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(float, png_get_pixel_aspect_ratio) PNGARG((png_structp
png_ptr, png_infop info_ptr));
#endif

/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
extern PNG_EXPORT(png_int_32, png_get_x_offset_pixels) PNGARG((png_structp
png_ptr, png_infop info_ptr));
extern PNG_EXPORT(png_int_32, png_get_y_offset_pixels) PNGARG((png_structp
png_ptr, png_infop info_ptr));
extern PNG_EXPORT(png_int_32, png_get_x_offset_microns) PNGARG((png_structp
png_ptr, png_infop info_ptr));
extern PNG_EXPORT(png_int_32, png_get_y_offset_microns) PNGARG((png_structp
png_ptr, png_infop info_ptr));

#endif /* PNG_EASY_ACCESS_SUPPORTED */

/* Returns pointer to signature string read from PNG header */
extern PNG_EXPORT(png_bytep,png_get_signature) PNGARG((png_structp png_ptr,
png_infop info_ptr));

#if defined(PNG_bKGD_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_bKGD) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_color_16p *background));
#endif

#if defined(PNG_bKGD_SUPPORTED)
extern PNG_EXPORT(void,png_set_bKGD) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_color_16p background));
#endif

#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(png_uint_32,png_get_cHRM) PNGARG((png_structp png_ptr,
   png_infop info_ptr, double *white_x, double *white_y, double *red_x,
   double *red_y, double *green_x, double *green_y, double *blue_x,
   double *blue_y));
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
extern PNG_EXPORT(png_uint_32,png_get_cHRM_fixed) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_fixed_point *int_white_x, png_fixed_point
   *int_white_y, png_fixed_point *int_red_x, png_fixed_point *int_red_y,
   png_fixed_point *int_green_x, png_fixed_point *int_green_y, png_fixed_point
   *int_blue_x, png_fixed_point *int_blue_y));
#endif
#endif

#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_cHRM) PNGARG((png_structp png_ptr,
   png_infop info_ptr, double white_x, double white_y, double red_x,
   double red_y, double green_x, double green_y, double blue_x, double blue_y));
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_cHRM_fixed) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_fixed_point int_white_x, png_fixed_point int_white_y,
   png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
   int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
   png_fixed_point int_blue_y));
#endif
#endif

#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(png_uint_32,png_get_gAMA) PNGARG((png_structp png_ptr,
   png_infop info_ptr, double *file_gamma));
#endif
extern PNG_EXPORT(png_uint_32,png_get_gAMA_fixed) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_fixed_point *int_file_gamma));
#endif

#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_gAMA) PNGARG((png_structp png_ptr,
   png_infop info_ptr, double file_gamma));
#endif
extern PNG_EXPORT(void,png_set_gAMA_fixed) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_fixed_point int_file_gamma));
#endif

#if defined(PNG_hIST_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_hIST) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_16p *hist));
#endif

#if defined(PNG_hIST_SUPPORTED)
extern PNG_EXPORT(void,png_set_hIST) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_16p hist));
#endif

extern PNG_EXPORT(png_uint_32,png_get_IHDR) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 *width, png_uint_32 *height,
   int *bit_depth, int *color_type, int *interlace_method,
   int *compression_method, int *filter_method));

extern PNG_EXPORT(void,png_set_IHDR) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth,
   int color_type, int interlace_method, int compression_method,
   int filter_method));

#if defined(PNG_oFFs_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_oFFs) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
   int *unit_type));
#endif

#if defined(PNG_oFFs_SUPPORTED)
extern PNG_EXPORT(void,png_set_oFFs) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_int_32 offset_x, png_int_32 offset_y,
   int unit_type));
#endif

#if defined(PNG_pCAL_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_pCAL) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_charp *purpose, png_int_32 *X0, png_int_32 *X1,
   int *type, int *nparams, png_charp *units, png_charpp *params));
#endif

#if defined(PNG_pCAL_SUPPORTED)
extern PNG_EXPORT(void,png_set_pCAL) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_charp purpose, png_int_32 X0, png_int_32 X1,
   int type, int nparams, png_charp units, png_charpp params));
#endif

#if defined(PNG_pHYs_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_pHYs) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type));
#endif

#if defined(PNG_pHYs_SUPPORTED)
extern PNG_EXPORT(void,png_set_pHYs) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
#endif

extern PNG_EXPORT(png_uint_32,png_get_PLTE) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_colorp *palette, int *num_palette));

extern PNG_EXPORT(void,png_set_PLTE) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_colorp palette, int num_palette));

#if defined(PNG_sBIT_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_sBIT) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_color_8p *sig_bit));
#endif

#if defined(PNG_sBIT_SUPPORTED)
extern PNG_EXPORT(void,png_set_sBIT) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_color_8p sig_bit));
#endif

#if defined(PNG_sRGB_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_sRGB) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int *intent));
#endif

#if defined(PNG_sRGB_SUPPORTED)
extern PNG_EXPORT(void,png_set_sRGB) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int intent));
extern PNG_EXPORT(void,png_set_sRGB_gAMA_and_cHRM) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int intent));
#endif

#if defined(PNG_iCCP_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_iCCP) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_charpp name, int *compression_type,
   png_charpp profile, png_uint_32 *proflen));
   /* Note to maintainer: profile should be png_bytepp */
#endif

#if defined(PNG_iCCP_SUPPORTED)
extern PNG_EXPORT(void,png_set_iCCP) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_charp name, int compression_type,
   png_charp profile, png_uint_32 proflen));
   /* Note to maintainer: profile should be png_bytep */
#endif

#if defined(PNG_sPLT_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_sPLT) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_sPLT_tpp entries));
#endif

#if defined(PNG_sPLT_SUPPORTED)
extern PNG_EXPORT(void,png_set_sPLT) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_sPLT_tp entries, int nentries));
#endif

#if defined(PNG_TEXT_SUPPORTED)
/* png_get_text also returns the number of text chunks in *num_text */
extern PNG_EXPORT(png_uint_32,png_get_text) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_textp *text_ptr, int *num_text));
#endif

/*
 *  Note while png_set_text() will accept a structure whose text,
 *  language, and  translated keywords are NULL pointers, the structure
 *  returned by png_get_text will always contain regular
 *  zero-terminated C strings.  They might be empty strings but
 *  they will never be NULL pointers.
 */

#if defined(PNG_TEXT_SUPPORTED)
extern PNG_EXPORT(void,png_set_text) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_textp text_ptr, int num_text));
#endif

#if defined(PNG_tIME_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_tIME) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_timep *mod_time));
#endif

#if defined(PNG_tIME_SUPPORTED)
extern PNG_EXPORT(void,png_set_tIME) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_timep mod_time));
#endif

#if defined(PNG_tRNS_SUPPORTED)
extern PNG_EXPORT(png_uint_32,png_get_tRNS) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_bytep *trans, int *num_trans,
   png_color_16p *trans_values));
#endif

#if defined(PNG_tRNS_SUPPORTED)
extern PNG_EXPORT(void,png_set_tRNS) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_bytep trans, int num_trans,
   png_color_16p trans_values));
#endif

#if defined(PNG_tRNS_SUPPORTED)
#endif

#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(png_uint_32,png_get_sCAL) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int *unit, double *width, double *height));
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
extern PNG_EXPORT(png_uint_32,png_get_sCAL_s) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int *unit, png_charpp swidth, png_charpp sheight));
#endif
#endif
#endif /* PNG_sCAL_SUPPORTED */

#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_sCAL) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int unit, double width, double height));
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
extern PNG_EXPORT(void,png_set_sCAL_s) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int unit, png_charp swidth, png_charp sheight));
#endif
#endif /* PNG_sCAL_SUPPORTED || PNG_WRITE_sCAL_SUPPORTED */

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
/* provide a list of chunks and how they are to be handled, if the built-in
   handling or default unknown chunk handling is not desired.  Any chunks not
   listed will be handled in the default manner.  The IHDR and IEND chunks
   must not be listed.
      keep = 0: follow default behavour
           = 1: do not keep
           = 2: keep only if safe-to-copy
           = 3: keep even if unsafe-to-copy
*/
extern PNG_EXPORT(void, png_set_keep_unknown_chunks) PNGARG((png_structp
   png_ptr, int keep, png_bytep chunk_list, int num_chunks));
extern PNG_EXPORT(void, png_set_unknown_chunks) PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns));
extern PNG_EXPORT(void, png_set_unknown_chunk_location)
   PNGARG((png_structp png_ptr, png_infop info_ptr, int chunk, int location));
extern PNG_EXPORT(png_uint_32,png_get_unknown_chunks) PNGARG((png_structp
   png_ptr, png_infop info_ptr, png_unknown_chunkpp entries));
#endif

/* Png_free_data() will turn off the "valid" flag for anything it frees.
   If you need to turn it off for a chunk that your application has freed,
   you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK); */
extern PNG_EXPORT(void, png_set_invalid) PNGARG((png_structp png_ptr,
   png_infop info_ptr, int mask));

#if defined(PNG_INFO_IMAGE_SUPPORTED)
/* The "params" pointer is currently not used and is for future expansion. */
extern PNG_EXPORT(void, png_read_png) PNGARG((png_structp png_ptr,
                        png_infop info_ptr,
                        int transforms,
                        png_voidp params));
extern PNG_EXPORT(void, png_write_png) PNGARG((png_structp png_ptr,
                        png_infop info_ptr,
                        int transforms,
                        png_voidp params));
#endif

/* Define PNG_DEBUG at compile time for debugging information.  Higher
 * numbers for PNG_DEBUG mean more debugging information.  This has
 * only been added since version 0.95 so it is not implemented throughout
 * libpng yet, but more support will be added as needed.
 */
#ifdef PNG_DEBUG
#if (PNG_DEBUG > 0)
#if !defined(PNG_DEBUG_FILE) && defined(_MSC_VER)
#include <crtdbg.h>
#if (PNG_DEBUG > 1)
#define png_debug(l,m)  _RPT0(_CRT_WARN,m)
#define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m,p1)
#define png_debug2(l,m,p1,p2) _RPT2(_CRT_WARN,m,p1,p2)
#endif
#else /* PNG_DEBUG_FILE || !_MSC_VER */
#ifndef PNG_DEBUG_FILE
#define PNG_DEBUG_FILE stderr
#endif /* PNG_DEBUG_FILE */
#if (PNG_DEBUG > 1)
#define png_debug(l,m) \
{ \
     int num_tabs=l; \
     fprintf(PNG_DEBUG_FILE,"%s"m,(num_tabs==1 ? "\t" : \
       (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":"")))); \
}
#define png_debug1(l,m,p1) \
{ \
     int num_tabs=l; \
     fprintf(PNG_DEBUG_FILE,"%s"m,(num_tabs==1 ? "\t" : \
       (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1); \
}
#define png_debug2(l,m,p1,p2) \
{ \
     int num_tabs=l; \
     fprintf(PNG_DEBUG_FILE,"%s"m,(num_tabs==1 ? "\t" : \
       (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1,p2); \
}
#endif /* (PNG_DEBUG > 1) */
#endif /* _MSC_VER */
#endif /* (PNG_DEBUG > 0) */
#endif /* PNG_DEBUG */
#ifndef png_debug
#define png_debug(l, m)
#endif
#ifndef png_debug1
#define png_debug1(l, m, p1)
#endif
#ifndef png_debug2
#define png_debug2(l, m, p1, p2)
#endif

extern PNG_EXPORT(png_bytep,png_sig_bytes) PNGARG((void));

extern PNG_EXPORT(png_charp,png_get_copyright) PNGARG((png_structp png_ptr));
extern PNG_EXPORT(png_charp,png_get_header_ver) PNGARG((png_structp png_ptr));
extern PNG_EXPORT(png_charp,png_get_header_version) PNGARG((png_structp png_ptr));
extern PNG_EXPORT(png_charp,png_get_libpng_ver) PNGARG((png_structp png_ptr));

#ifdef PNG_MNG_FEATURES_SUPPORTED
extern PNG_EXPORT(png_uint_32,png_permit_mng_features) PNGARG((png_structp
   png_ptr, png_uint_32 mng_features_permitted));
#endif

#if 0 /* delay these until version 1.2.0 */
/* png.c, pnggccrd.c, or pngvcrd.c */
extern PNG_EXPORT(int,png_mmx_support) PNGARG((void));
#endif

/* Maintainer: Put new public prototypes here ^, in libpng.3, and project defs */

#define PNG_HEADER_VERSION_STRING \
   " libpng version 1.0.11 - April 27, 2001 (header)\n"

#ifdef PNG_READ_COMPOSITE_NODIV_SUPPORTED
/* With these routines we avoid an integer divide, which will be slower on
 * most machines.  However, it does take more operations than the corresponding
 * divide method, so it may be slower on a few RISC systems.  There are two
 * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
 *
 * Note that the rounding factors are NOT supposed to be the same!  128 and
 * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
 * standard method.
 *
 * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
 */

 /* fg and bg should be in `gamma 1.0' space; alpha is the opacity          */

#  define png_composite(composite, fg, alpha, bg)                            \
     { png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) * (png_uint_16)(alpha) \
                        +        (png_uint_16)(bg)*(png_uint_16)(255 -       \
                        (png_uint_16)(alpha)) + (png_uint_16)128);           \
       (composite) = (png_byte)((temp + (temp >> 8)) >> 8); }

#  define png_composite_16(composite, fg, alpha, bg)                         \
     { png_uint_32 temp = (png_uint_32)((png_uint_32)(fg) * (png_uint_32)(alpha) \
                        + (png_uint_32)(bg)*(png_uint_32)(65535L -           \
                        (png_uint_32)(alpha)) + (png_uint_32)32768L);        \
       (composite) = (png_uint_16)((temp + (temp >> 16)) >> 16); }

#else  /* standard method using integer division */

#  define png_composite(composite, fg, alpha, bg)                            \
     (composite) = (png_byte)(((png_uint_16)(fg) * (png_uint_16)(alpha) +    \
       (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) +       \
       (png_uint_16)127) / 255)

#  define png_composite_16(composite, fg, alpha, bg)                         \
     (composite) = (png_uint_16)(((png_uint_32)(fg) * (png_uint_32)(alpha) + \
       (png_uint_32)(bg)*(png_uint_32)(65535L - (png_uint_32)(alpha)) +      \
       (png_uint_32)32767) / (png_uint_32)65535L)

#endif /* PNG_READ_COMPOSITE_NODIV_SUPPORTED */

/* These next functions are used internally in the code.  They generally
 * shouldn't be used unless you are writing code to add or replace some
 * functionality in libpng.  More information about most functions can
 * be found in the files where the functions are located.
 */

#if defined(PNG_INTERNAL)

/* Various modes of operation.  Note that after an init, mode is set to
 * zero automatically when the structure is created.
 */
#define PNG_HAVE_IHDR               0x01
#define PNG_HAVE_PLTE               0x02
#define PNG_HAVE_IDAT               0x04
#define PNG_AFTER_IDAT              0x08
#define PNG_HAVE_IEND               0x10
#define PNG_HAVE_gAMA               0x20
#define PNG_HAVE_cHRM               0x40
#define PNG_HAVE_sRGB               0x80
#define PNG_HAVE_CHUNK_HEADER      0x100
#define PNG_WROTE_tIME             0x200
#define PNG_WROTE_INFO_BEFORE_PLTE 0x400
#define PNG_BACKGROUND_IS_GRAY     0x800
#define PNG_HAVE_PNG_SIGNATURE    0x1000

/* flags for the transformations the PNG library does on the image data */
#define PNG_BGR                0x0001
#define PNG_INTERLACE          0x0002
#define PNG_PACK               0x0004
#define PNG_SHIFT              0x0008
#define PNG_SWAP_BYTES         0x0010
#define PNG_INVERT_MONO        0x0020
#define PNG_DITHER             0x0040
#define PNG_BACKGROUND         0x0080
#define PNG_BACKGROUND_EXPAND  0x0100
                          /*   0x0200 unused */
#define PNG_16_TO_8            0x0400
#define PNG_RGBA               0x0800
#define PNG_EXPAND             0x1000
#define PNG_GAMMA              0x2000
#define PNG_GRAY_TO_RGB        0x4000
#define PNG_FILLER             0x8000L
#define PNG_PACKSWAP          0x10000L
#define PNG_SWAP_ALPHA        0x20000L
#define PNG_STRIP_ALPHA       0x40000L
#define PNG_INVERT_ALPHA      0x80000L
#define PNG_USER_TRANSFORM   0x100000L
#define PNG_RGB_TO_GRAY_ERR  0x200000L
#define PNG_RGB_TO_GRAY_WARN 0x400000L
#define PNG_RGB_TO_GRAY      0x600000L  /* two bits, RGB_TO_GRAY_ERR|WARN */

/* flags for png_create_struct */
#define PNG_STRUCT_PNG   0x0001
#define PNG_STRUCT_INFO  0x0002

/* Scaling factor for filter heuristic weighting calculations */
#define PNG_WEIGHT_SHIFT 8
#define PNG_WEIGHT_FACTOR (1<<(PNG_WEIGHT_SHIFT))
#define PNG_COST_SHIFT 3
#define PNG_COST_FACTOR (1<<(PNG_COST_SHIFT))

/* flags for the png_ptr->flags rather than declaring a byte for each one */
#define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001
#define PNG_FLAG_ZLIB_CUSTOM_LEVEL        0x0002
#define PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL    0x0004
#define PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS  0x0008
#define PNG_FLAG_ZLIB_CUSTOM_METHOD       0x0010
#define PNG_FLAG_ZLIB_FINISHED            0x0020
#define PNG_FLAG_ROW_INIT                 0x0040
#define PNG_FLAG_FILLER_AFTER             0x0080
#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100
#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200
#define PNG_FLAG_CRC_CRITICAL_USE         0x0400
#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800
#define PNG_FLAG_FREE_PLTE                0x1000
#define PNG_FLAG_FREE_TRNS                0x2000
#define PNG_FLAG_FREE_HIST                0x4000
#define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000L
#define PNG_FLAG_KEEP_UNSAFE_CHUNKS       0x10000L
#define PNG_FLAG_LIBRARY_MISMATCH         0x20000L

/* For use in png_set_keep_unknown, png_handle_as_unknown */
#define HANDLE_CHUNK_AS_DEFAULT   0
#define HANDLE_CHUNK_NEVER        1
#define HANDLE_CHUNK_IF_SAFE      2
#define HANDLE_CHUNK_ALWAYS       3

#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)

#define PNG_FLAG_CRC_CRITICAL_MASK  (PNG_FLAG_CRC_CRITICAL_USE | \
                                     PNG_FLAG_CRC_CRITICAL_IGNORE)

#define PNG_FLAG_CRC_MASK           (PNG_FLAG_CRC_ANCILLARY_MASK | \
                                     PNG_FLAG_CRC_CRITICAL_MASK)

/* save typing and make code easier to understand */
#define PNG_COLOR_DIST(c1, c2) (abs((int)((c1).red) - (int)((c2).red)) + \
   abs((int)((c1).green) - (int)((c2).green)) + \
   abs((int)((c1).blue) - (int)((c2).blue)))

/* variables declared in png.c - only it needs to define PNG_NO_EXTERN */
#if !defined(PNG_NO_EXTERN) || defined(PNG_ALWAYS_EXTERN)
/* place to hold the signature string for a PNG file. */
#ifdef PNG_USE_GLOBAL_ARRAYS
   PNG_EXPORT_VAR (const png_byte FARDATA) png_sig[8];
#else
#define png_sig png_sig_bytes(NULL)
#endif
#endif /* PNG_NO_EXTERN */

/* Constant strings for known chunk types.  If you need to add a chunk,
 * define the name here, and add an invocation of the macro in png.c and
 * wherever it's needed.
 */
#define PNG_IHDR const png_byte png_IHDR[5] = { 73,  72,  68,  82, '\0'}
#define PNG_IDAT const png_byte png_IDAT[5] = { 73,  68,  65,  84, '\0'}
#define PNG_IEND const png_byte png_IEND[5] = { 73,  69,  78,  68, '\0'}
#define PNG_PLTE const png_byte png_PLTE[5] = { 80,  76,  84,  69, '\0'}
#define PNG_bKGD const png_byte png_bKGD[5] = { 98,  75,  71,  68, '\0'}
#define PNG_cHRM const png_byte png_cHRM[5] = { 99,  72,  82,  77, '\0'}
#define PNG_gAMA const png_byte png_gAMA[5] = {103,  65,  77,  65, '\0'}
#define PNG_hIST const png_byte png_hIST[5] = {104,  73,  83,  84, '\0'}
#define PNG_iCCP const png_byte png_iCCP[5] = {105,  67,  67,  80, '\0'}
#define PNG_iTXt const png_byte png_iTXt[5] = {105,  84,  88, 116, '\0'}
#define PNG_oFFs const png_byte png_oFFs[5] = {111,  70,  70, 115, '\0'}
#define PNG_pCAL const png_byte png_pCAL[5] = {112,  67,  65,  76, '\0'}
#define PNG_sCAL const png_byte png_sCAL[5] = {115,  67,  65,  76, '\0'}
#define PNG_pHYs const png_byte png_pHYs[5] = {112,  72,  89, 115, '\0'}
#define PNG_sBIT const png_byte png_sBIT[5] = {115,  66,  73,  84, '\0'}
#define PNG_sPLT const png_byte png_sPLT[5] = {115,  80,  76,  84, '\0'}
#define PNG_sRGB const png_byte png_sRGB[5] = {115,  82,  71,  66, '\0'}
#define PNG_tEXt const png_byte png_tEXt[5] = {116,  69,  88, 116, '\0'}
#define PNG_tIME const png_byte png_tIME[5] = {116,  73,  77,  69, '\0'}
#define PNG_tRNS const png_byte png_tRNS[5] = {116,  82,  78,  83, '\0'}
#define PNG_zTXt const png_byte png_zTXt[5] = {122,  84,  88, 116, '\0'}

#ifdef PNG_USE_GLOBAL_ARRAYS
PNG_EXPORT_VAR (const png_byte FARDATA) png_IHDR[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_IDAT[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_IEND[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_PLTE[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_bKGD[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_cHRM[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_gAMA[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_hIST[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_iCCP[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_iTXt[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_oFFs[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_pCAL[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_sCAL[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_pHYs[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_sBIT[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_sPLT[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_sRGB[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_tEXt[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_tIME[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_tRNS[5];
PNG_EXPORT_VAR (const png_byte FARDATA) png_zTXt[5];
#endif /* PNG_USE_GLOBAL_ARRAYS */


/* Inline macros to do direct reads of bytes from the input buffer.  These
 * require that you are using an architecture that uses PNG byte ordering
 * (MSB first) and supports unaligned data storage.  I think that PowerPC
 * in big-endian mode and 680x0 are the only ones that will support this.
 * The x86 line of processors definitely do not.  The png_get_int_32()
 * routine also assumes we are using two's complement format for negative
 * values, which is almost certainly true.
 */
#if defined(PNG_READ_BIG_ENDIAN_SUPPORTED)
#  if defined(PNG_pCAL_SUPPORTED) || defined(PNG_oFFs_SUPPORTED)
#    define png_get_int_32(buf) ( *((png_int_32p) (buf)))
#  endif
#  define png_get_uint_32(buf) ( *((png_uint_32p) (buf)))
#  define png_get_uint_16(buf) ( *((png_uint_16p) (buf)))
#else
#  if defined(PNG_pCAL_SUPPORTED) || defined(PNG_oFFs_SUPPORTED)
PNG_EXTERN png_int_32 png_get_int_32 PNGARG((png_bytep buf));
#  endif
PNG_EXTERN png_uint_32 png_get_uint_32 PNGARG((png_bytep buf));
PNG_EXTERN png_uint_16 png_get_uint_16 PNGARG((png_bytep buf));
#endif /* !PNG_READ_BIG_ENDIAN_SUPPORTED */

/* Initialize png_ptr struct for reading, and allocate any other memory.
 * (old interface - DEPRECATED - use png_create_read_struct instead).
 */
extern PNG_EXPORT(void,png_read_init) PNGARG((png_structp png_ptr));
#define png_read_init(png_ptr) png_read_init_2(png_ptr, \
    PNG_LIBPNG_VER_STRING,  sizeof(png_struct), sizeof(png_info));
extern PNG_EXPORT(void,png_read_init_2) PNGARG((png_structp png_ptr,
    png_const_charp user_png_ver, png_size_t png_struct_size, png_size_t
    png_info_size));

/* Initialize png_ptr struct for writing, and allocate any other memory.
 * (old interface - DEPRECATED - use png_create_write_struct instead).
 */
extern PNG_EXPORT(void,png_write_init) PNGARG((png_structp png_ptr));
#define png_write_init(png_ptr) png_write_init_2(png_ptr, \
    PNG_LIBPNG_VER_STRING, sizeof(png_struct), sizeof(png_info));
extern PNG_EXPORT(void,png_write_init_2) PNGARG((png_structp png_ptr,
    png_const_charp user_png_ver, png_size_t png_struct_size, png_size_t
    png_info_size));

/* Allocate memory for an internal libpng struct */
PNG_EXTERN png_voidp png_create_struct PNGARG((int type));

/* Free memory from internal libpng struct */
PNG_EXTERN void png_destroy_struct PNGARG((png_voidp struct_ptr));

PNG_EXTERN png_voidp png_create_struct_2 PNGARG((int type, png_malloc_ptr
  malloc_fn));
PNG_EXTERN void png_destroy_struct_2 PNGARG((png_voidp struct_ptr,
   png_free_ptr free_fn));

/* Free any memory that info_ptr points to and reset struct. */
PNG_EXTERN void png_info_destroy PNGARG((png_structp png_ptr,
   png_infop info_ptr));

/* Function to allocate memory for zlib. */
PNG_EXTERN voidpf png_zalloc PNGARG((voidpf png_ptr, uInt items, uInt size));

/* Function to free memory for zlib */
PNG_EXTERN void png_zfree PNGARG((voidpf png_ptr, voidpf ptr));

/* Reset the CRC variable */
PNG_EXTERN void png_reset_crc PNGARG((png_structp png_ptr));

/* Write the "data" buffer to whatever output you are using. */
PNG_EXTERN void png_write_data PNGARG((png_structp png_ptr, png_bytep data,
   png_size_t length));

/* Read data from whatever input you are using into the "data" buffer */
PNG_EXTERN void png_read_data PNGARG((png_structp png_ptr, png_bytep data,
   png_size_t length));

/* Read bytes into buf, and update png_ptr->crc */
PNG_EXTERN void png_crc_read PNGARG((png_structp png_ptr, png_bytep buf,
   png_size_t length));

/* Decompress data in a chunk that uses compression */
#if defined(PNG_zTXt_SUPPORTED) || defined(PNG_iTXt_SUPPORTED) || \
    defined(PNG_iCCP_SUPPORTED) || defined(PNG_sPLT_SUPPORTED)
PNG_EXTERN png_charp png_decompress_chunk PNGARG((png_structp png_ptr,
   int comp_type, png_charp chunkdata, png_size_t chunklength,
   png_size_t prefix_length, png_size_t *data_length));
#endif

/* Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc */
PNG_EXTERN int png_crc_finish PNGARG((png_structp png_ptr, png_uint_32 skip));

/* Read the CRC from the file and compare it to the libpng calculated CRC */
PNG_EXTERN int png_crc_error PNGARG((png_structp png_ptr));

/* Calculate the CRC over a section of data.  Note that we are only
 * passing a maximum of 64K on systems that have this as a memory limit,
 * since this is the maximum buffer size we can specify.
 */
PNG_EXTERN void png_calculate_crc PNGARG((png_structp png_ptr, png_bytep ptr,
   png_size_t length));

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
PNG_EXTERN void png_flush PNGARG((png_structp png_ptr));
#endif

/* Place a 32-bit number into a buffer in PNG byte order (big-endian).
 * The only currently known PNG chunks that use signed numbers are
 * the ancillary extension chunks, oFFs and pCAL.
 */
PNG_EXTERN void png_save_uint_32 PNGARG((png_bytep buf, png_uint_32 i));

#if defined(PNG_WRITE_pCAL_SUPPORTED)
PNG_EXTERN void png_save_int_32 PNGARG((png_bytep buf, png_int_32 i));
#endif

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
PNG_EXTERN void png_save_uint_16 PNGARG((png_bytep buf, unsigned int i));

/* simple function to write the signature */
PNG_EXTERN void png_write_sig PNGARG((png_structp png_ptr));

/* write various chunks */

/* Write the IHDR chunk, and update the png_struct with the necessary
 * information.
 */
PNG_EXTERN void png_write_IHDR PNGARG((png_structp png_ptr, png_uint_32 width,
   png_uint_32 height,
   int bit_depth, int color_type, int compression_method, int filter_method,
   int interlace_method));

PNG_EXTERN void png_write_PLTE PNGARG((png_structp png_ptr, png_colorp palette,
   png_uint_32 num_pal));

PNG_EXTERN void png_write_IDAT PNGARG((png_structp png_ptr, png_bytep data,
   png_size_t length));

PNG_EXTERN void png_write_IEND PNGARG((png_structp png_ptr));

#if defined(PNG_WRITE_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
PNG_EXTERN void png_write_gAMA PNGARG((png_structp png_ptr, double file_gamma));
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
PNG_EXTERN void png_write_gAMA_fixed PNGARG((png_structp png_ptr, png_fixed_point
    file_gamma));
#endif
#endif

#if defined(PNG_WRITE_sBIT_SUPPORTED)
PNG_EXTERN void png_write_sBIT PNGARG((png_structp png_ptr, png_color_8p sbit,
   int color_type));
#endif

#if defined(PNG_WRITE_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
PNG_EXTERN void png_write_cHRM PNGARG((png_structp png_ptr,
   double white_x, double white_y,
   double red_x, double red_y, double green_x, double green_y,
   double blue_x, double blue_y));
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
PNG_EXTERN void png_write_cHRM_fixed PNGARG((png_structp png_ptr,
   png_fixed_point int_white_x, png_fixed_point int_white_y,
   png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
   int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
   png_fixed_point int_blue_y));
#endif
#endif

#if defined(PNG_WRITE_sRGB_SUPPORTED)
PNG_EXTERN void png_write_sRGB PNGARG((png_structp png_ptr,
   int intent));
#endif

#if defined(PNG_WRITE_iCCP_SUPPORTED)
PNG_EXTERN void png_write_iCCP PNGARG((png_structp png_ptr,
   png_charp name, int compression_type,
   png_charp profile, int proflen));
   /* Note to maintainer: profile should be png_bytep */
#endif

#if defined(PNG_WRITE_sPLT_SUPPORTED)
PNG_EXTERN void png_write_sPLT PNGARG((png_structp png_ptr,
   png_sPLT_tp palette));
#endif

#if defined(PNG_WRITE_tRNS_SUPPORTED)
PNG_EXTERN void png_write_tRNS PNGARG((png_structp png_ptr, png_bytep trans,
   png_color_16p values, int number, int color_type));
#endif

#if defined(PNG_WRITE_bKGD_SUPPORTED)
PNG_EXTERN void png_write_bKGD PNGARG((png_structp png_ptr,
   png_color_16p values, int color_type));
#endif

#if defined(PNG_WRITE_hIST_SUPPORTED)
PNG_EXTERN void png_write_hIST PNGARG((png_structp png_ptr, png_uint_16p hist,
   int num_hist));
#endif

#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
PNG_EXTERN png_size_t png_check_keyword PNGARG((png_structp png_ptr,
   png_charp key, png_charpp new_key));
#endif

#if defined(PNG_WRITE_tEXt_SUPPORTED)
PNG_EXTERN void png_write_tEXt PNGARG((png_structp png_ptr, png_charp key,
   png_charp text, png_size_t text_len));
#endif

#if defined(PNG_WRITE_zTXt_SUPPORTED)
PNG_EXTERN void png_write_zTXt PNGARG((png_structp png_ptr, png_charp key,
   png_charp text, png_size_t text_len, int compression));
#endif

#if defined(PNG_WRITE_iTXt_SUPPORTED)
PNG_EXTERN void png_write_iTXt PNGARG((png_structp png_ptr,
   int compression, png_charp key, png_charp lang, png_charp lang_key,
   png_charp text));
#endif

#if defined(PNG_WRITE_oFFs_SUPPORTED)
PNG_EXTERN void png_write_oFFs PNGARG((png_structp png_ptr,
   png_uint_32 x_offset, png_uint_32 y_offset, int unit_type));
#endif

#if defined(PNG_WRITE_pCAL_SUPPORTED)
PNG_EXTERN void png_write_pCAL PNGARG((png_structp png_ptr, png_charp purpose,
   png_int_32 X0, png_int_32 X1, int type, int nparams,
   png_charp units, png_charpp params));
#endif

#if defined(PNG_WRITE_pHYs_SUPPORTED)
PNG_EXTERN void png_write_pHYs PNGARG((png_structp png_ptr,
   png_uint_32 x_pixels_per_unit, png_uint_32 y_pixels_per_unit,
   int unit_type));
#endif

#if defined(PNG_WRITE_tIME_SUPPORTED)
PNG_EXTERN void png_write_tIME PNGARG((png_structp png_ptr,
   png_timep mod_time));
#endif

#if defined(PNG_WRITE_sCAL_SUPPORTED)
#if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
PNG_EXTERN void png_write_sCAL PNGARG((png_structp png_ptr,
   int unit, double width, double height));
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
PNG_EXTERN void png_write_sCAL_s PNGARG((png_structp png_ptr,
   int unit, png_charp width, png_charp height));
#endif
#endif
#endif

/* Called when finished processing a row of data */
PNG_EXTERN void png_write_finish_row PNGARG((png_structp png_ptr));

/* Internal use only.   Called before first row of data */
PNG_EXTERN void png_write_start_row PNGARG((png_structp png_ptr));

#if defined(PNG_READ_GAMMA_SUPPORTED)
PNG_EXTERN void png_build_gamma_table PNGARG((png_structp png_ptr));
#endif

/* combine a row of data, dealing with alpha, etc. if requested */
PNG_EXTERN void png_combine_row PNGARG((png_structp png_ptr, png_bytep row,
   int mask));

#if defined(PNG_READ_INTERLACING_SUPPORTED)
/* expand an interlaced row */
/* OLD pre-1.0.9 interface:
PNG_EXTERN void png_do_read_interlace PNGARG((png_row_infop row_info,
   png_bytep row, int pass, png_uint_32 transformations));
 */
PNG_EXTERN void png_do_read_interlace PNGARG((png_structp png_ptr));
#endif

/* GRR TO DO (2.0 or whenever):  simplify other internal calling interfaces */

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* grab pixels out of a row for an interlaced pass */
PNG_EXTERN void png_do_write_interlace PNGARG((png_row_infop row_info,
   png_bytep row, int pass));
#endif

/* unfilter a row */
PNG_EXTERN void png_read_filter_row PNGARG((png_structp png_ptr,
   png_row_infop row_info, png_bytep row, png_bytep prev_row, int filter));

/* Choose the best filter to use and filter the row data */
PNG_EXTERN void png_write_find_filter PNGARG((png_structp png_ptr,
   png_row_infop row_info));

/* Write out the filtered row. */
PNG_EXTERN void png_write_filtered_row PNGARG((png_structp png_ptr,
   png_bytep filtered_row));
/* finish a row while reading, dealing with interlacing passes, etc. */
PNG_EXTERN void png_read_finish_row PNGARG((png_structp png_ptr));

/* initialize the row buffers, etc. */
PNG_EXTERN void png_read_start_row PNGARG((png_structp png_ptr));
/* optional call to update the users info structure */
PNG_EXTERN void png_read_transform_info PNGARG((png_structp png_ptr,
   png_infop info_ptr));

/* these are the functions that do the transformations */
#if defined(PNG_READ_FILLER_SUPPORTED)
PNG_EXTERN void png_do_read_filler PNGARG((png_row_infop row_info,
   png_bytep row, png_uint_32 filler, png_uint_32 flags));
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
PNG_EXTERN void png_do_read_swap_alpha PNGARG((png_row_infop row_info,
   png_bytep row));
#endif

#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
PNG_EXTERN void png_do_write_swap_alpha PNGARG((png_row_infop row_info,
   png_bytep row));
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
PNG_EXTERN void png_do_read_invert_alpha PNGARG((png_row_infop row_info,
   png_bytep row));
#endif

#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
PNG_EXTERN void png_do_write_invert_alpha PNGARG((png_row_infop row_info,
   png_bytep row));
#endif

#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
PNG_EXTERN void png_do_strip_filler PNGARG((png_row_infop row_info,
   png_bytep row, png_uint_32 flags));
#endif

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
PNG_EXTERN void png_do_swap PNGARG((png_row_infop row_info, png_bytep row));
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED) || defined(PNG_WRITE_PACKSWAP_SUPPORTED)
PNG_EXTERN void png_do_packswap PNGARG((png_row_infop row_info, png_bytep row));
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
PNG_EXTERN int png_do_rgb_to_gray PNGARG((png_structp png_ptr, png_row_infop
   row_info, png_bytep row));
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
PNG_EXTERN void png_do_gray_to_rgb PNGARG((png_row_infop row_info,
   png_bytep row));
#endif

#if defined(PNG_READ_PACK_SUPPORTED)
PNG_EXTERN void png_do_unpack PNGARG((png_row_infop row_info, png_bytep row));
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED)
PNG_EXTERN void png_do_unshift PNGARG((png_row_infop row_info, png_bytep row,
   png_color_8p sig_bits));
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
PNG_EXTERN void png_do_invert PNGARG((png_row_infop row_info, png_bytep row));
#endif

#if defined(PNG_READ_16_TO_8_SUPPORTED)
PNG_EXTERN void png_do_chop PNGARG((png_row_infop row_info, png_bytep row));
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
PNG_EXTERN void png_do_dither PNGARG((png_row_infop row_info,
   png_bytep row, png_bytep palette_lookup, png_bytep dither_lookup));

#  if defined(PNG_CORRECT_PALETTE_SUPPORTED)
PNG_EXTERN void png_correct_palette PNGARG((png_structp png_ptr,
   png_colorp palette, int num_palette));
#  endif
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
PNG_EXTERN void png_do_bgr PNGARG((png_row_infop row_info, png_bytep row));
#endif

#if defined(PNG_WRITE_PACK_SUPPORTED)
PNG_EXTERN void png_do_pack PNGARG((png_row_infop row_info,
   png_bytep row, png_uint_32 bit_depth));
#endif

#if defined(PNG_WRITE_SHIFT_SUPPORTED)
PNG_EXTERN void png_do_shift PNGARG((png_row_infop row_info, png_bytep row,
   png_color_8p bit_depth));
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED)
PNG_EXTERN void png_do_background PNGARG((png_row_infop row_info, png_bytep row,
   png_color_16p trans_values, png_color_16p background,
   png_color_16p background_1,
   png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
   png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
   png_uint_16pp gamma_16_to_1, int gamma_shift));
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED)
PNG_EXTERN void png_do_gamma PNGARG((png_row_infop row_info, png_bytep row,
   png_bytep gamma_table, png_uint_16pp gamma_16_table,
   int gamma_shift));
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
PNG_EXTERN void png_do_expand_palette PNGARG((png_row_infop row_info,
   png_bytep row, png_colorp palette, png_bytep trans, int num_trans));
PNG_EXTERN void png_do_expand PNGARG((png_row_infop row_info,
   png_bytep row, png_color_16p trans_value));
#endif

/* The following decodes the appropriate chunks, and does error correction,
 * then calls the appropriate callback for the chunk if it is valid.
 */

/* decode the IHDR chunk */
PNG_EXTERN void png_handle_IHDR PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
PNG_EXTERN void png_handle_PLTE PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
PNG_EXTERN void png_handle_IEND PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));

#if defined(PNG_READ_bKGD_SUPPORTED)
PNG_EXTERN void png_handle_bKGD PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_cHRM_SUPPORTED)
PNG_EXTERN void png_handle_cHRM PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_gAMA_SUPPORTED)
PNG_EXTERN void png_handle_gAMA PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_hIST_SUPPORTED)
PNG_EXTERN void png_handle_hIST PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_iCCP_SUPPORTED)
extern void png_handle_iCCP PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif /* PNG_READ_iCCP_SUPPORTED */

#if defined(PNG_READ_iTXt_SUPPORTED)
PNG_EXTERN void png_handle_iTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_oFFs_SUPPORTED)
PNG_EXTERN void png_handle_oFFs PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_pCAL_SUPPORTED)
PNG_EXTERN void png_handle_pCAL PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_pHYs_SUPPORTED)
PNG_EXTERN void png_handle_pHYs PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_sBIT_SUPPORTED)
PNG_EXTERN void png_handle_sBIT PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_sCAL_SUPPORTED)
PNG_EXTERN void png_handle_sCAL PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_sPLT_SUPPORTED)
extern void png_handle_sPLT PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif /* PNG_READ_sPLT_SUPPORTED */

#if defined(PNG_READ_sRGB_SUPPORTED)
PNG_EXTERN void png_handle_sRGB PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_tEXt_SUPPORTED)
PNG_EXTERN void png_handle_tEXt PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_tIME_SUPPORTED)
PNG_EXTERN void png_handle_tIME PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_tRNS_SUPPORTED)
PNG_EXTERN void png_handle_tRNS PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#if defined(PNG_READ_zTXt_SUPPORTED)
PNG_EXTERN void png_handle_zTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
   png_uint_32 length));
#endif

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
PNG_EXTERN int png_handle_as_unknown PNGARG((png_structp png_ptr, png_bytep
   chunk_name));
#endif

PNG_EXTERN void png_handle_unknown PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 length));

PNG_EXTERN void png_check_chunk_name PNGARG((png_structp png_ptr,
   png_bytep chunk_name));

/* handle the transformations for reading and writing */
PNG_EXTERN void png_do_read_transformations PNGARG((png_structp png_ptr));
PNG_EXTERN void png_do_write_transformations PNGARG((png_structp png_ptr));

PNG_EXTERN void png_init_read_transformations PNGARG((png_structp png_ptr));

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
PNG_EXTERN void png_push_read_chunk PNGARG((png_structp png_ptr,
   png_infop info_ptr));
PNG_EXTERN void png_push_read_sig PNGARG((png_structp png_ptr,
   png_infop info_ptr));
PNG_EXTERN void png_push_check_crc PNGARG((png_structp png_ptr));
PNG_EXTERN void png_push_crc_skip PNGARG((png_structp png_ptr,
   png_uint_32 length));
PNG_EXTERN void png_push_crc_finish PNGARG((png_structp png_ptr));
PNG_EXTERN void png_push_fill_buffer PNGARG((png_structp png_ptr,
   png_bytep buffer, png_size_t length));
PNG_EXTERN void png_push_save_buffer PNGARG((png_structp png_ptr));
PNG_EXTERN void png_push_restore_buffer PNGARG((png_structp png_ptr,
   png_bytep buffer, png_size_t buffer_length));
PNG_EXTERN void png_push_read_IDAT PNGARG((png_structp png_ptr));
PNG_EXTERN void png_process_IDAT_data PNGARG((png_structp png_ptr,
   png_bytep buffer, png_size_t buffer_length));
PNG_EXTERN void png_push_process_row PNGARG((png_structp png_ptr));
PNG_EXTERN void png_push_handle_unknown PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 length));
PNG_EXTERN void png_push_have_info PNGARG((png_structp png_ptr,
   png_infop info_ptr));
PNG_EXTERN void png_push_have_end PNGARG((png_structp png_ptr,
   png_infop info_ptr));
PNG_EXTERN void png_push_have_row PNGARG((png_structp png_ptr, png_bytep row));
PNG_EXTERN void png_push_read_end PNGARG((png_structp png_ptr,
   png_infop info_ptr));
PNG_EXTERN void png_process_some_data PNGARG((png_structp png_ptr,
   png_infop info_ptr));
PNG_EXTERN void png_read_push_finish_row PNGARG((png_structp png_ptr));
#if defined(PNG_READ_tEXt_SUPPORTED)
PNG_EXTERN void png_push_handle_tEXt PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 length));
PNG_EXTERN void png_push_read_tEXt PNGARG((png_structp png_ptr,
   png_infop info_ptr));
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
PNG_EXTERN void png_push_handle_zTXt PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 length));
PNG_EXTERN void png_push_read_zTXt PNGARG((png_structp png_ptr,
   png_infop info_ptr));
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
PNG_EXTERN void png_push_handle_iTXt PNGARG((png_structp png_ptr,
   png_infop info_ptr, png_uint_32 length));
PNG_EXTERN void png_push_read_iTXt PNGARG((png_structp png_ptr,
   png_infop info_ptr));
#endif

#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */

#ifdef PNG_MNG_FEATURES_SUPPORTED
PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
   png_bytep row));
PNG_EXTERN void png_do_write_intrapixel PNGARG((png_row_infop row_info,
   png_bytep row));
#endif

/* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */

#endif /* PNG_INTERNAL */

#ifdef __cplusplus
}
#endif

#endif /* PNG_VERSION_INFO_ONLY */
/* do not put anything past this line */
#endif /* PNG_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngconf.h ===
/* pngconf.h - machine configurable file for libpng
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

/* Any machine specific code is near the front of this file, so if you
 * are configuring libpng for a machine, you may want to read the section
 * starting here down to where it starts to typedef png_color, png_text,
 * and png_info.
 */

#ifndef PNGCONF_H
#define PNGCONF_H

/* This is the size of the compression buffer, and thus the size of
 * an IDAT chunk.  Make this whatever size you feel is best for your
 * machine.  One of these will be allocated per png_struct.  When this
 * is full, it writes the data to the disk, and does some other
 * calculations.  Making this an extremely small size will slow
 * the library down, but you may want to experiment to determine
 * where it becomes significant, if you are concerned with memory
 * usage.  Note that zlib allocates at least 32Kb also.  For readers,
 * this describes the size of the buffer available to read the data in.
 * Unless this gets smaller than the size of a row (compressed),
 * it should not make much difference how big this is.
 */

#ifndef PNG_ZBUF_SIZE
#  define PNG_ZBUF_SIZE 8192
#endif

/* Enable if you want a write-only libpng */

#ifndef PNG_NO_READ_SUPPORTED
#  define PNG_READ_SUPPORTED
#endif

/* Enable if you want a read-only libpng */

#ifndef PNG_NO_WRITE_SUPPORTED
#  define PNG_WRITE_SUPPORTED
#endif

/* Enable if you need to support PNGs that are embedded in MNG
   datastreams */
/*
#ifndef PNG_NO_MNG_FEATURES
#  ifndef PNG_MNG_FEATURES_SUPPORTED
#    define PNG_MNG_FEATURES_SUPPORTED
#  endif
#endif
*/

#ifndef PNG_NO_FLOATING_POINT_SUPPORTED
#  ifndef PNG_FLOATING_POINT_SUPPORTED
#    define PNG_FLOATING_POINT_SUPPORTED
#  endif
#endif

/* If you are running on a machine where you cannot allocate more
 * than 64K of memory at once, uncomment this.  While libpng will not
 * normally need that much memory in a chunk (unless you load up a very
 * large file), zlib needs to know how big of a chunk it can use, and
 * libpng thus makes sure to check any memory allocation to verify it
 * will fit into memory.
#define PNG_MAX_MALLOC_64K
 */
#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
#  define PNG_MAX_MALLOC_64K
#endif

/* Special munging to support doing things the 'cygwin' way:
 * 'Normal' png-on-win32 defines/defaults:
 *   PNG_BUILD_DLL -- building dll
 *   PNG_USE_DLL   -- building an application, linking to dll
 *   (no define)   -- building static library, or building an
 *                    application and linking to the static lib
 * 'Cygwin' defines/defaults:
 *   PNG_BUILD_DLL -- building the dll
 *   (no define)   -- building an application, linking to the dll
 *   PNG_STATIC    -- building the static lib, or building an application
 *                    that links to the static lib.
 *   ALL_STATIC    -- building various static libs, or building an application
 *                    that links to the static libs.
 * Thus,
 * a cygwin user should define either PNG_BUILD_DLL or PNG_STATIC, and
 * this bit of #ifdefs will define the 'correct' config variables based on
 * that. If a cygwin user *wants* to define 'PNG_USE_DLL' that's okay, but
 * unnecessary.
 */
#if defined(__CYGWIN__)
#  if defined(PNG_BUILD_DLL)
#    if defined(PNG_USE_DLL)
#      undef PNG_USE_DLL
#    endif
#    if !defined(PNG_DLL)
#      define PNG_DLL
#    endif
#    if defined(PNG_STATIC)
#      undef PNG_STATIC
#    endif
#  else
#    if defined(ALL_STATIC)
#      define PNG_STATIC
#    endif
#    if defined(PNG_STATIC)
#      if defined(PNG_USE_DLL)
#        undef PNG_USE_DLL
#      endif
#      if defined(PNG_DLL)
#        undef PNG_DLL
#      endif
#    else
#      if defined(PNG_USE_DLL)
#        if !defined(PNG_DLL)
#          define PNG_DLL
#        endif
#      else
#        if defined(PNG_DLL)
#           define PNG_USE_DLL
#        else
#           define PNG_USE_DLL
#           define PNG_DLL
#        endif
#      endif
#    endif
#  endif
#endif


/* This protects us against compilers that run on a windowing system
 * and thus don't have or would rather us not use the stdio types:
 * stdin, stdout, and stderr.  The only one currently used is stderr
 * in png_error() and png_warning().  #defining PNG_NO_CONSOLE_IO will
 * prevent these from being compiled and used. #defining PNG_NO_STDIO
 * will also prevent these, plus will prevent the entire set of stdio
 * macros and functions (FILE *, printf, etc.) from being compiled and used,
 * unless (PNG_DEBUG > 0) has been #defined.
 *
 * #define PNG_NO_CONSOLE_IO
 * #define PNG_NO_STDIO
 */

#if defined(_WIN32_WCE)
#  include <windows.h>
   /* Console I/O functions are not supported on WindowsCE */
#  define PNG_NO_CONSOLE_IO
#  ifdef PNG_DEBUG
#    undef PNG_DEBUG
#  endif
#endif

#ifdef PNG_BUILD_DLL
#  ifndef PNG_CONSOLE_IO_SUPPORTED
#    ifndef PNG_NO_CONSOLE_IO
#      define PNG_NO_CONSOLE_IO
#    endif
#  endif
#endif

#  ifdef PNG_NO_STDIO
#    ifndef PNG_NO_CONSOLE_IO
#      define PNG_NO_CONSOLE_IO
#    endif
#    ifdef PNG_DEBUG
#      if (PNG_DEBUG > 0)
#        include <stdio.h>
#      endif
#    endif
#  else
#    if !defined(_WIN32_WCE)
/* "stdio.h" functions are not supported on WindowsCE */
#      include <stdio.h>
#    endif
#  endif

/* This macro protects us against machines that don't have function
 * prototypes (ie K&R style headers).  If your compiler does not handle
 * function prototypes, define this macro and use the included ansi2knr.
 * I've always been able to use _NO_PROTO as the indicator, but you may
 * need to drag the empty declaration out in front of here, or change the
 * ifdef to suit your own needs.
 */
#ifndef PNGARG

#ifdef OF /* zlib prototype munger */
#  define PNGARG(arglist) OF(arglist)
#else

#ifdef _NO_PROTO
#  define PNGARG(arglist) ()
#else
#  define PNGARG(arglist) arglist
#endif /* _NO_PROTO */

#endif /* OF */

#endif /* PNGARG */

/* Try to determine if we are compiling on a Mac.  Note that testing for
 * just __MWERKS__ is not good enough, because the Codewarrior is now used
 * on non-Mac platforms.
 */
#ifndef MACOS
#  if (defined(__MWERKS__) && defined(macintosh)) || defined(applec) || \
      defined(THINK_C) || defined(__SC__) || defined(TARGET_OS_MAC)
#    define MACOS
#  endif
#endif

/* enough people need this for various reasons to include it here */
#if !defined(MACOS) && !defined(RISCOS) && !defined(_WIN32_WCE)
#  include <sys/types.h>
#endif

#ifndef PNG_SETJMP_NOT_SUPPORTED
#  define PNG_SETJMP_SUPPORTED
#endif

#ifdef PNG_SETJMP_SUPPORTED
/* This is an attempt to force a single setjmp behaviour on Linux.  If
 * the X config stuff didn't define _BSD_SOURCE we wouldn't need this.
 */

#  ifdef __linux__
#    ifdef _BSD_SOURCE
#      define PNG_SAVE_BSD_SOURCE
#      undef _BSD_SOURCE
#    endif
#    ifdef _SETJMP_H
      __png.h__ already includes setjmp.h;
      __dont__ include it again.;
#    endif
#  endif /* __linux__ */

   /* include setjmp.h for error handling */
#  include <setjmp.h>

#  ifdef __linux__
#    ifdef PNG_SAVE_BSD_SOURCE
#      define _BSD_SOURCE
#      undef PNG_SAVE_BSD_SOURCE
#    endif
#  endif /* __linux__ */
#endif /* PNG_SETJMP_SUPPORTED */

#ifdef BSD
#  include <strings.h>
#else
#  include <string.h>
#endif

/* Other defines for things like memory and the like can go here.  */
#ifdef PNG_INTERNAL

#include <stdlib.h>

/* The functions exported by PNG_EXTERN are PNG_INTERNAL functions, which
 * aren't usually used outside the library (as far as I know), so it is
 * debatable if they should be exported at all.  In the future, when it is
 * possible to have run-time registry of chunk-handling functions, some of
 * these will be made available again.
#define PNG_EXTERN extern
 */
#define PNG_EXTERN

/* Other defines specific to compilers can go here.  Try to keep
 * them inside an appropriate ifdef/endif pair for portability.
 */

#if defined(PNG_FLOATING_POINT_SUPPORTED)
#  if defined(MACOS)
     /* We need to check that <math.h> hasn't already been included earlier
      * as it seems it doesn't agree with <fp.h>, yet we should really use
      * <fp.h> if possible.
      */
#    if !defined(__MATH_H__) && !defined(__MATH_H) && !defined(__cmath__)
#      include <fp.h>
#    endif
#  else
#    include <math.h>
#  endif
#  if defined(_AMIGA) && defined(__SASC) && defined(_M68881)
     /* Amiga SAS/C: We must include builtin FPU functions when compiling using
      * MATH=68881
      */
#    include <m68881.h>
#  endif
#endif

/* Codewarrior on NT has linking problems without this. */
#if (defined(__MWERKS__) && defined(WIN32)) || defined(__STDC__)
#  define PNG_ALWAYS_EXTERN
#endif

/* For some reason, Borland C++ defines memcmp, etc. in mem.h, not
 * stdlib.h like it should (I think).  Or perhaps this is a C++
 * "feature"?
 */
#ifdef __TURBOC__
#  include <mem.h>
#  include "alloc.h"
#endif

#ifdef _MSC_VER
#  include <malloc.h>
#endif

/* This controls how fine the dithering gets.  As this allocates
 * a largish chunk of memory (32K), those who are not as concerned
 * with dithering quality can decrease some or all of these.
 */
#ifndef PNG_DITHER_RED_BITS
#  define PNG_DITHER_RED_BITS 5
#endif
#ifndef PNG_DITHER_GREEN_BITS
#  define PNG_DITHER_GREEN_BITS 5
#endif
#ifndef PNG_DITHER_BLUE_BITS
#  define PNG_DITHER_BLUE_BITS 5
#endif

/* This controls how fine the gamma correction becomes when you
 * are only interested in 8 bits anyway.  Increasing this value
 * results in more memory being used, and more pow() functions
 * being called to fill in the gamma tables.  Don't set this value
 * less then 8, and even that may not work (I haven't tested it).
 */

#ifndef PNG_MAX_GAMMA_8
#  define PNG_MAX_GAMMA_8 11
#endif

/* This controls how much a difference in gamma we can tolerate before
 * we actually start doing gamma conversion.
 */
#ifndef PNG_GAMMA_THRESHOLD
#  define PNG_GAMMA_THRESHOLD 0.05
#endif

#endif /* PNG_INTERNAL */

/* The following uses const char * instead of char * for error
 * and warning message functions, so some compilers won't complain.
 * If you do not want to use const, define PNG_NO_CONST here.
 */

#ifndef PNG_NO_CONST
#  define PNG_CONST const
#else
#  define PNG_CONST
#endif

/* The following defines give you the ability to remove code from the
 * library that you will not be using.  I wish I could figure out how to
 * automate this, but I can't do that without making it seriously hard
 * on the users.  So if you are not using an ability, change the #define
 * to and #undef, and that part of the library will not be compiled.  If
 * your linker can't find a function, you may want to make sure the
 * ability is defined here.  Some of these depend upon some others being
 * defined.  I haven't figured out all the interactions here, so you may
 * have to experiment awhile to get everything to compile.  If you are
 * creating or using a shared library, you probably shouldn't touch this,
 * as it will affect the size of the structures, and this will cause bad
 * things to happen if the library and/or application ever change.
 */

/* Any features you will not be using can be undef'ed here */

/* GR-P, 0.96a: Set "*TRANSFORMS_SUPPORTED as default but allow user
 * to turn it off with "*TRANSFORMS_NOT_SUPPORTED" or *PNG_NO_*_TRANSFORMS
 * on the compile line, then pick and choose which ones to define without
 * having to edit this file. It is safe to use the *TRANSFORMS_NOT_SUPPORTED
 * if you only want to have a png-compliant reader/writer but don't need
 * any of the extra transformations.  This saves about 80 kbytes in a
 * typical installation of the library. (PNG_NO_* form added in version
 * 1.0.1c, for consistency)
 */

/* The size of the png_text structure changed in libpng-1.0.6 when
 * iTXt is supported.  It is turned off by default, to support old apps
 * that malloc the png_text structure instead of calling png_set_text()
 * and letting libpng malloc it.  It will be turned on by default in
 * libpng-1.3.0.
 */

#ifndef PNG_iTXt_SUPPORTED
#  ifndef PNG_READ_iTXt_SUPPORTED
#    define PNG_NO_READ_iTXt
#  endif
#  ifndef PNG_WRITE_iTXt_SUPPORTED
#    define PNG_NO_WRITE_iTXt
#  endif
#endif

/* The following support, added after version 1.0.0, can be turned off here en
 * masse by defining PNG_LEGACY_SUPPORTED in case you need binary compatibility
 * with old applications that require the length of png_struct and png_info
 * to remain unchanged.
 */

#ifdef PNG_LEGACY_SUPPORTED
#  define PNG_NO_FREE_ME
#  define PNG_NO_READ_UNKNOWN_CHUNKS
#  define PNG_NO_WRITE_UNKNOWN_CHUNKS
#  define PNG_NO_READ_USER_CHUNKS
#  define PNG_NO_READ_iCCP
#  define PNG_NO_WRITE_iCCP
#  define PNG_NO_READ_iTXt
#  define PNG_NO_WRITE_iTXt
#  define PNG_NO_READ_sCAL
#  define PNG_NO_WRITE_sCAL
#  define PNG_NO_READ_sPLT
#  define PNG_NO_WRITE_sPLT
#  define PNG_NO_INFO_IMAGE
#  define PNG_NO_READ_RGB_TO_GRAY
#  define PNG_NO_READ_USER_TRANSFORM
#  define PNG_NO_WRITE_USER_TRANSFORM
#  define PNG_NO_USER_MEM
#  define PNG_NO_READ_EMPTY_PLTE
#  define PNG_NO_MNG_FEATURES
#  define PNG_NO_FIXED_POINT_SUPPORTED
#endif

/* Ignore attempt to turn off both floating and fixed point support */
#if !defined(PNG_FLOATING_POINT_SUPPORTED) || \
    !defined(PNG_NO_FIXED_POINT_SUPPORTED)
#  define PNG_FIXED_POINT_SUPPORTED
#endif

#ifndef PNG_NO_FREE_ME
#  define PNG_FREE_ME_SUPPORTED
#endif

#if defined(PNG_READ_SUPPORTED)

#if !defined(PNG_READ_TRANSFORMS_NOT_SUPPORTED) && \
      !defined(PNG_NO_READ_TRANSFORMS)
#  define PNG_READ_TRANSFORMS_SUPPORTED
#endif

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
#  ifndef PNG_NO_READ_EXPAND
#    define PNG_READ_EXPAND_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_SHIFT
#    define PNG_READ_SHIFT_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_PACK
#    define PNG_READ_PACK_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_BGR
#    define PNG_READ_BGR_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_SWAP
#    define PNG_READ_SWAP_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_PACKSWAP
#    define PNG_READ_PACKSWAP_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_INVERT
#    define PNG_READ_INVERT_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_DITHER
#    define PNG_READ_DITHER_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_BACKGROUND
#    define PNG_READ_BACKGROUND_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_16_TO_8
#    define PNG_READ_16_TO_8_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_FILLER
#    define PNG_READ_FILLER_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_GAMMA
#    define PNG_READ_GAMMA_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_GRAY_TO_RGB
#    define PNG_READ_GRAY_TO_RGB_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_SWAP_ALPHA
#    define PNG_READ_SWAP_ALPHA_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_INVERT_ALPHA
#    define PNG_READ_INVERT_ALPHA_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_STRIP_ALPHA
#    define PNG_READ_STRIP_ALPHA_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_USER_TRANSFORM
#    define PNG_READ_USER_TRANSFORM_SUPPORTED
#  endif
#  ifndef PNG_NO_READ_RGB_TO_GRAY
#    define PNG_READ_RGB_TO_GRAY_SUPPORTED
#  endif
#endif /* PNG_READ_TRANSFORMS_SUPPORTED */

#if !defined(PNG_NO_PROGRESSIVE_READ) && \
 !defined(PNG_PROGRESSIVE_READ_NOT_SUPPORTED)  /* if you don't do progressive */
#  define PNG_PROGRESSIVE_READ_SUPPORTED     /* reading.  This is not talking */
#endif                               /* about interlacing capability!  You'll */
              /* still have interlacing unless you change the following line: */

#define PNG_READ_INTERLACING_SUPPORTED /* required for PNG-compliant decoders */

#ifndef PNG_NO_READ_COMPOSITE_NODIV
#  ifndef PNG_NO_READ_COMPOSITED_NODIV  /* libpng-1.0.x misspelling */
#    define PNG_READ_COMPOSITE_NODIV_SUPPORTED   /* well tested on Intel, SGI */
#  endif
#endif

/* Deprecated, will be removed from version 2.0.0.
   Use PNG_MNG_FEATURES_SUPPORTED instead. */
#ifndef PNG_NO_READ_EMPTY_PLTE
#  define PNG_READ_EMPTY_PLTE_SUPPORTED
#endif

#endif /* PNG_READ_SUPPORTED */

#if defined(PNG_WRITE_SUPPORTED)

# if !defined(PNG_WRITE_TRANSFORMS_NOT_SUPPORTED) && \
    !defined(PNG_NO_WRITE_TRANSFORMS)
#  define PNG_WRITE_TRANSFORMS_SUPPORTED
#endif

#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
#  ifndef PNG_NO_WRITE_SHIFT
#    define PNG_WRITE_SHIFT_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_PACK
#    define PNG_WRITE_PACK_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_BGR
#    define PNG_WRITE_BGR_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_SWAP
#    define PNG_WRITE_SWAP_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_PACKSWAP
#    define PNG_WRITE_PACKSWAP_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_INVERT
#    define PNG_WRITE_INVERT_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_FILLER
#    define PNG_WRITE_FILLER_SUPPORTED   /* same as WRITE_STRIP_ALPHA */
#  endif
#  ifndef PNG_NO_WRITE_SWAP_ALPHA
#    define PNG_WRITE_SWAP_ALPHA_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_INVERT_ALPHA
#    define PNG_WRITE_INVERT_ALPHA_SUPPORTED
#  endif
#  ifndef PNG_NO_WRITE_USER_TRANSFORM
#    define PNG_WRITE_USER_TRANSFORM_SUPPORTED
#  endif
#endif /* PNG_WRITE_TRANSFORMS_SUPPORTED */

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
#  ifndef PNG_NO_USER_TRANSFORM_PTR
#    define PNG_USER_TRANSFORM_PTR_SUPPORTED
#  endif
#endif

#define PNG_WRITE_INTERLACING_SUPPORTED  /* not required for PNG-compliant
                                            encoders, but can cause trouble
                                            if left undefined */

#if !defined(PNG_NO_WRITE_WEIGHTED_FILTER) && \
     defined(PNG_FLOATING_POINT_SUPPORTED)
#  define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
#endif

#ifndef PNG_NO_WRITE_FLUSH
#  define PNG_WRITE_FLUSH_SUPPORTED
#endif

/* Deprecated, see PNG_MNG_FEATURES_SUPPORTED, above */
#ifndef PNG_NO_WRITE_EMPTY_PLTE
#  define PNG_WRITE_EMPTY_PLTE_SUPPORTED
#endif

#endif /* PNG_WRITE_SUPPORTED */

#ifndef PNG_NO_STDIO
#  define PNG_TIME_RFC1123_SUPPORTED
#endif

/* This adds extra functions in pngget.c for accessing data from the
 * info pointer (added in version 0.99)
 * png_get_image_width()
 * png_get_image_height()
 * png_get_bit_depth()
 * png_get_color_type()
 * png_get_compression_type()
 * png_get_filter_type()
 * png_get_interlace_type()
 * png_get_pixel_aspect_ratio()
 * png_get_pixels_per_meter()
 * png_get_x_offset_pixels()
 * png_get_y_offset_pixels()
 * png_get_x_offset_microns()
 * png_get_y_offset_microns()
 */
#ifndef PNG_NO_EASY_ACCESS
#  define PNG_EASY_ACCESS_SUPPORTED
#endif

/* PNG_ASSEMBLER_CODE will be enabled by default in version 1.2.0 
   even when PNG_USE_PNGVCRD or PNG_USE_PNGGCCRD is not defined */
#if defined(PNG_READ_SUPPORTED) && !defined(PNG_NO_ASSEMBLER_CODE)
#  if defined(PNG_USE_PNGVCRD) || defined(PNG_USE_PNGGCCRD)
#    ifndef PNG_ASSEMBLER_CODE_SUPPORTED
#      define PNG_ASSEMBLER_CODE_SUPPORTED
#    endif
#    if !defined(PNG_MMX_CODE_SUPPORTED) && !defined(PNG_NO_MMX_CODE)
#      define PNG_MMX_CODE_SUPPORTED
#    endif
#  endif
#endif

/* These are currently experimental features, define them if you want */

/* very little testing */
/*
#ifdef PNG_READ_SUPPORTED
#  ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
#    define PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_USER_MEM
#  define PNG_USER_MEM_SUPPORTED
#endif
#ifndef PNG_NO_ZALLOC_ZERO
#  define PNG_ZALLOC_ZERO
#endif
*/

/* This is only for PowerPC big-endian and 680x0 systems */
/* some testing */
/*
#ifdef PNG_READ_SUPPORTED
#  ifndef PNG_PNG_READ_BIG_ENDIAN_SUPPORTED
#    define PNG_READ_BIG_ENDIAN_SUPPORTED
#  endif
#endif
*/

/* Buggy compilers (e.g., gcc 2.7.2.2) need this */
/*
#define PNG_NO_POINTER_INDEXING
*/

/* These functions are turned off by default, as they will be phased out. */
/*
#define  PNG_USELESS_TESTS_SUPPORTED
#define  PNG_CORRECT_PALETTE_SUPPORTED
*/

/* Any chunks you are not interested in, you can undef here.  The
 * ones that allocate memory may be expecially important (hIST,
 * tEXt, zTXt, tRNS, pCAL).  Others will just save time and make png_info
 * a bit smaller.
 */

#if defined(PNG_READ_SUPPORTED) && \
    !defined(PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED) && \
    !defined(PNG_NO_READ_ANCILLARY_CHUNKS)
#  define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
#endif

#if defined(PNG_WRITE_SUPPORTED) && \
    !defined(PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED) && \
    !defined(PNG_NO_WRITE_ANCILLARY_CHUNKS)
#  define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
#endif

#ifdef PNG_READ_ANCILLARY_CHUNKS_SUPPORTED

#ifdef PNG_NO_READ_TEXT
#  define PNG_NO_READ_iTXt
#  define PNG_NO_READ_tEXt
#  define PNG_NO_READ_zTXt
#endif
#ifndef PNG_NO_READ_bKGD
#  define PNG_READ_bKGD_SUPPORTED
#  define PNG_bKGD_SUPPORTED
#endif
#ifndef PNG_NO_READ_cHRM
#  define PNG_READ_cHRM_SUPPORTED
#  define PNG_cHRM_SUPPORTED
#endif
#ifndef PNG_NO_READ_gAMA
#  define PNG_READ_gAMA_SUPPORTED
#  define PNG_gAMA_SUPPORTED
#endif
#ifndef PNG_NO_READ_hIST
#  define PNG_READ_hIST_SUPPORTED
#  define PNG_hIST_SUPPORTED
#endif
#ifndef PNG_NO_READ_iCCP
#  define PNG_READ_iCCP_SUPPORTED
#  define PNG_iCCP_SUPPORTED
#endif
#ifndef PNG_NO_READ_iTXt
#  define PNG_READ_iTXt_SUPPORTED
#  define PNG_iTXt_SUPPORTED
#endif
#ifndef PNG_NO_READ_oFFs
#  define PNG_READ_oFFs_SUPPORTED
#  define PNG_oFFs_SUPPORTED
#endif
#ifndef PNG_NO_READ_pCAL
#  define PNG_READ_pCAL_SUPPORTED
#  define PNG_pCAL_SUPPORTED
#endif
#ifndef PNG_NO_READ_sCAL
#  define PNG_READ_sCAL_SUPPORTED
#  define PNG_sCAL_SUPPORTED
#endif
#ifndef PNG_NO_READ_pHYs
#  define PNG_READ_pHYs_SUPPORTED
#  define PNG_pHYs_SUPPORTED
#endif
#ifndef PNG_NO_READ_sBIT
#  define PNG_READ_sBIT_SUPPORTED
#  define PNG_sBIT_SUPPORTED
#endif
#ifndef PNG_NO_READ_sPLT
#  define PNG_READ_sPLT_SUPPORTED
#  define PNG_sPLT_SUPPORTED
#endif
#ifndef PNG_NO_READ_sRGB
#  define PNG_READ_sRGB_SUPPORTED
#  define PNG_sRGB_SUPPORTED
#endif
#ifndef PNG_NO_READ_tEXt
#  define PNG_READ_tEXt_SUPPORTED
#  define PNG_tEXt_SUPPORTED
#endif
#ifndef PNG_NO_READ_tIME
#  define PNG_READ_tIME_SUPPORTED
#  define PNG_tIME_SUPPORTED
#endif
#ifndef PNG_NO_READ_tRNS
#  define PNG_READ_tRNS_SUPPORTED
#  define PNG_tRNS_SUPPORTED
#endif
#ifndef PNG_NO_READ_zTXt
#  define PNG_READ_zTXt_SUPPORTED
#  define PNG_zTXt_SUPPORTED
#endif
#ifndef PNG_NO_READ_UNKNOWN_CHUNKS
#  define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
#  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
#    define PNG_UNKNOWN_CHUNKS_SUPPORTED
#  endif
#  ifndef PNG_NO_HANDLE_AS_UNKNOWN
#    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#  endif
#endif
#if !defined(PNG_NO_READ_USER_CHUNKS) && \
     defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
#  define PNG_READ_USER_CHUNKS_SUPPORTED
#  define PNG_USER_CHUNKS_SUPPORTED
#  ifdef PNG_NO_READ_UNKNOWN_CHUNKS
#    undef PNG_NO_READ_UNKNOWN_CHUNKS
#  endif
#  ifdef PNG_NO_HANDLE_AS_UNKNOWN
#    undef PNG_NO_HANDLE_AS_UNKNOWN
#  endif
#endif
#ifndef PNG_NO_READ_OPT_PLTE
#  define PNG_READ_OPT_PLTE_SUPPORTED /* only affects support of the */
#endif                      /* optional PLTE chunk in RGB and RGBA images */
#if defined(PNG_READ_iTXt_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) || \
    defined(PNG_READ_zTXt_SUPPORTED)
#  define PNG_READ_TEXT_SUPPORTED
#  define PNG_TEXT_SUPPORTED
#endif

#endif /* PNG_READ_ANCILLARY_CHUNKS_SUPPORTED */

#ifdef PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED

#ifdef PNG_NO_WRITE_TEXT
#  define PNG_NO_WRITE_iTXt
#  define PNG_NO_WRITE_tEXt
#  define PNG_NO_WRITE_zTXt
#endif
#ifndef PNG_NO_WRITE_bKGD
#  define PNG_WRITE_bKGD_SUPPORTED
#  ifndef PNG_bKGD_SUPPORTED
#    define PNG_bKGD_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_cHRM
#  define PNG_WRITE_cHRM_SUPPORTED
#  ifndef PNG_cHRM_SUPPORTED
#    define PNG_cHRM_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_gAMA
#  define PNG_WRITE_gAMA_SUPPORTED
#  ifndef PNG_gAMA_SUPPORTED
#    define PNG_gAMA_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_hIST
#  define PNG_WRITE_hIST_SUPPORTED
#  ifndef PNG_hIST_SUPPORTED
#    define PNG_hIST_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_iCCP
#  define PNG_WRITE_iCCP_SUPPORTED
#  ifndef PNG_iCCP_SUPPORTED
#    define PNG_iCCP_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_iTXt
#  define PNG_WRITE_iTXt_SUPPORTED
#  ifndef PNG_iTXt_SUPPORTED
#    define PNG_iTXt_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_oFFs
#  define PNG_WRITE_oFFs_SUPPORTED
#  ifndef PNG_oFFs_SUPPORTED
#    define PNG_oFFs_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_pCAL
#  define PNG_WRITE_pCAL_SUPPORTED
#  ifndef PNG_pCAL_SUPPORTED
#    define PNG_pCAL_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_sCAL
#  define PNG_WRITE_sCAL_SUPPORTED
#  ifndef PNG_sCAL_SUPPORTED
#    define PNG_sCAL_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_pHYs
#  define PNG_WRITE_pHYs_SUPPORTED
#  ifndef PNG_pHYs_SUPPORTED
#    define PNG_pHYs_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_sBIT
#  define PNG_WRITE_sBIT_SUPPORTED
#  ifndef PNG_sBIT_SUPPORTED
#    define PNG_sBIT_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_sPLT
#  define PNG_WRITE_sPLT_SUPPORTED
#  ifndef PNG_sPLT_SUPPORTED
#    define PNG_sPLT_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_sRGB
#  define PNG_WRITE_sRGB_SUPPORTED
#  ifndef PNG_sRGB_SUPPORTED
#    define PNG_sRGB_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_tEXt
#  define PNG_WRITE_tEXt_SUPPORTED
#  ifndef PNG_tEXt_SUPPORTED
#    define PNG_tEXt_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_tIME
#  define PNG_WRITE_tIME_SUPPORTED
#  ifndef PNG_tIME_SUPPORTED
#    define PNG_tIME_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_tRNS
#  define PNG_WRITE_tRNS_SUPPORTED
#  ifndef PNG_tRNS_SUPPORTED
#    define PNG_tRNS_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_zTXt
#  define PNG_WRITE_zTXt_SUPPORTED
#  ifndef PNG_zTXt_SUPPORTED
#    define PNG_zTXt_SUPPORTED
#  endif
#endif
#ifndef PNG_NO_WRITE_UNKNOWN_CHUNKS
#  define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
#  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
#    define PNG_UNKNOWN_CHUNKS_SUPPORTED
#  endif
#  ifndef PNG_NO_HANDLE_AS_UNKNOWN
#     ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#       define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#     endif
#  endif
#endif
#if defined(PNG_WRITE_iTXt_SUPPORTED) || defined(PNG_WRITE_tEXt_SUPPORTED) || \
    defined(PNG_WRITE_zTXt_SUPPORTED)
#  define PNG_WRITE_TEXT_SUPPORTED
#  ifndef PNG_TEXT_SUPPORTED
#    define PNG_TEXT_SUPPORTED
#  endif
#endif

#endif /* PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED */

/* Turn this off to disable png_read_png() and
 * png_write_png() and leave the row_pointers member
 * out of the info structure.
 */
#ifndef PNG_NO_INFO_IMAGE
#  define PNG_INFO_IMAGE_SUPPORTED
#endif

/* need the time information for reading tIME chunks */
#if defined(PNG_tIME_SUPPORTED)
#  if !defined(_WIN32_WCE)
     /* "time.h" functions are not supported on WindowsCE */
#    include <time.h>
#  endif
#endif

/* Some typedefs to get us started.  These should be safe on most of the
 * common platforms.  The typedefs should be at least as large as the
 * numbers suggest (a png_uint_32 must be at least 32 bits long), but they
 * don't have to be exactly that size.  Some compilers dislike passing
 * unsigned shorts as function parameters, so you may be better off using
 * unsigned int for png_uint_16.  Likewise, for 64-bit systems, you may
 * want to have unsigned int for png_uint_32 instead of unsigned long.
 */

typedef unsigned long png_uint_32;
typedef long png_int_32;
typedef unsigned short png_uint_16;
typedef short png_int_16;
typedef unsigned char png_byte;

/* This is usually size_t.  It is typedef'ed just in case you need it to
   change (I'm not sure if you will or not, so I thought I'd be safe) */
typedef size_t png_size_t;

/* The following is needed for medium model support.  It cannot be in the
 * PNG_INTERNAL section.  Needs modification for other compilers besides
 * MSC.  Model independent support declares all arrays and pointers to be
 * large using the far keyword.  The zlib version used must also support
 * model independent data.  As of version zlib 1.0.4, the necessary changes
 * have been made in zlib.  The USE_FAR_KEYWORD define triggers other
 * changes that are needed. (Tim Wegner)
 */

/* Separate compiler dependencies (problem here is that zlib.h always
   defines FAR. (SJT) */
#ifdef __BORLANDC__
#  if defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
#    define LDATA 1
#  else
#    define LDATA 0
#  endif
   /* GRR:  why is Cygwin in here?  Cygwin is not Borland C... */
#  if !defined(__WIN32__) && !defined(__FLAT__) && !defined(__CYGWIN__)
#    define PNG_MAX_MALLOC_64K
#    if (LDATA != 1)
#      ifndef FAR
#        define FAR __far
#      endif
#      define USE_FAR_KEYWORD
#    endif   /* LDATA != 1 */
     /* Possibly useful for moving data out of default segment.
      * Uncomment it if you want. Could also define FARDATA as
      * const if your compiler supports it. (SJT)
#    define FARDATA FAR
      */
#  endif  /* __WIN32__, __FLAT__, __CYGWIN__ */
#endif   /* __BORLANDC__ */


/* Suggest testing for specific compiler first before testing for
 * FAR.  The Watcom compiler defines both __MEDIUM__ and M_I86MM,
 * making reliance oncertain keywords suspect. (SJT)
 */

/* MSC Medium model */
#if defined(FAR)
#  if defined(M_I86MM)
#    define USE_FAR_KEYWORD
#    define FARDATA FAR
#    include <dos.h>
#  endif
#endif

/* SJT: default case */
#ifndef FAR
#  define FAR
#endif

/* At this point FAR is always defined */
#ifndef FARDATA
#  define FARDATA
#endif

/* Typedef for floating-point numbers that are converted
   to fixed-point with a multiple of 100,000, e.g., int_gamma */
typedef png_int_32 png_fixed_point;

/* Add typedefs for pointers */
typedef void            FAR * png_voidp;
typedef png_byte        FAR * png_bytep;
typedef png_uint_32     FAR * png_uint_32p;
typedef png_int_32      FAR * png_int_32p;
typedef png_uint_16     FAR * png_uint_16p;
typedef png_int_16      FAR * png_int_16p;
typedef PNG_CONST char  FAR * png_const_charp;
typedef char            FAR * png_charp;
typedef png_fixed_point FAR * png_fixed_point_p;

#ifndef PNG_NO_STDIO
#if defined(_WIN32_WCE)
typedef HANDLE                png_FILE_p;
#else
typedef FILE                * png_FILE_p;
#endif
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double          FAR * png_doublep;
#endif

/* Pointers to pointers; i.e. arrays */
typedef png_byte        FAR * FAR * png_bytepp;
typedef png_uint_32     FAR * FAR * png_uint_32pp;
typedef png_int_32      FAR * FAR * png_int_32pp;
typedef png_uint_16     FAR * FAR * png_uint_16pp;
typedef png_int_16      FAR * FAR * png_int_16pp;
typedef PNG_CONST char  FAR * FAR * png_const_charpp;
typedef char            FAR * FAR * png_charpp;
typedef png_fixed_point FAR * FAR * png_fixed_point_pp;
#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double          FAR * FAR * png_doublepp;
#endif

/* Pointers to pointers to pointers; i.e., pointer to array */
typedef char            FAR * FAR * FAR * png_charppp;

/* libpng typedefs for types in zlib. If zlib changes
 * or another compression library is used, then change these.
 * Eliminates need to change all the source files.
 */
typedef charf *         png_zcharp;
typedef charf * FAR *   png_zcharpp;
typedef z_stream FAR *  png_zstreamp;

/*
 * Define PNG_BUILD_DLL if the module being built is a Windows
 * LIBPNG DLL.
 *
 * Define PNG_USE_DLL if you want to *link* to the Windows LIBPNG DLL.
 * It is equivalent to Microsoft predefined macro _DLL that is
 * automatically defined when you compile using the share
 * version of the CRT (C Run-Time library)
 *
 * The cygwin mods make this behavior a little different:
 * Define PNG_BUILD_DLL if you are building a dll for use with cygwin
 * Define PNG_STATIC if you are building a static library for use with cygwin,
 *   -or- if you are building an application that you want to link to the
 *   static library.
 * PNG_USE_DLL is defined by default (no user action needed) unless one of
 *   the other flags is defined.
 */

#if !defined(PNG_DLL) && (defined(PNG_BUILD_DLL) || defined(PNG_USE_DLL))
#  define PNG_DLL
#endif
/* If CYGWIN, then disallow GLOBAL ARRAYS unless building a static lib.
 * When building a static lib, default to no GLOBAL ARRAYS, but allow
 * command-line override
 */
#if defined(__CYGWIN__)
#  if !defined(PNG_STATIC)
#    if defined(PNG_USE_GLOBAL_ARRAYS)
#      undef PNG_USE_GLOBAL_ARRAYS
#    endif
#    if !defined(PNG_USE_LOCAL_ARRAYS)
#      define PNG_USE_LOCAL_ARRAYS
#    endif
#  else
#    if defined(PNG_USE_LOCAL_ARRAYS) || defined(PNG_NO_GLOBAL_ARRAYS)
#      if defined(PNG_USE_GLOBAL_ARRAYS)
#        undef PNG_USE_GLOBAL_ARRAYS
#      endif
#    endif
#  endif
#  if !defined(PNG_USE_LOCAL_ARRAYS) && !defined(PNG_USE_GLOBAL_ARRAYS)
#    define PNG_USE_LOCAL_ARRAYS
#  endif
#endif

/* Do not use global arrays (helps with building DLL's)
 * They are no longer used in libpng itself, since version 1.0.5c,
 * but might be required for some pre-1.0.5c applications.
 */
#if !defined(PNG_USE_LOCAL_ARRAYS) && !defined(PNG_USE_GLOBAL_ARRAYS)
#  if defined(PNG_NO_GLOBAL_ARRAYS) || (defined(__GNUC__) && defined(PNG_DLL))
#    define PNG_USE_LOCAL_ARRAYS
#  else
#    define PNG_USE_GLOBAL_ARRAYS
#  endif
#endif


#ifndef PNGAPI

#if defined(__MINGW32__) || defined(__CYGWIN__) && !defined(PNG_MODULEDEF)
#  ifndef PNG_NO_MODULEDEF
#    define PNG_NO_MODULEDEF
#  endif
#endif

#if !defined(PNG_IMPEXP) && defined(PNG_BUILD_DLL) && !defined(PNG_NO_MODULEDEF)
#  define PNG_IMPEXP
#endif

#if defined(PNG_DLL) || defined(_DLL) || defined(__DLL__ ) || \
    (( defined(_Windows) || defined(_WINDOWS) || \
       defined(WIN32) || defined(_WIN32) || defined(__WIN32__) \
	  ) && !defined(__CYGWIN__))

#  if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800))
#    define PNGAPI __cdecl
#  else
#    define PNGAPI _cdecl
#  endif

#  if !defined(PNG_IMPEXP) && (!defined(PNG_DLL) || \
       0 /* WINCOMPILER_WITH_NO_SUPPORT_FOR_DECLIMPEXP */)
#     define PNG_IMPEXP
#  endif

#  if !defined(PNG_IMPEXP)

#     define PNG_EXPORT_TYPE1(type,symbol)  PNG_IMPEXP type PNGAPI symbol
#     define PNG_EXPORT_TYPE2(type,symbol)  type PNG_IMPEXP PNGAPI symbol

      /* Borland/Microsoft */
#     if defined(_MSC_VER) || defined(__BORLANDC__)
#        if (_MSC_VER >= 800) || (__BORLANDC__ >= 0x500)
#           define PNG_EXPORT PNG_EXPORT_TYPE1
#        else
#           define PNG_EXPORT PNG_EXPORT_TYPE2
#           if defined(PNG_BUILD_DLL)
#              define PNG_IMPEXP __export
#           else
#              define PNG_IMPEXP /*__import*/ /* doesn't exist AFAIK in
                                                 VC++*/
#           endif                             /* Exists in Borland C++ for
                                                 C++ classes (== huge) */
#        endif
#     endif

#     if !defined(PNG_IMPEXP)
#        if defined(PNG_BUILD_DLL)
#           define PNG_IMPEXP __declspec(dllexport)
#        else
#           define PNG_IMPEXP __declspec(dllimport)
#        endif
#     endif
#  endif  /* PNG_IMPEXP */
#else /* !(DLL || non-cygwin WINDOWS) */
#  if defined(__CYGWIN__) && !defined(PNG_DLL)
#    if !defined(PNG_IMPEXP)
#      define PNG_IMPEXP
#    endif
#    define PNGAPI __cdecl
#  else
#    if (defined(__IBMC__) || defined(IBMCPP__)) && defined(__OS2__)
#      define PNGAPI _System
#      define PNG_IMPEXP
#    else
#      if 0 /* ... other platforms, with other meanings */
#      else
#        define PNGAPI
#        define PNG_IMPEXP
#      endif
#    endif
#  endif
#endif
#endif

#ifndef PNGAPI
#  define PNGAPI
#endif
#ifndef PNG_IMPEXP
#  define PNG_IMPEXP
#endif

#ifndef PNG_EXPORT
#  define PNG_EXPORT(type,symbol) PNG_IMPEXP type PNGAPI symbol
#endif

#ifdef PNG_USE_GLOBAL_ARRAYS
#  ifndef PNG_EXPORT_VAR
#    define PNG_EXPORT_VAR(type) extern PNG_IMPEXP type
#  endif
#endif

/* User may want to use these so they are not in PNG_INTERNAL. Any library
 * functions that are passed far data must be model independent.
 */

#ifndef PNG_ABORT
#  define PNG_ABORT() abort()
#endif

#ifdef PNG_SETJMP_SUPPORTED
#  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
#else
#  define png_jmpbuf(png_ptr) \
   (LIBPNG_WAS_COMPILED_WITH__PNG_SETJMP_NOT_SUPPORTED)
#endif

#if defined(USE_FAR_KEYWORD)  /* memory model independent fns */
/* use this to make far-to-near assignments */
#  define CHECK   1
#  define NOCHECK 0
#  define CVT_PTR(ptr) (png_far_to_near(png_ptr,ptr,CHECK))
#  define CVT_PTR_NOCHECK(ptr) (png_far_to_near(png_ptr,ptr,NOCHECK))
#  define png_strcpy _fstrcpy
#  define png_strlen _fstrlen
#  define png_memcmp _fmemcmp      /* SJT: added */
#  define png_memcpy _fmemcpy
#  define png_memset _fmemset
#else /* use the usual functions */
#  define CVT_PTR(ptr)         (ptr)
#  define CVT_PTR_NOCHECK(ptr) (ptr)
#  define png_strcpy strcpy
#  define png_strlen strlen
#  define png_memcmp memcmp     /* SJT: added */
#  define png_memcpy memcpy
#  define png_memset memset
#endif
/* End of memory model independent support */

/* Just a little check that someone hasn't tried to define something
 * contradictory.
 */
#if (PNG_ZBUF_SIZE > 65536) && defined(PNG_MAX_MALLOC_64K)
#  undef PNG_ZBUF_SIZE
#  define PNG_ZBUF_SIZE 65536
#endif

#ifdef PNG_READ_SUPPORTED
/* Prior to libpng-1.0.9, this block was in pngasmrd.h */
#if defined(PNG_INTERNAL)

/* These are the default thresholds before the MMX code kicks in; if either
 * rowbytes or bitdepth is below the threshold, plain C code is used.  These
 * can be overridden at runtime via the png_set_mmx_thresholds() call in
 * libpng 1.2.0 and later.  The values below were chosen by Intel.
 */

#ifndef PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT
#  define PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT  128  /*  >=  */
#endif
#ifndef PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT
#  define PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT  9    /*  >=  */   
#endif

/* Set this in the makefile for VC++ on Pentium, not here. */
/* Platform must be Pentium.  Makefile must assemble and load pngvcrd.c .
 * MMX will be detected at run time and used if present.
 */
#ifdef PNG_USE_PNGVCRD
#  define PNG_HAVE_ASSEMBLER_COMBINE_ROW
#  define PNG_HAVE_ASSEMBLER_READ_INTERLACE
#  define PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
#endif

/* Set this in the makefile for gcc/as on Pentium, not here. */
/* Platform must be Pentium.  Makefile must assemble and load pnggccrd.c .
 * MMX will be detected at run time and used if present.
 */
#ifdef PNG_USE_PNGGCCRD
#  define PNG_HAVE_ASSEMBLER_COMBINE_ROW
#  define PNG_HAVE_ASSEMBLER_READ_INTERLACE
#  define PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
#endif
/* - see pnggccrd.c for info about what is currently enabled */

#endif /* PNG_INTERNAL */
#endif /* PNG_READ_SUPPORTED */

#endif /* PNGCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngasmrd.h ===
/* pngasmrd.h - assembler version of utilities to read a PNG file
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 2001 Glenn Randers-Pehrson
 *
 */

/* This file is obsolete in libpng-1.0.9 and later; its contents now appear
 * at the end of pngconf.h.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngerror.c ===
/* pngerror.c - stub functions for i/o and memory allocation
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file provides a location for all error handling.  Users who
 * need special error handling are expected to write replacement functions
 * and use png_set_error_fn() to use those functions.  See the instructions
 * at each function.
 */

#define PNG_INTERNAL
#include "png.h"

static void /* PRIVATE */
png_default_error PNGARG((png_structp png_ptr,
                                      png_const_charp message));
static void /* PRIVATE */
png_default_warning PNGARG((png_structp png_ptr,
                                        png_const_charp message));

/* This function is called whenever there is a fatal error.  This function
 * should not be changed.  If there is a need to handle errors differently,
 * you should supply a replacement error function and use png_set_error_fn()
 * to replace the error function at run-time.
 */
void PNGAPI
png_error(png_structp png_ptr, png_const_charp message)
{
   if (png_ptr->error_fn != NULL)
      (*(png_ptr->error_fn))(png_ptr, message);

   /* if the following returns or doesn't exist, use the default function,
      which will not return */
   png_default_error(png_ptr, message);
}

/* This function is called whenever there is a non-fatal error.  This function
 * should not be changed.  If there is a need to handle warnings differently,
 * you should supply a replacement warning function and use
 * png_set_error_fn() to replace the warning function at run-time.
 */
void PNGAPI
png_warning(png_structp png_ptr, png_const_charp message)
{
   if (png_ptr->warning_fn != NULL)
      (*(png_ptr->warning_fn))(png_ptr, message);
   else
      png_default_warning(png_ptr, message);
}

/* These utilities are used internally to build an error message that relates
 * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
 * this is used to prefix the message.  The message is limited in length
 * to 63 bytes, the name characters are output as hex digits wrapped in []
 * if the character is invalid.
 */
#define isnonalpha(c) ((c) < 41 || (c) > 122 || ((c) > 90 && (c) < 97))
static PNG_CONST char png_digit[16] = {
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',
   'F' };

static void /* PRIVATE */
png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
   message)
{
   int iout = 0, iin = 0;

   while (iin < 4)
   {
      int c = png_ptr->chunk_name[iin++];
      if (isnonalpha(c))
      {
         buffer[iout++] = '[';
         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
         buffer[iout++] = png_digit[c & 0x0f];
         buffer[iout++] = ']';
      }
      else
      {
         buffer[iout++] = (png_byte)c;
      }
   }

   if (message == NULL)
      buffer[iout] = 0;
   else
   {
      buffer[iout++] = ':';
      buffer[iout++] = ' ';
      png_memcpy(buffer+iout, message, 64);
      buffer[iout+63] = 0;
   }
}

void PNGAPI
png_chunk_error(png_structp png_ptr, png_const_charp message)
{
   char msg[18+64];
   png_format_buffer(png_ptr, msg, message);
   png_error(png_ptr, msg);
}

void PNGAPI
png_chunk_warning(png_structp png_ptr, png_const_charp message)
{
   char msg[18+64];
   png_format_buffer(png_ptr, msg, message);
   png_warning(png_ptr, msg);
}

/* This is the default error handling function.  Note that replacements for
 * this function MUST NOT RETURN, or the program will likely crash.  This
 * function is used by default, or if the program supplies NULL for the
 * error function pointer in png_set_error_fn().
 */
static void /* PRIVATE */
png_default_error(png_structp png_ptr, png_const_charp message)
{
#ifndef PNG_NO_CONSOLE_IO
   fprintf(stderr, "libpng error: %s\n", message);
#else
   if (message)
     /* make compiler happy */ ;
#endif

#ifdef PNG_SETJMP_SUPPORTED
#  ifdef USE_FAR_KEYWORD
   {
      jmp_buf jmpbuf;
      png_memcpy(jmpbuf,png_ptr->jmpbuf,sizeof(jmp_buf));
      longjmp(jmpbuf, 1);
   }
#  else
   longjmp(png_ptr->jmpbuf, 1);
# endif
#else
   if (png_ptr)
     /* make compiler happy */ ;
   PNG_ABORT();
#endif
}

/* This function is called when there is a warning, but the library thinks
 * it can continue anyway.  Replacement functions don't have to do anything
 * here if you don't want them to.  In the default configuration, png_ptr is
 * not used, but it is passed in case it may be useful.
 */
static void /* PRIVATE */
png_default_warning(png_structp png_ptr, png_const_charp message)
{
#ifndef PNG_NO_CONSOLE_IO
   fprintf(stderr, "libpng warning: %s\n", message);
#else
   if (message)
     /* appease compiler */ ;
#endif
   if (png_ptr)
      return;
}

/* This function is called when the application wants to use another method
 * of handling errors and warnings.  Note that the error function MUST NOT
 * return to the calling routine or serious problems will occur.  The return
 * method used in the default routine calls longjmp(png_ptr->jmpbuf, 1)
 */
void PNGAPI
png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warning_fn)
{
   png_ptr->error_ptr = error_ptr;
   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
}


/* This function returns a pointer to the error_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.
 */
png_voidp PNGAPI
png_get_error_ptr(png_structp png_ptr)
{
   return ((png_voidp)png_ptr->error_ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\png.c ===
/* png.c - location for general purpose libpng functions
 *
 * libpng version 1.0.11 - April 27, 2001
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 */

#define PNG_INTERNAL
#define PNG_NO_EXTERN
#include "png.h"

/* Generate a compiler error if there is an old png.h in the search path. */
typedef version_1_0_11 Your_png_h_is_not_version_1_0_11;

/* Version information for C files.  This had better match the version
 * string defined in png.h.  */

#ifdef PNG_USE_GLOBAL_ARRAYS
/* png_libpng_ver was changed to a function in version 1.0.5c */
const char png_libpng_ver[18] = "1.0.11";

/* png_sig was changed to a function in version 1.0.5c */
/* Place to hold the signature string for a PNG file. */
const png_byte FARDATA png_sig[8] = {137, 80, 78, 71, 13, 10, 26, 10};

/* Invoke global declarations for constant strings for known chunk types */
PNG_IHDR;
PNG_IDAT;
PNG_IEND;
PNG_PLTE;
PNG_bKGD;
PNG_cHRM;
PNG_gAMA;
PNG_hIST;
PNG_iCCP;
PNG_iTXt;
PNG_oFFs;
PNG_pCAL;
PNG_sCAL;
PNG_pHYs;
PNG_sBIT;
PNG_sPLT;
PNG_sRGB;
PNG_tEXt;
PNG_tIME;
PNG_tRNS;
PNG_zTXt;

/* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

/* start of interlace block */
const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};

/* offset to next interlace block */
const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};

/* start of interlace block in the y direction */
const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};

/* offset to next interlace block in the y direction */
const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};

/* width of interlace block (used in assembler routines only) */
#ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
const int FARDATA png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
#endif

/* Height of interlace block.  This is not currently used - if you need
 * it, uncomment it here and in png.h
const int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
*/

/* Mask to determine which pixels are valid in a pass */
const int FARDATA png_pass_mask[] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};

/* Mask to determine which pixels to overwrite while displaying */
const int FARDATA png_pass_dsp_mask[]
   = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};

#endif

/* Tells libpng that we have already handled the first "num_bytes" bytes
 * of the PNG file signature.  If the PNG data is embedded into another
 * stream we can set num_bytes = 8 so that libpng will not attempt to read
 * or write any of the magic bytes before it starts on the IHDR.
 */

void PNGAPI
png_set_sig_bytes(png_structp png_ptr, int num_bytes)
{
   png_debug(1, "in png_set_sig_bytes\n");
   if (num_bytes > 8)
      png_error(png_ptr, "Too many bytes for PNG signature.");

   png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
}

/* Checks whether the supplied bytes match the PNG signature.  We allow
 * checking less than the full 8-byte signature so that those apps that
 * already read the first few bytes of a file to determine the file type
 * can simply check the remaining bytes for extra assurance.  Returns
 * an integer less than, equal to, or greater than zero if sig is found,
 * respectively, to be less than, to match, or be greater than the correct
 * PNG signature (this is the same behaviour as strcmp, memcmp, etc).
 */
int PNGAPI
png_sig_cmp(png_bytep sig, png_size_t start, png_size_t num_to_check)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
   if (num_to_check > 8)
      num_to_check = 8;
   else if (num_to_check < 1)
      return (0);

   if (start > 7)
      return (0);

   if (start + num_to_check > 8)
      num_to_check = 8 - start;

   return ((int)(png_memcmp(&sig[start], &png_signature[start], num_to_check)));
}

/* (Obsolete) function to check signature bytes.  It does not allow one
 * to check a partial signature.  This function might be removed in the
 * future - use png_sig_cmp().  Returns true (nonzero) if the file is a PNG.
 */
int PNGAPI
png_check_sig(png_bytep sig, int num)
{
  return ((int)!png_sig_cmp(sig, (png_size_t)0, (png_size_t)num));
}

/* Function to allocate memory for zlib and clear it to 0. */
voidpf /* PRIVATE */
png_zalloc(voidpf png_ptr, uInt items, uInt size)
{
   png_uint_32 num_bytes = (png_uint_32)items * size;
   png_voidp ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);

#ifndef PNG_NO_ZALLOC_ZERO
   if (num_bytes > (png_uint_32)0x8000L)
   {
      png_memset(ptr, 0, (png_size_t)0x8000L);
      png_memset((png_bytep)ptr + (png_size_t)0x8000L, 0,
         (png_size_t)(num_bytes - (png_uint_32)0x8000L));
   }
   else
   {
      png_memset(ptr, 0, (png_size_t)num_bytes);
   }
#endif
   return ((voidpf)ptr);
}

/* function to free memory for zlib */
void /* PRIVATE */
png_zfree(voidpf png_ptr, voidpf ptr)
{
   png_free((png_structp)png_ptr, (png_voidp)ptr);
}

/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
 * in case CRC is > 32 bits to leave the top bits 0.
 */
void /* PRIVATE */
png_reset_crc(png_structp png_ptr)
{
   png_ptr->crc = crc32(0, Z_NULL, 0);
}

/* Calculate the CRC over a section of data.  We can only pass as
 * much data to this routine as the largest single buffer size.  We
 * also check that this data will actually be used before going to the
 * trouble of calculating it.
 */
void /* PRIVATE */
png_calculate_crc(png_structp png_ptr, png_bytep ptr, png_size_t length)
{
   int need_crc = 1;

   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }
   else                                                    /* critical */
   {
      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
         need_crc = 0;
   }

   if (need_crc)
      png_ptr->crc = crc32(png_ptr->crc, ptr, (uInt)length);
}

/* Allocate the memory for an info_struct for the application.  We don't
 * really need the png_ptr, but it could potentially be useful in the
 * future.  This should be used in favour of malloc(sizeof(png_info))
 * and png_info_init() so that applications that want to use a shared
 * libpng don't have to be recompiled if png_info changes size.
 */
png_infop PNGAPI
png_create_info_struct(png_structp png_ptr)
{
   png_infop info_ptr;

   png_debug(1, "in png_create_info_struct\n");
   if(png_ptr == NULL) return (NULL);
#ifdef PNG_USER_MEM_SUPPORTED
   if ((info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
      png_ptr->malloc_fn)) != NULL)
#else
   if ((info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO)) != NULL)
#endif
   {
      png_info_init(info_ptr);
   }

   return (info_ptr);
}

/* This function frees the memory associated with a single info struct.
 * Normally, one would use either png_destroy_read_struct() or
 * png_destroy_write_struct() to free an info struct, but this may be
 * useful for some applications.
 */
void PNGAPI
png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
{
   png_infop info_ptr = NULL;

   png_debug(1, "in png_destroy_info_struct\n");
   if (info_ptr_ptr != NULL)
      info_ptr = *info_ptr_ptr;

   if (info_ptr != NULL)
   {
      png_info_destroy(png_ptr, info_ptr);

#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)info_ptr, png_ptr->free_fn);
#else
      png_destroy_struct((png_voidp)info_ptr);
#endif
      *info_ptr_ptr = (png_infop)NULL;
   }
}

/* Initialize the info structure.  This is now an internal function (0.89)
 * and applications using it are urged to use png_create_info_struct()
 * instead.
 */
void /* PRIVATE */
png_info_init(png_infop info_ptr)
{
   png_debug(1, "in png_info_init\n");
   /* set everything to 0 */
   png_memset(info_ptr, 0, sizeof (png_info));
}

#ifdef PNG_FREE_ME_SUPPORTED
void PNGAPI
png_data_freer(png_structp png_ptr, png_infop info_ptr,
   int freer, png_uint_32 mask)
{
   png_debug(1, "in png_data_freer\n");
   if (png_ptr == NULL || info_ptr == NULL)
      return;
   if(freer == PNG_DESTROY_WILL_FREE_DATA)
      info_ptr->free_me |= mask;
   else if(freer == PNG_USER_WILL_FREE_DATA)
      info_ptr->free_me &= ~mask;
   else
      png_warning(png_ptr,
         "Unknown freer parameter in png_data_freer.");
}
#endif

void PNGAPI
png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
   int num)
{
   png_debug(1, "in png_free_data\n");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

#if defined(PNG_TEXT_SUPPORTED)
/* free text item num or (if num == -1) all text items */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
#else
if (mask & PNG_FREE_TEXT)
#endif
{
   if (num != -1)
   {
     if (info_ptr->text && info_ptr->text[num].key)
     {
         png_free(png_ptr, info_ptr->text[num].key);
         info_ptr->text[num].key = NULL;
     }
   }
   else
   {
       int i;
       for (i = 0; i < info_ptr->num_text; i++)
           png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
       png_free(png_ptr, info_ptr->text);
       info_ptr->text = NULL;
       info_ptr->num_text=0;
   }
}
#endif

#if defined(PNG_tRNS_SUPPORTED)
/* free any tRNS entry */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
#else
if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
#endif
{
    png_free(png_ptr, info_ptr->trans);
    info_ptr->valid &= ~PNG_INFO_tRNS;
    info_ptr->trans = NULL;
}
#endif

#if defined(PNG_sCAL_SUPPORTED)
/* free any sCAL entry */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
#else
if (mask & PNG_FREE_SCAL)
#endif
{
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
    png_free(png_ptr, info_ptr->scal_s_width);
    png_free(png_ptr, info_ptr->scal_s_height);
    info_ptr->scal_s_width = NULL;
    info_ptr->scal_s_height = NULL;
#endif
    info_ptr->valid &= ~PNG_INFO_sCAL;
}
#endif

#if defined(PNG_pCAL_SUPPORTED)
/* free any pCAL entry */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
#else
if (mask & PNG_FREE_PCAL)
#endif
{
    png_free(png_ptr, info_ptr->pcal_purpose);
    png_free(png_ptr, info_ptr->pcal_units);
    info_ptr->pcal_purpose = NULL;
    info_ptr->pcal_units = NULL;
    if (info_ptr->pcal_params != NULL)
    {
        int i;
        for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
        {
          png_free(png_ptr, info_ptr->pcal_params[i]);
          info_ptr->pcal_params[i]=NULL;
        }
        png_free(png_ptr, info_ptr->pcal_params);
        info_ptr->pcal_params = NULL;
    }
    info_ptr->valid &= ~PNG_INFO_pCAL;
}
#endif

#if defined(PNG_iCCP_SUPPORTED)
/* free any iCCP entry */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
#else
if (mask & PNG_FREE_ICCP)
#endif
{
    png_free(png_ptr, info_ptr->iccp_name);
    png_free(png_ptr, info_ptr->iccp_profile);
    info_ptr->iccp_name = NULL;
    info_ptr->iccp_profile = NULL;
    info_ptr->valid &= ~PNG_INFO_iCCP;
}
#endif

#if defined(PNG_sPLT_SUPPORTED)
/* free a given sPLT entry, or (if num == -1) all sPLT entries */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
#else
if (mask & PNG_FREE_SPLT)
#endif
{
   if (num != -1)
   {
      if(info_ptr->splt_palettes)
      {
          png_free(png_ptr, info_ptr->splt_palettes[num].name);
          png_free(png_ptr, info_ptr->splt_palettes[num].entries);
          info_ptr->splt_palettes[num].name = NULL;
          info_ptr->splt_palettes[num].entries = NULL;
      }
   }
   else
   {
       if(info_ptr->splt_palettes_num)
       {
         int i;
         for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
            png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);

         png_free(png_ptr, info_ptr->splt_palettes);
         info_ptr->splt_palettes = NULL;
         info_ptr->splt_palettes_num = 0;
       }
       info_ptr->valid &= ~PNG_INFO_sPLT;
   }
}
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
#else
if (mask & PNG_FREE_UNKN)
#endif
{
   if (num != -1)
   {
       if(info_ptr->unknown_chunks)
       {
          png_free(png_ptr, info_ptr->unknown_chunks[num].data);
          info_ptr->unknown_chunks[num].data = NULL;
       }
   }
   else
   {
       int i;

       if(info_ptr->unknown_chunks_num)
       {
         for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
            png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);

         png_free(png_ptr, info_ptr->unknown_chunks);
         info_ptr->unknown_chunks = NULL;
         info_ptr->unknown_chunks_num = 0;
       }
   }
}
#endif

#if defined(PNG_hIST_SUPPORTED)
/* free any hIST entry */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
#else
if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
#endif
{
    png_free(png_ptr, info_ptr->hist);
    info_ptr->hist = NULL;
    info_ptr->valid &= ~PNG_INFO_hIST;
}
#endif

/* free any PLTE entry that was internally allocated */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
#else
if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
#endif
{
    png_zfree(png_ptr, info_ptr->palette);
    info_ptr->palette = NULL;
    info_ptr->valid &= ~PNG_INFO_PLTE;
    info_ptr->num_palette = 0;
}

#if defined(PNG_INFO_IMAGE_SUPPORTED)
/* free any image bits attached to the info structure */
#ifdef PNG_FREE_ME_SUPPORTED
if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
#else
if (mask & PNG_FREE_ROWS)
#endif
{
    if(info_ptr->row_pointers)
    {
       int row;
       for (row = 0; row < (int)info_ptr->height; row++)
       {
          png_free(png_ptr, info_ptr->row_pointers[row]);
          info_ptr->row_pointers[row]=NULL;
       }
       png_free(png_ptr, info_ptr->row_pointers);
       info_ptr->row_pointers=NULL;
    }
    info_ptr->valid &= ~PNG_INFO_IDAT;
}
#endif

#ifdef PNG_FREE_ME_SUPPORTED
   if(num == -1)
     info_ptr->free_me &= ~mask;
   else
     info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
#endif
}

/* This is an internal routine to free any memory that the info struct is
 * pointing to before re-using it or freeing the struct itself.  Recall
 * that png_free() checks for NULL pointers for us.
 */
void /* PRIVATE */
png_info_destroy(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_info_destroy\n");

   png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
   if (png_ptr->num_chunk_list)
   {
       png_free(png_ptr, png_ptr->chunk_list);
       png_ptr->chunk_list=NULL;
       png_ptr->num_chunk_list=0;
   }
#endif

   png_info_init(info_ptr);
}

/* This function returns a pointer to the io_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy() or png_read_destroy() are called.
 */
png_voidp PNGAPI
png_get_io_ptr(png_structp png_ptr)
{
   return (png_ptr->io_ptr);
}

#if !defined(PNG_NO_STDIO)
/* Initialize the default input/output functions for the PNG file.  If you
 * use your own read or write routines, you can call either png_set_read_fn()
 * or png_set_write_fn() instead of png_init_io().  If you have defined
 * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't
 * necessarily available.
 */
void PNGAPI
png_init_io(png_structp png_ptr, png_FILE_p fp)
{
   png_debug(1, "in png_init_io\n");
   png_ptr->io_ptr = (png_voidp)fp;
}
#endif

#if defined(PNG_TIME_RFC1123_SUPPORTED)
/* Convert the supplied time into an RFC 1123 string suitable for use in
 * a "Creation Time" or other text-based time string.
 */
png_charp PNGAPI
png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
{
   static PNG_CONST char short_months[12][4] =
        {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

   if (png_ptr->time_buffer == NULL)
   {
      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
         sizeof(char)));
   }

#if defined(_WIN32_WCE)
   {
      wchar_t time_buf[29];
      wsprintf(time_buf, TEXT("%d %S %d %02d:%02d:%02d +0000"),
          ptime->day % 32, short_months[(ptime->month - 1) % 12],
        ptime->year, ptime->hour % 24, ptime->minute % 60,
          ptime->second % 61);
      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,
          NULL, NULL);
   }
#else
#ifdef USE_FAR_KEYWORD
   {
      char near_time_buf[29];
      sprintf(near_time_buf, "%d %s %d %02d:%02d:%02d +0000",
          ptime->day % 32, short_months[(ptime->month - 1) % 12],
          ptime->year, ptime->hour % 24, ptime->minute % 60,
          ptime->second % 61);
      png_memcpy(png_ptr->time_buffer, near_time_buf,
          29*sizeof(char));
   }
#else
   sprintf(png_ptr->time_buffer, "%d %s %d %02d:%02d:%02d +0000",
       ptime->day % 32, short_months[(ptime->month - 1) % 12],
       ptime->year, ptime->hour % 24, ptime->minute % 60,
       ptime->second % 61);
#endif
#endif /* _WIN32_WCE */
   return ((png_charp)png_ptr->time_buffer);
}
#endif /* PNG_TIME_RFC1123_SUPPORTED */

#if 0
/* Signature string for a PNG file. */
png_bytep PNGAPI
png_sig_bytes(void)
{
   return ((png_bytep)"\211\120\116\107\015\012\032\012");
}
#endif

png_charp PNGAPI
png_get_copyright(png_structp png_ptr)
{
   if (png_ptr != NULL || png_ptr == NULL)  /* silence compiler warning */
   return ((png_charp) "\n libpng version 1.0.11 - April 27, 2001\n\
   Copyright (c) 1998-2001 Glenn Randers-Pehrson\n\
   Copyright (c) 1996, 1997 Andreas Dilger\n\
   Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.\n");
   return ((png_charp) "");
}

/* The following return the library version as a short string in the
 * format 1.0.0 through 99.99.99zz.  To get the version of *.h files used
 * with your application, print out PNG_LIBPNG_VER_STRING, which is defined
 * in png.h.
 */

png_charp PNGAPI
png_get_libpng_ver(png_structp png_ptr)
{
   /* Version of *.c files used when building libpng */
   if(png_ptr != NULL) /* silence compiler warning about unused png_ptr */
      return((png_charp) "1.0.11");
   return((png_charp) "1.0.11");
}

png_charp PNGAPI
png_get_header_ver(png_structp png_ptr)
{
   /* Version of *.h files used when building libpng */
   if(png_ptr != NULL) /* silence compiler warning about unused png_ptr */
      return((png_charp) PNG_LIBPNG_VER_STRING);
   return((png_charp) PNG_LIBPNG_VER_STRING);
}

png_charp PNGAPI
png_get_header_version(png_structp png_ptr)
{
   /* Returns longer string containing both version and date */
   if(png_ptr != NULL) /* silence compiler warning about unused png_ptr */
      return((png_charp) PNG_HEADER_VERSION_STRING);
   return((png_charp) PNG_HEADER_VERSION_STRING);
}

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
int /* PRIVATE */
png_handle_as_unknown(png_structp png_ptr, png_bytep chunk_name)
{
   /* check chunk_name and return "keep" value if it's on the list, else 0 */
   int i;
   png_bytep p;
   if((png_ptr == NULL && chunk_name == NULL) || png_ptr->num_chunk_list<=0)
      return 0;
   p=png_ptr->chunk_list+png_ptr->num_chunk_list*5-5;
   for (i = png_ptr->num_chunk_list; i; i--, p-=5)
      if (!png_memcmp(chunk_name, p, 4))
        return ((int)*(p+4));
   return 0;
}
#endif

/* This function, added to libpng-1.0.6g, is untested. */
int PNGAPI
png_reset_zstream(png_structp png_ptr)
{
   return (inflateReset(&png_ptr->zstream));
}

/* This function was added to libpng-1.0.7 */
png_uint_32 PNGAPI
png_access_version_number(void)
{
   /* Version of *.c files used when building libpng */
   return((png_uint_32) 10011L);
}


#if 0 /* delay this until version 1.2.0 */
/* this function was added to libpng 1.0.9 (porting aid to libpng-1.2.0) */
#ifndef PNG_ASSEMBLER_CODE_SUPPORTED
int PNGAPI
png_mmx_support(void)
{
    return -1;
}
#endif
#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pnggccrd.c ===
/* pnggccrd.c - mixed C/assembler version of utilities to read a PNG file
 *
 * For Intel x86 CPU (Pentium-MMX or later) and GNU C compiler.
 *
 *     See http://www.intel.com/drg/pentiumII/appnotes/916/916.htm
 *     and http://www.intel.com/drg/pentiumII/appnotes/923/923.htm
 *     for Intel's performance analysis of the MMX vs. non-MMX code.
 *
 * libpng version 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * Copyright (c) 1998, Intel Corporation
 *
 * Based on MSVC code contributed by Nirav Chhatrapati, Intel Corp., 1998.
 * Interface to libpng contributed by Gilles Vollant, 1999.
 * GNU C port by Greg Roelofs, 1999-2001.
 *
 * Lines 2350-4300 converted in place with intel2gas 1.3.1:
 *
 *   intel2gas -mdI pnggccrd.c.partially-msvc -o pnggccrd.c
 *
 * and then cleaned up by hand.  See http://hermes.terminal.at/intel2gas/ .
 *
 * NOTE:  A sufficiently recent version of GNU as (or as.exe under DOS/Windows)
 *        is required to assemble the newer MMX instructions such as movq.
 *        For djgpp, see
 *
 *           ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2gnu/bnu281b.zip
 *
 *        (or a later version in the same directory).  For Linux, check your
 *        distribution's web site(s) or try these links:
 *
 *           http://rufus.w3.org/linux/RPM/binutils.html
 *           http://www.debian.org/Packages/stable/devel/binutils.html
 *           ftp://ftp.slackware.com/pub/linux/slackware/slackware/slakware/d1/
 *             binutils.tgz
 *
 *        For other platforms, see the main GNU site:
 *
 *           ftp://ftp.gnu.org/pub/gnu/binutils/
 *
 *        Version 2.5.2l.15 is definitely too old...
 */

/*
 * TEMPORARY PORTING NOTES AND CHANGELOG (mostly by Greg Roelofs)
 * =====================================
 *
 * 19991006:
 *  - fixed sign error in post-MMX cleanup code (16- & 32-bit cases)
 *
 * 19991007:
 *  - additional optimizations (possible or definite):
 *     x [DONE] write MMX code for 64-bit case (pixel_bytes == 8) [not tested]
 *     - write MMX code for 48-bit case (pixel_bytes == 6)
 *     - figure out what's up with 24-bit case (pixel_bytes == 3):
 *        why subtract 8 from width_mmx in the pass 4/5 case?
 *        (only width_mmx case) (near line 1606)
 *     x [DONE] replace pixel_bytes within each block with the true
 *        constant value (or are compilers smart enough to do that?)
 *     - rewrite all MMX interlacing code so it's aligned with
 *        the *beginning* of the row buffer, not the end.  This
 *        would not only allow one to eliminate half of the memory
 *        writes for odd passes (that is, pass == odd), it may also
 *        eliminate some unaligned-data-access exceptions (assuming
 *        there's a penalty for not aligning 64-bit accesses on
 *        64-bit boundaries).  The only catch is that the "leftover"
 *        pixel(s) at the end of the row would have to be saved,
 *        but there are enough unused MMX registers in every case,
 *        so this is not a problem.  A further benefit is that the
 *        post-MMX cleanup code (C code) in at least some of the
 *        cases could be done within the assembler block.
 *  x [DONE] the "v3 v2 v1 v0 v7 v6 v5 v4" comments are confusing,
 *     inconsistent, and don't match the MMX Programmer's Reference
 *     Manual conventions anyway.  They should be changed to
 *     "b7 b6 b5 b4 b3 b2 b1 b0," where b0 indicates the byte that
 *     was lowest in memory (e.g., corresponding to a left pixel)
 *     and b7 is the byte that was highest (e.g., a right pixel).
 *
 * 19991016:
 *  - Brennan's Guide notwithstanding, gcc under Linux does *not*
 *     want globals prefixed by underscores when referencing them--
 *     i.e., if the variable is const4, then refer to it as const4,
 *     not _const4.  This seems to be a djgpp-specific requirement.
 *     Also, such variables apparently *must* be declared outside
 *     of functions; neither static nor automatic variables work if
 *     defined within the scope of a single function, but both
 *     static and truly global (multi-module) variables work fine.
 *
 * 19991023:
 *  - fixed png_combine_row() non-MMX replication bug (odd passes only?)
 *  - switched from string-concatenation-with-macros to cleaner method of
 *     renaming global variables for djgpp--i.e., always use prefixes in
 *     inlined assembler code (== strings) and conditionally rename the
 *     variables, not the other way around.  Hence _const4, _mask8_0, etc.
 *
 * 19991024:
 *  - fixed mmxsupport()/png_do_read_interlace() first-row bug
 *     This one was severely weird:  even though mmxsupport() doesn't touch
 *     ebx (where "row" pointer was stored), it nevertheless managed to zero
 *     the register (even in static/non-fPIC code--see below), which in turn
 *     caused png_do_read_interlace() to return prematurely on the first row of
 *     interlaced images (i.e., without expanding the interlaced pixels).
 *     Inspection of the generated assembly code didn't turn up any clues,
 *     although it did point at a minor optimization (i.e., get rid of
 *     mmx_supported_local variable and just use eax).  Possibly the CPUID
 *     instruction is more destructive than it looks?  (Not yet checked.)
 *  - "info gcc" was next to useless, so compared fPIC and non-fPIC assembly
 *     listings...  Apparently register spillage has to do with ebx, since
 *     it's used to index the global offset table.  Commenting it out of the
 *     input-reg lists in png_combine_row() eliminated compiler barfage, so
 *     ifdef'd with __PIC__ macro:  if defined, use a global for unmask
 *
 * 19991107:
 *  - verified CPUID clobberage:  12-char string constant ("GenuineIntel",
 *     "AuthenticAMD", etc.) placed in ebx:ecx:edx.  Still need to polish.
 *
 * 19991120:
 *  - made "diff" variable (now "_dif") global to simplify conversion of
 *     filtering routines (running out of regs, sigh).  "diff" is still used
 *     in interlacing routines, however.
 *  - fixed up both versions of mmxsupport() (ORIG_THAT_USED_TO_CLOBBER_EBX
 *     macro determines which is used); original not yet tested.
 *
 * 20000213:
 *  - when compiling with gcc, be sure to use  -fomit-frame-pointer
 *
 * 20000319:
 *  - fixed a register-name typo in png_do_read_interlace(), default (MMX) case,
 *     pass == 4 or 5, that caused visible corruption of interlaced images
 *
 * 20000623:
 *  - Various problems were reported with gcc 2.95.2 in the Cygwin environment,
 *     many of the form "forbidden register 0 (ax) was spilled for class AREG."
 *     This is explained at http://gcc.gnu.org/fom_serv/cache/23.html, and
 *     Chuck Wilson supplied a patch involving dummy output registers.  See
 *     http://sourceforge.net/bugs/?func=detailbug&bug_id=108741&group_id=5624
 *     for the original (anonymous) SourceForge bug report.
 *
 * 20000706:
 *  - Chuck Wilson passed along these remaining gcc 2.95.2 errors:
 *       pnggccrd.c: In function `png_combine_row':
 *       pnggccrd.c:525: more than 10 operands in `asm'
 *       pnggccrd.c:669: more than 10 operands in `asm'
 *       pnggccrd.c:828: more than 10 operands in `asm'
 *       pnggccrd.c:994: more than 10 operands in `asm'
 *       pnggccrd.c:1177: more than 10 operands in `asm'
 *     They are all the same problem and can be worked around by using the
 *     global _unmask variable unconditionally, not just in the -fPIC case.
 *     Reportedly earlier versions of gcc also have the problem with more than
 *     10 operands; they just don't report it.  Much strangeness ensues, etc.
 *
 * 20000729:
 *  - enabled png_read_filter_row_mmx_up() (shortest remaining unconverted
 *     MMX routine); began converting png_read_filter_row_mmx_sub()
 *  - to finish remaining sections:
 *     - clean up indentation and comments
 *     - preload local variables
 *     - add output and input regs (order of former determines numerical
 *        mapping of latter)
 *     - avoid all usage of ebx (including bx, bh, bl) register [20000823]
 *     - remove "$" from addressing of Shift and Mask variables [20000823]
 *
 * 20000731:
 *  - global union vars causing segfaults in png_read_filter_row_mmx_sub()?
 *
 * 20000822:
 *  - ARGH, stupid png_read_filter_row_mmx_sub() segfault only happens with
 *     shared-library (-fPIC) version!  Code works just fine as part of static
 *     library.  Damn damn damn damn damn, should have tested that sooner.
 *     ebx is getting clobbered again (explicitly this time); need to save it
 *     on stack or rewrite asm code to avoid using it altogether.  Blargh!
 *
 * 20000823:
 *  - first section was trickiest; all remaining sections have ebx -> edx now.
 *     (-fPIC works again.)  Also added missing underscores to various Shift*
 *     and *Mask* globals and got rid of leading "$" signs.
 *
 * 20000826:
 *  - added visual separators to help navigate microscopic printed copies
 *     (http://pobox.com/~newt/code/gpr-latest.zip, mode 10); started working
 *     on png_read_filter_row_mmx_avg()
 *
 * 20000828:
 *  - finished png_read_filter_row_mmx_avg():  only Paeth left! (930 lines...)
 *     What the hell, did png_read_filter_row_mmx_paeth(), too.  Comments not
 *     cleaned up/shortened in either routine, but functionality is complete
 *     and seems to be working fine.
 *
 * 20000829:
 *  - ahhh, figured out last(?) bit of gcc/gas asm-fu:  if register is listed
 *     as an input reg (with dummy output variables, etc.), then it *cannot*
 *     also appear in the clobber list or gcc 2.95.2 will barf.  The solution
 *     is simple enough...
 *
 * 20000914:
 *  - bug in png_read_filter_row_mmx_avg():  16-bit grayscale not handled
 *     correctly (but 48-bit RGB just fine)
 *
 * 20000916:
 *  - fixed bug in png_read_filter_row_mmx_avg(), bpp == 2 case; three errors:
 *     - "_ShiftBpp.use = 24;"      should have been   "_ShiftBpp.use = 16;"
 *     - "_ShiftRem.use = 40;"      should have been   "_ShiftRem.use = 48;"
 *     - "psllq _ShiftRem, %%mm2"   should have been   "psrlq _ShiftRem, %%mm2"
 *
 * 20010103:
 *  - renamed mmxsupport() to png_mmx_support(), with auto-set of mmx_supported,
 *     and made it public
 *
 * 20010104:
 *  - removed dependency on png_read_filter_row_c() (C code already duplicated
 *     within MMX version of png_read_filter_row()) so no longer necessary to
 *     compile it into pngrutil.o
 *
 * 20010310:
 *  - fixed buffer-overrun bug in png_combine_row() C code (non-MMX)
 *
 * STILL TO DO:
 *     - test png_do_read_interlace() 64-bit case (pixel_bytes == 8)
 *     - write MMX code for 48-bit case (pixel_bytes == 6)
 *     - figure out what's up with 24-bit case (pixel_bytes == 3):
 *        why subtract 8 from width_mmx in the pass 4/5 case?
 *        (only width_mmx case) (near line 1606)
 *     - rewrite all MMX interlacing code so it's aligned with beginning
 *        of the row buffer, not the end (see 19991007 for details)
 *     x pick one version of mmxsupport() and get rid of the other
 *     - add error messages to any remaining bogus default cases
 *     - enable pixel_depth == 8 cases in png_read_filter_row()? (test speed)
 *     - add support for runtime enable/disable/query of various MMX routines
 */

/*
#ifndef PNG_DEBUG
#  define PNG_DEBUG 0
#endif
*/

#define PNG_INTERNAL
#include "png.h"

#if defined(PNG_USE_PNGGCCRD)

int PNGAPI png_mmx_support(void);

#ifdef PNG_USE_LOCAL_ARRAYS
static const int FARDATA png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
static const int FARDATA png_pass_inc[7]   = {8, 8, 4, 4, 2, 2, 1};
static const int FARDATA png_pass_width[7] = {8, 4, 4, 2, 2, 1, 1};
#endif

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
/* djgpp, Win32, and Cygwin add their own underscores to global variables,
 * so define them without: */
#if defined(__DJGPP__) || defined(WIN32) || defined(__CYGWIN__)
#  define _mmx_supported  mmx_supported
#  define _unmask         unmask
#  define _const4         const4
#  define _const6         const6
#  define _mask8_0        mask8_0
#  define _mask16_1       mask16_1
#  define _mask16_0       mask16_0
#  define _mask24_2       mask24_2
#  define _mask24_1       mask24_1
#  define _mask24_0       mask24_0
#  define _mask32_3       mask32_3
#  define _mask32_2       mask32_2
#  define _mask32_1       mask32_1
#  define _mask32_0       mask32_0
#  define _mask48_5       mask48_5
#  define _mask48_4       mask48_4
#  define _mask48_3       mask48_3
#  define _mask48_2       mask48_2
#  define _mask48_1       mask48_1
#  define _mask48_0       mask48_0
#  define _FullLength     FullLength
#  define _MMXLength      MMXLength
#  define _dif            dif
#  define _LBCarryMask    LBCarryMask
#  define _HBClearMask    HBClearMask
#  define _ActiveMask     ActiveMask
#  define _ActiveMask2    ActiveMask2
#  define _ActiveMaskEnd  ActiveMaskEnd
#  define _ShiftBpp       ShiftBpp
#  define _ShiftRem       ShiftRem
#  define _patemp         patemp
#  define _pbtemp         pbtemp
#  define _pctemp         pctemp
#endif


/* These constants are used in the inlined MMX assembly code.
   Ignore gcc's "At top level: defined but not used" warnings. */

/* GRR 20000706:  originally _unmask was needed only when compiling with -fPIC,
 *  since that case uses the %ebx register for indexing the Global Offset Table
 *  and there were no other registers available.  But gcc 2.95 and later emit
 *  "more than 10 operands in `asm'" errors when %ebx is used to preload unmask
 *  in the non-PIC case, so we'll just use the global unconditionally now.
 */
static int _unmask;

static unsigned long long _mask8_0  = 0x0102040810204080LL;

static unsigned long long _mask16_1 = 0x0101020204040808LL;
static unsigned long long _mask16_0 = 0x1010202040408080LL;

static unsigned long long _mask24_2 = 0x0101010202020404LL;
static unsigned long long _mask24_1 = 0x0408080810101020LL;
static unsigned long long _mask24_0 = 0x2020404040808080LL;

static unsigned long long _mask32_3 = 0x0101010102020202LL;
static unsigned long long _mask32_2 = 0x0404040408080808LL;
static unsigned long long _mask32_1 = 0x1010101020202020LL;
static unsigned long long _mask32_0 = 0x4040404080808080LL;

static unsigned long long _mask48_5 = 0x0101010101010202LL;
static unsigned long long _mask48_4 = 0x0202020204040404LL;
static unsigned long long _mask48_3 = 0x0404080808080808LL;
static unsigned long long _mask48_2 = 0x1010101010102020LL;
static unsigned long long _mask48_1 = 0x2020202040404040LL;
static unsigned long long _mask48_0 = 0x4040808080808080LL;

static unsigned long long _const4   = 0x0000000000FFFFFFLL;
//static unsigned long long _const5 = 0x000000FFFFFF0000LL;     // NOT USED
static unsigned long long _const6   = 0x00000000000000FFLL;

// These are used in the row-filter routines and should/would be local
//  variables if not for gcc addressing limitations.

static png_uint_32  _FullLength;
static png_uint_32  _MMXLength;
static int          _dif;
static int          _patemp;	// temp variables for Paeth routine
static int          _pbtemp;
static int          _pctemp;
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */

static int _mmx_supported = 2;

/*===========================================================================*/
/*                                                                           */
/*                       P N G _ C O M B I N E _ R O W                       */
/*                                                                           */
/*===========================================================================*/

#if defined(PNG_HAVE_ASSEMBLER_COMBINE_ROW)

#define BPP2  2
#define BPP3  3		/* bytes per pixel (a.k.a. pixel_bytes) */
#define BPP4  4
#define BPP6  6		/* (defined only to help avoid cut-and-paste errors) */
#define BPP8  8

/* Combines the row recently read in with the previous row.
   This routine takes care of alpha and transparency if requested.
   This routine also handles the two methods of progressive display
   of interlaced images, depending on the mask value.
   The mask value describes which pixels are to be combined with
   the row.  The pattern always repeats every 8 pixels, so just 8
   bits are needed.  A one indicates the pixel is to be combined; a
   zero indicates the pixel is to be skipped.  This is in addition
   to any alpha or transparency value associated with the pixel.
   If you want all pixels to be combined, pass 0xff (255) in mask. */

/* Use this routine for the x86 platform - it uses a faster MMX routine
   if the machine supports MMX. */

void /* PRIVATE */
png_combine_row(png_structp png_ptr, png_bytep row, int mask)
{
   png_debug(1, "in png_combine_row (pnggccrd.c)\n");

   if (_mmx_supported == 2) {
       png_mmx_support();
   }

   if (mask == 0xff)
   {
      png_debug(2,"mask == 0xff:  doing single png_memcpy()\n");
      png_memcpy(row, png_ptr->row_buf + 1,
       (png_size_t)((png_ptr->width * png_ptr->row_info.pixel_depth + 7) >> 3));
   }
   else   /* (png_combine_row() is never called with mask == 0) */
   {
      switch (png_ptr->row_info.pixel_depth)
      {
         case 1:        /* png_ptr->row_info.pixel_depth */
         {
            png_bytep sp;
            png_bytep dp;
            int s_inc, s_start, s_end;
            int m;
            int shift;
            png_uint_32 i;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }
            else
#endif
            {
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  int value;

                  value = (*sp >> shift) & 0x1;
                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 2:        /* png_ptr->row_info.pixel_depth */
         {
            png_bytep sp;
            png_bytep dp;
            int s_start, s_end, s_inc;
            int m;
            int shift;
            png_uint_32 i;
            int value;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }
            else
#endif
            {
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0x3;
                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 4:        /* png_ptr->row_info.pixel_depth */
         {
            png_bytep sp;
            png_bytep dp;
            int s_start, s_end, s_inc;
            int m;
            int shift;
            png_uint_32 i;
            int value;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }
            else
#endif
            {
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0xf;
                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 8:        /* png_ptr->row_info.pixel_depth */
         {
            png_bytep srcptr;
            png_bytep dstptr;

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
            if ( _mmx_supported  )
            {
               png_uint_32 len;
               int diff;
               int dummy_value_a;   // fix 'forbidden register spilled' error
               int dummy_value_d;
               int dummy_value_c;
               int dummy_value_S;
               int dummy_value_D;
               _unmask = ~mask;            // global variable for -fPIC version
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               len  = png_ptr->width &~7;  // reduce to multiple of 8
               diff = (int) (png_ptr->width & 7);  // amount lost

               __asm__ __volatile__ (
                  "movd      _unmask, %%mm7  \n\t" // load bit pattern
                  "psubb     %%mm6, %%mm6    \n\t" // zero mm6
                  "punpcklbw %%mm7, %%mm7    \n\t"
                  "punpcklwd %%mm7, %%mm7    \n\t"
                  "punpckldq %%mm7, %%mm7    \n\t" // fill reg with 8 masks

                  "movq      _mask8_0, %%mm0 \n\t"
                  "pand      %%mm7, %%mm0    \n\t" // nonzero if keep byte
                  "pcmpeqb   %%mm6, %%mm0    \n\t" // zeros->1s, v versa

// preload        "movl      len, %%ecx      \n\t" // load length of line
// preload        "movl      srcptr, %%esi   \n\t" // load source
// preload        "movl      dstptr, %%edi   \n\t" // load dest

                  "cmpl      $0, %%ecx       \n\t" // len == 0 ?
                  "je        mainloop8end    \n\t"

                "mainloop8:                  \n\t"
                  "movq      (%%esi), %%mm4  \n\t" // *srcptr
                  "pand      %%mm0, %%mm4    \n\t"
                  "movq      %%mm0, %%mm6    \n\t"
                  "pandn     (%%edi), %%mm6  \n\t" // *dstptr
                  "por       %%mm6, %%mm4    \n\t"
                  "movq      %%mm4, (%%edi)  \n\t"
                  "addl      $8, %%esi       \n\t" // inc by 8 bytes processed
                  "addl      $8, %%edi       \n\t"
                  "subl      $8, %%ecx       \n\t" // dec by 8 pixels processed
                  "ja        mainloop8       \n\t"

                "mainloop8end:               \n\t"
// preload        "movl      diff, %%ecx     \n\t" // (diff is in eax)
                  "movl      %%eax, %%ecx    \n\t"
                  "cmpl      $0, %%ecx       \n\t"
                  "jz        end8            \n\t"
// preload        "movl      mask, %%edx     \n\t"
                  "sall      $24, %%edx      \n\t" // make low byte, high byte

                "secondloop8:                \n\t"
                  "sall      %%edx           \n\t" // move high bit to CF
                  "jnc       skip8           \n\t" // if CF = 0
                  "movb      (%%esi), %%al   \n\t"
                  "movb      %%al, (%%edi)   \n\t"

                "skip8:                      \n\t"
                  "incl      %%esi           \n\t"
                  "incl      %%edi           \n\t"
                  "decl      %%ecx           \n\t"
                  "jnz       secondloop8     \n\t"

                "end8:                       \n\t"
                  "EMMS                      \n\t"  // DONE

                  : "=a" (dummy_value_a),           // output regs (dummy)
                    "=d" (dummy_value_d),
                    "=c" (dummy_value_c),
                    "=S" (dummy_value_S),
                    "=D" (dummy_value_D)

                  : "3" (srcptr),      // esi       // input regs
                    "4" (dstptr),      // edi
                    "0" (diff),        // eax
// was (unmask)     "b"    RESERVED    // ebx       // Global Offset Table idx
                    "2" (len),         // ecx
                    "1" (mask)         // edx

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                  : "%mm0", "%mm4", "%mm6", "%mm7"  // clobber list
#endif
               );
            }
            else /* mmx _not supported - Use modified C routine */
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
            {
               register png_uint_32 i;
               png_uint_32 initial_val = png_pass_start[png_ptr->pass];
                 /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
               register int stride = png_pass_inc[png_ptr->pass];
                 /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
               register int rep_bytes = png_pass_width[png_ptr->pass];
                 /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
               png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
               int diff = (int) (png_ptr->width & 7); /* amount lost */
               register png_uint_32 final_val = len;  /* GRR bugfix */

               srcptr = png_ptr->row_buf + 1 + initial_val;
               dstptr = row + initial_val;

               for (i = initial_val; i < final_val; i += stride)
               {
                  png_memcpy(dstptr, srcptr, rep_bytes);
                  srcptr += stride;
                  dstptr += stride;
               }
               if (diff)  /* number of leftover pixels:  3 for pngtest */
               {
                  final_val+=diff /* *BPP1 */ ;
                  for (; i < final_val; i += stride)
                  {
                     if (rep_bytes > (int)(final_val-i))
                        rep_bytes = (int)(final_val-i);
                     png_memcpy(dstptr, srcptr, rep_bytes);
                     srcptr += stride;
                     dstptr += stride;
                  }
               }

            } /* end of else (_mmx_supported) */

            break;
         }       /* end 8 bpp */

         case 16:       /* png_ptr->row_info.pixel_depth */
         {
            png_bytep srcptr;
            png_bytep dstptr;

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
            if ( _mmx_supported )
            {
               png_uint_32 len;
               int diff;
               int dummy_value_a;   // fix 'forbidden register spilled' error
               int dummy_value_d;
               int dummy_value_c;
               int dummy_value_S;
               int dummy_value_D;
               _unmask = ~mask;            // global variable for -fPIC version
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               len  = png_ptr->width &~7;  // reduce to multiple of 8
               diff = (int) (png_ptr->width & 7); // amount lost //

               __asm__ __volatile__ (
                  "movd      _unmask, %%mm7   \n\t" // load bit pattern
                  "psubb     %%mm6, %%mm6     \n\t" // zero mm6
                  "punpcklbw %%mm7, %%mm7     \n\t"
                  "punpcklwd %%mm7, %%mm7     \n\t"
                  "punpckldq %%mm7, %%mm7     \n\t" // fill reg with 8 masks

                  "movq      _mask16_0, %%mm0 \n\t"
                  "movq      _mask16_1, %%mm1 \n\t"

                  "pand      %%mm7, %%mm0     \n\t"
                  "pand      %%mm7, %%mm1     \n\t"

                  "pcmpeqb   %%mm6, %%mm0     \n\t"
                  "pcmpeqb   %%mm6, %%mm1     \n\t"

// preload        "movl      len, %%ecx       \n\t" // load length of line
// preload        "movl      srcptr, %%esi    \n\t" // load source
// preload        "movl      dstptr, %%edi    \n\t" // load dest

                  "cmpl      $0, %%ecx        \n\t"
                  "jz        mainloop16end    \n\t"

                "mainloop16:                  \n\t"
                  "movq      (%%esi), %%mm4   \n\t"
                  "pand      %%mm0, %%mm4     \n\t"
                  "movq      %%mm0, %%mm6     \n\t"
                  "movq      (%%edi), %%mm7   \n\t"
                  "pandn     %%mm7, %%mm6     \n\t"
                  "por       %%mm6, %%mm4     \n\t"
                  "movq      %%mm4, (%%edi)   \n\t"

                  "movq      8(%%esi), %%mm5  \n\t"
                  "pand      %%mm1, %%mm5     \n\t"
                  "movq      %%mm1, %%mm7     \n\t"
                  "movq      8(%%edi), %%mm6  \n\t"
                  "pandn     %%mm6, %%mm7     \n\t"
                  "por       %%mm7, %%mm5     \n\t"
                  "movq      %%mm5, 8(%%edi)  \n\t"

                  "addl      $16, %%esi       \n\t" // inc by 16 bytes processed
                  "addl      $16, %%edi       \n\t"
                  "subl      $8, %%ecx        \n\t" // dec by 8 pixels processed
                  "ja        mainloop16       \n\t"

                "mainloop16end:               \n\t"
// preload        "movl      diff, %%ecx      \n\t" // (diff is in eax)
                  "movl      %%eax, %%ecx     \n\t"
                  "cmpl      $0, %%ecx        \n\t"
                  "jz        end16            \n\t"
// preload        "movl      mask, %%edx      \n\t"
                  "sall      $24, %%edx       \n\t" // make low byte, high byte

                "secondloop16:                \n\t"
                  "sall      %%edx            \n\t" // move high bit to CF
                  "jnc       skip16           \n\t" // if CF = 0
                  "movw      (%%esi), %%ax    \n\t"
                  "movw      %%ax, (%%edi)    \n\t"

                "skip16:                      \n\t"
                  "addl      $2, %%esi        \n\t"
                  "addl      $2, %%edi        \n\t"
                  "decl      %%ecx            \n\t"
                  "jnz       secondloop16     \n\t"

                "end16:                       \n\t"
                  "EMMS                       \n\t" // DONE

                  : "=a" (dummy_value_a),           // output regs (dummy)
                    "=c" (dummy_value_c),
                    "=d" (dummy_value_d),
                    "=S" (dummy_value_S),
                    "=D" (dummy_value_D)

                  : "0" (diff),        // eax       // input regs
// was (unmask)     " "    RESERVED    // ebx       // Global Offset Table idx
                    "1" (len),         // ecx
                    "2" (mask),        // edx
                    "3" (srcptr),      // esi
                    "4" (dstptr)       // edi

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                  : "%mm0", "%mm1", "%mm4"          // clobber list
                  , "%mm5", "%mm6", "%mm7"
#endif
               );
            }
            else /* mmx _not supported - Use modified C routine */
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
            {
               register png_uint_32 i;
               png_uint_32 initial_val = BPP2 * png_pass_start[png_ptr->pass];
                 /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
               register int stride = BPP2 * png_pass_inc[png_ptr->pass];
                 /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
               register int rep_bytes = BPP2 * png_pass_width[png_ptr->pass];
                 /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
               png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
               int diff = (int) (png_ptr->width & 7); /* amount lost */
               register png_uint_32 final_val = BPP2 * len;   /* GRR bugfix */

               srcptr = png_ptr->row_buf + 1 + initial_val;
               dstptr = row + initial_val;

               for (i = initial_val; i < final_val; i += stride)
               {
                  png_memcpy(dstptr, srcptr, rep_bytes);
                  srcptr += stride;
                  dstptr += stride;
               }
               if (diff)  /* number of leftover pixels:  3 for pngtest */
               {
                  final_val+=diff*BPP2;
                  for (; i < final_val; i += stride)
                  {
                     if (rep_bytes > (int)(final_val-i))
                        rep_bytes = (int)(final_val-i);
                     png_memcpy(dstptr, srcptr, rep_bytes);
                     srcptr += stride;
                     dstptr += stride;
                  }
               }
            } /* end of else (_mmx_supported) */

            break;
         }       /* end 16 bpp */

         case 24:       /* png_ptr->row_info.pixel_depth */
         {
            png_bytep srcptr;
            png_bytep dstptr;

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
            if ( _mmx_supported )
            {
               png_uint_32 len;
               int diff;
               int dummy_value_a;   // fix 'forbidden register spilled' error
               int dummy_value_d;
               int dummy_value_c;
               int dummy_value_S;
               int dummy_value_D;
               _unmask = ~mask;            // global variable for -fPIC version
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               len  = png_ptr->width &~7;  // reduce to multiple of 8
               diff = (int) (png_ptr->width & 7); // amount lost //

               __asm__ __volatile__ (
                  "movd      _unmask, %%mm7   \n\t" // load bit pattern
                  "psubb     %%mm6, %%mm6     \n\t" // zero mm6
                  "punpcklbw %%mm7, %%mm7     \n\t"
                  "punpcklwd %%mm7, %%mm7     \n\t"
                  "punpckldq %%mm7, %%mm7     \n\t" // fill reg with 8 masks

                  "movq      _mask24_0, %%mm0 \n\t"
                  "movq      _mask24_1, %%mm1 \n\t"
                  "movq      _mask24_2, %%mm2 \n\t"

                  "pand      %%mm7, %%mm0     \n\t"
                  "pand      %%mm7, %%mm1     \n\t"
                  "pand      %%mm7, %%mm2     \n\t"

                  "pcmpeqb   %%mm6, %%mm0     \n\t"
                  "pcmpeqb   %%mm6, %%mm1     \n\t"
                  "pcmpeqb   %%mm6, %%mm2     \n\t"

// preload        "movl      len, %%ecx       \n\t" // load length of line
// preload        "movl      srcptr, %%esi    \n\t" // load source
// preload        "movl      dstptr, %%edi    \n\t" // load dest

                  "cmpl      $0, %%ecx        \n\t"
                  "jz        mainloop24end    \n\t"

                "mainloop24:                  \n\t"
                  "movq      (%%esi), %%mm4   \n\t"
                  "pand      %%mm0, %%mm4     \n\t"
                  "movq      %%mm0, %%mm6     \n\t"
                  "movq      (%%edi), %%mm7   \n\t"
                  "pandn     %%mm7, %%mm6     \n\t"
                  "por       %%mm6, %%mm4     \n\t"
                  "movq      %%mm4, (%%edi)   \n\t"

                  "movq      8(%%esi), %%mm5  \n\t"
                  "pand      %%mm1, %%mm5     \n\t"
                  "movq      %%mm1, %%mm7     \n\t"
                  "movq      8(%%edi), %%mm6  \n\t"
                  "pandn     %%mm6, %%mm7     \n\t"
                  "por       %%mm7, %%mm5     \n\t"
                  "movq      %%mm5, 8(%%edi)  \n\t"

                  "movq      16(%%esi), %%mm6 \n\t"
                  "pand      %%mm2, %%mm6     \n\t"
                  "movq      %%mm2, %%mm4     \n\t"
                  "movq      16(%%edi), %%mm7 \n\t"
                  "pandn     %%mm7, %%mm4     \n\t"
                  "por       %%mm4, %%mm6     \n\t"
                  "movq      %%mm6, 16(%%edi) \n\t"

                  "addl      $24, %%esi       \n\t" // inc by 24 bytes processed
                  "addl      $24, %%edi       \n\t"
                  "subl      $8, %%ecx        \n\t" // dec by 8 pixels processed

                  "ja        mainloop24       \n\t"

                "mainloop24end:               \n\t"
// preload        "movl      diff, %%ecx      \n\t" // (diff is in eax)
                  "movl      %%eax, %%ecx     \n\t"
                  "cmpl      $0, %%ecx        \n\t"
                  "jz        end24            \n\t"
// preload        "movl      mask, %%edx      \n\t"
                  "sall      $24, %%edx       \n\t" // make low byte, high byte

                "secondloop24:                \n\t"
                  "sall      %%edx            \n\t" // move high bit to CF
                  "jnc       skip24           \n\t" // if CF = 0
                  "movw      (%%esi), %%ax    \n\t"
                  "movw      %%ax, (%%edi)    \n\t"
                  "xorl      %%eax, %%eax     \n\t"
                  "movb      2(%%esi), %%al   \n\t"
                  "movb      %%al, 2(%%edi)   \n\t"

                "skip24:                      \n\t"
                  "addl      $3, %%esi        \n\t"
                  "addl      $3, %%edi        \n\t"
                  "decl      %%ecx            \n\t"
                  "jnz       secondloop24     \n\t"

                "end24:                       \n\t"
                  "EMMS                       \n\t" // DONE

                  : "=a" (dummy_value_a),           // output regs (dummy)
                    "=d" (dummy_value_d),
                    "=c" (dummy_value_c),
                    "=S" (dummy_value_S),
                    "=D" (dummy_value_D)

                  : "3" (srcptr),      // esi       // input regs
                    "4" (dstptr),      // edi
                    "0" (diff),        // eax
// was (unmask)     "b"    RESERVED    // ebx       // Global Offset Table idx
                    "2" (len),         // ecx
                    "1" (mask)         // edx

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                  : "%mm0", "%mm1", "%mm2"          // clobber list
                  , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
               );
            }
            else /* mmx _not supported - Use modified C routine */
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
            {
               register png_uint_32 i;
               png_uint_32 initial_val = BPP3 * png_pass_start[png_ptr->pass];
                 /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
               register int stride = BPP3 * png_pass_inc[png_ptr->pass];
                 /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
               register int rep_bytes = BPP3 * png_pass_width[png_ptr->pass];
                 /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
               png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
               int diff = (int) (png_ptr->width & 7); /* amount lost */
               register png_uint_32 final_val = BPP3 * len;   /* GRR bugfix */

               srcptr = png_ptr->row_buf + 1 + initial_val;
               dstptr = row + initial_val;

               for (i = initial_val; i < final_val; i += stride)
               {
                  png_memcpy(dstptr, srcptr, rep_bytes);
                  srcptr += stride;
                  dstptr += stride;
               }
               if (diff)  /* number of leftover pixels:  3 for pngtest */
               {
                  final_val+=diff*BPP3;
                  for (; i < final_val; i += stride)
                  {
                     if (rep_bytes > (int)(final_val-i))
                        rep_bytes = (int)(final_val-i);
                     png_memcpy(dstptr, srcptr, rep_bytes);
                     srcptr += stride;
                     dstptr += stride;
                  }
               }
            } /* end of else (_mmx_supported) */

            break;
         }       /* end 24 bpp */

         case 32:       /* png_ptr->row_info.pixel_depth */
         {
            png_bytep srcptr;
            png_bytep dstptr;

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
            if ( _mmx_supported )
            {
               png_uint_32 len;
               int diff;
               int dummy_value_a;   // fix 'forbidden register spilled' error
               int dummy_value_d;
               int dummy_value_c;
               int dummy_value_S;
               int dummy_value_D;
               _unmask = ~mask;            // global variable for -fPIC version
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               len  = png_ptr->width &~7;  // reduce to multiple of 8
               diff = (int) (png_ptr->width & 7); // amount lost //

               __asm__ __volatile__ (
                  "movd      _unmask, %%mm7   \n\t" // load bit pattern
                  "psubb     %%mm6, %%mm6     \n\t" // zero mm6
                  "punpcklbw %%mm7, %%mm7     \n\t"
                  "punpcklwd %%mm7, %%mm7     \n\t"
                  "punpckldq %%mm7, %%mm7     \n\t" // fill reg with 8 masks

                  "movq      _mask32_0, %%mm0 \n\t"
                  "movq      _mask32_1, %%mm1 \n\t"
                  "movq      _mask32_2, %%mm2 \n\t"
                  "movq      _mask32_3, %%mm3 \n\t"

                  "pand      %%mm7, %%mm0     \n\t"
                  "pand      %%mm7, %%mm1     \n\t"
                  "pand      %%mm7, %%mm2     \n\t"
                  "pand      %%mm7, %%mm3     \n\t"

                  "pcmpeqb   %%mm6, %%mm0     \n\t"
                  "pcmpeqb   %%mm6, %%mm1     \n\t"
                  "pcmpeqb   %%mm6, %%mm2     \n\t"
                  "pcmpeqb   %%mm6, %%mm3     \n\t"

// preload        "movl      len, %%ecx       \n\t" // load length of line
// preload        "movl      srcptr, %%esi    \n\t" // load source
// preload        "movl      dstptr, %%edi    \n\t" // load dest

                  "cmpl      $0, %%ecx        \n\t" // lcr
                  "jz        mainloop32end    \n\t"

                "mainloop32:                  \n\t"
                  "movq      (%%esi), %%mm4   \n\t"
                  "pand      %%mm0, %%mm4     \n\t"
                  "movq      %%mm0, %%mm6     \n\t"
                  "movq      (%%edi), %%mm7   \n\t"
                  "pandn     %%mm7, %%mm6     \n\t"
                  "por       %%mm6, %%mm4     \n\t"
                  "movq      %%mm4, (%%edi)   \n\t"

                  "movq      8(%%esi), %%mm5  \n\t"
                  "pand      %%mm1, %%mm5     \n\t"
                  "movq      %%mm1, %%mm7     \n\t"
                  "movq      8(%%edi), %%mm6  \n\t"
                  "pandn     %%mm6, %%mm7     \n\t"
                  "por       %%mm7, %%mm5     \n\t"
                  "movq      %%mm5, 8(%%edi)  \n\t"

                  "movq      16(%%esi), %%mm6 \n\t"
                  "pand      %%mm2, %%mm6     \n\t"
                  "movq      %%mm2, %%mm4     \n\t"
                  "movq      16(%%edi), %%mm7 \n\t"
                  "pandn     %%mm7, %%mm4     \n\t"
                  "por       %%mm4, %%mm6     \n\t"
                  "movq      %%mm6, 16(%%edi) \n\t"

                  "movq      24(%%esi), %%mm7 \n\t"
                  "pand      %%mm3, %%mm7     \n\t"
                  "movq      %%mm3, %%mm5     \n\t"
                  "movq      24(%%edi), %%mm4 \n\t"
                  "pandn     %%mm4, %%mm5     \n\t"
                  "por       %%mm5, %%mm7     \n\t"
                  "movq      %%mm7, 24(%%edi) \n\t"

                  "addl      $32, %%esi       \n\t" // inc by 32 bytes processed
                  "addl      $32, %%edi       \n\t"
                  "subl      $8, %%ecx        \n\t" // dec by 8 pixels processed
                  "ja        mainloop32       \n\t"

                "mainloop32end:               \n\t"
// preload        "movl      diff, %%ecx      \n\t" // (diff is in eax)
                  "movl      %%eax, %%ecx     \n\t"
                  "cmpl      $0, %%ecx        \n\t"
                  "jz        end32            \n\t"
// preload        "movl      mask, %%edx      \n\t"
                  "sall      $24, %%edx       \n\t" // low byte => high byte

                "secondloop32:                \n\t"
                  "sall      %%edx            \n\t" // move high bit to CF
                  "jnc       skip32           \n\t" // if CF = 0
                  "movl      (%%esi), %%eax   \n\t"
                  "movl      %%eax, (%%edi)   \n\t"

                "skip32:                      \n\t"
                  "addl      $4, %%esi        \n\t"
                  "addl      $4, %%edi        \n\t"
                  "decl      %%ecx            \n\t"
                  "jnz       secondloop32     \n\t"

                "end32:                       \n\t"
                  "EMMS                       \n\t" // DONE

                  : "=a" (dummy_value_a),           // output regs (dummy)
                    "=d" (dummy_value_d),
                    "=c" (dummy_value_c),
                    "=S" (dummy_value_S),
                    "=D" (dummy_value_D)

                  : "3" (srcptr),      // esi       // input regs
                    "4" (dstptr),      // edi
                    "0" (diff),        // eax
// was (unmask)     "b"    RESERVED    // ebx       // Global Offset Table idx
                    "2" (len),         // ecx
                    "1" (mask)         // edx

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                  : "%mm0", "%mm1", "%mm2", "%mm3"  // clobber list
                  , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
               );
            }
            else /* mmx _not supported - Use modified C routine */
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
            {
               register png_uint_32 i;
               png_uint_32 initial_val = BPP4 * png_pass_start[png_ptr->pass];
                 /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
               register int stride = BPP4 * png_pass_inc[png_ptr->pass];
                 /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
               register int rep_bytes = BPP4 * png_pass_width[png_ptr->pass];
                 /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
               png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
               int diff = (int) (png_ptr->width & 7); /* amount lost */
               register png_uint_32 final_val = BPP4 * len;   /* GRR bugfix */

               srcptr = png_ptr->row_buf + 1 + initial_val;
               dstptr = row + initial_val;

               for (i = initial_val; i < final_val; i += stride)
               {
                  png_memcpy(dstptr, srcptr, rep_bytes);
                  srcptr += stride;
                  dstptr += stride;
               }
               if (diff)  /* number of leftover pixels:  3 for pngtest */
               {
                  final_val+=diff*BPP4;
                  for (; i < final_val; i += stride)
                  {
                     if (rep_bytes > (int)(final_val-i))
                        rep_bytes = (int)(final_val-i);
                     png_memcpy(dstptr, srcptr, rep_bytes);
                     srcptr += stride;
                     dstptr += stride;
                  }
               }
            } /* end of else (_mmx_supported) */

            break;
         }       /* end 32 bpp */

         case 48:       /* png_ptr->row_info.pixel_depth */
         {
            png_bytep srcptr;
            png_bytep dstptr;

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
            if ( _mmx_supported )
            {
               png_uint_32 len;
               int diff;
               int dummy_value_a;   // fix 'forbidden register spilled' error
               int dummy_value_d;
               int dummy_value_c;
               int dummy_value_S;
               int dummy_value_D;
               _unmask = ~mask;            // global variable for -fPIC version
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               len  = png_ptr->width &~7;  // reduce to multiple of 8
               diff = (int) (png_ptr->width & 7); // amount lost //

               __asm__ __volatile__ (
                  "movd      _unmask, %%mm7   \n\t" // load bit pattern
                  "psubb     %%mm6, %%mm6     \n\t" // zero mm6
                  "punpcklbw %%mm7, %%mm7     \n\t"
                  "punpcklwd %%mm7, %%mm7     \n\t"
                  "punpckldq %%mm7, %%mm7     \n\t" // fill reg with 8 masks

                  "movq      _mask48_0, %%mm0 \n\t"
                  "movq      _mask48_1, %%mm1 \n\t"
                  "movq      _mask48_2, %%mm2 \n\t"
                  "movq      _mask48_3, %%mm3 \n\t"
                  "movq      _mask48_4, %%mm4 \n\t"
                  "movq      _mask48_5, %%mm5 \n\t"

                  "pand      %%mm7, %%mm0     \n\t"
                  "pand      %%mm7, %%mm1     \n\t"
                  "pand      %%mm7, %%mm2     \n\t"
                  "pand      %%mm7, %%mm3     \n\t"
                  "pand      %%mm7, %%mm4     \n\t"
                  "pand      %%mm7, %%mm5     \n\t"

                  "pcmpeqb   %%mm6, %%mm0     \n\t"
                  "pcmpeqb   %%mm6, %%mm1     \n\t"
                  "pcmpeqb   %%mm6, %%mm2     \n\t"
                  "pcmpeqb   %%mm6, %%mm3     \n\t"
                  "pcmpeqb   %%mm6, %%mm4     \n\t"
                  "pcmpeqb   %%mm6, %%mm5     \n\t"

// preload        "movl      len, %%ecx       \n\t" // load length of line
// preload        "movl      srcptr, %%esi    \n\t" // load source
// preload        "movl      dstptr, %%edi    \n\t" // load dest

                  "cmpl      $0, %%ecx        \n\t"
                  "jz        mainloop48end    \n\t"

                "mainloop48:                  \n\t"
                  "movq      (%%esi), %%mm7   \n\t"
                  "pand      %%mm0, %%mm7     \n\t"
                  "movq      %%mm0, %%mm6     \n\t"
                  "pandn     (%%edi), %%mm6   \n\t"
                  "por       %%mm6, %%mm7     \n\t"
                  "movq      %%mm7, (%%edi)   \n\t"

                  "movq      8(%%esi), %%mm6  \n\t"
                  "pand      %%mm1, %%mm6     \n\t"
                  "movq      %%mm1, %%mm7     \n\t"
                  "pandn     8(%%edi), %%mm7  \n\t"
                  "por       %%mm7, %%mm6     \n\t"
                  "movq      %%mm6, 8(%%edi)  \n\t"

                  "movq      16(%%esi), %%mm6 \n\t"
                  "pand      %%mm2, %%mm6     \n\t"
                  "movq      %%mm2, %%mm7     \n\t"
                  "pandn     16(%%edi), %%mm7 \n\t"
                  "por       %%mm7, %%mm6     \n\t"
                  "movq      %%mm6, 16(%%edi) \n\t"

                  "movq      24(%%esi), %%mm7 \n\t"
                  "pand      %%mm3, %%mm7     \n\t"
                  "movq      %%mm3, %%mm6     \n\t"
                  "pandn     24(%%edi), %%mm6 \n\t"
                  "por       %%mm6, %%mm7     \n\t"
                  "movq      %%mm7, 24(%%edi) \n\t"

                  "movq      32(%%esi), %%mm6 \n\t"
                  "pand      %%mm4, %%mm6     \n\t"
                  "movq      %%mm4, %%mm7     \n\t"
                  "pandn     32(%%edi), %%mm7 \n\t"
                  "por       %%mm7, %%mm6     \n\t"
                  "movq      %%mm6, 32(%%edi) \n\t"

                  "movq      40(%%esi), %%mm7 \n\t"
                  "pand      %%mm5, %%mm7     \n\t"
                  "movq      %%mm5, %%mm6     \n\t"
                  "pandn     40(%%edi), %%mm6 \n\t"
                  "por       %%mm6, %%mm7     \n\t"
                  "movq      %%mm7, 40(%%edi) \n\t"

                  "addl      $48, %%esi       \n\t" // inc by 48 bytes processed
                  "addl      $48, %%edi       \n\t"
                  "subl      $8, %%ecx        \n\t" // dec by 8 pixels processed

                  "ja        mainloop48       \n\t"

                "mainloop48end:               \n\t"
// preload        "movl      diff, %%ecx      \n\t" // (diff is in eax)
                  "movl      %%eax, %%ecx     \n\t"
                  "cmpl      $0, %%ecx        \n\t"
                  "jz        end48            \n\t"
// preload        "movl      mask, %%edx      \n\t"
                  "sall      $24, %%edx       \n\t" // make low byte, high byte

                "secondloop48:                \n\t"
                  "sall      %%edx            \n\t" // move high bit to CF
                  "jnc       skip48           \n\t" // if CF = 0
                  "movl      (%%esi), %%eax   \n\t"
                  "movl      %%eax, (%%edi)   \n\t"

                "skip48:                      \n\t"
                  "addl      $4, %%esi        \n\t"
                  "addl      $4, %%edi        \n\t"
                  "decl      %%ecx            \n\t"
                  "jnz       secondloop48     \n\t"

                "end48:                       \n\t"
                  "EMMS                       \n\t" // DONE

                  : "=a" (dummy_value_a),           // output regs (dummy)
                    "=d" (dummy_value_d),
                    "=c" (dummy_value_c),
                    "=S" (dummy_value_S),
                    "=D" (dummy_value_D)

                  : "3" (srcptr),      // esi       // input regs
                    "4" (dstptr),      // edi
                    "0" (diff),        // eax
// was (unmask)     "b"    RESERVED    // ebx       // Global Offset Table idx
                    "2" (len),         // ecx
                    "1" (mask)         // edx

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                  : "%mm0", "%mm1", "%mm2", "%mm3"  // clobber list
                  , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
               );
            }
            else /* mmx _not supported - Use modified C routine */
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
            {
               register png_uint_32 i;
               png_uint_32 initial_val = BPP6 * png_pass_start[png_ptr->pass];
                 /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
               register int stride = BPP6 * png_pass_inc[png_ptr->pass];
                 /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
               register int rep_bytes = BPP6 * png_pass_width[png_ptr->pass];
                 /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
               png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
               int diff = (int) (png_ptr->width & 7); /* amount lost */
               register png_uint_32 final_val = BPP6 * len;   /* GRR bugfix */

               srcptr = png_ptr->row_buf + 1 + initial_val;
               dstptr = row + initial_val;

               for (i = initial_val; i < final_val; i += stride)
               {
                  png_memcpy(dstptr, srcptr, rep_bytes);
                  srcptr += stride;
                  dstptr += stride;
               }
               if (diff)  /* number of leftover pixels:  3 for pngtest */
               {
                  final_val+=diff*BPP6;
                  for (; i < final_val; i += stride)
                  {
                     if (rep_bytes > (int)(final_val-i))
                        rep_bytes = (int)(final_val-i);
                     png_memcpy(dstptr, srcptr, rep_bytes);
                     srcptr += stride;
                     dstptr += stride;
                  }
               }
            } /* end of else (_mmx_supported) */

            break;
         }       /* end 48 bpp */

         case 64:       /* png_ptr->row_info.pixel_depth */
         {
            png_bytep srcptr;
            png_bytep dstptr;
            register png_uint_32 i;
            png_uint_32 initial_val = BPP8 * png_pass_start[png_ptr->pass];
              /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
            register int stride = BPP8 * png_pass_inc[png_ptr->pass];
              /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
            register int rep_bytes = BPP8 * png_pass_width[png_ptr->pass];
              /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
            png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
            int diff = (int) (png_ptr->width & 7); /* amount lost */
            register png_uint_32 final_val = BPP8 * len;   /* GRR bugfix */

            srcptr = png_ptr->row_buf + 1 + initial_val;
            dstptr = row + initial_val;

            for (i = initial_val; i < final_val; i += stride)
            {
               png_memcpy(dstptr, srcptr, rep_bytes);
               srcptr += stride;
               dstptr += stride;
            }
            if (diff)  /* number of leftover pixels:  3 for pngtest */
            {
               final_val+=diff*BPP8;
               for (; i < final_val; i += stride)
               {
                  if (rep_bytes > (int)(final_val-i))
                     rep_bytes = (int)(final_val-i);
                  png_memcpy(dstptr, srcptr, rep_bytes);
                  srcptr += stride;
                  dstptr += stride;
               }
            }

            break;
         }       /* end 64 bpp */

         default: /* png_ptr->row_info.pixel_depth != 1,2,4,8,16,24,32,48,64 */
         {
            /* this should never happen */
            fprintf(stderr,
              "libpng internal error:  png_ptr->row_info.pixel_depth = %d\n",
              png_ptr->row_info.pixel_depth);
            fflush(stderr);
            break;
         }
      } /* end switch (png_ptr->row_info.pixel_depth) */

   } /* end if (non-trivial mask) */

} /* end png_combine_row() */

#endif /* PNG_HAVE_ASSEMBLER_COMBINE_ROW */




/*===========================================================================*/
/*                                                                           */
/*                 P N G _ D O _ R E A D _ I N T E R L A C E                 */
/*                                                                           */
/*===========================================================================*/

#if defined(PNG_READ_INTERLACING_SUPPORTED)
#if defined(PNG_HAVE_ASSEMBLER_READ_INTERLACE)

/* png_do_read_interlace() is called after any 16-bit to 8-bit conversion
 * has taken place.  [GRR: what other steps come before and/or after?]
 */

void /* PRIVATE */
png_do_read_interlace(png_structp png_ptr)
{
   png_row_infop row_info = &(png_ptr->row_info);
   png_bytep row = png_ptr->row_buf + 1;
   int pass = png_ptr->pass;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
   png_uint_32 transformations = png_ptr->transformations;
#endif

   png_debug(1, "in png_do_read_interlace (pnggccrd.c)\n");

   if (_mmx_supported == 2) {
       png_mmx_support();
   }

   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_byte v;
            png_uint_32 i;
            int j;

            sp = row + (png_size_t)((row_info->width - 1) >> 3);
            dp = row + (png_size_t)((final_width - 1) >> 3);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)((row_info->width + 7) & 7);
               dshift = (int)((final_width + 7) & 7);
               s_start = 7;
               s_end = 0;
               s_inc = -1;
            }
            else
#endif
            {
               sshift = 7 - (int)((row_info->width + 7) & 7);
               dshift = 7 - (int)((final_width + 7) & 7);
               s_start = 0;
               s_end = 7;
               s_inc = 1;
            }

            for (i = row_info->width; i; i--)
            {
               v = (png_byte)((*sp >> sshift) & 0x1);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         case 2:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;

            sp = row + (png_size_t)((row_info->width - 1) >> 2);
            dp = row + (png_size_t)((final_width - 1) >> 2);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (png_size_t)(((row_info->width + 3) & 3) << 1);
               dshift = (png_size_t)(((final_width + 3) & 3) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }
            else
#endif
            {
               sshift = (png_size_t)((3 - ((row_info->width + 3) & 3)) << 1);
               dshift = (png_size_t)((3 - ((final_width + 3) & 3)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = row_info->width; i; i--)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x3);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         case 4:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;

            sp = row + (png_size_t)((row_info->width - 1) >> 1);
            dp = row + (png_size_t)((final_width - 1) >> 1);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (png_size_t)(((row_info->width + 1) & 1) << 2);
               dshift = (png_size_t)(((final_width + 1) & 1) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            else
#endif
            {
               sshift = (png_size_t)((1 - ((row_info->width + 1) & 1)) << 2);
               dshift = (png_size_t)((1 - ((final_width + 1) & 1)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = row_info->width; i; i--)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0xf);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

       /*====================================================================*/

         default: /* 8-bit or larger (this is where the routine is modified) */
         {
#if 0
//          static unsigned long long _const4 = 0x0000000000FFFFFFLL;  no good
//          static unsigned long long const4 = 0x0000000000FFFFFFLL;   no good
//          unsigned long long _const4 = 0x0000000000FFFFFFLL;         no good
//          unsigned long long const4 = 0x0000000000FFFFFFLL;          no good
#endif
            png_bytep sptr, dp;
            png_uint_32 i;
            png_size_t pixel_bytes;
            int width = (int)row_info->width;

            pixel_bytes = (row_info->pixel_depth >> 3);

            /* point sptr at the last pixel in the pre-expanded row: */
            sptr = row + (width - 1) * pixel_bytes;

            /* point dp at the last pixel position in the expanded row: */
            dp = row + (final_width - 1) * pixel_bytes;

            /* New code by Nirav Chhatrapati - Intel Corporation */

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
            if ( _mmx_supported )
            {
               //--------------------------------------------------------------
               if (pixel_bytes == 3)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int dummy_value_c;   // fix 'forbidden register spilled'
                     int dummy_value_S;
                     int dummy_value_D;

                     __asm__ __volatile__ (
                        "subl $21, %%edi         \n\t"
                                     // (png_pass_inc[pass] - 1)*pixel_bytes

                     ".loop3_pass0:              \n\t"
                        "movd (%%esi), %%mm0     \n\t" // x x x x x 2 1 0
                        "pand _const4, %%mm0     \n\t" // z z z z z 2 1 0
                        "movq %%mm0, %%mm1       \n\t" // z z z z z 2 1 0
                        "psllq $16, %%mm0        \n\t" // z z z 2 1 0 z z
                        "movq %%mm0, %%mm2       \n\t" // z z z 2 1 0 z z
                        "psllq $24, %%mm0        \n\t" // 2 1 0 z z z z z
                        "psrlq $8, %%mm1         \n\t" // z z z z z z 2 1
                        "por %%mm2, %%mm0        \n\t" // 2 1 0 2 1 0 z z
                        "por %%mm1, %%mm0        \n\t" // 2 1 0 2 1 0 2 1
                        "movq %%mm0, %%mm3       \n\t" // 2 1 0 2 1 0 2 1
                        "psllq $16, %%mm0        \n\t" // 0 2 1 0 2 1 z z
                        "movq %%mm3, %%mm4       \n\t" // 2 1 0 2 1 0 2 1
                        "punpckhdq %%mm0, %%mm3  \n\t" // 0 2 1 0 2 1 0 2
                        "movq %%mm4, 16(%%edi)   \n\t"
                        "psrlq $32, %%mm0        \n\t" // z z z z 0 2 1 0
                        "movq %%mm3, 8(%%edi)    \n\t"
                        "punpckldq %%mm4, %%mm0  \n\t" // 1 0 2 1 0 2 1 0
                        "subl $3, %%esi          \n\t"
                        "movq %%mm0, (%%edi)     \n\t"
                        "subl $24, %%edi         \n\t"
                        "decl %%ecx              \n\t"
                        "jnz .loop3_pass0        \n\t"
                        "EMMS                    \n\t" // DONE

                        : "=c" (dummy_value_c),        // output regs (dummy)
                          "=S" (dummy_value_S),
                          "=D" (dummy_value_D)

                        : "1" (sptr),      // esi      // input regs
                          "2" (dp),        // edi
                          "0" (width)      // ecx
// doesn't work           "i" (0x0000000000FFFFFFLL)   // %1 (a.k.a. _const4)

#if 0  /* %mm0, ..., %mm4 not supported by gcc 2.7.2.3 or egcs 1.1 */
                        : "%mm0", "%mm1", "%mm2"       // clobber list
                        , "%mm3", "%mm4"
#endif
                     );
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int dummy_value_c;   // fix 'forbidden register spilled'
                     int dummy_value_S;
                     int dummy_value_D;

                     __asm__ __volatile__ (
                        "subl $9, %%edi          \n\t"
                                     // (png_pass_inc[pass] - 1)*pixel_bytes

                     ".loop3_pass2:              \n\t"
                        "movd (%%esi), %%mm0     \n\t" // x x x x x 2 1 0
                        "pand _const4, %%mm0     \n\t" // z z z z z 2 1 0
                        "movq %%mm0, %%mm1       \n\t" // z z z z z 2 1 0
                        "psllq $16, %%mm0        \n\t" // z z z 2 1 0 z z
                        "movq %%mm0, %%mm2       \n\t" // z z z 2 1 0 z z
                        "psllq $24, %%mm0        \n\t" // 2 1 0 z z z z z
                        "psrlq $8, %%mm1         \n\t" // z z z z z z 2 1
                        "por %%mm2, %%mm0        \n\t" // 2 1 0 2 1 0 z z
                        "por %%mm1, %%mm0        \n\t" // 2 1 0 2 1 0 2 1
                        "movq %%mm0, 4(%%edi)    \n\t"
                        "psrlq $16, %%mm0        \n\t" // z z 2 1 0 2 1 0
                        "subl $3, %%esi          \n\t"
                        "movd %%mm0, (%%edi)     \n\t"
                        "subl $12, %%edi         \n\t"
                        "decl %%ecx              \n\t"
                        "jnz .loop3_pass2        \n\t"
                        "EMMS                    \n\t" // DONE

                        : "=c" (dummy_value_c),        // output regs (dummy)
                          "=S" (dummy_value_S),
                          "=D" (dummy_value_D)

                        : "1" (sptr),      // esi      // input regs
                          "2" (dp),        // edi
                          "0" (width)      // ecx

#if 0  /* %mm0, ..., %mm2 not supported by gcc 2.7.2.3 or egcs 1.1 */
                        : "%mm0", "%mm1", "%mm2"       // clobber list
#endif
                     );
                  }
                  else if (width) /* && ((pass == 4) || (pass == 5)) */
                  {
                     int width_mmx = ((width >> 1) << 1) - 8;   // GRR:  huh?
                     if (width_mmx < 0)
                         width_mmx = 0;
                     width -= width_mmx;        // 8 or 9 pix, 24 or 27 bytes
                     if (width_mmx)
                     {
                        // png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
                        // sptr points at last pixel in pre-expanded row
                        // dp points at last pixel position in expanded row
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $3, %%esi          \n\t"
                           "subl $9, %%edi          \n\t"
                                        // (png_pass_inc[pass] + 1)*pixel_bytes

                        ".loop3_pass4:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // x x 5 4 3 2 1 0
                           "movq %%mm0, %%mm1       \n\t" // x x 5 4 3 2 1 0
                           "movq %%mm0, %%mm2       \n\t" // x x 5 4 3 2 1 0
                           "psllq $24, %%mm0        \n\t" // 4 3 2 1 0 z z z
                           "pand _const4, %%mm1     \n\t" // z z z z z 2 1 0
                           "psrlq $24, %%mm2        \n\t" // z z z x x 5 4 3
                           "por %%mm1, %%mm0        \n\t" // 4 3 2 1 0 2 1 0
                           "movq %%mm2, %%mm3       \n\t" // z z z x x 5 4 3
                           "psllq $8, %%mm2         \n\t" // z z x x 5 4 3 z
                           "movq %%mm0, (%%edi)     \n\t"
                           "psrlq $16, %%mm3        \n\t" // z z z z z x x 5
                           "pand _const6, %%mm3     \n\t" // z z z z z z z 5
                           "por %%mm3, %%mm2        \n\t" // z z x x 5 4 3 5
                           "subl $6, %%esi          \n\t"
                           "movd %%mm2, 8(%%edi)    \n\t"
                           "subl $12, %%edi         \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop3_pass4        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, ..., %mm3 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
                           , "%mm2", "%mm3"
#endif
                        );
                     }

                     sptr -= width_mmx*3;
                     dp -= width_mmx*6;
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;

                        png_memcpy(v, sptr, 3);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           png_memcpy(dp, v, 3);
                           dp -= 3;
                        }
                        sptr -= 3;
                     }
                  }
               } /* end of pixel_bytes == 3 */

               //--------------------------------------------------------------
               else if (pixel_bytes == 1)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int width_mmx = ((width >> 2) << 2);
                     width -= width_mmx;        // 0-3 pixels => 0-3 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $3, %%esi          \n\t"
                           "subl $31, %%edi         \n\t"

                        ".loop1_pass0:              \n\t"
                           "movd (%%esi), %%mm0     \n\t" // x x x x 3 2 1 0
                           "movq %%mm0, %%mm1       \n\t" // x x x x 3 2 1 0
                           "punpcklbw %%mm0, %%mm0  \n\t" // 3 3 2 2 1 1 0 0
                           "movq %%mm0, %%mm2       \n\t" // 3 3 2 2 1 1 0 0
                           "punpcklwd %%mm0, %%mm0  \n\t" // 1 1 1 1 0 0 0 0
                           "movq %%mm0, %%mm3       \n\t" // 1 1 1 1 0 0 0 0
                           "punpckldq %%mm0, %%mm0  \n\t" // 0 0 0 0 0 0 0 0
                           "punpckhdq %%mm3, %%mm3  \n\t" // 1 1 1 1 1 1 1 1
                           "movq %%mm0, (%%edi)     \n\t"
                           "punpckhwd %%mm2, %%mm2  \n\t" // 3 3 3 3 2 2 2 2
                           "movq %%mm3, 8(%%edi)    \n\t"
                           "movq %%mm2, %%mm4       \n\t" // 3 3 3 3 2 2 2 2
                           "punpckldq %%mm2, %%mm2  \n\t" // 2 2 2 2 2 2 2 2
                           "punpckhdq %%mm4, %%mm4  \n\t" // 3 3 3 3 3 3 3 3
                           "movq %%mm2, 16(%%edi)   \n\t"
                           "subl $4, %%esi          \n\t"
                           "movq %%mm4, 24(%%edi)   \n\t"
                           "subl $32, %%edi         \n\t"
                           "subl $4, %%ecx          \n\t"
                           "jnz .loop1_pass0        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, ..., %mm4 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1", "%mm2"       // clobber list
                           , "%mm3", "%mm4"
#endif
                        );
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*8;
                     for (i = width; i; i--)
                     {
                        int j;

                       /* I simplified this part in version 1.0.4e
                        * here and in several other instances where
                        * pixel_bytes == 1  -- GR-P
                        *
                        * Original code:
                        *
                        * png_byte v[8];
                        * png_memcpy(v, sptr, pixel_bytes);
                        * for (j = 0; j < png_pass_inc[pass]; j++)
                        * {
                        *    png_memcpy(dp, v, pixel_bytes);
                        *    dp -= pixel_bytes;
                        * }
                        * sptr -= pixel_bytes;
                        *
                        * Replacement code is in the next three lines:
                        */

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        --sptr;
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int width_mmx = ((width >> 2) << 2);
                     width -= width_mmx;        // 0-3 pixels => 0-3 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $3, %%esi          \n\t"
                           "subl $15, %%edi         \n\t"

                        ".loop1_pass2:              \n\t"
                           "movd (%%esi), %%mm0     \n\t" // x x x x 3 2 1 0
                           "punpcklbw %%mm0, %%mm0  \n\t" // 3 3 2 2 1 1 0 0
                           "movq %%mm0, %%mm1       \n\t" // 3 3 2 2 1 1 0 0
                           "punpcklwd %%mm0, %%mm0  \n\t" // 1 1 1 1 0 0 0 0
                           "punpckhwd %%mm1, %%mm1  \n\t" // 3 3 3 3 2 2 2 2
                           "movq %%mm0, (%%edi)     \n\t"
                           "subl $4, %%esi          \n\t"
                           "movq %%mm1, 8(%%edi)    \n\t"
                           "subl $16, %%edi         \n\t"
                           "subl $4, %%ecx          \n\t"
                           "jnz .loop1_pass2        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*4;
                     for (i = width; i; i--)
                     {
                        int j;

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        --sptr;
                     }
                  }
                  else if (width)  /* && ((pass == 4) || (pass == 5)) */
                  {
                     int width_mmx = ((width >> 3) << 3);
                     width -= width_mmx;        // 0-3 pixels => 0-3 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $7, %%esi          \n\t"
                           "subl $15, %%edi         \n\t"

                        ".loop1_pass4:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                           "movq %%mm0, %%mm1       \n\t" // 7 6 5 4 3 2 1 0
                           "punpcklbw %%mm0, %%mm0  \n\t" // 3 3 2 2 1 1 0 0
                           "punpckhbw %%mm1, %%mm1  \n\t" // 7 7 6 6 5 5 4 4
                           "movq %%mm1, 8(%%edi)    \n\t"
                           "subl $8, %%esi          \n\t"
                           "movq %%mm0, (%%edi)     \n\t"
                           "subl $16, %%edi         \n\t"
                           "subl $8, %%ecx          \n\t"
                           "jnz .loop1_pass4        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (none)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*2;
                     for (i = width; i; i--)
                     {
                        int j;

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        --sptr;
                     }
                  }
               } /* end of pixel_bytes == 1 */

               //--------------------------------------------------------------
               else if (pixel_bytes == 2)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1);
                     width -= width_mmx;        // 0,1 pixels => 0,2 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $2, %%esi          \n\t"
                           "subl $30, %%edi         \n\t"

                        ".loop2_pass0:              \n\t"
                           "movd (%%esi), %%mm0     \n\t" // x x x x 3 2 1 0
                           "punpcklwd %%mm0, %%mm0  \n\t" // 3 2 3 2 1 0 1 0
                           "movq %%mm0, %%mm1       \n\t" // 3 2 3 2 1 0 1 0
                           "punpckldq %%mm0, %%mm0  \n\t" // 1 0 1 0 1 0 1 0
                           "punpckhdq %%mm1, %%mm1  \n\t" // 3 2 3 2 3 2 3 2
                           "movq %%mm0, (%%edi)     \n\t"
                           "movq %%mm0, 8(%%edi)    \n\t"
                           "movq %%mm1, 16(%%edi)   \n\t"
                           "subl $4, %%esi          \n\t"
                           "movq %%mm1, 24(%%edi)   \n\t"
                           "subl $32, %%edi         \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop2_pass0        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= (width_mmx*2 - 2); // sign fixed
                     dp -= (width_mmx*16 - 2);  // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 2;
                        png_memcpy(v, sptr, 2);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 2;
                           png_memcpy(dp, v, 2);
                        }
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;        // 0,1 pixels => 0,2 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $2, %%esi          \n\t"
                           "subl $14, %%edi         \n\t"

                        ".loop2_pass2:              \n\t"
                           "movd (%%esi), %%mm0     \n\t" // x x x x 3 2 1 0
                           "punpcklwd %%mm0, %%mm0  \n\t" // 3 2 3 2 1 0 1 0
                           "movq %%mm0, %%mm1       \n\t" // 3 2 3 2 1 0 1 0
                           "punpckldq %%mm0, %%mm0  \n\t" // 1 0 1 0 1 0 1 0
                           "punpckhdq %%mm1, %%mm1  \n\t" // 3 2 3 2 3 2 3 2
                           "movq %%mm0, (%%edi)     \n\t"
                           "subl $4, %%esi          \n\t"
                           "movq %%mm1, 8(%%edi)    \n\t"
                           "subl $16, %%edi         \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop2_pass2        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= (width_mmx*2 - 2); // sign fixed
                     dp -= (width_mmx*8 - 2);   // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 2;
                        png_memcpy(v, sptr, 2);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 2;
                           png_memcpy(dp, v, 2);
                        }
                     }
                  }
                  else if (width)  // pass == 4 or 5
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;        // 0,1 pixels => 0,2 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $2, %%esi          \n\t"
                           "subl $6, %%edi          \n\t"

                        ".loop2_pass4:              \n\t"
                           "movd (%%esi), %%mm0     \n\t" // x x x x 3 2 1 0
                           "punpcklwd %%mm0, %%mm0  \n\t" // 3 2 3 2 1 0 1 0
                           "subl $4, %%esi          \n\t"
                           "movq %%mm0, (%%edi)     \n\t"
                           "subl $8, %%edi          \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop2_pass4        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0"                       // clobber list
#endif
                        );
                     }

                     sptr -= (width_mmx*2 - 2); // sign fixed
                     dp -= (width_mmx*4 - 2);   // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 2;
                        png_memcpy(v, sptr, 2);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 2;
                           png_memcpy(dp, v, 2);
                        }
                     }
                  }
               } /* end of pixel_bytes == 2 */

               //--------------------------------------------------------------
               else if (pixel_bytes == 4)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1);
                     width -= width_mmx;        // 0,1 pixels => 0,4 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $4, %%esi          \n\t"
                           "subl $60, %%edi         \n\t"

                        ".loop4_pass0:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                           "movq %%mm0, %%mm1       \n\t" // 7 6 5 4 3 2 1 0
                           "punpckldq %%mm0, %%mm0  \n\t" // 3 2 1 0 3 2 1 0
                           "punpckhdq %%mm1, %%mm1  \n\t" // 7 6 5 4 7 6 5 4
                           "movq %%mm0, (%%edi)     \n\t"
                           "movq %%mm0, 8(%%edi)    \n\t"
                           "movq %%mm0, 16(%%edi)   \n\t"
                           "movq %%mm0, 24(%%edi)   \n\t"
                           "movq %%mm1, 32(%%edi)   \n\t"
                           "movq %%mm1, 40(%%edi)   \n\t"
                           "movq %%mm1, 48(%%edi)   \n\t"
                           "subl $8, %%esi          \n\t"
                           "movq %%mm1, 56(%%edi)   \n\t"
                           "subl $64, %%edi         \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop4_pass0        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= (width_mmx*4 - 4); // sign fixed
                     dp -= (width_mmx*32 - 4);  // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 4;
                        png_memcpy(v, sptr, 4);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 4;
                           png_memcpy(dp, v, 4);
                        }
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1);
                     width -= width_mmx;        // 0,1 pixels => 0,4 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $4, %%esi          \n\t"
                           "subl $28, %%edi         \n\t"

                        ".loop4_pass2:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                           "movq %%mm0, %%mm1       \n\t" // 7 6 5 4 3 2 1 0
                           "punpckldq %%mm0, %%mm0  \n\t" // 3 2 1 0 3 2 1 0
                           "punpckhdq %%mm1, %%mm1  \n\t" // 7 6 5 4 7 6 5 4
                           "movq %%mm0, (%%edi)     \n\t"
                           "movq %%mm0, 8(%%edi)    \n\t"
                           "movq %%mm1, 16(%%edi)   \n\t"
                           "movq %%mm1, 24(%%edi)   \n\t"
                           "subl $8, %%esi          \n\t"
                           "subl $32, %%edi         \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop4_pass2        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= (width_mmx*4 - 4); // sign fixed
                     dp -= (width_mmx*16 - 4);  // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 4;
                        png_memcpy(v, sptr, 4);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 4;
                           png_memcpy(dp, v, 4);
                        }
                     }
                  }
                  else if (width)  // pass == 4 or 5
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;        // 0,1 pixels => 0,4 bytes
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $4, %%esi          \n\t"
                           "subl $12, %%edi         \n\t"

                        ".loop4_pass4:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                           "movq %%mm0, %%mm1       \n\t" // 7 6 5 4 3 2 1 0
                           "punpckldq %%mm0, %%mm0  \n\t" // 3 2 1 0 3 2 1 0
                           "punpckhdq %%mm1, %%mm1  \n\t" // 7 6 5 4 7 6 5 4
                           "movq %%mm0, (%%edi)     \n\t"
                           "subl $8, %%esi          \n\t"
                           "movq %%mm1, 8(%%edi)    \n\t"
                           "subl $16, %%edi         \n\t"
                           "subl $2, %%ecx          \n\t"
                           "jnz .loop4_pass4        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width_mmx)  // ecx

#if 0  /* %mm0, %mm1 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0", "%mm1"               // clobber list
#endif
                        );
                     }

                     sptr -= (width_mmx*4 - 4); // sign fixed
                     dp -= (width_mmx*8 - 4);   // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 4;
                        png_memcpy(v, sptr, 4);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 4;
                           png_memcpy(dp, v, 4);
                        }
                     }
                  }
               } /* end of pixel_bytes == 4 */

               //--------------------------------------------------------------
               else if (pixel_bytes == 8)
               {
// GRR TEST:  should work, but needs testing (special 64-bit version of rpng2?)
                  // GRR NOTE:  no need to combine passes here!
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int dummy_value_c;  // fix 'forbidden register spilled'
                     int dummy_value_S;
                     int dummy_value_D;

                     // source is 8-byte RRGGBBAA
                     // dest is 64-byte RRGGBBAA RRGGBBAA RRGGBBAA RRGGBBAA ...
                     __asm__ __volatile__ (
                        "subl $56, %%edi         \n\t" // start of last block

                     ".loop8_pass0:              \n\t"
                        "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                        "movq %%mm0, (%%edi)     \n\t"
                        "movq %%mm0, 8(%%edi)    \n\t"
                        "movq %%mm0, 16(%%edi)   \n\t"
                        "movq %%mm0, 24(%%edi)   \n\t"
                        "movq %%mm0, 32(%%edi)   \n\t"
                        "movq %%mm0, 40(%%edi)   \n\t"
                        "movq %%mm0, 48(%%edi)   \n\t"
                        "subl $8, %%esi          \n\t"
                        "movq %%mm0, 56(%%edi)   \n\t"
                        "subl $64, %%edi         \n\t"
                        "decl %%ecx              \n\t"
                        "jnz .loop8_pass0        \n\t"
                        "EMMS                    \n\t" // DONE

                        : "=c" (dummy_value_c),        // output regs (dummy)
                          "=S" (dummy_value_S),
                          "=D" (dummy_value_D)

                        : "1" (sptr),      // esi      // input regs
                          "2" (dp),        // edi
                          "0" (width)      // ecx

#if 0  /* %mm0 not supported by gcc 2.7.2.3 or egcs 1.1 */
                        : "%mm0"                       // clobber list
#endif
                     );
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     // source is 8-byte RRGGBBAA
                     // dest is 32-byte RRGGBBAA RRGGBBAA RRGGBBAA RRGGBBAA
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $24, %%edi         \n\t" // start of last block

                        ".loop8_pass2:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                           "movq %%mm0, (%%edi)     \n\t"
                           "movq %%mm0, 8(%%edi)    \n\t"
                           "movq %%mm0, 16(%%edi)   \n\t"
                           "subl $8, %%esi          \n\t"
                           "movq %%mm0, 24(%%edi)   \n\t"
                           "subl $32, %%edi         \n\t"
                           "decl %%ecx              \n\t"
                           "jnz .loop8_pass2        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width)      // ecx

#if 0  /* %mm0 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0"                       // clobber list
#endif
                        );
                     }
                  }
                  else if (width)  // pass == 4 or 5
                  {
                     // source is 8-byte RRGGBBAA
                     // dest is 16-byte RRGGBBAA RRGGBBAA
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        int dummy_value_c;  // fix 'forbidden register spilled'
                        int dummy_value_S;
                        int dummy_value_D;

                        __asm__ __volatile__ (
                           "subl $8, %%edi          \n\t" // start of last block

                        ".loop8_pass4:              \n\t"
                           "movq (%%esi), %%mm0     \n\t" // 7 6 5 4 3 2 1 0
                           "movq %%mm0, (%%edi)     \n\t"
                           "subl $8, %%esi          \n\t"
                           "movq %%mm0, 8(%%edi)    \n\t"
                           "subl $16, %%edi         \n\t"
                           "decl %%ecx              \n\t"
                           "jnz .loop8_pass4        \n\t"
                           "EMMS                    \n\t" // DONE

                           : "=c" (dummy_value_c),        // output regs (dummy)
                             "=S" (dummy_value_S),
                             "=D" (dummy_value_D)

                           : "1" (sptr),      // esi      // input regs
                             "2" (dp),        // edi
                             "0" (width)      // ecx

#if 0  /* %mm0 not supported by gcc 2.7.2.3 or egcs 1.1 */
                           : "%mm0"                       // clobber list
#endif
                        );
                     }
                  }

               } /* end of pixel_bytes == 8 */

               //--------------------------------------------------------------
               else if (pixel_bytes == 6)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 6);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, 6);
                        dp -= 6;
                     }
                     sptr -= 6;
                  }
               } /* end of pixel_bytes == 6 */

               //--------------------------------------------------------------
               else
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr-= pixel_bytes;
                  }
               }
            } // end of _mmx_supported ========================================

            else /* MMX not supported:  use modified C code - takes advantage
                  *   of inlining of png_memcpy for a constant */
                 /* GRR 19991007:  does it?  or should pixel_bytes in each
                  *   block be replaced with immediate value (e.g., 1)? */
                 /* GRR 19991017:  replaced with constants in each case */
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
            {
               if (pixel_bytes == 1)
               {
                  for (i = width; i; i--)
                  {
                     int j;
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        *dp-- = *sptr;
                     }
                     --sptr;
                  }
               }
               else if (pixel_bytes == 3)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 3);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, 3);
                        dp -= 3;
                     }
                     sptr -= 3;
                  }
               }
               else if (pixel_bytes == 2)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 2);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, 2);
                        dp -= 2;
                     }
                     sptr -= 2;
                  }
               }
               else if (pixel_bytes == 4)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 4);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
#ifdef PNG_DEBUG
               if (dp < row || dp+3 > row+png_ptr->row_buf_size)
                 {
                  printf("dp out of bounds: row=%d, dp=%d, rp=%d\n",row, dp,
                    row+png_ptr->row_buf_size);
                  printf("row_buf=%d\n",png_ptr->row_buf_size);
                 }
#endif
                        png_memcpy(dp, v, 4);
                        dp -= 4;
                     }
                     sptr -= 4;
                  }
               }
               else if (pixel_bytes == 6)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 6);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, 6);
                        dp -= 6;
                     }
                     sptr -= 6;
                  }
               }
               else if (pixel_bytes == 8)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 8);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, 8);
                        dp -= 8;
                     }
                     sptr -= 8;
                  }
               }
               else     /* GRR:  should never be reached */
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }

            } /* end if (MMX not supported) */
            break;
         }
      } /* end switch (row_info->pixel_depth) */

      row_info->width = final_width;
      row_info->rowbytes = ((final_width *
         (png_uint_32)row_info->pixel_depth + 7) >> 3);
   }

} /* end png_do_read_interlace() */

#endif /* PNG_HAVE_ASSEMBLER_READ_INTERLACE */
#endif /* PNG_READ_INTERLACING_SUPPORTED */




#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)

// These variables are utilized in the functions below.  They are declared
// globally here to ensure alignment on 8-byte boundaries.

union uAll {
   long long use;
   double  align;
} _LBCarryMask = {0x0101010101010101LL},
  _HBClearMask = {0x7f7f7f7f7f7f7f7fLL},
  _ActiveMask, _ActiveMask2, _ActiveMaskEnd, _ShiftBpp, _ShiftRem;



//===========================================================================//
//                                                                           //
//           P N G _ R E A D _ F I L T E R _ R O W _ M M X _ A V G           //
//                                                                           //
//===========================================================================//

// Optimized code for PNG Average filter decoder

static void /* PRIVATE */
png_read_filter_row_mmx_avg(png_row_infop row_info, png_bytep row,
                            png_bytep prev_row)
{
   int bpp;
   int dummy_value_c;   // fix 'forbidden register 2 (cx) was spilled' error
   int dummy_value_S;
   int dummy_value_D;

   bpp = (row_info->pixel_depth + 7) >> 3;  // get # bytes per pixel
   _FullLength  = row_info->rowbytes;       // # of bytes to filter

   __asm__ __volatile__ (
      // initialize address pointers and offset
#ifdef __PIC__
      "pushl %%ebx                 \n\t" // save index to Global Offset Table
#endif
//pre "movl row, %%edi             \n\t" // edi:  Avg(x)
      "xorl %%ebx, %%ebx           \n\t" // ebx:  x
      "movl %%edi, %%edx           \n\t"
//pre "movl prev_row, %%esi        \n\t" // esi:  Prior(x)
//pre "subl bpp, %%edx             \n\t" // (bpp is preloaded into ecx)
      "subl %%ecx, %%edx           \n\t" // edx:  Raw(x-bpp)

      "xorl %%eax,%%eax            \n\t"

      // Compute the Raw value for the first bpp bytes
      //    Raw(x) = Avg(x) + (Prior(x)/2)
   "avg_rlp:                       \n\t"
      "movb (%%esi,%%ebx,),%%al    \n\t" // load al with Prior(x)
      "incl %%ebx                  \n\t"
      "shrb %%al                   \n\t" // divide by 2
      "addb -1(%%edi,%%ebx,),%%al  \n\t" // add Avg(x); -1 to offset inc ebx
//pre "cmpl bpp, %%ebx             \n\t" // (bpp is preloaded into ecx)
      "cmpl %%ecx, %%ebx           \n\t"
      "movb %%al,-1(%%edi,%%ebx,)  \n\t" // write Raw(x); -1 to offset inc ebx
      "jb avg_rlp                  \n\t" // mov does not affect flags

      // get # of bytes to alignment
      "movl %%edi, _dif            \n\t" // take start of row
      "addl %%ebx, _dif            \n\t" // add bpp
      "addl $0xf, _dif             \n\t" // add 7+8 to incr past alignment bdry
      "andl $0xfffffff8, _dif      \n\t" // mask to alignment boundary
      "subl %%edi, _dif            \n\t" // subtract from start => value ebx at
      "jz avg_go                   \n\t" //  alignment

      // fix alignment
      // Compute the Raw value for the bytes up to the alignment boundary
      //    Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
      "xorl %%ecx, %%ecx           \n\t"

   "avg_lp1:                       \n\t"
      "xorl %%eax, %%eax           \n\t"
      "movb (%%esi,%%ebx,), %%cl   \n\t" // load cl with Prior(x)
      "movb (%%edx,%%ebx,), %%al   \n\t" // load al with Raw(x-bpp)
      "addw %%cx, %%ax             \n\t"
      "incl %%ebx                  \n\t"
      "shrw %%ax                   \n\t" // divide by 2
      "addb -1(%%edi,%%ebx,), %%al \n\t" // add Avg(x); -1 to offset inc ebx
      "cmpl _dif, %%ebx            \n\t" // check if at alignment boundary
      "movb %%al, -1(%%edi,%%ebx,) \n\t" // write Raw(x); -1 to offset inc ebx
      "jb avg_lp1                  \n\t" // repeat until at alignment boundary

   "avg_go:                        \n\t"
      "movl _FullLength, %%eax     \n\t"
      "movl %%eax, %%ecx           \n\t"
      "subl %%ebx, %%eax           \n\t" // subtract alignment fix
      "andl $0x00000007, %%eax     \n\t" // calc bytes over mult of 8
      "subl %%eax, %%ecx           \n\t" // drop over bytes from original length
      "movl %%ecx, _MMXLength      \n\t"
#ifdef __PIC__
      "popl %%ebx                  \n\t" // restore index to Global Offset Table
#endif

      : "=c" (dummy_value_c),            // output regs (dummy)
        "=S" (dummy_value_S),
        "=D" (dummy_value_D)

      : "0" (bpp),       // ecx          // input regs
        "1" (prev_row),  // esi
        "2" (row)        // edi

      : "%eax", "%edx"                   // clobber list
#ifndef __PIC__
      , "%ebx"
#endif
      // GRR: INCLUDE "memory" as clobbered? (_dif, _MMXLength)
      // (seems to work fine without...)
   );

   // now do the math for the rest of the row
   switch (bpp)
   {
      case 3:
      {
         _ActiveMask.use  = 0x0000000000ffffffLL;
         _ShiftBpp.use = 24;    // == 3 * 8
         _ShiftRem.use = 40;    // == 64 - 24

         __asm__ __volatile__ (
            // re-init address pointers and offset
            "movq _ActiveMask, %%mm7      \n\t"
            "movl _dif, %%ecx             \n\t" // ecx:  x = offset to
            "movq _LBCarryMask, %%mm5     \n\t" //  alignment boundary
// preload  "movl row, %%edi              \n\t" // edi:  Avg(x)
            "movq _HBClearMask, %%mm4     \n\t"
// preload  "movl prev_row, %%esi         \n\t" // esi:  Prior(x)

            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm2 \n\t" // load previous aligned 8 bytes
                                                // (correct pos. in loop below)
         "avg_3lp:                        \n\t"
            "movq (%%edi,%%ecx,), %%mm0   \n\t" // load mm0 with Avg(x)
            "movq %%mm5, %%mm3            \n\t"
            "psrlq _ShiftRem, %%mm2       \n\t" // correct position Raw(x-bpp) data
            "movq (%%esi,%%ecx,), %%mm1   \n\t" // load mm1 with Prior(x)
            "movq %%mm7, %%mm6            \n\t"
            "pand %%mm1, %%mm3            \n\t" // get lsb for each prev_row byte
            "psrlq $1, %%mm1              \n\t" // divide prev_row bytes by 2
            "pand  %%mm4, %%mm1           \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm0           \n\t" // add (Prev_row/2) to Avg for each byte
            // add 1st active group (Raw(x-bpp)/2) to average with LBCarry
            "movq %%mm3, %%mm1            \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1            \n\t" // get LBCarrys for each byte where both
                               // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2              \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2           \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2           \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2            \n\t" // leave only Active Group 1 bytes to add to Avg
            "paddb %%mm2, %%mm0           \n\t" // add (Raw/2) + LBCarrys to Avg for each Active
                               //  byte
            // add 2nd active group (Raw(x-bpp)/2) to average with _LBCarry
            "psllq _ShiftBpp, %%mm6       \n\t" // shift the mm6 mask to cover bytes 3-5
            "movq %%mm0, %%mm2            \n\t" // mov updated Raws to mm2
            "psllq _ShiftBpp, %%mm2       \n\t" // shift data to pos. correctly
            "movq %%mm3, %%mm1            \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1            \n\t" // get LBCarrys for each byte where both
                               // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2              \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2           \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2           \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2            \n\t" // leave only Active Group 2 bytes to add to Avg
            "paddb %%mm2, %%mm0           \n\t" // add (Raw/2) + LBCarrys to Avg for each Active
                               //  byte

            // add 3rd active group (Raw(x-bpp)/2) to average with _LBCarry
            "psllq _ShiftBpp, %%mm6       \n\t" // shift mm6 mask to cover last two
                                 // bytes
            "movq %%mm0, %%mm2            \n\t" // mov updated Raws to mm2
            "psllq _ShiftBpp, %%mm2       \n\t" // shift data to pos. correctly
                              // Data only needs to be shifted once here to
                              // get the correct x-bpp offset.
            "movq %%mm3, %%mm1            \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1            \n\t" // get LBCarrys for each byte where both
                              // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2              \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2           \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2           \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2            \n\t" // leave only Active Group 2 bytes to add to Avg
            "addl $8, %%ecx               \n\t"
            "paddb %%mm2, %%mm0           \n\t" // add (Raw/2) + LBCarrys to Avg for each Active
                                                // byte
            // now ready to write back to memory
            "movq %%mm0, -8(%%edi,%%ecx,) \n\t"
            // move updated Raw(x) to use as Raw(x-bpp) for next loop
            "cmpl _MMXLength, %%ecx       \n\t"
            "movq %%mm0, %%mm2            \n\t" // mov updated Raw(x) to mm2
            "jb avg_3lp                   \n\t"

            : "=S" (dummy_value_S),             // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi           // input regs
              "1" (row)        // edi

            : "%ecx"                            // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 3 bpp

      case 6:
      case 4:
      //case 7:   // who wrote this?  PNG doesn't support 5 or 7 bytes/pixel
      //case 5:   // GRR BOGUS
      {
         _ActiveMask.use  = 0xffffffffffffffffLL; // use shift below to clear
                                                  // appropriate inactive bytes
         _ShiftBpp.use = bpp << 3;
         _ShiftRem.use = 64 - _ShiftBpp.use;

         __asm__ __volatile__ (
            "movq _HBClearMask, %%mm4    \n\t"

            // re-init address pointers and offset
            "movl _dif, %%ecx            \n\t" // ecx:  x = offset to alignment boundary

            // load _ActiveMask and clear all bytes except for 1st active group
            "movq _ActiveMask, %%mm7     \n\t"
// preload  "movl row, %%edi             \n\t" // edi:  Avg(x)
            "psrlq _ShiftRem, %%mm7      \n\t"
// preload  "movl prev_row, %%esi        \n\t" // esi:  Prior(x)
            "movq %%mm7, %%mm6           \n\t"
            "movq _LBCarryMask, %%mm5    \n\t"
            "psllq _ShiftBpp, %%mm6      \n\t" // create mask for 2nd active group

            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm2 \n\t" // load previous aligned 8 bytes
                                          // (we correct pos. in loop below)
         "avg_4lp:                       \n\t"
            "movq (%%edi,%%ecx,), %%mm0  \n\t"
            "psrlq _ShiftRem, %%mm2      \n\t" // shift data to pos. correctly
            "movq (%%esi,%%ecx,), %%mm1  \n\t"
            // add (Prev_row/2) to average
            "movq %%mm5, %%mm3           \n\t"
            "pand %%mm1, %%mm3           \n\t" // get lsb for each prev_row byte
            "psrlq $1, %%mm1             \n\t" // divide prev_row bytes by 2
            "pand  %%mm4, %%mm1          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm0          \n\t" // add (Prev_row/2) to Avg for each byte
            // add 1st active group (Raw(x-bpp)/2) to average with _LBCarry
            "movq %%mm3, %%mm1           \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1           \n\t" // get LBCarrys for each byte where both
                              // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2          \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm7, %%mm2           \n\t" // leave only Active Group 1 bytes to add to Avg
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte
            // add 2nd active group (Raw(x-bpp)/2) to average with _LBCarry
            "movq %%mm0, %%mm2           \n\t" // mov updated Raws to mm2
            "psllq _ShiftBpp, %%mm2      \n\t" // shift data to pos. correctly
            "addl $8, %%ecx              \n\t"
            "movq %%mm3, %%mm1           \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1           \n\t" // get LBCarrys for each byte where both
                              // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2          \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2           \n\t" // leave only Active Group 2 bytes to add to Avg
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte
            "cmpl _MMXLength, %%ecx      \n\t"
            // now ready to write back to memory
            "movq %%mm0, -8(%%edi,%%ecx,) \n\t"
            // prep Raw(x-bpp) for next loop
            "movq %%mm0, %%mm2           \n\t" // mov updated Raws to mm2
            "jb avg_4lp                  \n\t"

            : "=S" (dummy_value_S),            // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi          // input regs
              "1" (row)        // edi

            : "%ecx"                           // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 4,6 bpp

      case 2:
      {
         _ActiveMask.use  = 0x000000000000ffffLL;
         _ShiftBpp.use = 16;   // == 2 * 8
         _ShiftRem.use = 48;   // == 64 - 16

         __asm__ __volatile__ (
            // load _ActiveMask
            "movq _ActiveMask, %%mm7     \n\t"
            // re-init address pointers and offset
            "movl _dif, %%ecx            \n\t" // ecx:  x = offset to alignment boundary
            "movq _LBCarryMask, %%mm5    \n\t"
// preload  "movl row, %%edi             \n\t" // edi:  Avg(x)
            "movq _HBClearMask, %%mm4    \n\t"
// preload  "movl prev_row, %%esi        \n\t" // esi:  Prior(x)

            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm2 \n\t" // load previous aligned 8 bytes
                              // (we correct pos. in loop below)
         "avg_2lp:                       \n\t"
            "movq (%%edi,%%ecx,), %%mm0  \n\t"
            "psrlq _ShiftRem, %%mm2      \n\t" // shift data to pos. correctly
            "movq (%%esi,%%ecx,), %%mm1  \n\t" //  (GRR BUGFIX:  was psllq)
            // add (Prev_row/2) to average
            "movq %%mm5, %%mm3           \n\t"
            "pand %%mm1, %%mm3           \n\t" // get lsb for each prev_row byte
            "psrlq $1, %%mm1             \n\t" // divide prev_row bytes by 2
            "pand  %%mm4, %%mm1          \n\t" // clear invalid bit 7 of each byte
            "movq %%mm7, %%mm6           \n\t"
            "paddb %%mm1, %%mm0          \n\t" // add (Prev_row/2) to Avg for each byte

            // add 1st active group (Raw(x-bpp)/2) to average with _LBCarry
            "movq %%mm3, %%mm1           \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1           \n\t" // get LBCarrys for each byte where both
                                               // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2          \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2           \n\t" // leave only Active Group 1 bytes to add to Avg
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) + LBCarrys to Avg for each Active byte

            // add 2nd active group (Raw(x-bpp)/2) to average with _LBCarry
            "psllq _ShiftBpp, %%mm6      \n\t" // shift the mm6 mask to cover bytes 2 & 3
            "movq %%mm0, %%mm2           \n\t" // mov updated Raws to mm2
            "psllq _ShiftBpp, %%mm2      \n\t" // shift data to pos. correctly
            "movq %%mm3, %%mm1           \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1           \n\t" // get LBCarrys for each byte where both
                                               // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2          \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2           \n\t" // leave only Active Group 2 bytes to add to Avg
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) + LBCarrys to Avg for each Active byte

            // add 3rd active group (Raw(x-bpp)/2) to average with _LBCarry
            "psllq _ShiftBpp, %%mm6      \n\t" // shift the mm6 mask to cover bytes 4 & 5
            "movq %%mm0, %%mm2           \n\t" // mov updated Raws to mm2
            "psllq _ShiftBpp, %%mm2      \n\t" // shift data to pos. correctly
            "movq %%mm3, %%mm1           \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1           \n\t" // get LBCarrys for each byte where both
                                               // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2          \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2           \n\t" // leave only Active Group 2 bytes to add to Avg
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) + LBCarrys to Avg for each Active byte

            // add 4th active group (Raw(x-bpp)/2) to average with _LBCarry
            "psllq _ShiftBpp, %%mm6      \n\t" // shift the mm6 mask to cover bytes 6 & 7
            "movq %%mm0, %%mm2           \n\t" // mov updated Raws to mm2
            "psllq _ShiftBpp, %%mm2      \n\t" // shift data to pos. correctly
            "addl $8, %%ecx              \n\t"
            "movq %%mm3, %%mm1           \n\t" // now use mm1 for getting LBCarrys
            "pand %%mm2, %%mm1           \n\t" // get LBCarrys for each byte where both
                                               // lsb's were == 1 (only valid for active group)
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm2          \n\t" // add LBCarrys to (Raw(x-bpp)/2) for each byte
            "pand %%mm6, %%mm2           \n\t" // leave only Active Group 2 bytes to add to Avg
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) + LBCarrys to Avg for each Active byte

            "cmpl _MMXLength, %%ecx      \n\t"
            // now ready to write back to memory
            "movq %%mm0, -8(%%edi,%%ecx,) \n\t"
            // prep Raw(x-bpp) for next loop
            "movq %%mm0, %%mm2           \n\t" // mov updated Raws to mm2
            "jb avg_2lp                  \n\t"

            : "=S" (dummy_value_S),            // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi          // input regs
              "1" (row)        // edi

            : "%ecx"                           // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 2 bpp

      case 1:
      {
         __asm__ __volatile__ (
            // re-init address pointers and offset
#ifdef __PIC__
            "pushl %%ebx                 \n\t" // save Global Offset Table index
#endif
            "movl _dif, %%ebx            \n\t" // ebx:  x = offset to alignment boundary
// preload  "movl row, %%edi             \n\t" // edi:  Avg(x)
            "cmpl _FullLength, %%ebx     \n\t" // test if offset at end of array
            "jnb avg_1end                \n\t"
            // do Paeth decode for remaining bytes
// preload  "movl prev_row, %%esi        \n\t" // esi:  Prior(x)
            "movl %%edi, %%edx           \n\t"
// preload  "subl bpp, %%edx             \n\t" // (bpp is preloaded into ecx)
            "subl %%ecx, %%edx           \n\t" // edx:  Raw(x-bpp)
            "xorl %%ecx, %%ecx           \n\t" // zero ecx before using cl & cx
                                               //  in loop below
         "avg_1lp:                       \n\t"
            // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
            "xorl %%eax, %%eax           \n\t"
            "movb (%%esi,%%ebx,), %%cl   \n\t" // load cl with Prior(x)
            "movb (%%edx,%%ebx,), %%al   \n\t" // load al with Raw(x-bpp)
            "addw %%cx, %%ax             \n\t"
            "incl %%ebx                  \n\t"
            "shrw %%ax                   \n\t" // divide by 2
            "addb -1(%%edi,%%ebx,), %%al \n\t" // add Avg(x); -1 to offset inc ebx
            "cmpl _FullLength, %%ebx     \n\t" // check if at end of array
            "movb %%al, -1(%%edi,%%ebx,) \n\t" // write back Raw(x);
                         // mov does not affect flags; -1 to offset inc ebx
            "jb avg_1lp                  \n\t"

         "avg_1end:                      \n\t"
#ifdef __PIC__
            "popl %%ebx                  \n\t" // Global Offset Table index
#endif

            : "=c" (dummy_value_c),            // output regs (dummy)
              "=S" (dummy_value_S),
              "=D" (dummy_value_D)

            : "0" (bpp),       // ecx          // input regs
              "1" (prev_row),  // esi
              "2" (row)        // edi

            : "%eax", "%edx"                   // clobber list
#ifndef __PIC__
            , "%ebx"
#endif
         );
      }
      return;  // end 1 bpp

      case 8:
      {
         __asm__ __volatile__ (
            // re-init address pointers and offset
            "movl _dif, %%ecx            \n\t" // ecx:  x == offset to alignment
            "movq _LBCarryMask, %%mm5    \n\t" //            boundary
// preload  "movl row, %%edi             \n\t" // edi:  Avg(x)
            "movq _HBClearMask, %%mm4    \n\t"
// preload  "movl prev_row, %%esi        \n\t" // esi:  Prior(x)

            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm2 \n\t" // load previous aligned 8 bytes
                                      // (NO NEED to correct pos. in loop below)

         "avg_8lp:                       \n\t"
            "movq (%%edi,%%ecx,), %%mm0  \n\t"
            "movq %%mm5, %%mm3           \n\t"
            "movq (%%esi,%%ecx,), %%mm1  \n\t"
            "addl $8, %%ecx              \n\t"
            "pand %%mm1, %%mm3           \n\t" // get lsb for each prev_row byte
            "psrlq $1, %%mm1             \n\t" // divide prev_row bytes by 2
            "pand %%mm2, %%mm3           \n\t" // get LBCarrys for each byte
                                               //  where both lsb's were == 1
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm1          \n\t" // clear invalid bit 7, each byte
            "paddb %%mm3, %%mm0          \n\t" // add LBCarrys to Avg, each byte
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7, each byte
            "paddb %%mm1, %%mm0          \n\t" // add (Prev_row/2) to Avg, each
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) to Avg for each
            "cmpl _MMXLength, %%ecx      \n\t"
            "movq %%mm0, -8(%%edi,%%ecx,) \n\t"
            "movq %%mm0, %%mm2           \n\t" // reuse as Raw(x-bpp)
            "jb avg_8lp                  \n\t"

            : "=S" (dummy_value_S),            // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi          // input regs
              "1" (row)        // edi

            : "%ecx"                           // clobber list
#if 0  /* %mm0, ..., %mm5 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2"
            , "%mm3", "%mm4", "%mm5"
#endif
         );
      }
      break;  // end 8 bpp

      default:                  // bpp greater than 8 (!= 1,2,3,4,[5],6,[7],8)
      {

         // GRR:  PRINT ERROR HERE:  SHOULD NEVER BE REACHED
         fprintf(stderr,
           "libpng:  internal logic error (png_read_filter_row_mmx_avg())\n");

#if 0
        __asm__ __volatile__ (
            "movq _LBCarryMask, %%mm5    \n\t"
            // re-init address pointers and offset
            "movl _dif, %%ebx            \n\t" // ebx:  x = offset to alignment boundary
            "movl row, %%edi             \n\t" // edi:  Avg(x)
            "movq _HBClearMask, %%mm4    \n\t"
            "movl %%edi, %%edx           \n\t"
            "movl prev_row, %%esi        \n\t" // esi:  Prior(x)
            "subl bpp, %%edx             \n\t" // edx:  Raw(x-bpp)
         "avg_Alp:                       \n\t"
            "movq (%%edi,%%ebx,), %%mm0  \n\t"
            "movq %%mm5, %%mm3           \n\t"
            "movq (%%esi,%%ebx,), %%mm1  \n\t"
            "pand %%mm1, %%mm3           \n\t" // get lsb for each prev_row byte
            "movq (%%edx,%%ebx,), %%mm2  \n\t"
            "psrlq $1, %%mm1             \n\t" // divide prev_row bytes by 2
            "pand %%mm2, %%mm3           \n\t" // get LBCarrys for each byte where both
                                // lsb's were == 1
            "psrlq $1, %%mm2             \n\t" // divide raw bytes by 2
            "pand  %%mm4, %%mm1          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm3, %%mm0          \n\t" // add LBCarrys to Avg for each byte
            "pand  %%mm4, %%mm2          \n\t" // clear invalid bit 7 of each byte
            "paddb %%mm1, %%mm0          \n\t" // add (Prev_row/2) to Avg for each byte
            "addl $8, %%ebx              \n\t"
            "paddb %%mm2, %%mm0          \n\t" // add (Raw/2) to Avg for each byte
            "cmpl _MMXLength, %%ebx      \n\t"
            "movq %%mm0, -8(%%edi,%%ebx,) \n\t"
            "jb avg_Alp                  \n\t"

            : // FIXASM: output regs/vars go here, e.g.:  "=m" (memory_var)

            : // FIXASM: input regs, e.g.:  "c" (count), "S" (src), "D" (dest)

            : "%ebx", "%edx", "%edi", "%esi" // CHECKASM: clobber list
         );
#endif /* 0 - NEVER REACHED */
      }
      break;

   } // end switch (bpp)

   __asm__ __volatile__ (
      // MMX acceleration complete; now do clean-up
      // check if any remaining bytes left to decode
#ifdef __PIC__
      "pushl %%ebx                 \n\t" // save index to Global Offset Table
#endif
      "movl _MMXLength, %%ebx      \n\t" // ebx:  x == offset bytes after MMX
//pre "movl row, %%edi             \n\t" // edi:  Avg(x)
      "cmpl _FullLength, %%ebx     \n\t" // test if offset at end of array
      "jnb avg_end                 \n\t"

      // do Avg decode for remaining bytes
//pre "movl prev_row, %%esi        \n\t" // esi:  Prior(x)
      "movl %%edi, %%edx           \n\t"
//pre "subl bpp, %%edx             \n\t" // (bpp is preloaded into ecx)
      "subl %%ecx, %%edx           \n\t" // edx:  Raw(x-bpp)
      "xorl %%ecx, %%ecx           \n\t" // zero ecx before using cl & cx below

   "avg_lp2:                       \n\t"
      // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
      "xorl %%eax, %%eax           \n\t"
      "movb (%%esi,%%ebx,), %%cl   \n\t" // load cl with Prior(x)
      "movb (%%edx,%%ebx,), %%al   \n\t" // load al with Raw(x-bpp)
      "addw %%cx, %%ax             \n\t"
      "incl %%ebx                  \n\t"
      "shrw %%ax                   \n\t" // divide by 2
      "addb -1(%%edi,%%ebx,), %%al \n\t" // add Avg(x); -1 to offset inc ebx
      "cmpl _FullLength, %%ebx     \n\t" // check if at end of array
      "movb %%al, -1(%%edi,%%ebx,) \n\t" // write back Raw(x) [mov does not
      "jb avg_lp2                  \n\t" //  affect flags; -1 to offset inc ebx]

   "avg_end:                       \n\t"
      "EMMS                        \n\t" // end MMX; prep for poss. FP instrs.
#ifdef __PIC__
      "popl %%ebx                  \n\t" // restore index to Global Offset Table
#endif

      : "=c" (dummy_value_c),            // output regs (dummy)
        "=S" (dummy_value_S),
        "=D" (dummy_value_D)

      : "0" (bpp),       // ecx          // input regs
        "1" (prev_row),  // esi
        "2" (row)        // edi

      : "%eax", "%edx"                   // clobber list
#ifndef __PIC__
      , "%ebx"
#endif
   );

} /* end png_read_filter_row_mmx_avg() */




//===========================================================================//
//                                                                           //
//         P N G _ R E A D _ F I L T E R _ R O W _ M M X _ P A E T H         //
//                                                                           //
//===========================================================================//

// Optimized code for PNG Paeth filter decoder

static void /* PRIVATE */
png_read_filter_row_mmx_paeth(png_row_infop row_info, png_bytep row,
                              png_bytep prev_row)
{
   int bpp;
   int dummy_value_c;   // fix 'forbidden register 2 (cx) was spilled' error
   int dummy_value_S;
   int dummy_value_D;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   _FullLength  = row_info->rowbytes; // # of bytes to filter

   __asm__ __volatile__ (
#ifdef __PIC__
      "pushl %%ebx                 \n\t" // save index to Global Offset Table
#endif
      "xorl %%ebx, %%ebx           \n\t" // ebx:  x offset
//pre "movl row, %%edi             \n\t"
      "xorl %%edx, %%edx           \n\t" // edx:  x-bpp offset
//pre "movl prev_row, %%esi        \n\t"
      "xorl %%eax, %%eax           \n\t"

      // Compute the Raw value for the first bpp bytes
      // Note: the formula works out to be always
      //   Paeth(x) = Raw(x) + Prior(x)      where x < bpp
   "paeth_rlp:                     \n\t"
      "movb (%%edi,%%ebx,), %%al   \n\t"
      "addb (%%esi,%%ebx,), %%al   \n\t"
      "incl %%ebx                  \n\t"
//pre "cmpl bpp, %%ebx             \n\t" (bpp is preloaded into ecx)
      "cmpl %%ecx, %%ebx           \n\t"
      "movb %%al, -1(%%edi,%%ebx,) \n\t"
      "jb paeth_rlp                \n\t"
      // get # of bytes to alignment
      "movl %%edi, _dif            \n\t" // take start of row
      "addl %%ebx, _dif            \n\t" // add bpp
      "xorl %%ecx, %%ecx           \n\t"
      "addl $0xf, _dif             \n\t" // add 7 + 8 to incr past alignment boundary
      "andl $0xfffffff8, _dif      \n\t" // mask to alignment boundary
      "subl %%edi, _dif            \n\t" // subtract from start ==> value ebx at alignment
      "jz paeth_go                 \n\t"
      // fix alignment

   "paeth_lp1:                     \n\t"
      "xorl %%eax, %%eax           \n\t"
      // pav = p - a = (a + b - c) - a = b - c
      "movb (%%esi,%%ebx,), %%al   \n\t" // load Prior(x) into al
      "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
      "subl %%ecx, %%eax           \n\t" // subtract Prior(x-bpp)
      "movl %%eax, _patemp         \n\t" // Save pav for later use
      "xorl %%eax, %%eax           \n\t"
      // pbv = p - b = (a + b - c) - b = a - c
      "movb (%%edi,%%edx,), %%al   \n\t" // load Raw(x-bpp) into al
      "subl %%ecx, %%eax           \n\t" // subtract Prior(x-bpp)
      "movl %%eax, %%ecx           \n\t"
      // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
      "addl _patemp, %%eax         \n\t" // pcv = pav + pbv
      // pc = abs(pcv)
      "testl $0x80000000, %%eax    \n\t"
      "jz paeth_pca                \n\t"
      "negl %%eax                  \n\t" // reverse sign of neg values

   "paeth_pca:                     \n\t"
      "movl %%eax, _pctemp         \n\t" // save pc for later use
      // pb = abs(pbv)
      "testl $0x80000000, %%ecx    \n\t"
      "jz paeth_pba                \n\t"
      "negl %%ecx                  \n\t" // reverse sign of neg values

   "paeth_pba:                     \n\t"
      "movl %%ecx, _pbtemp         \n\t" // save pb for later use
      // pa = abs(pav)
      "movl _patemp, %%eax         \n\t"
      "testl $0x80000000, %%eax    \n\t"
      "jz paeth_paa                \n\t"
      "negl %%eax                  \n\t" // reverse sign of neg values

   "paeth_paa:                     \n\t"
      "movl %%eax, _patemp         \n\t" // save pa for later use
      // test if pa <= pb
      "cmpl %%ecx, %%eax           \n\t"
      "jna paeth_abb               \n\t"
      // pa > pb; now test if pb <= pc
      "cmpl _pctemp, %%ecx         \n\t"
      "jna paeth_bbc               \n\t"
      // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
      "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
      "jmp paeth_paeth             \n\t"

   "paeth_bbc:                     \n\t"
      // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
      "movb (%%esi,%%ebx,), %%cl   \n\t" // load Prior(x) into cl
      "jmp paeth_paeth             \n\t"

   "paeth_abb:                     \n\t"
      // pa <= pb; now test if pa <= pc
      "cmpl _pctemp, %%eax         \n\t"
      "jna paeth_abc               \n\t"
      // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
      "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
      "jmp paeth_paeth             \n\t"

   "paeth_abc:                     \n\t"
      // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
      "movb (%%edi,%%edx,), %%cl   \n\t" // load Raw(x-bpp) into cl

   "paeth_paeth:                   \n\t"
      "incl %%ebx                  \n\t"
      "incl %%edx                  \n\t"
      // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
      "addb %%cl, -1(%%edi,%%ebx,) \n\t"
      "cmpl _dif, %%ebx            \n\t"
      "jb paeth_lp1                \n\t"

   "paeth_go:                      \n\t"
      "movl _FullLength, %%ecx     \n\t"
      "movl %%ecx, %%eax           \n\t"
      "subl %%ebx, %%eax           \n\t" // subtract alignment fix
      "andl $0x00000007, %%eax     \n\t" // calc bytes over mult of 8
      "subl %%eax, %%ecx           \n\t" // drop over bytes from original length
      "movl %%ecx, _MMXLength      \n\t"
#ifdef __PIC__
      "popl %%ebx                  \n\t" // restore index to Global Offset Table
#endif

      : "=c" (dummy_value_c),            // output regs (dummy)
        "=S" (dummy_value_S),
        "=D" (dummy_value_D)

      : "0" (bpp),       // ecx          // input regs
        "1" (prev_row),  // esi
        "2" (row)        // edi

      : "%eax", "%edx"                   // clobber list
#ifndef __PIC__
      , "%ebx"
#endif
   );

   // now do the math for the rest of the row
   switch (bpp)
   {
      case 3:
      {
         _ActiveMask.use = 0x0000000000ffffffLL;
         _ActiveMaskEnd.use = 0xffff000000000000LL;
         _ShiftBpp.use = 24;    // == bpp(3) * 8
         _ShiftRem.use = 40;    // == 64 - 24

         __asm__ __volatile__ (
            "movl _dif, %%ecx            \n\t"
// preload  "movl row, %%edi             \n\t"
// preload  "movl prev_row, %%esi        \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm1 \n\t"
         "paeth_3lp:                     \n\t"
            "psrlq _ShiftRem, %%mm1      \n\t" // shift last 3 bytes to 1st 3 bytes
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x)
            "punpcklbw %%mm0, %%mm1      \n\t" // unpack High bytes of a
            "movq -8(%%esi,%%ecx,), %%mm3 \n\t" // prep c=Prior(x-bpp) bytes
            "punpcklbw %%mm0, %%mm2      \n\t" // unpack High bytes of b
            "psrlq _ShiftRem, %%mm3      \n\t" // shift last 3 bytes to 1st 3 bytes
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            "punpcklbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "packuswb %%mm1, %%mm7       \n\t"
            "movq (%%esi,%%ecx,), %%mm3  \n\t" // load c=Prior(x-bpp)
            "pand _ActiveMask, %%mm7     \n\t"
            "movq %%mm3, %%mm2           \n\t" // load b=Prior(x) step 1
            "paddb (%%edi,%%ecx,), %%mm7 \n\t" // add Paeth predictor with Raw(x)
            "punpcklbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            "movq %%mm7, (%%edi,%%ecx,)  \n\t" // write back updated value
            "movq %%mm7, %%mm1           \n\t" // now mm1 will be used as Raw(x-bpp)
            // now do Paeth for 2nd set of bytes (3-5)
            "psrlq _ShiftBpp, %%mm2      \n\t" // load b=Prior(x) step 2
            "punpcklbw %%mm0, %%mm1      \n\t" // unpack High bytes of a
            "pxor %%mm7, %%mm7           \n\t"
            "punpcklbw %%mm0, %%mm2      \n\t" // unpack High bytes of b
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) =
            //       pav + pbv = pbv + pav
            "movq %%mm5, %%mm6           \n\t"
            "paddw %%mm4, %%mm6          \n\t"

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm5, %%mm0        \n\t" // create mask pbv bytes < 0
            "pcmpgtw %%mm4, %%mm7        \n\t" // create mask pav bytes < 0
            "pand %%mm5, %%mm0           \n\t" // only pbv bytes < 0 in mm0
            "pand %%mm4, %%mm7           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm0, %%mm5          \n\t"
            "psubw %%mm7, %%mm4          \n\t"
            "psubw %%mm0, %%mm5          \n\t"
            "psubw %%mm7, %%mm4          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x)
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "pxor %%mm1, %%mm1           \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "packuswb %%mm1, %%mm7       \n\t"
            "movq %%mm2, %%mm3           \n\t" // load c=Prior(x-bpp) step 1
            "pand _ActiveMask, %%mm7     \n\t"
            "punpckhbw %%mm0, %%mm2      \n\t" // unpack High bytes of b
            "psllq _ShiftBpp, %%mm7      \n\t" // shift bytes to 2nd group of 3 bytes
             // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            "paddb (%%edi,%%ecx,), %%mm7 \n\t" // add Paeth predictor with Raw(x)
            "psllq _ShiftBpp, %%mm3      \n\t" // load c=Prior(x-bpp) step 2
            "movq %%mm7, (%%edi,%%ecx,)  \n\t" // write back updated value
            "movq %%mm7, %%mm1           \n\t"
            "punpckhbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            "psllq _ShiftBpp, %%mm1      \n\t" // shift bytes
                                    // now mm1 will be used as Raw(x-bpp)
            // now do Paeth for 3rd, and final, set of bytes (6-7)
            "pxor %%mm7, %%mm7           \n\t"
            "punpckhbw %%mm0, %%mm1      \n\t" // unpack High bytes of a
            "psubw %%mm3, %%mm4          \n\t"
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "paddw %%mm5, %%mm6          \n\t"

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm1, %%mm1           \n\t"
            "packuswb %%mm7, %%mm1       \n\t"
            // step ecx to next set of 8 bytes and repeat loop til done
            "addl $8, %%ecx              \n\t"
            "pand _ActiveMaskEnd, %%mm1  \n\t"
            "paddb -8(%%edi,%%ecx,), %%mm1 \n\t" // add Paeth predictor with Raw(x)

            "cmpl _MMXLength, %%ecx      \n\t"
            "pxor %%mm0, %%mm0           \n\t" // pxor does not affect flags
            "movq %%mm1, -8(%%edi,%%ecx,) \n\t" // write back updated value
                                 // mm1 will be used as Raw(x-bpp) next loop
                           // mm3 ready to be used as Prior(x-bpp) next loop
            "jb paeth_3lp                \n\t"

            : "=S" (dummy_value_S),             // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi           // input regs
              "1" (row)        // edi

            : "%ecx"                            // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 3 bpp

      case 6:
      //case 7:   // GRR BOGUS
      //case 5:   // GRR BOGUS
      {
         _ActiveMask.use  = 0x00000000ffffffffLL;
         _ActiveMask2.use = 0xffffffff00000000LL;
         _ShiftBpp.use = bpp << 3;    // == bpp * 8
         _ShiftRem.use = 64 - _ShiftBpp.use;

         __asm__ __volatile__ (
            "movl _dif, %%ecx            \n\t"
// preload  "movl row, %%edi             \n\t"
// preload  "movl prev_row, %%esi        \n\t"
            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm1 \n\t"
            "pxor %%mm0, %%mm0           \n\t"

         "paeth_6lp:                     \n\t"
            // must shift to position Raw(x-bpp) data
            "psrlq _ShiftRem, %%mm1      \n\t"
            // do first set of 4 bytes
            "movq -8(%%esi,%%ecx,), %%mm3 \n\t" // read c=Prior(x-bpp) bytes
            "punpcklbw %%mm0, %%mm1      \n\t" // unpack Low bytes of a
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x)
            "punpcklbw %%mm0, %%mm2      \n\t" // unpack Low bytes of b
            // must shift to position Prior(x-bpp) data
            "psrlq _ShiftRem, %%mm3      \n\t"
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            "punpcklbw %%mm0, %%mm3      \n\t" // unpack Low bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "packuswb %%mm1, %%mm7       \n\t"
            "movq -8(%%esi,%%ecx,), %%mm3 \n\t" // load c=Prior(x-bpp)
            "pand _ActiveMask, %%mm7     \n\t"
            "psrlq _ShiftRem, %%mm3      \n\t"
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x) step 1
            "paddb (%%edi,%%ecx,), %%mm7 \n\t" // add Paeth predictor and Raw(x)
            "movq %%mm2, %%mm6           \n\t"
            "movq %%mm7, (%%edi,%%ecx,)  \n\t" // write back updated value
            "movq -8(%%edi,%%ecx,), %%mm1 \n\t"
            "psllq _ShiftBpp, %%mm6      \n\t"
            "movq %%mm7, %%mm5           \n\t"
            "psrlq _ShiftRem, %%mm1      \n\t"
            "por %%mm6, %%mm3            \n\t"
            "psllq _ShiftBpp, %%mm5      \n\t"
            "punpckhbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            "por %%mm5, %%mm1            \n\t"
            // do second set of 4 bytes
            "punpckhbw %%mm0, %%mm2      \n\t" // unpack High bytes of b
            "punpckhbw %%mm0, %%mm1      \n\t" // unpack High bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "pxor %%mm1, %%mm1           \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            // step ecx to next set of 8 bytes and repeat loop til done
            "addl $8, %%ecx              \n\t"
            "packuswb %%mm7, %%mm1       \n\t"
            "paddb -8(%%edi,%%ecx,), %%mm1 \n\t" // add Paeth predictor with Raw(x)
            "cmpl _MMXLength, %%ecx      \n\t"
            "movq %%mm1, -8(%%edi,%%ecx,) \n\t" // write back updated value
                                // mm1 will be used as Raw(x-bpp) next loop
            "jb paeth_6lp                \n\t"

            : "=S" (dummy_value_S),             // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi           // input regs
              "1" (row)        // edi

            : "%ecx"                            // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 6 bpp

      case 4:
      {
         _ActiveMask.use  = 0x00000000ffffffffLL;

         __asm__ __volatile__ (
            "movl _dif, %%ecx            \n\t"
// preload  "movl row, %%edi             \n\t"
// preload  "movl prev_row, %%esi        \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm1 \n\t" // only time should need to read
                                     //  a=Raw(x-bpp) bytes
         "paeth_4lp:                     \n\t"
            // do first set of 4 bytes
            "movq -8(%%esi,%%ecx,), %%mm3 \n\t" // read c=Prior(x-bpp) bytes
            "punpckhbw %%mm0, %%mm1      \n\t" // unpack Low bytes of a
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x)
            "punpcklbw %%mm0, %%mm2      \n\t" // unpack High bytes of b
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            "punpckhbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "packuswb %%mm1, %%mm7       \n\t"
            "movq (%%esi,%%ecx,), %%mm3  \n\t" // load c=Prior(x-bpp)
            "pand _ActiveMask, %%mm7     \n\t"
            "movq %%mm3, %%mm2           \n\t" // load b=Prior(x) step 1
            "paddb (%%edi,%%ecx,), %%mm7 \n\t" // add Paeth predictor with Raw(x)
            "punpcklbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            "movq %%mm7, (%%edi,%%ecx,)  \n\t" // write back updated value
            "movq %%mm7, %%mm1           \n\t" // now mm1 will be used as Raw(x-bpp)
            // do second set of 4 bytes
            "punpckhbw %%mm0, %%mm2      \n\t" // unpack Low bytes of b
            "punpcklbw %%mm0, %%mm1      \n\t" // unpack Low bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "pxor %%mm1, %%mm1           \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            // step ecx to next set of 8 bytes and repeat loop til done
            "addl $8, %%ecx              \n\t"
            "packuswb %%mm7, %%mm1       \n\t"
            "paddb -8(%%edi,%%ecx,), %%mm1 \n\t" // add predictor with Raw(x)
            "cmpl _MMXLength, %%ecx      \n\t"
            "movq %%mm1, -8(%%edi,%%ecx,) \n\t" // write back updated value
                                // mm1 will be used as Raw(x-bpp) next loop
            "jb paeth_4lp                \n\t"

            : "=S" (dummy_value_S),             // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi           // input regs
              "1" (row)        // edi

            : "%ecx"                            // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 4 bpp

      case 8:                          // bpp == 8
      {
         _ActiveMask.use  = 0x00000000ffffffffLL;

         __asm__ __volatile__ (
            "movl _dif, %%ecx            \n\t"
// preload  "movl row, %%edi             \n\t"
// preload  "movl prev_row, %%esi        \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%ecx,), %%mm1 \n\t" // only time should need to read
                                       //  a=Raw(x-bpp) bytes
         "paeth_8lp:                     \n\t"
            // do first set of 4 bytes
            "movq -8(%%esi,%%ecx,), %%mm3 \n\t" // read c=Prior(x-bpp) bytes
            "punpcklbw %%mm0, %%mm1      \n\t" // unpack Low bytes of a
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x)
            "punpcklbw %%mm0, %%mm2      \n\t" // unpack Low bytes of b
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            "punpcklbw %%mm0, %%mm3      \n\t" // unpack Low bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "packuswb %%mm1, %%mm7       \n\t"
            "movq -8(%%esi,%%ecx,), %%mm3 \n\t" // read c=Prior(x-bpp) bytes
            "pand _ActiveMask, %%mm7     \n\t"
            "movq (%%esi,%%ecx,), %%mm2  \n\t" // load b=Prior(x)
            "paddb (%%edi,%%ecx,), %%mm7 \n\t" // add Paeth predictor with Raw(x)
            "punpckhbw %%mm0, %%mm3      \n\t" // unpack High bytes of c
            "movq %%mm7, (%%edi,%%ecx,)  \n\t" // write back updated value
            "movq -8(%%edi,%%ecx,), %%mm1 \n\t" // read a=Raw(x-bpp) bytes

            // do second set of 4 bytes
            "punpckhbw %%mm0, %%mm2      \n\t" // unpack High bytes of b
            "punpckhbw %%mm0, %%mm1      \n\t" // unpack High bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            "movq %%mm2, %%mm4           \n\t"
            // pbv = p - b = (a + b - c) - b = a - c
            "movq %%mm1, %%mm5           \n\t"
            "psubw %%mm3, %%mm4          \n\t"
            "pxor %%mm7, %%mm7           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "movq %%mm4, %%mm6           \n\t"
            "psubw %%mm3, %%mm5          \n\t"
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            "pcmpgtw %%mm4, %%mm0        \n\t" // create mask pav bytes < 0
            "paddw %%mm5, %%mm6          \n\t"
            "pand %%mm4, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "pcmpgtw %%mm5, %%mm7        \n\t" // create mask pbv bytes < 0
            "psubw %%mm0, %%mm4          \n\t"
            "pand %%mm5, %%mm7           \n\t" // only pbv bytes < 0 in mm0
            "psubw %%mm0, %%mm4          \n\t"
            "psubw %%mm7, %%mm5          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            "pcmpgtw %%mm6, %%mm0        \n\t" // create mask pcv bytes < 0
            "pand %%mm6, %%mm0           \n\t" // only pav bytes < 0 in mm7
            "psubw %%mm7, %%mm5          \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            //  test pa <= pb
            "movq %%mm4, %%mm7           \n\t"
            "psubw %%mm0, %%mm6          \n\t"
            "pcmpgtw %%mm5, %%mm7        \n\t" // pa > pb?
            "movq %%mm7, %%mm0           \n\t"
            // use mm7 mask to merge pa & pb
            "pand %%mm7, %%mm5           \n\t"
            // use mm0 mask copy to merge a & b
            "pand %%mm0, %%mm2           \n\t"
            "pandn %%mm4, %%mm7          \n\t"
            "pandn %%mm1, %%mm0          \n\t"
            "paddw %%mm5, %%mm7          \n\t"
            "paddw %%mm2, %%mm0          \n\t"
            //  test  ((pa <= pb)? pa:pb) <= pc
            "pcmpgtw %%mm6, %%mm7        \n\t" // pab > pc?
            "pxor %%mm1, %%mm1           \n\t"
            "pand %%mm7, %%mm3           \n\t"
            "pandn %%mm0, %%mm7          \n\t"
            "pxor %%mm1, %%mm1           \n\t"
            "paddw %%mm3, %%mm7          \n\t"
            "pxor %%mm0, %%mm0           \n\t"
            // step ecx to next set of 8 bytes and repeat loop til done
            "addl $8, %%ecx              \n\t"
            "packuswb %%mm7, %%mm1       \n\t"
            "paddb -8(%%edi,%%ecx,), %%mm1 \n\t" // add Paeth predictor with Raw(x)
            "cmpl _MMXLength, %%ecx      \n\t"
            "movq %%mm1, -8(%%edi,%%ecx,) \n\t" // write back updated value
                            // mm1 will be used as Raw(x-bpp) next loop
            "jb paeth_8lp                \n\t"

            : "=S" (dummy_value_S),             // output regs (dummy)
              "=D" (dummy_value_D)

            : "0" (prev_row),  // esi           // input regs
              "1" (row)        // edi

            : "%ecx"                            // clobber list
#if 0  /* %mm0, ..., %mm7 not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3"
            , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;  // end 8 bpp

      case 1:                // bpp = 1
      case 2:                // bpp = 2
      default:               // bpp > 8
      {
         __asm__ __volatile__ (
#ifdef __PIC__
            "pushl %%ebx                 \n\t" // save Global Offset Table index
#endif
            "movl _dif, %%ebx            \n\t"
            "cmpl _FullLength, %%ebx     \n\t"
            "jnb paeth_dend              \n\t"

// preload  "movl row, %%edi             \n\t"
// preload  "movl prev_row, %%esi        \n\t"
            // do Paeth decode for remaining bytes
            "movl %%ebx, %%edx           \n\t"
// preload  "subl bpp, %%edx             \n\t" // (bpp is preloaded into ecx)
            "subl %%ecx, %%edx           \n\t" // edx = ebx - bpp
            "xorl %%ecx, %%ecx           \n\t" // zero ecx before using cl & cx

         "paeth_dlp:                     \n\t"
            "xorl %%eax, %%eax           \n\t"
            // pav = p - a = (a + b - c) - a = b - c
            "movb (%%esi,%%ebx,), %%al   \n\t" // load Prior(x) into al
            "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
            "subl %%ecx, %%eax           \n\t" // subtract Prior(x-bpp)
            "movl %%eax, _patemp         \n\t" // Save pav for later use
            "xorl %%eax, %%eax           \n\t"
            // pbv = p - b = (a + b - c) - b = a - c
            "movb (%%edi,%%edx,), %%al   \n\t" // load Raw(x-bpp) into al
            "subl %%ecx, %%eax           \n\t" // subtract Prior(x-bpp)
            "movl %%eax, %%ecx           \n\t"
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            "addl _patemp, %%eax         \n\t" // pcv = pav + pbv
            // pc = abs(pcv)
            "testl $0x80000000, %%eax    \n\t"
            "jz paeth_dpca               \n\t"
            "negl %%eax                  \n\t" // reverse sign of neg values

         "paeth_dpca:                    \n\t"
            "movl %%eax, _pctemp         \n\t" // save pc for later use
            // pb = abs(pbv)
            "testl $0x80000000, %%ecx    \n\t"
            "jz paeth_dpba               \n\t"
            "negl %%ecx                  \n\t" // reverse sign of neg values

         "paeth_dpba:                    \n\t"
            "movl %%ecx, _pbtemp         \n\t" // save pb for later use
            // pa = abs(pav)
            "movl _patemp, %%eax         \n\t"
            "testl $0x80000000, %%eax    \n\t"
            "jz paeth_dpaa               \n\t"
            "negl %%eax                  \n\t" // reverse sign of neg values

         "paeth_dpaa:                    \n\t"
            "movl %%eax, _patemp         \n\t" // save pa for later use
            // test if pa <= pb
            "cmpl %%ecx, %%eax           \n\t"
            "jna paeth_dabb              \n\t"
            // pa > pb; now test if pb <= pc
            "cmpl _pctemp, %%ecx         \n\t"
            "jna paeth_dbbc              \n\t"
            // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
            "jmp paeth_dpaeth            \n\t"

         "paeth_dbbc:                    \n\t"
            // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
            "movb (%%esi,%%ebx,), %%cl   \n\t" // load Prior(x) into cl
            "jmp paeth_dpaeth            \n\t"

         "paeth_dabb:                    \n\t"
            // pa <= pb; now test if pa <= pc
            "cmpl _pctemp, %%eax         \n\t"
            "jna paeth_dabc              \n\t"
            // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
            "jmp paeth_dpaeth            \n\t"

         "paeth_dabc:                    \n\t"
            // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
            "movb (%%edi,%%edx,), %%cl   \n\t" // load Raw(x-bpp) into cl

         "paeth_dpaeth:                  \n\t"
            "incl %%ebx                  \n\t"
            "incl %%edx                  \n\t"
            // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
            "addb %%cl, -1(%%edi,%%ebx,) \n\t"
            "cmpl _FullLength, %%ebx     \n\t"
            "jb paeth_dlp                \n\t"

         "paeth_dend:                    \n\t"
#ifdef __PIC__
            "popl %%ebx                  \n\t" // index to Global Offset Table
#endif

            : "=c" (dummy_value_c),            // output regs (dummy)
              "=S" (dummy_value_S),
              "=D" (dummy_value_D)

            : "0" (bpp),       // ecx          // input regs
              "1" (prev_row),  // esi
              "2" (row)        // edi

            : "%eax", "%edx"                   // clobber list
#ifndef __PIC__
            , "%ebx"
#endif
         );
      }
      return;                   // No need to go further with this one

   } // end switch (bpp)

   __asm__ __volatile__ (
      // MMX acceleration complete; now do clean-up
      // check if any remaining bytes left to decode
#ifdef __PIC__
      "pushl %%ebx                 \n\t" // save index to Global Offset Table
#endif
      "movl _MMXLength, %%ebx      \n\t"
      "cmpl _FullLength, %%ebx     \n\t"
      "jnb paeth_end               \n\t"
//pre "movl row, %%edi             \n\t"
//pre "movl prev_row, %%esi        \n\t"
      // do Paeth decode for remaining bytes
      "movl %%ebx, %%edx           \n\t"
//pre "subl bpp, %%edx             \n\t" // (bpp is preloaded into ecx)
      "subl %%ecx, %%edx           \n\t" // edx = ebx - bpp
      "xorl %%ecx, %%ecx           \n\t" // zero ecx before using cl & cx below

   "paeth_lp2:                     \n\t"
      "xorl %%eax, %%eax           \n\t"
      // pav = p - a = (a + b - c) - a = b - c
      "movb (%%esi,%%ebx,), %%al   \n\t" // load Prior(x) into al
      "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
      "subl %%ecx, %%eax           \n\t" // subtract Prior(x-bpp)
      "movl %%eax, _patemp         \n\t" // Save pav for later use
      "xorl %%eax, %%eax           \n\t"
      // pbv = p - b = (a + b - c) - b = a - c
      "movb (%%edi,%%edx,), %%al   \n\t" // load Raw(x-bpp) into al
      "subl %%ecx, %%eax           \n\t" // subtract Prior(x-bpp)
      "movl %%eax, %%ecx           \n\t"
      // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
      "addl _patemp, %%eax         \n\t" // pcv = pav + pbv
      // pc = abs(pcv)
      "testl $0x80000000, %%eax    \n\t"
      "jz paeth_pca2               \n\t"
      "negl %%eax                  \n\t" // reverse sign of neg values

   "paeth_pca2:                    \n\t"
      "movl %%eax, _pctemp         \n\t" // save pc for later use
      // pb = abs(pbv)
      "testl $0x80000000, %%ecx    \n\t"
      "jz paeth_pba2               \n\t"
      "negl %%ecx                  \n\t" // reverse sign of neg values

   "paeth_pba2:                    \n\t"
      "movl %%ecx, _pbtemp         \n\t" // save pb for later use
      // pa = abs(pav)
      "movl _patemp, %%eax         \n\t"
      "testl $0x80000000, %%eax    \n\t"
      "jz paeth_paa2               \n\t"
      "negl %%eax                  \n\t" // reverse sign of neg values

   "paeth_paa2:                    \n\t"
      "movl %%eax, _patemp         \n\t" // save pa for later use
      // test if pa <= pb
      "cmpl %%ecx, %%eax           \n\t"
      "jna paeth_abb2              \n\t"
      // pa > pb; now test if pb <= pc
      "cmpl _pctemp, %%ecx         \n\t"
      "jna paeth_bbc2              \n\t"
      // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
      "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
      "jmp paeth_paeth2            \n\t"

   "paeth_bbc2:                    \n\t"
      // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
      "movb (%%esi,%%ebx,), %%cl   \n\t" // load Prior(x) into cl
      "jmp paeth_paeth2            \n\t"

   "paeth_abb2:                    \n\t"
      // pa <= pb; now test if pa <= pc
      "cmpl _pctemp, %%eax         \n\t"
      "jna paeth_abc2              \n\t"
      // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
      "movb (%%esi,%%edx,), %%cl   \n\t" // load Prior(x-bpp) into cl
      "jmp paeth_paeth2            \n\t"

   "paeth_abc2:                    \n\t"
      // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
      "movb (%%edi,%%edx,), %%cl   \n\t" // load Raw(x-bpp) into cl

   "paeth_paeth2:                  \n\t"
      "incl %%ebx                  \n\t"
      "incl %%edx                  \n\t"
      // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
      "addb %%cl, -1(%%edi,%%ebx,) \n\t"
      "cmpl _FullLength, %%ebx     \n\t"
      "jb paeth_lp2                \n\t"

   "paeth_end:                     \n\t"
      "EMMS                        \n\t" // end MMX; prep for poss. FP instrs.
#ifdef __PIC__
      "popl %%ebx                  \n\t" // restore index to Global Offset Table
#endif

      : "=c" (dummy_value_c),            // output regs (dummy)
        "=S" (dummy_value_S),
        "=D" (dummy_value_D)

      : "0" (bpp),       // ecx          // input regs
        "1" (prev_row),  // esi
        "2" (row)        // edi

      : "%eax", "%edx"                   // clobber list (no input regs!)
#ifndef __PIC__
      , "%ebx"
#endif
   );

} /* end png_read_filter_row_mmx_paeth() */




//===========================================================================//
//                                                                           //
//           P N G _ R E A D _ F I L T E R _ R O W _ M M X _ S U B           //
//                                                                           //
//===========================================================================//

// Optimized code for PNG Sub filter decoder

static void /* PRIVATE */
png_read_filter_row_mmx_sub(png_row_infop row_info, png_bytep row)
{
   int bpp;
   int dummy_value_a;
   int dummy_value_D;

   bpp = (row_info->pixel_depth + 7) >> 3;   // calc number of bytes per pixel
   _FullLength = row_info->rowbytes - bpp;   // number of bytes to filter

   __asm__ __volatile__ (
//pre "movl row, %%edi             \n\t"
      "movl %%edi, %%esi           \n\t" // lp = row
//pre "movl bpp, %%eax             \n\t"
      "addl %%eax, %%edi           \n\t" // rp = row + bpp
//irr "xorl %%eax, %%eax           \n\t"
      // get # of bytes to alignment
      "movl %%edi, _dif            \n\t" // take start of row
      "addl $0xf, _dif             \n\t" // add 7 + 8 to incr past
                                         //  alignment boundary
      "xorl %%ecx, %%ecx           \n\t"
      "andl $0xfffffff8, _dif      \n\t" // mask to alignment boundary
      "subl %%edi, _dif            \n\t" // subtract from start ==> value
      "jz sub_go                   \n\t" //  ecx at alignment

   "sub_lp1:                       \n\t" // fix alignment
      "movb (%%esi,%%ecx,), %%al   \n\t"
      "addb %%al, (%%edi,%%ecx,)   \n\t"
      "incl %%ecx                  \n\t"
      "cmpl _dif, %%ecx            \n\t"
      "jb sub_lp1                  \n\t"

   "sub_go:                        \n\t"
      "movl _FullLength, %%eax     \n\t"
      "movl %%eax, %%edx           \n\t"
      "subl %%ecx, %%edx           \n\t" // subtract alignment fix
      "andl $0x00000007, %%edx     \n\t" // calc bytes over mult of 8
      "subl %%edx, %%eax           \n\t" // drop over bytes from length
      "movl %%eax, _MMXLength      \n\t"

      : "=a" (dummy_value_a),   // 0      // output regs (dummy)
        "=D" (dummy_value_D)    // 1

      : "0" (bpp),              // eax    // input regs
        "1" (row)               // edi

      : "%ebx", "%ecx", "%edx"            // clobber list
      , "%esi"

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
      , "%mm0", "%mm1", "%mm2", "%mm3"
      , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
   );

   // now do the math for the rest of the row
   switch (bpp)
   {
      case 3:
      {
         _ActiveMask.use  = 0x0000ffffff000000LL;
         _ShiftBpp.use = 24;       // == 3 * 8
         _ShiftRem.use  = 40;      // == 64 - 24

         __asm__ __volatile__ (
// preload  "movl row, %%edi              \n\t"
            "movq _ActiveMask, %%mm7       \n\t" // load _ActiveMask for 2nd
                                                //  active byte group
            "movl %%edi, %%esi            \n\t" // lp = row
// preload  "movl bpp, %%eax              \n\t"
            "addl %%eax, %%edi            \n\t" // rp = row + bpp
            "movq %%mm7, %%mm6            \n\t"
            "movl _dif, %%edx             \n\t"
            "psllq _ShiftBpp, %%mm6       \n\t" // move mask in mm6 to cover
                                                //  3rd active byte group
            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%edx,), %%mm1 \n\t"

         "sub_3lp:                        \n\t" // shift data for adding first
            "psrlq _ShiftRem, %%mm1       \n\t" //  bpp bytes (no need for mask;
                                                //  shift clears inactive bytes)
            // add 1st active group
            "movq (%%edi,%%edx,), %%mm0   \n\t"
            "paddb %%mm1, %%mm0           \n\t"

            // add 2nd active group
            "movq %%mm0, %%mm1            \n\t" // mov updated Raws to mm1
            "psllq _ShiftBpp, %%mm1       \n\t" // shift data to pos. correctly
            "pand %%mm7, %%mm1            \n\t" // mask to use 2nd active group
            "paddb %%mm1, %%mm0           \n\t"

            // add 3rd active group
            "movq %%mm0, %%mm1            \n\t" // mov updated Raws to mm1
            "psllq _ShiftBpp, %%mm1       \n\t" // shift data to pos. correctly
            "pand %%mm6, %%mm1            \n\t" // mask to use 3rd active group
            "addl $8, %%edx               \n\t"
            "paddb %%mm1, %%mm0           \n\t"

            "cmpl _MMXLength, %%edx       \n\t"
            "movq %%mm0, -8(%%edi,%%edx,) \n\t" // write updated Raws to array
            "movq %%mm0, %%mm1            \n\t" // prep 1st add at top of loop
            "jb sub_3lp                   \n\t"

            : "=a" (dummy_value_a),   // 0      // output regs (dummy)
              "=D" (dummy_value_D)    // 1

            : "0" (bpp),              // eax    // input regs
              "1" (row)               // edi

            : "%edx", "%esi"                    // clobber list
#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm6", "%mm7"
#endif
         );
      }
      break;

      case 1:
      {
         __asm__ __volatile__ (
            "movl _dif, %%edx            \n\t"
// preload  "movl row, %%edi             \n\t"
            "cmpl _FullLength, %%edx     \n\t"
            "jnb sub_1end                \n\t"
            "movl %%edi, %%esi           \n\t" // lp = row
            "xorl %%eax, %%eax           \n\t"
// preload  "movl bpp, %%eax             \n\t"
            "addl %%eax, %%edi           \n\t" // rp = row + bpp

         "sub_1lp:                       \n\t"
            "movb (%%esi,%%edx,), %%al   \n\t"
            "addb %%al, (%%edi,%%edx,)   \n\t"
            "incl %%edx                  \n\t"
            "cmpl _FullLength, %%edx     \n\t"
            "jb sub_1lp                  \n\t"

         "sub_1end:                      \n\t"

            : "=a" (dummy_value_a),   // 0      // output regs (dummy)
              "=D" (dummy_value_D)    // 1

            : "0" (bpp),              // eax    // input regs
              "1" (row)               // edi

            : "%edx", "%esi"                    // clobber list
         );
      }
      return;

      case 6:
      case 4:
      //case 7:   // GRR BOGUS
      //case 5:   // GRR BOGUS
      {
         _ShiftBpp.use = bpp << 3;
         _ShiftRem.use = 64 - _ShiftBpp.use;

         __asm__ __volatile__ (
// preload  "movl row, %%edi              \n\t"
            "movl _dif, %%edx             \n\t"
            "movl %%edi, %%esi            \n\t" // lp = row
// preload  "movl bpp, %%eax              \n\t"
            "addl %%eax, %%edi            \n\t" // rp = row + bpp

            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%edx,), %%mm1 \n\t"

         "sub_4lp:                        \n\t" // shift data for adding first
            "psrlq _ShiftRem, %%mm1       \n\t" //  bpp bytes (no need for mask;
                                                //  shift clears inactive bytes)
            "movq (%%edi,%%edx,), %%mm0   \n\t"
            "paddb %%mm1, %%mm0           \n\t"

            // add 2nd active group
            "movq %%mm0, %%mm1            \n\t" // mov updated Raws to mm1
            "psllq _ShiftBpp, %%mm1       \n\t" // shift data to pos. correctly
            "addl $8, %%edx               \n\t"
            "paddb %%mm1, %%mm0           \n\t"

            "cmpl _MMXLength, %%edx       \n\t"
            "movq %%mm0, -8(%%edi,%%edx,) \n\t"
            "movq %%mm0, %%mm1            \n\t" // prep 1st add at top of loop
            "jb sub_4lp                   \n\t"

            : "=a" (dummy_value_a),   // 0      // output regs (dummy)
              "=D" (dummy_value_D)    // 1

            : "0" (bpp),              // eax    // input regs
              "1" (row)               // edi

            : "%edx", "%esi"                    // clobber list
#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1"
#endif
         );
      }
      break;

      case 2:
      {
         _ActiveMask.use = 0x00000000ffff0000LL;
         _ShiftBpp.use = 16;       // == 2 * 8
         _ShiftRem.use = 48;       // == 64 - 16

         __asm__ __volatile__ (
            "movq _ActiveMask, %%mm7      \n\t" // load _ActiveMask for 2nd
                                                //  active byte group
            "movl _dif, %%edx             \n\t"
            "movq %%mm7, %%mm6            \n\t"
// preload  "movl row, %%edi              \n\t"
            "psllq _ShiftBpp, %%mm6       \n\t" // move mask in mm6 to cover
                                                //  3rd active byte group
            "movl %%edi, %%esi            \n\t" // lp = row
            "movq %%mm6, %%mm5            \n\t"
// preload  "movl bpp, %%eax              \n\t"
            "addl %%eax, %%edi            \n\t" // rp = row + bpp
            "psllq _ShiftBpp, %%mm5       \n\t" // move mask in mm5 to cover
                                                //  4th active byte group
            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%edx,), %%mm1 \n\t"

         "sub_2lp:                        \n\t" // shift data for adding first
            "psrlq _ShiftRem, %%mm1       \n\t" //  bpp bytes (no need for mask;
                                                //  shift clears inactive bytes)
            // add 1st active group
            "movq (%%edi,%%edx,), %%mm0   \n\t"
            "paddb %%mm1, %%mm0           \n\t"

            // add 2nd active group
            "movq %%mm0, %%mm1            \n\t" // mov updated Raws to mm1
            "psllq _ShiftBpp, %%mm1       \n\t" // shift data to pos. correctly
            "pand %%mm7, %%mm1            \n\t" // mask to use 2nd active group
            "paddb %%mm1, %%mm0           \n\t"

            // add 3rd active group
            "movq %%mm0, %%mm1            \n\t" // mov updated Raws to mm1
            "psllq _ShiftBpp, %%mm1       \n\t" // shift data to pos. correctly
            "pand %%mm6, %%mm1            \n\t" // mask to use 3rd active group
            "paddb %%mm1, %%mm0           \n\t"

            // add 4th active group
            "movq %%mm0, %%mm1            \n\t" // mov updated Raws to mm1
            "psllq _ShiftBpp, %%mm1       \n\t" // shift data to pos. correctly
            "pand %%mm5, %%mm1            \n\t" // mask to use 4th active group
            "addl $8, %%edx               \n\t"
            "paddb %%mm1, %%mm0           \n\t"
            "cmpl _MMXLength, %%edx       \n\t"
            "movq %%mm0, -8(%%edi,%%edx,) \n\t" // write updated Raws to array
            "movq %%mm0, %%mm1            \n\t" // prep 1st add at top of loop
            "jb sub_2lp                   \n\t"

            : "=a" (dummy_value_a),   // 0      // output regs (dummy)
              "=D" (dummy_value_D)    // 1

            : "0" (bpp),              // eax    // input regs
              "1" (row)               // edi

            : "%edx", "%esi"                    // clobber list
#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;

      case 8:
      {
         __asm__ __volatile__ (
// preload  "movl row, %%edi              \n\t"
            "movl _dif, %%edx             \n\t"
            "movl %%edi, %%esi            \n\t" // lp = row
// preload  "movl bpp, %%eax              \n\t"
            "addl %%eax, %%edi            \n\t" // rp = row + bpp
            "movl _MMXLength, %%ecx       \n\t"

            // prime the pump:  load the first Raw(x-bpp) data set
            "movq -8(%%edi,%%edx,), %%mm7 \n\t"
            "andl $0x0000003f, %%ecx      \n\t" // calc bytes over mult of 64

         "sub_8lp:                        \n\t"
            "movq (%%edi,%%edx,), %%mm0   \n\t" // load Sub(x) for 1st 8 bytes
            "paddb %%mm7, %%mm0           \n\t"
            "movq 8(%%edi,%%edx,), %%mm1  \n\t" // load Sub(x) for 2nd 8 bytes
            "movq %%mm0, (%%edi,%%edx,)   \n\t" // write Raw(x) for 1st 8 bytes

            // Now mm0 will be used as Raw(x-bpp) for the 2nd group of 8 bytes.
            // This will be repeated for each group of 8 bytes with the 8th
            // group being used as the Raw(x-bpp) for the 1st group of the
            // next loop.

            "paddb %%mm0, %%mm1           \n\t"
            "movq 16(%%edi,%%edx,), %%mm2 \n\t" // load Sub(x) for 3rd 8 bytes
            "movq %%mm1, 8(%%edi,%%edx,)  \n\t" // write Raw(x) for 2nd 8 bytes
            "paddb %%mm1, %%mm2           \n\t"
            "movq 24(%%edi,%%edx,), %%mm3 \n\t" // load Sub(x) for 4th 8 bytes
            "movq %%mm2, 16(%%edi,%%edx,) \n\t" // write Raw(x) for 3rd 8 bytes
            "paddb %%mm2, %%mm3           \n\t"
            "movq 32(%%edi,%%edx,), %%mm4 \n\t" // load Sub(x) for 5th 8 bytes
            "movq %%mm3, 24(%%edi,%%edx,) \n\t" // write Raw(x) for 4th 8 bytes
            "paddb %%mm3, %%mm4           \n\t"
            "movq 40(%%edi,%%edx,), %%mm5 \n\t" // load Sub(x) for 6th 8 bytes
            "movq %%mm4, 32(%%edi,%%edx,) \n\t" // write Raw(x) for 5th 8 bytes
            "paddb %%mm4, %%mm5           \n\t"
            "movq 48(%%edi,%%edx,), %%mm6 \n\t" // load Sub(x) for 7th 8 bytes
            "movq %%mm5, 40(%%edi,%%edx,) \n\t" // write Raw(x) for 6th 8 bytes
            "paddb %%mm5, %%mm6           \n\t"
            "movq 56(%%edi,%%edx,), %%mm7 \n\t" // load Sub(x) for 8th 8 bytes
            "movq %%mm6, 48(%%edi,%%edx,) \n\t" // write Raw(x) for 7th 8 bytes
            "addl $64, %%edx              \n\t"
            "paddb %%mm6, %%mm7           \n\t"
            "cmpl %%ecx, %%edx            \n\t"
            "movq %%mm7, -8(%%edi,%%edx,) \n\t" // write Raw(x) for 8th 8 bytes
            "jb sub_8lp                   \n\t"

            "cmpl _MMXLength, %%edx       \n\t"
            "jnb sub_8lt8                 \n\t"

         "sub_8lpA:                       \n\t"
            "movq (%%edi,%%edx,), %%mm0   \n\t"
            "addl $8, %%edx               \n\t"
            "paddb %%mm7, %%mm0           \n\t"
            "cmpl _MMXLength, %%edx       \n\t"
            "movq %%mm0, -8(%%edi,%%edx,) \n\t" // -8 to offset early addl edx
            "movq %%mm0, %%mm7            \n\t" // move calculated Raw(x) data
                                                //  to mm1 to be new Raw(x-bpp)
                                                //  for next loop
            "jb sub_8lpA                  \n\t"

         "sub_8lt8:                       \n\t"

            : "=a" (dummy_value_a),   // 0      // output regs (dummy)
              "=D" (dummy_value_D)    // 1

            : "0" (bpp),              // eax    // input regs
              "1" (row)               // edi

            : "%ecx", "%edx", "%esi"            // clobber list
#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1", "%mm2", "%mm3", "%mm4", "%mm5", "%mm6", "%mm7"
#endif
         );
      }
      break;

      default:                // bpp greater than 8 bytes	GRR BOGUS
      {
         __asm__ __volatile__ (
            "movl _dif, %%edx             \n\t"
// preload  "movl row, %%edi              \n\t"
            "movl %%edi, %%esi            \n\t" // lp = row
// preload  "movl bpp, %%eax              \n\t"
            "addl %%eax, %%edi            \n\t" // rp = row + bpp

         "sub_Alp:                        \n\t"
            "movq (%%edi,%%edx,), %%mm0   \n\t"
            "movq (%%esi,%%edx,), %%mm1   \n\t"
            "addl $8, %%edx               \n\t"
            "paddb %%mm1, %%mm0           \n\t"
            "cmpl _MMXLength, %%edx       \n\t"
            "movq %%mm0, -8(%%edi,%%edx,) \n\t" // mov does not affect flags;
                                                //  -8 to offset addl edx
            "jb sub_Alp                   \n\t"

            : "=a" (dummy_value_a),   // 0      // output regs (dummy)
              "=D" (dummy_value_D)    // 1

            : "0" (bpp),              // eax    // input regs
              "1" (row)               // edi

            : "%edx", "%esi"                    // clobber list
#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
            , "%mm0", "%mm1"
#endif
         );
      }
      break;

   } // end switch (bpp)

   __asm__ __volatile__ (
      "movl _MMXLength, %%edx       \n\t"
//pre "movl row, %%edi              \n\t"
      "cmpl _FullLength, %%edx      \n\t"
      "jnb sub_end                  \n\t"

      "movl %%edi, %%esi            \n\t" // lp = row
//pre "movl bpp, %%eax              \n\t"
      "addl %%eax, %%edi            \n\t" // rp = row + bpp
      "xorl %%eax, %%eax            \n\t"

   "sub_lp2:                        \n\t"
      "movb (%%esi,%%edx,), %%al    \n\t"
      "addb %%al, (%%edi,%%edx,)    \n\t"
      "incl %%edx                   \n\t"
      "cmpl _FullLength, %%edx      \n\t"
      "jb sub_lp2                   \n\t"

   "sub_end:                        \n\t"
      "EMMS                         \n\t" // end MMX instructions

      : "=a" (dummy_value_a),   // 0      // output regs (dummy)
        "=D" (dummy_value_D)    // 1

      : "0" (bpp),              // eax    // input regs
        "1" (row)               // edi

      : "%edx", "%esi"                    // clobber list
   );

} // end of png_read_filter_row_mmx_sub()




//===========================================================================//
//                                                                           //
//            P N G _ R E A D _ F I L T E R _ R O W _ M M X _ U P            //
//                                                                           //
//===========================================================================//

// Optimized code for PNG Up filter decoder

static void /* PRIVATE */
png_read_filter_row_mmx_up(png_row_infop row_info, png_bytep row,
                           png_bytep prev_row)
{
   png_uint_32 len;
   int dummy_value_d;   // fix 'forbidden register 3 (dx) was spilled' error
   int dummy_value_S;
   int dummy_value_D;

   len = row_info->rowbytes;              // number of bytes to filter

   __asm__ __volatile__ (
//pre "movl row, %%edi              \n\t"
      // get # of bytes to alignment
      "movl %%edi, %%ecx            \n\t"
      "xorl %%ebx, %%ebx            \n\t"
      "addl $0x7, %%ecx             \n\t"
      "xorl %%eax, %%eax            \n\t"
      "andl $0xfffffff8, %%ecx      \n\t"
//pre "movl prev_row, %%esi         \n\t"
      "subl %%edi, %%ecx            \n\t"
      "jz up_go                     \n\t"

   "up_lp1:                         \n\t" // fix alignment
      "movb (%%edi,%%ebx,), %%al    \n\t"
      "addb (%%esi,%%ebx,), %%al    \n\t"
      "incl %%ebx                   \n\t"
      "cmpl %%ecx, %%ebx            \n\t"
      "movb %%al, -1(%%edi,%%ebx,)  \n\t" // mov does not affect flags; -1 to
      "jb up_lp1                    \n\t" //  offset incl ebx

   "up_go:                          \n\t"
//pre "movl len, %%edx              \n\t"
      "movl %%edx, %%ecx            \n\t"
      "subl %%ebx, %%edx            \n\t" // subtract alignment fix
      "andl $0x0000003f, %%edx      \n\t" // calc bytes over mult of 64
      "subl %%edx, %%ecx            \n\t" // drop over bytes from length

      // unrolled loop - use all MMX registers and interleave to reduce
      // number of branch instructions (loops) and reduce partial stalls
   "up_loop:                        \n\t"
      "movq (%%esi,%%ebx,), %%mm1   \n\t"
      "movq (%%edi,%%ebx,), %%mm0   \n\t"
      "movq 8(%%esi,%%ebx,), %%mm3  \n\t"
      "paddb %%mm1, %%mm0           \n\t"
      "movq 8(%%edi,%%ebx,), %%mm2  \n\t"
      "movq %%mm0, (%%edi,%%ebx,)   \n\t"
      "paddb %%mm3, %%mm2           \n\t"
      "movq 16(%%esi,%%ebx,), %%mm5 \n\t"
      "movq %%mm2, 8(%%edi,%%ebx,)  \n\t"
      "movq 16(%%edi,%%ebx,), %%mm4 \n\t"
      "movq 24(%%esi,%%ebx,), %%mm7 \n\t"
      "paddb %%mm5, %%mm4           \n\t"
      "movq 24(%%edi,%%ebx,), %%mm6 \n\t"
      "movq %%mm4, 16(%%edi,%%ebx,) \n\t"
      "paddb %%mm7, %%mm6           \n\t"
      "movq 32(%%esi,%%ebx,), %%mm1 \n\t"
      "movq %%mm6, 24(%%edi,%%ebx,) \n\t"
      "movq 32(%%edi,%%ebx,), %%mm0 \n\t"
      "movq 40(%%esi,%%ebx,), %%mm3 \n\t"
      "paddb %%mm1, %%mm0           \n\t"
      "movq 40(%%edi,%%ebx,), %%mm2 \n\t"
      "movq %%mm0, 32(%%edi,%%ebx,) \n\t"
      "paddb %%mm3, %%mm2           \n\t"
      "movq 48(%%esi,%%ebx,), %%mm5 \n\t"
      "movq %%mm2, 40(%%edi,%%ebx,) \n\t"
      "movq 48(%%edi,%%ebx,), %%mm4 \n\t"
      "movq 56(%%esi,%%ebx,), %%mm7 \n\t"
      "paddb %%mm5, %%mm4           \n\t"
      "movq 56(%%edi,%%ebx,), %%mm6 \n\t"
      "movq %%mm4, 48(%%edi,%%ebx,) \n\t"
      "addl $64, %%ebx              \n\t"
      "paddb %%mm7, %%mm6           \n\t"
      "cmpl %%ecx, %%ebx            \n\t"
      "movq %%mm6, -8(%%edi,%%ebx,) \n\t" // (+56)movq does not affect flags;
      "jb up_loop                   \n\t" //  -8 to offset addl ebx

      "cmpl $0, %%edx               \n\t" // test for bytes over mult of 64
      "jz up_end                    \n\t"

      "cmpl $8, %%edx               \n\t" // test for less than 8 bytes
      "jb up_lt8                    \n\t" //  [added by lcreeve@netins.net]

      "addl %%edx, %%ecx            \n\t"
      "andl $0x00000007, %%edx      \n\t" // calc bytes over mult of 8
      "subl %%edx, %%ecx            \n\t" // drop over bytes from length
      "jz up_lt8                    \n\t"

   "up_lpA:                         \n\t" // use MMX regs to update 8 bytes sim.
      "movq (%%esi,%%ebx,), %%mm1   \n\t"
      "movq (%%edi,%%ebx,), %%mm0   \n\t"
      "addl $8, %%ebx               \n\t"
      "paddb %%mm1, %%mm0           \n\t"
      "cmpl %%ecx, %%ebx            \n\t"
      "movq %%mm0, -8(%%edi,%%ebx,) \n\t" // movq does not affect flags; -8 to
      "jb up_lpA                    \n\t" //  offset add ebx
      "cmpl $0, %%edx               \n\t" // test for bytes over mult of 8
      "jz up_end                    \n\t"

   "up_lt8:                         \n\t"
      "xorl %%eax, %%eax            \n\t"
      "addl %%edx, %%ecx            \n\t" // move over byte count into counter

   "up_lp2:                         \n\t" // use x86 regs for remaining bytes
      "movb (%%edi,%%ebx,), %%al    \n\t"
      "addb (%%esi,%%ebx,), %%al    \n\t"
      "incl %%ebx                   \n\t"
      "cmpl %%ecx, %%ebx            \n\t"
      "movb %%al, -1(%%edi,%%ebx,)  \n\t" // mov does not affect flags; -1 to
      "jb up_lp2                    \n\t" //  offset inc ebx

   "up_end:                         \n\t"
      "EMMS                         \n\t" // conversion of filtered row complete

      : "=d" (dummy_value_d),   // 0      // output regs (dummy)
        "=S" (dummy_value_S),   // 1
        "=D" (dummy_value_D)    // 2

      : "0" (len),              // edx    // input regs
        "1" (prev_row),         // esi
        "2" (row)               // edi

      : "%eax", "%ebx", "%ecx"            // clobber list (no input regs!)

#if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
      , "%mm0", "%mm1", "%mm2", "%mm3"
      , "%mm4", "%mm5", "%mm6", "%mm7"
#endif
   );

} // end of png_read_filter_row_mmx_up()

#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */




/*===========================================================================*/
/*                                                                           */
/*                   P N G _ R E A D _ F I L T E R _ R O W                   */
/*                                                                           */
/*===========================================================================*/

#if defined(PNG_HAVE_ASSEMBLER_READ_FILTER_ROW)

/* Optimized png_read_filter_row routines */

void /* PRIVATE */
png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep
   row, png_bytep prev_row, int filter)
{
#ifdef PNG_DEBUG
   char filnm[10];
#endif

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
/* GRR:  these are superseded by png_ptr->asm_flags: */
#define UseMMX_sub    1   // GRR:  converted 20000730
#define UseMMX_up     1   // GRR:  converted 20000729
#define UseMMX_avg    1   // GRR:  converted 20000828 (+ 16-bit bugfix 20000916)
#define UseMMX_paeth  1   // GRR:  converted 20000828

   if (_mmx_supported == 2) {
       png_mmx_support();
   }
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */

#ifdef PNG_DEBUG
   png_debug(1, "in png_read_filter_row (pnggccrd.c)\n");
   switch (filter)
   {
      case 0: sprintf(filnm, "none");
         break;
      case 1: sprintf(filnm, "sub-%s", "MMX");
         break;
      case 2: sprintf(filnm, "up-%s", "MMX");
         break;
      case 3: sprintf(filnm, "avg-%s", "MMX");
         break;
      case 4: sprintf(filnm, "Paeth-%s", "MMX");
         break;
      default: sprintf(filnm, "unknw");
         break;
   }
   png_debug2(0, "row_number=%5ld, %5s, ", png_ptr->row_number, filnm);
   png_debug1(0, "row=0x%08lx, ", (unsigned long)row);
   png_debug2(0, "pixdepth=%2d, bytes=%d, ", (int)row_info->pixel_depth,
      (int)((row_info->pixel_depth + 7) >> 3));
   png_debug1(0,"rowbytes=%8ld\n", row_info->rowbytes);
#endif /* PNG_DEBUG */

   switch (filter)
   {
      case PNG_FILTER_VALUE_NONE:
         break;

      case PNG_FILTER_VALUE_SUB:
#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
         if ( _mmx_supported &&
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_sub(row_info, row);
         }
         else
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
         {
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_bytep rp = row + bpp;
            png_bytep lp = row;

            for (i = bpp; i < istop; i++)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
               rp++;
            }
         }  /* end !UseMMX_sub */
         break;

      case PNG_FILTER_VALUE_UP:
#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
         if ( _mmx_supported &&
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_up(row_info, row, prev_row);
         }
          else
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
         {
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_bytep rp = row;
            png_bytep pp = prev_row;

            for (i = 0; i < istop; ++i)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
               rp++;
            }
         }  /* end !UseMMX_up */
         break;

      case PNG_FILTER_VALUE_AVG:
#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
         if ( _mmx_supported &&
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_avg(row_info, row, prev_row);
         }
         else
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
         {
            png_uint_32 i;
            png_bytep rp = row;
            png_bytep pp = prev_row;
            png_bytep lp = row;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_uint_32 istop = row_info->rowbytes - bpp;

            for (i = 0; i < bpp; i++)
            {
               *rp = (png_byte)(((int)(*rp) +
                  ((int)(*pp++) >> 1)) & 0xff);
               rp++;
            }

            for (i = 0; i < istop; i++)
            {
               *rp = (png_byte)(((int)(*rp) +
                  ((int)(*pp++ + *lp++) >> 1)) & 0xff);
               rp++;
            }
         }  /* end !UseMMX_avg */
         break;

      case PNG_FILTER_VALUE_PAETH:
#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
         if ( _mmx_supported &&
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_paeth(row_info, row, prev_row);
         }
         else
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
         {
            png_uint_32 i;
            png_bytep rp = row;
            png_bytep pp = prev_row;
            png_bytep lp = row;
            png_bytep cp = prev_row;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_uint_32 istop = row_info->rowbytes - bpp;

            for (i = 0; i < bpp; i++)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
               rp++;
            }

            for (i = 0; i < istop; i++)   /* use leftover rp,pp */
            {
               int a, b, c, pa, pb, pc, p;

               a = *lp++;
               b = *pp++;
               c = *cp++;

               p = b - c;
               pc = a - c;

#ifdef PNG_USE_ABS
               pa = abs(p);
               pb = abs(pc);
               pc = abs(p + pc);
#else
               pa = p < 0 ? -p : p;
               pb = pc < 0 ? -pc : pc;
               pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

               /*
                  if (pa <= pb && pa <= pc)
                     p = a;
                  else if (pb <= pc)
                     p = b;
                  else
                     p = c;
                */

               p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;

               *rp = (png_byte)(((int)(*rp) + p) & 0xff);
               rp++;
            }
         }  /* end !UseMMX_paeth */
         break;

      default:
         png_warning(png_ptr, "Ignoring bad row-filter type");
         *row=0;
         break;
   }
}

#endif /* PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */


/*===========================================================================*/
/*                                                                           */
/*                      P N G _ M M X _ S U P P O R T                        */
/*                                                                           */
/*===========================================================================*/

/* GRR NOTES:  (1) the following code assumes 386 or better (pushfl/popfl)
 *             (2) all instructions compile with gcc 2.7.2.3 and later
 *             (3) the function is moved down here to prevent gcc from
 *                  inlining it in multiple places and then barfing be-
 *                  cause the ".NOT_SUPPORTED" label is multiply defined
 *             [is there a way to signal that a *single* function should
 *              not be inlined?  is there a way to modify the label for
 *              each inlined instance, e.g., by appending _1, _2, etc.?
 *              maybe if don't use leading "." in label name? (nope...sigh)]
 */

int PNGAPI
png_mmx_support(void)
{
#if defined(PNG_MMX_CODE_SUPPORTED)
    __asm__ __volatile__ (
        "pushl %%ebx          \n\t"  // ebx gets clobbered by CPUID instruction
        "pushl %%ecx          \n\t"  // so does ecx...
        "pushl %%edx          \n\t"  // ...and edx (but ecx & edx safe on Linux)
//      ".byte  0x66          \n\t"  // convert 16-bit pushf to 32-bit pushfd
//      "pushf                \n\t"  // 16-bit pushf
        "pushfl               \n\t"  // save Eflag to stack
        "popl %%eax           \n\t"  // get Eflag from stack into eax
        "movl %%eax, %%ecx    \n\t"  // make another copy of Eflag in ecx
        "xorl $0x200000, %%eax \n\t" // toggle ID bit in Eflag (i.e., bit 21)
        "pushl %%eax          \n\t"  // save modified Eflag back to stack
//      ".byte  0x66          \n\t"  // convert 16-bit popf to 32-bit popfd
//      "popf                 \n\t"  // 16-bit popf
        "popfl                \n\t"  // restore modified value to Eflag reg
        "pushfl               \n\t"  // save Eflag to stack
        "popl %%eax           \n\t"  // get Eflag from stack
        "xorl %%ecx, %%eax    \n\t"  // compare new Eflag with original Eflag
        "jz .NOT_SUPPORTED    \n\t"  // if same, CPUID instr. is not supported

        "xorl %%eax, %%eax    \n\t"  // set eax to zero
//      ".byte  0x0f, 0xa2    \n\t"  // CPUID instruction (two-byte opcode)
        "cpuid                \n\t"  // get the CPU identification info
        "cmpl $1, %%eax       \n\t"  // make sure eax return non-zero value
        "jl .NOT_SUPPORTED    \n\t"  // if eax is zero, MMX is not supported

        "xorl %%eax, %%eax    \n\t"  // set eax to zero and...
        "incl %%eax           \n\t"  // ...increment eax to 1.  This pair is
                                     // faster than the instruction "mov eax, 1"
        "cpuid                \n\t"  // get the CPU identification info again
        "andl $0x800000, %%edx \n\t" // mask out all bits but MMX bit (23)
        "cmpl $0, %%edx       \n\t"  // 0 = MMX not supported
        "jz .NOT_SUPPORTED    \n\t"  // non-zero = yes, MMX IS supported

        "movl $1, %%eax       \n\t"  // set return value to 1
        "jmp  .RETURN         \n\t"  // DONE:  have MMX support

    ".NOT_SUPPORTED:          \n\t"  // target label for jump instructions
        "movl $0, %%eax       \n\t"  // set return value to 0
    ".RETURN:          \n\t"  // target label for jump instructions
        "movl %%eax, _mmx_supported \n\t" // save in global static variable, too
        "popl %%edx           \n\t"  // restore edx
        "popl %%ecx           \n\t"  // restore ecx
        "popl %%ebx           \n\t"  // restore ebx

//      "ret                  \n\t"  // DONE:  no MMX support
                                     // (fall through to standard C "ret")

        :                            // output list (none)

        :                            // any variables used on input (none)

        : "%eax"                     // clobber list
//      , "%ebx", "%ecx", "%edx"     // GRR:  we handle these manually
//      , "memory"   // if write to a variable gcc thought was in a reg
//      , "cc"       // "condition codes" (flag bits)
    );
#else     
    _mmx_supported = 0;
#endif /* PNG_MMX_CODE_SUPPORTED */

    return _mmx_supported;
}

#endif /* PNG_USE_PNGGCCRD */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngget.c ===
/* pngget.c - retrieval of values from info struct
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

#define PNG_INTERNAL
#include "png.h"

png_uint_32 PNGAPI
png_get_valid(png_structp png_ptr, png_infop info_ptr, png_uint_32 flag)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->valid & flag);
   else
      return(0);
}

png_uint_32 PNGAPI
png_get_rowbytes(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->rowbytes);
   else
      return(0);
}

#if defined(PNG_INFO_IMAGE_SUPPORTED)
png_bytepp PNGAPI
png_get_rows(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->row_pointers);
   else
      return(0);
}
#endif

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* easy access to info, added in libpng-0.99 */
png_uint_32 PNGAPI
png_get_image_width(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->width;
   }
   return (0);
}

png_uint_32 PNGAPI
png_get_image_height(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->height;
   }
   return (0);
}

png_byte PNGAPI
png_get_bit_depth(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->bit_depth;
   }
   return (0);
}

png_byte PNGAPI
png_get_color_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->color_type;
   }
   return (0);
}

png_byte PNGAPI
png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->filter_type;
   }
   return (0);
}

png_byte PNGAPI
png_get_interlace_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->interlace_type;
   }
   return (0);
}

png_byte PNGAPI
png_get_compression_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
   {
      return info_ptr->compression_type;
   }
   return (0);
}

png_uint_32 PNGAPI
png_get_x_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_x_pixels_per_meter");
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
          return (0);
      else return (info_ptr->x_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

png_uint_32 PNGAPI
png_get_y_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_y_pixels_per_meter");
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
          return (0);
      else return (info_ptr->y_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

png_uint_32 PNGAPI
png_get_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_pixels_per_meter");
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
         info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit)
          return (0);
      else return (info_ptr->x_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
png_get_pixel_aspect_ratio(png_structp png_ptr, png_infop info_ptr)
   {
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_aspect_ratio");
      if (info_ptr->x_pixels_per_unit == 0)
         return ((float)0.0);
      else
         return ((float)((float)info_ptr->y_pixels_per_unit
            /(float)info_ptr->x_pixels_per_unit));
   }
#else
   return (0.0);
#endif
   return ((float)0.0);
}
#endif

png_int_32 PNGAPI
png_get_x_offset_microns(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
          return (0);
      else return (info_ptr->x_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_microns(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
          return (0);
      else return (info_ptr->y_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_x_offset_pixels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
          return (0);
      else return (info_ptr->x_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_pixels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#if defined(PNG_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
          return (0);
      else return (info_ptr->y_offset);
   }
#else
   return (0);
#endif
   return (0);
}

#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
png_uint_32 PNGAPI
png_get_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

png_uint_32 PNGAPI
png_get_x_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_x_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

png_uint_32 PNGAPI
png_get_y_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_y_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

float PNGAPI
png_get_x_offset_inches(png_structp png_ptr, png_infop info_ptr)
{
   return ((float)png_get_x_offset_microns(png_ptr, info_ptr)
     *.00003937);
}

float PNGAPI
png_get_y_offset_inches(png_structp png_ptr, png_infop info_ptr)
{
   return ((float)png_get_y_offset_microns(png_ptr, info_ptr)
     *.00003937);
}

#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
png_get_pHYs_dpi(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_debug1(1, "in %s retrieval function\n", "pHYs");
      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
         if(*unit_type == 1)
         {
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
         }
      }
   }
   return (retval);
}
#endif /* PNG_pHYs_SUPPORTED */
#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */

/* png_get_channels really belongs in here, too, but it's been around longer */

#endif  /* PNG_EASY_ACCESS_SUPPORTED */

png_byte PNGAPI
png_get_channels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->channels);
   else
      return (0);
}

png_bytep PNGAPI
png_get_signature(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->signature);
   else
      return (NULL);
}

#if defined(PNG_bKGD_SUPPORTED)
png_uint_32 PNGAPI
png_get_bKGD(png_structp png_ptr, png_infop info_ptr,
   png_color_16p *background)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)
      && background != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "bKGD");
      *background = &(info_ptr->background);
      return (PNG_INFO_bKGD);
   }
   return (0);
}
#endif

#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM(png_structp png_ptr, png_infop info_ptr,
   double *white_x, double *white_y, double *red_x, double *red_y,
   double *green_x, double *green_y, double *blue_x, double *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function\n", "cHRM");
      if (white_x != NULL)
         *white_x = (double)info_ptr->x_white;
      if (white_y != NULL)
         *white_y = (double)info_ptr->y_white;
      if (red_x != NULL)
         *red_x = (double)info_ptr->x_red;
      if (red_y != NULL)
         *red_y = (double)info_ptr->y_red;
      if (green_x != NULL)
         *green_x = (double)info_ptr->x_green;
      if (green_y != NULL)
         *green_y = (double)info_ptr->y_green;
      if (blue_x != NULL)
         *blue_x = (double)info_ptr->x_blue;
      if (blue_y != NULL)
         *blue_y = (double)info_ptr->y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
   png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
   png_fixed_point *blue_x, png_fixed_point *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function\n", "cHRM");
      if (white_x != NULL)
         *white_x = info_ptr->int_x_white;
      if (white_y != NULL)
         *white_y = info_ptr->int_y_white;
      if (red_x != NULL)
         *red_x = info_ptr->int_x_red;
      if (red_y != NULL)
         *red_y = info_ptr->int_y_red;
      if (green_x != NULL)
         *green_x = info_ptr->int_x_green;
      if (green_y != NULL)
         *green_y = info_ptr->int_y_green;
      if (blue_x != NULL)
         *blue_x = info_ptr->int_x_blue;
      if (blue_y != NULL)
         *blue_y = info_ptr->int_y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#endif

#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA(png_structp png_ptr, png_infop info_ptr, double *file_gamma)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && file_gamma != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "gAMA");
      *file_gamma = (double)info_ptr->gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
    png_fixed_point *int_file_gamma)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && int_file_gamma != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "gAMA");
      *int_file_gamma = info_ptr->int_gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#endif

#if defined(PNG_sRGB_SUPPORTED)
png_uint_32 PNGAPI
png_get_sRGB(png_structp png_ptr, png_infop info_ptr, int *file_srgb_intent)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)
      && file_srgb_intent != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "sRGB");
      *file_srgb_intent = (int)info_ptr->srgb_intent;
      return (PNG_INFO_sRGB);
   }
   return (0);
}
#endif

#if defined(PNG_iCCP_SUPPORTED)
png_uint_32 PNGAPI
png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charpp name, int *compression_type,
             png_charpp profile, png_uint_32 *proflen)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
      && name != NULL && profile != NULL && proflen != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "iCCP");
      *name = info_ptr->iccp_name;
      *profile = info_ptr->iccp_profile;
      /* compression_type is a dummy so the API won't have to change
         if we introduce multiple compression types later. */
      *proflen = (int)info_ptr->iccp_proflen;
      *compression_type = (int)info_ptr->iccp_compression;
      return (PNG_INFO_iCCP);
   }
   return (0);
}
#endif

#if defined(PNG_sPLT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
             png_sPLT_tpp spalettes)
{
   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
     *spalettes = info_ptr->splt_palettes;
   return ((png_uint_32)info_ptr->splt_palettes_num);
}
#endif

#if defined(PNG_hIST_SUPPORTED)
png_uint_32 PNGAPI
png_get_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p *hist)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)
      && hist != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "hIST");
      *hist = info_ptr->hist;
      return (PNG_INFO_hIST);
   }
   return (0);
}
#endif

png_uint_32 PNGAPI
png_get_IHDR(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *width, png_uint_32 *height, int *bit_depth,
   int *color_type, int *interlace_type, int *compression_type,
   int *filter_type)

{
   if (png_ptr != NULL && info_ptr != NULL && width != NULL && height != NULL &&
      bit_depth != NULL && color_type != NULL)
   {
      int pixel_depth, channels;
      png_uint_32 rowbytes_per_pixel;

      png_debug1(1, "in %s retrieval function\n", "IHDR");
      *width = info_ptr->width;
      *height = info_ptr->height;
      *bit_depth = info_ptr->bit_depth;
      *color_type = info_ptr->color_type;
      if (compression_type != NULL)
         *compression_type = info_ptr->compression_type;
      if (filter_type != NULL)
         *filter_type = info_ptr->filter_type;
      if (interlace_type != NULL)
         *interlace_type = info_ptr->interlace_type;

      /* check for potential overflow of rowbytes */
      if (*color_type == PNG_COLOR_TYPE_PALETTE)
         channels = 1;
      else if (*color_type & PNG_COLOR_MASK_COLOR)
         channels = 3;
      else
         channels = 1;
      if (*color_type & PNG_COLOR_MASK_ALPHA)
         channels++;
      pixel_depth = *bit_depth * channels;
      rowbytes_per_pixel = (pixel_depth + 7) >> 3;
      if ((*width > PNG_MAX_UINT/rowbytes_per_pixel))
      {
         png_warning(png_ptr,
            "Width too large for libpng to process image data.");
      }
      return (1);
   }
   return (0);
}

#if defined(PNG_oFFs_SUPPORTED)
png_uint_32 PNGAPI
png_get_oFFs(png_structp png_ptr, png_infop info_ptr,
   png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)
      && offset_x != NULL && offset_y != NULL && unit_type != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "oFFs");
      *offset_x = info_ptr->x_offset;
      *offset_y = info_ptr->y_offset;
      *unit_type = (int)info_ptr->offset_unit_type;
      return (PNG_INFO_oFFs);
   }
   return (0);
}
#endif

#if defined(PNG_pCAL_SUPPORTED)
png_uint_32 PNGAPI
png_get_pCAL(png_structp png_ptr, png_infop info_ptr,
   png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,
   png_charp *units, png_charpp *params)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
      && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
      nparams != NULL && units != NULL && params != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "pCAL");
      *purpose = info_ptr->pcal_purpose;
      *X0 = info_ptr->pcal_X0;
      *X1 = info_ptr->pcal_X1;
      *type = (int)info_ptr->pcal_type;
      *nparams = (int)info_ptr->pcal_nparams;
      *units = info_ptr->pcal_units;
      *params = info_ptr->pcal_params;
      return (PNG_INFO_pCAL);
   }
   return (0);
}
#endif

#if defined(PNG_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
             int *unit, double *width, double *height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_pixel_width;
        *height = info_ptr->scal_pixel_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int *unit, png_charpp width, png_charpp height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_s_width;
        *height = info_ptr->scal_s_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#endif
#endif
#endif

#if defined(PNG_pHYs_SUPPORTED)
png_uint_32 PNGAPI
png_get_pHYs(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_debug1(1, "in %s retrieval function\n", "pHYs");
      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
      }
   }
   return (retval);
}
#endif

png_uint_32 PNGAPI
png_get_PLTE(png_structp png_ptr, png_infop info_ptr, png_colorp *palette,
   int *num_palette)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
       && palette != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "PLTE");
      *palette = info_ptr->palette;
      *num_palette = info_ptr->num_palette;
      png_debug1(3, "num_palette = %d\n", *num_palette);
      return (PNG_INFO_PLTE);
   }
   return (0);
}

#if defined(PNG_sBIT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sBIT(png_structp png_ptr, png_infop info_ptr, png_color_8p *sig_bit)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
      && sig_bit != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "sBIT");
      *sig_bit = &(info_ptr->sig_bit);
      return (PNG_INFO_sBIT);
   }
   return (0);
}
#endif

#if defined(PNG_TEXT_SUPPORTED)
png_uint_32 PNGAPI
png_get_text(png_structp png_ptr, png_infop info_ptr, png_textp *text_ptr,
   int *num_text)
{
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
   {
      png_debug1(1, "in %s retrieval function\n",
         (png_ptr->chunk_name[0] == '\0' ? "text"
             : (png_const_charp)png_ptr->chunk_name));
      if (text_ptr != NULL)
         *text_ptr = info_ptr->text;
      if (num_text != NULL)
         *num_text = info_ptr->num_text;
      return ((png_uint_32)info_ptr->num_text);
   }
   if (num_text != NULL)
     *num_text = 0;
   return(0);
}
#endif

#if defined(PNG_tIME_SUPPORTED)
png_uint_32 PNGAPI
png_get_tIME(png_structp png_ptr, png_infop info_ptr, png_timep *mod_time)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
       && mod_time != NULL)
   {
      png_debug1(1, "in %s retrieval function\n", "tIME");
      *mod_time = &(info_ptr->mod_time);
      return (PNG_INFO_tIME);
   }
   return (0);
}
#endif

#if defined(PNG_tRNS_SUPPORTED)
png_uint_32 PNGAPI
png_get_tRNS(png_structp png_ptr, png_infop info_ptr,
   png_bytep *trans, int *num_trans, png_color_16p *trans_values)
{
   png_uint_32 retval = 0;
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   {
      png_debug1(1, "in %s retrieval function\n", "tRNS");
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
          if (trans != NULL)
          {
             *trans = info_ptr->trans;
             retval |= PNG_INFO_tRNS;
          }
          if (trans_values != NULL)
             *trans_values = &(info_ptr->trans_values);
      }
      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
      {
          if (trans_values != NULL)
          {
             *trans_values = &(info_ptr->trans_values);
             retval |= PNG_INFO_tRNS;
          }
          if(trans != NULL)
             *trans = NULL;
      }
      if(num_trans != NULL)
      {
         *num_trans = info_ptr->num_trans;
         retval |= PNG_INFO_tRNS;
      }
   }
   return (retval);
}
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
png_uint_32 PNGAPI
png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
             png_unknown_chunkpp unknowns)
{
   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
     *unknowns = info_ptr->unknown_chunks;
   return ((png_uint_32)info_ptr->unknown_chunks_num);
}
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
png_byte PNGAPI
png_get_rgb_to_gray_status (png_structp png_ptr)
{
   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);
}
#endif

#if defined(PNG_USER_CHUNKS_SUPPORTED)
png_voidp PNGAPI
png_get_user_chunk_ptr(png_structp png_ptr)
{
   return (png_ptr? png_ptr->user_chunk_ptr : NULL);
}
#endif


png_uint_32 PNGAPI
png_get_compression_buffer_size(png_structp png_ptr)
{
   return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngpread.c ===
/* pngpread.c - read a png file in push mode
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

#define PNG_INTERNAL
#include "png.h"

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED

/* push model modes */
#define PNG_READ_SIG_MODE   0
#define PNG_READ_CHUNK_MODE 1
#define PNG_READ_IDAT_MODE  2
#define PNG_SKIP_MODE       3
#define PNG_READ_tEXt_MODE  4
#define PNG_READ_zTXt_MODE  5
#define PNG_READ_DONE_MODE  6
#define PNG_READ_iTXt_MODE  7
#define PNG_ERROR_MODE      8

void PNGAPI
png_process_data(png_structp png_ptr, png_infop info_ptr,
   png_bytep buffer, png_size_t buffer_size)
{
   png_push_restore_buffer(png_ptr, buffer, buffer_size);

   while (png_ptr->buffer_size)
   {
      png_process_some_data(png_ptr, info_ptr);
   }
}

/* What we do with the incoming data depends on what we were previously
 * doing before we ran out of data...
 */
void /* PRIVATE */
png_process_some_data(png_structp png_ptr, png_infop info_ptr)
{
   switch (png_ptr->process_mode)
   {
      case PNG_READ_SIG_MODE:
      {
         png_push_read_sig(png_ptr, info_ptr);
         break;
      }
      case PNG_READ_CHUNK_MODE:
      {
         png_push_read_chunk(png_ptr, info_ptr);
         break;
      }
      case PNG_READ_IDAT_MODE:
      {
         png_push_read_IDAT(png_ptr);
         break;
      }
#if defined(PNG_READ_tEXt_SUPPORTED)
      case PNG_READ_tEXt_MODE:
      {
         png_push_read_tEXt(png_ptr, info_ptr);
         break;
      }
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      case PNG_READ_zTXt_MODE:
      {
         png_push_read_zTXt(png_ptr, info_ptr);
         break;
      }
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      case PNG_READ_iTXt_MODE:
      {
         png_push_read_iTXt(png_ptr, info_ptr);
         break;
      }
#endif
      case PNG_SKIP_MODE:
      {
         png_push_crc_finish(png_ptr);
         break;
      }
      default:
      {
         png_ptr->buffer_size = 0;
         break;
      }
   }
}

/* Read any remaining signature bytes from the stream and compare them with
 * the correct PNG signature.  It is possible that this routine is called
 * with bytes already read from the signature, either because they have been
 * checked by the calling application, or because of multiple calls to this
 * routine.
 */
void /* PRIVATE */
png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
{
   png_size_t num_checked = png_ptr->sig_bytes,
             num_to_check = 8 - num_checked;

   if (png_ptr->buffer_size < num_to_check)
   {
      num_to_check = png_ptr->buffer_size;
   }

   png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),
      num_to_check);
   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes+num_to_check);

   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
   {
      if (num_checked < 4 &&
          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
         png_error(png_ptr, "Not a PNG file");
      else
         png_error(png_ptr, "PNG file corrupted by ASCII conversion");
   }
   else
   {
      if (png_ptr->sig_bytes >= 8)
      {
         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
      }
   }
}

void /* PRIVATE */
png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_IHDR;
      PNG_IDAT;
      PNG_IEND;
      PNG_PLTE;
#if defined(PNG_READ_bKGD_SUPPORTED)
      PNG_bKGD;
#endif
#if defined(PNG_READ_cHRM_SUPPORTED)
      PNG_cHRM;
#endif
#if defined(PNG_READ_gAMA_SUPPORTED)
      PNG_gAMA;
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
      PNG_hIST;
#endif
#if defined(PNG_READ_iCCP_SUPPORTED)
      PNG_iCCP;
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      PNG_iTXt;
#endif
#if defined(PNG_READ_oFFs_SUPPORTED)
      PNG_oFFs;
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
      PNG_pCAL;
#endif
#if defined(PNG_READ_pHYs_SUPPORTED)
      PNG_pHYs;
#endif
#if defined(PNG_READ_sBIT_SUPPORTED)
      PNG_sBIT;
#endif
#if defined(PNG_READ_sCAL_SUPPORTED)
      PNG_sCAL;
#endif
#if defined(PNG_READ_sRGB_SUPPORTED)
      PNG_sRGB;
#endif
#if defined(PNG_READ_sPLT_SUPPORTED)
      PNG_sPLT;
#endif
#if defined(PNG_READ_tEXt_SUPPORTED)
      PNG_tEXt;
#endif
#if defined(PNG_READ_tIME_SUPPORTED)
      PNG_tIME;
#endif
#if defined(PNG_READ_tRNS_SUPPORTED)
      PNG_tRNS;
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      PNG_zTXt;
#endif
#endif /* PNG_USE_LOCAL_ARRAYS */
   /* First we make sure we have enough data for the 4 byte chunk name
    * and the 4 byte chunk length before proceeding with decoding the
    * chunk data.  To fully decode each of these chunks, we also make
    * sure we have enough data in the buffer for the 4 byte CRC at the
    * end of every chunk (except IDAT, which is handled separately).
    */
   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
   {
      png_byte chunk_length[4];

      if (png_ptr->buffer_size < 8)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_fill_buffer(png_ptr, chunk_length, 4);
      png_ptr->push_length = png_get_uint_32(chunk_length);
      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
   }

   if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
   }
   else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
   }
   else if (!png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
   {
      /* If we reach an IDAT chunk, this means we have read all of the
       * header chunks, and we can start reading the image (or if this
       * is called after the image has been read - we have an error).
       */
      if (png_ptr->mode & PNG_HAVE_IDAT)
      {
         if (png_ptr->push_length == 0)
            return;

         if (png_ptr->mode & PNG_AFTER_IDAT)
            png_error(png_ptr, "Too many IDAT's found");
      }

      png_ptr->idat_size = png_ptr->push_length;
      png_ptr->mode |= PNG_HAVE_IDAT;
      png_ptr->process_mode = PNG_READ_IDAT_MODE;
      png_push_have_info(png_ptr, info_ptr);
      png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
      png_ptr->zstream.next_out = png_ptr->row_buf;
      return;
   }
   else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);
      png_ptr->process_mode = PNG_READ_DONE_MODE;
      png_push_have_end(png_ptr, info_ptr);
   }
#if defined(PNG_READ_gAMA_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_sBIT_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_cHRM_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_sRGB_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_iCCP_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_sPLT_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_tRNS_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_bKGD_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_pHYs_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_oFFs_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_sCAL_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_tIME_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_tEXt_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
   {
      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
   {
      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
   else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
   {
      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif
   else
   {
      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
   }

   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
}

void /* PRIVATE */
png_push_crc_skip(png_structp png_ptr, png_uint_32 skip)
{
   png_ptr->process_mode = PNG_SKIP_MODE;
   png_ptr->skip_length = skip;
}

void /* PRIVATE */
png_push_crc_finish(png_structp png_ptr)
{
   if (png_ptr->skip_length && png_ptr->save_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->skip_length < (png_uint_32)png_ptr->save_buffer_size)
         save_size = (png_size_t)png_ptr->skip_length;
      else
         save_size = png_ptr->save_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_ptr->skip_length -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (png_ptr->skip_length && png_ptr->current_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->skip_length < (png_uint_32)png_ptr->current_buffer_size)
         save_size = (png_size_t)png_ptr->skip_length;
      else
         save_size = png_ptr->current_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_ptr->skip_length -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
   if (!png_ptr->skip_length)
   {
      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_crc_finish(png_ptr, 0);
      png_ptr->process_mode = PNG_READ_CHUNK_MODE;
   }
}

void /* PRIVATE */
png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
{
   png_bytep ptr;

   ptr = buffer;
   if (png_ptr->save_buffer_size)
   {
      png_size_t save_size;

      if (length < png_ptr->save_buffer_size)
         save_size = length;
      else
         save_size = png_ptr->save_buffer_size;

      png_memcpy(ptr, png_ptr->save_buffer_ptr, save_size);
      length -= save_size;
      ptr += save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (length && png_ptr->current_buffer_size)
   {
      png_size_t save_size;

      if (length < png_ptr->current_buffer_size)
         save_size = length;
      else
         save_size = png_ptr->current_buffer_size;

      png_memcpy(ptr, png_ptr->current_buffer_ptr, save_size);
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
}

void /* PRIVATE */
png_push_save_buffer(png_structp png_ptr)
{
   if (png_ptr->save_buffer_size)
   {
      if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)
      {
         png_size_t i,istop;
         png_bytep sp;
         png_bytep dp;

         istop = png_ptr->save_buffer_size;
         for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;
            i < istop; i++, sp++, dp++)
         {
            *dp = *sp;
         }
      }
   }
   if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
      png_ptr->save_buffer_max)
   {
      png_size_t new_max;
      png_bytep old_buffer;

      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
      old_buffer = png_ptr->save_buffer;
      png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr,
         (png_uint_32)new_max);
      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);
      png_free(png_ptr, old_buffer);
      png_ptr->save_buffer_max = new_max;
   }
   if (png_ptr->current_buffer_size)
   {
      png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,
         png_ptr->current_buffer_ptr, png_ptr->current_buffer_size);
      png_ptr->save_buffer_size += png_ptr->current_buffer_size;
      png_ptr->current_buffer_size = 0;
   }
   png_ptr->save_buffer_ptr = png_ptr->save_buffer;
   png_ptr->buffer_size = 0;
}

void /* PRIVATE */
png_push_restore_buffer(png_structp png_ptr, png_bytep buffer,
   png_size_t buffer_length)
{
   png_ptr->current_buffer = buffer;
   png_ptr->current_buffer_size = buffer_length;
   png_ptr->buffer_size = buffer_length + png_ptr->save_buffer_size;
   png_ptr->current_buffer_ptr = png_ptr->current_buffer;
}

void /* PRIVATE */
png_push_read_IDAT(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IDAT;
#endif
   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
   {
      png_byte chunk_length[4];

      if (png_ptr->buffer_size < 8)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_fill_buffer(png_ptr, chunk_length, 4);
      png_ptr->push_length = png_get_uint_32(chunk_length);

      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;

      if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
      {
         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
         if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
            png_error(png_ptr, "Not enough compressed data");
         return;
      }

      png_ptr->idat_size = png_ptr->push_length;
   }
   if (png_ptr->idat_size && png_ptr->save_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)
      {
         save_size = (png_size_t)png_ptr->idat_size;
         /* check for overflow */
         if((png_uint_32)save_size != png_ptr->idat_size)
            png_error(png_ptr, "save_size overflowed in pngpread");
      }
      else
         save_size = png_ptr->save_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);
      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_ptr->idat_size -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (png_ptr->idat_size && png_ptr->current_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->idat_size < (png_uint_32)png_ptr->current_buffer_size)
      {
         save_size = (png_size_t)png_ptr->idat_size;
         /* check for overflow */
         if((png_uint_32)save_size != png_ptr->idat_size)
            png_error(png_ptr, "save_size overflowed in pngpread");
      }
      else
         save_size = png_ptr->current_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);
      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_ptr->idat_size -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
   if (!png_ptr->idat_size)
   {
      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_crc_finish(png_ptr, 0);
      png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
   }
}

void /* PRIVATE */
png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
   png_size_t buffer_length)
{
   int ret;

   if ((png_ptr->flags & PNG_FLAG_ZLIB_FINISHED) && buffer_length)
      png_error(png_ptr, "Extra compression data");

   png_ptr->zstream.next_in = buffer;
   png_ptr->zstream.avail_in = (uInt)buffer_length;
   for(;;)
   {
      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
      if (ret != Z_OK)
      {
         if (ret == Z_STREAM_END)
         {
            if (png_ptr->zstream.avail_in)
               png_error(png_ptr, "Extra compressed data");
            if (!(png_ptr->zstream.avail_out))
            {
               png_push_process_row(png_ptr);
            }

            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }
         else if (ret == Z_BUF_ERROR)
            break;
         else
            png_error(png_ptr, "Decompression Error");
      }
      if (!(png_ptr->zstream.avail_out))
      {
         png_push_process_row(png_ptr);
         png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
         png_ptr->zstream.next_out = png_ptr->row_buf;
      }
      else
         break;
   }
}

void /* PRIVATE */
png_push_process_row(png_structp png_ptr)
{
   png_ptr->row_info.color_type = png_ptr->color_type;
   png_ptr->row_info.width = png_ptr->iwidth;
   png_ptr->row_info.channels = png_ptr->channels;
   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;

   png_ptr->row_info.rowbytes = ((png_ptr->row_info.width *
      (png_uint_32)png_ptr->row_info.pixel_depth + 7) >> 3);

   png_read_filter_row(png_ptr, &(png_ptr->row_info),
      png_ptr->row_buf + 1, png_ptr->prev_row + 1,
      (int)(png_ptr->row_buf[0]));

   png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
      png_ptr->rowbytes + 1);

   if (png_ptr->transformations)
      png_do_read_transformations(png_ptr);

#if defined(PNG_READ_INTERLACING_SUPPORTED)
   /* blow up interlaced rows to full size */
   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
   {
      if (png_ptr->pass < 6)
/*       old interface (pre-1.0.9):
         png_do_read_interlace(&(png_ptr->row_info),
            png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
 */
         png_do_read_interlace(png_ptr);

    switch (png_ptr->pass)
    {
         case 0:
         {
            int i;
            for (i = 0; i < 8 && png_ptr->pass == 0; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr); /* updates png_ptr->pass */
            }
            if (png_ptr->pass == 2) /* pass 1 might be empty */
            {
               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }
	    if (png_ptr->pass == 4 && png_ptr->height <= 4)
	    {
	        for (i = 0; i < 2 && png_ptr->pass == 4; i++)
                {
                   png_push_have_row(png_ptr, NULL);
                   png_read_push_finish_row(png_ptr);
                }
            }
            if (png_ptr->pass == 6 && png_ptr->height <= 4)
            {
                png_push_have_row(png_ptr, NULL);
                png_read_push_finish_row(png_ptr);
            }
            break;
         }
         case 1:
         {
            int i;
            for (i = 0; i < 8 && png_ptr->pass == 1; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }
            if (png_ptr->pass == 2) /* skip top 4 generated rows */
            {
               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }
            break;
         }
         case 2:
         {
            int i;
            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }
            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }
            if (png_ptr->pass == 4) /* pass 3 might be empty */
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }
            break;
         }
         case 3:
         {
            int i;
            for (i = 0; i < 4 && png_ptr->pass == 3; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }
            if (png_ptr->pass == 4) /* skip top two generated rows */
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }
            break;
         }
         case 4:
         {
            int i;
            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }
            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }
            if (png_ptr->pass == 6) /* pass 5 might be empty */
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }
            break;
         }
         case 5:
         {
            int i;
            for (i = 0; i < 2 && png_ptr->pass == 5; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }
            if (png_ptr->pass == 6) /* skip top generated row */
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }
            break;
         }
         case 6:
         {
            png_push_have_row(png_ptr, png_ptr->row_buf + 1);
            png_read_push_finish_row(png_ptr);
            if (png_ptr->pass != 6)
               break;
            png_push_have_row(png_ptr, NULL);
            png_read_push_finish_row(png_ptr);
         }
      }
   }
   else
#endif
   {
      png_push_have_row(png_ptr, png_ptr->row_buf + 1);
      png_read_push_finish_row(png_ptr);
   }
}

void /* PRIVATE */
png_read_push_finish_row(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* start of interlace block */
   const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};

   /* offset to next interlace block */
   const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};

   /* start of interlace block in the y direction */
   const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};

   /* offset to next interlace block in the y direction */
   const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};

   /* Width of interlace block.  This is not currently used - if you need
    * it, uncomment it here and in png.h
   const int FARDATA png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
   */

   /* Height of interlace block.  This is not currently used - if you need
    * it, uncomment it here and in png.h
   const int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
   */
#endif

   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      png_memset_check(png_ptr, png_ptr->prev_row, 0,
         png_ptr->rowbytes + 1);
      do
      {
         png_ptr->pass++;
         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||
             (png_ptr->pass == 3 && png_ptr->width < 3) ||
             (png_ptr->pass == 5 && png_ptr->width < 2))
           png_ptr->pass++;

         if (png_ptr->pass >= 7)
            break;

         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];

         png_ptr->irowbytes = ((png_ptr->iwidth *
            png_ptr->pixel_depth + 7) >> 3) + 1;

         if (png_ptr->transformations & PNG_INTERLACE)
            break;

         png_ptr->num_rows = (png_ptr->height +
            png_pass_yinc[png_ptr->pass] - 1 -
            png_pass_ystart[png_ptr->pass]) /
            png_pass_yinc[png_ptr->pass];

      } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);
   }
}

#if defined(PNG_READ_tEXt_SUPPORTED)
void /* PRIVATE */
png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
      {
         png_error(png_ptr, "Out of place tEXt");
         /* to quiet some compiler warnings */
         if(info_ptr == NULL) return;
      }

#ifdef PNG_MAX_MALLOC_64K
   png_ptr->skip_length = 0;  /* This may not be necessary */

   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
   {
      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
      png_ptr->skip_length = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
         (png_uint_32)(length+1));
   png_ptr->current_text[length] = '\0';
   png_ptr->current_text_ptr = png_ptr->current_text;
   png_ptr->current_text_size = (png_size_t)length;
   png_ptr->current_text_left = (png_size_t)length;
   png_ptr->process_mode = PNG_READ_tEXt_MODE;
}

void /* PRIVATE */
png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->buffer_size && png_ptr->current_text_left)
   {
      png_size_t text_size;

      if (png_ptr->buffer_size < png_ptr->current_text_left)
         text_size = png_ptr->buffer_size;
      else
         text_size = png_ptr->current_text_left;
      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
      png_ptr->current_text_left -= text_size;
      png_ptr->current_text_ptr += text_size;
   }
   if (!(png_ptr->current_text_left))
   {
      png_textp text_ptr;
      png_charp text;
      png_charp key;

      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_crc_finish(png_ptr);

#if defined(PNG_MAX_MALLOC_64K)
      if (png_ptr->skip_length)
         return;
#endif

      key = png_ptr->current_text;
      png_ptr->current_text = 0;

      for (text = key; *text; text++)
         /* empty loop */ ;

      if (text != key + png_ptr->current_text_size)
         text++;

      text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
      text_ptr->key = key;
#ifdef PNG_iTXt_SUPPORTED
      text_ptr->lang = (char *)NULL;
      text_ptr->lang_key = (char *)NULL;
#endif
      text_ptr->text = text;

      png_set_text(png_ptr, info_ptr, text_ptr, 1);

      png_free(png_ptr, key);
      png_free(png_ptr, text_ptr);
   }
}
#endif

#if defined(PNG_READ_zTXt_SUPPORTED)
void /* PRIVATE */
png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
      {
         png_error(png_ptr, "Out of place zTXt");
         /* to quiet some compiler warnings */
         if(info_ptr == NULL) return;
      }

#ifdef PNG_MAX_MALLOC_64K
   /* We can't handle zTXt chunks > 64K, since we don't have enough space
    * to be able to store the uncompressed data.  Actually, the threshold
    * is probably around 32K, but it isn't as definite as 64K is.
    */
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "zTXt chunk too large to fit in memory");
      png_push_crc_skip(png_ptr, length);
      return;
   }
#endif

   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
       (png_uint_32)(length+1));
   png_ptr->current_text[length] = '\0';
   png_ptr->current_text_ptr = png_ptr->current_text;
   png_ptr->current_text_size = (png_size_t)length;
   png_ptr->current_text_left = (png_size_t)length;
   png_ptr->process_mode = PNG_READ_zTXt_MODE;
}

void /* PRIVATE */
png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->buffer_size && png_ptr->current_text_left)
   {
      png_size_t text_size;

      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)
         text_size = png_ptr->buffer_size;
      else
         text_size = png_ptr->current_text_left;
      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
      png_ptr->current_text_left -= text_size;
      png_ptr->current_text_ptr += text_size;
   }
   if (!(png_ptr->current_text_left))
   {
      png_textp text_ptr;
      png_charp text;
      png_charp key;
      int ret;
      png_size_t text_size, key_size;

      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_crc_finish(png_ptr);

      key = png_ptr->current_text;
      png_ptr->current_text = 0;

      for (text = key; *text; text++)
         /* empty loop */ ;

      /* zTXt can't have zero text */
      if (text == key + png_ptr->current_text_size)
      {
         png_free(png_ptr, key);
         return;
      }

      text++;

      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* check compression byte */
      {
         png_free(png_ptr, key);
         return;
      }

      text++;

      png_ptr->zstream.next_in = (png_bytep )text;
      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -
         (text - key));
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

      key_size = text - key;
      text_size = 0;
      text = NULL;
      ret = Z_STREAM_END;

      while (png_ptr->zstream.avail_in)
      {
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END)
         {
            inflateReset(&png_ptr->zstream);
            png_ptr->zstream.avail_in = 0;
            png_free(png_ptr, key);
            png_free(png_ptr, text);
            return;
         }
         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)
         {
            if (text == NULL)
            {
               text = (png_charp)png_malloc(png_ptr,
                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
                     + key_size + 1));
               png_memcpy(text + key_size, png_ptr->zbuf,
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
               png_memcpy(text, key, key_size);
               text_size = key_size + png_ptr->zbuf_size -
                  png_ptr->zstream.avail_out;
               *(text + text_size) = '\0';
            }
            else
            {
               png_charp tmp;

               tmp = text;
               text = (png_charp)png_malloc(png_ptr, text_size +
                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
                   + 1));
               png_memcpy(text, tmp, text_size);
               png_free(png_ptr, tmp);
               png_memcpy(text + text_size, png_ptr->zbuf,
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               *(text + text_size) = '\0';
            }
            if (ret != Z_STREAM_END)
            {
               png_ptr->zstream.next_out = png_ptr->zbuf;
               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            }
         }
         else
         {
            break;
         }

         if (ret == Z_STREAM_END)
            break;
      }

      inflateReset(&png_ptr->zstream);
      png_ptr->zstream.avail_in = 0;

      if (ret != Z_STREAM_END)
      {
         png_free(png_ptr, key);
         png_free(png_ptr, text);
         return;
      }

      png_free(png_ptr, key);
      key = text;
      text += key_size;

      text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;
      text_ptr->key = key;
#ifdef PNG_iTXt_SUPPORTED
      text_ptr->lang = (char *)NULL;
      text_ptr->lang_key = (char *)NULL;
#endif
      text_ptr->text = text;

      png_set_text(png_ptr, info_ptr, text_ptr, 1);

      png_free(png_ptr, key);
      png_free(png_ptr, text_ptr);
   }
}
#endif

#if defined(PNG_READ_iTXt_SUPPORTED)
void /* PRIVATE */
png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
      {
         png_error(png_ptr, "Out of place iTXt");
         /* to quiet some compiler warnings */
         if(info_ptr == NULL) return;
      }

#ifdef PNG_MAX_MALLOC_64K
   png_ptr->skip_length = 0;  /* This may not be necessary */

   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
   {
      png_warning(png_ptr, "iTXt chunk too large to fit in memory");
      png_ptr->skip_length = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
         (png_uint_32)(length+1));
   png_ptr->current_text[length] = '\0';
   png_ptr->current_text_ptr = png_ptr->current_text;
   png_ptr->current_text_size = (png_size_t)length;
   png_ptr->current_text_left = (png_size_t)length;
   png_ptr->process_mode = PNG_READ_iTXt_MODE;
}

void /* PRIVATE */
png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)
{

   if (png_ptr->buffer_size && png_ptr->current_text_left)
   {
      png_size_t text_size;

      if (png_ptr->buffer_size < png_ptr->current_text_left)
         text_size = png_ptr->buffer_size;
      else
         text_size = png_ptr->current_text_left;
      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
      png_ptr->current_text_left -= text_size;
      png_ptr->current_text_ptr += text_size;
   }
   if (!(png_ptr->current_text_left))
   {
      png_textp text_ptr;
      png_charp key;
      int comp_flag;
      png_charp lang;
      png_charp lang_key;
      png_charp text;

      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_crc_finish(png_ptr);

#if defined(PNG_MAX_MALLOC_64K)
      if (png_ptr->skip_length)
         return;
#endif

      key = png_ptr->current_text;
      png_ptr->current_text = 0;

      for (lang = key; *lang; lang++)
         /* empty loop */ ;

      if (lang != key + png_ptr->current_text_size)
         lang++;

      comp_flag = *lang++;
      lang++;     /* skip comp_type, always zero */

      for (lang_key = lang; *lang_key; lang_key++)
         /* empty loop */ ;
      lang_key++;        /* skip NUL separator */

      for (text = lang_key; *text; text++)
         /* empty loop */ ;

      if (text != key + png_ptr->current_text_size)
         text++;

      text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
      text_ptr->compression = comp_flag + 2;
      text_ptr->key = key;
      text_ptr->lang = lang;
      text_ptr->lang_key = lang_key;
      text_ptr->text = text;
      text_ptr->text_length = 0;
      text_ptr->itxt_length = png_strlen(text);

      png_set_text(png_ptr, info_ptr, text_ptr, 1);

      png_free(png_ptr, text_ptr);
   }
}
#endif

/* This function is called when we haven't found a handler for this
 * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk
 * name or a critical chunk), the chunk is (currently) silently ignored.
 */
void /* PRIVATE */
png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   png_uint_32 skip=0;
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

   if (!(png_ptr->chunk_name[0] & 0x20))
   {
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
      if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
           HANDLE_CHUNK_ALWAYS
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
           && png_ptr->read_user_chunk_fn == NULL
#endif
         )
#endif
         png_chunk_error(png_ptr, "unknown critical chunk");

      /* to quiet compiler warnings about unused info_ptr */
      if (info_ptr == NULL)
         return;
   }

#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
   {
       png_unknown_chunk chunk;

#ifdef PNG_MAX_MALLOC_64K
       if (length > (png_uint_32)65535L)
       {
           png_warning(png_ptr, "unknown chunk too large to fit in memory");
           skip = length - (png_uint_32)65535L;
           length = (png_uint_32)65535L;
       }
#endif

       png_strcpy((png_charp)chunk.name, (png_charp)png_ptr->chunk_name);
       chunk.data = (png_bytep)png_malloc(png_ptr, length);
       png_crc_read(png_ptr, chunk.data, length);
       chunk.size = length;
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
       if(png_ptr->read_user_chunk_fn != NULL)
       {
          /* callback to user unknown chunk handler */
          if ((*(png_ptr->read_user_chunk_fn)) (png_ptr, &chunk) <= 0)
          {
             if (!(png_ptr->chunk_name[0] & 0x20))
                if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                     HANDLE_CHUNK_ALWAYS)
                   png_chunk_error(png_ptr, "unknown critical chunk");
          }
             png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
       }
       else
#endif
          png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
       png_free(png_ptr, chunk.data);
   }
   else
#endif
      skip=length;
   png_push_crc_skip(png_ptr, skip);
}

void /* PRIVATE */
png_push_have_info(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->info_fn != NULL)
      (*(png_ptr->info_fn))(png_ptr, info_ptr);
}

void /* PRIVATE */
png_push_have_end(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->end_fn != NULL)
      (*(png_ptr->end_fn))(png_ptr, info_ptr);
}

void /* PRIVATE */
png_push_have_row(png_structp png_ptr, png_bytep row)
{
   if (png_ptr->row_fn != NULL)
      (*(png_ptr->row_fn))(png_ptr, row, png_ptr->row_number,
         (int)png_ptr->pass);
}

void PNGAPI
png_progressive_combine_row (png_structp png_ptr,
   png_bytep old_row, png_bytep new_row)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   const int FARDATA png_pass_dsp_mask[7] =
      {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
#endif
   if (new_row != NULL)    /* new_row must == png_ptr->row_buf here. */
      png_combine_row(png_ptr, old_row, png_pass_dsp_mask[png_ptr->pass]);
}

void PNGAPI
png_set_progressive_read_fn(png_structp png_ptr, png_voidp progressive_ptr,
   png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
   png_progressive_end_ptr end_fn)
{
   png_ptr->info_fn = info_fn;
   png_ptr->row_fn = row_fn;
   png_ptr->end_fn = end_fn;

   png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
}

png_voidp PNGAPI
png_get_progressive_ptr(png_structp png_ptr)
{
   return png_ptr->io_ptr;
}

#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngrtran.c ===
/* pngrtran.c - transforms the data in a row for PNG readers
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file contains functions optionally called by an application
 * in order to tell libpng how to handle data when reading a PNG.
 * Transformations that are used in both reading and writing are
 * in pngtrans.c.
 */

#define PNG_INTERNAL
#include "png.h"

/* Set the action on getting a CRC error for an ancillary or critical chunk. */
void PNGAPI
png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
{
   png_debug(1, "in png_set_crc_action\n");
   /* Tell libpng how we react to CRC errors in critical chunks */
   switch (crit_action)
   {
      case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
         break;
      case PNG_CRC_WARN_USE:                               /* warn/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
         break;
      case PNG_CRC_QUIET_USE:                             /* quiet/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
                           PNG_FLAG_CRC_CRITICAL_IGNORE;
         break;
      case PNG_CRC_WARN_DISCARD:    /* not a valid action for critical data */
         png_warning(png_ptr, "Can't discard critical data on CRC error.");
      case PNG_CRC_ERROR_QUIT:                                /* error/quit */
      case PNG_CRC_DEFAULT:
      default:
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         break;
   }

   switch (ancil_action)
   {
      case PNG_CRC_NO_CHANGE:                       /* leave setting as is */
         break;
      case PNG_CRC_WARN_USE:                              /* warn/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
         break;
      case PNG_CRC_QUIET_USE:                            /* quiet/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
         break;
      case PNG_CRC_ERROR_QUIT:                               /* error/quit */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
         break;
      case PNG_CRC_WARN_DISCARD:                      /* warn/discard data */
      case PNG_CRC_DEFAULT:
      default:
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         break;
   }
}

#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
    defined(PNG_FLOATING_POINT_SUPPORTED)
/* handle alpha and tRNS via a background color */
void PNGAPI
png_set_background(png_structp png_ptr,
   png_color_16p background_color, int background_gamma_code,
   int need_expand, double background_gamma)
{
   png_debug(1, "in png_set_background\n");
   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
   {
      png_warning(png_ptr, "Application must supply a known background gamma");
      return;
   }

   png_ptr->transformations |= PNG_BACKGROUND;
   png_memcpy(&(png_ptr->background), background_color, sizeof(png_color_16));
   png_ptr->background_gamma = (float)background_gamma;
   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
   png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);

   /* Note:  if need_expand is set and color_type is either RGB or RGB_ALPHA
    * (in which case need_expand is superfluous anyway), the background color
    * might actually be gray yet not be flagged as such. This is not a problem
    * for the current code, which uses PNG_BACKGROUND_IS_GRAY only to
    * decide when to do the png_do_gray_to_rgb() transformation.
    */
   if ((need_expand && !(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) ||
       (!need_expand && background_color->red == background_color->green &&
        background_color->red == background_color->blue))
      png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
}
#endif

#if defined(PNG_READ_16_TO_8_SUPPORTED)
/* strip 16 bit depth files to 8 bit depth */
void PNGAPI
png_set_strip_16(png_structp png_ptr)
{
   png_debug(1, "in png_set_strip_16\n");
   png_ptr->transformations |= PNG_16_TO_8;
}
#endif

#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
void PNGAPI
png_set_strip_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_strip_alpha\n");
   png_ptr->transformations |= PNG_STRIP_ALPHA;
}
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
/* Dither file to 8 bit.  Supply a palette, the current number
 * of elements in the palette, the maximum number of elements
 * allowed, and a histogram if possible.  If the current number
 * of colors is greater then the maximum number, the palette will be
 * modified to fit in the maximum number.  "full_dither" indicates
 * whether we need a dithering cube set up for RGB images, or if we
 * simply are reducing the number of colors in a paletted image.
 */

typedef struct png_dsort_struct
{
   struct png_dsort_struct FAR * next;
   png_byte left;
   png_byte right;
} png_dsort;
typedef png_dsort FAR *       png_dsortp;
typedef png_dsort FAR * FAR * png_dsortpp;

void PNGAPI
png_set_dither(png_structp png_ptr, png_colorp palette,
   int num_palette, int maximum_colors, png_uint_16p histogram,
   int full_dither)
{
   png_debug(1, "in png_set_dither\n");
   png_ptr->transformations |= PNG_DITHER;

   if (!full_dither)
   {
      int i;

      png_ptr->dither_index = (png_bytep)png_malloc(png_ptr,
         (png_uint_32)(num_palette * sizeof (png_byte)));
      for (i = 0; i < num_palette; i++)
         png_ptr->dither_index[i] = (png_byte)i;
   }

   if (num_palette > maximum_colors)
   {
      if (histogram != NULL)
      {
         /* This is easy enough, just throw out the least used colors.
            Perhaps not the best solution, but good enough. */

         int i;
         png_bytep sort;

         /* initialize an array to sort colors */
         sort = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_palette
            * sizeof (png_byte)));

         /* initialize the sort array */
         for (i = 0; i < num_palette; i++)
            sort[i] = (png_byte)i;

         /* Find the least used palette entries by starting a
            bubble sort, and running it until we have sorted
            out enough colors.  Note that we don't care about
            sorting all the colors, just finding which are
            least used. */

         for (i = num_palette - 1; i >= maximum_colors; i--)
         {
            int done; /* to stop early if the list is pre-sorted */
            int j;

            done = 1;
            for (j = 0; j < i; j++)
            {
               if (histogram[sort[j]] < histogram[sort[j + 1]])
               {
                  png_byte t;

                  t = sort[j];
                  sort[j] = sort[j + 1];
                  sort[j + 1] = t;
                  done = 0;
               }
            }
            if (done)
               break;
         }

         /* swap the palette around, and set up a table, if necessary */
         if (full_dither)
         {
            int j = num_palette;

            /* put all the useful colors within the max, but don't
               move the others */
            for (i = 0; i < maximum_colors; i++)
            {
               if ((int)sort[i] >= maximum_colors)
               {
                  do
                     j--;
                  while ((int)sort[j] >= maximum_colors);
                  palette[i] = palette[j];
               }
            }
         }
         else
         {
            int j = num_palette;

            /* move all the used colors inside the max limit, and
               develop a translation table */
            for (i = 0; i < maximum_colors; i++)
            {
               /* only move the colors we need to */
               if ((int)sort[i] >= maximum_colors)
               {
                  png_color tmp_color;

                  do
                     j--;
                  while ((int)sort[j] >= maximum_colors);

                  tmp_color = palette[j];
                  palette[j] = palette[i];
                  palette[i] = tmp_color;
                  /* indicate where the color went */
                  png_ptr->dither_index[j] = (png_byte)i;
                  png_ptr->dither_index[i] = (png_byte)j;
               }
            }

            /* find closest color for those colors we are not using */
            for (i = 0; i < num_palette; i++)
            {
               if ((int)png_ptr->dither_index[i] >= maximum_colors)
               {
                  int min_d, k, min_k, d_index;

                  /* find the closest color to one we threw out */
                  d_index = png_ptr->dither_index[i];
                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
                  for (k = 1, min_k = 0; k < maximum_colors; k++)
                  {
                     int d;

                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);

                     if (d < min_d)
                     {
                        min_d = d;
                        min_k = k;
                     }
                  }
                  /* point to closest color */
                  png_ptr->dither_index[i] = (png_byte)min_k;
               }
            }
         }
         png_free(png_ptr, sort);
      }
      else
      {
         /* This is much harder to do simply (and quickly).  Perhaps
            we need to go through a median cut routine, but those
            don't always behave themselves with only a few colors
            as input.  So we will just find the closest two colors,
            and throw out one of them (chosen somewhat randomly).
            [We don't understand this at all, so if someone wants to
             work on improving it, be our guest - AED, GRP]
            */
         int i;
         int max_d;
         int num_new_palette;
         png_dsortpp hash;
         png_bytep index_to_palette;
            /* where the original index currently is in the palette */
         png_bytep palette_to_index;
            /* which original index points to this palette color */

         /* initialize palette index arrays */
         index_to_palette = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(num_palette * sizeof (png_byte)));
         palette_to_index = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(num_palette * sizeof (png_byte)));

         /* initialize the sort array */
         for (i = 0; i < num_palette; i++)
         {
            index_to_palette[i] = (png_byte)i;
            palette_to_index[i] = (png_byte)i;
         }

         hash = (png_dsortpp)png_malloc(png_ptr, (png_uint_32)(769 *
            sizeof (png_dsortp)));
         for (i = 0; i < 769; i++)
            hash[i] = NULL;
/*         png_memset(hash, 0, 769 * sizeof (png_dsortp)); */

         num_new_palette = num_palette;

         /* initial wild guess at how far apart the farthest pixel
            pair we will be eliminating will be.  Larger
            numbers mean more areas will be allocated, Smaller
            numbers run the risk of not saving enough data, and
            having to do this all over again.

            I have not done extensive checking on this number.
            */
         max_d = 96;

         while (num_new_palette > maximum_colors)
         {
            for (i = 0; i < num_new_palette - 1; i++)
            {
               int j;

               for (j = i + 1; j < num_new_palette; j++)
               {
                  int d;

                  d = PNG_COLOR_DIST(palette[i], palette[j]);

                  if (d <= max_d)
                  {
                     png_dsortp t;

                     t = (png_dsortp)png_malloc(png_ptr, (png_uint_32)(sizeof
                         (png_dsort)));
                     t->next = hash[d];
                     t->left = (png_byte)i;
                     t->right = (png_byte)j;
                     hash[d] = t;
                  }
               }
            }

            for (i = 0; i <= max_d; i++)
            {
               if (hash[i] != NULL)
               {
                  png_dsortp p;

                  for (p = hash[i]; p; p = p->next)
                  {
                     if ((int)index_to_palette[p->left] < num_new_palette &&
                        (int)index_to_palette[p->right] < num_new_palette)
                     {
                        int j, next_j;

                        if (num_new_palette & 0x01)
                        {
                           j = p->left;
                           next_j = p->right;
                        }
                        else
                        {
                           j = p->right;
                           next_j = p->left;
                        }

                        num_new_palette--;
                        palette[index_to_palette[j]] = palette[num_new_palette];
                        if (!full_dither)
                        {
                           int k;

                           for (k = 0; k < num_palette; k++)
                           {
                              if (png_ptr->dither_index[k] ==
                                 index_to_palette[j])
                                 png_ptr->dither_index[k] =
                                    index_to_palette[next_j];
                              if ((int)png_ptr->dither_index[k] ==
                                 num_new_palette)
                                 png_ptr->dither_index[k] =
                                    index_to_palette[j];
                           }
                        }

                        index_to_palette[palette_to_index[num_new_palette]] =
                           index_to_palette[j];
                        palette_to_index[index_to_palette[j]] =
                           palette_to_index[num_new_palette];

                        index_to_palette[j] = (png_byte)num_new_palette;
                        palette_to_index[num_new_palette] = (png_byte)j;
                     }
                     if (num_new_palette <= maximum_colors)
                        break;
                  }
                  if (num_new_palette <= maximum_colors)
                     break;
               }
            }

            for (i = 0; i < 769; i++)
            {
               if (hash[i] != NULL)
               {
                  png_dsortp p = hash[i];
                  while (p)
                  {
                     png_dsortp t;

                     t = p->next;
                     png_free(png_ptr, p);
                     p = t;
                  }
               }
               hash[i] = 0;
            }
            max_d += 96;
         }
         png_free(png_ptr, hash);
         png_free(png_ptr, palette_to_index);
         png_free(png_ptr, index_to_palette);
      }
      num_palette = maximum_colors;
   }
   if (png_ptr->palette == NULL)
   {
      png_ptr->palette = palette;
   }
   png_ptr->num_palette = (png_uint_16)num_palette;

   if (full_dither)
   {
      int i;
      png_bytep distance;
      int total_bits = PNG_DITHER_RED_BITS + PNG_DITHER_GREEN_BITS +
         PNG_DITHER_BLUE_BITS;
      int num_red = (1 << PNG_DITHER_RED_BITS);
      int num_green = (1 << PNG_DITHER_GREEN_BITS);
      int num_blue = (1 << PNG_DITHER_BLUE_BITS);
      png_size_t num_entries = ((png_size_t)1 << total_bits);

      png_ptr->palette_lookup = (png_bytep )png_malloc(png_ptr,
         (png_uint_32)(num_entries * sizeof (png_byte)));

      png_memset(png_ptr->palette_lookup, 0, num_entries * sizeof (png_byte));

      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
         sizeof(png_byte)));

      png_memset(distance, 0xff, num_entries * sizeof(png_byte));

      for (i = 0; i < num_palette; i++)
      {
         int ir, ig, ib;
         int r = (palette[i].red >> (8 - PNG_DITHER_RED_BITS));
         int g = (palette[i].green >> (8 - PNG_DITHER_GREEN_BITS));
         int b = (palette[i].blue >> (8 - PNG_DITHER_BLUE_BITS));

         for (ir = 0; ir < num_red; ir++)
         {
            int dr = abs(ir - r);
            int index_r = (ir << (PNG_DITHER_BLUE_BITS + PNG_DITHER_GREEN_BITS));

            for (ig = 0; ig < num_green; ig++)
            {
               int dg = abs(ig - g);
               int dt = dr + dg;
               int dm = ((dr > dg) ? dr : dg);
               int index_g = index_r | (ig << PNG_DITHER_BLUE_BITS);

               for (ib = 0; ib < num_blue; ib++)
               {
                  int d_index = index_g | ib;
                  int db = abs(ib - b);
                  int dmax = ((dm > db) ? dm : db);
                  int d = dmax + dt + db;

                  if (d < (int)distance[d_index])
                  {
                     distance[d_index] = (png_byte)d;
                     png_ptr->palette_lookup[d_index] = (png_byte)i;
                  }
               }
            }
         }
      }

      png_free(png_ptr, distance);
   }
}
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
/* Transform the image from the file_gamma to the screen_gamma.  We
 * only do transformations on images where the file_gamma and screen_gamma
 * are not close reciprocals, otherwise it slows things down slightly, and
 * also needlessly introduces small errors.
 */
void PNGAPI
png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
{
   png_debug(1, "in png_set_gamma\n");
   if (fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD)
      png_ptr->transformations |= PNG_GAMMA;
   png_ptr->gamma = (float)file_gamma;
   png_ptr->screen_gamma = (float)scrn_gamma;
}
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
/* Expand paletted images to RGB, expand grayscale images of
 * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
 * to alpha channels.
 */
void PNGAPI
png_set_expand(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand\n");
   png_ptr->transformations |= PNG_EXPAND;
}

/* GRR 19990627:  the following three functions currently are identical
 *  to png_set_expand().  However, it is entirely reasonable that someone
 *  might wish to expand an indexed image to RGB but *not* expand a single,
 *  fully transparent palette entry to a full alpha channel--perhaps instead
 *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
 *  the transparent color with a particular RGB value, or drop tRNS entirely.
 *  IOW, a future version of the library may make the transformations flag
 *  a bit more fine-grained, with separate bits for each of these three
 *  functions.
 *
 *  More to the point, these functions make it obvious what libpng will be
 *  doing, whereas "expand" can (and does) mean any number of things.
 */

/* Expand paletted images to RGB. */
void PNGAPI
png_set_palette_to_rgb(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand\n");
   png_ptr->transformations |= PNG_EXPAND;
}

/* Expand grayscale images of less than 8-bit depth to 8 bits. */
void PNGAPI
png_set_gray_1_2_4_to_8(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand\n");
   png_ptr->transformations |= PNG_EXPAND;
}

/* Expand tRNS chunks to alpha channels. */
void PNGAPI
png_set_tRNS_to_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand\n");
   png_ptr->transformations |= PNG_EXPAND;
}
#endif /* defined(PNG_READ_EXPAND_SUPPORTED) */

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
void PNGAPI
png_set_gray_to_rgb(png_structp png_ptr)
{
   png_debug(1, "in png_set_gray_to_rgb\n");
   png_ptr->transformations |= PNG_GRAY_TO_RGB;
}
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
#if defined(PNG_FLOATING_POINT_SUPPORTED)
/* Convert a RGB image to a grayscale of the same width.  This allows us,
 * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
 */

void PNGAPI
png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
   double green)
{
      int red_fixed = (int)((float)red*100000.0 + 0.5);
      int green_fixed = (int)((float)green*100000.0 + 0.5);
      png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
}
#endif

void PNGAPI
png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
   png_fixed_point red, png_fixed_point green)
{
   png_debug(1, "in png_set_rgb_to_gray\n");
   switch(error_action)
   {
      case 1: png_ptr->transformations |= PNG_RGB_TO_GRAY;
              break;
      case 2: png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
              break;
      case 3: png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
   }
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#if defined(PNG_READ_EXPAND_SUPPORTED)
      png_ptr->transformations |= PNG_EXPAND;
#else
   {
      png_warning(png_ptr, "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED.");
      png_ptr->transformations &= ~PNG_RGB_TO_GRAY;
   }
#endif
   {
      png_uint_16 red_int, green_int;
      if(red < 0 || green < 0)
      {
         red_int   =  6968; /* .212671 * 32768 + .5 */
         green_int = 23434; /* .715160 * 32768 + .5 */
      }
      else if(red + green < 100000L)
      {
        red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
        green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
      }
      else
      {
         png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
         red_int   =  6968;
         green_int = 23434;
      }
      png_ptr->rgb_to_gray_red_coeff   = red_int;
      png_ptr->rgb_to_gray_green_coeff = green_int;
      png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(32768-red_int-green_int);
   }
}
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
void PNGAPI
png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
   read_user_transform_fn)
{
   png_debug(1, "in png_set_read_user_transform_fn\n");
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   png_ptr->transformations |= PNG_USER_TRANSFORM;
   png_ptr->read_user_transform_fn = read_user_transform_fn;
#endif
#ifdef PNG_LEGACY_SUPPORTED
   if(read_user_transform_fn)
      png_warning(png_ptr,
        "This version of libpng does not support user transforms");
#endif
}
#endif

/* Initialize everything needed for the read.  This includes modifying
 * the palette.
 */
void /* PRIVATE */
png_init_read_transformations(png_structp png_ptr)
{
   png_debug(1, "in png_init_read_transformations\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if(png_ptr != NULL)
#endif
  {
#if defined(PNG_READ_BACKGROUND_SUPPORTED) || defined(PNG_READ_SHIFT_SUPPORTED) \
 || defined(PNG_READ_GAMMA_SUPPORTED)
   int color_type = png_ptr->color_type;
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
       (png_ptr->transformations & PNG_EXPAND))
   {
      if (!(color_type & PNG_COLOR_MASK_COLOR))  /* i.e., GRAY or GRAY_ALPHA */
      {
         /* expand background chunk. */
         switch (png_ptr->bit_depth)
         {
            case 1:
               png_ptr->background.gray *= (png_uint_16)0xff;
               png_ptr->background.red = png_ptr->background.green =
               png_ptr->background.blue = png_ptr->background.gray;
               break;
            case 2:
               png_ptr->background.gray *= (png_uint_16)0x55;
               png_ptr->background.red = png_ptr->background.green =
               png_ptr->background.blue = png_ptr->background.gray;
               break;
            case 4:
               png_ptr->background.gray *= (png_uint_16)0x11;
               png_ptr->background.red = png_ptr->background.green =
               png_ptr->background.blue = png_ptr->background.gray;
               break;
            case 8:
            case 16:
               png_ptr->background.red = png_ptr->background.green =
               png_ptr->background.blue = png_ptr->background.gray;
               break;
         }
      }
      else if (color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_ptr->background.red   =
            png_ptr->palette[png_ptr->background.index].red;
         png_ptr->background.green =
            png_ptr->palette[png_ptr->background.index].green;
         png_ptr->background.blue  =
            png_ptr->palette[png_ptr->background.index].blue;

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
        if (png_ptr->transformations & PNG_INVERT_ALPHA)
        {
#if defined(PNG_READ_EXPAND_SUPPORTED)
           if (!(png_ptr->transformations & PNG_EXPAND))
#endif
           {
           /* invert the alpha channel (in tRNS) unless the pixels are
              going to be expanded, in which case leave it for later */
              int i,istop;
              istop=(int)png_ptr->num_trans;
              for (i=0; i<istop; i++)
                 png_ptr->trans[i] = (png_byte)(255 - png_ptr->trans[i]);
           }
        }
#endif

      }
   }
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   png_ptr->background_1 = png_ptr->background;
#endif
#if defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
   if (png_ptr->transformations & (PNG_GAMMA | PNG_RGB_TO_GRAY))
   {
      png_build_gamma_table(png_ptr);
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
      if (png_ptr->transformations & PNG_BACKGROUND)
      {
         if (color_type == PNG_COLOR_TYPE_PALETTE)
         {
            png_color back, back_1;
            png_colorp palette = png_ptr->palette;
            int num_palette = png_ptr->num_palette;
            int i;
            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
            {
               back.red = png_ptr->gamma_table[png_ptr->background.red];
               back.green = png_ptr->gamma_table[png_ptr->background.green];
               back.blue = png_ptr->gamma_table[png_ptr->background.blue];

               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
            }
            else
            {
               double g, gs;

               switch (png_ptr->background_gamma_type)
               {
                  case PNG_BACKGROUND_GAMMA_SCREEN:
                     g = (png_ptr->screen_gamma);
                     gs = 1.0;
                     break;
                  case PNG_BACKGROUND_GAMMA_FILE:
                     g = 1.0 / (png_ptr->gamma);
                     gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
                     break;
                  case PNG_BACKGROUND_GAMMA_UNIQUE:
                     g = 1.0 / (png_ptr->background_gamma);
                     gs = 1.0 / (png_ptr->background_gamma *
                                 png_ptr->screen_gamma);
                     break;
                  default:
                     g = 1.0;    /* back_1 */
                     gs = 1.0;   /* back */
               }

               if ( fabs(gs - 1.0) < PNG_GAMMA_THRESHOLD)
               {
                  back.red   = (png_byte)png_ptr->background.red;
                  back.green = (png_byte)png_ptr->background.green;
                  back.blue  = (png_byte)png_ptr->background.blue;
               }
               else
               {
                  back.red = (png_byte)(pow(
                     (double)png_ptr->background.red/255, gs) * 255.0 + .5);
                  back.green = (png_byte)(pow(
                     (double)png_ptr->background.green/255, gs) * 255.0 + .5);
                  back.blue = (png_byte)(pow(
                     (double)png_ptr->background.blue/255, gs) * 255.0 + .5);
               }

               back_1.red = (png_byte)(pow(
                  (double)png_ptr->background.red/255, g) * 255.0 + .5);
               back_1.green = (png_byte)(pow(
                  (double)png_ptr->background.green/255, g) * 255.0 + .5);
               back_1.blue = (png_byte)(pow(
                  (double)png_ptr->background.blue/255, g) * 255.0 + .5);
            }
            for (i = 0; i < num_palette; i++)
            {
               if (i < (int)png_ptr->num_trans && png_ptr->trans[i] != 0xff)
               {
                  if (png_ptr->trans[i] == 0)
                  {
                     palette[i] = back;
                  }
                  else /* if (png_ptr->trans[i] != 0xff) */
                  {
                     png_byte v, w;

                     v = png_ptr->gamma_to_1[palette[i].red];
                     png_composite(w, v, png_ptr->trans[i], back_1.red);
                     palette[i].red = png_ptr->gamma_from_1[w];

                     v = png_ptr->gamma_to_1[palette[i].green];
                     png_composite(w, v, png_ptr->trans[i], back_1.green);
                     palette[i].green = png_ptr->gamma_from_1[w];

                     v = png_ptr->gamma_to_1[palette[i].blue];
                     png_composite(w, v, png_ptr->trans[i], back_1.blue);
                     palette[i].blue = png_ptr->gamma_from_1[w];
                  }
               }
               else
               {
                  palette[i].red = png_ptr->gamma_table[palette[i].red];
                  palette[i].green = png_ptr->gamma_table[palette[i].green];
                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
               }
            }
         }
         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN)*/
         else
         /* color_type != PNG_COLOR_TYPE_PALETTE */
         {
            double m = (double)(((png_uint_32)1 << png_ptr->bit_depth) - 1);
            double g = 1.0;
            double gs = 1.0;

            switch (png_ptr->background_gamma_type)
            {
               case PNG_BACKGROUND_GAMMA_SCREEN:
                  g = (png_ptr->screen_gamma);
                  gs = 1.0;
                  break;
               case PNG_BACKGROUND_GAMMA_FILE:
                  g = 1.0 / (png_ptr->gamma);
                  gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
                  break;
               case PNG_BACKGROUND_GAMMA_UNIQUE:
                  g = 1.0 / (png_ptr->background_gamma);
                  gs = 1.0 / (png_ptr->background_gamma *
                     png_ptr->screen_gamma);
                  break;
            }

            if (color_type & PNG_COLOR_MASK_COLOR)
            {
               /* RGB or RGBA */
               png_ptr->background_1.red = (png_uint_16)(pow(
                  (double)png_ptr->background.red / m, g) * m + .5);
               png_ptr->background_1.green = (png_uint_16)(pow(
                  (double)png_ptr->background.green / m, g) * m + .5);
               png_ptr->background_1.blue = (png_uint_16)(pow(
                  (double)png_ptr->background.blue / m, g) * m + .5);
               png_ptr->background.red = (png_uint_16)(pow(
                  (double)png_ptr->background.red / m, gs) * m + .5);
               png_ptr->background.green = (png_uint_16)(pow(
                  (double)png_ptr->background.green / m, gs) * m + .5);
               png_ptr->background.blue = (png_uint_16)(pow(
                  (double)png_ptr->background.blue / m, gs) * m + .5);
            }
            else
            {
               /* GRAY or GRAY ALPHA */
               png_ptr->background_1.gray = (png_uint_16)(pow(
                  (double)png_ptr->background.gray / m, g) * m + .5);
               png_ptr->background.gray = (png_uint_16)(pow(
                  (double)png_ptr->background.gray / m, gs) * m + .5);
            }
         }
      }
      else
      /* transformation does not include PNG_BACKGROUND */
#endif
      if (color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_colorp palette = png_ptr->palette;
         int num_palette = png_ptr->num_palette;
         int i;

         for (i = 0; i < num_palette; i++)
         {
            palette[i].red = png_ptr->gamma_table[palette[i].red];
            palette[i].green = png_ptr->gamma_table[palette[i].green];
            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
         }
      }
   }
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   else
#endif
#endif
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* No GAMMA transformation */
   if ((png_ptr->transformations & PNG_BACKGROUND) &&
       (color_type == PNG_COLOR_TYPE_PALETTE))
   {
      int i;
      int istop = (int)png_ptr->num_trans;
      png_color back;
      png_colorp palette = png_ptr->palette;

      back.red   = (png_byte)png_ptr->background.red;
      back.green = (png_byte)png_ptr->background.green;
      back.blue  = (png_byte)png_ptr->background.blue;

      for (i = 0; i < istop; i++)
      {
         if (png_ptr->trans[i] == 0)
         {
            palette[i] = back;
         }
         else if (png_ptr->trans[i] != 0xff)
         {
            /* The png_composite() macro is defined in png.h */
            png_composite(palette[i].red, palette[i].red,
               png_ptr->trans[i], back.red);
            png_composite(palette[i].green, palette[i].green,
               png_ptr->trans[i], back.green);
            png_composite(palette[i].blue, palette[i].blue,
               png_ptr->trans[i], back.blue);
         }
      }
   }
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED)
   if ((png_ptr->transformations & PNG_SHIFT) &&
      (color_type == PNG_COLOR_TYPE_PALETTE))
   {
      png_uint_16 i;
      png_uint_16 istop = png_ptr->num_palette;
      int sr = 8 - png_ptr->sig_bit.red;
      int sg = 8 - png_ptr->sig_bit.green;
      int sb = 8 - png_ptr->sig_bit.blue;

      if (sr < 0 || sr > 8)
         sr = 0;
      if (sg < 0 || sg > 8)
         sg = 0;
      if (sb < 0 || sb > 8)
         sb = 0;
      for (i = 0; i < istop; i++)
      {
         png_ptr->palette[i].red >>= sr;
         png_ptr->palette[i].green >>= sg;
         png_ptr->palette[i].blue >>= sb;
      }
   }
#endif
 }
#if !defined(PNG_READ_GAMMA_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED) \
 && !defined(PNG_READ_BACKGROUND_SUPPORTED)
   if(png_ptr)
      return;
#endif
}

/* Modify the info structure to reflect the transformations.  The
 * info should be updated so a PNG file could be written with it,
 * assuming the transformations result in valid PNG data.
 */
void /* PRIVATE */
png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_read_transform_info\n");
#if defined(PNG_READ_EXPAND_SUPPORTED)
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trans)
            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
         else
            info_ptr->color_type = PNG_COLOR_TYPE_RGB;
         info_ptr->bit_depth = 8;
         info_ptr->num_trans = 0;
      }
      else
      {
         if (png_ptr->num_trans)
            info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
         if (info_ptr->bit_depth < 8)
            info_ptr->bit_depth = 8;
         info_ptr->num_trans = 0;
      }
   }
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   if (png_ptr->transformations & PNG_BACKGROUND)
   {
      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
      info_ptr->num_trans = 0;
      info_ptr->background = png_ptr->background;
   }
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED)
   if (png_ptr->transformations & PNG_GAMMA)
   {
#ifdef PNG_FLOATING_POINT_SUPPORTED
      info_ptr->gamma = png_ptr->gamma;
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
      info_ptr->int_gamma = png_ptr->int_gamma;
#endif
   }
#endif

#if defined(PNG_READ_16_TO_8_SUPPORTED)
   if ((png_ptr->transformations & PNG_16_TO_8) && (info_ptr->bit_depth == 16))
      info_ptr->bit_depth = 8;
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
   if (png_ptr->transformations & PNG_DITHER)
   {
      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
         (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
         png_ptr->palette_lookup && info_ptr->bit_depth == 8)
      {
         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
      }
   }
#endif

#if defined(PNG_READ_PACK_SUPPORTED)
   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
      info_ptr->bit_depth = 8;
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
#endif

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      info_ptr->channels = 1;
   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
      info_ptr->channels = 3;
   else
      info_ptr->channels = 1;

#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_STRIP_ALPHA)
      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
#endif

   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
      info_ptr->channels++;

#if defined(PNG_READ_FILLER_SUPPORTED)
   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
   if ((png_ptr->transformations & PNG_FILLER) &&
       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))
   {
      info_ptr->channels++;
#if 0 /* if adding a true alpha channel not just filler */
      info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
#endif
   }
#endif

#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   if(png_ptr->transformations & PNG_USER_TRANSFORM)
     {
       if(info_ptr->bit_depth < png_ptr->user_transform_depth)
         info_ptr->bit_depth = png_ptr->user_transform_depth;
       if(info_ptr->channels < png_ptr->user_transform_channels)
         info_ptr->channels = png_ptr->user_transform_channels;
     }
#endif

   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
      info_ptr->bit_depth);
   info_ptr->rowbytes = ((info_ptr->width * info_ptr->pixel_depth + 7) >> 3);

#if !defined(PNG_READ_EXPAND_SUPPORTED)
   if(png_ptr)
      return;
#endif
}

/* Transform the row.  The order of transformations is significant,
 * and is very touchy.  If you add a transformation, take care to
 * decide how it fits in with the other transformations here.
 */
void /* PRIVATE */
png_do_read_transformations(png_structp png_ptr)
{
   png_debug(1, "in png_do_read_transformations\n");
#if !defined(PNG_USELESS_TESTS_SUPPORTED)
   if (png_ptr->row_buf == NULL)
   {
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
      char msg[50];

      sprintf(msg, "NULL row buffer for row %ld, pass %d", png_ptr->row_number,
         png_ptr->pass);
      png_error(png_ptr, msg);
#else
      png_error(png_ptr, "NULL row buffer");
#endif
   }
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
            png_ptr->palette, png_ptr->trans, png_ptr->num_trans);
      }
      else
      {
         if (png_ptr->num_trans)
            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
               &(png_ptr->trans_values));
         else
            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
               NULL);
      }
   }
#endif

#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_STRIP_ALPHA)
      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
         PNG_FLAG_FILLER_AFTER);
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
   {
      int rgb_error =
         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info), png_ptr->row_buf + 1);
      if(rgb_error)
      {
         png_ptr->rgb_to_gray_status=1;
         if(png_ptr->transformations == PNG_RGB_TO_GRAY_WARN)
            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
         if(png_ptr->transformations == PNG_RGB_TO_GRAY_ERR)
            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
      }
   }
#endif

/*
From Andreas Dilger e-mail to png-implement, 26 March 1998:

  In most cases, the "simple transparency" should be done prior to doing
  gray-to-RGB, or you will have to test 3x as many bytes to check if a
  pixel is transparent.  You would also need to make sure that the
  transparency information is upgraded to RGB.

  To summarize, the current flow is:
  - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
                                  with background "in place" if transparent,
                                  convert to RGB if necessary
  - Gray + alpha -> composite with gray background and remove alpha bytes,
                                  convert to RGB if necessary

  To support RGB backgrounds for gray images we need:
  - Gray + simple transparency -> convert to RGB + simple transparency, compare
                                  3 or 6 bytes and composite with background
                                  "in place" if transparent (3x compare/pixel
                                  compared to doing composite with gray bkgrnd)
  - Gray + alpha -> convert to RGB + alpha, composite with background and
                                  remove alpha bytes (3x float operations/pixel
                                  compared with composite on gray background)

  Greg's change will do this.  The reason it wasn't done before is for
  performance, as this increases the per-pixel operations.  If we would check
  in advance if the background was gray or RGB, and position the gray-to-RGB
  transform appropriately, then it would save a lot of work/time.
 */

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   /* if gray -> RGB, do so now only if background is non-gray; else do later
    * for performance reasons */
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
       !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   if ((png_ptr->transformations & PNG_BACKGROUND) &&
      ((png_ptr->num_trans != 0 ) ||
      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)))
      png_do_background(&(png_ptr->row_info), png_ptr->row_buf + 1,
         &(png_ptr->trans_values), &(png_ptr->background),
         &(png_ptr->background_1),
         png_ptr->gamma_table, png_ptr->gamma_from_1,
         png_ptr->gamma_to_1, png_ptr->gamma_16_table,
         png_ptr->gamma_16_from_1, png_ptr->gamma_16_to_1,
         png_ptr->gamma_shift);
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED)
   if ((png_ptr->transformations & PNG_GAMMA) &&
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
      !((png_ptr->transformations & PNG_BACKGROUND) &&
      ((png_ptr->num_trans != 0) ||
      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
#endif
      (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
      png_do_gamma(&(png_ptr->row_info), png_ptr->row_buf + 1,
         png_ptr->gamma_table, png_ptr->gamma_16_table,
         png_ptr->gamma_shift);
#endif

#if defined(PNG_READ_16_TO_8_SUPPORTED)
   if (png_ptr->transformations & PNG_16_TO_8)
      png_do_chop(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
   if (png_ptr->transformations & PNG_DITHER)
   {
      png_do_dither((png_row_infop)&(png_ptr->row_info), png_ptr->row_buf + 1,
         png_ptr->palette_lookup, png_ptr->dither_index);
      if(png_ptr->row_info.rowbytes == (png_uint_32)0)
         png_error(png_ptr, "png_do_dither returned rowbytes=0");
   }
#endif

#if defined(PNG_READ_INVERT_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED)
   if (png_ptr->transformations & PNG_SHIFT)
      png_do_unshift(&(png_ptr->row_info), png_ptr->row_buf + 1,
         &(png_ptr->shift));
#endif

#if defined(PNG_READ_PACK_SUPPORTED)
   if (png_ptr->transformations & PNG_PACK)
      png_do_unpack(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_BGR_SUPPORTED)
   if (png_ptr->transformations & PNG_BGR)
      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   /* if gray -> RGB, do so now only if we did not do so above */
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_FILLER_SUPPORTED)
   if (png_ptr->transformations & PNG_FILLER)
      png_do_read_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
         (png_uint_32)png_ptr->filler, png_ptr->flags);
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_ALPHA)
      png_do_read_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_ALPHA)
      png_do_read_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_SWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
    {
      if(png_ptr->read_user_transform_fn != NULL)
        (*(png_ptr->read_user_transform_fn)) /* user read transform function */
          (png_ptr,                    /* png_ptr */
           &(png_ptr->row_info),       /* row_info:     */
             /*  png_uint_32 width;          width of row */
             /*  png_uint_32 rowbytes;       number of bytes in row */
             /*  png_byte color_type;        color type of pixels */
             /*  png_byte bit_depth;         bit depth of samples */
             /*  png_byte channels;          number of channels (1-4) */
             /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
           png_ptr->row_buf + 1);      /* start of pixel data for row */
#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
      if(png_ptr->user_transform_depth)
         png_ptr->row_info.bit_depth = png_ptr->user_transform_depth;
      if(png_ptr->user_transform_channels)
         png_ptr->row_info.channels = png_ptr->user_transform_channels;
#endif
      png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
         png_ptr->row_info.channels);
      png_ptr->row_info.rowbytes = (png_ptr->row_info.width *
         png_ptr->row_info.pixel_depth+7)>>3;
   }
#endif

}

#if defined(PNG_READ_PACK_SUPPORTED)
/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
 * without changing the actual values.  Thus, if you had a row with
 * a bit depth of 1, you would end up with bytes that only contained
 * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
 * png_do_shift() after this.
 */
void /* PRIVATE */
png_do_unpack(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_unpack\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL && row_info->bit_depth < 8)
#else
   if (row_info->bit_depth < 8)
#endif
   {
      png_uint_32 i;
      png_uint_32 row_width=row_info->width;

      switch (row_info->bit_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x01);
               if (shift == 7)
               {
                  shift = 0;
                  sp--;
               }
               else
                  shift++;

               dp--;
            }
            break;
         }
         case 2:
         {

            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x03);
               if (shift == 6)
               {
                  shift = 0;
                  sp--;
               }
               else
                  shift += 2;

               dp--;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x0f);
               if (shift == 4)
               {
                  shift = 0;
                  sp--;
               }
               else
                  shift = 4;

               dp--;
            }
            break;
         }
      }
      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_width * row_info->channels;
   }
}
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED)
/* Reverse the effects of png_do_shift.  This routine merely shifts the
 * pixels back to their significant bits values.  Thus, if you have
 * a row of bit depth 8, but only 5 are significant, this will shift
 * the values back to 0 through 31.
 */
void /* PRIVATE */
png_do_unshift(png_row_infop row_info, png_bytep row, png_color_8p sig_bits)
{
   png_debug(1, "in png_do_unshift\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL && sig_bits != NULL &&
#endif
       row_info->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      int shift[4];
      int channels = 0;
      int c;
      png_uint_16 value = 0;
      png_uint_32 row_width = row_info->width;

      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
      {
         shift[channels++] = row_info->bit_depth - sig_bits->red;
         shift[channels++] = row_info->bit_depth - sig_bits->green;
         shift[channels++] = row_info->bit_depth - sig_bits->blue;
      }
      else
      {
         shift[channels++] = row_info->bit_depth - sig_bits->gray;
      }
      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
      {
         shift[channels++] = row_info->bit_depth - sig_bits->alpha;
      }

      for (c = 0; c < channels; c++)
      {
         if (shift[c] <= 0)
            shift[c] = 0;
         else
            value = 1;
      }

      if (!value)
         return;

      switch (row_info->bit_depth)
      {
         case 2:
         {
            png_bytep bp;
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;

            for (bp = row, i = 0; i < istop; i++)
            {
               *bp >>= 1;
               *bp++ &= 0x55;
            }
            break;
         }
         case 4:
         {
            png_bytep bp = row;
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_byte mask = (png_byte)((((int)0xf0 >> shift[0]) & (int)0xf0) |
               (png_byte)((int)0xf >> shift[0]));

            for (i = 0; i < istop; i++)
            {
               *bp >>= shift[0];
               *bp++ &= mask;
            }
            break;
         }
         case 8:
         {
            png_bytep bp = row;
            png_uint_32 i;
            png_uint_32 istop = row_width * channels;

            for (i = 0; i < istop; i++)
            {
               *bp++ >>= shift[i%channels];
            }
            break;
         }
         case 16:
         {
            png_bytep bp = row;
            png_uint_32 i;
            png_uint_32 istop = channels * row_width;

            for (i = 0; i < istop; i++)
            {
               value = (png_uint_16)((*bp << 8) + *(bp + 1));
               value >>= shift[i%channels];
               *bp++ = (png_byte)(value >> 8);
               *bp++ = (png_byte)(value & 0xff);
            }
            break;
         }
      }
   }
}
#endif

#if defined(PNG_READ_16_TO_8_SUPPORTED)
/* chop rows of bit depth 16 down to 8 */
void /* PRIVATE */
png_do_chop(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_chop\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL && row_info->bit_depth == 16)
#else
   if (row_info->bit_depth == 16)
#endif
   {
      png_bytep sp = row;
      png_bytep dp = row;
      png_uint_32 i;
      png_uint_32 istop = row_info->width * row_info->channels;

      for (i = 0; i<istop; i++, sp += 2, dp++)
      {
#if defined(PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED)
      /* This does a more accurate scaling of the 16-bit color
       * value, rather than a simple low-byte truncation.
       *
       * What the ideal calculation should be:
       *   *dp = (((((png_uint_32)(*sp) << 8) |
       *          (png_uint_32)(*(sp + 1))) * 255 + 127) / (png_uint_32)65535L;
       *
       * GRR: no, I think this is what it really should be:
       *   *dp = (((((png_uint_32)(*sp) << 8) |
       *           (png_uint_32)(*(sp + 1))) + 128L) / (png_uint_32)257L;
       *
       * GRR: here's the exact calculation with shifts:
       *   temp = (((png_uint_32)(*sp) << 8) | (png_uint_32)(*(sp + 1))) + 128L;
       *   *dp = (temp - (temp >> 8)) >> 8;
       *
       * Approximate calculation with shift/add instead of multiply/divide:
       *   *dp = ((((png_uint_32)(*sp) << 8) |
       *          (png_uint_32)((int)(*(sp + 1)) - *sp)) + 128) >> 8;
       *
       * What we actually do to avoid extra shifting and conversion:
       */

         *dp = *sp + ((((int)(*(sp + 1)) - *sp) > 128) ? 1 : 0);
#else
       /* Simply discard the low order byte */
         *dp = *sp;
#endif
      }
      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_info->width * row_info->channels;
   }
}
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
void /* PRIVATE */
png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_swap_alpha\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This converts from RGBA to ARGB */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save;
            }
         }
         /* This converts from RRGGBBAA to AARRGGBB */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save[2];
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save[0] = *(--sp);
               save[1] = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save[0];
               *(--dp) = save[1];
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This converts from GA to AG */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save;
            }
         }
         /* This converts from GGAA to AAGG */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save[2];
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save[0] = *(--sp);
               save[1] = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save[0];
               *(--dp) = save[1];
            }
         }
      }
   }
}
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
void /* PRIVATE */
png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_invert_alpha\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This inverts the alpha channel in RGBA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));

/*             This does nothing:
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               We can replace it with:
*/
               sp-=3;
               dp=sp;
            }
         }
         /* This inverts the alpha channel in RRGGBBAA */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));
               *(--dp) = (png_byte)(255 - *(--sp));

/*             This does nothing:
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               We can replace it with:
*/
               sp-=6;
               dp=sp;
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This inverts the alpha channel in GA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));
               *(--dp) = *(--sp);
            }
         }
         /* This inverts the alpha channel in GGAA */
         else
         {
            png_bytep sp  = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));
               *(--dp) = (png_byte)(255 - *(--sp));
/*
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
*/
               sp-=2;
               dp=sp;
            }
         }
      }
   }
}
#endif

#if defined(PNG_READ_FILLER_SUPPORTED)
/* Add filler channel if we have RGB color */
void /* PRIVATE */
png_do_read_filler(png_row_infop row_info, png_bytep row,
   png_uint_32 filler, png_uint_32 flags)
{
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;

   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
   png_byte lo_filler = (png_byte)(filler & 0xff);

   png_debug(1, "in png_do_read_filler\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL  && row_info != NULL &&
#endif
       row_info->color_type == PNG_COLOR_TYPE_GRAY)
   {
      if(row_info->bit_depth == 8)
      {
         /* This changes the data from G to GX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp =  sp + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            row_info->channels = 2;
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
      /* This changes the data from G to XG */
         else
         {
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
            }
            row_info->channels = 2;
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
      }
      else if(row_info->bit_depth == 16)
      {
         /* This changes the data from GG to GGXX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = hi_filler;
            *(--dp) = lo_filler;
            row_info->channels = 2;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
         /* This changes the data from GG to XXGG */
         else
         {
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
            }
            row_info->channels = 2;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      }
   } /* COLOR_TYPE == GRAY */
   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
   {
      if(row_info->bit_depth == 8)
      {
         /* This changes the data from RGB to RGBX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            row_info->channels = 4;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      /* This changes the data from RGB to XRGB */
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
            }
            row_info->channels = 4;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      }
      else if(row_info->bit_depth == 16)
      {
         /* This changes the data from RRGGBB to RRGGBBXX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = hi_filler;
            *(--dp) = lo_filler;
            row_info->channels = 4;
            row_info->pixel_depth = 64;
            row_info->rowbytes = row_width * 8;
         }
         /* This changes the data from RRGGBB to XXRRGGBB */
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
            }
            row_info->channels = 4;
            row_info->pixel_depth = 64;
            row_info->rowbytes = row_width * 8;
         }
      }
   } /* COLOR_TYPE == RGB */
}
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
/* expand grayscale files to RGB, with or without alpha */
void /* PRIVATE */
png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
{
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;

   png_debug(1, "in png_do_gray_to_rgb\n");
   if (row_info->bit_depth >= 8 &&
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
      !(row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + (png_size_t)row_width - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *sp;
               *(dp--) = *sp;
               *(dp--) = *(sp--);
            }
         }
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 4;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *(sp--);
               *(dp--) = *sp;
               *(dp--) = *sp;
               *(dp--) = *(sp--);
            }
         }
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 4;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
            }
         }
      }
      row_info->channels += (png_byte)2;
      row_info->color_type |= PNG_COLOR_MASK_COLOR;
      row_info->pixel_depth = (png_byte)(row_info->channels *
         row_info->bit_depth);
      row_info->rowbytes = ((row_width *
         row_info->pixel_depth + 7) >> 3);
   }
}
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
/* reduce RGB files to grayscale, with or without alpha
 * using the equation given in Poynton's ColorFAQ at
 * <http://www.inforamp.net/~poynton/>
 * Copyright (c) 1998-01-04 Charles Poynton poynton@inforamp.net
 *
 *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
 *
 *  We approximate this with
 *
 *     Y = 0.21268 * R    + 0.7151 * G    + 0.07217 * B
 *
 *  which can be expressed with integers as
 *
 *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
 *
 *  The calculation is to be done in a linear colorspace.
 *
 *  Other integer coefficents can be used via png_set_rgb_to_gray().
 */
int /* PRIVATE */
png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)

{
   png_uint_32 i;

   png_uint_32 row_width = row_info->width;
   int rgb_error = 0;

   png_debug(1, "in png_do_rgb_to_gray\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
      (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;

      if (row_info->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (row_info->bit_depth == 8)
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;

               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
                  if(red != green || red != blue)
                  {
                     rgb_error |= 1;
                     *(dp++) = png_ptr->gamma_from_1[
                       (rc*red+gc*green+bc*blue)>>15];
                  }
                  else
                     *(dp++) = *(sp-1);
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = *(sp++);
                  png_byte green = *(sp++);
                  png_byte blue  = *(sp++);
                  if(red != green || red != blue)
                  {
                     rgb_error |= 1;
                     *(dp++) = (png_byte)((rc*red+gc*green+bc*blue)>>15);
                  }
                  else
                     *(dp++) = *(sp-1);
               }
            }
         }

         else /* RGB bit_depth == 16 */
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_16_to_1 != NULL &&
                png_ptr->gamma_16_from_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, w;

                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;

                  if(red == green && red == blue)
                     w = red;
                  else
                  {
                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
                                  png_ptr->gamma_shift][red>>8];
                     png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >>
                                  png_ptr->gamma_shift][green>>8];
                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
                                  png_ptr->gamma_shift][blue>>8];
                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
                                  + bc*blue_1)>>15);
                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
                         png_ptr->gamma_shift][gray16 >> 8];
                     rgb_error |= 1;
                  }

                  *(dp++) = (png_byte)((w>>8) & 0xff);
                  *(dp++) = (png_byte)(w & 0xff);
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, gray16;

                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;

                  if(red != green || red != blue)
                     rgb_error |= 1;
                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
                  *(dp++) = (png_byte)(gray16 & 0xff);
               }
            }
         }
      }
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
                  if(red != green || red != blue)
                     rgb_error |= 1;
                  *(dp++) =  png_ptr->gamma_from_1
                             [(rc*red + gc*green + bc*blue)>>15];
                  *(dp++) = *(sp++);  /* alpha */
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = *(sp++);
                  png_byte green = *(sp++);
                  png_byte blue  = *(sp++);
                  if(red != green || red != blue)
                     rgb_error |= 1;
                  *(dp++) =  (png_byte)((gc*red + gc*green + bc*blue)>>8);
                  *(dp++) = *(sp++);  /* alpha */
               }
            }
         }
         else /* RGBA bit_depth == 16 */
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_16_to_1 != NULL &&
                png_ptr->gamma_16_from_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, w;

                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;

                  if(red == green && red == blue)
                     w = red;
                  else
                  {
                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
                                  png_ptr->gamma_shift][red>>8];
                     png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >>
                                  png_ptr->gamma_shift][green>>8];
                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
                                  png_ptr->gamma_shift][blue>>8];
                     png_uint_16 gray16  = (png_uint_16)((rc * red_1
                                  + gc * green_1 + bc * blue_1)>>15);
                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
                         png_ptr->gamma_shift][gray16 >> 8];
                     rgb_error |= 1;
                  }

                  *(dp++) = (png_byte)((w>>8) & 0xff);
                  *(dp++) = (png_byte)(w & 0xff);
                  *(dp++) = *(sp++);  /* alpha */
                  *(dp++) = *(sp++);
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, gray16;
                  red   = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                  if(red != green || red != blue)
                     rgb_error |= 1;
                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
                  *(dp++) = (png_byte)(gray16 & 0xff);
                  *(dp++) = *(sp++);  /* alpha */
                  *(dp++) = *(sp++);
               }
            }
         }
      }
   row_info->channels -= (png_byte)2;
      row_info->color_type &= ~PNG_COLOR_MASK_COLOR;
      row_info->pixel_depth = (png_byte)(row_info->channels *
         row_info->bit_depth);
      row_info->rowbytes = ((row_width *
         row_info->pixel_depth + 7) >> 3);
   }
   return rgb_error;
}
#endif

/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
 * large of png_color.  This lets grayscale images be treated as
 * paletted.  Most useful for gamma correction and simplification
 * of code.
 */
void /* PRIVATE */
png_build_grayscale_palette(int bit_depth, png_colorp palette)
{
   int num_palette;
   int color_inc;
   int i;
   int v;

   png_debug(1, "in png_do_build_grayscale_palette\n");
   if (palette == NULL)
      return;

   switch (bit_depth)
   {
      case 1:
         num_palette = 2;
         color_inc = 0xff;
         break;
      case 2:
         num_palette = 4;
         color_inc = 0x55;
         break;
      case 4:
         num_palette = 16;
         color_inc = 0x11;
         break;
      case 8:
         num_palette = 256;
         color_inc = 1;
         break;
      default:
         num_palette = 0;
         color_inc = 0;
         break;
   }

   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
   {
      palette[i].red = (png_byte)v;
      palette[i].green = (png_byte)v;
      palette[i].blue = (png_byte)v;
   }
}

/* This function is currently unused.  Do we really need it? */
#if defined(PNG_READ_DITHER_SUPPORTED) && defined(PNG_CORRECT_PALETTE_SUPPORTED)
void /* PRIVATE */
png_correct_palette(png_structp png_ptr, png_colorp palette,
   int num_palette)
{
   png_debug(1, "in png_correct_palette\n");
#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
    defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
   if (png_ptr->transformations & (PNG_GAMMA | PNG_BACKGROUND))
   {
      png_color back, back_1;

      if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
      {
         back.red = png_ptr->gamma_table[png_ptr->background.red];
         back.green = png_ptr->gamma_table[png_ptr->background.green];
         back.blue = png_ptr->gamma_table[png_ptr->background.blue];

         back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
         back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
         back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
      }
      else
      {
         double g;

         g = 1.0 / (png_ptr->background_gamma * png_ptr->screen_gamma);

         if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_SCREEN ||
             fabs(g - 1.0) < PNG_GAMMA_THRESHOLD)
         {
            back.red = png_ptr->background.red;
            back.green = png_ptr->background.green;
            back.blue = png_ptr->background.blue;
         }
         else
         {
            back.red =
               (png_byte)(pow((double)png_ptr->background.red/255, g) *
                255.0 + 0.5);
            back.green =
               (png_byte)(pow((double)png_ptr->background.green/255, g) *
                255.0 + 0.5);
            back.blue =
               (png_byte)(pow((double)png_ptr->background.blue/255, g) *
                255.0 + 0.5);
         }

         g = 1.0 / png_ptr->background_gamma;

         back_1.red =
            (png_byte)(pow((double)png_ptr->background.red/255, g) *
             255.0 + 0.5);
         back_1.green =
            (png_byte)(pow((double)png_ptr->background.green/255, g) *
             255.0 + 0.5);
         back_1.blue =
            (png_byte)(pow((double)png_ptr->background.blue/255, g) *
             255.0 + 0.5);
      }

      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_uint_32 i;

         for (i = 0; i < (png_uint_32)num_palette; i++)
         {
            if (i < png_ptr->num_trans && png_ptr->trans[i] == 0)
            {
               palette[i] = back;
            }
            else if (i < png_ptr->num_trans && png_ptr->trans[i] != 0xff)
            {
               png_byte v, w;

               v = png_ptr->gamma_to_1[png_ptr->palette[i].red];
               png_composite(w, v, png_ptr->trans[i], back_1.red);
               palette[i].red = png_ptr->gamma_from_1[w];

               v = png_ptr->gamma_to_1[png_ptr->palette[i].green];
               png_composite(w, v, png_ptr->trans[i], back_1.green);
               palette[i].green = png_ptr->gamma_from_1[w];

               v = png_ptr->gamma_to_1[png_ptr->palette[i].blue];
               png_composite(w, v, png_ptr->trans[i], back_1.blue);
               palette[i].blue = png_ptr->gamma_from_1[w];
            }
            else
            {
               palette[i].red = png_ptr->gamma_table[palette[i].red];
               palette[i].green = png_ptr->gamma_table[palette[i].green];
               palette[i].blue = png_ptr->gamma_table[palette[i].blue];
            }
         }
      }
      else
      {
         int i;

         for (i = 0; i < num_palette; i++)
         {
            if (palette[i].red == (png_byte)png_ptr->trans_values.gray)
            {
               palette[i] = back;
            }
            else
            {
               palette[i].red = png_ptr->gamma_table[palette[i].red];
               palette[i].green = png_ptr->gamma_table[palette[i].green];
               palette[i].blue = png_ptr->gamma_table[palette[i].blue];
            }
         }
      }
   }
   else
#endif
#if defined(PNG_READ_GAMMA_SUPPORTED)
   if (png_ptr->transformations & PNG_GAMMA)
   {
      int i;

      for (i = 0; i < num_palette; i++)
      {
         palette[i].red = png_ptr->gamma_table[palette[i].red];
         palette[i].green = png_ptr->gamma_table[palette[i].green];
         palette[i].blue = png_ptr->gamma_table[palette[i].blue];
      }
   }
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   else
#endif
#endif
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   if (png_ptr->transformations & PNG_BACKGROUND)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_color back;

         back.red   = (png_byte)png_ptr->background.red;
         back.green = (png_byte)png_ptr->background.green;
         back.blue  = (png_byte)png_ptr->background.blue;

         for (i = 0; i < (int)png_ptr->num_trans; i++)
         {
            if (png_ptr->trans[i] == 0)
            {
               palette[i].red = back.red;
               palette[i].green = back.green;
               palette[i].blue = back.blue;
            }
            else if (png_ptr->trans[i] != 0xff)
            {
               png_composite(palette[i].red, png_ptr->palette[i].red,
                  png_ptr->trans[i], back.red);
               png_composite(palette[i].green, png_ptr->palette[i].green,
                  png_ptr->trans[i], back.green);
               png_composite(palette[i].blue, png_ptr->palette[i].blue,
                  png_ptr->trans[i], back.blue);
            }
         }
      }
      else /* assume grayscale palette (what else could it be?) */
      {
         int i;

         for (i = 0; i < num_palette; i++)
         {
            if (i == (png_byte)png_ptr->trans_values.gray)
            {
               palette[i].red = (png_byte)png_ptr->background.red;
               palette[i].green = (png_byte)png_ptr->background.green;
               palette[i].blue = (png_byte)png_ptr->background.blue;
            }
         }
      }
   }
#endif
}
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED)
/* Replace any alpha or transparency with the supplied background color.
 * "background" is already in the screen gamma, while "background_1" is
 * at a gamma of 1.0.  Paletted files have already been taken care of.
 */
void /* PRIVATE */
png_do_background(png_row_infop row_info, png_bytep row,
   png_color_16p trans_values, png_color_16p background,
   png_color_16p background_1,
   png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
   png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
   png_uint_16pp gamma_16_to_1, int gamma_shift)
{
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;
   int shift;

   png_debug(1, "in png_do_background\n");
   if (background != NULL &&
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
      (!(row_info->color_type & PNG_COLOR_MASK_ALPHA) ||
      (row_info->color_type != PNG_COLOR_TYPE_PALETTE && trans_values)))
   {
      switch (row_info->color_type)
      {
         case PNG_COLOR_TYPE_GRAY:
         {
            switch (row_info->bit_depth)
            {
               case 1:
               {
                  sp = row;
                  shift = 7;
                  for (i = 0; i < row_width; i++)
                  {
                     if ((png_uint_16)((*sp >> shift) & 0x01)
                        == trans_values->gray)
                     {
                        *sp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                        *sp |= (png_byte)(background->gray << shift);
                     }
                     if (!shift)
                     {
                        shift = 7;
                        sp++;
                     }
                     else
                        shift--;
                  }
                  break;
               }
               case 2:
               {
#if defined(PNG_READ_GAMMA_SUPPORTED)
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     shift = 6;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x03)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        else
                        {
                           png_byte p = (png_byte)((*sp >> shift) & 0x03);
                           png_byte g = (png_byte)((gamma_table [p | (p << 2) |
                               (p << 4) | (p << 6)] >> 6) & 0x03);
                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                           *sp |= (png_byte)(g << shift);
                        }
                        if (!shift)
                        {
                           shift = 6;
                           sp++;
                        }
                        else
                           shift -= 2;
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     shift = 6;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x03)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        if (!shift)
                        {
                           shift = 6;
                           sp++;
                        }
                        else
                           shift -= 2;
                     }
                  }
                  break;
               }
               case 4:
               {
#if defined(PNG_READ_GAMMA_SUPPORTED)
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     shift = 4;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x0f)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        else
                        {
                           png_byte p = (png_byte)((*sp >> shift) & 0x0f);
                           png_byte g = (png_byte)((gamma_table[p |
                             (p << 4)] >> 4) & 0x0f);
                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                           *sp |= (png_byte)(g << shift);
                        }
                        if (!shift)
                        {
                           shift = 4;
                           sp++;
                        }
                        else
                           shift -= 4;
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     shift = 4;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x0f)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        if (!shift)
                        {
                           shift = 4;
                           sp++;
                        }
                        else
                           shift -= 4;
                     }
                  }
                  break;
               }
               case 8:
               {
#if defined(PNG_READ_GAMMA_SUPPORTED)
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp++)
                     {
                        if (*sp == trans_values->gray)
                        {
                           *sp = (png_byte)background->gray;
                        }
                        else
                        {
                           *sp = gamma_table[*sp];
                        }
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp++)
                     {
                        if (*sp == trans_values->gray)
                        {
                           *sp = (png_byte)background->gray;
                        }
                     }
                  }
                  break;
               }
               case 16:
               {
#if defined(PNG_READ_GAMMA_SUPPORTED)
                  if (gamma_16 != NULL)
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp += 2)
                     {
                        png_uint_16 v;

                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        if (v == trans_values->gray)
                        {
                           /* background is already in screen gamma */
                           *sp = (png_byte)((background->gray >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(background->gray & 0xff);
                        }
                        else
                        {
                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                           *sp = (png_byte)((v >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(v & 0xff);
                        }
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp += 2)
                     {
                        png_uint_16 v;

                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        if (v == trans_values->gray)
                        {
                           *sp = (png_byte)((background->gray >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(background->gray & 0xff);
                        }
                     }
                  }
                  break;
               }
            }
            break;
         }
         case PNG_COLOR_TYPE_RGB:
         {
            if (row_info->bit_depth == 8)
            {
#if defined(PNG_READ_GAMMA_SUPPORTED)
               if (gamma_table != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 3)
                  {
                     if (*sp == trans_values->red &&
                        *(sp + 1) == trans_values->green &&
                        *(sp + 2) == trans_values->blue)
                     {
                        *sp = (png_byte)background->red;
                        *(sp + 1) = (png_byte)background->green;
                        *(sp + 2) = (png_byte)background->blue;
                     }
                     else
                     {
                        *sp = gamma_table[*sp];
                        *(sp + 1) = gamma_table[*(sp + 1)];
                        *(sp + 2) = gamma_table[*(sp + 2)];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 3)
                  {
                     if (*sp == trans_values->red &&
                        *(sp + 1) == trans_values->green &&
                        *(sp + 2) == trans_values->blue)
                     {
                        *sp = (png_byte)background->red;
                        *(sp + 1) = (png_byte)background->green;
                        *(sp + 2) = (png_byte)background->blue;
                     }
                  }
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
#if defined(PNG_READ_GAMMA_SUPPORTED)
               if (gamma_16 != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 6)
                  {
                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                     png_uint_16 g = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
                     png_uint_16 b = (png_uint_16)(((*(sp+4)) << 8) + *(sp+5));
                     if (r == trans_values->red && g == trans_values->green &&
                        b == trans_values->blue)
                     {
                        /* background is already in screen gamma */
                        *sp = (png_byte)((background->red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(background->red & 0xff);
                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(background->green & 0xff);
                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(background->blue & 0xff);
                     }
                     else
                     {
                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(v & 0xff);
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 6)
                  {
                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp+1));
                     png_uint_16 g = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
                     png_uint_16 b = (png_uint_16)(((*(sp+4)) << 8) + *(sp+5));

                     if (r == trans_values->red && g == trans_values->green &&
                        b == trans_values->blue)
                     {
                        *sp = (png_byte)((background->red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(background->red & 0xff);
                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(background->green & 0xff);
                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(background->blue & 0xff);
                     }
                  }
               }
            }
            break;
         }
         case PNG_COLOR_TYPE_GRAY_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
#if defined(PNG_READ_GAMMA_SUPPORTED)
               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                   gamma_table != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 2, dp++)
                  {
                     png_uint_16 a = *(sp + 1);

                     if (a == 0xff)
                     {
                        *dp = gamma_table[*sp];
                     }
                     else if (a == 0)
                     {
                        /* background is already in screen gamma */
                        *dp = (png_byte)background->gray;
                     }
                     else
                     {
                        png_byte v, w;

                        v = gamma_to_1[*sp];
                        png_composite(w, v, a, background_1->gray);
                        *dp = gamma_from_1[w];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 2, dp++)
                  {
                     png_byte a = *(sp + 1);

                     if (a == 0xff)
                     {
                        *dp = *sp;
                     }
                     else if (a == 0)
                     {
                        *dp = (png_byte)background->gray;
                     }
                     else
                     {
                        png_composite(*dp, *sp, a, background_1->gray);
                     }
                  }
               }
            }
            else /* if (png_ptr->bit_depth == 16) */
            {
#if defined(PNG_READ_GAMMA_SUPPORTED)
               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                   gamma_16_to_1 != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
                  {
                     png_uint_16 a = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));

                     if (a == (png_uint_16)0xffff)
                     {
                        png_uint_16 v;

                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                     }
                     else if (a == 0)
                     {
                        /* background is already in screen gamma */
                        *dp = (png_byte)((background->gray >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->gray & 0xff);
                     }
                     else
                     {
                        png_uint_16 g, v, w;

                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
                        png_composite_16(v, g, a, background_1->gray);
                        w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
                        *dp = (png_byte)((w >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(w & 0xff);
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
                  {
                     png_uint_16 a = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
                     if (a == (png_uint_16)0xffff)
                     {
                        png_memcpy(dp, sp, 2);
                     }
                     else if (a == 0)
                     {
                        *dp = (png_byte)((background->gray >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->gray & 0xff);
                     }
                     else
                     {
                        png_uint_16 g, v;

                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        png_composite_16(v, g, a, background_1->gray);
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                     }
                  }
               }
            }
            break;
         }
         case PNG_COLOR_TYPE_RGB_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
#if defined(PNG_READ_GAMMA_SUPPORTED)
               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                   gamma_table != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
                  {
                     png_byte a = *(sp + 3);

                     if (a == 0xff)
                     {
                        *dp = gamma_table[*sp];
                        *(dp + 1) = gamma_table[*(sp + 1)];
                        *(dp + 2) = gamma_table[*(sp + 2)];
                     }
                     else if (a == 0)
                     {
                        /* background is already in screen gamma */
                        *dp = (png_byte)background->red;
                        *(dp + 1) = (png_byte)background->green;
                        *(dp + 2) = (png_byte)background->blue;
                     }
                     else
                     {
                        png_byte v, w;

                        v = gamma_to_1[*sp];
                        png_composite(w, v, a, background_1->red);
                        *dp = gamma_from_1[w];
                        v = gamma_to_1[*(sp + 1)];
                        png_composite(w, v, a, background_1->green);
                        *(dp + 1) = gamma_from_1[w];
                        v = gamma_to_1[*(sp + 2)];
                        png_composite(w, v, a, background_1->blue);
                        *(dp + 2) = gamma_from_1[w];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
                  {
                     png_byte a = *(sp + 3);

                     if (a == 0xff)
                     {
                        *dp = *sp;
                        *(dp + 1) = *(sp + 1);
                        *(dp + 2) = *(sp + 2);
                     }
                     else if (a == 0)
                     {
                        *dp = (png_byte)background->red;
                        *(dp + 1) = (png_byte)background->green;
                        *(dp + 2) = (png_byte)background->blue;
                     }
                     else
                     {
                        png_composite(*dp, *sp, a, background->red);
                        png_composite(*(dp + 1), *(sp + 1), a,
                           background->green);
                        png_composite(*(dp + 2), *(sp + 2), a,
                           background->blue);
                     }
                  }
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
#if defined(PNG_READ_GAMMA_SUPPORTED)
               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                   gamma_16_to_1 != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
                  {
                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                         << 8) + (png_uint_16)(*(sp + 7)));
                     if (a == (png_uint_16)0xffff)
                     {
                        png_uint_16 v;

                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(v & 0xff);
                     }
                     else if (a == 0)
                     {
                        /* background is already in screen gamma */
                        *dp = (png_byte)((background->red >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->red & 0xff);
                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(background->green & 0xff);
                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(background->blue & 0xff);
                     }
                     else
                     {
                        png_uint_16 v, w, x;

                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
                        png_composite_16(w, v, a, background->red);
                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
                        *dp = (png_byte)((x >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(x & 0xff);
                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        png_composite_16(w, v, a, background->green);
                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
                        *(dp + 2) = (png_byte)((x >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(x & 0xff);
                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        png_composite_16(w, v, a, background->blue);
                        x = gamma_16_from_1[(w & 0xff) >> gamma_shift][w >> 8];
                        *(dp + 4) = (png_byte)((x >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(x & 0xff);
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
                  {
                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                        << 8) + (png_uint_16)(*(sp + 7)));
                     if (a == (png_uint_16)0xffff)
                     {
                        png_memcpy(dp, sp, 6);
                     }
                     else if (a == 0)
                     {
                        *dp = (png_byte)((background->red >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->red & 0xff);
                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(background->green & 0xff);
                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(background->blue & 0xff);
                     }
                     else
                     {
                        png_uint_16 v;

                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
                            + *(sp + 3));
                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                            + *(sp + 5));

                        png_composite_16(v, r, a, background->red);
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                        png_composite_16(v, g, a, background->green);
                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(v & 0xff);
                        png_composite_16(v, b, a, background->blue);
                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(v & 0xff);
                     }
                  }
               }
            }
            break;
         }
      }

      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
      {
         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
         row_info->channels--;
         row_info->pixel_depth = (png_byte)(row_info->channels *
            row_info->bit_depth);
         row_info->rowbytes = ((row_width *
            row_info->pixel_depth + 7) >> 3);
      }
   }
}
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED)
/* Gamma correct the image, avoiding the alpha channel.  Make sure
 * you do this after you deal with the transparency issue on grayscale
 * or RGB images. If your bit depth is 8, use gamma_table, if it
 * is 16, use gamma_16_table and gamma_shift.  Build these with
 * build_gamma_table().
 */
void /* PRIVATE */
png_do_gamma(png_row_infop row_info, png_bytep row,
   png_bytep gamma_table, png_uint_16pp gamma_16_table,
   int gamma_shift)
{
   png_bytep sp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_gamma\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       ((row_info->bit_depth <= 8 && gamma_table != NULL) ||
        (row_info->bit_depth == 16 && gamma_16_table != NULL)))
   {
      switch (row_info->color_type)
      {
         case PNG_COLOR_TYPE_RGB:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
               }
            }
            break;
         }
         case PNG_COLOR_TYPE_RGB_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  sp++;
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 4;
               }
            }
            break;
         }
         case PNG_COLOR_TYPE_GRAY_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp += 2;
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 4;
               }
            }
            break;
         }
         case PNG_COLOR_TYPE_GRAY:
         {
            if (row_info->bit_depth == 2)
            {
               sp = row;
               for (i = 0; i < row_width; i += 4)
               {
                  int a = *sp & 0xc0;
                  int b = *sp & 0x30;
                  int c = *sp & 0x0c;
                  int d = *sp & 0x03;

                  *sp = (png_byte)(
                        ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
                        ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
                        ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
                        ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
                  sp++;
               }
            }
            if (row_info->bit_depth == 4)
            {
               sp = row;
               for (i = 0; i < row_width; i += 2)
               {
                  int msb = *sp & 0xf0;
                  int lsb = *sp & 0x0f;

                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
                          | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
                  sp++;
               }
            }
            else if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
               }
            }
            else if (row_info->bit_depth == 16)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
               }
            }
            break;
         }
      }
   }
}
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
/* Expands a palette row to an RGB or RGBA row depending
 * upon whether you supply trans and num_trans.
 */
void /* PRIVATE */
png_do_expand_palette(png_row_infop row_info, png_bytep row,
   png_colorp palette, png_bytep trans, int num_trans)
{
   int shift, value;
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_expand_palette\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (row_info->bit_depth < 8)
      {
         switch (row_info->bit_depth)
         {
            case 1:
            {
               sp = row + (png_size_t)((row_width - 1) >> 3);
               dp = row + (png_size_t)row_width - 1;
               shift = 7 - (int)((row_width + 7) & 0x07);
               for (i = 0; i < row_width; i++)
               {
                  if ((*sp >> shift) & 0x01)
                     *dp = 1;
                  else
                     *dp = 0;
                  if (shift == 7)
                  {
                     shift = 0;
                     sp--;
                  }
                  else
                     shift++;

                  dp--;
               }
               break;
            }
            case 2:
            {
               sp = row + (png_size_t)((row_width - 1) >> 2);
               dp = row + (png_size_t)row_width - 1;
               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
               for (i = 0; i < row_width; i++)
               {
                  value = (*sp >> shift) & 0x03;
                  *dp = (png_byte)value;
                  if (shift == 6)
                  {
                     shift = 0;
                     sp--;
                  }
                  else
                     shift += 2;

                  dp--;
               }
               break;
            }
            case 4:
            {
               sp = row + (png_size_t)((row_width - 1) >> 1);
               dp = row + (png_size_t)row_width - 1;
               shift = (int)((row_width & 0x01) << 2);
               for (i = 0; i < row_width; i++)
               {
                  value = (*sp >> shift) & 0x0f;
                  *dp = (png_byte)value;
                  if (shift == 4)
                  {
                     shift = 0;
                     sp--;
                  }
                  else
                     shift += 4;

                  dp--;
               }
               break;
            }
         }
         row_info->bit_depth = 8;
         row_info->pixel_depth = 8;
         row_info->rowbytes = row_width;
      }
      switch (row_info->bit_depth)
      {
         case 8:
         {
            if (trans != NULL)
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width << 2) - 1;

               for (i = 0; i < row_width; i++)
               {
                  if ((int)(*sp) >= num_trans)
                     *dp-- = 0xff;
                  else
                     *dp-- = trans[*sp];
                  *dp-- = palette[*sp].blue;
                  *dp-- = palette[*sp].green;
                  *dp-- = palette[*sp].red;
                  sp--;
               }
               row_info->bit_depth = 8;
               row_info->pixel_depth = 32;
               row_info->rowbytes = row_width * 4;
               row_info->color_type = 6;
               row_info->channels = 4;
            }
            else
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width * 3) - 1;

               for (i = 0; i < row_width; i++)
               {
                  *dp-- = palette[*sp].blue;
                  *dp-- = palette[*sp].green;
                  *dp-- = palette[*sp].red;
                  sp--;
               }
               row_info->bit_depth = 8;
               row_info->pixel_depth = 24;
               row_info->rowbytes = row_width * 3;
               row_info->color_type = 2;
               row_info->channels = 3;
            }
            break;
         }
      }
   }
}

/* If the bit depth < 8, it is expanded to 8.  Also, if the
 * transparency value is supplied, an alpha channel is built.
 */
void /* PRIVATE */
png_do_expand(png_row_infop row_info, png_bytep row,
   png_color_16p trans_value)
{
   int shift, value;
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_expand\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
      {
         png_uint_16 gray = (png_uint_16)(trans_value ? trans_value->gray : 0);

         if (row_info->bit_depth < 8)
         {
            switch (row_info->bit_depth)
            {
               case 1:
               {
                  gray = (png_uint_16)(gray*0xff);
                  sp = row + (png_size_t)((row_width - 1) >> 3);
                  dp = row + (png_size_t)row_width - 1;
                  shift = 7 - (int)((row_width + 7) & 0x07);
                  for (i = 0; i < row_width; i++)
                  {
                     if ((*sp >> shift) & 0x01)
                        *dp = 0xff;
                     else
                        *dp = 0;
                     if (shift == 7)
                     {
                        shift = 0;
                        sp--;
                     }
                     else
                        shift++;

                     dp--;
                  }
                  break;
               }
               case 2:
               {
                  gray = (png_uint_16)(gray*0x55);
                  sp = row + (png_size_t)((row_width - 1) >> 2);
                  dp = row + (png_size_t)row_width - 1;
                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
                  for (i = 0; i < row_width; i++)
                  {
                     value = (*sp >> shift) & 0x03;
                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
                        (value << 6));
                     if (shift == 6)
                     {
                        shift = 0;
                        sp--;
                     }
                     else
                        shift += 2;

                     dp--;
                  }
                  break;
               }
               case 4:
               {
                  gray = (png_uint_16)(gray*0x11);
                  sp = row + (png_size_t)((row_width - 1) >> 1);
                  dp = row + (png_size_t)row_width - 1;
                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
                  for (i = 0; i < row_width; i++)
                  {
                     value = (*sp >> shift) & 0x0f;
                     *dp = (png_byte)(value | (value << 4));
                     if (shift == 4)
                     {
                        shift = 0;
                        sp--;
                     }
                     else
                        shift = 4;

                     dp--;
                  }
                  break;
               }
            }
            row_info->bit_depth = 8;
            row_info->pixel_depth = 8;
            row_info->rowbytes = row_width;
         }

         if (trans_value != NULL)
         {
            if (row_info->bit_depth == 8)
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width << 1) - 1;
               for (i = 0; i < row_width; i++)
               {
                  if (*sp == gray)
                     *dp-- = 0;
                  else
                     *dp-- = 0xff;
                  *dp-- = *sp--;
               }
            }
            else if (row_info->bit_depth == 16)
            {
               sp = row + row_info->rowbytes - 1;
               dp = row + (row_info->rowbytes << 1) - 1;
               for (i = 0; i < row_width; i++)
               {
                  if (((png_uint_16)*(sp) |
                     ((png_uint_16)*(sp - 1) << 8)) == gray)
                  {
                     *dp-- = 0;
                     *dp-- = 0;
                  }
                  else
                  {
                     *dp-- = 0xff;
                     *dp-- = 0xff;
                  }
                  *dp-- = *sp--;
                  *dp-- = *sp--;
               }
            }
            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
            row_info->channels = 2;
            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
            row_info->rowbytes =
               ((row_width * row_info->pixel_depth) >> 3);
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_value)
      {
         if (row_info->bit_depth == 8)
         {
            sp = row + (png_size_t)row_info->rowbytes - 1;
            dp = row + (png_size_t)(row_width << 2) - 1;
            for (i = 0; i < row_width; i++)
            {
               if (*(sp - 2) == trans_value->red &&
                  *(sp - 1) == trans_value->green &&
                  *(sp - 0) == trans_value->blue)
                  *dp-- = 0;
               else
                  *dp-- = 0xff;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
            }
         }
         else if (row_info->bit_depth == 16)
         {
            sp = row + row_info->rowbytes - 1;
            dp = row + (png_size_t)(row_width << 3) - 1;
            for (i = 0; i < row_width; i++)
            {
               if ((((png_uint_16)*(sp - 4) |
                  ((png_uint_16)*(sp - 5) << 8)) == trans_value->red) &&
                  (((png_uint_16)*(sp - 2) |
                  ((png_uint_16)*(sp - 3) << 8)) == trans_value->green) &&
                  (((png_uint_16)*(sp - 0) |
                  ((png_uint_16)*(sp - 1) << 8)) == trans_value->blue))
               {
                  *dp-- = 0;
                  *dp-- = 0;
               }
               else
               {
                  *dp-- = 0xff;
                  *dp-- = 0xff;
               }
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
            }
         }
         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
         row_info->channels = 4;
         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
         row_info->rowbytes =
            ((row_width * row_info->pixel_depth) >> 3);
      }
   }
}
#endif

#if defined(PNG_READ_DITHER_SUPPORTED)
void /* PRIVATE */
png_do_dither(png_row_infop row_info, png_bytep row,
    png_bytep palette_lookup, png_bytep dither_lookup)
{
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_dither\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
         palette_lookup && row_info->bit_depth == 8)
      {
         int r, g, b, p;
         sp = row;
         dp = row;
         for (i = 0; i < row_width; i++)
         {
            r = *sp++;
            g = *sp++;
            b = *sp++;

            /* this looks real messy, but the compiler will reduce
               it down to a reasonable formula.  For example, with
               5 bits per color, we get:
               p = (((r >> 3) & 0x1f) << 10) |
                  (((g >> 3) & 0x1f) << 5) |
                  ((b >> 3) & 0x1f);
               */
            p = (((r >> (8 - PNG_DITHER_RED_BITS)) &
               ((1 << PNG_DITHER_RED_BITS) - 1)) <<
               (PNG_DITHER_GREEN_BITS + PNG_DITHER_BLUE_BITS)) |
               (((g >> (8 - PNG_DITHER_GREEN_BITS)) &
               ((1 << PNG_DITHER_GREEN_BITS) - 1)) <<
               (PNG_DITHER_BLUE_BITS)) |
               ((b >> (8 - PNG_DITHER_BLUE_BITS)) &
               ((1 << PNG_DITHER_BLUE_BITS) - 1));

            *dp++ = palette_lookup[p];
         }
         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
         row_info->channels = 1;
         row_info->pixel_depth = row_info->bit_depth;
         row_info->rowbytes =
             ((row_width * row_info->pixel_depth + 7) >> 3);
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
         palette_lookup != NULL && row_info->bit_depth == 8)
      {
         int r, g, b, p;
         sp = row;
         dp = row;
         for (i = 0; i < row_width; i++)
         {
            r = *sp++;
            g = *sp++;
            b = *sp++;
            sp++;

            p = (((r >> (8 - PNG_DITHER_RED_BITS)) &
               ((1 << PNG_DITHER_RED_BITS) - 1)) <<
               (PNG_DITHER_GREEN_BITS + PNG_DITHER_BLUE_BITS)) |
               (((g >> (8 - PNG_DITHER_GREEN_BITS)) &
               ((1 << PNG_DITHER_GREEN_BITS) - 1)) <<
               (PNG_DITHER_BLUE_BITS)) |
               ((b >> (8 - PNG_DITHER_BLUE_BITS)) &
               ((1 << PNG_DITHER_BLUE_BITS) - 1));

            *dp++ = palette_lookup[p];
         }
         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
         row_info->channels = 1;
         row_info->pixel_depth = row_info->bit_depth;
         row_info->rowbytes =
            ((row_width * row_info->pixel_depth + 7) >> 3);
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
         dither_lookup && row_info->bit_depth == 8)
      {
         sp = row;
         for (i = 0; i < row_width; i++, sp++)
         {
            *sp = dither_lookup[*sp];
         }
      }
   }
}
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
#if defined(PNG_READ_GAMMA_SUPPORTED)
static int png_gamma_shift[] =
   {0x10, 0x21, 0x42, 0x84, 0x110, 0x248, 0x550, 0xff0};

/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
 * tables, we don't make a full table if we are reducing to 8-bit in
 * the future.  Note also how the gamma_16 tables are segmented so that
 * we don't need to allocate > 64K chunks for a full 16-bit table.
 */
void /* PRIVATE */
png_build_gamma_table(png_structp png_ptr)
{
  png_debug(1, "in png_build_gamma_table\n");
  if(png_ptr->gamma != 0.0)
  {
   if (png_ptr->bit_depth <= 8)
   {
      int i;
      double g;

      if (png_ptr->screen_gamma > .000001)
         g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
      else
         g = 1.0;

      png_ptr->gamma_table = (png_bytep)png_malloc(png_ptr,
         (png_uint_32)256);

      for (i = 0; i < 256; i++)
      {
         png_ptr->gamma_table[i] = (png_byte)(pow((double)i / 255.0,
            g) * 255.0 + .5);
      }

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
      if (png_ptr->transformations & ((PNG_BACKGROUND) | PNG_RGB_TO_GRAY))
      {

         g = 1.0 / (png_ptr->gamma);

         png_ptr->gamma_to_1 = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)256);

         for (i = 0; i < 256; i++)
         {
            png_ptr->gamma_to_1[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);
         }


         png_ptr->gamma_from_1 = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)256);

         if(png_ptr->screen_gamma > 0.000001)
            g = 1.0 / png_ptr->screen_gamma;
         else
            g = png_ptr->gamma;   /* probably doing rgb_to_gray */

         for (i = 0; i < 256; i++)
         {
            png_ptr->gamma_from_1[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);

         }
      }
#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
   }
   else
   {
      double g;
      int i, j, shift, num;
      int sig_bit;
      png_uint_32 ig;

      if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
      {
         sig_bit = (int)png_ptr->sig_bit.red;
         if ((int)png_ptr->sig_bit.green > sig_bit)
            sig_bit = png_ptr->sig_bit.green;
         if ((int)png_ptr->sig_bit.blue > sig_bit)
            sig_bit = png_ptr->sig_bit.blue;
      }
      else
      {
         sig_bit = (int)png_ptr->sig_bit.gray;
      }

      if (sig_bit > 0)
         shift = 16 - sig_bit;
      else
         shift = 0;

      if (png_ptr->transformations & PNG_16_TO_8)
      {
         if (shift < (16 - PNG_MAX_GAMMA_8))
            shift = (16 - PNG_MAX_GAMMA_8);
      }

      if (shift > 8)
         shift = 8;
      if (shift < 0)
         shift = 0;

      png_ptr->gamma_shift = (png_byte)shift;

      num = (1 << (8 - shift));

      if (png_ptr->screen_gamma > .000001)
         g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
      else
         g = 1.0;

      png_ptr->gamma_16_table = (png_uint_16pp)png_malloc(png_ptr,
         (png_uint_32)(num * sizeof (png_uint_16p)));

      if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
      {
         double fin, fout;
         png_uint_32 last, max;

         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * sizeof (png_uint_16)));
         }

         g = 1.0 / g;
         last = 0;
         for (i = 0; i < 256; i++)
         {
            fout = ((double)i + 0.5) / 256.0;
            fin = pow(fout, g);
            max = (png_uint_32)(fin * (double)((png_uint_32)num << 8));
            while (last <= max)
            {
               png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
                  [(int)(last >> (8 - shift))] = (png_uint_16)(
                  (png_uint_16)i | ((png_uint_16)i << 8));
               last++;
            }
         }
         while (last < ((png_uint_32)num << 8))
         {
            png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
               [(int)(last >> (8 - shift))] = (png_uint_16)65535L;
            last++;
         }
      }
      else
      {
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * sizeof (png_uint_16)));

            ig = (((png_uint_32)i * (png_uint_32)png_gamma_shift[shift]) >> 4);
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_table[i][j] =
                  (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                     65535.0, g) * 65535.0 + .5);
            }
         }
      }

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
      if (png_ptr->transformations & (PNG_BACKGROUND | PNG_RGB_TO_GRAY))
      {

         g = 1.0 / (png_ptr->gamma);

         png_ptr->gamma_16_to_1 = (png_uint_16pp)png_malloc(png_ptr,
            (png_uint_32)(num * sizeof (png_uint_16p )));

         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * sizeof (png_uint_16)));

            ig = (((png_uint_32)i *
               (png_uint_32)png_gamma_shift[shift]) >> 4);
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_to_1[i][j] =
                  (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                     65535.0, g) * 65535.0 + .5);
            }
         }

         if(png_ptr->screen_gamma > 0.000001)
            g = 1.0 / png_ptr->screen_gamma;
         else
            g = png_ptr->gamma;   /* probably doing rgb_to_gray */

         png_ptr->gamma_16_from_1 = (png_uint_16pp)png_malloc(png_ptr,
            (png_uint_32)(num * sizeof (png_uint_16p)));

         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * sizeof (png_uint_16)));

            ig = (((png_uint_32)i *
               (png_uint_32)png_gamma_shift[shift]) >> 4);
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_from_1[i][j] =
                  (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                     65535.0, g) * 65535.0 + .5);
            }
         }
      }
#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
   }
 }
}
#endif
/* To do: install integer version of png_build_gamma_table here */
#endif

#if defined(PNG_MNG_FEATURES_SUPPORTED)
/* undoes intrapixel differencing  */
void /* PRIVATE */
png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_intrapixel\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      int bytes_per_pixel;
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 3;
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 4;
         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            *(rp) = (png_byte)((256 + *rp + *(rp+1))&0xff);
            *(rp+2) = (png_byte)((256 + *(rp+2) + *(rp+1))&0xff);
         }
      }
      else if (row_info->bit_depth == 16)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 6;
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 8;
         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            png_uint_32 s0=*(rp  )<<8 | *(rp+1);
            png_uint_32 s1=*(rp+2)<<8 | *(rp+3);
            png_uint_32 s2=*(rp+4)<<8 | *(rp+5);
            png_uint_32 red=(65536+s0+s1)&0xffff;
            png_uint_32 blue=(65536+s2+s1)&0xffff;
            *(rp  ) = (png_byte)((red>>8)&0xff);
            *(rp+1) = (png_byte)(red&0xff);
            *(rp+4) = (png_byte)((blue>>8)&0xff);
            *(rp+5) = (png_byte)(blue&0xff);
         }
      }
   }
}
#endif /* PNG_MNG_FEATURES_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngread.c ===
/* pngread.c - read a PNG file
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file contains routines that an application calls directly to
 * read a PNG file or stream.
 */

#define PNG_INTERNAL
#include "png.h"

/* Create a PNG structure for reading, and allocate any memory needed. */
png_structp PNGAPI
png_create_read_struct(png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn)
{

#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
      warn_fn, NULL, NULL, NULL));
}

/* Alternate create PNG structure for reading, and allocate any memory needed. */
png_structp PNGAPI
png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
   png_malloc_ptr malloc_fn, png_free_ptr free_fn)
{
#endif /* PNG_USER_MEM_SUPPORTED */

   png_structp png_ptr;

#ifdef PNG_SETJMP_SUPPORTED
#ifdef USE_FAR_KEYWORD
   jmp_buf jmpbuf;
#endif
#endif

   int i;

   png_debug(1, "in png_create_read_struct\n");
#ifdef PNG_USER_MEM_SUPPORTED
   if ((png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
      (png_malloc_ptr)malloc_fn)) == NULL)
#else
   if ((png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG)) == NULL)
#endif
   {
      return (png_structp)NULL;
   }

#ifdef PNG_SETJMP_SUPPORTED
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(png_ptr->jmpbuf))
#endif
   {
      png_free(png_ptr, png_ptr->zbuf);
      png_ptr->zbuf=NULL;
      png_destroy_struct(png_ptr);
      return (png_structp)NULL;
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
#endif
#endif

#ifdef PNG_USER_MEM_SUPPORTED
   png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);
#endif

   png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);

   i=0;
   do
   {
     if(user_png_ver[i] != png_libpng_ver[i])
        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
   } while (png_libpng_ver[i++]);

   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
   {
     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
      * we must recompile any applications that use any older library version.
      * For versions after libpng 1.0, we will be compatible, so we need
      * only check the first digit.
      */
     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
     {
        png_error(png_ptr,
           "Incompatible libpng version in application and library");
     }

     /* Libpng 1.0.6 was not binary compatible, due to insertion of the
        info_ptr->free_me member.  Note to maintainer: this test can be
        removed from version 2.0.0 and beyond because the previous test
        would have already rejected it. */

     if (user_png_ver[4] == '6' && user_png_ver[2] == '0' &&
         user_png_ver[0] == '1' && user_png_ver[5] == '\0')
     {
        png_error(png_ptr,
           "Application must be recompiled; version 1.0.6 was incompatible");
     }
   }

   /* initialize zbuf - compression buffer */
   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
     (png_uint_32)png_ptr->zbuf_size);
   png_ptr->zstream.zalloc = png_zalloc;
   png_ptr->zstream.zfree = png_zfree;
   png_ptr->zstream.opaque = (voidpf)png_ptr;

   switch (inflateInit(&png_ptr->zstream))
   {
     case Z_OK: /* Do nothing */ break;
     case Z_MEM_ERROR:
     case Z_STREAM_ERROR: png_error(png_ptr, "zlib memory error"); break;
     case Z_VERSION_ERROR: png_error(png_ptr, "zlib version error"); break;
     default: png_error(png_ptr, "Unknown zlib error");
   }

   png_ptr->zstream.next_out = png_ptr->zbuf;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

   png_set_read_fn(png_ptr, NULL, NULL);

   return (png_ptr);
}

/* Initialize PNG structure for reading, and allocate any memory needed.
   This interface is deprecated in favour of the png_create_read_struct(),
   and it will eventually disappear. */
#undef png_read_init
void PNGAPI
png_read_init(png_structp png_ptr)
{
   /* We only come here via pre-1.0.7-compiled applications */
   png_read_init_2(png_ptr, "1.0.0", 10000, 10000);
}

void PNGAPI
png_read_init_2(png_structp png_ptr, png_const_charp user_png_ver,
   png_size_t png_struct_size, png_size_t png_info_size)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp;  /* to save current jump buffer */
#endif

   int i=0;
   do
   {
     if(user_png_ver[i] != png_libpng_ver[i])
     {
#ifdef PNG_LEGACY_SUPPORTED
       png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
#else
       png_ptr->error_fn=(png_error_ptr)NULL;
       png_error(png_ptr,
        "Application uses deprecated png_read_init() and must be recompiled.");
#endif
     }
   } while (png_libpng_ver[i++]);

   if(sizeof(png_struct) > png_struct_size ||
      sizeof(png_info) > png_info_size)
     {
       png_ptr->error_fn=(png_error_ptr)NULL;
       png_error(png_ptr,
      "Application and library have different sized structs. Please recompile.");
     }

   png_debug(1, "in png_read_init_2\n");

#ifdef PNG_SETJMP_SUPPORTED
   /* save jump buffer and error functions */
   png_memcpy(tmp_jmp, png_ptr->jmpbuf, sizeof (jmp_buf));
#endif

   /* reset all variables to 0 */
   png_memset(png_ptr, 0, sizeof (png_struct));

#ifdef PNG_SETJMP_SUPPORTED
   /* restore jump buffer */
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, sizeof (jmp_buf));
#endif

   /* initialize zbuf - compression buffer */
   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
     (png_uint_32)png_ptr->zbuf_size);
   png_ptr->zstream.zalloc = png_zalloc;
   png_ptr->zstream.zfree = png_zfree;
   png_ptr->zstream.opaque = (voidpf)png_ptr;

   switch (inflateInit(&png_ptr->zstream))
   {
     case Z_OK: /* Do nothing */ break;
     case Z_MEM_ERROR:
     case Z_STREAM_ERROR: png_error(png_ptr, "zlib memory"); break;
     case Z_VERSION_ERROR: png_error(png_ptr, "zlib version"); break;
     default: png_error(png_ptr, "Unknown zlib error");
   }

   png_ptr->zstream.next_out = png_ptr->zbuf;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

   png_set_read_fn(png_ptr, NULL, NULL);
}

/* Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already has the magic
 * bytes read from the stream.  You can tell libpng how many bytes have
 * been read from the beginning of the stream (up to the maximum of 8)
 * via png_set_sig_bytes(), and we will only check the remaining bytes
 * here.  The application can then have access to the signature bytes we
 * read if it is determined that this isn't a valid PNG file.
 */
void PNGAPI
png_read_info(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_read_info\n");
   /* save jump buffer and error functions */
   /* If we haven't checked all of the PNG signature bytes, do so now. */
   if (png_ptr->sig_bytes < 8)
   {
      png_size_t num_checked = png_ptr->sig_bytes,
                 num_to_check = 8 - num_checked;

      png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);
      png_ptr->sig_bytes = 8;

      if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
      {
         if (num_checked < 4 &&
             png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
            png_error(png_ptr, "Not a PNG file");
         else
            png_error(png_ptr, "PNG file corrupted by ASCII conversion");
      }
      if (num_checked < 3)
         png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
   }

   for(;;)
   {
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_IHDR;
      PNG_IDAT;
      PNG_IEND;
      PNG_PLTE;
#if defined(PNG_READ_bKGD_SUPPORTED)
      PNG_bKGD;
#endif
#if defined(PNG_READ_cHRM_SUPPORTED)
      PNG_cHRM;
#endif
#if defined(PNG_READ_gAMA_SUPPORTED)
      PNG_gAMA;
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
      PNG_hIST;
#endif
#if defined(PNG_READ_iCCP_SUPPORTED)
      PNG_iCCP;
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      PNG_iTXt;
#endif
#if defined(PNG_READ_oFFs_SUPPORTED)
      PNG_oFFs;
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
      PNG_pCAL;
#endif
#if defined(PNG_READ_pHYs_SUPPORTED)
      PNG_pHYs;
#endif
#if defined(PNG_READ_sBIT_SUPPORTED)
      PNG_sBIT;
#endif
#if defined(PNG_READ_sCAL_SUPPORTED)
      PNG_sCAL;
#endif
#if defined(PNG_READ_sPLT_SUPPORTED)
      PNG_sPLT;
#endif
#if defined(PNG_READ_sRGB_SUPPORTED)
      PNG_sRGB;
#endif
#if defined(PNG_READ_tEXt_SUPPORTED)
      PNG_tEXt;
#endif
#if defined(PNG_READ_tIME_SUPPORTED)
      PNG_tIME;
#endif
#if defined(PNG_READ_tRNS_SUPPORTED)
      PNG_tRNS;
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      PNG_zTXt;
#endif
#endif /* PNG_GLOBAL_ARRAYS */
      png_byte chunk_length[4];
      png_uint_32 length;

      png_read_data(png_ptr, chunk_length, 4);
      length = png_get_uint_32(chunk_length);

      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, png_ptr->chunk_name, 4);

      png_debug2(0, "Reading %s chunk, length=%lu.\n", png_ptr->chunk_name,
         length);

      /* This should be a binary subdivision search or a hash for
       * matching the chunk name rather than a linear search.
       */
      if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
         png_handle_IHDR(png_ptr, info_ptr, length);
      else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
         png_handle_IEND(png_ptr, info_ptr, length);
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
      else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
      {
         if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
            png_ptr->mode |= PNG_HAVE_IDAT;
         png_handle_unknown(png_ptr, info_ptr, length);
         if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
            png_ptr->mode |= PNG_HAVE_PLTE;
         else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
         {
            if (!(png_ptr->mode & PNG_HAVE_IHDR))
               png_error(png_ptr, "Missing IHDR before IDAT");
            else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
                     !(png_ptr->mode & PNG_HAVE_PLTE))
               png_error(png_ptr, "Missing PLTE before IDAT");
            break;
         }
      }
#endif
      else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
         png_handle_PLTE(png_ptr, info_ptr, length);
      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
      {
         if (!(png_ptr->mode & PNG_HAVE_IHDR))
            png_error(png_ptr, "Missing IHDR before IDAT");
         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
                  !(png_ptr->mode & PNG_HAVE_PLTE))
            png_error(png_ptr, "Missing PLTE before IDAT");

         png_ptr->idat_size = length;
         png_ptr->mode |= PNG_HAVE_IDAT;
         break;
      }
#if defined(PNG_READ_bKGD_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
         png_handle_bKGD(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_cHRM_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
         png_handle_cHRM(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_gAMA_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
         png_handle_gAMA(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
         png_handle_hIST(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_oFFs_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
         png_handle_oFFs(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
         png_handle_pCAL(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sCAL_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
         png_handle_sCAL(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_pHYs_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
         png_handle_pHYs(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sBIT_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
         png_handle_sBIT(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sRGB_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
         png_handle_sRGB(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_iCCP_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
         png_handle_iCCP(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sPLT_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
         png_handle_sPLT(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_tEXt_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
         png_handle_tEXt(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_tIME_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
         png_handle_tIME(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_tRNS_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
         png_handle_tRNS(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
         png_handle_zTXt(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
         png_handle_iTXt(png_ptr, info_ptr, length);
#endif
      else
         png_handle_unknown(png_ptr, info_ptr, length);
   }
}

/* optional call to update the users info_ptr structure */
void PNGAPI
png_read_update_info(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_read_update_info\n");
   /* save jump buffer and error functions */
   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
      png_read_start_row(png_ptr);
   else
      png_warning(png_ptr,
      "Ignoring extra png_read_update_info() call; row buffer not reallocated");
   png_read_transform_info(png_ptr, info_ptr);
}

/* Initialize palette, background, etc, after transformations
 * are set, but before any reading takes place.  This allows
 * the user to obtain a gamma-corrected palette, for example.
 * If the user doesn't call this, we will do it ourselves.
 */
void PNGAPI
png_start_read_image(png_structp png_ptr)
{
   png_debug(1, "in png_start_read_image\n");
   /* save jump buffer and error functions */
   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
      png_read_start_row(png_ptr);
}

void PNGAPI
png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IDAT;
   const int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
   const int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
#endif
   int ret;
   png_debug2(1, "in png_read_row (row %lu, pass %d)\n",
      png_ptr->row_number, png_ptr->pass);
   /* save jump buffer and error functions */
   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
      png_read_start_row(png_ptr);
   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
   {
   /* check for transforms that have been set but were defined out */
#if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined.");
#endif
#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)
   if (png_ptr->transformations & PNG_FILLER)
      png_warning(png_ptr, "PNG_READ_FILLER_SUPPORTED is not defined.");
#endif
#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && !defined(PNG_READ_PACKSWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_warning(png_ptr, "PNG_READ_PACKSWAP_SUPPORTED is not defined.");
#endif
#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)
   if (png_ptr->transformations & PNG_PACK)
      png_warning(png_ptr, "PNG_READ_PACK_SUPPORTED is not defined.");
#endif
#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)
   if (png_ptr->transformations & PNG_SHIFT)
      png_warning(png_ptr, "PNG_READ_SHIFT_SUPPORTED is not defined.");
#endif
#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)
   if (png_ptr->transformations & PNG_BGR)
      png_warning(png_ptr, "PNG_READ_BGR_SUPPORTED is not defined.");
#endif
#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_warning(png_ptr, "PNG_READ_SWAP_SUPPORTED is not defined.");
#endif
   }

#if defined(PNG_READ_INTERLACING_SUPPORTED)
   /* if interlaced and we do not need a new row, combine row and return */
   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
   {
      switch (png_ptr->pass)
      {
         case 0:
            if (png_ptr->row_number & 0x07)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row,
                     png_pass_dsp_mask[png_ptr->pass]);
               png_read_finish_row(png_ptr);
               return;
            }
            break;
         case 1:
            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row,
                     png_pass_dsp_mask[png_ptr->pass]);
               png_read_finish_row(png_ptr);
               return;
            }
            break;
         case 2:
            if ((png_ptr->row_number & 0x07) != 4)
            {
               if (dsp_row != NULL && (png_ptr->row_number & 4))
                  png_combine_row(png_ptr, dsp_row,
                     png_pass_dsp_mask[png_ptr->pass]);
               png_read_finish_row(png_ptr);
               return;
            }
            break;
         case 3:
            if ((png_ptr->row_number & 3) || png_ptr->width < 3)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row,
                     png_pass_dsp_mask[png_ptr->pass]);
               png_read_finish_row(png_ptr);
               return;
            }
            break;
         case 4:
            if ((png_ptr->row_number & 3) != 2)
            {
               if (dsp_row != NULL && (png_ptr->row_number & 2))
                  png_combine_row(png_ptr, dsp_row,
                     png_pass_dsp_mask[png_ptr->pass]);
               png_read_finish_row(png_ptr);
               return;
            }
            break;
         case 5:
            if ((png_ptr->row_number & 1) || png_ptr->width < 2)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row,
                     png_pass_dsp_mask[png_ptr->pass]);
               png_read_finish_row(png_ptr);
               return;
            }
            break;
         case 6:
            if (!(png_ptr->row_number & 1))
            {
               png_read_finish_row(png_ptr);
               return;
            }
            break;
      }
   }
#endif

   if (!(png_ptr->mode & PNG_HAVE_IDAT))
      png_error(png_ptr, "Invalid attempt to read row data");

   png_ptr->zstream.next_out = png_ptr->row_buf;
   png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
   do
   {
      if (!(png_ptr->zstream.avail_in))
      {
         while (!png_ptr->idat_size)
         {
            png_byte chunk_length[4];

            png_crc_finish(png_ptr, 0);

            png_read_data(png_ptr, chunk_length, 4);
            png_ptr->idat_size = png_get_uint_32(chunk_length);

            png_reset_crc(png_ptr);
            png_crc_read(png_ptr, png_ptr->chunk_name, 4);
            if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
               png_error(png_ptr, "Not enough image data");
         }
         png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
         png_ptr->zstream.next_in = png_ptr->zbuf;
         if (png_ptr->zbuf_size > png_ptr->idat_size)
            png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
         png_crc_read(png_ptr, png_ptr->zbuf,
            (png_size_t)png_ptr->zstream.avail_in);
         png_ptr->idat_size -= png_ptr->zstream.avail_in;
      }
      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
      if (ret == Z_STREAM_END)
      {
         if (png_ptr->zstream.avail_out || png_ptr->zstream.avail_in ||
            png_ptr->idat_size)
            png_error(png_ptr, "Extra compressed data");
         png_ptr->mode |= PNG_AFTER_IDAT;
         png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
         break;
      }
      if (ret != Z_OK)
         png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
                   "Decompression error");

   } while (png_ptr->zstream.avail_out);

   png_ptr->row_info.color_type = png_ptr->color_type;
   png_ptr->row_info.width = png_ptr->iwidth;
   png_ptr->row_info.channels = png_ptr->channels;
   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;
   png_ptr->row_info.rowbytes = ((png_ptr->row_info.width *
      (png_uint_32)png_ptr->row_info.pixel_depth + 7) >> 3);

   if(png_ptr->row_buf[0])
   png_read_filter_row(png_ptr, &(png_ptr->row_info),
      png_ptr->row_buf + 1, png_ptr->prev_row + 1,
      (int)(png_ptr->row_buf[0]));

   png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
      png_ptr->rowbytes + 1);
   
#if defined(PNG_MNG_FEATURES_SUPPORTED)
   if((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
      (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
   {
      /* Intrapixel differencing */
      png_do_read_intrapixel(&(png_ptr->row_info), png_ptr->row_buf + 1);
   }
#endif

   if (png_ptr->transformations)
      png_do_read_transformations(png_ptr);

#if defined(PNG_READ_INTERLACING_SUPPORTED)
   /* blow up interlaced rows to full size */
   if (png_ptr->interlaced &&
      (png_ptr->transformations & PNG_INTERLACE))
   {
      if (png_ptr->pass < 6)
/*       old interface (pre-1.0.9):
         png_do_read_interlace(&(png_ptr->row_info),
            png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
 */
         png_do_read_interlace(png_ptr);

      if (dsp_row != NULL)
         png_combine_row(png_ptr, dsp_row,
            png_pass_dsp_mask[png_ptr->pass]);
      if (row != NULL)
         png_combine_row(png_ptr, row,
            png_pass_mask[png_ptr->pass]);
   }
   else
#endif
   {
      if (row != NULL)
         png_combine_row(png_ptr, row, 0xff);
      if (dsp_row != NULL)
         png_combine_row(png_ptr, dsp_row, 0xff);
   }
   png_read_finish_row(png_ptr);

   if (png_ptr->read_row_fn != NULL)
      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
}

/* Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * image has alpha or transparency, and png_handle_alpha()[*] has been
 * called, the rows contents must be initialized to the contents of the
 * screen.
 *
 * "row" holds the actual image, and pixels are placed in it
 * as they arrive.  If the image is displayed after each pass, it will
 * appear to "sparkle" in.  "display_row" can be used to display a
 * "chunky" progressive image, with finer detail added as it becomes
 * available.  If you do not want this "chunky" display, you may pass
 * NULL for display_row.  If you do not want the sparkle display, and
 * you have not called png_handle_alpha(), you may pass NULL for rows.
 * If you have called png_handle_alpha(), and the image has either an
 * alpha channel or a transparency chunk, you must provide a buffer for
 * rows.  In this case, you do not have to provide a display_row buffer
 * also, but you may.  If the image is not interlaced, or if you have
 * not called png_set_interlace_handling(), the display_row buffer will
 * be ignored, so pass NULL to it.
 *
 * [*] png_handle_alpha() does not exist yet, as of libpng version 1.0.11
 */

void PNGAPI
png_read_rows(png_structp png_ptr, png_bytepp row,
   png_bytepp display_row, png_uint_32 num_rows)
{
   png_uint_32 i;
   png_bytepp rp;
   png_bytepp dp;

   png_debug(1, "in png_read_rows\n");
   /* save jump buffer and error functions */
   rp = row;
   dp = display_row;
   if (rp != NULL && dp != NULL)
      for (i = 0; i < num_rows; i++)
      {
         png_bytep rptr = *rp++;
         png_bytep dptr = *dp++;

         png_read_row(png_ptr, rptr, dptr);
      }
   else if(rp != NULL)
      for (i = 0; i < num_rows; i++)
      {
         png_bytep rptr = *rp;
         png_read_row(png_ptr, rptr, NULL);
         rp++;
      }
   else if(dp != NULL)
      for (i = 0; i < num_rows; i++)
      {
         png_bytep dptr = *dp;
         png_read_row(png_ptr, NULL, dptr);
         dp++;
      }
}

/* Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of libpng version 1.0.11
 */
void PNGAPI
png_read_image(png_structp png_ptr, png_bytepp image)
{
   png_uint_32 i,image_height;
   int pass, j;
   png_bytepp rp;

   png_debug(1, "in png_read_image\n");
   /* save jump buffer and error functions */

#ifdef PNG_READ_INTERLACING_SUPPORTED
   pass = png_set_interlace_handling(png_ptr);
#else
   if (png_ptr->interlaced)
      png_error(png_ptr,
        "Cannot read interlaced image -- interlace handler disabled.");
   pass = 1;
#endif


   image_height=png_ptr->height;
   png_ptr->num_rows = image_height; /* Make sure this is set correctly */

   for (j = 0; j < pass; j++)
   {
      rp = image;
      for (i = 0; i < image_height; i++)
      {
         png_read_row(png_ptr, *rp, NULL);
         rp++;
      }
   }
}

/* Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.
 */
void PNGAPI
png_read_end(png_structp png_ptr, png_infop info_ptr)
{
   png_byte chunk_length[4];
   png_uint_32 length;

   png_debug(1, "in png_read_end\n");
   /* save jump buffer and error functions */
   png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */

   do
   {
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_IHDR;
      PNG_IDAT;
      PNG_IEND;
      PNG_PLTE;
#if defined(PNG_READ_bKGD_SUPPORTED)
      PNG_bKGD;
#endif
#if defined(PNG_READ_cHRM_SUPPORTED)
      PNG_cHRM;
#endif
#if defined(PNG_READ_gAMA_SUPPORTED)
      PNG_gAMA;
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
      PNG_hIST;
#endif
#if defined(PNG_READ_iCCP_SUPPORTED)
      PNG_iCCP;
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      PNG_iTXt;
#endif
#if defined(PNG_READ_oFFs_SUPPORTED)
      PNG_oFFs;
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
      PNG_pCAL;
#endif
#if defined(PNG_READ_pHYs_SUPPORTED)
      PNG_pHYs;
#endif
#if defined(PNG_READ_sBIT_SUPPORTED)
      PNG_sBIT;
#endif
#if defined(PNG_READ_sCAL_SUPPORTED)
      PNG_sCAL;
#endif
#if defined(PNG_READ_sPLT_SUPPORTED)
      PNG_sPLT;
#endif
#if defined(PNG_READ_sRGB_SUPPORTED)
      PNG_sRGB;
#endif
#if defined(PNG_READ_tEXt_SUPPORTED)
      PNG_tEXt;
#endif
#if defined(PNG_READ_tIME_SUPPORTED)
      PNG_tIME;
#endif
#if defined(PNG_READ_tRNS_SUPPORTED)
      PNG_tRNS;
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      PNG_zTXt;
#endif
#endif /* PNG_GLOBAL_ARRAYS */

      png_read_data(png_ptr, chunk_length, 4);
      length = png_get_uint_32(chunk_length);

      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, png_ptr->chunk_name, 4);

      png_debug1(0, "Reading %s chunk.\n", png_ptr->chunk_name);

      if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
         png_handle_IHDR(png_ptr, info_ptr, length);
      else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
         png_handle_IEND(png_ptr, info_ptr, length);
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
      else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
      {
         if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
         {
            if (length > 0 || png_ptr->mode & PNG_AFTER_IDAT)
               png_error(png_ptr, "Too many IDAT's found");
         }
         else
            png_ptr->mode |= PNG_AFTER_IDAT;
         png_handle_unknown(png_ptr, info_ptr, length);
         if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
            png_ptr->mode |= PNG_HAVE_PLTE;
      }
#endif
      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
      {
         /* Zero length IDATs are legal after the last IDAT has been
          * read, but not after other chunks have been read.
          */
         if (length > 0 || png_ptr->mode & PNG_AFTER_IDAT)
            png_error(png_ptr, "Too many IDAT's found");
         png_crc_finish(png_ptr, length);
      }
      else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
         png_handle_PLTE(png_ptr, info_ptr, length);
#if defined(PNG_READ_bKGD_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
         png_handle_bKGD(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_cHRM_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
         png_handle_cHRM(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_gAMA_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
         png_handle_gAMA(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
         png_handle_hIST(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_oFFs_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
         png_handle_oFFs(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
         png_handle_pCAL(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sCAL_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
         png_handle_sCAL(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_pHYs_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
         png_handle_pHYs(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sBIT_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
         png_handle_sBIT(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sRGB_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
         png_handle_sRGB(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_iCCP_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
         png_handle_iCCP(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_sPLT_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
         png_handle_sPLT(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_tEXt_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
         png_handle_tEXt(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_tIME_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
         png_handle_tIME(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_tRNS_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
         png_handle_tRNS(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
         png_handle_zTXt(png_ptr, info_ptr, length);
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
         png_handle_iTXt(png_ptr, info_ptr, length);
#endif
      else
         png_handle_unknown(png_ptr, info_ptr, length);
   } while (!(png_ptr->mode & PNG_HAVE_IEND));
}

/* free all memory used by the read */
void PNGAPI
png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
   png_infopp end_info_ptr_ptr)
{
   png_structp png_ptr = NULL;
   png_infop info_ptr = NULL, end_info_ptr = NULL;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn = NULL;
#endif

   png_debug(1, "in png_destroy_read_struct\n");
   /* save jump buffer and error functions */
   if (png_ptr_ptr != NULL)
      png_ptr = *png_ptr_ptr;

   if (info_ptr_ptr != NULL)
      info_ptr = *info_ptr_ptr;

   if (end_info_ptr_ptr != NULL)
      end_info_ptr = *end_info_ptr_ptr;

#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_read_destroy(png_ptr, info_ptr, end_info_ptr);

   if (info_ptr != NULL)
   {
#if defined(PNG_TEXT_SUPPORTED)
      png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, -1);
#endif

#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)info_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)info_ptr);
#endif
      *info_ptr_ptr = (png_infop)NULL;
   }

   if (end_info_ptr != NULL)
   {
#if defined(PNG_READ_TEXT_SUPPORTED)
      png_free_data(png_ptr, end_info_ptr, PNG_FREE_TEXT, -1);
#endif
#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)end_info_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)end_info_ptr);
#endif
      *end_info_ptr_ptr = (png_infop)NULL;
   }

   if (png_ptr != NULL)
   {
#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)png_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)png_ptr);
#endif
      *png_ptr_ptr = (png_structp)NULL;
   }
}

/* free all memory used by the read (old method) */
void /* PRIVATE */
png_read_destroy(png_structp png_ptr, png_infop info_ptr, png_infop end_info_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp;
#endif
   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn;
#endif

   png_debug(1, "in png_read_destroy\n");
   /* save jump buffer and error functions */
   if (info_ptr != NULL)
      png_info_destroy(png_ptr, info_ptr);

   if (end_info_ptr != NULL)
      png_info_destroy(png_ptr, end_info_ptr);

   png_free(png_ptr, png_ptr->zbuf);
   png_free(png_ptr, png_ptr->row_buf);
   png_free(png_ptr, png_ptr->prev_row);
#if defined(PNG_READ_DITHER_SUPPORTED)
   png_free(png_ptr, png_ptr->palette_lookup);
   png_free(png_ptr, png_ptr->dither_index);
#endif
#if defined(PNG_READ_GAMMA_SUPPORTED)
   png_free(png_ptr, png_ptr->gamma_table);
#endif
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   png_free(png_ptr, png_ptr->gamma_from_1);
   png_free(png_ptr, png_ptr->gamma_to_1);
#endif
#ifdef PNG_FREE_ME_SUPPORTED
   if (png_ptr->free_me & PNG_FREE_PLTE)
      png_zfree(png_ptr, png_ptr->palette);
   png_ptr->free_me &= ~PNG_FREE_PLTE;
#else
   if (png_ptr->flags & PNG_FLAG_FREE_PLTE)
      png_zfree(png_ptr, png_ptr->palette);
   png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;
#endif
#if defined(PNG_tRNS_SUPPORTED) || \
    defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
#ifdef PNG_FREE_ME_SUPPORTED
   if (png_ptr->free_me & PNG_FREE_TRNS)
      png_free(png_ptr, png_ptr->trans);
   png_ptr->free_me &= ~PNG_FREE_TRNS;
#else
   if (png_ptr->flags & PNG_FLAG_FREE_TRNS)
      png_free(png_ptr, png_ptr->trans);
   png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
#endif
#endif
#if defined(PNG_READ_hIST_SUPPORTED)
#ifdef PNG_FREE_ME_SUPPORTED
   if (png_ptr->free_me & PNG_FREE_HIST)
      png_free(png_ptr, png_ptr->hist);
   png_ptr->free_me &= ~PNG_FREE_HIST;
#else
   if (png_ptr->flags & PNG_FLAG_FREE_HIST)
      png_free(png_ptr, png_ptr->hist);
   png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
#endif
#endif
#if defined(PNG_READ_GAMMA_SUPPORTED)
   if (png_ptr->gamma_16_table != NULL)
   {
      int i;
      int istop = (1 << (8 - png_ptr->gamma_shift));
      for (i = 0; i < istop; i++)
      {
         png_free(png_ptr, png_ptr->gamma_16_table[i]);
      }
   png_free(png_ptr, png_ptr->gamma_16_table);
   }
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
   if (png_ptr->gamma_16_from_1 != NULL)
   {
      int i;
      int istop = (1 << (8 - png_ptr->gamma_shift));
      for (i = 0; i < istop; i++)
      {
         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
      }
   png_free(png_ptr, png_ptr->gamma_16_from_1);
   }
   if (png_ptr->gamma_16_to_1 != NULL)
   {
      int i;
      int istop = (1 << (8 - png_ptr->gamma_shift));
      for (i = 0; i < istop; i++)
      {
         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
      }
   png_free(png_ptr, png_ptr->gamma_16_to_1);
   }
#endif
#endif
#if defined(PNG_TIME_RFC1123_SUPPORTED)
   png_free(png_ptr, png_ptr->time_buffer);
#endif

   inflateEnd(&png_ptr->zstream);
#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
   png_free(png_ptr, png_ptr->save_buffer);
#endif

   /* Save the important info out of the png_struct, in case it is
    * being used again.
    */
#ifdef PNG_SETJMP_SUPPORTED
   png_memcpy(tmp_jmp, png_ptr->jmpbuf, sizeof (jmp_buf));
#endif

   error_fn = png_ptr->error_fn;
   warning_fn = png_ptr->warning_fn;
   error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_memset(png_ptr, 0, sizeof (png_struct));

   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
   png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, sizeof (jmp_buf));
#endif

}

void PNGAPI
png_set_read_status_fn(png_structp png_ptr, png_read_status_ptr read_row_fn)
{
   png_ptr->read_row_fn = read_row_fn;
}

#if defined(PNG_INFO_IMAGE_SUPPORTED)
void PNGAPI
png_read_png(png_structp png_ptr, png_infop info_ptr,
                           int transforms,
                           voidp params)
{
   int row;

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
   /* invert the alpha channel from opacity to transparency */
   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
       png_set_invert_alpha(png_ptr);
#endif

   /* The call to png_read_info() gives us all of the information from the
    * PNG file before the first IDAT (image data chunk).
    */
   png_read_info(png_ptr, info_ptr);

   /* -------------- image transformations start here ------------------- */

#if defined(PNG_READ_16_TO_8_SUPPORTED)
   /* tell libpng to strip 16 bit/color files down to 8 bits/color */
   if (transforms & PNG_TRANSFORM_STRIP_16)
       png_set_strip_16(png_ptr);
#endif

#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
   /* Strip alpha bytes from the input data without combining with the
    * background (not recommended).
    */
   if (transforms & PNG_TRANSFORM_STRIP_ALPHA)
       png_set_strip_alpha(png_ptr);
#endif

#if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED)
   /* Extract multiple pixels with bit depths of 1, 2, and 4 from a single
    * byte into separate bytes (useful for paletted and grayscale images).
    */
   if (transforms & PNG_TRANSFORM_PACKING)
       png_set_packing(png_ptr);
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
   /* Change the order of packed pixels to least significant bit first
    * (not useful if you are using png_set_packing). */
   if (transforms & PNG_TRANSFORM_PACKSWAP)
       png_set_packswap(png_ptr);
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
   /* Expand paletted colors into true RGB triplets
    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
    * Expand paletted or RGB images with transparency to full alpha
    * channels so the data will be available as RGBA quartets.
    */
   if (transforms & PNG_TRANSFORM_EXPAND)
       if ((png_ptr->bit_depth < 8) ||
           (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ||
           (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)))
         png_set_expand(png_ptr);
#endif

   /* We don't handle background color or gamma transformation or dithering. */

#if defined(PNG_READ_INVERT_SUPPORTED)
   /* invert monochrome files to have 0 as white and 1 as black */
   if (transforms & PNG_TRANSFORM_INVERT_MONO)
       png_set_invert_mono(png_ptr);
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED)
   /* If you want to shift the pixel values from the range [0,255] or
    * [0,65535] to the original [0,7] or [0,31], or whatever range the
    * colors were originally in:
    */
   if ((transforms & PNG_TRANSFORM_SHIFT)
       && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT))
   {
      png_color_8p sig_bit;

      png_get_sBIT(png_ptr, info_ptr, &sig_bit);
      png_set_shift(png_ptr, sig_bit);
   }
#endif

#if defined(PNG_READ_BGR_SUPPORTED)
   /* flip the RGB pixels to BGR (or RGBA to BGRA) */
   if (transforms & PNG_TRANSFORM_BGR)
       png_set_bgr(png_ptr);
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
   /* swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
   if (transforms & PNG_TRANSFORM_SWAP_ALPHA)
       png_set_swap_alpha(png_ptr);
#endif

#if defined(PNG_READ_SWAP_SUPPORTED)
   /* swap bytes of 16 bit files to least significant byte first */
   if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
       png_set_swap(png_ptr);
#endif

   /* We don't handle adding filler bytes */

   /* Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected such a transform above).
    */
   png_read_update_info(png_ptr, info_ptr);

   /* -------------- image transformations end here ------------------- */

#ifdef PNG_FREE_ME_SUPPORTED
   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
#endif
   if(info_ptr->row_pointers == NULL)
   {
      info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr,
         info_ptr->height * sizeof(png_bytep));
#ifdef PNG_FREE_ME_SUPPORTED
      info_ptr->free_me |= PNG_FREE_ROWS;
#endif
      for (row = 0; row < (int)info_ptr->height; row++)
      {
         info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,
            png_get_rowbytes(png_ptr, info_ptr));
      }
   }

   png_read_image(png_ptr, info_ptr->row_pointers);
   info_ptr->valid |= PNG_INFO_IDAT;

   /* read rest of file, and get additional chunks in info_ptr - REQUIRED */
   png_read_end(png_ptr, info_ptr);

   if(transforms == 0 || params == NULL)
      /* quiet compiler warnings */ return;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngmem.c ===
/* pngmem.c - stub functions for memory allocation
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file provides a location for all memory allocation.  Users who
 * need special memory handling are expected to supply replacement
 * functions for png_malloc() and png_free(), and to use
 * png_create_read_struct_2() and png_create_write_struct_2() to
 * identify the replacement functions.
 */

#define PNG_INTERNAL
#include "png.h"

/* Borland DOS special memory handler */
#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
/* if you change this, be sure to change the one in png.h also */

/* Allocate memory for a png_struct.  The malloc and memset can be replaced
   by a single call to calloc() if this is thought to improve performance. */
png_voidp /* PRIVATE */
png_create_struct(int type)
{
#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_struct_2(type, NULL));
}

/* Alternate version of png_create_struct, for use with user-defined malloc. */
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   png_size_t size;
   png_voidp struct_ptr;

   if (type == PNG_STRUCT_INFO)
     size = sizeof(png_info);
   else if (type == PNG_STRUCT_PNG)
     size = sizeof(png_struct);
   else
     return ((png_voidp)NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(malloc_fn != NULL)
   {
      if ((struct_ptr = (*(malloc_fn))(NULL, size)) != NULL)
         png_memset(struct_ptr, 0, size);
         return (struct_ptr);
   }
#endif /* PNG_USER_MEM_SUPPORTED */
   if ((struct_ptr = (png_voidp)farmalloc(size)) != NULL)
   {
      png_memset(struct_ptr, 0, size);
   }
   return (struct_ptr);
}


/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct(png_voidp struct_ptr)
{
#ifdef PNG_USER_MEM_SUPPORTED
   png_destroy_struct_2(struct_ptr, (png_free_ptr)NULL);
}

/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn)
{
#endif
   if (struct_ptr != NULL)
   {
#ifdef PNG_USER_MEM_SUPPORTED
      if(free_fn != NULL)
      {
         png_struct dummy_struct;
         png_structp png_ptr = &dummy_struct;
         (*(free_fn))(png_ptr, struct_ptr);
         return;
      }
#endif /* PNG_USER_MEM_SUPPORTED */
      farfree (struct_ptr);
   }
}

/* Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more then 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information. zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.
 *
 * Borland seems to have a problem in DOS mode for exactly 64K.
 * It gives you a segment with an offset of 8 (perhaps to store its
 * memory stuff).  zlib doesn't like this at all, so we have to
 * detect and deal with it.  This code should not be needed in
 * Windows or OS/2 modes, and only in 16 bit mode.  This code has
 * been updated by Alexander Lehmann for version 0.89 to waste less
 * memory.
 *
 * Note that we can't use png_size_t for the "size" declaration,
 * since on some systems a png_size_t is a 16-bit quantity, and as a
 * result, we would be truncating potentially larger memory requests
 * (which should cause a fatal error) and introducing major problems.
 */
png_voidp PNGAPI
png_malloc(png_structp png_ptr, png_uint_32 size)
{
#ifndef PNG_USER_MEM_SUPPORTED
   png_voidp ret;
#endif
   if (png_ptr == NULL || size == 0)
      return ((png_voidp)NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(png_ptr->malloc_fn != NULL)
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
       if (ret == NULL)
          png_error(png_ptr, "Out of memory!");
       return (ret);
   }
   else
       return png_malloc_default(png_ptr, size);
}

png_voidp PNGAPI
png_malloc_default(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;
#endif /* PNG_USER_MEM_SUPPORTED */

#ifdef PNG_MAX_MALLOC_64K
   if (size > (png_uint_32)65536L)
      png_error(png_ptr, "Cannot Allocate > 64K");
#endif

   if (size == (png_uint_32)65536L)
   {
      if (png_ptr->offset_table == NULL)
      {
         /* try to see if we need to do any of this fancy stuff */
         ret = farmalloc(size);
         if (ret == NULL || ((png_size_t)ret & 0xffff))
         {
            int num_blocks;
            png_uint_32 total_size;
            png_bytep table;
            int i;
            png_byte huge * hptr;

            if (ret != NULL)
            {
               farfree(ret);
               ret = NULL;
            }

            if(png_ptr->zlib_window_bits > 14)
               num_blocks = (int)(1 << (png_ptr->zlib_window_bits - 14));
            else
               num_blocks = 1;
            if (png_ptr->zlib_mem_level >= 7)
               num_blocks += (int)(1 << (png_ptr->zlib_mem_level - 7));
            else
               num_blocks++;

            total_size = ((png_uint_32)65536L) * (png_uint_32)num_blocks+16;

            table = farmalloc(total_size);

            if (table == NULL)
            {
               png_error(png_ptr, "Out Of Memory."); /* Note "O" and "M" */
            }

            if ((png_size_t)table & 0xfff0)
            {
               png_error(png_ptr, "Farmalloc didn't return normalized pointer");
            }

            png_ptr->offset_table = table;
            png_ptr->offset_table_ptr = farmalloc(num_blocks *
               sizeof (png_bytep));

            if (png_ptr->offset_table_ptr == NULL)
            {
               png_error(png_ptr, "Out Of memory.");
            }

            hptr = (png_byte huge *)table;
            if ((png_size_t)hptr & 0xf)
            {
               hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
            }
            for (i = 0; i < num_blocks; i++)
            {
               png_ptr->offset_table_ptr[i] = (png_bytep)hptr;
               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
            }

            png_ptr->offset_table_number = num_blocks;
            png_ptr->offset_table_count = 0;
            png_ptr->offset_table_count_free = 0;
         }
      }

      if (png_ptr->offset_table_count >= png_ptr->offset_table_number)
         png_error(png_ptr, "Out of Memory.");

      ret = png_ptr->offset_table_ptr[png_ptr->offset_table_count++];
   }
   else
      ret = farmalloc(size);

   if (ret == NULL)
   {
      png_error(png_ptr, "Out of memory."); /* Note "o" and "m" */
   }

   return (ret);
}

/* free a pointer allocated by png_malloc().  In the default
   configuration, png_ptr is not used, but is passed in case it
   is needed.  If ptr is NULL, return without taking any action. */
void PNGAPI
png_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#ifdef PNG_USER_MEM_SUPPORTED
   if (png_ptr->free_fn != NULL)
   {
      (*(png_ptr->free_fn))(png_ptr, ptr);
      return;
   }
   else png_free_default(png_ptr, ptr);
}

void PNGAPI
png_free_default(png_structp png_ptr, png_voidp ptr)
{
#endif /* PNG_USER_MEM_SUPPORTED */

   if (png_ptr->offset_table != NULL)
   {
      int i;

      for (i = 0; i < png_ptr->offset_table_count; i++)
      {
         if (ptr == png_ptr->offset_table_ptr[i])
         {
            ptr = NULL;
            png_ptr->offset_table_count_free++;
            break;
         }
      }
      if (png_ptr->offset_table_count_free == png_ptr->offset_table_count)
      {
         farfree(png_ptr->offset_table);
         farfree(png_ptr->offset_table_ptr);
         png_ptr->offset_table = NULL;
         png_ptr->offset_table_ptr = NULL;
      }
   }

   if (ptr != NULL)
   {
      farfree(ptr);
   }
}

#else /* Not the Borland DOS special memory handler */

/* Allocate memory for a png_struct or a png_info.  The malloc and
   memset can be replaced by a single call to calloc() if this is thought
   to improve performance noticably.*/
png_voidp /* PRIVATE */
png_create_struct(int type)
{
#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_struct_2(type, NULL));
}

/* Allocate memory for a png_struct or a png_info.  The malloc and
   memset can be replaced by a single call to calloc() if this is thought
   to improve performance noticably.*/
png_voidp /* PRIVATE */
png_create_struct_2(int type, png_malloc_ptr malloc_fn)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   png_size_t size;
   png_voidp struct_ptr;

   if (type == PNG_STRUCT_INFO)
      size = sizeof(png_info);
   else if (type == PNG_STRUCT_PNG)
      size = sizeof(png_struct);
   else
      return ((png_voidp)NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(malloc_fn != NULL)
   {
      if ((struct_ptr = (*(malloc_fn))(NULL, size)) != NULL)
         png_memset(struct_ptr, 0, size);
      return (struct_ptr);
   }
#endif /* PNG_USER_MEM_SUPPORTED */

#if defined(__TURBOC__) && !defined(__FLAT__)
   if ((struct_ptr = (png_voidp)farmalloc(size)) != NULL)
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
   if ((struct_ptr = (png_voidp)halloc(size,1)) != NULL)
# else
   if ((struct_ptr = (png_voidp)malloc(size)) != NULL)
# endif
#endif
   {
      png_memset(struct_ptr, 0, size);
   }

   return (struct_ptr);
}


/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct(png_voidp struct_ptr)
{
#ifdef PNG_USER_MEM_SUPPORTED
   png_destroy_struct_2(struct_ptr, (png_free_ptr)NULL);
}

/* Free memory allocated by a png_create_struct() call */
void /* PRIVATE */
png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   if (struct_ptr != NULL)
   {
#ifdef PNG_USER_MEM_SUPPORTED
      if(free_fn != NULL)
      {
         png_struct dummy_struct;
         png_structp png_ptr = &dummy_struct;
         (*(free_fn))(png_ptr, struct_ptr);
         return;
      }
#endif /* PNG_USER_MEM_SUPPORTED */
#if defined(__TURBOC__) && !defined(__FLAT__)
      farfree(struct_ptr);
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
      hfree(struct_ptr);
# else
      free(struct_ptr);
# endif
#endif
   }
}


/* Allocate memory.  For reasonable files, size should never exceed
   64K.  However, zlib may allocate more then 64K if you don't tell
   it not to.  See zconf.h and png.h for more information.  zlib does
   need to allocate exactly 64K, so whatever you call here must
   have the ability to do that. */

png_voidp PNGAPI
png_malloc(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;
   if (png_ptr == NULL || size == 0)
      return ((png_voidp)NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   if(png_ptr->malloc_fn != NULL)
   {
       ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
       if (ret == NULL)
          png_error(png_ptr, "Out of Memory!");
       return (ret);
   }
   else
       return (png_malloc_default(png_ptr, size));
}
png_voidp /* PRIVATE */
png_malloc_default(png_structp png_ptr, png_uint_32 size)
{
   png_voidp ret;
#endif /* PNG_USER_MEM_SUPPORTED */

#ifdef PNG_MAX_MALLOC_64K
   if (size > (png_uint_32)65536L)
      png_error(png_ptr, "Cannot Allocate > 64K");
#endif

#if defined(__TURBOC__) && !defined(__FLAT__)
   ret = farmalloc(size);
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
   ret = halloc(size, 1);
# else
   ret = malloc((size_t)size);
# endif
#endif

   if (ret == NULL)
      png_error(png_ptr, "Out of Memory");

   return (ret);
}

/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
   without taking any action. */
void PNGAPI
png_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#ifdef PNG_USER_MEM_SUPPORTED
   if (png_ptr->free_fn != NULL)
   {
      (*(png_ptr->free_fn))(png_ptr, ptr);
      return;
   }
   else png_free_default(png_ptr, ptr);
}
void /* PRIVATE */
png_free_default(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#endif /* PNG_USER_MEM_SUPPORTED */

#if defined(__TURBOC__) && !defined(__FLAT__)
   farfree(ptr);
#else
# if defined(_MSC_VER) && defined(MAXSEG_64K)
   hfree(ptr);
# else
   free(ptr);
# endif
#endif
}

#endif /* Not Borland DOS special memory handler */

png_voidp /* PRIVATE */
png_memcpy_check (png_structp png_ptr, png_voidp s1, png_voidp s2,
   png_uint_32 length)
{
   png_size_t size;

   size = (png_size_t)length;
   if ((png_uint_32)size != length)
      png_error(png_ptr,"Overflow in png_memcpy_check.");

   return(png_memcpy (s1, s2, size));
}

png_voidp /* PRIVATE */
png_memset_check (png_structp png_ptr, png_voidp s1, int value,
   png_uint_32 length)
{
   png_size_t size;

   size = (png_size_t)length;
   if ((png_uint_32)size != length)
      png_error(png_ptr,"Overflow in png_memset_check.");

   return (png_memset (s1, value, size));

}

#ifdef PNG_USER_MEM_SUPPORTED
/* This function is called when the application wants to use another method
 * of allocating and freeing memory.
 */
void PNGAPI
png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
  malloc_fn, png_free_ptr free_fn)
{
   png_ptr->mem_ptr = mem_ptr;
   png_ptr->malloc_fn = malloc_fn;
   png_ptr->free_fn = free_fn;
}

/* This function returns a pointer to the mem_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.
 */
png_voidp PNGAPI
png_get_mem_ptr(png_structp png_ptr)
{
   return ((png_voidp)png_ptr->mem_ptr);
}
#endif /* PNG_USER_MEM_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngrutil.c ===
/* pngrutil.c - utilities to read a PNG file
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file contains routines that are only called from within
 * libpng itself during the course of reading an image.
 */

#define PNG_INTERNAL
#include "png.h"

#if defined(_WIN32_WCE)
/* strtod() function is not supported on WindowsCE */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
__inline double strtod(const char *nptr, char **endptr)
{
   double result = 0;
   int len;
   wchar_t *str, *end;

   len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
   str = (wchar_t *)malloc(len * sizeof(wchar_t));
   if ( NULL != str )
   {
      MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
      result = wcstod(str, &end);
      len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
      *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
      free(str);
   }
   return result;
}
#  endif
#endif

#ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
png_uint_32 /* PRIVATE */
png_get_uint_32(png_bytep buf)
{
   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
      ((png_uint_32)(*(buf + 1)) << 16) +
      ((png_uint_32)(*(buf + 2)) << 8) +
      (png_uint_32)(*(buf + 3));

   return (i);
}

#if defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_oFFs_SUPPORTED)
/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
 * data is stored in the PNG file in two's complement format, and it is
 * assumed that the machine format for signed integers is the same. */
png_int_32 /* PRIVATE */
png_get_int_32(png_bytep buf)
{
   png_int_32 i = ((png_int_32)(*buf) << 24) +
      ((png_int_32)(*(buf + 1)) << 16) +
      ((png_int_32)(*(buf + 2)) << 8) +
      (png_int_32)(*(buf + 3));

   return (i);
}
#endif /* PNG_READ_pCAL_SUPPORTED */

/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
png_uint_16 /* PRIVATE */
png_get_uint_16(png_bytep buf)
{
   png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +
      (png_uint_16)(*(buf + 1)));

   return (i);
}
#endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */

/* Read data, and (optionally) run it through the CRC. */
void /* PRIVATE */
png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
{
   png_read_data(png_ptr, buf, length);
   png_calculate_crc(png_ptr, buf, length);
}

/* Optionally skip data and then check the CRC.  Depending on whether we
   are reading a ancillary or critical chunk, and how the program has set
   things up, we may calculate the CRC on the data and print a message.
   Returns '1' if there was a CRC error, '0' otherwise. */
int /* PRIVATE */
png_crc_finish(png_structp png_ptr, png_uint_32 skip)
{
   png_size_t i;
   png_size_t istop = png_ptr->zbuf_size;

   for (i = (png_size_t)skip; i > istop; i -= istop)
   {
      png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
   }
   if (i)
   {
      png_crc_read(png_ptr, png_ptr->zbuf, i);
   }

   if (png_crc_error(png_ptr))
   {
      if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
           !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
      {
         png_chunk_warning(png_ptr, "CRC error");
      }
      else
      {
         png_chunk_error(png_ptr, "CRC error");
      }
      return (1);
   }

   return (0);
}

/* Compare the CRC stored in the PNG file with that calculated by libpng from
   the data it has read thus far. */
int /* PRIVATE */
png_crc_error(png_structp png_ptr)
{
   png_byte crc_bytes[4];
   png_uint_32 crc;
   int need_crc = 1;

   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }
   else                                                    /* critical */
   {
      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
         need_crc = 0;
   }

   png_read_data(png_ptr, crc_bytes, 4);

   if (need_crc)
   {
      crc = png_get_uint_32(crc_bytes);
      return ((int)(crc != png_ptr->crc));
   }
   else
      return (0);
}

#if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
    defined(PNG_READ_iCCP_SUPPORTED)
/*
 * Decompress trailing data in a chunk.  The assumption is that chunkdata
 * points at an allocated area holding the contents of a chunk with a
 * trailing compressed part.  What we get back is an allocated area
 * holding the original prefix part and an uncompressed version of the
 * trailing part (the malloc area passed in is freed).
 */
png_charp /* PRIVATE */
png_decompress_chunk(png_structp png_ptr, int comp_type,
                              png_charp chunkdata, png_size_t chunklength,
                              png_size_t prefix_size, png_size_t *newlength)
{
   static char msg[] = "Error decoding compressed text";
   png_charp text = NULL;
   png_size_t text_size;

   if (comp_type == PNG_COMPRESSION_TYPE_BASE)
   {
      int ret = Z_OK;
      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);
      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

      text_size = 0;
      text = NULL;

      while (png_ptr->zstream.avail_in)
      {
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END)
         {
            if (png_ptr->zstream.msg != NULL)
               png_warning(png_ptr, png_ptr->zstream.msg);
            else
               png_warning(png_ptr, msg);
            inflateReset(&png_ptr->zstream);
            png_ptr->zstream.avail_in = 0;

            if (text ==  NULL)
            {
               text_size = prefix_size + sizeof(msg) + 1;
               text = (png_charp)png_malloc(png_ptr, text_size);
               png_memcpy(text, chunkdata, prefix_size);
            }

            text[text_size - 1] = 0x00;

            /* Copy what we can of the error message into the text chunk */
            text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);
            text_size = sizeof(msg) > text_size ? text_size : sizeof(msg);
            png_memcpy(text + prefix_size, msg, text_size + 1);
            break;
         }
         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
         {
            if (text == NULL)
            {
               text_size = prefix_size +
                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               text = (png_charp)png_malloc(png_ptr, text_size + 1);
               png_memcpy(text + prefix_size, png_ptr->zbuf,
                    text_size - prefix_size);
               png_memcpy(text, chunkdata, prefix_size);
               *(text + text_size) = 0x00;
            }
            else
            {
               png_charp tmp;

               tmp = text;
               text = (png_charp)png_malloc(png_ptr, (png_uint_32)(text_size +
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
               png_memcpy(text, tmp, text_size);
               png_free(png_ptr, tmp);
               png_memcpy(text + text_size, png_ptr->zbuf,
                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               *(text + text_size) = 0x00;
            }
            if (ret == Z_STREAM_END)
               break;
            else
            {
               png_ptr->zstream.next_out = png_ptr->zbuf;
               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            }
         }
      }
      if (ret != Z_STREAM_END)
      {
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
         char umsg[50];

         if (ret == Z_BUF_ERROR)
            sprintf(umsg,"Buffer error in compressed datastream in %s chunk",
                png_ptr->chunk_name);
         else if (ret == Z_DATA_ERROR)
            sprintf(umsg,"Data error in compressed datastream in %s chunk",
                png_ptr->chunk_name);
         else
            sprintf(umsg,"Incomplete compressed datastream in %s chunk",
                png_ptr->chunk_name);
         png_warning(png_ptr, umsg);
#else
         png_warning(png_ptr,
            "Incomplete compressed datastream in chunk other than IDAT");
#endif
         text_size=prefix_size;
         if (text ==  NULL)
         {
            text = (png_charp)png_malloc(png_ptr, text_size+1);
            png_memcpy(text, chunkdata, prefix_size);
         }
         *(text + text_size) = 0x00;
      }

      inflateReset(&png_ptr->zstream);
      png_ptr->zstream.avail_in = 0;

      png_free(png_ptr, chunkdata);
      chunkdata = text;
      *newlength=text_size;
   }
   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
   {
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
      char umsg[50];

      sprintf(umsg, "Unknown zTXt compression type %d", comp_type);
      png_warning(png_ptr, umsg);
#else
      png_warning(png_ptr, "Unknown zTXt compression type");
#endif

      *(chunkdata + prefix_size) = 0x00;
      *newlength=prefix_size;
   }

   return chunkdata;
}
#endif

/* read and check the IDHR chunk */
void /* PRIVATE */
png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[13];
   png_uint_32 width, height;
   int bit_depth, color_type, compression_type, filter_type;
   int interlace_type;

   png_debug(1, "in png_handle_IHDR\n");

   if (png_ptr->mode & PNG_HAVE_IHDR)
      png_error(png_ptr, "Out of place IHDR");

   /* check the length */
   if (length != 13)
      png_error(png_ptr, "Invalid IHDR chunk");

   png_ptr->mode |= PNG_HAVE_IHDR;

   png_crc_read(png_ptr, buf, 13);
   png_crc_finish(png_ptr, 0);

   width = png_get_uint_32(buf);
   height = png_get_uint_32(buf + 4);
   bit_depth = buf[8];
   color_type = buf[9];
   compression_type = buf[10];
   filter_type = buf[11];
   interlace_type = buf[12];


   /* set internal variables */
   png_ptr->width = width;
   png_ptr->height = height;
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->interlaced = (png_byte)interlace_type;
   png_ptr->color_type = (png_byte)color_type;
   png_ptr->filter_type = (png_byte)filter_type;

   /* find number of channels */
   switch (png_ptr->color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
      case PNG_COLOR_TYPE_PALETTE:
         png_ptr->channels = 1;
         break;
      case PNG_COLOR_TYPE_RGB:
         png_ptr->channels = 3;
         break;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
         png_ptr->channels = 2;
         break;
      case PNG_COLOR_TYPE_RGB_ALPHA:
         png_ptr->channels = 4;
         break;
   }

   /* set up other useful info */
   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
   png_ptr->channels);
   png_ptr->rowbytes = ((png_ptr->width *
      (png_uint_32)png_ptr->pixel_depth + 7) >> 3);
   png_debug1(3,"bit_depth = %d\n", png_ptr->bit_depth);
   png_debug1(3,"channels = %d\n", png_ptr->channels);
   png_debug1(3,"rowbytes = %lu\n", png_ptr->rowbytes);
   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
      color_type, interlace_type, compression_type, filter_type);
}

/* read and check the palette */
void /* PRIVATE */
png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_color palette[PNG_MAX_PALETTE_LENGTH];
   int num, i;
#ifndef PNG_NO_POINTER_INDEXING
   png_colorp pal_ptr;
#endif

   png_debug(1, "in png_handle_PLTE\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before PLTE");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid PLTE after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      png_error(png_ptr, "Duplicate PLTE chunk");

   png_ptr->mode |= PNG_HAVE_PLTE;

#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      png_crc_finish(png_ptr, length);
      return;
   }
#endif

   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)
   {
      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
      {
         png_warning(png_ptr, "Invalid palette chunk");
         png_crc_finish(png_ptr, length);
         return;
      }
      else
      {
         png_error(png_ptr, "Invalid palette chunk");
      }
   }

   num = (int)length / 3;

#ifndef PNG_NO_POINTER_INDEXING
   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      pal_ptr->red = buf[0];
      pal_ptr->green = buf[1];
      pal_ptr->blue = buf[2];
   }
#else
   for (i = 0; i < num; i++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      /* don't depend upon png_color being any order */
      palette[i].red = buf[0];
      palette[i].green = buf[1];
      palette[i].blue = buf[2];
   }
#endif

   /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
      whatever the normal CRC configuration tells us.  However, if we
      have an RGB image, the PLTE can be considered ancillary, so
      we will act as though it is. */
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#endif
   {
      png_crc_finish(png_ptr, 0);
   }
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
   {
      /* If we don't want to use the data from an ancillary chunk,
         we have two options: an error abort, or a warning and we
         ignore the data in this chunk (which should be OK, since
         it's considered ancillary for a RGB or RGBA image). */
      if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))
      {
         if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)
         {
            png_chunk_error(png_ptr, "CRC error");
         }
         else
         {
            png_chunk_warning(png_ptr, "CRC error");
            return;
         }
      }
      /* Otherwise, we (optionally) emit a warning and use the chunk. */
      else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))
      {
         png_chunk_warning(png_ptr, "CRC error");
      }
   }
#endif

   png_set_PLTE(png_ptr, info_ptr, palette, num);

#if defined(PNG_READ_tRNS_SUPPORTED)
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
      {
         if (png_ptr->num_trans > (png_uint_16)num)
         {
            png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
            png_ptr->num_trans = (png_uint_16)num;
         }
         if (info_ptr->num_trans > (png_uint_16)num)
         {
            png_warning(png_ptr, "Truncating incorrect info tRNS chunk length");
            info_ptr->num_trans = (png_uint_16)num;
         }
      }
   }
#endif

}

void /* PRIVATE */
png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_debug(1, "in png_handle_IEND\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
   {
      png_error(png_ptr, "No image in file");

      /* to quiet compiler warnings about unused info_ptr */
      if (info_ptr == NULL)
         return;
   }

   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);

   if (length != 0)
   {
      png_warning(png_ptr, "Incorrect IEND chunk length");
   }
   png_crc_finish(png_ptr, length);
}

#if defined(PNG_READ_gAMA_SUPPORTED)
void /* PRIVATE */
png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_fixed_point igamma;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float file_gamma;
#endif
   png_byte buf[4];

   png_debug(1, "in png_handle_gAMA\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before gAMA");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid gAMA after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place gAMA chunk");

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
#if defined(PNG_READ_sRGB_SUPPORTED)
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate gAMA chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 4)
   {
      png_warning(png_ptr, "Incorrect gAMA chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   if (png_crc_finish(png_ptr, 0))
      return;

   igamma = (png_fixed_point)png_get_uint_32(buf);
   /* check for zero gamma */
   if (igamma == 0)
      {
         png_warning(png_ptr,
           "Ignoring gAMA chunk with gamma=0");
         return;
      }

#if defined(PNG_READ_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      if(igamma < 45000L || igamma > 46000L)
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
         fprintf(stderr, "gamma = (%d/100000)\n", (int)igamma);
#endif
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */

#ifdef PNG_FLOATING_POINT_SUPPORTED
   file_gamma = (float)igamma / (float)100000.0;
#  ifdef PNG_READ_GAMMA_SUPPORTED
     png_ptr->gamma = file_gamma;
#  endif
     png_set_gAMA(png_ptr, info_ptr, file_gamma);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
#endif
}
#endif

#if defined(PNG_READ_sBIT_SUPPORTED)
void /* PRIVATE */
png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_size_t truelen;
   png_byte buf[4];

   png_debug(1, "in png_handle_sBIT\n");

   buf[0] = buf[1] = buf[2] = buf[3] = 0;

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sBIT");
   else if (png_ptr->mode & P