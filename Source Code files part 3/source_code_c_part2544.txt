
	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPeerAddress"

HRESULT DIRECTNETOBJECT::DN_GetPeerAddress(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CNameTableEntry		*pNTEntry;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;

	DPF(2,"Parameters : pInterface [0x%p], dpnid [0x%lx], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,ppAddress,dwFlags);

	RIP_ON_NOT_TRUE( "GetPeerAddress() Error validating params", SUCCEEDED( DN_ValidateGetPeerAddress( pInterface , dpnid, ppAddress, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetPeerAddress() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) &&
    	   !(pdnObject->dwFlags & DN_OBJECT_FLAG_DISCONNECTING) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	

	pNTEntry = NULL;
	pAddress = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	if ((pNTEntry->GetAddress() == NULL) || (pNTEntry->IsGroup()) || !pNTEntry->IsAvailable())
	{
	    DPFERR( "Invalid ID specified.  Not a player" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->GetAddress()->Duplicate(ppAddress);

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\pools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:    DirectNet Fixed Pools
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/15/00	mjn		Created
 *	01/19/00	mjn		Added SyncEventNew()
 *	02/29/00	mjn		Added ConnectionNew()
 *	03/02/00	mjn		Added GroupConnectionNew()
 *	04/08/00	mjn		Added AsyncOpNew()
 *	07/30/00	mjn		Added PendingDeletionNew()
 *	07/31/00	mjn		Added QueuedMsgNew()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__POOLS_H__
#define	__POOLS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

// DirectNet - Fixed Pools
HRESULT RefCountBufferNew(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwBufferSize,
						  CRefCountBuffer **const ppNewRefCountBuffer);

HRESULT SyncEventNew(DIRECTNETOBJECT *const pdnObject,
					 CSyncEvent **const ppNewSyncEvent);

HRESULT ConnectionNew(DIRECTNETOBJECT *const pdnObject,
					  CConnection **const ppNewConnection);

HRESULT GroupConnectionNew(DIRECTNETOBJECT *const pdnObject,
						   CGroupConnection **const ppNewGroupConnection);

HRESULT GroupMemberNew(DIRECTNETOBJECT *const pdnObject,
					   CGroupMember **const ppNewGroupMember);

HRESULT NameTableEntryNew(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry **const ppNewNameTableEntry);

HRESULT AsyncOpNew(DIRECTNETOBJECT *const pdnObject,
				   CAsyncOp **const ppNewAsyncOp);

HRESULT PendingDeletionNew(DIRECTNETOBJECT *const pdnObject,
						   CPendingDeletion **const ppNewPendingDeletion);

HRESULT QueuedMsgNew(DIRECTNETOBJECT *const pdnObject,
					 CQueuedMsg **const ppNewQueuedMsg);

HRESULT WorkerJobNew(DIRECTNETOBJECT *const pdnObject,
					 CWorkerJob **const ppNewWorkerJob);

HRESULT NameTableOpNew(DIRECTNETOBJECT *const pdnObject,
					   CNameTableOp **const ppNewNameTableOp);


#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\protocol.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Protocol.h
 *  Content:    Direct Net Protocol interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/01/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PROTOCOL_H__
#define	__PROTOCOL_H__

#include "dpprot.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
extern IDirectPlay8ProtocolVtbl DN_ProtocolVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectPlay8Protocol
//
STDMETHODIMP DN_ProtocolInitialize(IDirectPlay8Protocol *pInterface,PDN_PROTOCOL_INTERFACE_VTBL pfVTbl);
STDMETHODIMP DN_ProtocolAddSP(IDirectPlay8Protocol *pInterface, IDP8ServiceProvider *const pISP);
STDMETHODIMP DN_ProtocolConnect(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pLocal_Address, IDirectPlay8Address *const pRemote_Address, DWORD Timeout, ULONG Flags, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolListen(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pAddress, ULONG Flags, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolSendData(IDirectPlay8Protocol *pInterface, HANDLE Dest, UINT BufCount, PBUFFERDESC Buffers, UINT Priority, UINT Timeout, ULONG Flags, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolDisconnect(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolAbort(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint);
STDMETHODIMP DN_ProtocolCancel(IDirectPlay8Protocol *pInterface, HANDLE hHandle);
STDMETHODIMP DN_ProtocolTerminate(IDirectPlay8Protocol *pInterface);
STDMETHODIMP DN_ProtocolDebug(IDirectPlay8Protocol *pInterface, UINT Opcode, HANDLE hEndPoint, PVOID Buffer);
STDMETHODIMP DN_ProtocolEnumAdapters(IDirectPlay8Protocol *pInterface, PVOID pData);
STDMETHODIMP DN_ProtocolReleaseReceiveBuffer(IDirectPlay8Protocol *pInterface, HANDLE hBuffer);
STDMETHODIMP DN_ProtocolGetEPCaps(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID pBuffer);

#endif	// __PROTOCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\queuedmsg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       QueuedMsg.cpp
 *  Content:    Queued Message Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/31/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CQueuedMsg::SetAsyncOp"

void CQueuedMsg::SetAsyncOp(CAsyncOp *const pAsyncOp)
{
	if (pAsyncOp)
	{
		pAsyncOp->AddRef();
	}
	m_pAsyncOp = pAsyncOp;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\queuedmsg.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       QueuedMsg.h
 *  Content:    Queued Message Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/31/00	mjn		Created
 *	09/12/00	mjn		Added m_OpType
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__QUEUED_MSG_H__
#define	__QUEUED_MSG_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	QUEUED_MSG_FLAG_VOICE		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CQueuedMsg;
template< class CQueuedMsg > class CLockedContextClassFixedPool;

typedef enum
{
	UNKNOWN,
	RECEIVE,
	ADD_PLAYER_TO_GROUP,
	REMOVE_PLAYER_FROM_GROUP,
	UPDATE_INFO
} QUEUED_MSG_TYPE;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Queued Messages

class CQueuedMsg
{
	STDNEWDELETE

public:
	CQueuedMsg()				// Constructor
		{
			m_Sig[0] = 'Q';
			m_Sig[1] = 'M';
			m_Sig[2] = 'S';
			m_Sig[3] = 'G';
		};

	~CQueuedMsg() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CQueuedMsg::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);

			m_OpType = UNKNOWN;
			m_dwFlags = 0;
			m_pBuffer = NULL;
			m_dwBufferSize = 0;
			m_hCompletionOp = 0;
			m_pAsyncOp = NULL;
			m_bilinkQueuedMsgs.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	void ReturnSelfToPool( void )
		{
			m_pdnObject->m_pFPOOLQueuedMsg->Release( this );
		};

	void SetOpType( const QUEUED_MSG_TYPE OpType )
		{
			m_OpType = OpType;
		};

	QUEUED_MSG_TYPE GetOpType( void )
		{
			return( m_OpType );
		};

	void MakeVoiceMessage( void )
		{
			m_dwFlags |= QUEUED_MSG_FLAG_VOICE;
		};

	BOOL IsVoiceMessage( void )
		{
			if (m_dwFlags & QUEUED_MSG_FLAG_VOICE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetBuffer( BYTE *const pBuffer )
		{
			m_pBuffer = pBuffer;
		};

	BYTE *GetBuffer( void )
		{
			return( m_pBuffer );
		};

	void SetBufferSize( const DWORD dwBufferSize )
		{
			m_dwBufferSize = dwBufferSize;
		};

	DWORD GetBufferSize( void )
		{
			return( m_dwBufferSize );
		};

	void SetCompletionOp( const DPNHANDLE hCompletionOp)
		{
			m_hCompletionOp = hCompletionOp;
		};

	DPNHANDLE GetCompletionOp( void )
		{
			return( m_hCompletionOp );
		};

	void CQueuedMsg::SetAsyncOp( CAsyncOp *const pAsyncOp );

	CAsyncOp *GetAsyncOp( void )
		{
			return( m_pAsyncOp );
		};

	CBilink				m_bilinkQueuedMsgs;

private:
	BYTE				m_Sig[4];			// Signature
	QUEUED_MSG_TYPE		m_OpType;
	DWORD	volatile	m_dwFlags;

	BYTE				*m_pBuffer;
	DWORD				m_dwBufferSize;

	DPNHANDLE			m_hCompletionOp;

	CAsyncOp			*m_pAsyncOp;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __QUEUED_MSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\protocol.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Protocol.cpp
 *  Content:    DNET protocol interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/01/00	ejs		Created
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	STDMETHODIMP ProtocolQueryInterface( IDirectPlay8Protocol *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ProtocolAddRef( IDirectPlay8Protocol *pInterface );
typedef	STDMETHODIMP_(ULONG)	ProtocolRelease( IDirectPlay8Protocol *pInterface );

//**********************************************************************
// Function definitions
//**********************************************************************


//	DN_ProtocolInitialize
//
//	Initialize protocol

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolInitialize"
STDMETHODIMP DN_ProtocolInitialize(IDirectPlay8Protocol *pInterface, PVOID pContext, PDN_PROTOCOL_INTERFACE_VTBL pfVTbl)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPProtocolInitialize( pContext, pdnObject->pdnProtocolData, pfVTbl );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolShutdown"
STDMETHODIMP DN_ProtocolShutdown(IDirectPlay8Protocol *pInterface)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPProtocolShutdown(pdnObject->pdnProtocolData);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolAddSP"
STDMETHODIMP DN_ProtocolAddSP(IDirectPlay8Protocol *pInterface, IDP8ServiceProvider * const pISP, HANDLE* pContext)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPAddServiceProvider(pdnObject->pdnProtocolData, pISP, pContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolRemoveSP"
STDMETHODIMP DN_ProtocolRemoveSP(IDirectPlay8Protocol *pInterface, const HANDLE hSPHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPRemoveServiceProvider(pdnObject->pdnProtocolData, hSPHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolConnect"
STDMETHODIMP DN_ProtocolConnect(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pLocal_Address, IDirectPlay8Address *const pRemote_Address, const HANDLE hSPHandle, DWORD Timeout, ULONG Flags, PVOID Context, PHANDLE pHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPConnect(pdnObject->pdnProtocolData, pLocal_Address, pRemote_Address, hSPHandle, Timeout, Flags, Context, pHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolListen"
STDMETHODIMP DN_ProtocolListen(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pAddress, const HANDLE hSPHandle, ULONG Flags, PVOID Context, PHANDLE Handle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPListen(pdnObject->pdnProtocolData, pAddress, hSPHandle, Flags, Context, Handle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolSendData"
STDMETHODIMP DN_ProtocolSendData(IDirectPlay8Protocol *pInterface, HANDLE Dest, UINT BufCount, PBUFFERDESC Buffers, UINT Priority, UINT Timeout, ULONG Flags, PVOID Context, PHANDLE Handle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPSendData(pdnObject->pdnProtocolData, Dest, BufCount, Buffers, Priority, Timeout, Flags, Context, Handle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolDisconnectEP"
STDMETHODIMP DN_ProtocolDisconnectEP(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID pContext, PHANDLE pHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPDisconnectEndPoint(pdnObject->pdnProtocolData, hEndPoint, pContext, pHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolAbortEP"
STDMETHODIMP DN_ProtocolAbortEP(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPAbortEndPoint(pdnObject->pdnProtocolData, hEndPoint);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolCancel"
STDMETHODIMP DN_ProtocolCancel(IDirectPlay8Protocol *pInterface, HANDLE hHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPCancelCommand(pdnObject->pdnProtocolData, hHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolReleaseReceiveBuffer"
STDMETHODIMP DN_ProtocolReleaseReceiveBuffer(IDirectPlay8Protocol *pInterface, HANDLE hBuffer)
{
	return DNPReleaseReceiveBuffer(hBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetEPCaps"
STDMETHODIMP DN_ProtocolGetEPCaps(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID pBuffer)
{
	return DNPGetEPCaps(hEndPoint, (PDPN_CONNECTION_INFO) pBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolDebug"
STDMETHODIMP DN_ProtocolDebug(IDirectPlay8Protocol *pInterface, UINT Opcode, HANDLE hEndPoint, PVOID Buffer)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNP_Debug(pdnObject->pdnProtocolData, Opcode, hEndPoint, Buffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetCaps"
STDMETHODIMP DN_ProtocolGetCaps(IDirectPlay8Protocol *pInterface, PDPN_CAPS pCaps)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPGetProtocolCaps(pdnObject->pdnProtocolData, pCaps);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetCaps"
STDMETHODIMP DN_ProtocolSetCaps(IDirectPlay8Protocol *pInterface, const PDPN_CAPS pCaps)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPSetProtocolCaps(pdnObject->pdnProtocolData, pCaps);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolEnumQuery"
STDMETHODIMP DN_ProtocolEnumQuery(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pHostAddress, IDirectPlay8Address *const pDeviceAddress, const HANDLE hSPHandle, BUFFERDESC *const pBuffers, const DWORD dwBufferCount, const DWORD dwRetryCount, const DWORD dwRetryInterval, const DWORD dwTimeout, const DWORD dwFlags, void *const pUserContext, HANDLE *const pCommandHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPEnumQuery( pdnObject->pdnProtocolData, pHostAddress, pDeviceAddress, hSPHandle, pBuffers, dwBufferCount, dwRetryCount, dwRetryInterval, dwTimeout, dwFlags, pUserContext, pCommandHandle );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolEnumRespond"
STDMETHODIMP DN_ProtocolEnumRespond(IDirectPlay8Protocol *pInterface, const HANDLE hSPHandle, const HANDLE hQueryHandle, BUFFERDESC *const pResponseBuffers, const DWORD dwResponseBufferCount, const DWORD dwFlags, void *const pUserContext, HANDLE *const pCommandHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPEnumRespond( pdnObject->pdnProtocolData, hSPHandle, hQueryHandle, pResponseBuffers, dwResponseBufferCount, dwFlags, pUserContext, pCommandHandle );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolCrackEPD"
STDMETHODIMP DN_ProtocolCrackEPD(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, long Flags, IDirectPlay8Address** ppAddr )
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	SPGETADDRESSINFODATA SPData;
	SPData.Flags = (SP_GET_ADDRESS_INFO_FLAGS)Flags;

	HRESULT hr = DNPCrackEndPointDescriptor( hEndPoint, &SPData );
	*ppAddr = SPData.pAddress;
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetListenAddressInfo"
STDMETHODIMP DN_ProtocolGetListenAddressInfo(IDirectPlay8Protocol *pInterface, HANDLE hCommand, long Flags, IDirectPlay8Address** ppAddr )
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	SPGETADDRESSINFODATA SPData;
	SPData.Flags = (SP_GET_ADDRESS_INFO_FLAGS)Flags;

	HRESULT hr = DNPGetListenAddressInfo( hCommand, &SPData );
	*ppAddr = SPData.pAddress;
	return hr;
}

IDirectPlay8ProtocolVtbl DN_ProtocolVtbl =
{
	(ProtocolQueryInterface*)		DN_QueryInterface,
	(ProtocolAddRef*)				DN_AddRef,
	(ProtocolRelease*)				DN_Release,
							DN_ProtocolInitialize,
							DN_ProtocolShutdown,
							DN_ProtocolAddSP,
							DN_ProtocolRemoveSP,
							DN_ProtocolConnect,
							DN_ProtocolListen,
							DN_ProtocolSendData,
							DN_ProtocolDisconnectEP,
							DN_ProtocolAbortEP,
							DN_ProtocolCancel,
							DN_ProtocolReleaseReceiveBuffer,
							DN_ProtocolGetEPCaps,
							DN_ProtocolGetCaps,
							DN_ProtocolSetCaps,
							DN_ProtocolEnumQuery,
							DN_ProtocolEnumRespond,
							DN_ProtocolCrackEPD,
							DN_ProtocolGetListenAddressInfo,
							DN_ProtocolDebug,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\receive.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Receive.h
 *  Content:    DirectNet receive user data
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/27/00	mjn		Created
 *	04/20/00	mjn		ReceiveBuffers use CAsyncOp
 *	08/02/00	mjn		Added dwFlags to DNReceiveUserData()
 *				mjn		Added DNSendUserProcessCompletion()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__RECEIVE_H__
#define	__RECEIVE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DNReceiveUserData(DIRECTNETOBJECT *const pdnObject,
						  const DPNID dpnidSender,
						  BYTE *const pBufferData,
						  const DWORD dwBufferSize,
						  const HANDLE hProtocol,
						  CRefCountBuffer *const pRefCountBuffer,
						  const DPNHANDLE hCompletionOp,
						  const DWORD dwFlags);

HRESULT DNSendUserProcessCompletion(DIRECTNETOBJECT *const pdnObject,
									CConnection *const pConnection,
									const DPNHANDLE hCompletionOp);

void DNFreeProtocolBuffer(void *const pv,void *const pvBuffer);

void DNCompleteReceiveBuffer(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __RECEIVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\request.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Request.cpp
 *  Content:    Requested operations
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/18/00	mjn		Created
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/16/00	mjn		Better locking during User notifications
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/26/00	mjn		Replaced DPNADDCLIENTTOGROUP_SYNC DPNADDPLAYERTOGROUP_SYNC
 *				mjn		Replaced DPNREMOVECLIENTFROMGROUP_SYNC with DPNREMOVEPLAYERFROMGROUP_SYNC
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added DNProcessFailedRequest()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Added DNRequestIntegrityCheck(),DNHostCheckIntegrity(),DNProcessCheckIntegrity(),DNHostFixIntegrity()
 *	08/08/00	mjn		Mark groups created after CREATE_GROUP
 *	08/09/00	mjn		Made requests and host operations more robust for host migration
 *	08/15/00	mjn		Keep request operations if HostPlayer or connection is unavailable
 *	09/05/00	mjn		Removed dwIndex from CNameTable::InsertEntry()
 *	09/13/00	mjn		Perform queued operations after creating group in DNConnectToHost2()
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	10/10/00	mjn		Return DPN_OK from Host operations if unable to get reference on local player
 *	10/13/00	mjn		Update version if FindPlayer fails in DNProcessXXX() functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestCreateGroup"

HRESULT DNRequestCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 const PWSTR pwszName,
							 const DWORD dwNameSize,
							 const PVOID pvData,
							 const DWORD dwDataSize,
							 const DWORD dwGroupFlags,
							 void *const pvGroupContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pMsg;

	DPF(4,"Parameters: pwszName [%S], pvData [0x%p], dwDataSize [%ld], dwGroupFlags [0x%lx], pvUserContext [0x%p], dwFlags [0x%lx]",
		pwszName,pvData,dwDataSize,dwGroupFlags,pvUserContext,dwFlags);

	DNASSERT(pdnObject != NULL);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//

	// Create buffer
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP) + dwNameSize + dwDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP))) != DPN_OK)
	{
		DPFERR("Could not reserve space at front of buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Flags
	pMsg->dwGroupFlags = dwGroupFlags;
	pMsg->dwInfoFlags = 0;

	// Add Name
	if (dwNameSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
		{
			DPFERR("Could not add Name to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwNameOffset = packedBuffer.GetTailOffset();
		pMsg->dwNameSize = dwNameSize;
		pMsg->dwInfoFlags |= DPNINFO_NAME;
	}
	else
	{
		pMsg->dwNameOffset = 0;
		pMsg->dwNameSize = 0;
	}

	// Add Data
	if (dwDataSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
		{
			DPFERR("Could not add Data to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwDataOffset = packedBuffer.GetTailOffset();
		pMsg->dwDataSize = dwDataSize;
		pMsg->dwInfoFlags |= DPNINFO_DATA;
	}
	else
	{
		pMsg->dwDataOffset = 0;
		pMsg->dwDataSize = 0;
	}

		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_CREATE_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	pRequest->SetContext( pvGroupContext );
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestDestroyGroup"

HRESULT DNRequestDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidGroup,
							  PVOID const pvUserContext,
							  DPNHANDLE *const phAsyncOp,
							  const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CRefCountBuffer		*pRefCountBuffer;
	CSyncEvent			*pSyncEvent;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP	*pMsg;

	DPF(4,"Parameters: dpnidGroup [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;

		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_DESTROY_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestAddPlayerToGroup"

HRESULT DNRequestAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  const DPNID dpnidGroup,
								  const DPNID dpnidPlayer,
								  PVOID const pvUserContext,
								  DPNHANDLE *const phAsyncOp,
								  const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP	*pMsg;

	DPF(4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;
	pMsg->dpnidPlayer = dpnidPlayer;

		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestDeletePlayerFromGroup"

HRESULT DNRequestDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   const DPNID dpnidGroup,
									   const DPNID dpnidPlayer,
									   PVOID const pvUserContext,
									   DPNHANDLE *const phAsyncOp,
									   const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPF(4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		return(hResultCode);
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;
	pMsg->dpnidPlayer = dpnidPlayer;

		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestUpdateInfo"

HRESULT DNRequestUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							const DPNID dpnid,
							const PWSTR pwszName,
							const DWORD dwNameSize,
							const PVOID pvData,
							const DWORD dwDataSize,
							const DWORD dwInfoFlags,
							PVOID const pvUserContext,
							DPNHANDLE *const phAsyncOp,
							const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pMsg;

	DPF(4,"Parameters: pwszName [%S], pvData [0x%p], dwInfoFlags [%ld], dwGroupFlags [0x%lx], pvUserContext [0x%p], dwFlags [0x%lx]",
		pwszName,pvData,dwDataSize,dwInfoFlags,pvUserContext,dwFlags);

	DNASSERT(pdnObject != NULL);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	// Create buffer
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO) + dwNameSize + dwDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		return(hResultCode);
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO))) != DPN_OK)
	{
		DPFERR("Could not reserve space at front of buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
		return(hResultCode);
	}

	// Add Name
	if ((dwInfoFlags & DPNINFO_NAME) && dwNameSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
		{
			DPFERR("Could not add Name to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
			return(hResultCode);
		}
		pMsg->dwNameOffset = packedBuffer.GetTailOffset();
		pMsg->dwNameSize = dwNameSize;
	}
	else
	{
		pMsg->dwNameOffset = 0;
		pMsg->dwNameSize = 0;
	}

	// Add Data
	if ((dwInfoFlags & DPNINFO_DATA) && dwDataSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
		{
			DPFERR("Could not add Data to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
			return(hResultCode);
		}
		pMsg->dwDataOffset = packedBuffer.GetTailOffset();
		pMsg->dwDataSize = dwDataSize;
	}
	else
	{
		pMsg->dwDataOffset = 0;
		pMsg->dwDataSize = 0;
	}

	// Remaining fields
	pMsg->dpnid = dpnid;
	pMsg->dwInfoFlags = dwInfoFlags;

		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_UPDATE_INFO,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNRequestIntegrityCheck
//
//	In the case where a non-host player detects a disconnect from another non-host player,
//	the detecting player will request the host to perform an integrity check to prevent a
//	disjoint game from occurring.  The host will ping the disconnected player, and if a
//	response is received, the host will disconnect the detecting player.  If no response
//	is received, presumably the disconnected player is in fact dropping, and a DESTROY_PLAYER
//	message will be sent out.

#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestIntegrityCheck"

HRESULT DNRequestIntegrityCheck(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidTarget)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pMsg;

	DPF(6,"Parameters: dpnidTarget [0x%lx]",dpnidTarget);

	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pNTEntry = NULL;
	pConnection = NULL;
	pRequest = NULL;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Closing - aborting");
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Determine if player is still in NameTable - maybe the Host has already deleteed him
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidTarget,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Target player not in NameTable");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable())
	{
		pNTEntry->Unlock();
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Create request message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidTarget = dpnidTarget;

	//
	//	Get host connection for request operation
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Send request
	//
	if ((hResultCode = DNPerformRequest(pdnObject,
										DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,
										pRefCountBuffer->BufferDescAddress(),
										pConnection,
										NULL,
										&pRequest)) != DPNERR_PENDING)
	{
		DPFERR("Could not perform request (INTEGRITY_CHECK)");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pRequest->Release();
	pRequest = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	goto Exit;
}


//	HOST OPERATIONS
//
//	The Host will perform an operation and if in PEER mode, will inform
//	other players of the operation.   These messages will contain the
//	DPNID of the player requesting the operation along with the HANDLE
//	supplied with the request.


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostProcessRequest"

HRESULT DNHostProcessRequest(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 PVOID const pv,
							 const DPNID dpnidRequesting)
{
	HRESULT	hResultCode;
	DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION			*pRequest;

	DPF(6,"Parameters: dwMsgId [0x%lx], pv [0x%p], dpnidRequesting [0x%lx]",
			dwMsgId,pv,dpnidRequesting);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);
	DNASSERT(dpnidRequesting != 0);

	pRequest = static_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pv);

	switch(dwMsgId)
	{
	case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
		{
			DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pCreateGroup;
			PWSTR	pwszName;
			PVOID	pvData;

			DPF(7,"DN_MSG_INTERNAL_REQ_CREATE_GROUP");

			pCreateGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(pRequest + 1);
			if (pCreateGroup->dwNameSize)
			{
				pwszName = reinterpret_cast<WCHAR*>(reinterpret_cast<BYTE*>(pCreateGroup) + pCreateGroup->dwNameOffset);
			}
			else
			{
				pwszName = NULL;
			}
			if (pCreateGroup->dwDataSize)
			{
				pvData = static_cast<void*>(reinterpret_cast<BYTE*>(pCreateGroup) + pCreateGroup->dwDataOffset);
			}
			else
			{
				pvData = NULL;
			}
			DNHostCreateGroup(	pdnObject,
								pwszName,
								pCreateGroup->dwNameSize,
								pvData,
								pCreateGroup->dwDataSize,
								pCreateGroup->dwInfoFlags,
								pCreateGroup->dwGroupFlags,
								NULL,
								NULL,
								dpnidRequesting,
								pRequest->hCompletionOp,
								NULL,
								0 );

			break;
		}

	case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
		{
			DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP	*pDestroyGroup;

			DPF(7,"DN_MSG_INTERNAL_REQ_DESTROY_GROUP");

			pDestroyGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP*>(pRequest + 1);

			DNHostDestroyGroup(	pdnObject,
								pDestroyGroup->dpnidGroup,
								NULL,
								dpnidRequesting,
								pRequest->hCompletionOp,
								NULL,
								0 );
								
			break;
		}

	case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		{
			DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP	*pAddPlayerToGroup;

			DPF(7,"DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP");

			pAddPlayerToGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP*>(pRequest + 1);

			DNHostAddPlayerToGroup(	pdnObject,
									pAddPlayerToGroup->dpnidGroup,
									pAddPlayerToGroup->dpnidPlayer,
									NULL,
									dpnidRequesting,
									pRequest->hCompletionOp,
									NULL,
									0 );

			break;
		}

	case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:
		{
			DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP	*pDeletePlayerFromGroup;

			DPF(7,"DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP");

			pDeletePlayerFromGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP*>(pRequest + 1);

			DNHostDeletePlayerFromGroup(pdnObject,
										pDeletePlayerFromGroup->dpnidGroup,
										pDeletePlayerFromGroup->dpnidPlayer,
										NULL,
										dpnidRequesting,
										pRequest->hCompletionOp,
										NULL,
										0);

			break;
		}

	case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
		{
			DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pUpdateInfo;
			PWSTR	pwszName;
			PVOID	pvData;

			DPF(7,"DN_MSG_INTERNAL_REQ_UPDATE_INFO");

			pUpdateInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(pRequest + 1);
			if (pUpdateInfo->dwNameSize)
			{
				pwszName = reinterpret_cast<WCHAR*>(reinterpret_cast<BYTE*>(pUpdateInfo) + pUpdateInfo->dwNameOffset);
			}
			else
			{
				pwszName = NULL;
			}
			if (pUpdateInfo->dwDataSize)
			{
				pvData = reinterpret_cast<void*>(reinterpret_cast<BYTE*>(pUpdateInfo) + pUpdateInfo->dwDataOffset);
			}
			else
			{
				pvData = NULL;
			}
			DNHostUpdateInfo(pdnObject,
							pUpdateInfo->dpnid,
							pwszName,
							pUpdateInfo->dwNameSize,
							pvData,
							pUpdateInfo->dwDataSize,
							pUpdateInfo->dwInfoFlags,
							NULL,
							dpnidRequesting,
							pRequest->hCompletionOp,
							NULL,
							0);

			break;
		}

	case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
		{
			DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pIntegrityCheck;
			CNameTableEntry	*pLocalPlayer;

			DPF(7,"DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK");

			pIntegrityCheck = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>(pRequest + 1);

			//
			//	If we submitted this request, this is being called during host migration,
			//	so remove it from the handle table since we will destroy the dropped player anyways.
			//	Otherwise, we will perform the integrity check
			//

			if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
			{
				if (pLocalPlayer->GetDPNID() == dpnidRequesting)
				{
					pdnObject->HandleTable.Destroy( pRequest->hCompletionOp );
				}
				else
				{
					DNHostCheckIntegrity(pdnObject,pIntegrityCheck->dpnidTarget,dpnidRequesting);
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}
			break;
		}

	default:
		{
			DPFERR("How did we get here ?");
			DNASSERT(FALSE);
		}
	}

	DPF(6,"Returning: DPN_OK");
	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostFailRequest"

void DNHostFailRequest(DIRECTNETOBJECT *const pdnObject,
					   const DPNID dpnid,
					   const DPNHANDLE hCompletionOp,
					   const HRESULT hr)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CRefCountBuffer	*pRefCountBuffer;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_REQUEST_FAILED	*pMsg;

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != NULL);

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pConnection = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQUEST_FAILED),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQUEST_FAILED*>(pRefCountBuffer->GetBufferAddress());
	pMsg->hCompletionOp = hCompletionOp;
	pMsg->hResultCode = hr;

	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
	{
		hResultCode = DNSendMessage(pdnObject,
									pConnection,
									DN_MSG_INTERNAL_REQUEST_FAILED,
									dpnid,
									pRefCountBuffer->BufferDescAddress(),
									pRefCountBuffer,
									0,
									DN_SENDFLAGS_RELIABLE,
									NULL,
									NULL);

		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	return;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNHostCreateGroup"

HRESULT	DNHostCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  PWSTR pwszName,
						  const DWORD dwNameSize,
						  void *const pvData,
						  const DWORD dwDataSize,
						  const DWORD dwInfoFlags,
						  const DWORD dwGroupFlags,
						  void *const pvGroupContext,
						  void *const pvUserContext,
						  const DPNID dpnidOwner,
						  const DPNHANDLE hCompletionOp,
						  DPNHANDLE *const phAsyncOp,
						  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	void			*pvContext;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CPackedBuffer	packedBuffer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CAsyncOp		*pRequest;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_CREATE_GROUP	*pMsg;

	DPF(4,"Parameters: pwszName [0x%p], dwNameSize [%ld], pvData [0x%p], dwDataSize [%ld], dwInfoFlags [0x%lx], dwGroupFlags [0x%lx], pvGroupContext [0x%p], pvUserContext [0x%p], dpnidOwner [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags,dwGroupFlags,pvGroupContext,pvUserContext,dpnidOwner,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);

	//
	//	If this is called from DN_CreateGroup(),
	//			hCompletion=0
	//			dpnidOwner = DPNID of Host
	//			pvGroupContext is valid
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidOwner = DPNID of requesting player
	//			pvGroupContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidOwner = DPNID of THIS (now Host) player
	//			pvGroupContext is invalid
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;
	pHandleParent = NULL;
	pRequest = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidOwner)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Get group context if this is a Host Migration re-try by finding REQUEST AsyncOp
	//
	if ((fHostRequested) && (hCompletionOp != 0))
	{
		if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pvContext = pRequest->GetContext();
		pRequest->Release();
		pRequest = NULL;
	}
	else
	{
		pvContext = pvGroupContext;
	}

	//
	//	Create and fill in NameTableEntry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pNTEntry->MakeGroup();

	// This function takes the lock internally
	pNTEntry->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags, FALSE);

	pNTEntry->SetOwner( dpnidOwner );
	pNTEntry->SetContext( pvContext );

	if (dwGroupFlags & DPNGROUP_AUTODESTRUCT)
	{
		pNTEntry->MakeAutoDestructGroup();
	}

	//
	//	Add Group to NameTable
	//
#pragma TODO(minara,"Check to see if Autodestruct owner is still in NameTable")
#pragma TODO(minara,"This should happen after getting a NameTable version number - as DESTROY player will clean up")
#pragma TODO(minara,"We should send out a NOP in this case")

	hrOperation = pdnObject->NameTable.AddEntry(pNTEntry);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not add NameTableEntry to NameTable");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidOwner,hCompletionOp,hrOperation);
		}
	}
	else
	{
		BOOL	fNotify;

		fNotify = FALSE;
		pNTEntry->Lock();
		if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting())
		{
			pNTEntry->MakeAvailable();
			pNTEntry->NotifyAddRef();
			pNTEntry->NotifyAddRef();
			pNTEntry->SetInUse();
			fNotify = TRUE;
		}
		pNTEntry->Unlock();

		if (fNotify)
		{
			DNUserCreateGroup(pdnObject,pNTEntry);

			pNTEntry->PerformQueuedOperations();

			pdnObject->NameTable.PopulateGroup( pNTEntry );
		}

		//
		//	Send CREATE_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Determine size of message
			packedBuffer.Initialize(NULL,0);
			packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP));
			pNTEntry->PackEntryInfo(&packedBuffer);

			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
			pMsg = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(packedBuffer.GetHeadAddress());
			if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP))) != DPN_OK)
			{
				DPFERR("Could not reserve front of buffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPN_OK)
			{
				DPFERR("Could not pack NameTableEntry");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg->dpnidRequesting = dpnidOwner;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND CreateGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_CREATE_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( pNTEntry->GetVersion() );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (hrOperation == DPN_OK)
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp, &pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidOwner,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDestroyGroup"

HRESULT	DNHostDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnid,
						   void *const pvUserContext,
						   const DPNID dpnidRequesting,
						   const DPNHANDLE hCompletionOp,
						   DPNHANDLE *const phAsyncOp,
						   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_DESTROY_GROUP	*pMsg;

	DPF(4,"Parameters: dpnid [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnid,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_DestroyGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Remove Group from NameTable
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.DeleteGroup(dpnid,&dwVersion);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not delete group from NameTable");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send DESTROY_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DESTROY_GROUP),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnid;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND DestroyGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DESTROY_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (hrOperation == DPN_OK)
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostAddPlayerToGroup"

HRESULT	DNHostAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnidGroup,
							   const DPNID dpnidPlayer,
							   void *const pvUserContext,
							   const DPNID dpnidRequesting,
							   const DPNHANDLE hCompletionOp,
							   DPNHANDLE *const phAsyncOp,
							   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pPlayer;
	CNameTableEntry	*pGroup;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP	*pMsg;

	DPF(4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);
	DNASSERT(dpnidPlayer != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_AddPlayerToGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	See if the player and group are still in the NameTable
	//	(this has to happen after we set fHostRequested so we can gracefully handle errors)
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDGROUP;
		hrOperation = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		hrOperation = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Add Player To Group
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.AddPlayerToGroup(pGroup,pPlayer,&dwVersion);

	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not add player to group");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send ADD_PLAYER_TO_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnidGroup;
			pMsg->dpnidPlayer = dpnidPlayer;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND AddPlayerToGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (hrOperation == DPN_OK)
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDeletePlayerFromGroup"

HRESULT	DNHostDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									const DPNID dpnidGroup,
									const DPNID dpnidPlayer,
									void *const pvUserContext,
									const DPNID dpnidRequesting,
									const DPNHANDLE hCompletionOp,
									DPNHANDLE *const phAsyncOp,
									const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPF(4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);
	DNASSERT(dpnidPlayer != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_DeletePlayerFromGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}

	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	See if the player and group are still in the NameTable
	//	(this has to happen after we set fHostRequested so we can gracefully handle errors)
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDGROUP;
		hrOperation = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		hrOperation = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Delete Player From Group
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.RemovePlayerFromGroup(pGroup,pPlayer,&dwVersion);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not delete player from group");
		DisplayDNError(0,hrOperation);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send DELETE_PLAYER_FROM_GROUP message if successful
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnidGroup;
			pMsg->dpnidPlayer = dpnidPlayer;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND DeletePlayerFromGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (hrOperation == DPN_OK)
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostUpdateInfo"

HRESULT	DNHostUpdateInfo(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 PWSTR pwszName,
						 const DWORD dwNameSize,
						 void *const pvData,
						 const DWORD dwDataSize,
						 const DWORD dwInfoFlags,
						 void *const pvUserContext,
						 const DPNID dpnidRequesting,
						 const DPNHANDLE hCompletionOp,
						 DPNHANDLE *const phAsyncOp,
						 const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwSize;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CPackedBuffer	packedBuffer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_UPDATE_INFO	*pMsg;

	DPF(4,"Parameters: dpnid [0x%lx], pwszName [0x%p], dwNameSize [%ld], pvData [0x%p], dwDataSize [%ld], dwInfoFlags [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnid,pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);
	DNASSERT(dpnidRequesting != 0);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Update Info
	//
	hrOperation = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not find entry");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		// This function takes the lock internally
		pNTEntry->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags, (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER)) ? TRUE : !fHostRequested);

		pdnObject->NameTable.Lock();
		pdnObject->NameTable.GetNewVersion( &dwVersion );
		pdnObject->NameTable.Unlock();

		//
		//	Send UPDATE_INFO message
		//
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER) ||
			((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER))
		   )
		{
			// Create buffer
			dwSize = sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO) + dwNameSize + dwDataSize;
			if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
			pMsg = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(packedBuffer.GetHeadAddress());
			if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO))) != DPN_OK)
			{
				DPFERR("Could not reserve front of buffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			if ((dwInfoFlags & DPNINFO_NAME) && (pwszName) && (dwNameSize))
			{
				if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
				{
					DPFERR("Could not add Name to back of buffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pMsg->dwNameOffset = packedBuffer.GetTailOffset();
				pMsg->dwNameSize = dwNameSize;
			}
			else
			{
				pMsg->dwNameOffset = 0;
				pMsg->dwNameSize = 0;
			}
			if ((dwInfoFlags & DPNINFO_DATA) && (pvData) && (dwDataSize))
			{
				if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
				{
					DPFERR("Could not add Data to back of buffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pMsg->dwDataOffset = packedBuffer.GetTailOffset();
				pMsg->dwDataSize = dwDataSize;
			}
			else
			{
				pMsg->dwDataOffset = 0;
				pMsg->dwDataSize = 0;
			}
			pMsg->dpnid = dpnid;
			pMsg->dwInfoFlags = dwInfoFlags;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND UpdateInfo messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}

			if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
			{
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			}
			else if ((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) && fHostRequested)
			{
				// Send to everyone except the server
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidRequesting );
			}
			else
			{
				DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER);

				// This will be responding to a client that requested its
				// info updated via SetClientInfo

				// Use the Exclude DPNID as the address to send to
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidRequesting );
			}
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_UPDATE_INFO );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (hrOperation == DPN_OK)
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNHostCheckIntegrity
//
//	The host has been asked to perform an integrity check.  We will send a message to the
//	target player with the DPNID of the requesting player.  If this is returned to us, we
//	will destroy the requesting player.

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostCheckIntegrity"

HRESULT	DNHostCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnidTarget,
							 const DPNID dpnidRequesting)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK	*pMsg;

	DPF(6,"Parameters: dpnidTarget [0x%lx], dpnidRequesting [0x%lx]",dpnidTarget,dpnidRequesting);

	pNTEntry = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Ensure that the target player is still in the NameTable, as we might have deleted him already
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidTarget,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find integrity check target in NameTable - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get target player connection reference - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Create the message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidRequesting = dpnidRequesting;

	//
	//	Send message
	//
	if ((hResultCode = DNSendMessage(	pdnObject,
										pConnection,
										DN_MSG_INTERNAL_INTEGRITY_CHECK,
										dpnidTarget,
										pRefCountBuffer->BufferDescAddress(),
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL )) != DPNERR_PENDING)
	{
		DPFERR("Could not send message - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNHostFixIntegrity
//
//	The host has received a response from a player whose session integrity was being checked.
//	The player who requested this check will be dropped.
							 
#undef DPF_MODNAME
#define DPF_MODNAME "DNHostFixIntegrity"

HRESULT	DNHostFixIntegrity(DIRECTNETOBJECT *const pdnObject,
						   void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE	*pResponse;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION			*pMsg;

	DPF(6,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pNTEntry = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;;

	pResponse = static_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE*>(pvBuffer);

	//
	//	Get requesting player's connection - they may have already dropped
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pResponse->dpnidRequesting,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player in NameTable - may have dropped");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get player connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dwTerminateDataOffset = 0;
	pMsg->dwTerminateDataSize = 0;

	//
	//	Send message to player to exit
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_TERMINATE_SESSION,
								pResponse->dpnidRequesting,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Disconnect player
	//
	hResultCode = DNHostDisconnect(pdnObject,pResponse->dpnidRequesting,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessCreateGroup"

HRESULT	DNProcessCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CAsyncOp		*pRequest;
	DN_NAMETABLE_ENTRY_INFO				*pInfo;
	DN_INTERNAL_MESSAGE_CREATE_GROUP	*pMsg;
	BOOL			fNotify;
//	void			*pvContext;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRequest = NULL;
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pvBuffer);
	pInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pMsg + 1);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create Group
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pNTEntry->UnpackEntryInfo(pInfo,static_cast<BYTE*>(pvBuffer))) != DPN_OK)
	{
		DPFERR("Could not unpack NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get async op if we requested this operation - it has the group context on it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pNTEntry->SetContext( pRequest->GetContext() );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Add Group to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.InsertEntry(pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not update NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnObject->NameTable.Lock();
	pdnObject->NameTable.SetVersion(pNTEntry->GetVersion());
	pdnObject->NameTable.Unlock();

	fNotify = FALSE;
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting())
	{
		pNTEntry->MakeAvailable();
		pNTEntry->NotifyAddRef();
		pNTEntry->NotifyAddRef();
		pNTEntry->SetInUse();
		fNotify = TRUE;
	}
	pNTEntry->Unlock();

	if (fNotify)
	{
		DNUserCreateGroup(pdnObject,pNTEntry);

		pNTEntry->PerformQueuedOperations();
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this is a completion, release it
	//
	if (pRequest)
	{
		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessDestroyGroup"

HRESULT	DNProcessDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pLocalPlayer;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_DESTROY_GROUP	*pMsg;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pvBuffer);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Destroy Group
	//
	if ((hResultCode = pdnObject->NameTable.DeleteGroup(pMsg->dpnidGroup,&pMsg->dwVersion)) != DPN_OK)
	{
		DPFERR("Could not delete group from NameTable");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.Lock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}

	//
	//	If this is a completion, release it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessAddPlayerToGroup"

HRESULT	DNProcessAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP	*pMsg;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pvBuffer);

	//
	//	Get NameTable entries
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.Lock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.Lock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}


	//
	//	Add Player To Group
	//
	if ((hResultCode = pdnObject->NameTable.AddPlayerToGroup(pGroup,pPlayer,&pMsg->dwVersion)) != DPN_OK)
	{
		DPFERR("Could not add player to group");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this is a completion, release it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessDeletePlayerFromGroup"

HRESULT	DNProcessDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pvBuffer);

	//
	//	Get NameTable entries
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.Lock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.Lock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}

	//
	//	Delete Player From Group
	//
	if ((hResultCode = pdnObject->NameTable.RemovePlayerFromGroup(pGroup,pPlayer,&pMsg->dwVersion)) != DPN_OK)
	{
		DPFERR("Could not delete player from group");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this is a completion, release it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessUpdateInfo"

HRESULT	DNProcessUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							void *const pvBuffer)
{
	HRESULT			hResultCode;
	PWSTR			pwszName;
	PVOID			pvData;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_UPDATE_INFO	*pMsg;
	BOOL			fDoUpdate = TRUE;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pvBuffer);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		//
		//	Update Info
		//
		if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find NameTableEntry");
			DisplayDNError(0,hResultCode);

			//
			//	Update version in any event (to prevent NameTable hangs)
			//
			pdnObject->NameTable.Lock();
			pdnObject->NameTable.SetVersion( pMsg->dwVersion );
			pdnObject->NameTable.Unlock();

			goto Failure;
		}
	}
	else 
	{
		DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT);

		// We are either being told that the host info has changed by a call
		// on the Host to SetServerInfo, or we are being told that our own
		// request to the server to change this Client's info has completed.
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find Host NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if (pNTEntry->GetDPNID() == pMsg->dpnid)
		{
			DPF(5,"Updating server info");
		}
		else if (pLocalPlayer->GetDPNID() == pMsg->dpnid)
		{
			fDoUpdate = FALSE;
			DPF(5,"Completing updating client info");
		}
		else
		{
			DPFERR("Received UpdateInfo for bad DPNID");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	if (fDoUpdate)
	{
		if ((pMsg->dwInfoFlags & DPNINFO_NAME) && (pMsg->dwNameOffset))
		{
			pwszName = reinterpret_cast<WCHAR*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwNameOffset);
		}
		else
		{
			pwszName = NULL;
		}
		if ((pMsg->dwInfoFlags & DPNINFO_DATA) && (pMsg->dwDataOffset))
		{
			pvData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwDataOffset);
		}
		else
		{
			pvData = NULL;
		}

		// This function takes the lock internally
		pNTEntry->UpdateEntryInfo(pwszName,pMsg->dwNameSize,pvData,pMsg->dwDataSize,pMsg->dwInfoFlags, TRUE);
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Set NameTable version
	//
	pdnObject->NameTable.Lock();
	pdnObject->NameTable.SetVersion(pMsg->dwVersion);
	pdnObject->NameTable.Unlock();

	//
	//	If this is a completion, release it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessFailedRequest"

HRESULT DNProcessFailedRequest(DIRECTNETOBJECT *const pdnObject,
							   void *const pvBuffer)
{
	HRESULT		hResultCode;
	CAsyncOp	*pRequest;
	DN_INTERNAL_MESSAGE_REQUEST_FAILED	*pMsg;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQUEST_FAILED*>(pvBuffer);

	//
	//	Update request using handle to HRESULT passed back by Host
	//
	if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp, &pRequest )) == DPN_OK)
	{
		DNASSERT( pMsg->hCompletionOp != 0 );

		pRequest->SetResult( pMsg->hResultCode );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	hResultCode = DPN_OK;

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNProcessCheckIntegrity
//
//	The host is performing an integrity check and is asking the local player (us) if we are still
//	in the session.  We will respond that we are, and the host will drop the requesting player.

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessCheckIntegrity"

HRESULT	DNProcessCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
								void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK				*pMsg;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE	*pResponse;

	DPF(6,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pHostPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Get host player connection to respond to
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host player connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Create response
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pResponse = reinterpret_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE*>(pRefCountBuffer->GetBufferAddress());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK*>(pvBuffer);
	pResponse->dpnidRequesting = pMsg->dpnidRequesting;

	//
	//	Send response
	//
	if ((hResultCode = DNSendMessage(	pdnObject,
										pConnection,
										DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE,
										pConnection->GetDPNID(),
										pRefCountBuffer->BufferDescAddress(),
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL )) != DPNERR_PENDING)
	{
		DPFERR("Could not send integrity check response");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\receive.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Receive.cpp
 *  Content:    Receive user messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/27/99	mjn		Created
 *	02/01/00	mjn		Implement Player/Group context values
 *	04/06/00	mjn		Prevent receives from being passed up until after ADD_PLAYER notification
 *	04/13/00	mjn		Fixed bug in DNReceiveUserData
 *	04/20/00	mjn		ReceiveBuffers use CAsyncOp
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	06/25/00	mjn		Always wait for sending player to be available before indicating receives from them
 *	08/02/00	mjn		Added CQueuedMsg to queue incoming messages for players who have not been indicated yet
 *				mjn		Added hCompletionOp and dwFlags to DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *	08/08/00	mjn		Used CNameTableEntry::IsCreated() to determine if clients or peers may receive
 *	08/31/00	mjn		AddRef DirectNetLock during receives to prevent leaking operations
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNReceiveUserData
//
//	Pass received user data to the user.
//	This is normally a simple undertaking, but since we allow the user to
//	retain ownership of the buffer, there is an added level of complexity.
//
//	We also need to handle the condition of the player receiving data from
//	another player for whom he has not received a CREATE_PLAYER notification.
//	In this case, we will queue the messages on the NameTableEntry, and
//	once the player has been indicated as created, we will drain the queue.
//	Also, if the player entry is in use, we will queue the message so that
//	the thread currently indicating up the user will process this receive for us.

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveUserData"

HRESULT	DNReceiveUserData(DIRECTNETOBJECT *const pdnObject,
						  const DPNID dpnidSender,
						  BYTE *const pBufferData,
						  const DWORD dwBufferSize,
						  const HANDLE hProtocol,
						  CRefCountBuffer *const pRefCountBuffer,
						  const DPNHANDLE hCompletionOp,
						  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DPNHANDLE		hAsyncOp;
	CNameTableEntry	*pNTEntry;
	BOOL			fQueueMsg;
	BOOL			fReleaseLock;

	DPF(6,"Parameters: dpnidSender [0x%lx], pBufferData [0x%p], dwBufferSize [0x%lx], hProtocol [0x%p]",
			dpnidSender,pBufferData,dwBufferSize,hProtocol);

	DNASSERT(pBufferData != NULL);
	DNASSERT(hProtocol == NULL || pRefCountBuffer == NULL);	// One or the other - not both

	hAsyncOp = 0;
	pAsyncOp = NULL;
	pNTEntry = NULL;
	fReleaseLock = FALSE;

	//
	//	Keep DirectNetObject from vanishing under us !
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFERR("Aborting receive - object is closing");
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Find sending player's NameTableEntry
	//
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
	{
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidSender,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Player no longer in NameTable");
			DisplayDNError(0,hResultCode);

			//
			//	Try "deleted" list
			//
			if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnidSender,&pNTEntry)) != DPN_OK)
			{
				DPFERR("Player not in deleted list either");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
		}
	}
	else
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFERR("Could not find Host player");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	//
	//	Create an AsyncOp for this receive
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOp,&hAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create Handle for AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_RECEIVE_BUFFER );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );

	//
	//	Add buffer to list of active AsyncOp's
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	fQueueMsg = FALSE;
	pNTEntry->Lock();
	if (pNTEntry->IsDisconnecting())
	{
		pNTEntry->Unlock();
		DPFERR("Message received from disconnecting player - ignoring");
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pNTEntry->IsInUse())
	{
		//
		//	If the player entry is in use, we will queue the message
		//
		fQueueMsg = TRUE;
	}
	else
	{
		//
		//	If the player entry is not in use, but the target player is not available (not created)
		//	we will queue the message
		//
		if (	((pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT) && !pNTEntry->IsAvailable())	||
				(!(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT) && !pNTEntry->IsCreated())		)
		{
			fQueueMsg = TRUE;
		}
		else
		{
			//
			//	If there are other messages queued, add this to the queue
			//
			if (!pNTEntry->m_bilinkQueuedMsgs.IsEmpty())
			{
				fQueueMsg = TRUE;
			}
			else
			{
				pNTEntry->SetInUse();
			}
		}
	}

	//
	//	If required, add the message to the end of the queue, otherwise process it
	//
	if (fQueueMsg)
	{
		CQueuedMsg	*pQueuedMsg;

		pQueuedMsg = NULL;

		if ((hResultCode = QueuedMsgNew(pdnObject,&pQueuedMsg)) != DPN_OK)
		{
			pNTEntry->Unlock();
			DPFERR("Could not create queued message");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->SetCompletion( DNCompleteReceiveBuffer );

		pQueuedMsg->SetOpType( RECEIVE );
		pQueuedMsg->SetBuffer( pBufferData );
		pQueuedMsg->SetBufferSize( dwBufferSize );
		pQueuedMsg->SetAsyncOp( pAsyncOp );
		if (dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO)
		{
			pQueuedMsg->MakeVoiceMessage();
		}
		if (hCompletionOp)
		{
			pQueuedMsg->SetCompletionOp( hCompletionOp );
		}
		pQueuedMsg->m_bilinkQueuedMsgs.InsertBefore( &pNTEntry->m_bilinkQueuedMsgs );
#ifdef DEBUG
		pNTEntry->m_lNumQueuedMsgs++;
		if ((pNTEntry->m_lNumQueuedMsgs % 25) == 0)
		{
			DPF(1, "Queue now contains %d msgs from player [0x%lx], the CREATE_PLAYER might be taking a long time and sender may need to back off.", pNTEntry->m_lNumQueuedMsgs, pNTEntry->GetDPNID());
		}
#endif // DEBUG


		pNTEntry->NotifyAddRef();
		pNTEntry->Unlock();

		hResultCode = DPNERR_PENDING;
	}
	else
	{
		//
		//	Hand the message directly to the user
		//
		HRESULT		hrProcess;
		HRESULT		hr;
//		CQueuedMsg	*pQueuedMsg;

		//
		//	Hand message up and track it if the user returns DPNERR_PENDING.
		//	Otherwise, let it go
		//
		pNTEntry->NotifyAddRef();
		pNTEntry->Unlock();
		if (dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO)
		{
#ifdef ENABLE_DPLAY_VOICE
			hr = Voice_Receive(	pdnObject,
								pNTEntry->GetDPNID(),
								0,
								pBufferData,
								dwBufferSize);

#endif
			pNTEntry->NotifyRelease();
		}
		else
		{
			hr = DNUserReceive(	pdnObject,
								pNTEntry,
								pBufferData,
								dwBufferSize,
								hAsyncOp);
			if (hCompletionOp != 0)
			{
				//
				//	Send completion message
				//
				CConnection	*pConnection;

				pConnection = NULL;
				if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
				{
					hResultCode = DNSendUserProcessCompletion(pdnObject,pConnection,hCompletionOp);
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}
		if (hr == DPNERR_PENDING)
		{
			if (!pRefCountBuffer)
			{
				pAsyncOp->SetProtocolHandle( hProtocol );
				pAsyncOp->SetCompletion(DNCompleteReceiveBuffer);
			}
			hrProcess = DPNERR_PENDING;
		}
		else
		{
			DNEnterCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->m_bilinkActiveList.RemoveFromList();
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				pAsyncOp->SetComplete();
				pAsyncOp->Unlock();
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
			else
			{
				pAsyncOp->Unlock();
			}
			hrProcess = DPN_OK;
		}

		//
		//	Perform any queued messages which need to be indicated up to the user
		//
		pNTEntry->PerformQueuedOperations();
		hResultCode = hrProcess;
	}



	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;

	pAsyncOp->Release();
	pAsyncOp = NULL;
	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (hAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pdnObject->HandleTable.Destroy(hAsyncOp);
		hAsyncOp = 0;
	}
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNSendUserProcessCompletion
//
//	Send a PROCESS_COMPLETION for a user message.  This indicates that a message was received and
//	handed to the user's message handler.

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendUserProcessCompletion"

HRESULT DNSendUserProcessCompletion(DIRECTNETOBJECT *const pdnObject,
									CConnection *const pConnection,
									const DPNHANDLE hCompletionOp)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_PROCESS_COMPLETION	*pMsg;

	DPF(4,"Parameters: pConnection [0x%p], hCompletionOp [0x%lx]",pConnection,hCompletionOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;

	//
	//	Create process completion
	//
	if ((hResultCode = RefCountBufferNew(	pdnObject,
											sizeof(DN_INTERNAL_MESSAGE_PROCESS_COMPLETION),
											&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer for processed response");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_PROCESS_COMPLETION*>(pRefCountBuffer->GetBufferAddress());
	pMsg->hCompletionOp = hCompletionOp;

	//
	//	SEND process completion
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_PROCESS_COMPLETION,
								pConnection->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not SEND process completion");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNFreeProtocolBuffer"

void DNFreeProtocolBuffer(void *const pvProtocolHandle,void *const pvBuffer)
{
	DNPReleaseReceiveBuffer(pvProtocolHandle);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteReceiveBuffer"

void DNCompleteReceiveBuffer(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNASSERT(pAsyncOp->GetProtocolHandle()  != NULL);

	DNPReleaseReceiveBuffer( pAsyncOp->GetProtocolHandle() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\request.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Request.h
 *  Content:    Request Operation Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/18/00	mjn		Created
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	08/05/00	mjn		Added DNProcessFailedRequest()
 *	08/07/00	mjn		Added DNRequestIntegrityCheck(),DNHostCheckIntegrity(),DNProcessCheckIntegrity(),DNHostFixIntegrity()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__REQUEST_H__
#define	__REQUEST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNRequestCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 const PWSTR pwszName,
							 const DWORD dwNameSize,
							 const PVOID pvData,
							 const DWORD dwDataSize,
							 const DWORD dwGroupFlags,
							 void *const pvGroupContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags);

HRESULT DNRequestDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidGroup,
							  PVOID const pvUserContext,
							  DPNHANDLE *const phAsyncOp,
							  const DWORD dwFlags);

HRESULT DNRequestAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  const DPNID dpnidGroup,
								  const DPNID dpnidPlayer,
								  PVOID const pvUserContext,
								  DPNHANDLE *const phAsyncOp,
								  const DWORD dwFlags);

HRESULT DNRequestDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   const DPNID dpnidGroup,
									   const DPNID dpnidPlayer,
									   PVOID const pvUserContext,
									   DPNHANDLE *const phAsyncOp,
									   const DWORD dwFlags);

HRESULT DNRequestUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							const DPNID dpnid,
							const PWSTR pwszName,
							const DWORD dwNameSize,
							const PVOID pvData,
							const DWORD dwDataSize,
							const DWORD dwInfoFlags,
							PVOID const pvUserContext,
							DPNHANDLE *const phAsyncOp,
							const DWORD dwFlags);

HRESULT DNRequestIntegrityCheck(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidTarget);

HRESULT DNHostProcessRequest(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 PVOID const pv,
							 const DPNID dpnidRequesting);

void DNHostFailRequest(DIRECTNETOBJECT *const pdnObject,
					   const DPNID dpnid,
					   const DPNHANDLE hCompletionOp,
					   const HRESULT hr);

HRESULT	DNHostCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  PWSTR pwszName,
						  const DWORD dwNameSize,
						  void *const pvData,
						  const DWORD dwDataSize,
						  const DWORD dwInfoFlags,
						  const DWORD dwGroupFlags,
						  void *const pvGroupContext,
						  void *const pvUserContext,
						  const DPNID dpnidOwner,
						  const DPNHANDLE hCompletionOp,
						  DPNHANDLE *const phAsyncOp,
						  const DWORD dwFlags);

HRESULT	DNHostDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnid,
						   void *const pvUserContext,
						   const DPNID dpnidRequesting,
						   const DPNHANDLE hCompletionOp,
						   DPNHANDLE *const phAsyncOp,
						   const DWORD dwFlags);

HRESULT	DNHostAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnidGroup,
							   const DPNID dpnidPlayer,
							   void *const pvUserContext,
							   const DPNID dpnidRequesting,
							   const DPNHANDLE hCompletionOp,
							   DPNHANDLE *const phAsyncOp,
							   const DWORD dwFlags);

HRESULT	DNHostDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									const DPNID dpnidGroup,
									const DPNID dpnidPlayer,
									void *const pvUserContext,
									const DPNID dpnidRequesting,
									const DPNHANDLE hCompletionOp,
									DPNHANDLE *const phAsyncOp,
									const DWORD dwFlags);

HRESULT	DNHostUpdateInfo(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 PWSTR pwszName,
						 const DWORD dwNameSize,
						 void *const pvData,
						 const DWORD dwDataSize,
						 const DWORD dwInfoFlags,
						 void *const pvUserContext,
						 const DPNID dpnidRequesting,
						 const DPNHANDLE hCompletionOp,
						 DPNHANDLE *const phAsyncOp,
						 const DWORD dwFlags);

HRESULT	DNHostCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnidTarget,
							 const DPNID dpnidRequesting);

HRESULT	DNHostFixIntegrity(DIRECTNETOBJECT *const pdnObject,
						   void *const pvBuffer);

HRESULT	DNProcessCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer);

HRESULT	DNProcessDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  void *const pvBuffer);

HRESULT	DNProcessAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer);

HRESULT	DNProcessDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   void *const pvBuffer);

HRESULT	DNProcessUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							void *const pvBuffer);

HRESULT DNProcessFailedRequest(DIRECTNETOBJECT *const pdnObject,
							   void *const pvBuffer);

HRESULT	DNProcessCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
								void *const pvBuffer);


//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __REQUEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\servprov.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ServProv.cpp
 *  Content:    Service Provider Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	mjn		Created
 *  04/04/00    rmt     Added set of SP caps from cache (if cache exists).
 *	04/10/00	mjn		Farm out RemoveSP to worker thread
 *	05/02/00	mjn		Fixed RefCount issue
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat 
 *	07/06/00	mjn		Fixes to support SP handle to Protocol
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2  
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/06/00	mjn		Added CWorkerJob
 *	08/20/00	mjn		Changed Initialize() to not add SP to DirectNet object bilink
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Initialize"

HRESULT CServiceProvider::Initialize(DIRECTNETOBJECT *const pdnObject,const GUID *const pguid)
{
	HRESULT			hResultCode;
	IDP8ServiceProvider	*pISP;

	DNASSERT(pdnObject != NULL);
	DNASSERT(pguid != NULL);

	pISP = NULL;

	m_pdnObject = pdnObject;

	//
	//	Instantiate SP
	//
	if ((hResultCode = COM_CoCreateInstance(*pguid,
										NULL,
										GUID_NULL,
										reinterpret_cast<void**>(&pISP))) != DPN_OK)
	{
		DPFERR("Could not instantiate SP");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Exit;
	}

	//
	//	Add SP to Protocol Layer
	//
	DNProtocolAddRef(pdnObject);
	if ((hResultCode = DNPAddServiceProvider(m_pdnObject->pdnProtocolData,pISP,&m_hProtocolSPHandle)) != DPN_OK)
	{
		DPFERR("COULD NOT ADD SERVICE PROVIDER TO PROTOCOL !  (Is this SP supported or correctly installed locally ?)");
		DisplayDNError(0,hResultCode);
		DNProtocolRelease(pdnObject);
		goto Failure;
	}
	m_dwFlags |= DN_SERVICE_PROVIDER_FLAG_LOADED;

	pISP->lpVtbl->AddRef(pISP);
	m_pISP = pISP;
	pISP->lpVtbl->Release(pISP);
	pISP = NULL;

	m_guid = *pguid;
/*	REMOVE
	// Add to bilink
	AddRef();
	m_bilink.InsertBefore(&m_pdnObject->m_bilinkServiceProviders);
*/

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	if (pISP)
	{
		pISP->lpVtbl->Release(pISP);
		pISP = NULL;
	}
	goto Exit;
};


#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Release"

void CServiceProvider::Release( void )
{
	HRESULT		hResultCode;
	LONG		lRefCount;

	lRefCount = InterlockedDecrement(&m_lRefCount);
	DPF(9,"[0x%p] new RefCount [%ld]",this,lRefCount);
	DNASSERT(lRefCount >= 0);
	if (lRefCount == 0)
	{
		if (m_dwFlags & DN_SERVICE_PROVIDER_FLAG_LOADED)
		{
			CWorkerJob	*pWorkerJob;

			pWorkerJob = NULL;

			if ((hResultCode = WorkerJobNew(m_pdnObject,&pWorkerJob)) == DPN_OK)
			{
				pWorkerJob->SetJobType( WORKER_JOB_REMOVE_SERVICE_PROVIDER );
				pWorkerJob->SetRemoveServiceProviderHandle( m_hProtocolSPHandle );

				DNQueueWorkerJob(m_pdnObject,pWorkerJob);
				pWorkerJob = NULL;
			}
			else
			{
				DPFERR("Could not remove SP");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
			}
			if (m_pISP)
			{
				m_pISP->lpVtbl->Release(m_pISP);
				m_pISP = NULL;
			}
		}
		m_pdnObject = NULL;

		delete this;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::GetInterfaceRef"

HRESULT CServiceProvider::GetInterfaceRef( IDP8ServiceProvider **ppIDP8SP )
{
	DNASSERT( ppIDP8SP != NULL );

	if (m_pISP == NULL)
	{
		return( DPNERR_GENERIC );
	}

	m_pISP->lpVtbl->AddRef( m_pISP );
	*ppIDP8SP = m_pISP;

	return( DPN_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\servprov.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ServProv.h
 *  Content:    Service Provider Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	mjn		Created
 *	05/02/00	mjn		Fixed RefCount issue
 *	07/06/00	mjn		Fixes to support SP handle to Protocol
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/20/00	mjn		Changed m_bilink to m_bilinkServiceProviders
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SERV_PROV_H__
#define	__SERV_PROV_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_SERVICE_PROVIDER_FLAG_LOADED		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for ServiceProvider objects

class CServiceProvider
{
	STDNEWDELETE

public:
	CServiceProvider()		// Constructor
		{
			m_dwFlags = 0;
			m_pdnObject = NULL;
			m_lRefCount = 1;
			m_pISP = NULL;
			m_hProtocolSPHandle = NULL;

			m_bilinkServiceProviders.Initialize();
		};

	~CServiceProvider()		// Destructor
		{
		};

	HRESULT Initialize(DIRECTNETOBJECT *const pdnObject,const GUID *const pguid);

#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::AddRef"

	void AddRef( void )
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			DNASSERT(m_pdnObject != NULL);

			lRefCount = InterlockedIncrement(&m_lRefCount);
			DPF(9,"[0x%p] new RefCount [%ld]",this,lRefCount);
		};

	void Release( void );

	BOOL CheckGUID( const GUID *const pGUID )
		{
			if (m_guid == *pGUID)
				return(TRUE);

			return(FALSE);
		};

	HRESULT GetInterfaceRef( IDP8ServiceProvider **ppIDP8SP );

	HANDLE GetHandle( void )
		{
			return( m_hProtocolSPHandle );
		};

	CBilink		m_bilinkServiceProviders;

private:
	DWORD				m_dwFlags;
	GUID				m_guid;
	LONG				m_lRefCount;
	IDP8ServiceProvider	*m_pISP;
	HANDLE				m_hProtocolSPHandle;
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __SERV_PROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\sources.inc ===
!include ..\..\sources.inc

SYNCHRONIZE_DRAIN=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dncorei.h
PRECOMPILED_PCH=dncorei.pch
PRECOMPILED_OBJ=dncorei.obj

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DASSUME_VALID_PARAMETERS -DCINTERFACE
!else
C_DEFINES=$(C_DEFINES) -DDEBUG -DCINTERFACE
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Od
!endif

INCLUDES=..; \
    $(INCLUDES)

SOURCES= ..\appdesc.cpp \
	 ..\async.cpp \
	 ..\asyncop.cpp \
	 ..\cancel.cpp \
	 ..\caps.cpp \
         ..\classfac.cpp \
	 ..\client.cpp \
	 ..\common.cpp \
	 ..\connect.cpp \
	 ..\connection.cpp \
	 ..\disconnect.cpp \
         ..\dncore.cpp \
	 ..\enum_sp.cpp \
	 ..\enumhosts.cpp \
         ..\globals.cpp \
         ..\groupcon.cpp \
	 ..\groupmem.cpp \
         ..\handles.cpp \
	 ..\handletable.cpp \
         ..\memoryfpm.cpp \
	 ..\migration.cpp \
         ..\msghandler.cpp \
	 ..\nametable.cpp \
	 ..\ntentry.cpp \
         ..\ntoplist.cpp \
	 ..\paramval.cpp \
	 ..\peer.cpp \
         ..\pools.cpp \
         ..\protocol.cpp \
	 ..\queuedmsg.cpp \
         ..\receive.cpp \
	 ..\request.cpp \
	 ..\server.cpp \
         ..\servprov.cpp \
         ..\spmessages.cpp \
         ..\syncevent.cpp \
	 ..\user.cpp \
         ..\voice.cpp \
	 ..\worker.cpp

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\server.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Server.cpp
 *  Content:    DNET server interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/22/00	mjn		Implemented DestroyClient in API
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/15/00	mjn		Use INFO flags in SetServerInfo and return context in GetClientInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *  03/17/00    rmt     Added new caps functions
 *	04/04/00	mjn		Added TerminateSession to API
 *	04/05/00	mjn		Modified DestroyClient
 *	04/06/00	mjn		Added GetClientAddress to API
 *				mjn		Added GetHostAddress to API
 *  04/18/00    rmt     Added additional paramtere validation
 *	04/19/00	mjn		SendTo API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from SendTo() API call
 *	07/09/00	mjn		Cleaned up DN_SetServerInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *				mjn		Check deleted list in DN_GetClientInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

ULONG WINAPI IDirectPlay8Server_AddRef(LPDIRECTPLAY8SERVER pDirectPlay8Server)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->AddRef();
}
ULONG WINAPI IDirectPlay8Server_Release(LPDIRECTPLAY8SERVER pDirectPlay8Server)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->Release();
}

HRESULT WINAPI IDirectPlay8Server_Initialize(LPDIRECTPLAY8SERVER pDirectPlay8Server, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_Initialize(NULL, lpvUserContext,lpfn,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_EnumServiceProviders(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pvoid,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_EnumServiceProviders(NULL, pvoid,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_CancelAsyncOperation(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_CancelAsyncOperation(NULL, hAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetSendQueueInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetSendQueueInfo(NULL, dpnid,lpdwNumMsgs,lpdwNumBytes,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetApplicationDesc(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetApplicationDesc(NULL, pAppDescBuffer,lpcbDataSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_SetServerInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_SetServerInfo(NULL, pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetClientInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags )
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetClientInfo(NULL, dpnid,pdpnPlayerInfo,pdwSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetClientAddress(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags )
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetClientAddress(NULL, dpnid,pAddress,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetLocalHostAddresses(LPDIRECTPLAY8SERVER pDirectPlay8Server, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetHostAddress(NULL, prgpAddress,pcAddress,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_SetApplicationDesc(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_APPLICATION_DESC *const lpad, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_SetApplicationDesc(NULL, lpad,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_Host(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_Host(NULL, pdnAppDesc,prgpDeviceInfo,cDeviceInfo,pdnSecurity,pdnCredentials,pvPlayerContext,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_SendTo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dnid, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_SendTo(NULL, dnid,prgBufferDesc,cBufferDesc,dwTimeOut,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_CreateGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_CreateGroup(NULL, pdpnGroupInfo,pvGroupContext,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_DestroyGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_DestroyGroup(NULL, idGroup,pvUserContext,lpAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_AddPlayerToGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_AddClientToGroup(NULL, idGroup,idClient,pvUserContext,lpAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_RemovePlayerFromGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_RemoveClientFromGroup(NULL, idGroup,idClient,pvUserContext,lpAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_SetGroupInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_SetGroupInfo(NULL, dpnid,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetGroupInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetGroupInfo(NULL, dpnid,pdpnGroupInfo,pdwSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_EnumPlayersAndGroups(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_EnumClientsAndGroups(NULL, lprgdnid,lpcdnid,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_EnumGroupMembers(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dnid, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_EnumGroupMembers(NULL, dnid,lprgdnid,lpcdnid,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_Close(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_Close(NULL, dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_DestroyClient(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dnid,const void *const pvDestroyData,const DWORD dwDestroyDataSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_DestroyPlayer(NULL, dnid,pvDestroyData,dwDestroyDataSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_ReturnBuffer(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE hBufferHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_ReturnBuffer(NULL, hBufferHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetPlayerContext(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetPlayerContext(NULL, dpnid,ppvPlayerContext,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetGroupContext(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetGroupContext(NULL, dpnid,ppvGroupContext,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPN_CAPS *const pdnCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetCaps(NULL, pdnCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_SetCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_CAPS *const pdnCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_SetCaps(NULL, pdnCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_SetSPCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pvoid, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_SetSPCaps(NULL, pvoid,pdpspCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetSPCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pvoid, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetSPCaps(NULL, pvoid,pdpspCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_GetConnectionInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_GetConnectionInfo(NULL, dpnid,pdpConnectionInfo,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_RegisterLobby(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_RegisterLobby(NULL, dpnHandle,pIDP8LobbiedApplication,dwFlags);
}

HRESULT WINAPI IDirectPlay8Server_DumpNameTable(LPDIRECTPLAY8SERVER pDirectPlay8Server, char *const Buffer)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DN_DumpNameTable(NULL, Buffer);
}

HRESULT WINAPI IDirectPlay8Server_DoWork(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Server(pDirectPlay8Server)->DoWork(dwFlags);
}



//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//	DN_SetServerInfo
//
//	Set the info for the server and propagate to client players

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetServerInfo"

HRESULT DIRECTNETOBJECT::DN_SetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPF(2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "SetServerInfo() Error validating params", SUCCEEDED( DN_ValidateSetServerInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "SetServerInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will update our entry.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		DPF(3,"Host is updating server info");

		hResultCode = DNHostUpdateInfo(	pdnObject,
										pLocalPlayer->GetDPNID(),
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnPlayerInfo->dwInfoFlags,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags );
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to update group");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetClientInfo
//
//	Retrieve client info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetClientInfo"

HRESULT DIRECTNETOBJECT::DN_GetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CNameTableEntry		*pNTEntry;
	CPackedBuffer		packedBuffer;
	HRESULT				hResultCode;

	DPF(2,"Parameters: dpnid [0x%lx], pdpnPlayerInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnPlayerInfo,dwFlags);

	RIP_ON_NOT_TRUE( "GetClientInfo() Error validating params", SUCCEEDED( DN_ValidateGetClientInfo( pInterface , dpnid, pdpnPlayerInfo, pdwSize, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetClientInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) &&
    	   !(pdnObject->dwFlags & DN_OBJECT_FLAG_DISCONNECTING) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve name table entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pNTEntry->Lock();
	if (pNTEntry->IsGroup() || pNTEntry->IsHost())
	{
	    DPFERR( "Specified ID is invalid" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetClientAddress"

HRESULT DIRECTNETOBJECT::DN_GetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CNameTableEntry		*pNTEntry;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;

	DPF(2,"Parameters : pInterface [0x%p], dpnid [0x%lx], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,ppAddress,dwFlags);

	RIP_ON_NOT_TRUE( "GetClientAddress() Error validating params", SUCCEEDED( DN_ValidateGetClientAddress( pInterface , dpnid, ppAddress, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetClientAddress() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) &&
    	   !(pdnObject->dwFlags & DN_OBJECT_FLAG_DISCONNECTING) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	

	pNTEntry = NULL;
	pAddress = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	if ((pNTEntry->GetAddress() == NULL) || (pNTEntry->IsGroup()) || !pNTEntry->IsAvailable())
	{
	    DPFERR( "Specified player is not valid" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->GetAddress()->Duplicate(ppAddress);

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\spmessages.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPMessages.h
 *  Content:    Direct SP callback interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SPMESSAGES_H__
#define	__SPMESSAGES_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// VTable for SPMessage callback functions
//
extern	IDP8SPCallbackVtbl SPMessagesVtbl;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#endif	// __SPMESSAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\spmessages.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPMessages.cpp
 *  Content:    Direct SP callback interface .CPP file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

static	STDMETHODIMP	SPQueryInterface(IDP8SPCallback *pInterface,REFIID riid,LPVOID *ppvObj);
static	STDMETHODIMP_(ULONG)	SPAddRef(IDP8SPCallback *pInterface);
static	STDMETHODIMP_(ULONG)	SPRelease(IDP8SPCallback *pInterface);
static	STDMETHODIMP	SPIndicateEvent(IDP8SPCallback *pInterface,SP_EVENT_TYPE dwEvent, LPVOID pParam);
static	STDMETHODIMP	SPCommandComplete(IDP8SPCallback *pInterface,HANDLE hCommand, HRESULT hResult, void *pContext);

//
// VTable for SPMessages interface
//
IDP8SPCallbackVtbl SPMessagesVtbl =
{
	SPQueryInterface,
	SPAddRef,
	SPRelease,
	SPIndicateEvent,
	SPCommandComplete
};

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "SPQueryInterface"
static	STDMETHODIMP	SPQueryInterface(IDP8SPCallback *pInterface,REFIID riid,LPVOID *ppvObj)
{
	DNASSERT(FALSE);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPAddRef"
static	STDMETHODIMP_(ULONG)	SPAddRef(IDP8SPCallback *pInterface)
{
//	DNASSERT(FALSE);

	return(0);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPRelease"
static	STDMETHODIMP_(ULONG)	SPRelease(IDP8SPCallback *pInterface)
{
//	DNASSERT(FALSE);

	return(0);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPIndicateEvent"
static	STDMETHODIMP	SPIndicateEvent(IDP8SPCallback *pInterface,SP_EVENT_TYPE dwEvent, LPVOID pParam)
{
	DNASSERT(FALSE);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPCommandComplete"
static	STDMETHODIMP	SPCommandComplete(IDP8SPCallback *pInterface,HANDLE hCommand, HRESULT hResult, void *pContext )
{
	DNASSERT(FALSE);

	return(DPN_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\voice.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Voice.cpp
 *  Content:    DNET voice transport interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/17/00	rmt		Created
 *  01/19/00	rmt		Fixed bug in send, wasn't copying buffer
 *  01/21/00	rmt		Updated for new interface
 *  01/21/00	rmt		Updated to use locks to protect voice portion of DNet interface
 *  01/27/2000	rmt		Added concurrency protection to the interface
 *  04/04/2000  rmt     Fixed crash if transmitting during shutdown
 *  04/07/2000  rmt     Fixed Bug #32179
 *              rmt     Added support for nocopy sends
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/20/00	mjn		DNCompleteVoiceSend calls DNCompleteSendAsyncOp to clean up
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *  04/28/00	rmt		Fixed possible deadlock condition
 *	04/28/00	mjn		Prevent infinite loops in group SENDs
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/30/00	mjn		Modified logic for group sends to target connected players only
 *	06/26/00	mjn		Added VoiceSendSpeechSync()
 *				mjn		Use Host player as sender in Client mode for Voice_Receive()
 *  06/27/00	rmt		Added support for sync sends
 *				mjn		Ensure DirectNet object is initialized and not closing when sending
 *	07/06/00	mjn		Use DNSendGroupMessage() to send group voice messages
 *	07/08/00	mjn		Send non-guaranteed voice traffic as non-sequential
 *	07/11/00	mjn		Added NOLOOPBACK capability to group sends
 *  07/21/00	rmt		Bug #36386 - Target list with groups and players may result in redundant sends
 *  07/22/00	rmt  	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  	Now for a thread to make an indication into voice they addref the interface
 *						so that the voice core can tell when all indications have returned.  
 *  07/31/00	rodtoll	Bug #41135 - Shutdown lockup -- now does not addref if notification
 *						is a session lost.  Added AddRefs() for VoiceReceive 
 *  08/11/2000	rodtoll	Bug #42235 - DVERR_NOTRANSPORT error when attempting to host voice sample app
 *	09/04/00	mjn		Added CApplicationDesc
 *  10/06/2000	rodtoll	Bug #46693 - DPVOICE: DPLAY8: Voice Data sends do not timeout
 *  10/10/2000	rodtoll	Bug #46895 - Regression from above -- guaranteed voice sends would timeout
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifdef ENABLE_DPLAY_VOICE

#define DNET_VOICE_TIMEOUT			1500

//**********************************************************************
// Function prototypes
//**********************************************************************

ULONG WINAPI IDirectPlayVoiceTransport_AddRef(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->AddRef();
}
ULONG WINAPI IDirectPlayVoiceTransport_Release(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->Release();
}

HRESULT WINAPI IDirectPlayVoiceTransport_DoWork(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DWORD Arg1)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->DoWork(Arg1);
}

HRESULT WINAPI IDirectPlayVoiceTransport_Advise(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, LPUNKNOWN pArg1, DWORD pArg2)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceAdvise(pArg1, pArg2);
}

HRESULT WINAPI IDirectPlayVoiceTransport_UnAdvise(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DWORD Arg1)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceUnAdvise(Arg1);
}

HRESULT WINAPI IDirectPlayVoiceTransport_IsGroupMember(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DVID Arg1, DVID Arg2)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceIsGroupMember(Arg1, Arg2);
}

HRESULT WINAPI IDirectPlayVoiceTransport_SendSpeech(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DVID Arg1, DVID Arg2, PVOID pArg3, PVOID pArg4, DWORD Arg5)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceSendSpeech(Arg1, Arg2, (struct _DVTRANSPORT_BUFFERDESC *) pArg3, pArg4, Arg5);
}

HRESULT WINAPI IDirectPlayVoiceTransport_GetSessionInfo(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, PDVTRANSPORTINFO pArg1)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceGetSessionInfo(pArg1);
}

HRESULT WINAPI IDirectPlayVoiceTransport_IsValidEntity(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DVID Arg1, PBOOL pArg2)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceIsValidEntity(Arg1, pArg2);
}

HRESULT WINAPI IDirectPlayVoiceTransport_SendSpeechEx(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DVID Arg1, DWORD Arg2, PDVID pArg3, PVOID pArg4, PVOID Arg5, DWORD Arg6)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceSendSpeechEx(Arg1, Arg2, pArg3, (struct _DVTRANSPORT_BUFFERDESC *) pArg4, Arg5, Arg6);
}

HRESULT WINAPI IDirectPlayVoiceTransport_IsValidGroup(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DVID Arg1, PBOOL pArg2)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceIsValidGroup(Arg1, pArg2);
}

HRESULT WINAPI IDirectPlayVoiceTransport_IsValidPlayer(LPDIRECTPLAYVOICETRANSPORT pDirectPlayVoiceTransport, DVID Arg1, PBOOL pArg2)
{
    return DIRECTNETOBJECT::GetDirectPlayVoiceTransport(pDirectPlayVoiceTransport)->VoiceIsValidPlayer(Arg1, pArg2);
}


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "Voice_Receive"
HRESULT Voice_Receive(DIRECTNETOBJECT *pdnObject, DVID dvidFrom, DVID dvidTo, LPVOID lpvMessage, DWORD dwMessageLen )
{
	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;
	CNameTableEntry	*pNTEntry;
	HRESULT			hResultCode;

    pNTEntry = NULL;

	//
	//	Ensure sender still exists in NameTable.
	//	If we are a client, the sender will be the Host player.  Otherwise, we will have to look up the player
	//	by the specified DPNID
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
		{
			DPFERR("Host not in NameTable - fail");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = pdnObject->NameTable.FindEntry(dvidFrom,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Player not in NameTable - fail");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	if (!pNTEntry->IsAvailable())
	{
		DNASSERT(FALSE);	// Is this ever hit ?
		DPF(7,"Waiting for connection");
//		pNTEntry->WaitUntilAvailable();
	}
	if (pNTEntry->IsDisconnecting())
	{
		DPFERR("Player is now disconnecting !");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	DNEnterCriticalSection( &pdnObject->csVoice );

	pServer = pdnObject->lpDxVoiceNotifyServer;
	pClient = pdnObject->lpDxVoiceNotifyClient;
	
	if( pServer )
		pServer->AddRef();

	if( pClient )
		pClient->AddRef();
	
	DNLeaveCriticalSection( &pdnObject->csVoice );

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification	

	if( pClient != NULL )
        pClient->ReceiveSpeechMessage(dvidFrom, dvidTo, lpvMessage, dwMessageLen );

	if( pServer != NULL )
    	pServer->ReceiveSpeechMessage(dvidFrom, dvidTo, lpvMessage, dwMessageLen );

	if( pServer )
		pServer->Release();

	if( pClient )
		pClient->Release();	

	hResultCode = DV_OK;

Exit:
	DNASSERT(hResultCode != DPNERR_PENDING);
	return hResultCode;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Voice_Notify"
HRESULT Voice_Notify( DIRECTNETOBJECT *pdnObject, DWORD dwMsgType, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD dwObjectType )
{
	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;
    
	DNEnterCriticalSection( &pdnObject->csVoice );

	pServer = pdnObject->lpDxVoiceNotifyServer;
	pClient = pdnObject->lpDxVoiceNotifyClient;

	if( dwMsgType != DVEVENT_STOPSESSION )
	{
	    if( pServer )
		    pServer->AddRef();

	    if( pClient )
		    pClient->AddRef();
	}

	DNLeaveCriticalSection( &pdnObject->csVoice );

	// Reset the target cache when nametable changes
	if(  dwMsgType == DVEVENT_ADDPLAYER || 
		dwMsgType == DVEVENT_REMOVEPLAYER ||
		dwMsgType == DVEVENT_CREATEGROUP || 
		dwMsgType == DVEVENT_DELETEGROUP ||
		dwMsgType == DVEVENT_ADDPLAYERTOGROUP ||
		dwMsgType == DVEVENT_REMOVEPLAYERFROMGROUP )
	{
		VoiceTarget_ClearTargetList( pdnObject );
	}

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification	

	if( pClient != NULL  && dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
        pClient->NotifyEvent(dwMsgType, dwParam1, dwParam2 );

	if( pServer != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER)
    	pServer->NotifyEvent(dwMsgType, dwParam1, dwParam2 );

	if( dwMsgType != DVEVENT_STOPSESSION )
	{
		if( pClient )
			pClient->Release();

		if( pServer )
			pServer->Release();
	}

	return DV_OK;
}

#pragma TODO(rodtoll,"Add protection to the voice elements")
#pragma TODO(rodtoll,"Add checking for session parameters")
#undef DPF_MODNAME
#define DPF_MODNAME "VoiceAdvise"
HRESULT DIRECTNETOBJECT::VoiceAdvise( IUnknown *pUnknown, DWORD dwObjectType )
{
	DIRECTNETOBJECT *pdnObject = this;
	HRESULT hr;
//	DWORD dwCurrentIndex;

	DNEnterCriticalSection( &pdnObject->csVoice );

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
	    if( pdnObject->lpDxVoiceNotifyServer != NULL )
	    {
	        DPF( 0, "There is already a server interface registered on this object" );
	        hr = DPNERR_GENERIC;
	    }
	    else
	    {
	        pdnObject->lpDxVoiceNotifyServer = (IDirectPlayVoiceNotify *) pUnknown;

            	hr = pdnObject->lpDxVoiceNotifyServer->Initialize();

            	if( FAILED( hr ) )
            	{
            	    DPF( 0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    pdnObject->lpDxVoiceNotifyServer->Release();
            	    pdnObject->lpDxVoiceNotifyServer = NULL;
            	}
	    }
	    
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( pdnObject->lpDxVoiceNotifyClient != NULL )
	    {
	        DPF( 0, "There is already a client interface registered on this object" );
	        hr = DPNERR_GENERIC;
	    }
	    else
	    {
	        pdnObject->lpDxVoiceNotifyClient = (IDirectPlayVoiceNotify *) pUnknown;

            	hr = pdnObject->lpDxVoiceNotifyClient->Initialize();

            	if( FAILED( hr ) )
            	{
            	    DPF( 0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    pdnObject->lpDxVoiceNotifyClient->Release();
            	    pdnObject->lpDxVoiceNotifyClient = NULL;
            	}
	    }	    
	}
	else
	{
	    DPF( 0, "Error: Invalid object type specified in advise" );
	    DNASSERT( FALSE );
	    hr = DPNERR_GENERIC;
	}

	DNLeaveCriticalSection( &pdnObject->csVoice );
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceUnAdvise"
HRESULT DIRECTNETOBJECT::VoiceUnAdvise( DWORD dwObjectType )
{
	DIRECTNETOBJECT *pdnObject = this;
//	DWORD dwIndex;
	HRESULT hr = DV_OK;

	DNEnterCriticalSection( &pdnObject->csVoice );

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
        if( pdnObject->lpDxVoiceNotifyServer != NULL )
	    {
    	    pdnObject->lpDxVoiceNotifyServer->Release();
    	    pdnObject->lpDxVoiceNotifyServer = NULL;	    
	    }
	    else
	    {
	        DPF( 0, "No server currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( pdnObject->lpDxVoiceNotifyClient != NULL )
	    {
    	    pdnObject->lpDxVoiceNotifyClient->Release();
    	    pdnObject->lpDxVoiceNotifyClient = NULL;	    
	    }
	    else
	    {
	        DPF( 0, "No client currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else
	{
	    DPF( 0, "Could not find interface to unadvise" );
	    hr = DVERR_GENERIC;
	}
	
	DNLeaveCriticalSection( &pdnObject->csVoice );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsGroupMember"
HRESULT DIRECTNETOBJECT::VoiceIsGroupMember( DVID dvidGroup, DVID dvidPlayer )
{
	DIRECTNETOBJECT	*pdnObject = this;	
	BOOL				fResult;

	if( dvidGroup == 0 )
	{
		return DV_OK;
	}
	
	fResult = pdnObject->NameTable.IsMember(dvidGroup,dvidPlayer);

	if( fResult )
	{
		return DV_OK;
	}
	else
	{
		return E_FAIL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNVReturnBuffer"
void DNVReturnBuffer( DIRECTNETOBJECT *const pdnObject, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, HRESULT hrResult )
{
	if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
	{
    	DVEVENTMSG_SENDCOMPLETE dvSendComplete;

    	dvSendComplete.pvUserContext = pvContext; 
		dvSendComplete.hrSendResult = hrResult; 

    	Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteVoiceSend"

void DNCompleteVoiceSend(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) (pAsyncOp->GetContext());

	DNVReturnBuffer( pdnObject, pBufferDesc, pAsyncOp->GetContext(), pAsyncOp->GetResult() );

	//
	//	Still need to complete the SEND to clean up
	//
	DNCompleteSendAsyncOp(pdnObject,pAsyncOp);
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeech"
HRESULT DIRECTNETOBJECT::VoiceSendSpeech( DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags )
{
	if( dwFlags & DVTRANSPORT_SEND_SYNC )
	{
		return VoiceSendSpeechSync( dvidFrom, dvidTo, pBufferDesc, pvUserContext, dwFlags );
	}
	else
	{
		return VoiceSendSpeechAsync( dvidFrom, dvidTo, pBufferDesc, pvUserContext, dwFlags );
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeech"
HRESULT DIRECTNETOBJECT::VoiceSendSpeechAsync( DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags )
{
	HRESULT             hr;
	DWORD	            dwAsyncFlags = 0;
	DWORD	            dwSendFlags = 0;
	DIRECTNETOBJECT    *pdnObject = this;
	CNameTableEntry		*pNTEntry;
	CGroupConnection	*pGroupConnection;
	CAsyncOp			*pAsyncOp;
    CConnection			*pConnection;
	DWORD				dwTimeout = 0;

	pNTEntry = NULL;
	pGroupConnection = NULL;
	pAsyncOp = NULL;
	pConnection = NULL;

    if( pBufferDesc->lRefCount == 0 )
    	pBufferDesc->lRefCount = 1;	

	//
    //	Flags
	//
	if (dwFlags & DVTRANSPORT_SEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	else
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
		dwTimeout = DNET_VOICE_TIMEOUT;
	}

    // Sending to ALL players
	// Retrieve NameTableEntry (use AllPlayersGroup if none specified)
	if( dvidTo == 0 )
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetAllPlayersGroupRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

            if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
            {
                DPF(0, "ERROR: All group does not exist!" );
				hr = DPNERR_GENERIC;
				goto Failure;
            }
            else
            {
    		    DPF(1, "All players group missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
            }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		dvidTo = pNTEntry->GetDPNID();
	}
	// Sending to server player
	else if( dvidTo == 1 )
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	        if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	        {
	            DPF( 0, "ERROR: No host player in session!" );
				hr = DPNERR_GENERIC;
				goto Failure;
	        }
	        else
	        {
	            DPF( 1, "Host player missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
	        }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	    dvidTo = pNTEntry->GetDPNID();
	}
	else
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.FindEntry(dvidTo,&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Could not find player/group");
			goto Failure;
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (pNTEntry->IsGroup())
	{
		hr = DNSendGroupMessage(pdnObject,
								pNTEntry,
								DN_MSG_INTERNAL_VOICE_SEND,
								reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
								NULL,
								dwTimeout,
								dwSendFlags,
								FALSE,
								FALSE,
								NULL,
								&pAsyncOp );

		if (hr == DPN_OK)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetCompletion( DNCompleteVoiceSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	else
	{
	    hr = pNTEntry->GetConnectionRef( &pConnection );

	    if( FAILED( hr ) )
	    {
	        DPF( 0, "Getting connection for player failed hr=0x%x", hr );
			goto Failure;
	    }
	    
   		DNASSERT(pConnection != NULL);
   		
   		hr = DNSendMessage(	pdnObject,
    						pConnection,
    						DN_MSG_INTERNAL_VOICE_SEND,
    						dvidTo,
    						reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
    						NULL,
    						dwTimeout,
    						dwSendFlags,
							NULL,
    						&pAsyncOp);

		if (hr == DPNERR_PENDING)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetCompletion( DNCompleteVoiceSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
			hr = DPN_OK;
		}
		else if (hr == DPNERR_INVALIDENDPOINT)
		{
			hr = DPNERR_INVALIDPLAYER;
		}

        // Release our reference on the connection
		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return hr;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	DNVReturnBuffer( pdnObject, pBufferDesc, pvUserContext, hr );
		
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeechSync"
HRESULT DIRECTNETOBJECT::VoiceSendSpeechSync(
									  DVID dvidFrom,
									  DVID dvidTo,
									  PDVTRANSPORT_BUFFERDESC pBufferDesc,
									  void *pvUserContext,
									  DWORD dwFlags )
{
	HRESULT             hr;
	HRESULT				hrSend;
	DWORD	            dwAsyncFlags = 0;
	DWORD	            dwSendFlags = 0;
	DIRECTNETOBJECT    *pdnObject = this;
	CNameTableEntry		*pNTEntry;
	CGroupConnection	*pGroupConnection;
	CAsyncOp			*pAsyncOp;
    CConnection			*pConnection;
	CSyncEvent			*pSyncEvent;
	DWORD				dwTimeout = 0;
	

	pNTEntry = NULL;
	pGroupConnection = NULL;
	pAsyncOp = NULL;
	pConnection = NULL;
	pSyncEvent = NULL;

    if( pBufferDesc->lRefCount == 0 )
    	pBufferDesc->lRefCount = 1;	

	//
	//	Create Sync Event
	//
	if ((hr = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		DisplayDNError(0,hr);
		goto Failure;
	}
	pSyncEvent->Reset();

	//
    //	Flags
	//
	if (dwFlags & DVTRANSPORT_SEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	else
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
		dwTimeout = DNET_VOICE_TIMEOUT;
	}

	//
	//	Get appropriate target
	//
	if( dvidTo == 0 )
	{
		//
		//	Sending to ALL players
		//	Retrieve NameTableEntry (use AllPlayersGroup if none specified)
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetAllPlayersGroupRef(&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

            if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
            {
                DPF(0, "ERROR: All group does not exist!" );
				hr = DPNERR_GENERIC;
				goto Failure;
            }
            else
            {
    		    DPF(1, "All players group missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
            }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		dvidTo = pNTEntry->GetDPNID();
	}
	else if( dvidTo == 1 )
	{
		//
		//	Sending to server player
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	        if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	        {
	            DPF( 0, "ERROR: No host player in session!" );
				hr = DPNERR_GENERIC;
				goto Failure;
	        }
	        else
	        {
	            DPF( 1, "Host player missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
	        }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	    dvidTo = pNTEntry->GetDPNID();
	}
	else
	{
		//
		//	Targeted send to some other player
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.FindEntry(dvidTo,&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Could not find player/group");
			DisplayDNError(0,hr);
			goto Failure;
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);;
	}

	if (pNTEntry->IsGroup())
	{
		hr = DNSendGroupMessage(pdnObject,
								pNTEntry,
								DN_MSG_INTERNAL_VOICE_SEND,
								reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
								NULL,
								dwTimeout,
								dwSendFlags,
								FALSE,
								FALSE,
								NULL,
								&pAsyncOp );

		if (hr == DPN_OK)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	else
	{
	    hr = pNTEntry->GetConnectionRef( &pConnection );

	    if( FAILED( hr ) )
	    {
	        DPF( 0, "Getting connection for player failed hr=0x%x", hr );
			DisplayDNError(0,hr);
			goto Failure;
	    }
	    
   		DNASSERT(pConnection != NULL);
   		
   		hr = DNSendMessage(	pdnObject,
    						pConnection,
    						DN_MSG_INTERNAL_VOICE_SEND,
    						dvidTo,
    						reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
    						NULL,
    						dwTimeout,
    						dwSendFlags,
							NULL,
    						&pAsyncOp);

		if (hr == DPNERR_PENDING)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;

			hr = DPN_OK;
		}

        // Release our reference on the connection
		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Wait for SENDs to complete
	//
	pSyncEvent->WaitForEvent(INFINITE, this);
	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;
	hr = hrSend;

Exit:
	return hr;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	DNVReturnBuffer( pdnObject, pBufferDesc, pvUserContext, hr );
	
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceGetSessionInfo"
HRESULT DIRECTNETOBJECT::VoiceGetSessionInfo( PDVTRANSPORTINFO pdvTransportInfo )
{
	DIRECTNETOBJECT *pdnObject = this;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pLocalPlayer;
	
	pHostPlayer = NULL;
	pLocalPlayer = NULL;
	pdvTransportInfo->dwFlags = 0;

	if (pdnObject->ApplicationDesc.IsClientServer())
	{
		pdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_CLIENTSERVER;
	}
	else
	{
		pdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_PEERTOPEER;
	}

	if (pdnObject->ApplicationDesc.AllowHostMigrate())
	{
		pdvTransportInfo->dwFlags |= DVTRANSPORT_MIGRATEHOST;
	} 

	pdvTransportInfo->dwMaxPlayers = pdnObject->ApplicationDesc.GetMaxPlayers();

	if (pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer ) == DPN_OK)
	{
		pdvTransportInfo->dvidLocalID = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DPFERR( "Unable to find a local player" );
		pdvTransportInfo->dvidLocalID = 0;
		return DVERR_TRANSPORTNOPLAYER;
	}

	if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) != DPN_OK)
	{
		pdvTransportInfo->dvidSessionHost = 0;
		DPFERR( "Unable to find a session host" );
//		return DVERR_TRANSPORTNOPLAYER;
	}
	else
	{
		pdvTransportInfo->dvidSessionHost = pHostPlayer->GetDPNID();	
		pHostPlayer->Release();
	}
	
	pHostPlayer = NULL;

	if( pdvTransportInfo->dvidSessionHost == pdvTransportInfo->dvidLocalID )
	{
		pdvTransportInfo->dwFlags |= DVTRANSPORT_LOCALHOST;
	}
		
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidGroup"
HRESULT DIRECTNETOBJECT::VoiceIsValidGroup( DVID dvidID, PBOOL pfIsValid )
{
	DIRECTNETOBJECT *pdnObject = this;
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else if( pNTEntry->IsGroup() )
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidPlayer"
HRESULT DIRECTNETOBJECT::VoiceIsValidPlayer( DVID dvidID, PBOOL pfIsValid )
{
	DIRECTNETOBJECT *pdnObject = this;
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else if( !pNTEntry->IsGroup() )
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidEntity"
HRESULT DIRECTNETOBJECT::VoiceIsValidEntity( DVID dvidID, PBOOL pfIsValid )
{
	DIRECTNETOBJECT *pdnObject = this;
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeechEx"
#pragma BUGBUG(rodtoll,"Build a list of cached targets")
HRESULT DIRECTNETOBJECT::VoiceSendSpeechEx( DVID dvidFrom, DWORD dwNumTargets, PDVID pdvidTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags )
{
	DIRECTNETOBJECT *pdnObject = this;	
	
	DWORD dwIndex;
	HRESULT hr;

	DNEnterCriticalSection( &pdnObject->csVoice );

	hr= VoiceTarget_ExpandTargetList(pdnObject, dwNumTargets, pdvidTargets);

	if(hr != DPN_OK)
	{
		DNLeaveCriticalSection( &pdnObject->csVoice );		
		return hr;
	}

	pBufferDesc->lRefCount = pdnObject->nExpandedTargets;

	// Send to our expanded and duplicate removed list.
	for(dwIndex=0; dwIndex < pdnObject->nExpandedTargets; dwIndex++)
	{
		hr = VoiceSendSpeech( dvidFrom, pdnObject->pExpandedTargetList[dwIndex], pBufferDesc, pvUserContext, dwFlags );
	}    

	DNLeaveCriticalSection( &pdnObject->csVoice );			

	return hr;
}

/////////////////////////////////////////
// Support Routinesfor VoiceSendSpeechEx //
/////////////////////////////////////////

VOID VoiceTarget_ClearTargetList( DIRECTNETOBJECT *pdnObject )
{
	pdnObject->nTargets=0;
}

VOID VoiceTarget_ClearExpandedTargetList(DIRECTNETOBJECT *pdnObject)
{
	pdnObject->nExpandedTargets=0;
}

HRESULT VoiceTarget_AddExpandedTargetListEntry(DIRECTNETOBJECT *pdnObject, DPNID dpid)
{
	#define GROW_SIZE 16
	
	PDPNID pdpid;
	
	if(pdnObject->nExpandedTargets == pdnObject->nExpandedTargetListLen){
		// Need more room, allocate another 16 entries

		pdpid=new DPNID[pdnObject->nExpandedTargetListLen+GROW_SIZE];

		if(!pdpid){
			DPF( 0, "Error allocating room for target cache" );
			return DVERR_OUTOFMEMORY;
		}
		
		if(pdnObject->pExpandedTargetList){
			memcpy(pdpid, pdnObject->pExpandedTargetList, pdnObject->nExpandedTargetListLen*sizeof(DPNID));
			if( pdnObject->pExpandedTargetList )
			{
				delete [] pdnObject->pExpandedTargetList;
				pdnObject->pExpandedTargetList = NULL;
			}
		}
		pdnObject->pExpandedTargetList = pdpid;
		pdnObject->nExpandedTargetListLen += GROW_SIZE;
	}

	pdnObject->pExpandedTargetList[pdnObject->nExpandedTargets++]=dpid;

	return DV_OK;

	#undef GROW_SIZE
}

void VoiceTarget_AddIfNotAlreadyFound( DIRECTNETOBJECT *pdnObject, DPNID dpidID )
{
	DWORD j;
	
	for(j=0;j<pdnObject->nExpandedTargets;j++)
	{
		if( pdnObject->pExpandedTargetList[j] == dpidID )
		{
			break;
		}
	}

	// It was not found, add him to the list
	if( j == pdnObject->nExpandedTargets )
	{
		VoiceTarget_AddExpandedTargetListEntry(pdnObject, dpidID);							
	}
}

HRESULT VoiceTarget_ExpandTargetList(DIRECTNETOBJECT *pdnObject, DWORD nTargets, PDVID pdvidTo)
{
	HRESULT hr=DPN_OK;
	UINT i;
	CNameTableEntry *pEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;

	pEntry = NULL;
	
	// See if we need to change the expanded target list or we have it cached.
	
	if(nTargets != pdnObject->nTargets || memcmp(pdvidTo, pdnObject->pTargetList, nTargets * sizeof(DVID))){

		DPF(9, "VoiceTarget_ExpandTargetList, new list re-building cached list\n");
		
		// the target list is wrong, rebuild it.
		// First copy the new target list...
		if(nTargets > pdnObject->nTargetListLen){
			// Current list is too small, possibly non-existant, allocate one to cache the list.
			if(pdnObject->pTargetList){
				delete [] pdnObject->pTargetList;
				pdnObject->pTargetList = NULL;
			}
			pdnObject->pTargetList=new DVID[nTargets];
			if(pdnObject->pTargetList){
				pdnObject->nTargetListLen=nTargets;
			} else {
				pdnObject->nTargetListLen=0;
				pdnObject->nTargets=0;
				hr=DPNERR_OUTOFMEMORY;
				DPF(0,"Ran out of memory trying to cache target list!\n");
				goto exit;
			}
		}
		pdnObject->nTargets = nTargets;
		memcpy(pdnObject->pTargetList, pdvidTo, nTargets*sizeof(DPNID));

		// OK we have the target list cached, now build the list we are going to send to.
		VoiceTarget_ClearExpandedTargetList(pdnObject);
		for(i=0;i<pdnObject->nTargets;i++)
		{
			hr = pdnObject->NameTable.FindEntry( pdnObject->pTargetList[i], &pEntry );

			if( SUCCEEDED( hr ) )
			{
				if( !pEntry->IsGroup() )
				{
					VoiceTarget_AddIfNotAlreadyFound( pdnObject, pdnObject->pTargetList[i] );
				}
				else
				{
					pEntry->Lock();

					pBilink = pEntry->m_bilinkMembership.GetNext();
					while (pBilink != &pEntry->m_bilinkMembership)
					{
						pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
						VoiceTarget_AddIfNotAlreadyFound( pdnObject, pGroupMember->GetPlayer()->GetDPNID() );
										
						pBilink = pBilink->GetNext();
					}

					pEntry->Unlock();					
				}

				pEntry->Release();
				pEntry = NULL;
				
			}
			
		}

	} else {
		DPF(9,"ExpandTargetList, using cached list\n");
	}

exit:
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\syncevent.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SyncEvent.cpp
 *  Content:    DNET Synchronization Events FPM
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/20/99	mjn		Created
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

/*	REMOVE
//**********************************************************************
// ------------------------------
// CSyncEvent::Initialize
//
// Entry:		CFixedPool <SyncEvent> *pFPSyncEvent
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

HRESULT CSyncEvent::Initialize(CFixedPool <CSyncEvent> *pFPSyncEvent)
{
	if (m_hEvent == NULL)
	{
		m_pFPOOLSyncEvent = pFPSyncEvent;
		if ((m_hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
		{
			DNASSERT(FALSE);
			return(DNERR_OUTOFMEMORY);
		}
	}
	Reset();

	return(DN_OK);
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSyncEvent::ReturnSelfToPool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------

void CSyncEvent::ReturnSelfToPool( void )
{
	m_pFPOOLSyncEvent->Release( this );
}
//**********************************************************************

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\user.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       User.h
 *  Content:    DirectNet User Call Back Routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/16/00	mjn		Created
 *	01/17/00	mjn		Added DN_UserHostMigrate
 *	01/17/00	mjn		Implemented send time
 *	01/22/00	mjn		Added DN_UserHostDestroyPlayer
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	01/28/00	mjn		Added DN_UserConnectionTerminated
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/04/00	mjn		Added DN_UserTerminateSession()
 *	04/05/00	mjn		Updated DN_UserHostDestroyPlayer()
 *	04/18/00	mjn		Added DN_UserReturnBuffer
 *				mjn		Added ppvReplyContext to DN_UserIndicateConnect
 *	07/29/00	mjn		Added DNUserIndicatedConnectAborted()
 *				mjn		DNUserConnectionTerminated() supercedes DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *	07/30/00	mjn		Added pAddressDevice to DNUserIndicateConnect()
 *				mjn		Replaced DNUserConnectionTerminated() with DNUserTerminateSession()
 *	07/31/00	mjn		Revised DNUserDestroyGroup()
 *				mjn		Removed DN_UserHostDestroyPlayer()
 *	08/01/00	mjn		DN_UserReceive() -> DNUserReceive()
 *	08/02/00	mjn		DN_UserAddPlayer() -> DNUserCreatePlayer()
 *	08/08/00	mjn		DN_UserCreateGroup() -> DNUserCreateGroup()
 *	08/20/00	mjn		Added DNUserEnumQuery() and DNUserEnumResponse()
 *	09/17/00	mjn		Changed parameters list of DNUserCreateGroup(),DNUserCreatePlayer(),
 *						DNUserAddPlayerToGroup(),DNRemovePlayerFromGroup()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__USER_H__
#define	__USER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNUserConnectComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr,
							  CRefCountBuffer *const pRefCountBuffer);

HRESULT DNUserIndicateConnect(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvConnectData,
							  const DWORD dwConnectDataSize,
							  void **const ppvReplyData,
							  DWORD *const pdwReplyDataSize,
							  void **const ppvReplyContext,
							  IDirectPlay8Address *const pAddressPlayer,
							  IDirectPlay8Address *const pAddressDevice,
							  void **const ppvPlayerContext);

HRESULT DNUserIndicatedConnectAborted(DIRECTNETOBJECT *const pdnObject,
									  void *const pvPlayerContext);

HRESULT DNUserCreatePlayer(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry);

HRESULT DNUserDestroyPlayer(DIRECTNETOBJECT *const pdnObject,
							CNameTableEntry *const pNTEntry);

HRESULT DNUserCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry);

HRESULT DNUserDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry);

HRESULT DNUserAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   CNameTableEntry *const pGroup,
							   CNameTableEntry *const pPlayer);

HRESULT DNUserRemovePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer);

HRESULT DNUserUpdateGroupInfo(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid,
							  const PVOID pvContext);

HRESULT DNUserUpdatePeerInfo(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnid,
							 const PVOID pvContext);

HRESULT DNUserUpdateClientInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext);

HRESULT DNUserUpdateServerInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext);

HRESULT DNUserAsyncComplete(DIRECTNETOBJECT *const pdnObject,
							const DPNHANDLE hAsyncOp,
							PVOID const pvContext,
							const HRESULT hr);

HRESULT DNUserSendComplete(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hAsyncOp,
						   PVOID const pvContext,
						   const DWORD dwStartTime,
						   const HRESULT hr);

HRESULT DNUserUpdateAppDesc(DIRECTNETOBJECT *const pdnObject);

HRESULT DNUserReceive(DIRECTNETOBJECT *const pdnObject,
					  CNameTableEntry *const pNTEntry,
					  BYTE *const pBufferData,
					  const DWORD dwBufferSize,
					  const DPNHANDLE hBufferHandle);

HRESULT DN_UserHostMigrate(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnidNewHost,
						   const PVOID pvPlayerContext);

HRESULT DNUserTerminateSession(DIRECTNETOBJECT *const pdnObject,
							   const HRESULT hr,
							   void *const pvTerminateData,
							   const DWORD dwTerminateDataSize);

HRESULT DNUserReturnBuffer(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hr,
						   void *const pvBuffer,
						   void *const pvUserContext);

HRESULT DNUserEnumQuery(DIRECTNETOBJECT *const pdnObject,
						DPNMSG_ENUM_HOSTS_QUERY *const pMsg);

HRESULT DNUserEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   DPNMSG_ENUM_HOSTS_RESPONSE *const pMsg);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __USER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\voice.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.h
 *  Content:    Direct Net Voice Transport Interface
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/17/00	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__VOICE_H__
#define	__VOICE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

VOID    VoiceTarget_ClearTargetList( DIRECTNETOBJECT *pdnObject );
VOID    VoiceTarget_ClearExpandedTargetList(DIRECTNETOBJECT *pdnObject);
HRESULT VoiceTarget_AddExpandedTargetListEntry(DIRECTNETOBJECT *pdnObject, DPNID dpid);
void    VoiceTarget_AddIfNotAlreadyFound( DIRECTNETOBJECT *pdnObject, DPNID dpidID );
HRESULT VoiceTarget_ExpandTargetList(DIRECTNETOBJECT *pdnObject, DWORD nTargets, PDPNID pdvidTo);

//
// VTable for peer interface
//
//extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;

HRESULT Voice_Notify( DIRECTNETOBJECT *pObject, DWORD dwMsgID, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD dwObjectType = DVTRANSPORT_OBJECTTYPE_BOTH );
HRESULT Voice_Receive(DIRECTNETOBJECT *pObject, DVID dvidFrom, DVID dvidTo, LPVOID lpvMessage, DWORD dwMessageLen );


//**********************************************************************
// Function prototypes
//**********************************************************************

#endif	// __VOICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\dplay8\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\dplay8v\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\user.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       User.cpp
 *  Content:    DNET user call-back routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/02/99	mjn		Created
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Allow reply in DN_UserIndicateConnect
 *	01/08/00	mjn		DN_UserIndicateConnect provides failed buffer back to DN_UserConnectComplete
 *	01/10/00	mjn		Added DN_UserUpdateAppDesc
 *	01/16/00	mjn		Upgraded to new UserMessageHandler definition
 *	01/17/00	mjn		Added DN_UserHostMigrate
 *	01/17/00	mjn		Implemented send time
 *  01/18/00	rmt		Added calls into voice layer for events
 *	01/22/00	mjn		Added DN_UserHostDestroyPlayer
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	01/28/00	mjn		Added DN_UserConnectionTerminated
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/01/00	mjn		Implement Player/Group context values
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/04/00	mjn		Added DN_UserTerminateSession()
 *	04/05/00	mjn		Updated DN_UserHostDestroyPlayer()
 *	04/18/00	mjn		Added DN_UserReturnBuffer
 *				mjn		Added ppvReplyContext to DN_UserIndicateConnect
 *	04/19/00	mjn		Removed hAsyncOp (unused) from DPNMSG_INDICATE_CONNECT
 *	06/26/00	mjn		Added reasons for DELETE_PLAYER and DESTROY_GROUP
 *	07/29/00	mjn		Added DNUserIndicatedConnectAborted()
 *				mjn		DNUserConnectionTerminated() supercedes DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *	07/30/00	mjn		Added pAddressDevice to DNUserIndicateConnect()
 *				mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		DN_UserDestroyGroup() -> DNUserDestroyGroup()
 *				mjn		DN_UserDeletePlayer() -> DNUserDestroyPlayer()
 *				mjn		Removed DN_UserHostDestroyPlayer()
 *				mjn		Renamed DPN_MSGID_ASYNC_OPERATION_COMPLETE to DPN_MSGID_ASYNC_OP_COMPLETE
 *	08/01/00	mjn		DN_UserReceive() -> DNUserReceive()
 *	08/02/00	mjn		DN_UserAddPlayer() -> DNUserCreatePlayer()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/08/00	mjn		DN_UserCreateGroup() -> DNUserCreateGroup()
 *	08/20/00	mjn		Added DNUserEnumQuery() and DNUserEnumResponse()
 *	09/17/00	mjn		Changed parameters list of DNUserCreateGroup(),DNUserCreatePlayer(),
 *						DNUserAddPlayerToGroup(),DNUserRemovePlayerFromGroup()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

// DNUserConnectComplete
//
//	Send a CONNECT_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserConnectComplete"

HRESULT DNUserConnectComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr,
							  CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT			hResultCode;
	DPNMSG_CONNECT_COMPLETE	Msg;

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	DPF(6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx], pRefCountBuffer [0x%p]",
		hAsyncOp,pvContext,hr,pRefCountBuffer);

	Msg.dwSize = sizeof(DPNMSG_CONNECT_COMPLETE);
	Msg.pvUserContext = pvContext;
	Msg.hAsyncOp = hAsyncOp;
	Msg.hResultCode = hr;
	if (pRefCountBuffer)
	{
		Msg.pvApplicationReplyData = pRefCountBuffer->GetBufferAddress();
		Msg.dwApplicationReplyDataSize = pRefCountBuffer->GetBufferSize();
	}
	else
	{
		Msg.pvApplicationReplyData = NULL;
		Msg.dwApplicationReplyDataSize = 0;
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CONNECT_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserIndicateConnect
//
//	Send an INDICATE_CONNECT message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserIndicateConnect"

HRESULT DNUserIndicateConnect(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvConnectData,
							  const DWORD dwConnectDataSize,
							  void **const ppvReplyData,
							  DWORD *const pdwReplyDataSize,
							  void **const ppvReplyContext,
							  IDirectPlay8Address *const pAddressPlayer,
							  IDirectPlay8Address *const pAddressDevice,
							  void **const ppvPlayerContext)
{
	HRESULT			hResultCode;
	DPNMSG_INDICATE_CONNECT	Msg;

	DPF(6,"Parameters: pvConnectData [0x%p], dwConnectDataSize [%ld], ppvReplyData [0x%p], pdwReplyDataSize [0x%p]",
		pvConnectData,dwConnectDataSize,ppvReplyData,pdwReplyDataSize);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(ppvReplyData != NULL);
	DNASSERT(pdwReplyDataSize != NULL);

	Msg.dwSize = sizeof(DPNMSG_INDICATE_CONNECT);
	Msg.pvUserConnectData = pvConnectData;
	Msg.dwUserConnectDataSize = dwConnectDataSize;
	Msg.pvReplyData = NULL;
	Msg.dwReplyDataSize = 0;
	Msg.pvReplyContext = NULL;
	Msg.pvPlayerContext = NULL;
	Msg.pAddressPlayer = pAddressPlayer;
	Msg.pAddressDevice = pAddressDevice;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_INDICATE_CONNECT,reinterpret_cast<BYTE*>(&Msg));

	*ppvReplyData = Msg.pvReplyData;
	*pdwReplyDataSize = Msg.dwReplyDataSize;
	*ppvReplyContext = Msg.pvReplyContext;
	*ppvPlayerContext = Msg.pvPlayerContext;

	if (hResultCode != DPN_OK)
	{
		hResultCode = DPNERR_HOSTREJECTEDCONNECTION;
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserIndicatedConnectAborted
//
//	Send an INDICATED_CONNECT_ABORTED message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserIndicatedConnectAborted"

HRESULT DNUserIndicatedConnectAborted(DIRECTNETOBJECT *const pdnObject,
									  void *const pvPlayerContext)
{
	HRESULT			hResultCode;
	DPNMSG_INDICATED_CONNECT_ABORTED	Msg;

	DPF(6,"Parameters: pvPlayerContext [0x%p]",pvPlayerContext);

	DNASSERT(pdnObject != NULL);

	Msg.dwSize = sizeof(DPNMSG_INDICATED_CONNECT_ABORTED);
	Msg.pvPlayerContext = pvPlayerContext;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_INDICATED_CONNECT_ABORTED,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNUserCreatePlayer
//
//	Send a CREATE_PLAYER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreatePlayer"

HRESULT DNUserCreatePlayer(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry)
{
	HRESULT				hResultCode;
	DPNMSG_CREATE_PLAYER	Msg;

	DPF(6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, pNTEntry->GetDPNID(), 0 );
#endif

	Msg.dwSize = sizeof(DPNMSG_CREATE_PLAYER);
	Msg.dpnidPlayer = pNTEntry->GetDPNID();
	Msg.pvPlayerContext = pNTEntry->GetContext();

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_PLAYER,reinterpret_cast<BYTE*>(&Msg));

	//
	//	Save context value on NameTableEntry
	//
	pNTEntry->Lock();
	pNTEntry->SetContext( Msg.pvPlayerContext );
	pNTEntry->SetCreated();
//	pNTEntry->NotifyAddRef();
	pNTEntry->Unlock();

	pNTEntry->NotifyRelease();

	DPF(7,"Set context [0x%p]",pNTEntry->GetContext());

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroyPlayer
//
//	Send a DESTROY_PLAYER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroyPlayer"

HRESULT DNUserDestroyPlayer(DIRECTNETOBJECT *const pdnObject,
							CNameTableEntry *const pNTEntry)
{
	HRESULT				hResultCode;
	DPNMSG_DESTROY_PLAYER	Msg;

	DPF(6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);
	DNASSERT(pNTEntry->GetDPNID() != 0);
	DNASSERT(pNTEntry->GetDestroyReason() != 0);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, pNTEntry->GetDPNID(), 0 );
#endif

	Msg.dwSize = sizeof(DPNMSG_DESTROY_PLAYER);
	Msg.dpnidPlayer = pNTEntry->GetDPNID();
	Msg.pvPlayerContext = pNTEntry->GetContext();
	Msg.dwReason = pNTEntry->GetDestroyReason();

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_PLAYER,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserCreateGroup
//
//	Send an CREATE_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreateGroup"

HRESULT DNUserCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry)
{
	HRESULT				hResultCode;
	DPNMSG_CREATE_GROUP	Msg;

	DPF(6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, pNTEntry->GetDPNID(), 0 );
#endif

	Msg.dwSize = sizeof(DPNMSG_CREATE_GROUP);
	Msg.dpnidGroup = pNTEntry->GetDPNID();
	if (pNTEntry->IsAutoDestructGroup())
	{
		Msg.dpnidOwner = pNTEntry->GetOwner();
	}
	else
	{
		Msg.dpnidOwner = 0;
	}
	Msg.pvGroupContext = pNTEntry->GetContext();

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_GROUP,reinterpret_cast<BYTE*>(&Msg));

	//
	//	Save context value on NameTableEntry
	//
	pNTEntry->Lock();
	pNTEntry->SetContext( Msg.pvGroupContext );
	pNTEntry->SetCreated();
//	pNTEntry->NotifyAddRef();
	pNTEntry->Unlock();

	pNTEntry->NotifyRelease();

	DPF(7,"Set context [0x%p]",pNTEntry->GetContext());

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroyGroup
//
//	Send a DESTROY_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroyGroup"

HRESULT DNUserDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry)
{
	HRESULT				hResultCode;
	DPNMSG_DESTROY_GROUP	Msg;

	DPF(6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);
	DNASSERT(pNTEntry->GetDPNID() != 0);
	DNASSERT(pNTEntry->GetDestroyReason() != 0);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, pNTEntry->GetDPNID(), 0 );
#endif

	Msg.dwSize = sizeof(DPNMSG_DESTROY_GROUP);
	Msg.dpnidGroup = pNTEntry->GetDPNID();
	Msg.pvGroupContext = pNTEntry->GetContext();
	Msg.dwReason = pNTEntry->GetDestroyReason();

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_GROUP,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserAddPlayerToGroup
//
//	Send an ADD_PLAYER_TO_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserAddPlayerToGroup"

HRESULT DNUserAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   CNameTableEntry *const pGroup,
							   CNameTableEntry *const pPlayer)
{
	HRESULT		hResultCode;
	DPNMSG_ADD_PLAYER_TO_GROUP	Msg;

	DPF(6,"Parameters: pGroup [0x%p], pPlayer [0x%p]",pGroup,pPlayer);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, pGroup->GetDPNID(), pPlayer->GetDPNID() );
#endif

	Msg.dwSize = sizeof(DPNMSG_ADD_PLAYER_TO_GROUP);
	Msg.dpnidGroup = pGroup->GetDPNID();
	Msg.pvGroupContext = pGroup->GetContext();
	Msg.dpnidPlayer = pPlayer->GetDPNID();
	Msg.pvPlayerContext = pPlayer->GetContext();

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_ADD_PLAYER_TO_GROUP,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserRemovePlayerFromGroup
//
//	Send a REMOVE_PLAYER_FROM_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserRemovePlayerFromGroup"

HRESULT DNUserRemovePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer)
{
	HRESULT		hResultCode;
	DPNMSG_REMOVE_PLAYER_FROM_GROUP	Msg;

	DPF(6,"Parameters: pGroup [0x%p], pPlayer [0x%p]",pGroup,pPlayer);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, pGroup->GetDPNID(), pPlayer->GetDPNID());
#endif

	Msg.dwSize = sizeof(DPNMSG_REMOVE_PLAYER_FROM_GROUP);
	Msg.dpnidGroup = pGroup->GetDPNID();
	Msg.pvGroupContext = pGroup->GetContext();
	Msg.dpnidPlayer = pPlayer->GetDPNID();
	Msg.pvPlayerContext = pPlayer->GetContext();

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_REMOVE_PLAYER_FROM_GROUP,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateGroupInfo"

HRESULT DNUserUpdateGroupInfo(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid,
							  const PVOID pvContext)
{
	HRESULT				hResultCode;
	DPNMSG_GROUP_INFO	MsgGroupInfo;

	DPF(6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgGroupInfo.dwSize = sizeof(DPNMSG_GROUP_INFO);
	MsgGroupInfo.dpnidGroup = dpnid;
	MsgGroupInfo.pvGroupContext = pvContext;
	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_GROUP_INFO,reinterpret_cast<BYTE*>(&MsgGroupInfo));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdatePeerInfo"

HRESULT DNUserUpdatePeerInfo(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnid,
							 const PVOID pvContext)
{
	HRESULT				hResultCode;
	DPNMSG_PEER_INFO	MsgPeerInfo;

	DPF(6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgPeerInfo.dwSize = sizeof(DPNMSG_PEER_INFO);
	MsgPeerInfo.dpnidPeer = dpnid;
	MsgPeerInfo.pvPlayerContext = pvContext;
	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_PEER_INFO,reinterpret_cast<BYTE*>(&MsgPeerInfo));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateClientInfo"

HRESULT DNUserUpdateClientInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext)
{
	HRESULT				hResultCode;
	DPNMSG_CLIENT_INFO	MsgClientInfo;

	DPF(6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgClientInfo.dwSize = sizeof(DPNMSG_CLIENT_INFO);
	MsgClientInfo.dpnidClient = dpnid;
	MsgClientInfo.pvPlayerContext = pvContext;
	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CLIENT_INFO,reinterpret_cast<BYTE*>(&MsgClientInfo));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateServerInfo"

HRESULT DNUserUpdateServerInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext)
{
	HRESULT				hResultCode;
	DPNMSG_SERVER_INFO	MsgServerInfo;

	DPF(6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgServerInfo.dwSize = sizeof(DPNMSG_SERVER_INFO);
	MsgServerInfo.dpnidServer = dpnid;
	MsgServerInfo.pvPlayerContext = pvContext;
	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_SERVER_INFO,reinterpret_cast<BYTE*>(&MsgServerInfo));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserAsyncComplete
//
//	Send a DN_MSGID_ASYNC_OPERATION_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserAsyncComplete"

HRESULT DNUserAsyncComplete(DIRECTNETOBJECT *const pdnObject,
							const DPNHANDLE hAsyncOp,
							PVOID const pvContext,
							const HRESULT hr)
{
	HRESULT			hResultCode;
	DPNMSG_ASYNC_OP_COMPLETE	Msg;

	DPF(6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",hAsyncOp,pvContext,hr);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_ASYNC_OP_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_ASYNC_OP_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserSendComplete
//
//	Send a DN_MSGID_SEND_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserSendComplete"

HRESULT DNUserSendComplete(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hAsyncOp,
						   PVOID const pvContext,
						   const DWORD dwStartTime,
						   const HRESULT hr)
{
	HRESULT				hResultCode;
	DPNMSG_SEND_COMPLETE	Msg;
	DWORD				dwEndTime;

	DPF(6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",hAsyncOp,pvContext,hr);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_SEND_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;
	dwEndTime = timeGetTime();
	Msg.dwSendTime = dwEndTime - dwStartTime;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_SEND_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserUpdateAppDesc
//
//	Send a DN_MSGID_APPLICATION_DESC message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateAppDesc"

HRESULT DNUserUpdateAppDesc(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;

	DPF(6,"Parameters: (none)");

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_APPLICATION_DESC,NULL);

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DN_UserReceive
//
//	Send a DN_MSGID_RECEIVE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DN_UserReceive"

HRESULT DNUserReceive(DIRECTNETOBJECT *const pdnObject,
					  CNameTableEntry *const pNTEntry,
					  BYTE *const pBufferData,
					  const DWORD dwBufferSize,
					  const DPNHANDLE hBufferHandle)
{
	HRESULT			hResultCode;
	DPNMSG_RECEIVE	Msg;

	DPF(6,"Parameters: pNTEntry [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hBufferHandle [0x%lx]",
			pNTEntry,pBufferData,dwBufferSize,hBufferHandle);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);

	Msg.dwSize = sizeof(DPNMSG_RECEIVE);
	Msg.pReceiveData = pBufferData;
	Msg.dwReceiveDataSize = dwBufferSize;
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		Msg.dpnidSender = 0;
	}
	else
	{
		Msg.dpnidSender = pNTEntry->GetDPNID();
	}
	Msg.pvPlayerContext = pNTEntry->GetContext();
	Msg.hBufferHandle = hBufferHandle;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RECEIVE,reinterpret_cast<BYTE*>(&Msg));

	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pNTEntry->NotifyRelease();

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DN_UserHostMigrate
//
//	Send a DN_MSGID_HOST_MIGRATE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DN_UserHostMigrate"

HRESULT DN_UserHostMigrate(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnidNewHost,
						   const PVOID pvPlayerContext)
{
	HRESULT				hResultCode;
	DPNMSG_HOST_MIGRATE	Msg;

	DPF(6,"Parameters: (none)");

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

#ifdef ENABLE_DPLAY_VOICE
	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
#endif

	Msg.dwSize = sizeof(DPNMSG_HOST_MIGRATE);
	Msg.dpnidNewHost = dpnidNewHost;
	Msg.pvPlayerContext = pvPlayerContext;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_HOST_MIGRATE,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserTerminateSession
//
//	Send a DN_MSGID_CONNECTION_TERMINATED message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserTerminateSession"

HRESULT DNUserTerminateSession(DIRECTNETOBJECT *const pdnObject,
							   const HRESULT hr,
							   void *const pvTerminateData,
							   const DWORD dwTerminateDataSize)
{
	HRESULT			hResultCode;
	DPNMSG_TERMINATE_SESSION	Msg;

	DPF(6,"Parameters: hr [0x%lx],pvTerminateData [0x%p], dwTerminateDataSize [%ld]",
			hr,pvTerminateData,dwTerminateDataSize);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_TERMINATE_SESSION);
	Msg.hResultCode = hr;
	Msg.pvTerminateData = pvTerminateData;
	Msg.dwTerminateDataSize = dwTerminateDataSize;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_TERMINATE_SESSION,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserReturnBuffer
//
//	Send a DPN_MSGID_RETURN_BUFFER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserReturnBuffer"

HRESULT DNUserReturnBuffer(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hr,
						   void *const pvBuffer,
						   void *const pvUserContext)
{
	HRESULT					hResultCode;
	DPNMSG_RETURN_BUFFER	Msg;

	DPF(6,"Parameters: hr [0x%lx], pvBuffer [0x%p], pvUserContext [0x%p]",hr,pvBuffer,pvUserContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_RETURN_BUFFER);
	Msg.hResultCode = hr;
	Msg.pvBuffer = pvBuffer;
	Msg.pvUserContext = pvUserContext;

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RETURN_BUFFER,reinterpret_cast<BYTE*>(&Msg));

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserEnumQuery
//
//	Send a DPN_MSGID_ENUM_QUERY message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserEnumQuery"

HRESULT DNUserEnumQuery(DIRECTNETOBJECT *const pdnObject,
						DPNMSG_ENUM_HOSTS_QUERY *const pMsg)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_ENUM_HOSTS_QUERY,reinterpret_cast<BYTE*>(pMsg));

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserEnumResponse
//
//	Send a DPN_MSGID_ENUM_RESPONSE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserEnumResponse"

HRESULT DNUserEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   DPNMSG_ENUM_HOSTS_RESPONSE *const pMsg)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_ENUM_HOSTS_RESPONSE,reinterpret_cast<BYTE*>(pMsg));

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\syncevent.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SyncEvent.h
 *  Content:    Synchronization Events FPM Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/20/99	mjn		Created
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SYNC_EVENT_H__
#define	__SYNC_EVENT_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CSyncEvent > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

extern CThreadPool *g_pThreadPool;
extern DIRECTNETOBJECT *g_DPlayInterfaces[16];

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CSyncEvent
{
	STDNEWDELETE

public:
	CSyncEvent()		// Constructor
		{
			m_hEvent = NULL;
			m_pFPOOLSyncEvent = NULL;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::~CSyncEvent"
	~CSyncEvent()		// Destructor
		{
			DNASSERT(m_hEvent == NULL);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(m_hEvent == NULL);

			m_pFPOOLSyncEvent = static_cast<CLockedContextClassFixedPool<CSyncEvent>*>(pvContext);
			if ((m_hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
			{
				DNASSERT(FALSE);
				return(FALSE);
			}
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);

			Reset();
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
			CloseHandle(m_hEvent);
			m_hEvent = NULL;
		};

	void ReturnSelfToPool( void )
		{
			m_pFPOOLSyncEvent->Release( this );
		};

	HRESULT Reset( void ) const
		{
			if (ResetEvent(m_hEvent) == 0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

	HRESULT Set( void ) const
		{
			if (SetEvent(m_hEvent) == 0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

	HRESULT WaitForEvent(const DWORD dwMilliSeconds, DIRECTNETOBJECT *pDirectNetObject) const
		{
#ifdef DPLAY_DOWORK
	//BUGBUG: [mgere] [xbox] Verify that this is the correct way to do it.
	// better method would be to check time before starting loop and then keep looping until it goes beyond the dwMilliSeconds
	//

			if (dwMilliSeconds == INFINITE)
			{
				while (1)
				{
					switch (WaitForSingleObject(m_hEvent,0))
					{
						case WAIT_TIMEOUT:
						{
						        for (DWORD i = 0; i < 16; i += 1)
							{
								if (g_DPlayInterfaces[i] != NULL)
								{
									g_DPlayInterfaces[i]->DoWork(0);
								}
							}
							break;
						}

						case WAIT_OBJECT_0:
						{
							return DPN_OK;
						}
					}
				}
			}
			else
			{
				if (WaitForSingleObject(m_hEvent,dwMilliSeconds) != WAIT_OBJECT_0)
				{
					return(DPNERR_GENERIC);
				}
			}
			return(DPN_OK);
#else
			if (WaitForSingleObject(m_hEvent,dwMilliSeconds) != WAIT_OBJECT_0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
#endif
		}

private:
	HANDLE						m_hEvent;
	CLockedContextClassFixedPool< CSyncEvent >	*m_pFPOOLSyncEvent;	// source FP of RefCountBuffers
};

#undef DPF_MODNAME

#endif	// __SYNC_EVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\worker.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       worker.cpp
 *  Content:    DNET worker thread routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/01/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added SendHostMigration functionality
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/09/00	mjn		Send Connect Info rather than just NameTable at connect
 *	01/10/00	mjn		Added SendUpdateApplicationDesc functionality
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed user notification jobs
 *	01/23/00	mjn		Implemented TerminateSession
 *	01/24/00	mjn		Added support for NameTable operation list cleanup
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	04/04/00	mjn		Added DNWTSendTerminateSession
 *	04/10/00	mjn		Added DNWTRemoveServiceProvider
 *	04/13/00	mjn		Internal sends use new Protocol Interface VTBL functions
 *				mjn		Internal sends contain dwFlags field
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/19/00	mjn		Added support to send NameTable operations directly
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/05/00	mjn		Use GetConnectionRef() to send NameTable operations
 *	05/10/00	mjn		Ensure valid local player in DNWTProcessSend()
 *	06/07/00	mjn		Pull assert in send failure case (it was handled)
 *	06/21/00	mjn		Added support to install the NameTable (from Host)
 *	06/22/00	mjn		Fixed DNWTProcessSend() to properly handle voice messages
 *	07/06/00	mjn		Use SP handle instead of interface
 *	07/21/00	mjn		RefCount cleanup
 *	07/30/00	mjn		Added DN_WORKER_JOB_TERMINATE_SESSION
 *	08/02/00	mjn		Changed DNWTProcessSend() to pass voice messages to DNReceiveUserData()
 *				mjn		Added DN_WORKER_JOB_ALTERNATE_SEND
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *	08/06/00	mjn		Added CWorkerJob
 *				mjn		Added DNQueueWorkerJob()
 *				mjn		Made DNWTSendNameTableOperation() more robust
 *	08/07/00	mjn		Removed COM_CoInitialize() and COM_CoUninitialize() calls in DNWorkerThreadProc()
 *	08/08/00	mjn		Added WORKER_JOB_PERFORM_LISTEN,DNWTPerformListen()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNWorkerThreadProc"

#ifdef DPLAY_DOWORK
DWORD DIRECTNETOBJECT::DNWorkerThreadProc(void)
{
	CWorkerJob			*pWorkerJob;

	DPF(4,"Enter: DNWorkerThreadProc");

	if (m_hWorkerCloseEvent == NULL)
	{
		return 1;
	}

	//
	//	Process one job on queue
	//
		pWorkerJob = NULL;
		DNEnterCriticalSection(&csWorkerQueue);
		if (m_bilinkWorkerJobs.GetNext() != &m_bilinkWorkerJobs)
		{
			pWorkerJob = CONTAINING_OBJECT(m_bilinkWorkerJobs.GetNext(),CWorkerJob,m_bilinkWorkerJobs);
			pWorkerJob->m_bilinkWorkerJobs.RemoveFromList();
		}
		DNLeaveCriticalSection(&csWorkerQueue);

		if (pWorkerJob == NULL)
		{
			return 1;
		}

		DPF(5,"Extracted job id [0x%lx]",pWorkerJob->GetJobType());
		switch(pWorkerJob->GetJobType())
		{
			case WORKER_JOB_INSTALL_NAMETABLE:
				{
					DPF(5,"Job: WORKER_JOB_INSTALL_NAMETABLE");
					DNWTInstallNameTable(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_INTERNAL_SEND:
				{
					DPF(5,"Job: WORKER_JOB_INTERNAL_SEND");
					DNWTProcessSend(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_PERFORM_LISTEN:
				{
					DPF(5,"Job: WORKER_JOB_PERFORM_LISTEN");
					DNWTPerformListen(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_REMOVE_SERVICE_PROVIDER:
				{
					DPF(5,"Job: WORKER_JOB_REMOVE_SERVICE_PROVIDER");
					DNWTRemoveServiceProvider(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_SEND_NAMETABLE_OPERATION:
				{
					DPF(5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION");
					DNWTSendNameTableOperation(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT:
				{
					DPF(5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT");
					DNWTSendNameTableOperationClient(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_SEND_NAMETABLE_VERSION:
				{
					DPF(5,"Job: WORKER_JOB_SEND_NAMETABLE_VERSION");
					DNWTSendNameTableVersion(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_TERMINATE:
				{
					DPF(5,"Job: WORKER_JOB_TERMINATE");
					pWorkerJob->ReturnSelfToPool();
					pWorkerJob = NULL;
					if (m_hWorkerCloseEvent != NULL)
					{
						m_hWorkerCloseEvent->Set();
					}
					return 0;
				}
			case WORKER_JOB_TERMINATE_SESSION:
				{
					DPF(5,"Job: WORKER_JOB_TERMINATE_SESSION");
					DNWTTerminateSession(this, pWorkerJob);
					break;
				}
			case WORKER_JOB_UNKNOWN:
			default:
				{
					DPFERR("Unknown Job !");
					DNASSERT(FALSE);
					break;
				}
		}

		//
		//	Return this job to the queue (clean up is automatic)
		//
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;

	DPF(5,"Processed one job on queue at this time");
	DPF(4,"Leave: DNWorkerThreadProc");

	return(0);
}
#else
DWORD WINAPI DNWorkerThreadProc(PVOID pvParam)
{
	DIRECTNETOBJECT		*pdnObject;
	CWorkerJob			*pWorkerJob;
	BOOL				fTerminate;

	DPF(4,"Worker thread starting");

	DNASSERT(pvParam != NULL);
	pdnObject = static_cast<DIRECTNETOBJECT*>(pvParam);

//	COM_CoInitialize(NULL);

	fTerminate = FALSE;
	while (!fTerminate)
	{
		DPF(5,"Worker thread waiting ...");
		if (WaitForSingleObject(pdnObject->hWorkerEvent,INFINITE) != WAIT_OBJECT_0)
			break;
		DPF(5,"Worker thread signalled");

		// Reset Event
		DPF(5,"Resetting worker thread job event");
		if (!ResetEvent(pdnObject->hWorkerEvent))
			break;

		//
		//	Process all jobs on queue
		//
		while (!fTerminate)
		{
			pWorkerJob = NULL;
			DNEnterCriticalSection(&pdnObject->csWorkerQueue);
			if (pdnObject->m_bilinkWorkerJobs.GetNext() != &pdnObject->m_bilinkWorkerJobs)
			{
				pWorkerJob = CONTAINING_OBJECT(pdnObject->m_bilinkWorkerJobs.GetNext(),CWorkerJob,m_bilinkWorkerJobs);
				pWorkerJob->m_bilinkWorkerJobs.RemoveFromList();
			}
			DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

			if (pWorkerJob == NULL)
			{
				break;
			}

			DPF(5,"Extracted job id [0x%lx]",pWorkerJob->GetJobType());
			switch(pWorkerJob->GetJobType())
			{
				case WORKER_JOB_INSTALL_NAMETABLE:
					{
						DPF(5,"Job: WORKER_JOB_INSTALL_NAMETABLE");
						DNWTInstallNameTable(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_INTERNAL_SEND:
					{
						DPF(5,"Job: WORKER_JOB_INTERNAL_SEND");
						DNWTProcessSend(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_PERFORM_LISTEN:
					{
						DPF(5,"Job: WORKER_JOB_PERFORM_LISTEN");
						DNWTPerformListen(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_REMOVE_SERVICE_PROVIDER:
					{
						DPF(5,"Job: WORKER_JOB_REMOVE_SERVICE_PROVIDER");
						DNWTRemoveServiceProvider(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_SEND_NAMETABLE_OPERATION:
					{
						DPF(5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION");
						DNWTSendNameTableOperation(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT:
					{
						DPF(5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT");
						DNWTSendNameTableOperationClient(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_SEND_NAMETABLE_VERSION:
					{
						DPF(5,"Job: WORKER_JOB_SEND_NAMETABLE_VERSION");
						DNWTSendNameTableVersion(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_TERMINATE:
					{
						DPF(5,"Job: WORKER_JOB_TERMINATE");
						fTerminate = TRUE;
						break;
					}
				case WORKER_JOB_TERMINATE_SESSION:
					{
						DPF(5,"Job: WORKER_JOB_TERMINATE_SESSION");
						DNWTTerminateSession(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_UNKNOWN:
				default:
					{
						DPFERR("Unknown Job !");
						DNASSERT(FALSE);
						break;
					}
			}

			//
			//	Return this job to the queue (clean up is automatic)
			//
			pWorkerJob->ReturnSelfToPool();
			pWorkerJob = NULL;
		}
		DPF(5,"Processed all jobs on queue at this time");
	}

//	COM_CoUninitialize();

	DPF(4,"Worker thread terminating");
	return(0);
}
#endif

//	DNQueueWorkerJob
//
//	Add a worker thread job to the end of the job queue, and signal the queue to run

void DNQueueWorkerJob(DIRECTNETOBJECT *const pdnObject,
					  CWorkerJob *const pWorkerJob)
{
	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DPF(7,"Adding job to worker job queue");
	DNEnterCriticalSection(&pdnObject->csWorkerQueue);
	pWorkerJob->m_bilinkWorkerJobs.InsertBefore(&pdnObject->m_bilinkWorkerJobs);
	DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

	DPF(7,"Signalling Worker Thread");
#ifndef DPLAY_DOWORK
	SetEvent(pdnObject->hWorkerEvent);
#endif

	DPF(6,"Returning");
}


//	DNWTTerminate
//
//	Request the worker thread to terminate by placing a terminate message on its job queue.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTTerminate"

HRESULT DNWTTerminate(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CWorkerJob	*pWorkerJob;

	DPF(6,"Adding Terminate to Job Queue");
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
	{
		pWorkerJob->SetJobType( WORKER_JOB_TERMINATE );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;
	}
	else
	{
		DPFERR("Could not create worker job - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendInternal
//
//	Send an internal message. This will copy the message buffer and place the operation on the
//	working thread job queue

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendInternal"

HRESULT DNWTSendInternal(DIRECTNETOBJECT *const pdnObject,
						 DPN_BUFFER_DESC *prgBufferDesc,
						 CAsyncOp *const pAsyncOp)
{
	HRESULT				hResultCode;
	DWORD				dwJobBufferSize;
	DPN_BUFFER_DESC		*pHeaderBuffer;
	DPN_BUFFER_DESC		*pDataBuffer;
	CWorkerJob			*pWorkerJob;
	CRefCountBuffer		*pRefCountBuffer;
	DPN_BUFFER_DESC		*pdnBufferDesc;

	DPF(6,"Parameters: prgBufferDesc [0x%p], pAsyncOp [0x%p]",prgBufferDesc,pAsyncOp);

	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	// Get buffers
	pHeaderBuffer = prgBufferDesc;
	pDataBuffer = prgBufferDesc + 1;

	// Create local buffer
	dwJobBufferSize = pHeaderBuffer->dwBufferSize + pDataBuffer->dwBufferSize;
	if ((hResultCode = RefCountBufferNew(pdnObject,dwJobBufferSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate space for local buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	else
	{
		DPF(7,"Allocated RefCount Buffer [0x%p] - [%ld] bytes",pRefCountBuffer,dwJobBufferSize);
		pdnBufferDesc = pRefCountBuffer->BufferDescAddress();
		memcpy(	pdnBufferDesc->pBufferData,
				pHeaderBuffer->pBufferData,
				pHeaderBuffer->dwBufferSize);
		memcpy(	pdnBufferDesc->pBufferData + pHeaderBuffer->dwBufferSize,
				pDataBuffer->pBufferData,
				pDataBuffer->dwBufferSize);

		//	TODO - user context value of send ?
		DPF(7,"Adding Internal Send to Job Queue");
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
		{
			pWorkerJob->SetJobType( WORKER_JOB_INTERNAL_SEND );
			pWorkerJob->SetInternalSendFlags( pAsyncOp->GetOpFlags() );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			//
			//	Invoke send completion handler
			//
			DNPICompleteSend(	pdnObject,
								static_cast<void*>(pAsyncOp),
								DPN_OK);
			
			hResultCode = DPNERR_PENDING;
		}
		else
		{
			DPFERR("Could not create worker job");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNWTProcessSend
//
//	Process an internal send message.  This will invoke the send completion handler and
//	then the receive handler with the message. It will

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTProcessSend"

HRESULT DNWTProcessSend(DIRECTNETOBJECT *const pdnObject,
						CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	void		*pvData;
	DWORD		dwDataSize;
	void		*pvInternalData;
	DWORD		dwInternalDataSize;
	DWORD		*pdwMsgId;
	CNameTableEntry	*pLocalPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	pLocalPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Extract and clear RefCountBuffer from job
	//
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);
	pRefCountBuffer = pWorkerJob->GetRefCountBuffer();
	pWorkerJob->SetRefCountBuffer( NULL );

	//
	//	Get local player's connection (if still valid)
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Local player not in NameTable (shutting down ?)");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pLocalPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Local player connection is not valid (shutting down?)");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	DNASSERT(pRefCountBuffer->GetBufferAddress() != NULL);
	pvData = pRefCountBuffer->GetBufferAddress();
	dwDataSize = pRefCountBuffer->GetBufferSize();

	if ((pWorkerJob->GetInternalSendFlags() & DN_SENDFLAGS_SET_USER_FLAG)
			&& !(pWorkerJob->GetInternalSendFlags() & DN_SENDFLAGS_SET_USER_FLAG_TWO))
	{
		//
		//	Internal message
		//
		DPF(7,"Received INTERNAL message");

		// Extract internal message
		DNASSERT(dwDataSize >= sizeof(DWORD));
		pdwMsgId = static_cast<DWORD*>(pvData);
		dwInternalDataSize = dwDataSize - sizeof(DWORD);
		if (dwInternalDataSize > 0)
		{
			pvInternalData = static_cast<void*>(static_cast<BYTE*>(pvData) + sizeof(DWORD));
		}
		else
		{
			pvInternalData = NULL;
		}

		// Process internal message
		hResultCode = DNProcessInternalOperation(	pdnObject,
													*pdwMsgId,
													pvInternalData,
													dwInternalDataSize,
													pConnection,
													NULL,
													pRefCountBuffer);
	}
	else
	{
		//
		//	User or voice message
		//
		DPF(7,"Received USER or Voice message");

		hResultCode = DNReceiveUserData(pdnObject,
										pConnection->GetDPNID(),
										static_cast<BYTE*>(pvData),
										dwDataSize,
										NULL,
										pRefCountBuffer,
										0,
										pWorkerJob->GetInternalSendFlags());
	}

	//
	//	Clean up
	//
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pConnection->Release();
	pConnection = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNWTTerminateSession
//
//	Disconnect the Local player from the session

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTTerminateSession"

HRESULT	DNWTTerminateSession(DIRECTNETOBJECT *const pdnObject,
							 CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	// Terminate session
	hResultCode = DNTerminateSession(pdnObject,pWorkerJob->GetTerminateSessionReason());

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendNameTableVersion
//
//	Send NAMETABLE_VERSION message to the host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableVersion"

HRESULT DNWTSendNameTableVersion(DIRECTNETOBJECT *const pdnObject,
								 CWorkerJob *const pWorkerJob)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Extract and clear RefCountBuffer from job
	//
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);
	pRefCountBuffer = pWorkerJob->GetRefCountBuffer();
	pWorkerJob->SetRefCountBuffer( NULL );

	// Send message to host player
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_NAMETABLE_VERSION,
								pHostPlayer->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send message to Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pConnection->Release();
	pConnection = NULL;
	pHostPlayer->Release();
	pHostPlayer = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DNWTRemoveServiceProvider
//
//	Remove a ServiceProvider from the Protocol

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTRemoveServiceProvider"

HRESULT DNWTRemoveServiceProvider(DIRECTNETOBJECT *const pdnObject,
								  CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pWorkerJob->GetRemoveServiceProviderHandle() != NULL);

	hResultCode = DNPRemoveServiceProvider(pdnObject->pdnProtocolData,pWorkerJob->GetRemoveServiceProviderHandle());

	DNProtocolRelease(pdnObject);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendNameTableOperation
//
//	Send a NameTable operation to each connected player
//	This is based on the version number supplied and an excluded DPNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableOperation"

void DNWTSendNameTableOperation(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;
	DWORD		dwMsgId;
	DWORD		dwVersion;
	DPNID		dpnidExclude;
	DWORD		dwCount;
	DWORD		dwActual;
	DWORD		dw;
	CConnection **TargetList;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	TargetList = NULL;

	dwMsgId = pWorkerJob->GetSendNameTableOperationMsgId();
	dwVersion = pWorkerJob->GetSendNameTableOperationVersion();
	dpnidExclude = pWorkerJob->GetSendNameTableOperationDPNIDExclude();

	hResultCode = DNCreateSendParent(	pdnObject,
										dwMsgId,
										pWorkerJob->GetRefCountBuffer()->BufferDescAddress(),
										DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->SetRefCountBuffer(pWorkerJob->GetRefCountBuffer());

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.Lock();

	//
	//	Determine recipient list
	//
	dwCount = 0;
	dwActual = 0;
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (	   !pNTEntry->IsDisconnecting()
				&& !pNTEntry->IsLocal()
				&& ((dwVersion == 0) || (pNTEntry->GetVersion() < dwVersion))
				&& ((dpnidExclude == 0) || (pNTEntry->GetDPNID() != dpnidExclude))
			)
		{
			dwCount++;
		}
		pBilink = pBilink->GetNext();
	}
	DPF(7,"Number of targets [%ld]",dwCount);

	//
	//	Create target list
	//
	if (dwCount > 0)
	{
		if ((TargetList = reinterpret_cast<CConnection**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CConnection*)))) == NULL)
		{
			DPFERR("Could not create target list");
			DNASSERT(FALSE);
			goto Failure;
		}

		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (	   !pNTEntry->IsDisconnecting()
					&& !pNTEntry->IsLocal()
					&& ((dwVersion == 0) || (pNTEntry->GetVersion() < dwVersion))
					&& ((dpnidExclude == 0) || (pNTEntry->GetDPNID() != dpnidExclude))
				)
			{
				DNASSERT(dwActual < dwCount);
				if ((hResultCode = pNTEntry->GetConnectionRef( &(TargetList[dwActual]) )) == DPN_OK)
				{
					dwActual++;
				}
			}
			pBilink = pBilink->GetNext();
		}
		DPF(7,"Actual number of targets [%ld]",dwActual);
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	//
	//	Send to target list
	//
	if (TargetList)
	{
		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(TargetList[dw] != NULL);

			hResultCode = DNPerformChildSend(	pdnObject,
												pParent,
												TargetList[dw],
												0,
												NULL,
												TRUE);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not perform part of group send - ignore and continue");
				DisplayDNError(0,hResultCode);
			}
			TargetList[dw]->Release();
			TargetList[dw] = NULL;
		}

		MemoryBlockFree(pdnObject,TargetList);
		TargetList = NULL;
	}

	pParent->Release();
	pParent = NULL;

Exit:
	DPF(6,"Returning");
	return;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (TargetList)
	{
		MemoryBlockFree(pdnObject,TargetList);
		TargetList = NULL;
	}
	goto Exit;
}

//	DNWTSendNameTableOperationClient
//
//	Send a NameTable operation to a single client
//	This is based on the version number supplied and a DPNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableOperationClient"

void DNWTSendNameTableOperationClient(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CNameTableEntry	*pNTEntry;
	DWORD		dwMsgId;
	DWORD		dwVersion;
	DPNID		dpnid;
	CConnection *pConnection;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	dwMsgId = pWorkerJob->GetSendNameTableOperationMsgId();
	dwVersion = pWorkerJob->GetSendNameTableOperationVersion();
	dpnid = pWorkerJob->GetSendNameTableOperationDPNIDExclude();

	hResultCode = DNCreateSendParent(	pdnObject,
										dwMsgId,
										pWorkerJob->GetRefCountBuffer()->BufferDescAddress(),
										DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->SetRefCountBuffer(pWorkerJob->GetRefCountBuffer());

	//
	//	Lookup player
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection for player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DNPerformChildSend(	pdnObject,
										pParent,
										pConnection,
										0,
										NULL,
										TRUE);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not perform send - ignore and continue");
		DisplayDNError(0,hResultCode);
	}
	pConnection->Release();
	pConnection = NULL;

	pParent->Release();
	pParent = NULL;

Exit:
	DPF(6,"Returning");
	return;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}

//	DNWTInstallNameTable
//
//	Install the Host sent NameTable and ApplicationDescription.  We will also be cracking open
//	LISTENs if required.  This has to be done on the worker thread due to the async->sync
//	behaviour of LISTEN.  We can't perform it on the SP's threads.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTInstallNameTable"

void DNWTInstallNameTable(DIRECTNETOBJECT *const pdnObject,
						  CWorkerJob *const pWorkerJob)
{
	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DNASSERT(pWorkerJob->GetConnection() != NULL);
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);

	DNConnectToHost2(	pdnObject,
						pWorkerJob->GetRefCountBuffer()->GetBufferAddress(),
						pWorkerJob->GetConnection() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNWTPerformListen"

void DNWTPerformListen(DIRECTNETOBJECT *const pdnObject,
					   CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DNASSERT(pWorkerJob->GetAddress() != NULL);
	DNASSERT(pWorkerJob->GetAsyncOp() != NULL);

	hResultCode = DNPerformListen(pdnObject,pWorkerJob->GetAddress(),pWorkerJob->GetAsyncOp());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\worker.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       worker.h
 *  Content:    DIRECT NET WORKER THREAD HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/09/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added SendHostMigration functionality
 *	01/09/00	mjn		Send Connect Info rather than just NameTable at connect
 *	01/10/00	mjn		Added support to update application descriptions
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed user notification jobs
 *	01/23/00	mjn		Implemented TerminateSession
 *	01/24/00	mjn		Added support for NameTable operation list cleanup
 *	04/04/00	mjn		Added support for TerminateSession
 *	04/13/00	mjn		Added dwFlags for internal sends
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/19/00	mjn		Added support to send NameTable operations directly
 *	06/21/00	mjn		Added support to install the NameTable (from Host)
 *	07/06/00	mjn		Use SP handle instead of interface
 *	07/30/00	mjn		Added DN_WORKER_JOB_TERMINATE_SESSION
 *	08/02/00	mjn		Added DN_WORKER_JOB_ALTERNATE_SEND
 *	08/08/00	mjn		Added DNWTPerformListen()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__WORKER_H__
#define	__WORKER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNQueueWorkerJob(DIRECTNETOBJECT *const pdnObject,
					  CWorkerJob *const pWorkerJob);

// DirectNet - Worker Thread Routines
#ifndef DPLAY_DOWORK
DWORD WINAPI DNWorkerThreadProc(PVOID pvParam);
#endif

HRESULT DNWTTerminate(DIRECTNETOBJECT *const pdnObject);

HRESULT DNWTSendInternal(DIRECTNETOBJECT *const pdnObject,
						 DPN_BUFFER_DESC *prgBufferDesc,
						 CAsyncOp *const pAsyncOp);

HRESULT DNWTProcessSend(DIRECTNETOBJECT *const pdnObject,
						CWorkerJob *const pWorkerJob);

HRESULT	DNWTTerminateSession(DIRECTNETOBJECT *const pdnObject,
							 CWorkerJob *const pWorkerJob);

HRESULT DNWTSendNameTableVersion(DIRECTNETOBJECT *const pdnObject,
								 CWorkerJob *const pWorkerJob);

HRESULT DNWTRemoveServiceProvider(DIRECTNETOBJECT *const pdnObject,
								  CWorkerJob *const pWorkerJob);

void DNWTSendNameTableOperation(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob);
void DNWTSendNameTableOperationClient(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob);
void DNWTInstallNameTable(DIRECTNETOBJECT *const pdnObject,
						  CWorkerJob *const pWorkerJob);

void DNWTPerformListen(DIRECTNETOBJECT *const pdnObject,
					   CWorkerJob *const pWorkerJob);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __WORKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\workerjob.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WorkerJob.h
 *  Content:    Worker Job Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/00	mjn		Created
 *	08/08/00	mjn		Added m_pAddress,m_pAsyncOp,WORKER_JOB_PERFORM_LISTEN
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__WORKER_JOB_H__
#define	__WORKER_JOB_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CWorkerJob;
template< class CWorkerJob > class CLockedContextClassFixedPool;

typedef enum
{
//	WORKER_JOB_ABORT_CONNECT,
	WORKER_JOB_INSTALL_NAMETABLE,
	WORKER_JOB_INTERNAL_SEND,
	WORKER_JOB_PERFORM_LISTEN,
	WORKER_JOB_REMOVE_SERVICE_PROVIDER,
	WORKER_JOB_SEND_NAMETABLE_OPERATION,
	WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT,
	WORKER_JOB_SEND_NAMETABLE_VERSION,
	WORKER_JOB_TERMINATE,
	WORKER_JOB_TERMINATE_SESSION,
	WORKER_JOB_UNKNOWN
} WORKER_JOB_TYPE;

typedef struct
{
	DWORD				dwFlags;
} WORKER_JOB_INTERNAL_SEND_DATA;

typedef struct
{
	HANDLE		hProtocolSPHandle;
} WORKER_JOB_REMOVE_SERVICE_PROVIDER_DATA;

typedef struct
{
	DWORD			dwMsgId;
	DWORD			dwVersion;
	DPNID			dpnidExclude;
} WORKER_JOB_SEND_NAMETABLE_OPERATION_DATA;

typedef struct
{
	HRESULT		hrReason;
} WORKER_JOB_TERMINATE_SESSION_DATA;

typedef union
{
	WORKER_JOB_INTERNAL_SEND_DATA				InternalSend;
	WORKER_JOB_REMOVE_SERVICE_PROVIDER_DATA		RemoveServiceProvider;
	WORKER_JOB_SEND_NAMETABLE_OPERATION_DATA	SendNameTableOperation;
	WORKER_JOB_TERMINATE_SESSION_DATA			TerminateSession;
} WORKER_JOB_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Worker Thread Jobs

class CWorkerJob
{
	STDNEWDELETE

public:
	CWorkerJob()				// Constructor
		{
			m_Sig[0] = 'W';
			m_Sig[1] = 'J';
			m_Sig[2] = 'O';
			m_Sig[3] = 'B';
		};

	~CWorkerJob() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);

			m_JobType = WORKER_JOB_UNKNOWN;
			m_pAsyncOp = NULL;
			m_pConnection = NULL;
			m_pRefCountBuffer = NULL;
			m_pAddress = NULL;
			m_bilinkWorkerJobs.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			if (m_pAsyncOp)
			{
				m_pAsyncOp->Release();
				m_pAsyncOp = NULL;
			}
			if (m_pConnection)
			{
				m_pConnection->Release();
				m_pConnection = NULL;
			}
			if (m_pRefCountBuffer)
			{
				m_pRefCountBuffer->Release();
				m_pRefCountBuffer = NULL;
			}
			if (m_pAddress)
			{
				m_pAddress->Release();
				m_pAddress = NULL;
			}

			DNASSERT(m_pConnection == NULL);
			DNASSERT(m_pRefCountBuffer == NULL);

			m_pdnObject->m_pFPOOLWorkerJob->Release( this );
		};

	void SetJobType( const WORKER_JOB_TYPE JobType )
		{
			m_JobType = JobType;
		};

	WORKER_JOB_TYPE GetJobType( void )
		{
			return( m_JobType );
		};

	void SetConnection( CConnection *const pConnection )
		{
			if (pConnection)
			{
				pConnection->AddRef();
			}
			m_pConnection = pConnection;
		};

	CConnection *GetConnection( void )
		{
			return( m_pConnection );
		};

	void SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
		{
			if (pRefCountBuffer)
			{
				pRefCountBuffer->AddRef();
			}
			m_pRefCountBuffer = pRefCountBuffer;
		};

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetInternalSendFlags"
	void SetInternalSendFlags( const DWORD dwFlags )
		{
			DNASSERT( m_JobType == WORKER_JOB_INTERNAL_SEND );

			m_JobData.InternalSend.dwFlags = dwFlags;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetInternalSendFlags"
	DWORD GetInternalSendFlags( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_INTERNAL_SEND );

			return( m_JobData.InternalSend.dwFlags );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetRemoveServiceProviderHandle"
	void SetRemoveServiceProviderHandle( const HANDLE hProtocolSPHandle )
		{
			DNASSERT( m_JobType == WORKER_JOB_REMOVE_SERVICE_PROVIDER );

			m_JobData.RemoveServiceProvider.hProtocolSPHandle = hProtocolSPHandle;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetRemoveServiceProviderHandle"
	HANDLE GetRemoveServiceProviderHandle( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_REMOVE_SERVICE_PROVIDER );

			return( m_JobData.RemoveServiceProvider.hProtocolSPHandle );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationMsgId"
	void SetSendNameTableOperationMsgId( const DWORD dwMsgId )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dwMsgId = dwMsgId;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationMsgId"
	DWORD GetSendNameTableOperationMsgId( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dwMsgId );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationVersion"
	void SetSendNameTableOperationVersion( const DWORD dwVersion )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dwVersion = dwVersion;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationVersion"
	DWORD GetSendNameTableOperationVersion( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dwVersion );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationDPNIDExclude"
	void SetSendNameTableOperationDPNIDExclude( const DPNID dpnidExclude )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dpnidExclude = dpnidExclude;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationDPNIDExclude"
	DPNID GetSendNameTableOperationDPNIDExclude( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dpnidExclude );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetTerminateSessionReason"
	void SetTerminateSessionReason( const HRESULT hrReason )
		{
			DNASSERT( m_JobType == WORKER_JOB_TERMINATE_SESSION );

			m_JobData.TerminateSession.hrReason = hrReason;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetTerminateSessionReason"
	HRESULT GetTerminateSessionReason( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_TERMINATE_SESSION );

			return( m_JobData.TerminateSession.hrReason );
		};

	void SetAsyncOp( CAsyncOp *const pAsyncOp )
		{
			if (pAsyncOp)
			{
				pAsyncOp->AddRef();
			}
			m_pAsyncOp = pAsyncOp;
		};

	CAsyncOp *GetAsyncOp( void )
		{
			return( m_pAsyncOp );
		};

	void SetAddress( IDirectPlay8Address *const pAddress )
		{
			if (pAddress)
			{
				pAddress->AddRef();
			}
			m_pAddress = pAddress;
		};

	IDirectPlay8Address *GetAddress( void )
		{
			return( m_pAddress );
		};

	CBilink				m_bilinkWorkerJobs;

private:
	BYTE				m_Sig[4];			// Signature

	WORKER_JOB_TYPE		m_JobType;

	CAsyncOp			*m_pAsyncOp;
	CConnection			*m_pConnection;
	CRefCountBuffer		*m_pRefCountBuffer;
	IDirectPlay8Address	*m_pAddress;

	WORKER_JOB_DATA		m_JobData;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __WORKER_JOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addcore.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address core implementation file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/10/2000	rmt		Updated to use DPNA_ defines instead of URL_
 * 02/12/2000	rmt		Split Get into GetByName and GetByIndex
 * 02/17/2000	rmt		Parameter validation work
 * 02/18/2000	rmt		Added type validation to all pre-defined elements
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 02/23/2000	rmt		Fixed length calculations in GetURL
 *				rmt		Buffer too small error debug messages -> Warning level
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *                      Added support for the new ANSI type
 *	05/04/00	mjn		delete temp var at end of SetElement()
 *	05/05/00	mjn		Better error cleanup in SetElement()
 *  06/06/00    rmt     Bug #36455 failure when calling with ANSI string shortcut for SP
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  06/21/2000	rmt		Bug #37392 - Leak if replacing allocated element with new item same size as GUID
 *  06/27/2000	rmt		Bug #37630 - Service provider shortcuts / element names were case sensitive
 *  07/06/2000	rmt		Bug #38714 - ADDRESSING: GetURL doesn't return the # of chars written
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *  07/12/2000	rmt		Fixed some critical section related bugs:
 *						- Added leave in an error path where it wasn't being called
 *						- Moved critical section init/delete to constructor / destructor
 *  07/13/2000	rmt		Bug #39274 - INT 3 during voice run
 *						- Fixed point where a critical section was being re-initialized
 *				rmt		Added critical sections to protect FPMs					
 * 07/21/2000	rmt		Fixed bug w/directplay 4 address parsing 
 * 07/31/2000	rmt		Bug #41125 - Addressing() GetUserData when none available should return doesnotexist
 * 08/03/2000	rmt		Missing LEAVELOCK() was causing lockups.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/



#include "dnaddri.h"

DWORD g_dwGlobalObjectCount = 0;
BOOL g_fGlobalObjectInit = FALSE;

const DWORD c_dwNumBaseStrings = 11;

const WCHAR * szBaseStrings[] =
{
	DPNA_KEY_PROVIDER,
	DPNA_KEY_DEVICE,
	DPNA_KEY_HOSTNAME,
	DPNA_KEY_PORT,
	DPNA_KEY_APPLICATION_INSTANCE,
	DPNA_KEY_BAUD,
	DPNA_KEY_FLOWCONTROL,
	DPNA_KEY_PARITY,
	DPNA_KEY_PHONENUMBER,
	DPNA_KEY_PROGRAM,
	DPNA_KEY_STOPBITS
};

const DWORD dwBaseRequiredTypes[] =
{
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_DWORD,
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_DWORD,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_STRING
};

ULONG IDirectPlay8Address_AddRef(LPDIRECTPLAY8ADDRESS pDirectPlay8Address)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->AddRef();
}
ULONG IDirectPlay8Address_Release(LPDIRECTPLAY8ADDRESS pDirectPlay8Address)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->Release();
}

HRESULT IDirectPlay8Address_BuildFromURLW(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *pwszSourceURL)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_BuildFromURLW(pDirectPlay8Address, pwszSourceURL);
}

HRESULT IDirectPlay8Address_BuildFromURLA(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, CHAR *pszSourceURL)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_BuildFromURLA(pDirectPlay8Address, pszSourceURL);
}

HRESULT IDirectPlay8Address_Duplicate(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, IDirectPlay8Address **ppdpaNewAddress)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_Duplicate(pDirectPlay8Address, ppdpaNewAddress);
}

HRESULT IDirectPlay8Address_SetEqual(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, IDirectPlay8Address *pdpaAddress)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_SetEqual(pDirectPlay8Address, pdpaAddress);
}

HRESULT IDirectPlay8Address_IsEqual(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, IDirectPlay8Address *pdpaAddress)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_IsEqual(pDirectPlay8Address, pdpaAddress);
}

HRESULT IDirectPlay8Address_Clear(LPDIRECTPLAY8ADDRESS pDirectPlay8Address)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_Clear(pDirectPlay8Address);
}

HRESULT IDirectPlay8Address_GetURLW(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *pwszURL, PDWORD pdwNumChars)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetURLW(pDirectPlay8Address, pwszURL, pdwNumChars);
}

HRESULT IDirectPlay8Address_GetURLA(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, CHAR *pszURL, PDWORD pdwNumChars)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetURLA(pDirectPlay8Address, pszURL, pdwNumChars);
}

HRESULT IDirectPlay8Address_GetSP(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pguidSP)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetSP(pDirectPlay8Address, pguidSP);
}

HRESULT IDirectPlay8Address_GetUserData(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, void *pvUserData, PDWORD pdwBufferSize)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetUserData(pDirectPlay8Address, pvUserData, pdwBufferSize);
}

HRESULT IDirectPlay8Address_SetSP(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID *const pguidSP)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_SetSP(pDirectPlay8Address, pguidSP);
}

HRESULT IDirectPlay8Address_SetUserData(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const void * const pvUserData, const DWORD dwDataSize)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_SetUserData(pDirectPlay8Address, pvUserData, dwDataSize);
}

HRESULT IDirectPlay8Address_GetNumComponents(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDWORD pdwNumComponents)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetNumComponents(pDirectPlay8Address, pdwNumComponents);
}

HRESULT IDirectPlay8Address_GetComponentByName(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetComponentByNameW(pDirectPlay8Address, pwszName, pvBuffer, pdwBufferSize, pdwDataType);
}

HRESULT IDirectPlay8Address_GetComponentByIndex(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetComponentByIndexW(pDirectPlay8Address, dwComponentID, pwszName, pdwNameLen, pvBuffer, pdwBufferSize, pdwDataType);
}

HRESULT IDirectPlay8Address_AddComponent(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_AddComponentW(pDirectPlay8Address, pwszName, lpvData, dwDataSize, dwDataType);
}

HRESULT IDirectPlay8Address_GetDevice(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pGUID)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_GetDevice(pDirectPlay8Address, pGUID);
}

HRESULT IDirectPlay8Address_SetDevice(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID * const pGUID)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8A_SetDevice(pDirectPlay8Address, pGUID);
}

LPFPOOL fpmAddressElements;
CRITICAL_SECTION g_csFPMElements;
CRITICAL_SECTION g_csSocketAccessLock;

CStringCache *g_pcstrKeyCache = NULL;

extern void Pools_Pre_Init();
extern void Pools_Deinit();
extern BOOL InitProcessGlobals( void );
extern void DeinitProcessGlobals( void );

#ifdef DPLAY_DOWORK_STATEMN
STMN_ID	g_stmnID;
extern HRESULT StateMachineHandler(PSTMN_ASYNC pstmnAsync, DWORD dwFlags);
PFNSTMN_HANDLER aStmnHandlers[1];
#endif

void GlobalInitialize(void)
{
	WORD wVersionRequested = MAKEWORD(2,2);
	WSADATA wsaData;
	int nRet = 0;
#ifdef DPLAY_DOWORK_STATEMN
	STMN_DESCRIPTOR stmnDescriptor;
	HRESULT hResult = S_OK;
#endif

	DPFINIT();

	nRet = WSAStartup( wVersionRequested, &wsaData );

	DNOSIndirectionInit();
	COM_Init();

	fpmAddressElements = FPM_Create( sizeof( DP8ADDRESSELEMENT ), NULL, 
									 DP8ADDRESSOBJECT::FPM_Element_BlockInit, 
									 DP8ADDRESSOBJECT::FPM_Element_BlockRelease, NULL );

	DP8A_STRCACHE_Init();

	InitializeCriticalSection( &g_csFPMElements );
	InitializeCriticalSection( &g_csSocketAccessLock );

	Pools_Pre_Init();

	if ( InitProcessGlobals() == FALSE )
	{
		// BUGBUG: [mgere] [xbox] Error here.  Figure out what to do.
	}

#ifdef DPLAY_DOWORK_STATEMN
	//
	// Xbox:  Add to state machine handler
	//
	aStmnHandlers[0] = StateMachineHandler;
	stmnDescriptor.wRefCount = 0;
	stmnDescriptor.wTotalStates = 1;
	stmnDescriptor.pfnCancel = NULL;  // BUGBUG: [mgere] [xbox] Revisit this.  See if we need a cancel function
	stmnDescriptor.rgpfnHandlers = aStmnHandlers;

	hResult = XONAddStateMachine( &stmnDescriptor, &g_stmnID );
	if (FAILED(hResult))
	{
		// BUGBUG: [mgere] [xbox] Remove this once we get statemachine working
		__asm int 3;
	}
#endif

	g_fGlobalObjectInit = TRUE;
}

HRESULT GlobalCleanup(void)
{
#ifdef DPLAY_DOWORK_STATEMN
	HRESULT hResult = S_OK;
#endif

	if (g_dwGlobalObjectCount != 0)
	{
		return E_FAIL;
	}

#ifdef DPLAY_DOWORK_STATEMN
	hResult = XONRemoveStateMachine( g_stmnID );
	if (FAILED(hResult))
	{
		// BUGBUG: [mgere] [xbox] Remove this once we get statemachine working
		__asm int 3;
		// E_OUTOFMEMORY can be returned...
	}
#endif

	DeinitProcessGlobals();

	Pools_Deinit();

	fpmAddressElements->Fini(fpmAddressElements);
	fpmAddressElements = NULL;

	DeleteCriticalSection( &g_csFPMElements );
	DeleteCriticalSection( &g_csSocketAccessLock );

	DP8A_STRCACHE_Free();
	COM_Free();

	DNOSIndirectionDeinit();
	WSACleanup();

	return S_OK;
}


/****************************************************************************
 *
 *  DirectPlay8AddressCreate
 *
 *  Description:
 *      Creates and initializes a DirectPlay8Address object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8AddressCreate"
HRESULT
DirectPlay8AddressCreate
(
    DWORD dwIID,
    void ** ppvInterface,
    void **pUnknown
)
{
    DP8ADDRESSOBJECT *          pDirectPlay8Address        = NULL;
    HRESULT                 hr                  = DPN_OK;
    
    RIP_ON_NOT_TRUE("DirectPlay8Create() pUnknown must be NULL", pUnknown == NULL );
    
    if (g_fGlobalObjectInit == FALSE)
    {
        return E_FAIL;
    }
    
    // Create the DirectPlay8Address object
    if(SUCCEEDED(hr))
    {
        switch (dwIID)
        {
            case IID_IDirectPlay8Address:
            {
                hr = (pDirectPlay8Address = new DP8ADDRESSOBJECT) ? S_OK : E_OUTOFMEMORY;
                break;
            }

            case IID_IDirectPlay8AddressIP:
            {
                hr = (pDirectPlay8Address = new DP8ADDRESSOBJECT) ? S_OK : E_OUTOFMEMORY;
                break;
            }

            default:
            {
                RIP("DirectPlay8Create() dwIID must be one of IID_IDirectPlay8Address | IID_IDirectPlay8AddressIP");
                return E_FAIL;
            }
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppvInterface = ADDREF(pDirectPlay8Address);
        g_dwGlobalObjectCount += 1;
    }

    // Clean up
    RELEASE(pDirectPlay8Address);

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::DP8ADDRESSOBJECT"
DP8ADDRESSOBJECT::DP8ADDRESSOBJECT(void)
{
    m_ulRefCount = 1;

    m_dwSignature = DPASIGNATURE_ADDRESS;
    DNInitializeCriticalSection( &m_csAddressLock );

    Init();

    return;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::~DP8ADDRESSOBJECT"
DP8ADDRESSOBJECT::~DP8ADDRESSOBJECT(void)
{
    g_dwGlobalObjectCount -= 1;

    Clear();

    m_dwSignature = DPASIGNATURE_ADDRESS_FREE;
    DNDeleteCriticalSection( &m_csAddressLock );

    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::AddRef"
ULONG DP8ADDRESSOBJECT::AddRef(void)
{
    ULONG                   ulRefCount;

    DNASSERT(m_ulRefCount);

    ulRefCount = ++m_ulRefCount;

    return ulRefCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Release"
ULONG DP8ADDRESSOBJECT::Release(void)
{
    ULONG                   ulRefCount;

    DNASSERT(m_ulRefCount);
    
    if(!(ulRefCount = --m_ulRefCount))
    {
        delete this;
    }

    return ulRefCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_STRCACHE_Init"
HRESULT DP8A_STRCACHE_Init()
{
	HRESULT hr;
	PWSTR	pstrTmp;
	DWORD	dwIndex;

	DNASSERT( g_pcstrKeyCache == NULL );
	g_pcstrKeyCache = new CStringCache;
	if ( g_pcstrKeyCache == NULL )
	{
		DPF( 0, "Failed to create addressing string cache!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	for( dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
	{
		hr = g_pcstrKeyCache->AddString( szBaseStrings[dwIndex], &pstrTmp );

		if( FAILED( hr ) )
		{
			DPF( 0, "Error adding base strings" );
			return hr;
		}
	}

Exit:
	return DPN_OK;

Failure:
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_STRCACHE_Free"
// Nothing needs to be done.
void DP8A_STRCACHE_Free()
{
	if ( g_pcstrKeyCache != NULL )
	{
		delete	g_pcstrKeyCache;
		g_pcstrKeyCache = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_Element_BlockInit"
void DP8ADDRESSOBJECT::FPM_Element_BlockInit( void *pvItem )
{
	memset( pvItem, 0x00, sizeof( DP8ADDRESSELEMENT ) );
	((PDP8ADDRESSELEMENT) pvItem)->dwSignature = DPASIGNATURE_ELEMENT;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_Element_BlockRelease"
void DP8ADDRESSOBJECT::FPM_Element_BlockRelease( void *pvItem )
{
	((PDP8ADDRESSELEMENT) pvItem)->dwSignature = DPASIGNATURE_ELEMENT_FREE;
}

// InternalGetElement
//
// This function does the lookup for an element by index.
//
// Requires the object lock.
//
// Does not do parameter validation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::InternalGetElement"
HRESULT DP8ADDRESSOBJECT::InternalGetElement( const DWORD dwIndex, PDP8ADDRESSELEMENT *ppaElement )
{
	CBilink *pblSearch;
	PDP8ADDRESSELEMENT paddElement;

	if( dwIndex >= m_dwElements )
		return DPNERR_DOESNOTEXIST;

	pblSearch = m_blAddressElements.GetNext();

	for( DWORD dwSearchIndex = 0; dwSearchIndex < dwIndex; dwSearchIndex++ )
	{
		pblSearch = pblSearch->GetNext();
	}
	
	*ppaElement = CONTAINING_RECORD(pblSearch, DP8ADDRESSELEMENT, blAddressElements);

	return DPN_OK;

}

// InternalGetElement
//
// This function does the lookup for an element by name.
//
// Requires the object lock.
//
// Does not do parameter validation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::InternalGetElement"
HRESULT DP8ADDRESSOBJECT::InternalGetElement( const WCHAR * const pszTag, PDP8ADDRESSELEMENT *ppaElement )
{
	CBilink *pblSearch;
	PDP8ADDRESSELEMENT paddElement;

	pblSearch = m_blAddressElements.GetNext();

	while( pblSearch != &m_blAddressElements )
	{
		paddElement = CONTAINING_RECORD(pblSearch, DP8ADDRESSELEMENT, blAddressElements);

		if( _wcsicmp( pszTag, paddElement->pszTag ) == 0 )
		{
			*ppaElement = paddElement;
			return DPN_OK;
		}

		pblSearch = pblSearch->GetNext();
	}

	return DPNERR_DOESNOTEXIST;
}

// GetElement
//
// Implements retrieval of element by name
//
// Parameter validation must be performed BEFORE calling this function.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElement"
HRESULT DP8ADDRESSOBJECT::GetElement( const WCHAR * const pszTag, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	ENTERLOCK();
	
	hr = InternalGetElement( pszTag, &paddElement );

	if( FAILED( hr ) )
	{
		DPF( 1, "Unable to find specified element hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	DNASSERT( paddElement != NULL );

	*pdwDataType = paddElement->dwType;

	if( *pdwDataSize < paddElement->dwDataSize ||
	   pvDataBuffer == NULL )
	{
		*pdwDataSize = paddElement->dwDataSize;
		DPF( DP8A_WARNINGLEVEL, "Specified buffers were too small hr=0x%x", hr );
		LEAVELOCK();		
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwDataSize = paddElement->dwDataSize;

	if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	{
		memcpy( pvDataBuffer, paddElement->uData.pvData, paddElement->dwDataSize );
	}
	else
	{
		memcpy( pvDataBuffer, &paddElement->uData, paddElement->dwDataSize );
	}

	LEAVELOCK();	

	return DPN_OK;	

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElementType"
HRESULT DP8ADDRESSOBJECT::GetElementType( const WCHAR * pszTag, PDWORD pdwType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	ENTERLOCK();

	hr = InternalGetElement( pszTag, &paddElement );

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to find specified element hr=0x%x" );
		LEAVELOCK();
		return hr;
	}

	*pdwType = paddElement->dwType;

	LEAVELOCK();

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElement"
HRESULT DP8ADDRESSOBJECT::GetElement( const DWORD dwIndex, WCHAR * pszTag, PDWORD pdwTagSize, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	if( pdwTagSize == NULL || pdwDataSize == NULL || pdwDataType == NULL )
	{
		DPF( 0, "Invalid Poiinter" );
		return DPNERR_INVALIDPOINTER;
	}

	DWORD dwTmp2 = DPNA_INDEX_INVALID;

	ENTERLOCK();

	hr = InternalGetElement( dwIndex, &paddElement );

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to find specified element hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	DNASSERT( paddElement != NULL );

	*pdwDataType = paddElement->dwType;

	if( *pdwTagSize < (wcslen( paddElement->pszTag )+1) ||
	   *pdwDataSize < paddElement->dwDataSize ||
	   pszTag == NULL ||
	   pvDataBuffer == NULL )
	{
		*pdwTagSize = paddElement->dwTagSize;
		*pdwDataSize = paddElement->dwDataSize;
		DPF( DP8A_WARNINGLEVEL, "Specified buffers were too small hr=0x%x", hr );
		LEAVELOCK();		
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwTagSize = paddElement->dwTagSize;
	*pdwDataSize = paddElement->dwDataSize;

	wcscpy( pszTag, paddElement->pszTag );

	if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	{
		memcpy( pvDataBuffer, paddElement->uData.pvData, paddElement->dwDataSize );
	}
	else
	{
		memcpy( pvDataBuffer, &paddElement->uData, paddElement->dwDataSize );
	}

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetElement"
HRESULT DP8ADDRESSOBJECT::SetElement( const WCHAR * const pszTag, const void * const pvData, const DWORD dwDataSize, const DWORD dwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr = DPN_OK;
	BOOL fReplace = FALSE;
	WCHAR *wszUnicodeString = NULL;
	DWORD dwUnicodeSize = 0;
	DWORD dwRealDataSize = dwDataSize;
	DWORD dwRealDataType = dwDataType;
	PVOID pvRealData = (void *) pvData;

	if( pvData == NULL )
		return DPNERR_INVALIDPOINTER;

	switch( dwRealDataType )
	{
	case DPNA_DATATYPE_DWORD:
		if( dwRealDataSize != sizeof( DWORD ) )
		{
			DPF( 0, "Size is wrong for element" );
			return DPNERR_INVALIDPARAM;
		}
		break;
	case DPNA_DATATYPE_GUID:
		if( dwRealDataSize != sizeof( GUID ) )
		{
			DPF( 0, "Size is wrong for GUID element" );
			return DPNERR_INVALIDPARAM;
		}
		break;
	case DPNA_DATATYPE_STRING_ANSI:
        wszUnicodeString = new WCHAR[dwRealDataSize];
        if( wszUnicodeString == NULL )
        {
            DPF( 0, "Error allocating memory for conversion" );
            return DPNERR_OUTOFMEMORY;
        }

		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );

		if( FAILED( hr ) )
		{
		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
            return DPNERR_CONVERSION;
		}
		pvRealData = wszUnicodeString;
	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
		dwRealDataType = DPNA_DATATYPE_STRING;
	    break;
	case DPNA_DATATYPE_STRING:
	case DPNA_DATATYPE_BINARY:
		break;
	default:
		DPF( 0, "Invalid data type" );
		return DPNERR_INVALIDPARAM;
		
	}

	ENTERLOCK();

    // We need to treat provider key differently, it can also take one of the provider
    // shortcut values
    if( _wcsicmp( DPNA_KEY_PROVIDER, pszTag ) == 0 )
    {
        // If it's a GUID we're golden, otherwise..
        if( dwRealDataType != DPNA_DATATYPE_GUID )
        {
            if( dwRealDataType == DPNA_DATATYPE_STRING )
            {
                if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_TCPIPPROVIDER ) == 0 )
                {
// BUGBUG: [mgere] [xbox] Must set the SP sometime...
//                    hr = SetSP( &CLSID_DP8SP_TCPIP );
                }
                else
                {
                    DPF( DP8A_ERRORLEVEL, "Provider must be specified as a GUID or a valid shortcut string" );
					hr = DPNERR_INVALIDPARAM;
					goto APPEND_ERROR;
                }

                if( FAILED( hr ) )
                {
                    DPF( DP8A_ERRORLEVEL, "Failed setting provider with shortcut hr=0x%x", hr );
                    goto APPEND_ERROR;
                }

                goto APPEND_SUCCESS;

            }
            else
            {
                DPF( DP8A_ERRORLEVEL, "Specified values is not a supported datatype for the given key" );
				hr = DPNERR_INVALIDPARAM;
				goto APPEND_ERROR;
            }
        }
    }
    else
    {
	    // Ensure that datatype is correct in case the key is a reserved key
	    for( DWORD dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
	    {
		    if( _wcsicmp( szBaseStrings[dwIndex], pszTag ) == 0 )
		    {
			    if( dwRealDataType != dwBaseRequiredTypes[dwIndex] )
			    {
				    DPF( DP8A_ERRORLEVEL, "Specified key is reserved and specified datatype is not correct for key" );
					hr = DPNERR_INVALIDPARAM;
					goto APPEND_ERROR;
			    }
			    break;
		    }
	    }
    }

	if( IsLocked() )
	{
		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		hr = DPNERR_NOTALLOWED;
		goto APPEND_ERROR;
	}

	hr = InternalGetElement( pszTag, &paddElement );

	// If the element is not already in the address we need to add an element
	if( FAILED( hr ) )
	{
		EnterCriticalSection( &g_csFPMElements );
		paddElement = (PDP8ADDRESSELEMENT) fpmAddressElements->Get( fpmAddressElements );
		LeaveCriticalSection( &g_csFPMElements );

		if( paddElement == NULL )
		{
			DPF( 0, "Error getting new element" );
			hr = DPNERR_OUTOFMEMORY;
			goto APPEND_ERROR;
		}

		hr = g_pcstrKeyCache->AddString( pszTag, &paddElement->pszTag );

		if( FAILED( hr ) )
		{
			DPF( 0, "Unable to cache tag element hr=0x%x" );
			goto APPEND_ERROR;
		}

		// Set flag to 0 
		paddElement->dwFlags = 0;
	}
	// The element is already there.  Fill in the data.
	else
	{
		DNASSERT( paddElement != NULL );

		// If the one we're replacing was on the heap AND
		// The new one doesn't need the heap or is a different size..
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP &&
		   (dwRealDataSize <= sizeof(GUID) || dwRealDataSize > paddElement->dwDataSize) )
		{
			delete paddElement->uData.pvData;
			paddElement->uData.pvData = NULL;
			paddElement->dwDataSize = 0;
		}

		// Reduce the object's string size so object string size will be correct
		m_dwStringSize -= paddElement->dwStringSize;
		fReplace = TRUE;
	}

	paddElement->dwTagSize = wcslen( pszTag )+1;

	// Can fit in the internal buffer
	if( dwRealDataSize <= sizeof( GUID ) )
	{
		memcpy( &paddElement->uData, pvRealData, dwRealDataSize );

		// Turn off heap flag in this case
		paddElement->dwFlags &= ~(DP8ADDRESS_ELEMENT_HEAP);
	}
	else
	{
		if( !fReplace || !(paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP) ||
		     paddElement->dwDataSize < dwRealDataSize )
		{
			paddElement->uData.pvData = new BYTE[dwRealDataSize];

			if( paddElement->uData.pvData == NULL )
			{
				DPF( 0, "Error allocating memory" );
				goto APPEND_ERROR;
			}
		}

		memcpy( paddElement->uData.pvData, pvRealData, dwRealDataSize );

		paddElement->dwFlags |= DP8ADDRESS_ELEMENT_HEAP;
	}

	paddElement->dwType = dwRealDataType;
	paddElement->dwDataSize = dwRealDataSize;
	paddElement->dwStringSize = 0;

	hr = CalcComponentStringSize( paddElement, &paddElement->dwStringSize );

	if( FAILED( hr ) )
	{
		DPF( 0, "Failed to determine string length hr=0x%x", hr );
		goto APPEND_ERROR;
	}

	m_dwStringSize += paddElement->dwStringSize;

	// Create shortcuts if appropriate
	if( _wcsicmp( DPNA_KEY_PROVIDER, paddElement->pszTag ) == 0 )
	{
		m_pSP = paddElement;
	}
	else if( _wcsicmp( DPNA_KEY_DEVICE, paddElement->pszTag ) == 0 )
	{
		m_pAdapter = paddElement;
	}	

	if( !fReplace )
	{
		// We are adding the SP
		if( m_pSP == paddElement )
		{
			paddElement->blAddressElements.InsertAfter( &m_blAddressElements );
		}
		// We are adding the adapter
		else if( m_pAdapter == paddElement )
		{
			if( m_pSP != NULL )
			{
				paddElement->blAddressElements.InsertAfter( &m_pSP->blAddressElements);			
			}
			else
			{
				paddElement->blAddressElements.InsertAfter( &m_blAddressElements);			
			}
		}
		// Tack it onto the end
		else
		{
			paddElement->blAddressElements.InsertBefore( &m_blAddressElements );
		}

		// Add one char length for seperator w/previous element
		if( m_dwElements > 0 )
			m_dwStringSize ++;

		m_dwElements++;	

	}

APPEND_SUCCESS:
    
	LEAVELOCK();    
	//
	//	minara added this ...
	//
	if (wszUnicodeString)
	{
		delete [] wszUnicodeString;
		wszUnicodeString = NULL;
	}

	return DPN_OK;

APPEND_ERROR:

	if( paddElement != NULL )
	{
	    if( paddElement->dwFlags && DP8ADDRESS_ELEMENT_HEAP )
	    {
	        if( paddElement->uData.pvData )
	            delete [] paddElement->uData.pvData;
	    }

		EnterCriticalSection( &g_csFPMElements );
		fpmAddressElements->Release( fpmAddressElements, paddElement );
		LeaveCriticalSection( &g_csFPMElements );
	}

	if( wszUnicodeString != NULL )
	    delete [] wszUnicodeString;

	LEAVELOCK();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Init"
HRESULT DP8ADDRESSOBJECT::Init( )
{
	ENTERLOCK();

	m_dwElements = 0;
	m_pSP = NULL;
	m_pAdapter = NULL;
	m_pvUserData = NULL;
	m_dwUserDataSize = 0;
	m_dwStringSize = DNURL_LENGTH_HEADER;
	m_dwUserDataStringSize = 0;
	m_iLockCount  = 0;
	m_fValid = FALSE;
	m_blAddressElements.Initialize();

	LEAVELOCK();
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::IsValid"
BOOL DP8ADDRESSOBJECT::IsValid()
{
	/*if( m_dwElements < 1 )
		return FALSE;

	if( !m_pSP )
		return FALSE;*/

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Clear"
HRESULT DP8ADDRESSOBJECT::Clear( )
{
	HRESULT				hResultCode = S_OK;
	CBilink 				*pbl, *pblToDelete;
	PDP8ADDRESSELEMENT paddElement;

	ENTERLOCK();	

	if( IsLocked() )
	{
		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		LEAVELOCK();
		return DPNERR_NOTALLOWED;
	}	

	pbl = m_blAddressElements.GetNext();

	// Destroy Address Members address members
	while( !m_blAddressElements.IsEmpty() )
	{
		paddElement = CONTAINING_RECORD(m_blAddressElements.GetNext(), DP8ADDRESSELEMENT, blAddressElements);

		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			delete paddElement->uData.pvData;
		}		
		
		pbl->RemoveFromList();

		EnterCriticalSection( &g_csFPMElements );
		fpmAddressElements->Release( fpmAddressElements, paddElement );
		LeaveCriticalSection( &g_csFPMElements );

		pbl = m_blAddressElements.GetNext();
	}

	if( m_pvUserData != NULL )
	{
		delete m_pvUserData;
		m_pvUserData = NULL;
		m_dwUserDataSize = 0;
	}

	m_fValid = FALSE;	

	LEAVELOCK();

	Init( );

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetSP"
HRESULT DP8ADDRESSOBJECT::GetSP( GUID * pGuid )
{
	return DPNERR_UNSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetSP"
HRESULT DP8ADDRESSOBJECT::SetSP( LPCGUID const pGuid )
{
	// On Xbox always return OK even if it fails.  It's not necessary to explicitly set the SP -- it is always set to TCPIP.
	//
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetDevice"
HRESULT DP8ADDRESSOBJECT::GetDevice( GUID * pGuid )
{
	return DPNERR_UNSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetDevice"
HRESULT DP8ADDRESSOBJECT::SetDevice( const GUID * const pGuid )
{
	HRESULT hr;
	
	// BUBBUG: [mgere] [xbox] Remove this code once we determine that it's no longer called.
	if( pGuid == NULL )
	{
		DPF( 0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	hr = SetElement( DPNA_KEY_DEVICE, pGuid, sizeof( GUID ), DPNA_DATATYPE_GUID );

	if( FAILED( hr ) )
	{
		DPF( 0, "Adding SP element failed hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetUserData"
HRESULT DP8ADDRESSOBJECT::SetUserData( const void * const pvData, const DWORD dwDataSize )
{
	if( pvData == NULL && dwDataSize > 0 )
	{
		DPF( 0, "Invalid param" );
		return DPNERR_INVALIDPARAM;
	}

	ENTERLOCK();

	if( IsLocked() )
	{
		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		LEAVELOCK();
		return DPNERR_NOTALLOWED;
	}	

	if( m_dwUserDataSize > 0 )
	{
		// Remove escaped user data
		m_dwStringSize -= m_dwUserDataStringSize;
	}
	
	if( dwDataSize == 0 )
	{
		m_dwUserDataSize = 0;
		if( m_pvUserData != NULL )
			delete m_pvUserData;
		m_pvUserData = NULL;
		LEAVELOCK();
		return DPN_OK;
	}

	PBYTE pNewDataBuffer;

	if( dwDataSize > m_dwUserDataSize )
	{
		pNewDataBuffer = new BYTE[dwDataSize];

		if( pNewDataBuffer == NULL )
		{
			DPF( 0, "Error allocating memory" );
			LEAVELOCK();			
			return DPNERR_OUTOFMEMORY;
		}

		if( m_pvUserData != NULL )
		{
			delete [] m_pvUserData;
		}

		m_pvUserData = pNewDataBuffer;
	}

	m_dwUserDataStringSize = CalcExpandedBinarySize( (PBYTE) pvData, dwDataSize );

	m_dwStringSize += m_dwUserDataStringSize;
	m_dwStringSize += DNURL_LENGTH_USERDATA_SEPERATOR;

	memcpy( m_pvUserData, pvData, dwDataSize );
	m_dwUserDataSize = dwDataSize;

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetUserData"
HRESULT DP8ADDRESSOBJECT::GetUserData( void * pvDataBuffer, PDWORD pdwDataSize )
{
	if( pdwDataSize == NULL )
	{
		DPF( 0, "Must specify a pointer for the size" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_dwUserDataSize == 0 )
	{
		LEAVELOCK();
		DPF( DP8A_WARNINGLEVEL, "No user data was specified for this address" );
		return DPNERR_DOESNOTEXIST;
	}

	if( *pdwDataSize < m_dwUserDataSize )
	{
		*pdwDataSize = m_dwUserDataSize;
		LEAVELOCK();		
		DPF( DP8A_WARNINGLEVEL, "Buffer too small" );
		return DPNERR_BUFFERTOOSMALL;
	}

	memcpy( pvDataBuffer, m_pvUserData, m_dwUserDataSize );

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Cleanup"
HRESULT DP8ADDRESSOBJECT::Cleanup()
{
	Clear();
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcExpandedBinarySize"
DWORD DP8ADDRESSOBJECT::CalcExpandedBinarySize( PBYTE pbData, DWORD dwDataSize )
{
	PBYTE pbCurrentLocation = pbData;
	DWORD dwCount = 0;

	for( DWORD dwIndex = 0; dwIndex < dwDataSize; dwIndex++ )
	{
		if( IsEscapeChar( (WCHAR) *pbCurrentLocation ) )
		{
			if( ((WCHAR) *pbCurrentLocation) == DPNA_ESCAPECHAR )
				dwCount += 2;
			else
				dwCount+=3;
		}
		else
		{
			dwCount++;
		}

		pbCurrentLocation++;
	}

	return dwCount;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcExpandedStringSize"
DWORD DP8ADDRESSOBJECT::CalcExpandedStringSize( WCHAR *szString )
{
	WCHAR *szCurrentLocation = szString;
	DWORD dwCount = 0;

	while( *szCurrentLocation )
	{
		if( IsEscapeChar( *szCurrentLocation ) )
		{
			if( *szCurrentLocation == DPNA_ESCAPECHAR )
				dwCount += 2;
			else
				dwCount+=3;
		}
		else
		{
			dwCount++;
		}

		szCurrentLocation++;
	}

	return dwCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcComponentStringSize"
HRESULT DP8ADDRESSOBJECT::CalcComponentStringSize( PDP8ADDRESSELEMENT paddElement, PDWORD pdwSize )
{
	if( paddElement == NULL )
		return DPNERR_INVALIDPOINTER;

	if( paddElement->dwType == DPNA_DATATYPE_GUID )
	{
		*pdwSize = DNURL_LENGTH_GUID;
	}
	else if( paddElement->dwType == DPNA_DATATYPE_DWORD )
	{
		WCHAR tmpString[DNURL_LENGTH_DWORD+1];
		
		swprintf( tmpString, L"%d", paddElement->uData.dwData );		
		
		*pdwSize = wcslen(tmpString);	
	}
	// No WWCHARs need to be escaped
	else if( paddElement->dwType == DPNA_DATATYPE_STRING )
	{
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			*pdwSize = CalcExpandedStringSize( (WCHAR *) paddElement->uData.pvData );
		}
		else
		{
			*pdwSize = CalcExpandedStringSize( paddElement->uData.szData );		
		}
	}
	// Every WWCHAR needs to be escaped
	else
	{
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			*pdwSize = CalcExpandedBinarySize( (BYTE *) paddElement->uData.pvData, paddElement->dwDataSize );
		}
		else
		{
			*pdwSize = CalcExpandedBinarySize( (BYTE *) paddElement->uData.szData, paddElement->dwDataSize );		
		}	
	}

	// Add on the tag
	*pdwSize += paddElement->dwTagSize-1;

	// Add on the = and the ;
	(*pdwSize) ++;

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::IsEscapeChar"
BOOL DP8ADDRESSOBJECT::IsEscapeChar( WCHAR ch )
{
	if( ch >= L'A' && ch <= L'Z' )
		return FALSE;

	if( ch >= L'a' && ch <= L'z' )
		return FALSE;

	if( ch >= L'0' && ch <= L'9' )
		return FALSE;

	if( ch == L'-' || ch == L'?' || ch == L'.' ||
		ch == L',' || ch == 'L+' || ch == L'_' )
		return FALSE;

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddString"
void DP8ADDRESSOBJECT::BuildURL_AddString( WCHAR *szElements, WCHAR *szSource )
{
	WCHAR *szSourceLoc = szSource;
	WCHAR tmpEscape[4];
	DWORD dwIndex;

	while( *szSourceLoc )
	{
		if( IsEscapeChar( *szSourceLoc ) )
		{
			if( *szSourceLoc == DPNA_ESCAPECHAR )
			{
				wcscat( szElements, L"%%" );
			}
			else
			{
				swprintf( tmpEscape, L"%%%02.2X", (DWORD) *szSourceLoc );
				wcscat( szElements, tmpEscape );		
			}
		}
		else
		{
			dwIndex = wcslen(szElements);
			szElements[dwIndex] = *szSourceLoc;
			szElements[dwIndex+1] = 0;
		}

		szSourceLoc++;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddElements"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddElements( WCHAR *szElements )
{
	DP8ADDRESSELEMENT *pCurrentElement;
	CBilink *pblRunner;
	WCHAR tmpString[DNURL_LENGTH_GUID+2];
	BOOL fFirstElement = TRUE;
	DWORD dwTmpLength;

	pblRunner = m_blAddressElements.GetNext();

	while( pblRunner != &m_blAddressElements )
	{
		pCurrentElement = CONTAINING_RECORD(pblRunner, DP8ADDRESSELEMENT, blAddressElements);

		if( !fFirstElement )
		{
			dwTmpLength = wcslen(szElements);
			szElements[dwTmpLength] = DPNA_SEPARATOR_COMPONENT;
			szElements[dwTmpLength+1] = 0;
		}

		wcscat( szElements, pCurrentElement->pszTag );

		dwTmpLength = wcslen(szElements);
		szElements[dwTmpLength] = DPNA_SEPARATOR_KEYVALUE;
		szElements[dwTmpLength+1] = 0;
	
		if( pCurrentElement->dwType == DPNA_DATATYPE_STRING )
		{
			if( pCurrentElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
			{
				BuildURL_AddString( szElements, (WCHAR *) pCurrentElement->uData.pvData );			
			}
			else
			{
				BuildURL_AddString( szElements, pCurrentElement->uData.szData );
			}
		}
		else if( pCurrentElement->dwType == DPNA_DATATYPE_GUID )
		{
			swprintf( tmpString, L"%%7B%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X%%7D",
    		       pCurrentElement->uData.guidData.Data1, pCurrentElement->uData.guidData.Data2, pCurrentElement->uData.guidData.Data3,
    		       pCurrentElement->uData.guidData.Data4[0], pCurrentElement->uData.guidData.Data4[1],
    		       pCurrentElement->uData.guidData.Data4[2], pCurrentElement->uData.guidData.Data4[3],
		           pCurrentElement->uData.guidData.Data4[4], pCurrentElement->uData.guidData.Data4[5],
		           pCurrentElement->uData.guidData.Data4[6], pCurrentElement->uData.guidData.Data4[7] );			
		    wcscat( szElements, tmpString );
		}
		else if( pCurrentElement->dwType == DPNA_DATATYPE_DWORD )
		{
			swprintf( tmpString, L"%d", pCurrentElement->uData.dwData );	
			wcscat( szElements, tmpString );
		}
		// Binary
		else
		{
			if( pCurrentElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
			{
				BuildURL_AddBinaryData( szElements, (BYTE *) pCurrentElement->uData.pvData , pCurrentElement->dwDataSize );				
			}
			else
			{
				BuildURL_AddBinaryData( szElements, ((BYTE *) &pCurrentElement->uData), pCurrentElement->dwDataSize );
			}
		}

		fFirstElement = FALSE;
		
		pblRunner = pblRunner->GetNext();
	}

	return DPN_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddHeader"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddHeader( WCHAR *szWorking )
{
	WCHAR *szReturn;

	wcscpy( szWorking, DPNA_HEADER );

	szReturn = szWorking + wcslen( DPNA_HEADER );

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddUserData"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddUserData(WCHAR * szWorking)
{
	return BuildURL_AddBinaryData( szWorking, (BYTE *) m_pvUserData, m_dwUserDataSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddBinaryData"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddBinaryData( WCHAR *szSource, BYTE *bData, DWORD dwDataLen )
{
	BYTE *szSourceLoc = bData;
	WCHAR tmpEscape[4];
	DWORD dwIndex = 0;

	for( dwIndex = 0; dwIndex < dwDataLen; dwIndex++ )
	{
		if( IsEscapeChar( (WCHAR) *szSourceLoc ) )
		{
			swprintf( tmpEscape, L"%%%02.2X", (DWORD) *szSourceLoc );
			wcscat( szSource, tmpEscape );		
		}
		else
		{
			dwIndex = wcslen(szSource);
			szSource[dwIndex] = (WCHAR) *szSourceLoc;
			szSource[dwIndex+1] = 0;
		}

		szSourceLoc++;
	}
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL"
HRESULT DP8ADDRESSOBJECT::BuildURL( WCHAR * szURL, PDWORD pdwRequiredSize )
{
	if( pdwRequiredSize == NULL )
	{
		DPF( 0, "Must specify valid pointer for size" );
		return DPNERR_INVALIDPOINTER;
	}

	HRESULT hr;

	ENTERLOCK();

	// Address must be valid
	if( !IsValid() )
	{
		DPF( DP8A_ERRORLEVEL, "Address is not valid" );
		LEAVELOCK();
		return DPNERR_INVALIDURL;
	}

	if( *pdwRequiredSize < m_dwStringSize || szURL == NULL )
	{
		*pdwRequiredSize = m_dwStringSize;
		DPF( DP8A_WARNINGLEVEL, "Buffer too small" );
		LEAVELOCK();
		return DPNERR_BUFFERTOOSMALL;
	}

	hr = BuildURL_AddHeader( szURL );

	if( FAILED( hr ) )
	{
		DPF( 0, "Error adding header hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	hr = BuildURL_AddElements( szURL );

	if( FAILED( hr ) )
	{
		DPF( 0, "Error adding elements hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}
	
	hr = BuildURL_AddUserData( szURL );

	if( FAILED( hr ) )
	{
		DPF( 0, "Error adding user data hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	LEAVELOCK();

	*pdwRequiredSize = m_dwStringSize;

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetURL"
HRESULT DP8ADDRESSOBJECT::SetURL( WCHAR * szURL )
{
	HRESULT hr;

	DP8ADDRESSPARSE dp8aParser;

	if( IsLocked() )
	{
		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		return DPNERR_NOTALLOWED;
	}

	hr = Clear();

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to clear existing address hr=0x%x", hr );
		return hr;
	}

	ENTERLOCK();	

	hr = dp8aParser.ParseURL(this, szURL);

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error parsing the URL hr=0x%x", hr );
		LEAVELOCK();
		return hr;
	}

	LEAVELOCK();	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Lock"
HRESULT DP8ADDRESSOBJECT::	Lock(  )
{
	ENTERLOCK();	

	m_iLockCount++;

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::UnLock"
HRESULT DP8ADDRESSOBJECT::	UnLock(  )
{
	ENTERLOCK();	

	if( m_iLockCount == 0 )
	{
		DPF( 0, "Unlocking unlocked object is not allowed" );
		LEAVELOCK();
		return DPNERR_NOTALLOWED;
	}

	m_iLockCount--;

	LEAVELOCK();	

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.cpp
 *  Content:    DirectPlay8Address Internal interace file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

HRESULT IDirectPlay8Address_Lock(LPDIRECTPLAY8ADDRESS pDirectPlay8Address)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->Lock();
}

HRESULT IDirectPlay8Address_UnLock(LPDIRECTPLAY8ADDRESS pDirectPlay8Address)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->UnLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addbase.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address TCP interace file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/12/2000	rmt		Split Get into GetByName and GetByIndex
 * 02/17/2000	rmt		Parameter validation work
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *                      Added support for the new ANSI type
 *                      Added SetEqual function
 * 03/24/2000	rmt		Added IsEqual function
 * 04/21/2000   rmt     Bug #32952 - Does not run on Win95 GOLD pre-IE4
 * 05/01/2000   rmt     Bug #33074 - Debug accessing invalid memory
 * 05/17/2000   rmt     Bug #35051 - Incorrect function names in debug spew
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat
 * 07/21/2000	rmt		Fixed bug w/directplay 4 address parsing
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_IsEqual"
HRESULT DP8ADDRESSOBJECT::DP8A_IsEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8ExternalAddress )
{
	DP8ADDRESSOBJECT *pdp8Address = this;

	RIP_ON_NOT_TRUE( "IsEqual() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	HRESULT hr;
	WCHAR *wszFirstURL = NULL,
		  *wszSecondURL = NULL;
	DWORD dwFirstBufferSize = 0,
	      dwSecondBuffersize = 0;

	DPF( DP8A_ENTERLEVEL, "Enter" );

	RIP_ON_NOT_TRUE( "IsEqual() Invalid pointer specified", pdp8ExternalAddress != NULL );
	RIP_ON_NOT_TRUE( "IsEqual() Invalid object", DP8A_VALID( pdp8ExternalAddress ) );

	hr = pInterface->GetURLW( wszFirstURL, &dwFirstBufferSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPF( 0, "Could not get URL size for current object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	wszFirstURL = new WCHAR[dwFirstBufferSize];

	if( wszFirstURL == NULL )
	{
		DPF( 0, "Error allocating memory hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = pInterface->GetURLW( wszFirstURL, &dwFirstBufferSize );

	if( FAILED( hr ) )
	{
		DPF( 0, "Could not get URL for current object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = pdp8ExternalAddress->GetURLW( wszSecondURL, &dwSecondBuffersize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPF( 0, "Could not get URL size for exterior object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	wszSecondURL = new WCHAR[dwSecondBuffersize];

	if( wszSecondURL == NULL )
	{
		DPF( 0, "Error allocating memory hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = pdp8ExternalAddress->GetURLW( wszSecondURL, &dwSecondBuffersize );

	if( FAILED( hr ) )
	{
		DPF( 0, "Could not get URL for exterior object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	if( _wcsicmp( wszFirstURL, wszSecondURL ) == 0 )
	{
		hr = DPNSUCCESS_EQUAL;
	}
	else
	{
		hr = DPNSUCCESS_NOTEQUAL;
	}

ISEQUAL_ERROR:

	if( wszFirstURL != NULL )
		delete [] wszFirstURL;

	if( wszSecondURL != NULL )
		delete [] wszSecondURL;

	DP8A_RETURN( hr );

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetEqual"
HRESULT DP8ADDRESSOBJECT::DP8A_SetEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8ExternalAddress )
{
	RIP_ON_NOT_TRUE( "SetEqual() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;

	HRESULT hr;
	WCHAR *wszURLBuffer = NULL;
	DWORD dwBufferSize = 0;

	DPF( DP8A_ENTERLEVEL, "Enter" );

	RIP_ON_NOT_TRUE( "SetEqual() Invalid pointer specified", pdp8ExternalAddress != NULL );
	RIP_ON_NOT_TRUE( "SetEqual() Invalid object", DP8A_VALID( pdp8ExternalAddress ) );

    // Get ourselves a reference for duration of the call
	pdp8ExternalAddress->AddRef();

	hr = pdp8ExternalAddress->GetURLW( wszURLBuffer, &dwBufferSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
	    DPF( DP8A_ERRORLEVEL, "Error getting contents of passed address hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

	wszURLBuffer = new WCHAR[dwBufferSize];

	if( wszURLBuffer == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
		goto SETEQUAL_CLEANUP;
	}

	hr = pdp8ExternalAddress->GetURLW( wszURLBuffer, &dwBufferSize );

	if( FAILED( hr ) )
	{
	    DPF( DP8A_ERRORLEVEL, "Error getting contents of passed address w/buffer hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

	hr = pdp8Address->SetURL( wszURLBuffer );

	if( FAILED( hr ) )
	{
	    DPF( DP8A_ERRORLEVEL, "Error setting address to match passed address hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

SETEQUAL_CLEANUP:

    pdp8ExternalAddress->Release();

    if( wszURLBuffer != NULL )
        delete [] wszURLBuffer;

    DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromDirectPlay4Address"
HRESULT DP8ADDRESSOBJECT::DP8A_BuildFromDirectPlay4Address( IDirectPlay8Address *pInterface, void * pvDataBuffer, DWORD dwDataSize )
{
    DP8A_RETURN( DPNERR_UNSUPPORTED );
}

// DP8A_BuildFromURLA
//
// Initializes this object with URL specified in ANSI
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromURLA"
HRESULT DP8ADDRESSOBJECT::DP8A_BuildFromURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress )
{
	RIP_ON_NOT_TRUE( "BuildFromURLA() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;

	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "BuildFromURLA() Invalid pointer to address.  An address must be specified", pszAddress != NULL );
	RIP_ON_NOT_TRUE( "BuildFromURLA() Invalid string specified for address", DNVALID_STRING_A( pszAddress ) );

	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );

	WCHAR *szShadowBuffer = NULL;

	DWORD dwStrSize = 0;

	if( pszAddress != NULL )
	{
		dwStrSize = strlen(pszAddress)+1;
		
		szShadowBuffer = new WCHAR[dwStrSize];

		if( szShadowBuffer == NULL )
		{
			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
			hr = DPNERR_OUTOFMEMORY;
			goto BUILDFROMURLW_RETURN;
		}

		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
		{
			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
			hr = DPNERR_CONVERSION;
			goto BUILDFROMURLW_RETURN;
		}
	}

	hr = pdp8Address->SetURL( szShadowBuffer );

BUILDFROMURLW_RETURN:

	if( szShadowBuffer )
		delete [] szShadowBuffer;

	DP8A_RETURN( hr );	
}

// DP8A_BuildFromURLW
//
// Initializes this object with URL specified in Unicode
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromURLW"
HRESULT DP8ADDRESSOBJECT::DP8A_BuildFromURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress )

{
	RIP_ON_NOT_TRUE( "BuildFromURLW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;

	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "BuildFromURLW() Invalid pointer to address.  An address must be specified", pwszAddress != NULL );
	RIP_ON_NOT_TRUE( "BuildFromURLW() Invalid string specified for address", DNVALID_STRING_W( pwszAddress ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p", pwszAddress );

	hr = pdp8Address->SetURL( pwszAddress );

	DP8A_RETURN( hr );	
}

// DP8A_Duplicate
//
// Creates and initializes another address object as a duplicate to this one.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Duplicate"
HRESULT DP8ADDRESSOBJECT::DP8A_Duplicate( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS *ppInterface )
{
	RIP_ON_NOT_TRUE( "Duplicate() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	WCHAR *szTmpURL = NULL;
	DWORD dwURLSize = 0;
	LPDIRECTPLAY8ADDRESS lpdp8Address = NULL;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "Duplicate() Invalid pointer to pointer specified in ppInterface", !( ppInterface == NULL || !DNVALID_WRITEPTR( ppInterface, sizeof(LPVOID) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "ppInterface = 0x%p", ppInterface );	

	hr = pdp8Address->BuildURL( szTmpURL, &dwURLSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPF( DP8A_ERRORLEVEL, "BuildURL from object failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
	}

	szTmpURL = new WCHAR[dwURLSize];

	if( szTmpURL == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( DP8A_ERRORLEVEL, "Memory alloc failure" );
		goto DUPLICATE_FAIL;	
	}

	hr = pdp8Address->BuildURL( szTmpURL, &dwURLSize );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "BuildURL from object failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
	}
	
	hr = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &lpdp8Address, NULL );

	if( FAILED( hr ) )
    {
		DPF( DP8A_ERRORLEVEL, "CoCreate failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
    }

    hr = lpdp8Address->BuildFromURLW( szTmpURL );

    if( FAILED( hr ) )
    {
    	DPF( DP8A_ERRORLEVEL, "BuildFailed hr=0x%x", hr );
    	goto DUPLICATE_FAIL;
    }

    *ppInterface = lpdp8Address;

	if( szTmpURL != NULL )
		delete [] szTmpURL;

    return DPN_OK;

DUPLICATE_FAIL:

	if( lpdp8Address != NULL )
		lpdp8Address->Release();

	if( szTmpURL != NULL )
		delete [] szTmpURL;

	return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetURLA"
HRESULT DP8ADDRESSOBJECT::DP8A_GetURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress, PDWORD pdwAddressSize )

{
	RIP_ON_NOT_TRUE( "GetURLA() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;

	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "GetURLA() Invalid pointer specified for address size", !( pdwAddressSize == NULL || !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) ) );
	RIP_ON_NOT_TRUE( "GetURLA() Invalid pointer specified for address", !( *pdwAddressSize > 0 && (pszAddress == NULL || !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
	     pszAddress , pdwAddressSize, *pdwAddressSize );

	WCHAR *szShadowBuffer = NULL;

	if( *pdwAddressSize  != 0 )
	{
		szShadowBuffer = new WCHAR[*pdwAddressSize];

		if( szShadowBuffer == NULL )
		{
			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
			hr = DPNERR_OUTOFMEMORY;
			goto GETURLW_RETURN;
		}
	}
	else
	{	
		szShadowBuffer= NULL;
	}

	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );

	if( hr == DPN_OK )
	{
		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
		{
			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
			hr = DPNERR_CONVERSION;
			goto GETURLW_RETURN;
		}
	}
	
GETURLW_RETURN:

	if( szShadowBuffer != NULL )
		delete [] szShadowBuffer;

	DP8A_RETURN( hr );
}

// DP8A_GetURLW
//
// Retrieves the URL represented by this object in Unicode format
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetURLW"
HRESULT DP8ADDRESSOBJECT::DP8A_GetURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressSize )
{
	RIP_ON_NOT_TRUE( "GetURLW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;

	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "GetURLW() Invalid pointer specified for address size", !( pdwAddressSize == NULL || !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) ) );
	RIP_ON_NOT_TRUE( "GetURLW() Invalid pointer specified for address", !( *pdwAddressSize > 0 && (pwszAddress == NULL || !DNVALID_WRITEPTR( pwszAddress, (*pdwAddressSize)*sizeof(WCHAR) ) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
	     pwszAddress, pdwAddressSize, *pdwAddressSize );

	hr = pdp8Address->BuildURL( pwszAddress, pdwAddressSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetSP"
HRESULT DP8ADDRESSOBJECT::DP8A_GetSP( IDirectPlay8Address *pInterface, GUID * pguidSP )
{
	RIP_ON_NOT_TRUE( "GetSP() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pguidSP = 0x%p ", pguidSP );

	hr = pdp8Address->GetSP( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetUserData"
HRESULT DP8ADDRESSOBJECT::DP8A_GetUserData( IDirectPlay8Address *pInterface, void * pBuffer, PDWORD pdwBufferSize )
{
	RIP_ON_NOT_TRUE( "GetUserData() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "GetUserData() Invalid pointer specified for pdwBufferSize", !( pdwBufferSize == NULL || !DNVALID_WRITEPTR( pdwBufferSize, sizeof( DWORD ) ) ) );
	RIP_ON_NOT_TRUE( "GetUserData() Invalid pointer specified for pdwBufferSize", !( *pdwBufferSize > 0 && (pBuffer == NULL || !DNVALID_WRITEPTR( pBuffer, *pdwBufferSize ) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pBuffer = 0x%p pdwBufferSize = 0x%p(%u) ", pBuffer, pdwBufferSize, *pdwBufferSize );

	hr = pdp8Address->GetUserData( pBuffer, pdwBufferSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetSP"
HRESULT DP8ADDRESSOBJECT::DP8A_SetSP( IDirectPlay8Address *pInterface, const GUID * const pguidSP )
{
	RIP_ON_NOT_TRUE( "SetSP() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pguidSP = 0x%p", pguidSP );

	hr = pdp8Address->SetSP( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetDevice"
HRESULT DP8ADDRESSOBJECT::DP8A_GetDevice( IDirectPlay8Address *pInterface, GUID * pguidSP )
{
	RIP_ON_NOT_TRUE( "GetDevice() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pguidDevice = 0x%p", pguidSP );	

	hr = pdp8Address->GetDevice( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetDevice"
HRESULT DP8ADDRESSOBJECT::DP8A_SetDevice( IDirectPlay8Address *pInterface, const GUID * const pguidSP )
{
	RIP_ON_NOT_TRUE( "SetDevice() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pguidDevice = 0x%p", pguidSP );		

	hr = pdp8Address->SetDevice( pguidSP );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid parameters", hr != DPNERR_INVALIDPARAM );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetUserData"
HRESULT DP8ADDRESSOBJECT::DP8A_SetUserData( IDirectPlay8Address *pInterface, const void * const pBuffer, const DWORD dwBufferSize )
{
	RIP_ON_NOT_TRUE( "SetUserData() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "SetUserData() Invalid pointer specified for pBuffer", !( dwBufferSize > 0 && (pBuffer == NULL || !DNVALID_READPTR( pBuffer, dwBufferSize ) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pBuffer = 0x%p dwBufferSize = %u", pBuffer, dwBufferSize );		

	hr = pdp8Address->SetUserData( pBuffer, dwBufferSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetNumComponents"
HRESULT DP8ADDRESSOBJECT::DP8A_GetNumComponents( IDirectPlay8Address *pInterface, PDWORD pdwNumComponents )
{
	RIP_ON_NOT_TRUE( "GetNumComponents() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "GetNumComponents() Invalid ptr for num of components", !( pdwNumComponents == NULL || !DNVALID_WRITEPTR( pdwNumComponents, sizeof(DWORD) ) ) );

	*pdwNumComponents = pdp8Address->GetNumComponents();

	DP8A_RETURN( DPN_OK );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetComponentByNameW"
HRESULT DP8ADDRESSOBJECT::DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
{
	RIP_ON_NOT_TRUE( "GetComponentByNameW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "GetComponentByNameW() Invalid pointer to tag.  A name must be specified", pwszTag != NULL );
	RIP_ON_NOT_TRUE( "GetComponentByNameW() Invalid Pointer to data size", !( pdwComponentSize == NULL || !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD)) ) );
	RIP_ON_NOT_TRUE( "GetComponentByNameW() Invalid pointer to data type", !( pdwDataType == NULL || !DNVALID_READPTR( pdwDataType, sizeof(DWORD)) ) );
	RIP_ON_NOT_TRUE( "GetComponentByNameW() Invalid pointer to component data", !( *pdwComponentSize > 0 && (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) ) );
	RIP_ON_NOT_TRUE( "GetComponentByNameW() Invalid string specified for tag", DNVALID_STRING_W( pwszTag ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszTag = 0x%p pComponentBuffer = 0x%p, pdwComponentSize = 0x%p, pdwDataType = 0x%p",
		(pwszTag==NULL) ? NULL : pwszTag, pComponentBuffer, pdwComponentSize, pdwDataType );

	hr = pdp8Address->GetElement( pwszTag, pComponentBuffer, pdwComponentSize, pdwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetComponentByIndexW"
HRESULT DP8ADDRESSOBJECT::DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface,
	const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen,
	void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
{
	RIP_ON_NOT_TRUE( "GetComponentByIndexW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	
	
	RIP_ON_NOT_TRUE( "GetComponentByIndexW() Invalid pointer specified for pdwNameLen", !( pdwNameLen == NULL || !DNVALID_WRITEPTR( pdwNameLen, sizeof(DWORD) ) ) );
	RIP_ON_NOT_TRUE( "GetComponentByIndexW() Invalid pointer specified for pwszTag", !( *pdwNameLen != 0 && (pwszTag == NULL || !DNVALID_WRITEPTR( pwszTag, *pdwNameLen*sizeof(WCHAR) ) ) ) );
	RIP_ON_NOT_TRUE( "GetComponentByIndexW() Invalid pointer specified for pdwComponentSize", !( pdwComponentSize == NULL || !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD) ) ) );
	RIP_ON_NOT_TRUE( "GetComponentByIndexW() Invalid pointer specified for pwszTag", !( *pdwComponentSize != 0 && (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) ) );
	RIP_ON_NOT_TRUE( "GetComponentByIndexW() Invalid pointer specified for pdwDataType", !( pdwDataType == NULL || !DNVALID_WRITEPTR( pdwDataType, sizeof(DWORD) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "dwComponentID = %u pwszTag = 0x%p pdwNameLen = 0x%p (%u)  pComponentBuffer = 0x%p, pdwComponentSize = 0x%p (%u), pdwDataType = 0x%p",
		dwComponentID, pwszTag, pdwNameLen, *pdwNameLen, pComponentBuffer, pdwComponentSize, *pdwComponentSize, pdwDataType );

	hr = pdp8Address->GetElement( dwComponentID, pwszTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_AddComponentW"
HRESULT DP8ADDRESSOBJECT::DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType )

{
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	RIP_ON_NOT_TRUE( "AddComponentW() Invalid pointer for tag string", pwszTag != NULL );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid pointer specified for component", !( pComponentData == NULL || !DNVALID_READPTR( pComponentData, dwComponentSize ) ) );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid string specified for tag", DNVALID_STRING_W( pwszTag ) );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid datatype specified", !( dwDataType != DPNA_DATATYPE_STRING && dwDataType != DPNA_DATATYPE_DWORD && dwDataType != DPNA_DATATYPE_GUID && dwDataType != DPNA_DATATYPE_BINARY && dwDataType != DPNA_DATATYPE_STRING_ANSI ) );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid string component specified", !( ( dwDataType == DPNA_DATATYPE_STRING ) && !DNVALID_STRING_W( (const WCHAR * const) pComponentData ) ) );
	RIP_ON_NOT_TRUE( "AddComponentW() String size and component size don't match", !( ( dwDataType == DPNA_DATATYPE_STRING ) && ( ((wcslen( (const WCHAR * const) pComponentData)+1)*sizeof(WCHAR)) != dwComponentSize ) ) );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid string component specified", !( ( dwDataType == DPNA_DATATYPE_STRING_ANSI ) && !DNVALID_STRING_A( (const CHAR * const) pComponentData ) ) );
	RIP_ON_NOT_TRUE( "AddComponentW() String size and component size don't match", !( ( dwDataType == DPNA_DATATYPE_STRING_ANSI ) && ( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize ) ) );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid size for DWORD component", !( ( dwDataType == DPNA_DATATYPE_DWORD ) && ( dwComponentSize != sizeof( DWORD ) ) ) );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid size for GUID component", !( ( dwDataType == DPNA_DATATYPE_GUID ) && ( dwComponentSize != sizeof( GUID ) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszTag = 0x%p pComponentData = 0x%p dwComponentSize = %d dwDataType = %d",
	     pwszTag, pComponentData, dwComponentSize, dwDataType );

	hr = pdp8Address->SetElement( pwszTag, pComponentData, dwComponentSize, dwDataType );
	RIP_ON_NOT_TRUE( "AddComponentW() Invalid parameters", hr != DPNERR_INVALIDPARAM );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Clear"
HRESULT DP8ADDRESSOBJECT::DP8A_Clear( IDirectPlay8Address *pInterface )
{
	RIP_ON_NOT_TRUE( "Clear() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );	

	hr = pdp8Address->Clear(  );

	DP8A_RETURN( hr );
}

BOOL IsValidDP8AObject( LPVOID lpvObject )
{
// BUGBUG: [mgere] [xbox] Revisit this later.  For now always return TRUE
/*
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DP8A_BaseVtbl &&
	   pIntList->lpVtbl != &DP8A_IPVtbl &&
	   pIntList->lpVtbl != &DP8A_InternalVtbl &&
	   pIntList->lpVtbl != &DP8A_UnknownVtbl )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8Address &&
	   pIntList->iid != IID_IDirectPlay8AddressIP &&
	   pIntList->iid != IID_IDirectPlay8AddressInternal &&
	   pIntList->iid != IID_IUnknown )
	{
		DPF( DP8A_ERRORLEVEL, "Unknown object" );
		return FALSE;
	}

	if( pIntList->lpObject == NULL ||
	   !DNVALID_READPTR( pIntList->lpObject, sizeof( OBJECT_DATA ) ) )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdp8Address == NULL ||
	   !DNVALID_READPTR( pdp8Address, sizeof( DP8ADDRESSOBJECT ) ) )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}
*/
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addparse.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:   Parsing engine
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date         By      Reason
 *   ====       ==      ======
 *  02/04/2000	 rmt	  Created
 *  02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __ADDPARSE_H
#define __ADDPARSE_H

class DP8ADDRESSPARSE
{
	STDNEWDELETE

protected:

	typedef enum { 
		DP8AP_IDLE,
		DP8AP_KEY,
		DP8AP_VALUE,
		DP8AP_USERDATA
	} DP8AP_STATE;
	
public:

	DP8ADDRESSPARSE();
	~DP8ADDRESSPARSE();

	HRESULT ParseURL( DP8ADDRESSOBJECT *pdp8aObject, WCHAR *pstrURL );

protected:

	BOOL IsValidHex( WCHAR ch );
	BOOL IsValidKeyChar(WCHAR ch);
	BOOL IsValidKeyTerminator(WCHAR ch);
	BOOL IsValidValueChar(WCHAR ch);
	BOOL IsValidValueTerminator(WCHAR ch);
	BOOL IsValidNumber(WCHAR ch );

	WCHAR HexToChar( WCHAR *sz );

	HRESULT FSM_Key();
	HRESULT FSM_Value();
	HRESULT FSM_UserData();
	HRESULT FSM_CommitEntry(DP8ADDRESSOBJECT *pdp8aObject);

	WCHAR *m_pwszCurrentLocation;	// Current Location in string

	WCHAR *m_pwszCurrentKey;		// Key will be placed here as we build
	WCHAR *m_pwszCurrentValue;		// Value will be placed here as we build
	BYTE *m_pbUserData;
	DWORD m_dwUserDataSize;
	DP8AP_STATE m_dp8State;		// Current State 
	BOOL m_fNonNumeric;
	DWORD m_dwLenURL;
	DWORD m_dwValueLen;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addparse.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:   Parsing engine
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date         By      Reason
 *   ====       ==      ======
 *  02/04/2000	 rmt	  Created
 * 02/17/2000	rmt		Parameter validation work
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *  07/21/2000	rmt		Bug #39940 - Addressing library doesn't properly parse stopbits in URLs 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::DP8ADDRESSPARSE"
DP8ADDRESSPARSE::DP8ADDRESSPARSE(
	):	m_pwszCurrentLocation(NULL),
		m_pwszCurrentKey(NULL),
		m_pwszCurrentValue(NULL),
		m_pbUserData(NULL),
		m_dwUserDataSize(0),
		m_dp8State(DP8AP_IDLE),
		m_dwLenURL(0)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::~DP8ADDRESSPARSE"
DP8ADDRESSPARSE::~DP8ADDRESSPARSE()
{
	if( m_pwszCurrentKey != NULL )
	{
		delete [] m_pwszCurrentKey;
	}

	if( m_pwszCurrentValue != NULL )
	{
		delete [] m_pwszCurrentValue;
	}

	if ( m_pbUserData != NULL )
	{
		delete [] m_pbUserData;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::ParseURL"
HRESULT DP8ADDRESSPARSE::ParseURL( DP8ADDRESSOBJECT *dp8aObject, WCHAR *pstrURL )
{
	HRESULT hr;
	
	if( m_pwszCurrentKey != NULL )
	{
		delete [] m_pwszCurrentKey;
		m_pwszCurrentKey = NULL;
	}

	if( m_pwszCurrentValue != NULL )
	{
		delete [] m_pwszCurrentValue;
		m_pwszCurrentValue = NULL;
	}

	if( m_pbUserData != NULL )
	{
		delete [] m_pbUserData;
		m_pbUserData = NULL;
	}	

	m_dwUserDataSize = 0;

	m_pwszCurrentLocation = pstrURL;

	m_dwLenURL = wcslen(pstrURL);

	if( m_dwLenURL < wcslen( DPNA_HEADER ) )
	{
		DPF( 0, "Invalid URL" );
		return DPNERR_INVALIDURL;
	}

	if( wcsncmp( pstrURL, DPNA_HEADER, wcslen(DPNA_HEADER) ) != 0 )
	{
		DPF( 0, "No header, invalid URL" );
		return DPNERR_INVALIDURL;
	}

	m_pwszCurrentLocation += wcslen( DPNA_HEADER );

	m_pwszCurrentKey = new WCHAR[m_dwLenURL+1];
	m_pwszCurrentValue = new WCHAR[m_dwLenURL+1];
	m_pbUserData = new BYTE[m_dwLenURL+1];

	if( !m_pwszCurrentKey )
	{
		DPF( 0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;
	}

	if( !m_pwszCurrentValue )
	{
		delete [] m_pwszCurrentKey;
		DPF( 0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;	
	}

	if( !m_pbUserData )
	{
		delete [] m_pwszCurrentKey;
		delete [] m_pwszCurrentValue;
		DPF( 0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;	
	}

	m_dp8State = DP8AP_IDLE;

	// Loop until the string is done
	while( *m_pwszCurrentLocation != L'\0' )
	{
		switch( m_dp8State )
		{
		case DP8AP_IDLE:
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
			}
			else
			{
				m_dp8State = DP8AP_KEY;
			}
			break;
		case DP8AP_KEY:

			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
				break;
			}

			hr = FSM_Key();

			if( FAILED( hr ) )
			{
				DPF( 0, "Error parsing key hr = 0x%x", hr );
				return hr;	
			}

			// Parse ended with an equals
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_KEYVALUE )
			{
				m_dp8State = DP8AP_VALUE;
				m_pwszCurrentLocation++;
			}
			else
			{
				DPF( 0, "keyname without associated value hr=0x%x", hr );
				return DPNERR_INVALIDURL;
			}

			break;
		case DP8AP_VALUE:

			hr = FSM_Value();

			if( FAILED( hr ) )
			{
				DPF( 0, "Error parsing value hr=0x%x", hr );
				return hr;
			}

			// Parse ended with an equals
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_COMPONENT )
			{
				m_dp8State = DP8AP_KEY;
				m_pwszCurrentLocation++;
			}
			else if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
			}
			else if( *m_pwszCurrentLocation == L'\0' )
			{
				m_dp8State = DP8AP_IDLE;
			}
			else
			{
				DPF( 0, "Error parsing next key" );
				hr = DPNERR_INVALIDURL;
				return hr;
			}

			hr = FSM_CommitEntry(dp8aObject);

			if( hr == DPNERR_INVALIDPARAM )
			{
				DPF( 0, "Invalid value specified in URL hr=0x%x", hr );
				hr = DPNERR_INVALIDURL;
				return hr;
			}
			else if( FAILED( hr ) )
			{
				DPF( 0, "Error commiting entry hr=0x%x", hr );
				return hr;
			}

			break;
			
		case DP8AP_USERDATA:

			hr = FSM_UserData();

			if( FAILED( hr ) )
			{
				DPF( 0, "Error parsing user data hr=0x%x", hr );
				return hr;
			}

			hr = dp8aObject->SetUserData( m_pbUserData, m_dwUserDataSize );

			if( FAILED( hr ) )
			{
				DPF( 0, "Error setting user data hr=0x%x", hr );
				return hr;
			}

			break;
		}
	}

	if( m_dp8State != DP8AP_IDLE &&
	    m_dp8State != DP8AP_USERDATA )
	{
		DPF( 0, "Parsing error hr=0x%x", hr );
		hr = DPNERR_INVALIDURL;
		return hr;
	}

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidKeyChar"
BOOL DP8ADDRESSPARSE::IsValidKeyChar( WCHAR ch )
{
	if( ch >= L'A' && ch <= L'Z' )
		return TRUE;

	if( ch >= L'a' && ch <= L'z' )
		return TRUE;

	if( ch >= L'0' && ch <= L'9' )
		return TRUE;

	if( ch == L'-' || ch == L'?' || ch == L'.' ||
		ch == L',' || ch == L'+' || ch == L'_' )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidKeyTerminator"
BOOL DP8ADDRESSPARSE::IsValidKeyTerminator( WCHAR ch )
{
	if( ch == 0 )
		return TRUE;

	if( ch == DPNA_SEPARATOR_USERDATA )
		return TRUE;

	if( ch == DPNA_SEPARATOR_COMPONENT )
		return TRUE;

	if( ch == DPNA_SEPARATOR_KEYVALUE )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_Key"
// FSM_Key
//
// Parse a keyname, or return an error on error
//
HRESULT DP8ADDRESSPARSE::FSM_Key()
{
	DWORD dwKeyLoc = 0;
	m_pwszCurrentKey[0] = 0;
	HRESULT hr = DPN_OK;

	while( 1 )
	{
		if( IsValidKeyChar(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentKey[dwKeyLoc] = *m_pwszCurrentLocation;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentKey[dwKeyLoc] = 0;
			break;
		}
		else
		{
			m_pwszCurrentKey[dwKeyLoc] = 0;
			hr = DPNERR_INVALIDURL;
			break;
		}

		dwKeyLoc++;
		m_pwszCurrentLocation++;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidNumber"
BOOL DP8ADDRESSPARSE::IsValidNumber( WCHAR ch )
{
	if( ch < L'0' ||
	   ch > L'9' )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidHex"
BOOL DP8ADDRESSPARSE::IsValidHex( WCHAR ch )
{
	if( IsValidNumber( ch ) )
		return TRUE;

	if( ch >= L'A' || ch <= L'F' )
		return TRUE;

	if( ch >= L'a' || ch <= L'f' )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::HexToChar"
WCHAR DP8ADDRESSPARSE::HexToChar( WCHAR *sz )
{
	WCHAR chResult = sz[0];

	// First digit
	if( sz[0] >= L'0' && sz[0] <= L'9' )
		chResult = sz[0]-L'0';

	if( sz[0] >= L'A' && sz[0] <= L'F' )
		chResult = sz[0]-L'A'+10;

	if( sz[0] >= L'a' && sz[0] <= L'f' )
		chResult = sz[0]-L'a'+10;

	chResult <<= 4;

	// Second digit
	if( sz[1] >= L'0' && sz[1] <= L'9' )
		chResult += sz[1]-'0';

	if( sz[1] >= L'A' && sz[1] <= L'F' )
		chResult += sz[1]-L'A'+10;

	if( sz[1] >= L'a' && sz[1] <= L'f' )
		chResult += sz[1]-L'a'+10;	

	return chResult;
		
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_Value"
HRESULT DP8ADDRESSPARSE::FSM_Value()
{
	m_fNonNumeric = FALSE;
	m_pwszCurrentValue[0] = 0;
	HRESULT hr = DPN_OK;
	BYTE bTmp;

	m_dwValueLen = 0;

	while( 1 )
	{
		// Just add it
		if( IsValidKeyChar( *m_pwszCurrentLocation ) )
		{
			m_pwszCurrentValue[m_dwValueLen] = *m_pwszCurrentLocation;

			if( !IsValidNumber( *m_pwszCurrentLocation ) )
			{
				m_fNonNumeric = TRUE;
			}
		}
		// ESCAPE SEQUENCE
		else if( *m_pwszCurrentLocation == DPNA_ESCAPECHAR )
		{
			m_fNonNumeric = TRUE;

			if( *(m_pwszCurrentLocation+1) == DPNA_ESCAPECHAR )
			{
				m_pwszCurrentValue[m_dwValueLen] = DPNA_ESCAPECHAR;
				m_pwszCurrentLocation += 2;
			}
			
			if( wcslen( m_pwszCurrentLocation ) < 3 )
			{
				DPF( 0, "Unexpected end in escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			if( !IsValidHex( *(m_pwszCurrentLocation+1) ) ||
			   !IsValidHex( *(m_pwszCurrentLocation+2) ) )
			{
				DPF( 0, "Invalid escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			m_pwszCurrentLocation ++;			

			m_pwszCurrentValue[m_dwValueLen] = HexToChar(m_pwszCurrentLocation);

			m_pwszCurrentLocation ++;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentValue[m_dwValueLen] = 0;
			break;
		}
		else
		{
			m_pwszCurrentValue[m_dwValueLen] = 0;
			DPF( 0, "Unexpected character in URL" );
			hr = DPNERR_INVALIDURL;
			break;
		}

		m_dwValueLen++;
		m_pwszCurrentLocation++;
	}

	if( m_dwValueLen < 1 )
	{
		DPF( DP8A_ERRORLEVEL, "0 length value" );
		return DPNERR_INVALIDURL;
	}	

	return hr;
}
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_UserData"
HRESULT DP8ADDRESSPARSE::FSM_UserData()
{
	m_pwszCurrentValue[0] = 0;
	HRESULT hr = DPN_OK;
	DWORD dwValueLoc = 0;
	BYTE bTmp;

	while( 1 )
	{
		// Just add it
		if( IsValidKeyChar( *m_pwszCurrentLocation ) )
		{
			m_pbUserData[dwValueLoc] = (CHAR) *m_pwszCurrentLocation;
		}
		// ESCAPE SEQUENCE
		else if( *m_pwszCurrentLocation == DPNA_ESCAPECHAR )
		{
			if( *(m_pwszCurrentLocation+1) == DPNA_ESCAPECHAR )
			{
				m_pbUserData[dwValueLoc] = DPNA_ESCAPECHAR;
				m_pwszCurrentLocation += 2;
			}
			
			if( wcslen( m_pwszCurrentLocation ) < 3 )
			{
				DPF( 0, "Unexpected end in escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			if( !IsValidHex( *(m_pwszCurrentLocation+1) ) ||
			   !IsValidHex( *(m_pwszCurrentLocation+2) ) )
			{
				DPF( 0, "Invalid escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			m_pwszCurrentLocation ++;			

			m_pbUserData[dwValueLoc] = (CHAR) HexToChar(m_pwszCurrentLocation);

			m_pwszCurrentLocation ++;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentValue[dwValueLoc] = 0;
			break;
		}
		else
		{
			m_pwszCurrentValue[dwValueLoc] = 0;
			hr = DPNERR_INVALIDURL;
			break;
		}

		dwValueLoc++;
		m_pwszCurrentLocation++;
	}


	m_dwUserDataSize = dwValueLoc;

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_CommitEntry"
HRESULT DP8ADDRESSPARSE::FSM_CommitEntry(DP8ADDRESSOBJECT *pdp8aObject)
{
	DWORD dwDataType = 0xFFFFFFFF;
	
    // Ensure that datatype is correct in case the key is a reserved key
    for( DWORD dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
    {
	    if( _wcsicmp( szBaseStrings[dwIndex], m_pwszCurrentKey ) == 0 )
	    {
		    dwDataType = dwBaseRequiredTypes[dwIndex] ;
		    break;
	    }
    }

	// If it's numeric
	if( (dwDataType == DPNA_DATATYPE_DWORD || dwDataType == 0xFFFFFFFF) && !m_fNonNumeric && wcslen(m_pwszCurrentValue)<=10)
	{
		DWORD dwTmpValue;

		dwTmpValue = _wtol( m_pwszCurrentValue );

		return pdp8aObject->SetElement( m_pwszCurrentKey, &dwTmpValue, sizeof(DWORD), DPNA_DATATYPE_DWORD );
	}

    UINT aiTmp[11];

	// We've read a GUID
    if( (dwDataType == DPNA_DATATYPE_GUID || dwDataType == 0xFFFFFFFF) && wcslen( m_pwszCurrentValue ) == 38 && swscanf( m_pwszCurrentValue, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}" ,
                    &aiTmp[0],
                    &aiTmp[1], &aiTmp[2],
                    &aiTmp[3], &aiTmp[4],
                    &aiTmp[5], &aiTmp[6],
                    &aiTmp[7], &aiTmp[8],
                    &aiTmp[9], &aiTmp[10]) == 11)
    {
    	GUID guidValue;

    	guidValue.Data1      = (ULONG) aiTmp[0];
        guidValue.Data2      = (USHORT) aiTmp[1];
		guidValue.Data3      = (USHORT) aiTmp[2];
        guidValue.Data4[0]    = (BYTE) aiTmp[3];
        guidValue.Data4[1]    = (BYTE) aiTmp[4];
        guidValue.Data4[2]    = (BYTE) aiTmp[5];
        guidValue.Data4[3]    = (BYTE) aiTmp[6];
        guidValue.Data4[4]    = (BYTE) aiTmp[7];
        guidValue.Data4[5]    = (BYTE) aiTmp[8];
        guidValue.Data4[6]    = (BYTE) aiTmp[9];
        guidValue.Data4[7]    = (BYTE) aiTmp[10];

		return pdp8aObject->SetElement( m_pwszCurrentKey, &guidValue, sizeof(GUID), DPNA_DATATYPE_GUID  );
     }

	 // If there are no NULLs it's a string
     if( (dwDataType == DPNA_DATATYPE_STRING || dwDataType == 0xFFFFFFFF || wcscmp(DPNA_KEY_PROVIDER,m_pwszCurrentKey)==0 ) && wcslen( m_pwszCurrentValue ) == m_dwValueLen )
     {
		 // Otherwise it's a string
    	 return pdp8aObject->SetElement( m_pwszCurrentKey, m_pwszCurrentValue, (wcslen(m_pwszCurrentValue)+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
     }

	 // Otherwise it's a binary
   	 return pdp8aObject->SetElement( m_pwszCurrentKey, m_pwszCurrentValue, m_dwValueLen, DPNA_DATATYPE_BINARY );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\dnaddri.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    DirectPlayAddress master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *  09/11/00	mgere	Converted to DPlay
 *
 ***************************************************************************/

#ifndef __DNADDRI_H__
#define __DNADDRI_H__

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#include <winsockx.h>
#include <dplay8p.h>
#include <dpaddrp.h>
#include <xdbg.h>
#include <stdio.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

#ifdef __cplusplus

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}

#define ADDREF(p) \
    __AddRef(p)

template <class type> void __Release(type **pp)
{
    type * p = *pp;

    if(p)
    {
        p->Release();
    }
}

#define RELEASE(p) \
    __Release(&(p))

#endif // __cplusplus

//
// Private includes
//

#include "dndbg.h"
#include "osind.h"
#include "comutil.h"
#include "strutils.h"
#include "classbilink.h"
#include "fpm.h"
#include "strcache.h"
#include "addcore.h"
#include "addparse.h"

#endif // __DSOUNDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addtcp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address TCP interface file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/12/2000	rmt		Completed first implementation
 * 02/17/2000	rmt		Parameter validation work
 * 02/20/2000	rmt		Changed ports to USHORTs
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls
 * 02/23/2000	rmt		Further parameter validation
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 * 03/24/2000	rmt		Added IsEqual function
 *	05/04/00	mjn		Fixed leak in DP8ATCP_GetSockAddress()
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 * 08/03/2000 	rmt		Bug #41246 - Remove IP versions of Duplicate, SetEqual, IsEqual, BuildURL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

HRESULT IDirectPlay8Address_BuildFromSockAddr(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const SOCKADDR * const pSockAddr)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8ATCP_BuildFromSockAddr(pDirectPlay8Address, pSockAddr);
}

HRESULT IDirectPlay8Address_BuildAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const wszAddress, const USHORT usPort)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8ATCP_BuildAddressW(pDirectPlay8Address, wszAddress, usPort);
}

HRESULT IDirectPlay8Address_BuildLocalAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID * const pguidAdapter, const USHORT usPort)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8ATCP_BuildLocalAddress(pDirectPlay8Address, pguidAdapter, usPort);
}

HRESULT IDirectPlay8Address_GetSockAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, SOCKADDR *pSockAddr, PDWORD pDword)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8ATCP_GetSockAddress(pDirectPlay8Address, pSockAddr, pDword);
}

HRESULT IDirectPlay8Address_GetLocalAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pguidAdapter, USHORT *pusPort)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8ATCP_GetLocalAddress(pDirectPlay8Address, pguidAdapter, pusPort);
}

HRESULT IDirectPlay8Address_GetAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort)
{
    return DP8ADDRESSOBJECT::GetDirectPlay8Address(pDirectPlay8Address)->DP8ATCP_GetAddressW(pDirectPlay8Address, wszAddress, pdwAddressLength, psPort);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildLocalAddress"
HRESULT DP8ADDRESSOBJECT::DP8ATCP_BuildLocalAddress( IDirectPlay8Address *pInterface, const GUID * const pguidAdapter, const USHORT usPort )
{
	RIP_ON_NOT_TRUE( "BuildLocalAddress() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );		
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pguidAdapter: 0x%p usPort: %u", pguidAdapter, (DWORD)usPort );	

	RIP_ON_NOT_TRUE( "BuildLocalAddress() Invalid pointer", !( pguidAdapter == NULL || !DNVALID_READPTR( pguidAdapter, sizeof( GUID ) ) ) );

	hr = pdp8Address->Clear();

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Failed to clear current address hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

// BUGBUG: [mgere] [xbox] Must set the SP sometime...
//	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	hr = pdp8Address->SetDevice( pguidAdapter );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error setting device hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	DWORD dwTmpPort = usPort;

	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPF( 0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
	
	DP8A_RETURN( hr );	
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildFromSockAddr"
HRESULT DP8ADDRESSOBJECT::DP8ATCP_BuildFromSockAddr( IDirectPlay8Address *pInterface, const SOCKADDR * const pSockAddr )
{
	RIP_ON_NOT_TRUE( "BuildFromSockAddr() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );
	
	DP8ADDRESSOBJECT *pdp8Address = this;
	
	HRESULT hr;
	DWORD dwTmpPort;
	LPSTR szHostName = NULL;
	LPWSTR swzHostName = NULL;
	DWORD dwTmpLength;
	sockaddr_in *saIPAddress;

	DPF( DP8A_ENTERLEVEL, "Enter" );
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pSockAddr: 0x%p", pSockAddr );	

	RIP_ON_NOT_TRUE( "BuildFromSockAddr() Invalid pointer to sockaddr", !( pSockAddr == NULL || !DNVALID_READPTR( pSockAddr, sizeof( SOCKADDR ) ) ) );
	RIP_ON_NOT_TRUE( "BuildFromSockAddr() Only TCP addresses are supported", pSockAddr->sa_family == AF_INET );

	saIPAddress = (sockaddr_in * ) pSockAddr;

	hr = pdp8Address->Clear();

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Failed clearing object hr=0x%x", hr );
		goto BUILDFROMSOCKADDR_ERROR;
	}

// BUGBUG: [mgere] [xbox] Must set the SP sometime...
//	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	// Sockaddr is in network byte order, convert to host order
	dwTmpPort = ntohs(saIPAddress->sin_port);

	szHostName = inet_ntoa( saIPAddress->sin_addr );

	if( szHostName == NULL )
	{
		DPF( DP8A_ERRORLEVEL, "Error converting from address to string" );
		hr = DPNERR_INVALIDPARAM;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	dwTmpLength = strlen(szHostName)+1;

	swzHostName = new WCHAR[dwTmpLength];

	if( swzHostName == NULL )
	{
		DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
		hr = DPNERR_OUTOFMEMORY;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	if( FAILED( hr = STR_jkAnsiToWide(swzHostName,szHostName,dwTmpLength) ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error converting hostname 0x%x", hr );
		hr = DPNERR_CONVERSION;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	hr = pdp8Address->SetElement( DPNA_KEY_HOSTNAME, swzHostName, dwTmpLength*sizeof(WCHAR), DPNA_DATATYPE_STRING );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Failed to set hostname hr=0x%x", hr );
		DP8A_RETURN( hr );
	}	

	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof(DWORD), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ENTERLEVEL, "Failed setting port hr=0x%x", hr );
		DP8A_RETURN( hr );
	}

	delete [] swzHostName;

	DP8A_RETURN( DPN_OK );

BUILDFROMSOCKADDR_ERROR:

	if( swzHostName != NULL )
		delete [] swzHostName;

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildAddressW"
HRESULT DP8ADDRESSOBJECT::DP8ATCP_BuildAddressW( IDirectPlay8Address *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
{
	RIP_ON_NOT_TRUE( "BuildAddressW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );

	RIP_ON_NOT_TRUE( "BuildAddressW() Invalid pointer to address", pwszAddress != NULL );
	RIP_ON_NOT_TRUE( "BuildAddressW() Invalid string for address", DNVALID_STRING_W( pwszAddress ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszAddress: 0x%p, usPort = %u", pwszAddress, (DWORD)usPort );

	hr = pdp8Address->Clear();

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error clearing current address hr=0x%x", hr );
		DP8A_RETURN( hr );		
	}

// BUGBUG: [mgere] [xbox] Must set the SP sometime...
//	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	hr = pdp8Address->SetElement( DPNA_KEY_HOSTNAME, pwszAddress, (wcslen(pwszAddress)+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );

	if( FAILED( hr ) )
	{
		DPF( 0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}	

	DWORD dwTmpPort = usPort;
	
	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPF( 0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
	
	DP8A_RETURN( hr );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetSockAddress"
HRESULT DP8ADDRESSOBJECT::DP8ATCP_GetSockAddress( IDirectPlay8Address *pInterface, SOCKADDR *pSockAddr, PDWORD pdwBufferSize )
{
	RIP_ON_NOT_TRUE( "GetSockAddress() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	HRESULT hr;
	WCHAR *swzAddress = NULL;		// Unicode version of hostname
	CHAR *szAddress = NULL; 		// ANSI version of hostname
	DWORD dwAddressSize = 0;
	USHORT usPort;
	LPHOSTENT lpHostEntry;
	in_addr iaTmp;
	in_addr *piaTmp;
	DWORD dwIndex;
	DWORD dwRequiredSize;
	DWORD dwNumElements;
	sockaddr_in *psinCurAddress;
	SOCKADDR *pCurLoc;
	GUID guidSP;

	dwAddressSize = 0;

	RIP_ON_NOT_TRUE( "GetSockAddress() Invalid pointer for pdwBufferSize", !( pdwBufferSize == NULL || !DNVALID_WRITEPTR( pdwBufferSize, sizeof( DWORD ) ) ) );
	RIP_ON_NOT_TRUE( "GetSockAddress() Invalid pointer for sockaddress", !( *pdwBufferSize > 0 && (pSockAddr == NULL || !DNVALID_WRITEPTR( pSockAddr, *pdwBufferSize ) ) ) );

	DPF( DP8A_ENTERLEVEL, "Enter" );
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pSockAddr = 0x%p, pdwBufferSize = 0x%p (%d)", pSockAddr, pdwBufferSize, *pdwBufferSize );	

	hr = DP8ATCP_GetAddressW( pInterface, swzAddress, &dwAddressSize, &usPort );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to retrieve size required hr=0x%x", hr );
		goto GETSOCKADDRESS_ERROR;
	}

	swzAddress = new WCHAR[dwAddressSize];

	if( swzAddress == NULL )
	{
		DPF( DP8A_ERRORLEVEL, "Error allocating memory hr=0x%x", hr );
		hr = DPNERR_OUTOFMEMORY;
		goto GETSOCKADDRESS_ERROR;
	}

	hr = DP8ATCP_GetAddressW( pInterface, swzAddress, &dwAddressSize, &usPort );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to retrieve address hr=0x%x", hr );
		goto GETSOCKADDRESS_ERROR;
	}	

	szAddress = new CHAR[dwAddressSize];

	if( szAddress == NULL )
	{
		DPF( DP8A_ERRORLEVEL, "Error allocating memory hr=0x%x", hr );
		hr = DPNERR_OUTOFMEMORY;
		goto GETSOCKADDRESS_ERROR;	
	}

	if( FAILED( hr = STR_jkWideToAnsi( szAddress, swzAddress, dwAddressSize ) ) )
	{
		DPF( DP8A_ERRORLEVEL, "Error converting address to ANSI hr=0x%x", hr );
		hr = DPNERR_CONVERSION;
		goto GETSOCKADDRESS_ERROR;
	}

	iaTmp.s_addr = inet_addr( szAddress );

    if( iaTmp.s_addr != INADDR_NONE || strcmp( szAddress, "255.255.255.255" ) == 0 )
    {
        dwRequiredSize = sizeof( SOCKADDR );

	    if( *pdwBufferSize < dwRequiredSize )
	    {
		    *pdwBufferSize = dwRequiredSize;
		    DPF( DP8A_WARNINGLEVEL, "Buffer too small" );
		    hr = DPNERR_BUFFERTOOSMALL;
		    goto GETSOCKADDRESS_ERROR;
	    }

        memset( pSockAddr, 0x00, sizeof( SOCKADDR ) );

        psinCurAddress = (sockaddr_in *) pSockAddr;

   		psinCurAddress->sin_family = AF_INET;
		psinCurAddress->sin_port = htons(usPort);
		psinCurAddress->sin_addr = iaTmp;

		hr = DPN_OK;

		goto GETSOCKADDRESS_ERROR;
    }

	lpHostEntry = gethostbyname( szAddress );	

	if( lpHostEntry == NULL )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid host specified hr=0x%x" , hr );
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto GETSOCKADDRESS_ERROR;
	}

	// Count addresses
	for( dwNumElements = 0; ; dwNumElements++ )
	{
		piaTmp = ((LPIN_ADDR)lpHostEntry->h_addr_list[dwNumElements]);

		if( piaTmp == NULL )
			break;
	}

	dwRequiredSize = dwNumElements * sizeof( SOCKADDR );

	if( *pdwBufferSize < dwRequiredSize )
	{
		*pdwBufferSize = dwRequiredSize;
		DPF( DP8A_WARNINGLEVEL, "Buffer too small" );
		hr = DPNERR_BUFFERTOOSMALL;
		goto GETSOCKADDRESS_ERROR;
	}

	*pdwBufferSize = dwRequiredSize;

	pCurLoc = pSockAddr;

	memset( pCurLoc, 0x00, *pdwBufferSize );

	// Build addresses and copy them to the buffer
	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		psinCurAddress = (sockaddr_in *) pCurLoc;
		psinCurAddress->sin_family = AF_INET;
		psinCurAddress->sin_port = htons(usPort);
		psinCurAddress->sin_addr = *((LPIN_ADDR)lpHostEntry->h_addr_list[dwIndex]);
		
		pCurLoc++;
	}

	delete [] swzAddress;
	delete [] szAddress;

	DP8A_RETURN( DPN_OK );

GETSOCKADDRESS_ERROR:

	if( swzAddress != NULL )
		delete [] swzAddress;

	if( szAddress != NULL )
		delete [] szAddress;

	DP8A_RETURN( hr );
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetLocalAddress"
HRESULT DP8ADDRESSOBJECT::DP8ATCP_GetLocalAddress( IDirectPlay8Address *pInterface, GUID * pguidAdapter, PUSHORT pusPort )
{
	RIP_ON_NOT_TRUE( "GetLocalAddress() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	
	HRESULT hr;

	DPF( DP8A_ENTERLEVEL, "Enter" );

	GUID guidDevice;
	DWORD dwPort;
	DWORD dwType;
	DWORD dwSize;	
	GUID guidSP;

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pguidAdapter = 0x%p pusPort = 0x%p",
	     pguidAdapter, pusPort );

	RIP_ON_NOT_TRUE( "GetLocalAddress() Invalid pointer for adapter", !( pguidAdapter == NULL || !DNVALID_WRITEPTR( pguidAdapter, sizeof( GUID ) ) ) );
	RIP_ON_NOT_TRUE( "GetLocalAddress() Invalid pointer for port", !( pusPort == NULL || !DNVALID_WRITEPTR( pusPort, sizeof( USHORT ) ) ) );

	hr = pdp8Address->GetElementType( DPNA_KEY_DEVICE, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "This address does not have a device element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_GUID )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid Address: The device is not a GUID hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_PORT, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "This address does not have a port element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_DWORD )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid Address: The port is not a dword hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(DWORD);

	hr = pdp8Address->GetElement( DPNA_KEY_PORT, &dwPort, &dwSize, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to retrieve port element hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(GUID);

	hr = pdp8Address->GetElement( DPNA_KEY_DEVICE, &guidDevice, &dwSize, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to retrieve device element hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}	

	*pguidAdapter = guidDevice;
	*pusPort = (USHORT) dwPort;

	DP8A_RETURN( DPN_OK );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetAddressW"
HRESULT DP8ADDRESSOBJECT::DP8ATCP_GetAddressW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
{
	RIP_ON_NOT_TRUE( "GetAddressW() Invalid object", !( pInterface == NULL || !DP8A_VALID( pInterface ) ) );

	DP8ADDRESSOBJECT *pdp8Address = this;
	
	HRESULT hr;
	DWORD dwPort;
	DWORD dwType;
	DWORD dwSize;
	GUID guidSP;

	DPF( DP8A_ENTERLEVEL, "Enter" );

	RIP_ON_NOT_TRUE( "GetAddressW() Invalid pointer for pdwAddressLength", !( pdwAddressLength == NULL || !DNVALID_WRITEPTR( pdwAddressLength, sizeof( DWORD ) ) ) );
	RIP_ON_NOT_TRUE( "GetAddressW() Invalid pointer for pwszAddress", !( *pdwAddressLength > 0 && (pwszAddress == NULL || !DNVALID_WRITEPTR( pwszAddress, (*pdwAddressLength)*sizeof(WCHAR) ) ) ) );
	RIP_ON_NOT_TRUE( "GetAddressW() Invalid pointer for port", !( pusPort == NULL || !DNVALID_WRITEPTR( pusPort, sizeof( USHORT ) ) ) );

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressLength = 0x%p (%u) pusPort = 0x%p (%u)",
	     pwszAddress, pdwAddressLength, *pdwAddressLength, pusPort, (DWORD)*pusPort );

	hr = pdp8Address->GetElementType( DPNA_KEY_HOSTNAME, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "This address does not have a hostname element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;				
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_STRING )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid Address: The host name is not a string hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_PORT, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "This address does not have a port element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_DWORD )
	{
		DPF( DP8A_ERRORLEVEL, "Invalid Address: The port is not a dword hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(DWORD);

	hr = pdp8Address->GetElement( DPNA_KEY_PORT, &dwPort, &dwSize, &dwType );

	if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to retrieve port element hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	*pdwAddressLength *= 2;

	hr = pdp8Address->GetElement( DPNA_KEY_HOSTNAME, pwszAddress, pdwAddressLength, &dwType );

	*pdwAddressLength /= 2;

	if( hr == DPNERR_BUFFERTOOSMALL )
	{
		DPF( DP8A_WARNINGLEVEL, "Buffer too small hr=0x%x", hr );
		DP8A_RETURN( hr );
	}
	else if( FAILED( hr ) )
	{
		DPF( DP8A_ERRORLEVEL, "Unable to retrieve hostname element hr=0x%x", hr );
 		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}	

	*pusPort = (USHORT) dwPort;
	
	DP8A_RETURN( DPN_OK );		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\addcore.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addcore.h
 *  Content:    DIRECTPLAY8ADDRESS CORE HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/04/2000	rmt		Created
 *  02/17/2000	rmt		Added new defines for 
 *  02/17/2000	rmt		Parameter validation work 
 *  02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls 
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *  07/13/2000	rmt		Bug #39274 - INT 3 during voice run
 *  07/21/2000	rmt		Bug #39940 - Addressing library doesn't properly parse stopbits in URLs
 *   7/31/2000  RichGr  IA64: FPM_Release() overwrites first 8 bytes of chunk of memory on IA64.
 *                      Rearrange positions of members of affected structs so that's OK.  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDCORE_H
#define	__ADDCORE_H

void GlobalInitialize(void);
HRESULT GlobalCleanup(void);

extern DWORD g_dwGlobalObjectCount;
extern BOOL g_fGlobalObjectInit;

// Length of a single byte of userdata 
#define DNURL_LENGTH_USERDATA_BYTE	1

// Header length (14 chars + null terminator)
#define DNURL_LENGTH_HEADER			15

// Includes escaped brackets
#define DNURL_LENGTH_GUID			42

// Just the number, in decimal
#define DNURL_LENGTH_DWORD			10

// The length of the seperator for user data
#define DNURL_LENGTH_USERDATA_SEPERATOR	1

// The right length for one byte of escaped data
#define DNURL_LENGTH_BINARY_BYTE	3


#define DP8A_ENTERLEVEL			2
#define DP8A_INFOLEVEL			7
#define DP8A_ERRORLEVEL			0
#define DP8A_WARNINGLEVEL		1
#define DP8A_PARAMLEVEL			3

extern const WCHAR *szBaseStrings[];
extern const DWORD dwBaseRequiredTypes[];
extern const DWORD c_dwNumBaseStrings;

#if defined(DEBUG) || defined(DBG)

extern BOOL IsValidDP8AObject( LPVOID lpvObject );

#define DP8A_VALID(a) 	IsValidDP8AObject( a )
#else
#define DP8A_VALID(a)  TRUE
#endif




#define DP8A_RETURN( x ) 	DPF( DP8A_ENTERLEVEL, "Function returning hr=0x%x", x ); \
							return x;

extern LPFPOOL fpmAddressElements;
extern CRITICAL_SECTION g_csFPMElements;

extern CStringCache *g_pcstrKeyCache;

#define DP8ADDRESS_ELEMENT_HEAP	0x00000001

#define DPASIGNATURE_ELEMENT		'LEAD'
#define DPASIGNATURE_ELEMENT_FREE	'LEA_'

#define DPASIGNATURE_ADDRESS		'BOAD'
#define DPASIGNATURE_ADDRESS_FREE	'BOA_'

// DP8ADDRESSELEMENT
//
// This structure contains all the information about a single element of the 
// address.  These address elements are allocated from a central, fixed
//
//  7/31/2000(RichGr) - IA64: FPM_Release() overwrites first 8 bytes.  Rearrange position of dwSignature so that's OK.  
typedef struct _DP8ADDRESSELEMENT
{
	DWORD dwTagSize;			// Size of the tag
	DWORD dwType;				// Element type DNADDRESS8_DATATYPE_XXXXXX
	DWORD dwDataSize;			// Size of the data
	DWORD dwStringSize;
	DWORD dwSignature;          // Element debug signature
	WCHAR *pszTag;	            // Tag for the element.  
	DWORD dwFlags;				// Flags DNADDRESSELEMENT_XXXX
	union {
		GUID guidData;
		DWORD dwData;
		WCHAR szData[sizeof(GUID)];
		PVOID pvData;
	} uData;					// Union 
	CBilink blAddressElements;	// Bilink of address elements
} DP8ADDRESSELEMENT, *PDP8ADDRESSELEMENT;

// DP8ADDRESSELEMENT
// 
// Data structure representing the address itself
class DP8ADDRESSOBJECT
    : public IDirectPlay8Address
{
	STDNEWDELETE

protected:
	ULONG	m_ulRefCount;	// object reference count

public:
	DP8ADDRESSOBJECT(void);
	~DP8ADDRESSOBJECT(void);

	// IUnknown interface
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

	HRESULT DP8A_BuildFromURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress );
	HRESULT DP8A_BuildFromURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress );
	HRESULT DP8A_Duplicate( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS *ppInterface );
	HRESULT DP8A_Clear( IDirectPlay8Address *pInterface );
	HRESULT DP8A_GetURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressSize );
	HRESULT DP8A_GetURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress, PDWORD pdwAddressSize );
	HRESULT DP8A_GetSP( IDirectPlay8Address *pInterface, GUID * pguidSP );
	HRESULT DP8A_GetDevice( IDirectPlay8Address *pInterface, GUID * pguidSP );
	HRESULT DP8A_GetUserData( IDirectPlay8Address *pInterface, void * pvUserData, PDWORD pdwBufferSize );
	HRESULT DP8A_SetDevice( IDirectPlay8Address *pInterface, const GUID * const pguidSP );
	HRESULT DP8A_SetSP( IDirectPlay8Address *pInterface, const GUID * const pguidSP );
	HRESULT DP8A_SetUserData( IDirectPlay8Address *pInterface, const void * const pBuffer, const DWORD dwBufferSize );
	HRESULT DP8A_GetNumComponents( IDirectPlay8Address *pInterface, PDWORD pdwNumComponents );
	HRESULT DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface, const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
	HRESULT DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
	HRESULT DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
	HRESULT DP8A_BuildFromDirectPlay4Address( IDirectPlay8Address *pInterface, void * pvDataBuffer, DWORD dwDataSize );
	HRESULT DP8A_SetEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8Address );
	HRESULT DP8A_IsEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8Address );

	HRESULT DP8ATCP_BuildFromSockAddr( IDirectPlay8Address *pInterface, const SOCKADDR * const pSockAddr );
	HRESULT DP8ATCP_BuildAddressW( IDirectPlay8Address *pInterface, const WCHAR * const pwszAddress, const USHORT usPort );
	HRESULT DP8ATCP_GetSockAddress( IDirectPlay8Address *pInterface, SOCKADDR *pSockAddr, PDWORD pdwBufferSize );
	HRESULT DP8ATCP_GetLocalAddress( IDirectPlay8Address *pInterface, GUID * pguidAdapter, USHORT *psPort );
	HRESULT DP8ATCP_GetAddressW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, USHORT *psPort );
	HRESULT DP8ATCP_BuildLocalAddress( IDirectPlay8Address *pInterface, const GUID * const pguidAdapter, const USHORT psPort );

	// Typecast
	static DP8ADDRESSOBJECT *STDMETHODCALLTYPE GetDirectPlay8Address(IDirectPlay8Address *pBuffer);

	HRESULT Cleanup();
	HRESULT Clear();
	HRESULT Init();
	HRESULT SetElement( const WCHAR * const pszTag, const void * const pvData, const DWORD dwDataSize, const DWORD dwDataType );
	HRESULT GetElement( DWORD dwIndex, WCHAR * pszTag, PDWORD pdwTagSize, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType );
	HRESULT GetElement( const WCHAR * const pszTag, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType );
	HRESULT GetSP( GUID * pGuid );
	HRESULT SetSP( LPCGUID const pGuid );
	HRESULT GetDevice( GUID * pGuid );
	HRESULT SetDevice( LPCGUID const pGuid );
	HRESULT SetUserData( const void * const pvData, const DWORD dwDataSize );
	HRESULT GetUserData( void * pvDataBuffer, PDWORD pdwDataSize );

	HRESULT BuildURL( WCHAR * szURL, PDWORD pdwRequiredSize )	;
	HRESULT SetURL( WCHAR * szURL );

	HRESULT GetElementType( const WCHAR * pszTag, PDWORD pdwType );

	HRESULT Lock();
	HRESULT UnLock();

	inline GetNumComponents() { return m_dwElements; };

	inline void ENTERLOCK() { DNEnterCriticalSection( &m_csAddressLock ); };
	inline void LEAVELOCK() { DNLeaveCriticalSection( &m_csAddressLock ); };

	static void FPM_Element_BlockInit( void *pvItem );
	static void FPM_Element_BlockRelease( void *pvItem );
	
protected:

	inline BOOL IsLocked() { return (m_iLockCount>0); };

	HRESULT BuildURL_AddElements( WCHAR *szElements );
	HRESULT BuildURL_AddHeader( WCHAR *szWorking );
	HRESULT BuildURL_AddUserData( WCHAR *szWorking );
	void BuildURL_AddString( WCHAR *szElements, WCHAR *szSource );
	HRESULT BuildURL_AddBinaryData( WCHAR *szSource, BYTE *bData, DWORD dwDataLen );

	HRESULT InternalGetElement( const WCHAR * const pszTag, PDP8ADDRESSELEMENT *ppaElement );
	HRESULT InternalGetElement( const DWORD dwIndex, PDP8ADDRESSELEMENT *ppaElement );
	HRESULT CalcComponentStringSize( PDP8ADDRESSELEMENT paddElement, PDWORD pdwSize );
	DWORD CalcExpandedStringSize( WCHAR *szString );
	DWORD CalcExpandedBinarySize( PBYTE pbData, DWORD dwDataSize );
	BOOL IsEscapeChar( WCHAR ch );
	BOOL IsValid();

	DWORD m_dwSignature;
	DNCRITICAL_SECTION m_csAddressLock;
	DWORD m_dwStringSize;
	DWORD m_dwElements;
	PDP8ADDRESSELEMENT m_pSP;
	PDP8ADDRESSELEMENT m_pAdapter;
	PVOID m_pvUserData;
	DWORD m_dwUserDataSize;
	DWORD m_dwUserDataStringSize;
	int m_iLockCount;
	BOOL m_fValid;
	CBilink  m_blAddressElements;

};

__inline DP8ADDRESSOBJECT *DP8ADDRESSOBJECT::GetDirectPlay8Address(IDirectPlay8Address *pBuffer)
{
    return (DP8ADDRESSOBJECT *)pBuffer;
}

typedef DP8ADDRESSOBJECT *PDP8ADDRESSOBJECT;

HRESULT DP8A_STRCACHE_Init();
void DP8A_STRCACHE_Free();
 
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_ADDR


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\strcache.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strcache.h
 *  Content:   Class for caching strings
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef __STRCACHE_H
#define __STRCACHE_H

class CStringCache
{
	STDNEWDELETE

public:
	CStringCache();
	~CStringCache();

	HRESULT AddString( const WCHAR *pszString, WCHAR * *ppszSlot );
	
protected:
	HRESULT GetString( const WCHAR *pszString, WCHAR * *ppszSlot );
	HRESULT GrowCache( DWORD dwNewSize );

	WCHAR ** m_ppszStringCache;
	DWORD m_dwNumElements;
	DWORD m_dwNumSlots;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvclient.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvclient.h
 *  Content:	Defines functions for the DirectXVoiceClient interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	02/07/99	rodtoll	Created It
 * 09/01/2000  georgioc started rewrite/port to xbox 
 *
 ***************************************************************************/

#ifndef __DVCLIENT__
#define __DVCLIENT__

#include "dvntos.h"
#include "dvoicep.h"
#include "dvcleng.h"
#include "dvtran.h"
#include "dvshared.h"

volatile struct DIRECTVOICECLIENTOBJECT : public DIRECTVOICEOBJECT
{
	CDirectVoiceClientEngine	*lpDVClientEngine;
};

typedef DIRECTVOICECLIENTOBJECT *LPDIRECTVOICECLIENTOBJECT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvcreate.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       unk.c
 *  Content:	IUnknown implementation
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 07/02/99 rodtoll Modified existing unk.c for use w/DirectXVoice
 * 07/26/99	rodtoll	Added the new IDirectXVoiceNotify Interfaces
 * 08/09/99 rodtoll	Fixed VTable for server notify interface
 * 08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *					compression sub-system. 
 * 08/31/99	rodtoll	Updated to use new debug libs 
 * 09/02/99	pnewson	Added IDirectXVoiceSetup interface
 * 09/07/99	rodtoll	Added DPF_MODNAMEs to the module
 * 			rodtoll	Fixed vtable for server object
 * 09/10/99	rodtoll	Vtables from static to non-static so other modules can access
 * 09/13/99	pnewson added dplobby.h include so lobby GUIDs get created
 * 09/14/99	rodtoll	Modified VTable to add new SetNotifyMask func
 * 10/05/99	rodtoll	Added DPFs
 * 10/07/99	rodtoll	Updated to work in Unicode, Add Init of OS Abstraction Layer
 * 10/18/99	rodtoll	Fix: Passing NULL in QueryInterface casues crash
 * 10/19/99	rodtoll	Fix: Bug #113904 Release Issues
 *					Added init for notify interface count
 * 10/25/99	rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 * 11/12/99	rodtoll	Fixed to use new dsound header.
 * 11/30/99	pnewson	Bug #117449 - IDirectPlayVoiceSetup Parameter validation
 * 12/01/99	rodtoll	Added includes to define and instantiate GUID_NULL
 * 12/16/99	rodtoll Bug #117405 - 3D sound APIs misleading
 * 01/14/00	rodtoll	Added new DVC_GetSoundDeviceConfig member to VTable
 * 02/17/00	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *					Added instrumentation
 *			rodtoll	Removed self-registration code
 * 03/03/00	rodtoll	Updated to handle alternative gamevoice build. 
 * 04/11/00 rodtoll Added code for redirection for custom builds if registry bit is set 
 * 04/21/00 rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 * 06/07/00	rodtoll	Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 * 06/28/2000	rodtoll	Prefix Bug #38022
 * 07/05/00	rodtoll	Moved code to new dllmain.cpp
 ***************************************************************************/

#include "dvntos.h"
#include <dvoicep.h>
#include "dvclient.h"
#include "dvserver.h"
#include "trnotify.h"
#include "in_core.h"

#define EXP __declspec(dllexport)

/*#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif*/

//
// keep global count of when/if we were initialized
//

LONG   g_DirectVoiceInitCount = 0;
#if DBG

UCHAR g_ModName[256];
PVOID g_This = NULL;
DVDEBUGDATA g_DVDbgData;

ULONG  g_DVDebugLevel = DPVL_ERRORS_ONLY;

#endif

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayVoiceCreate"

__inline HRESULT WINAPI XDirectPlayVoiceCreate(
	DWORD dwIID, 
	void** ppvInterface)
{

    return DirectPlayVoiceCreate(dwIID, ppvInterface, NULL);

}


HRESULT WINAPI DirectPlayVoiceCreate( DWORD dwIID, void **ppvInterface, void *pUnknown) 
{
    HRESULT hr = DV_OK;
    LPDIRECTVOICECLIENTOBJECT pDVCInt;

    ASSERT(pUnknown == NULL);

#if DBG

    memset(&g_DVDbgData,0,sizeof(g_DVDbgData));

#endif

#ifndef ASSUME_VALID_PARAMETERS

    if( dwIID != IID_IDirectPlayVoiceClient && 
        dwIID != IID_IDirectPlayVoiceServer)
    {
        DPVF( 0, "Interface ID is not recognized" );
        return DVERR_INVALIDPARAM;
    }

    if( ppvInterface == NULL )
    {
        DPVF( 0, "Invalid pointer specified to receive interface" );
        return DVERR_INVALIDPOINTER;
    }
#endif

    if (g_DirectVoiceInitCount == 0) {

        CDirectVoiceEngine::Startup();
        InterlockedIncrement(&g_DirectVoiceInitCount );

    }

	if( dwIID == IID_IDirectPlayVoiceServer )
	{
		LPDIRECTVOICESERVEROBJECT pDVSInt;
    
        pDVSInt = static_cast<LPDIRECTVOICESERVEROBJECT>( malloc(sizeof(DIRECTVOICESERVEROBJECT)) );
        if (pDVSInt == NULL)
        {
            DPVF( DPVF_ERRORLEVEL, "Out of memory" );
            return E_OUTOFMEMORY;
        }
    
        pDVSInt->lpDVServerEngine = new CDirectVoiceServerEngine(pDVSInt);
        pDVSInt->lpDVEngine = static_cast<CDirectVoiceEngine *>(pDVSInt->lpDVServerEngine);
    
        if (pDVSInt->lpDVEngine == NULL)
        {
            DPVF( DPVF_ERRORLEVEL, "Out of memory" );
            free( pDVSInt );
            return E_OUTOFMEMORY;
        }
    
        pDVSInt->lpDVTransport = NULL;
        pDVSInt->lIntRefCnt = 0;
        pDVSInt->dvNotify.lpDV = pDVSInt;
        pDVSInt->dvNotify.lRefCnt = 0;
    
        *ppvInterface = pDVSInt;

        // bump the refcount
		IDirectPlayVoiceServer_AddRef((LPDIRECTPLAYVOICESERVER) *ppvInterface);

	}
	else if( dwIID == IID_IDirectPlayVoiceClient) {    

        pDVCInt = static_cast<LPDIRECTVOICECLIENTOBJECT>( malloc(sizeof(DIRECTVOICECLIENTOBJECT)) );
        if (pDVCInt == NULL)
        {
            DPVF( DPVF_ERRORLEVEL, "Out of memory" );
            return E_OUTOFMEMORY;
        }
    
        pDVCInt->lpDVClientEngine = new CDirectVoiceClientEngine(pDVCInt);
        pDVCInt->lpDVEngine = static_cast<CDirectVoiceEngine *>(pDVCInt->lpDVClientEngine);
    
        if (pDVCInt->lpDVEngine == NULL)
        {
            DPVF( DPVF_ERRORLEVEL, "Out of memory" );
            free( pDVCInt );
            return E_OUTOFMEMORY;
        }
    
        pDVCInt->lpDVTransport = NULL;
        pDVCInt->lIntRefCnt = 0;
        pDVCInt->dvNotify.lpDV = pDVCInt;
        pDVCInt->dvNotify.lRefCnt = 0;
    
        *ppvInterface = pDVCInt;

        // get the right interface and bump the refcount
		IDirectPlayVoiceClient_AddRef((LPDIRECTPLAYVOICECLIENT) *ppvInterface);
    
    }    

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dnaddress\strcache.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strcache.cpp
 *  Content:   Class for caching strings
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_ADDR

// # of slots to grow the cache at each opportunity
#define STRINGCACHE_GROW_SLOTS				10

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::CStringCache"

CStringCache::CStringCache(): m_ppszStringCache(NULL), m_dwNumElements(0), m_dwNumSlots(0)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::~CStringCache"

CStringCache::~CStringCache()
{
	for( DWORD dwIndex = 0; dwIndex < m_dwNumElements; dwIndex++ )
	{
		delete [] m_ppszStringCache[dwIndex];
	}

	delete [] m_ppszStringCache;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::AddString"

HRESULT CStringCache::AddString( const WCHAR *pszString, WCHAR * *ppszSlot )
{
	HRESULT hr;
	PWSTR pszSlot;

	hr = GetString( pszString, &pszSlot );

	if( hr != DPN_OK )
	{
		DPF( 0, "Internal Error hr=0x%x", hr );
		return hr;
	}

	// Entry was found
	if( pszSlot != NULL )
	{
		*ppszSlot = pszSlot;
		return DPN_OK;
	}
	else
	{
		if( m_dwNumElements == m_dwNumSlots )
		{
			hr = GrowCache( m_dwNumSlots + STRINGCACHE_GROW_SLOTS );

			if( FAILED( hr ) )
			{
				DPF( 0, "Failed to grow string cache hr=0x%x", hr );
				return hr;
			}
		}

		m_ppszStringCache[m_dwNumElements] = new WCHAR[wcslen(pszString)+1];

		if( m_ppszStringCache[m_dwNumElements] == NULL )
		{
			DPF( 0, "Failed to alloc mem" );
			return DPNERR_OUTOFMEMORY;
		}

		wcscpy( m_ppszStringCache[m_dwNumElements], pszString );
		*ppszSlot = m_ppszStringCache[m_dwNumElements];

		m_dwNumElements++;

		return DPN_OK;
		
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::GetString"

HRESULT CStringCache::GetString( const WCHAR *pszString, WCHAR * *ppszSlot )
{
	*ppszSlot = NULL;
	
	for( DWORD dwIndex = 0; dwIndex < m_dwNumElements; dwIndex++ )
	{
		if( wcscmp( m_ppszStringCache[dwIndex], pszString ) == 0 )
		{
			*ppszSlot = m_ppszStringCache[dwIndex];
			return DPN_OK;
		}
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::GrowCache"

HRESULT CStringCache::GrowCache( DWORD dwNewSize )
{
	WCHAR **ppszNewCache;

	ppszNewCache = new WCHAR *[dwNewSize];

	if( ppszNewCache == NULL )
	{
		DPF( 0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;
	}

	memcpy( ppszNewCache, m_ppszStringCache, sizeof( WCHAR * ) * m_dwNumElements );
	m_dwNumSlots = dwNewSize;

	if( m_ppszStringCache != NULL )
		delete [] m_ppszStringCache;	

	m_ppszStringCache = ppszNewCache;

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvclient.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvclient.c
 *  Content:	Implements functions for the DirectXVoiceClient interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/02/99	rodtoll	Created It
 *  07/26/99	rodtoll	Updated QueryInterface to support IDirectXVoiceNotify
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added new parameter to GetCompressionTypes
 *  09/03/99	rodtoll	Updated parameters for DeleteUserBuffer
 *  09/07/99	rodtoll	Updated EnumCompressionTypes so that object doesn't
 *						need to be Initialized.
 *  09/10/99	rodtoll	Object validity checking
 *  09/14/99	rodtoll	Added DVC_SetNotifyMask  
 *  10/05/99	rodtoll	Reversed destruction order to destroy object before
 *						transport.  Fixes crash in some situations
 *  10/18/99	rodtoll	Fix: Passing NULL in QueryInterface casues crash
 *				rodtoll	Fix: Calling Initialize twice passes
 *  10/19/99	rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if disconnect should be called from release
 *  10/25/99	rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 *  11/17/99	rodtoll	Fix: Bug #117447 - Removed checks for initialization because
 *						DirectVoiceCLientEngine members already do this.
 *  12/16/99	rodtoll	Bug #117405 - 3D Sound APIs misleading - 3d sound apis renamed
 *						The Delete3DSoundBuffer was re-worked to match the create
 *  01/14/2000	rodtoll	Updated parameters to Get/SetTransmitTargets
 *				rodtoll	Added new API call GetSoundDeviceConfig 
 *  01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC  
 *  03/28/2000  rodtoll   Removed reference to removed header file.
 *  06/21/2000	rodtoll	Bug #35767 - Update Create3DSoundBuffer to take DIRECTSOUNDBUFFERs
 *
 ***************************************************************************/

#include "dvntos.h"
#include  <dvoicep.h>
#include "dvclient.h"
#include "in_core.h"
#include "trnotify.h"

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_Initialize"
HRESULT WINAPI IDirectPlayVoiceClient_Initialize(LPDIRECTPLAYVOICECLIENT lpDV, PVOID lpTransport, LPDVMESSAGEHANDLER lpMessageHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{
    HRESULT hr;
    //
    // call the common routine
    //

    hr = DV_Initialize((LPDIRECTVOICEOBJECT) lpDV, lpTransport,lpMessageHandler, lpUserContext, lpdwMessages, dwNumElements);
    PAGED_CODE();
    return hr;

}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_DoWork"
HRESULT WINAPI IDirectPlayVoiceClient_DoWork(LPDIRECTPLAYVOICECLIENT lpDV)
{

    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
    HRESULT hr;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );


	hr = This->lpDVClientEngine->DoWork();
    PAGED_CODE();
    return hr;

}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_AddRef"
ULONG WINAPI IDirectPlayVoiceClient_AddRef(LPDIRECTPLAYVOICECLIENT This )
{
    LPDIRECTVOICECLIENTOBJECT lpDV  = (LPDIRECTVOICECLIENTOBJECT) This;
	LONG rc;
    KIRQL irql;
	RIRQL(irql); 

	rc = ++lpDV->lIntRefCnt;

    LIRQL(irql); 
	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_Release"
ULONG WINAPI IDirectPlayVoiceClient_Release(LPDIRECTPLAYVOICECLIENT This )
{
    LPDIRECTVOICECLIENTOBJECT lpDV  = (LPDIRECTVOICECLIENTOBJECT) This;
    HRESULT hr=S_OK;
    LONG rc;
    KIRQL irql;
	ASSERT( lpDV );

	RIRQL(irql);

	if (lpDV->lIntRefCnt == 0)
	{
		LIRQL(irql);
		return 0;
	}

	// dec the interface count
	lpDV->lIntRefCnt--;

	// Special case: Releasing object without stopping session
	// May be more then one transport thread indicating in us 
	if( (lpDV->lIntRefCnt == 0) && lpDV->lpDVClientEngine->GetCurrentState() != DVCSTATE_IDLE  )
	{
		DPVF( DPVF_ERRORLEVEL, "Releasing interface without calling Disconnect" );

		lpDV->lIntRefCnt = 0;

		// We must release the lock because stopsession may call back into this function
		LIRQL(irql);		

		hr = lpDV->lpDVClientEngine->Disconnect( 0 );

		RIRQL(irql);			

		if( FAILED(hr))
		{
			DPVF( DPVF_ERRORLEVEL, "Disconnect Failed hr=0x%x", hr );
		}

	}

    PAGED_CODE();

	rc = lpDV->lIntRefCnt;

	if ( lpDV->lIntRefCnt == 0 )
	{
		// Leave the critical section, we may call back into this func.
		// (Shouldn't though).
		LIRQL(irql);

		delete lpDV->lpDVClientEngine;
		lpDV->lpDVClientEngine = NULL;

		if( lpDV->lpDVTransport != 0 )
		{
			ASSERT( lpDV->lpDVTransport->m_lRefCount == 0 );		
			delete lpDV->lpDVTransport;
			lpDV->lpDVTransport = NULL;
		}

		free(lpDV);
	} 
	else
	{
		LIRQL(irql);
	}
   	
    PAGED_CODE();
    return rc;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_Connect"
STDMETHODIMP IDirectPlayVoiceClient_Connect(LPDIRECTPLAYVOICECLIENT lpDV,LPDVCLIENTCONFIG lpClientConfig, DWORD dwFlags )
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );


	hr = This->lpDVClientEngine->Connect(lpClientConfig, dwFlags );
    PAGED_CODE();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_Disconnect"
STDMETHODIMP IDirectPlayVoiceClient_Disconnect(LPDIRECTPLAYVOICECLIENT lpDV, DWORD dwFlags)
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );

	hr = This->lpDVClientEngine->Disconnect( dwFlags );
    PAGED_CODE();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_GetSessionDesc"
STDMETHODIMP IDirectPlayVoiceClient_GetSessionDesc(LPDIRECTPLAYVOICECLIENT lpDV, LPDVSESSIONDESC lpSessionDesc )
{
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
    HRESULT hr;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );
	hr = This->lpDVClientEngine->GetSessionDesc( lpSessionDesc );
    PAGED_CODE();
    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_GetClientConfig"
STDMETHODIMP IDirectPlayVoiceClient_GetClientConfig(LPDIRECTPLAYVOICECLIENT lpDV, LPDVCLIENTCONFIG lpClientConfig )
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );

	hr = This->lpDVClientEngine->GetClientConfig( lpClientConfig );
    PAGED_CODE();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_SetClientConfig"
STDMETHODIMP IDirectPlayVoiceClient_SetClientConfig(LPDIRECTPLAYVOICECLIENT lpDV, LPDVCLIENTCONFIG lpClientConfig )
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );

	hr = This->lpDVClientEngine->SetClientConfig( lpClientConfig );
    PAGED_CODE();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_SetTransmitTargets"
STDMETHODIMP IDirectPlayVoiceClient_SetTransmitTargets( LPDIRECTPLAYVOICECLIENT lpDV, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags )
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );
	hr = This->lpDVClientEngine->SetTransmitTarget( pdvidTargets, dwNumTargets, dwFlags );
    PAGED_CODE();
    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_GetTransmitTarget"
STDMETHODIMP IDirectPlayVoiceClient_GetTransmitTarget(LPDIRECTPLAYVOICECLIENT lpDV, LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags )
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );
	hr = This->lpDVClientEngine->GetTransmitTarget( lpdvidTargets, pdwNumElements, dwFlags );
    PAGED_CODE();
    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_SetNotifyMask"
STDMETHODIMP IDirectPlayVoiceClient_SetNotifyMask( LPDIRECTPLAYVOICECLIENT lpDV, LPDWORD lpdwMessages, DWORD dwNumElements )
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );
	hr = This->lpDVClientEngine->SetNotifyMask( lpdwMessages, dwNumElements );
    PAGED_CODE();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_CreateSoundTarget"
STDMETHODIMP IDirectPlayVoiceClient_CreateSoundTarget( LPDIRECTPLAYVOICECLIENT lpDV, DVID dvidID, PWAVEFORMATEX *ppwfxMediaFormat, XMediaObject **ppMediaObject)
{
    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );
	hr = This->lpDVClientEngine->CreateSoundTarget( dvidID, ppwfxMediaFormat, ppMediaObject);
    PAGED_CODE();
    return hr;


}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceClient_DeleteSoundTarget"
STDMETHODIMP IDirectPlayVoiceClient_DeleteSoundTarget( LPDIRECTPLAYVOICECLIENT lpDV, DVID dvidID, XMediaObject **ppMediaObject)
{

    HRESULT hr;
    LPDIRECTVOICECLIENTOBJECT This  = (LPDIRECTVOICECLIENTOBJECT) lpDV;
	ASSERT( This != NULL );
	ASSERT( This->lpDVEngine != NULL );
	hr = This->lpDVClientEngine->DeleteSoundTarget(dvidID, ppMediaObject );
    PAGED_CODE();
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvcleng.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvclientengine.cpp
 *  Content:    Implementation of class for DirectXVoice Client
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 07/19/99     rodtoll Created
 * 09/01/2000   georgioc started rewrite/port to xbox
========================================================================== */

#include "dvntos.h"
#include <dvoicep.h>
#include "dvcleng.h"
#include "dvshared.h"
#include "mixutils.h"
#include "sndutils.h"
#include "dvrecsub.h"
#include "dvclient.h"
#include "dvshared.h"
#include "dvsndt.h"
#include "dvserver.h"
#include "dvdxtran.h"
#include "in_core.h"

// Forces full duplex mode
//#define __FORCEFULLDUPLEX

// # of ms of inactivity before a multicast user is considered to have
// timed-out.
#define DV_MULTICAST_USERTIMEOUT_PERIOD     300000

// # of ms of inactivity before an incoming audio stream is considered to 
// have stopped.  Used to determine when to send PLAYERVOICESTOP 
// message.
#define PLAYBACK_RECEIVESTOP_TIMEOUT        500

// # of ms the notify thread sleeps without notification to wakeup 
// and perform house cleaning.
#define DV_CLIENT_NOTIFYWAKEUP_TIMEOUT      100

// # of ms before a connect request is considered to have been lost
#define DV_CLIENT_CONNECT_RETRY_TIMEOUT     1250

// # of ms before we should timeout a connect request completely
#define DV_CLIENT_CONNECT_TIMEOUT           30000

// Maximum count notification semaphores can have 
#define DVCLIENT_NOTIFY_MAXSEMCOUNT         20

//// TODO: Needs tuning.
// # of ms to wait for disconnect reply from server before timing out.
#define DV_CLIENT_DISCONNECT_TIMEOUT        10000


#define DV_CLIENT_SRCQUALITY_INVALID        ((DIRECTSOUNDMIXER_SRCQUALITY) 0xFFFFFFFF)

#define CLIENT_POOLS_NUM_TARGETS_BUFFERED   10

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CDirectVoiceClientEngine"
//
// Constructor
//
// Initializes object to uninitialized state.  Must call Initialize succesfully before 
// the object can be used (except GetCompressionTypes which can be called at any time).  
//
CDirectVoiceClientEngine::CDirectVoiceClientEngine( DIRECTVOICECLIENTOBJECT *lpObject
    ):  m_dwSignature(VSIG_CLIENTENGINE),
        m_lpFramePool(NULL),
        m_lpObject(lpObject),
        m_lpSessionTransport(NULL),
        m_lpUserContext(NULL),
        m_tmpFrame(NULL),
        m_RecordSubSystem(NULL),
        m_dvidServer(0),
        m_bLastPeak(0),
        m_bLastPlaybackPeak(0),
        m_bLastTransmitted(FALSE),
        m_bMsgNum(0),
        m_bSeqNum(0),
        m_dwLastConnectSent(0),
        m_dwCurrentState(DVCSTATE_NOTINITIALIZED),
        m_hrConnectResult(DV_OK),
        m_hrDisconnectResult(DV_OK),
        m_lpdvServerMigrated(NULL),
        m_pFramePool(NULL),
        m_pMessageElements(NULL),
        m_dwNumMessageElements(0),
        m_fSessionLost(FALSE),
        m_fLocalPlayerNotify(FALSE),
        m_dwHostOrderID(DVPROTOCOL_HOSTORDER_INVALID),
        m_pdvidTargets(NULL),
        m_dwNumTargets(0),
        m_dwTargetVersion(0),
        m_dwPlayActiveCount(0),
        m_fLocalPlayerAvailable(FALSE),
        m_fNotifyQueueEnabled(FALSE),
        m_pBufferDescAllocation(NULL),
        m_pMessagePoolAllocation(NULL),
        m_pSpeechBufferAllocation(NULL)

{

    InitializeListHead(&m_NotifyList);
    memset(&m_dvClientConfig, 0 ,sizeof(DVCLIENTCONFIG));

    InitializeCriticalSection(&m_CS);

    m_SpeechBufferAllocs = 0;
    m_MsgBufferAllocs = 0;

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::~CDirectVoiceClientEngine"
// Destructor
//
// This function requires a write lock to complete.  
//
// If the object is connected to a session, it will be disconnected
// by this function.
//
// Releases the resources associated with the object and stops the 
// notifythread.
//
// Locks Required:
// - Class Write Lock
//
// Called By:
// DVC_Release when reference count reaches 0.
//
CDirectVoiceClientEngine::~CDirectVoiceClientEngine()
{
    DPVF_ENTER();

    //
    // BUGBUG to we need DPC sync. here?

    if( m_dwCurrentState != DVCSTATE_IDLE && 
        m_dwCurrentState != DVCSTATE_NOTINITIALIZED )
    {
        Cleanup();
    }

    if( m_lpdvServerMigrated != NULL )
    {
        m_lpdvServerMigrated->Release();
        m_lpdvServerMigrated = NULL;
    }

    if( m_pMessageElements != NULL )
        DV_POOL_FREE(m_pMessageElements);       

    //
    // lower irql..

    NotifyQueue_Free();

    if( m_pdvidTargets != NULL )
    {
        DV_POOL_FREE (m_pdvidTargets);
    }

    m_dwSignature = VSIG_CLIENTENGINE_FREE;
    DPVF_EXIT();
}

// InternalSetNotifyMask
//
// Sets the list of valid notifiers for this object.
//
// must be called at DPC 
//
// Called By:
// DVC_SetNotifyMask
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InternalSetNotifyMask" 
HRESULT CDirectVoiceClientEngine::InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{

    DPVF_ENTER();

    // Delete previous elements
    if( m_pMessageElements != NULL )
    {
        DV_POOL_FREE(m_pMessageElements);
        m_pMessageElements = NULL;
    }

    m_dwNumMessageElements = dwNumElements;

    // Make copies of the message elements into our own message array.
    if( dwNumElements > 0 )
    {
        m_pMessageElements = (PDWORD) DV_POOL_ALLOC(sizeof(DWORD)*dwNumElements);

        if( m_pMessageElements == NULL )
        {
            DPVF( DPVF_ERRORLEVEL, "Initialize: Error allocating memory" );
            return DVERR_OUTOFMEMORY;
        }

        memcpy( m_pMessageElements, lpdwMessages, sizeof(DWORD)*dwNumElements );
    }
    else
    {
        m_pMessageElements = NULL;
    }   

    DPVF_EXIT();
    return DV_OK;

}


// SetNotifyMask
//
// Sets the list of valid notifiers for this object.
//
// Locks Needed:
// - ReadLock to check status and then releases it.
// - m_csNotifyLock to update notification list
//
// Called By:
// DVC_SetNotifyMask
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetNotifyMask" 
HRESULT CDirectVoiceClientEngine::SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{
    HRESULT hr;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Enter" );
#ifndef ASSUME_VALID_PARAMETERS
    hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, FALSE );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL,"ValidMessageArray Failed 0x%x", hr ); 
        DPVF_EXIT();
        return hr;
    }   
#endif  
    DPVF( DPVF_APIPARAM, "Message IDs=%d", dwNumElements );
    
    if( lpdwMessages != NULL )
    {
        for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
        {
            DPVF( DPVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
        }
    }

    if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not initialized" );
        DPVF_EXIT();
        return DVERR_NOTINITIALIZED;
    }

    if( m_lpMessageHandler == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
        return DVERR_NOCALLBACK;
    }       

    hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

    DPVF( DPVF_APIPARAM, "Returning hr=0x%x", hr );

    DPVF_EXIT();
    return DV_OK;
}

// Initialize
//
// Initializes this object into a state where it can be used to Connect to a session.  Sets the 
// notification function, notification mask and the transport object that will be used.
//
// Starts the notification thread.
//
// Locks Required:
// - Class Write Lock
// 
// Called By: 
// DV_Initialize
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Initialize"
HRESULT CDirectVoiceClientEngine::Initialize(
    CDirectVoiceTransport *lpTransport,
    LPDVMESSAGEHANDLER lpdvHandler,
    LPVOID lpUserContext,
    LPDWORD lpdwMessages,
    DWORD dwNumElements )
{
    HRESULT hr;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    DPVF( DPVF_ENTRYLEVEL, "Enter" );

    DPVF( DPVF_APIPARAM, "Param: lpTransport = 0x%p lpdvHandler = 0x%p lpUserContext = 0x%p dwNumElements = %d", lpTransport, lpdvHandler, lpUserContext, dwNumElements );   

    if( lpTransport == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid transport" );
        DPVF_EXIT();
        return DVERR_INVALIDPOINTER;
    }

#ifndef ASSUME_VALID_PARAMETERS
    hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, FALSE );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "ValidMessageArray Failed hr = 0x%x", hr );   
        DPVF_EXIT();
        return hr;
    }   
    
    DPVF( DPVF_APIPARAM, "Message IDs=%d", dwNumElements );
    
#if DBG
    if( lpdwMessages != NULL )
    {
        for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
        {
            DPVF( DPVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
        }
    }
#endif

    if( lpdvHandler == NULL && lpdwMessages != NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
        DPVF_EXIT();
        return DVERR_NOCALLBACK;
    }   

#endif

    if( m_dwCurrentState != DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Already Initialized" );
    }

    m_dwLastConnectSent = 0;
    m_dwSynchBegin = 0;
    SetCurrentState( DVCSTATE_IDLE );   

    m_lpMessageHandler = lpdvHandler;
    
    hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

    if( FAILED( hr ) )
    {
        SetCurrentState( DVCSTATE_NOTINITIALIZED ); 
        DPVF( DPVF_ERRORLEVEL, "SetNotifyMask Failed hr=0x%x", hr );
        DPVF_EXIT();
        return hr;
    }

    m_lpSessionTransport = lpTransport;
    m_lpUserContext = lpUserContext;

    m_dvidLocal = 0;

    DPVF_EXIT();

    hr = m_lpSessionTransport->Initialize();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Connect"
// Connect
//
// Implements the IDirectXVoiceClient::Connect function.
//
// Locks Required:
// - Write Lock
//
// Called By:
// DVC_Connect
//
HRESULT CDirectVoiceClientEngine::Connect(LPDVCLIENTCONFIG lpClientConfig, DWORD dwFlags )
{
    HRESULT hr; 

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Enter" );

#ifndef ASSUME_VALID_PARAMETERS
    hr = DV_ValidClientConfig( lpClientConfig );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid Client Config hr=0x%x", hr );
        DPVF_EXIT();
        return hr;
    }

#endif

    DV_AUTO_LOCK(&m_CS);

    DV_DUMP_CC( lpClientConfig );

    if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Object not initialized" );
        DPVF_EXIT();
        return DVERR_NOTINITIALIZED;
    }

    if( m_dwCurrentState == DVCSTATE_CONNECTING ||
        m_dwCurrentState == DVCSTATE_DISCONNECTING )
    {
        DPVF( DPVF_ERRORLEVEL, "Already connecting or disconnecting" );
        return DVERR_ALREADYPENDING;
    }

    if( m_dwCurrentState == DVCSTATE_CONNECTED )
    {
        DPVF( DPVF_ERRORLEVEL, "Already connected" );
        DPVF_EXIT();
        return DVERR_CONNECTED;
    }

    // RESET Session flags that need to be reset on every connect
    m_fSessionLost = FALSE;
    m_fLocalPlayerNotify = FALSE;
    m_fLocalPlayerAvailable = FALSE;
    m_dwHostOrderID = DVPROTOCOL_HOSTORDER_INVALID; 

    memcpy( &m_dvClientConfig, lpClientConfig, sizeof( DVCLIENTCONFIG ) );

    if( m_dvClientConfig.dwThreshold == DVTHRESHOLD_DEFAULT )
    {
        m_dvClientConfig.dwThreshold = s_dwDefaultSensitivity;
    }

    if( m_dvClientConfig.dwThreshold == DVTHRESHOLD_UNUSED )
    {
        m_dvClientConfig.dwThreshold = s_dwDefaultSensitivity;
    }

    m_dwLastConnectSent = 0;
    m_dwSynchBegin = 0;
    SetCurrentState( DVCSTATE_CONNECTING );

    //
    // initialize notification queue
    //

    hr = DV_InitializeList(&m_NotificationElementPool,
                           m_lpSessionTransport->GetMaxPlayers(),
                           sizeof(CNotifyElement),
                           DVLAT_RAW);

    if (FAILED(hr)) {
        ASSERT(FALSE);
        DPVF_EXIT();
        return hr;
    }

    m_fNotifyQueueEnabled = TRUE;
    
    m_dwPlayActiveCount = 0;
    InitializeListHead( &m_PlayActivePlayersList);
    InitializeListHead( &m_PlayAddPlayersList);
    InitializeListHead( &m_NotifyActivePlayersList);
    InitializeListHead( &m_NotifyAddPlayersList);

    hr = SetupInitialBuffers(); 

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "SetupBuffersInitial Failed 0x%x", hr );
        DPVF_EXIT();
        goto CONNECT_ERROR;
    }        

    hr = m_lpSessionTransport->EnableReceiveHook( m_lpObject, DVTRANSPORT_OBJECTTYPE_CLIENT );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "EnableReceiveHook Failed 0x%x", hr );
        DPVF_EXIT();
        goto CONNECT_ERROR;
    }

    m_dvidServer = m_lpSessionTransport->GetServerID();
    m_dvidLocal = m_lpSessionTransport->GetLocalID();

    //
    // Initialize the name table
    //

    m_voiceNameTable.Initialize();

    //
    // Send connect request to the server
    //

    m_dwLastConnectSent = GetTickCount();
    m_dwSynchBegin = m_dwLastConnectSent;

    hr = Send_ConnectRequest();
    
    DPVF(  DPVF_INFOLEVEL, "DVCE::Connect() - Sending Request to server" );

    if( FAILED( hr ) )
    {
        DPVF(  DPVF_ERRORLEVEL, "Error on send 0x%x", hr  );
        DPVF_EXIT();
        goto CONNECT_ERROR;
    }

    DPVF_EXIT();
    return DVERR_PENDING;
    
CONNECT_ERROR:

    SetCurrentState( DVCSTATE_IDLE );       
               
    m_voiceNameTable.DeInitialize((m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER),m_lpUserContext,m_lpMessageHandler);
    
    FreeBuffers();
    
    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_SessionLost"
HRESULT CDirectVoiceClientEngine::Send_SessionLost()
{
    PDVPROTOCOLMSG_SESSIONLOST pSessionLost;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    LPVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();
    pBufferDesc = GetTransmitBuffer(sizeof( DVPROTOCOLMSG_SESSIONLOST ), &pvSendContext, FALSE );

    if( pBufferDesc == NULL )
    {
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;       
    }

    pSessionLost = (PDVPROTOCOLMSG_SESSIONLOST) pBufferDesc->pBufferData;

    // Send connection request to the server
    pSessionLost->dwType = DVMSGID_SESSIONLOST;
    pSessionLost->hresReason = DVERR_SESSIONLOST;
    
    // Fixed so that it gets sent
    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPVF( 0, "Error sending connect request hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_ConnectRequest"
HRESULT CDirectVoiceClientEngine::Send_ConnectRequest()
{
    PDVPROTOCOLMSG_CONNECTREQUEST pConnectRequest;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    LPVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();
    pBufferDesc = GetTransmitBuffer(sizeof( DVPROTOCOLMSG_CONNECTREQUEST ),&pvSendContext, FALSE );

    if( pBufferDesc == NULL )
    {
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;       
    }

    pConnectRequest = (PDVPROTOCOLMSG_CONNECTREQUEST) pBufferDesc->pBufferData;

    // Send connection request to the server
    pConnectRequest->dwType = DVMSGID_CONNECTREQUEST;
    pConnectRequest->ucVersionMajor = DVPROTOCOL_VERSION_MAJOR;
    pConnectRequest->ucVersionMinor = DVPROTOCOL_VERSION_MINOR;
    pConnectRequest->dwVersionBuild = DVPROTOCOL_VERSION_BUILD; 
    
    hr = m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPVF( 0, "Error sending connect request hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_DisconnectRequest"
HRESULT CDirectVoiceClientEngine::Send_DisconnectRequest()
{
    PDVPROTOCOLMSG_GENERIC pDisconnectRequest;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    LPVOID pvSendContext;
    HRESULT hr; 

    DPVF_ENTER();
    pBufferDesc = GetTransmitBuffer(sizeof( DVPROTOCOLMSG_GENERIC ), &pvSendContext, FALSE );

    if( pBufferDesc == NULL )
    {
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;       
    }

    pDisconnectRequest = (PDVPROTOCOLMSG_GENERIC) pBufferDesc->pBufferData;

    // Send connection request to the server
    pDisconnectRequest->dwType = DVMSGID_DISCONNECT;
    
    hr = m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPVF( 0, "Error sending connect request hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_SettingsConfirm"
HRESULT CDirectVoiceClientEngine::Send_SettingsConfirm()
{
    PDVPROTOCOLMSG_SETTINGSCONFIRM pSettingsConfirm;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    LPVOID pvSendContext;
    HRESULT hr; 

    DPVF_ENTER();
    pBufferDesc = GetTransmitBuffer(sizeof( DVPROTOCOLMSG_SETTINGSCONFIRM ), &pvSendContext, FALSE );

    if( pBufferDesc == NULL )
    {
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;       
    }

    pSettingsConfirm = (PDVPROTOCOLMSG_SETTINGSCONFIRM) pBufferDesc->pBufferData;

    // Send connection request to the server
    pSettingsConfirm->dwType = DVMSGID_SETTINGSCONFIRM;
    pSettingsConfirm->dwHostOrderID = m_dwHostOrderID;
    pSettingsConfirm->dwFlags = 0;

    hr = m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPVF( 0, "Error sending connect request hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Disconnect"
// Disconnect
//
// Implements the IDirectXVoiceClient::Disconnect function
//
// Locks Required:
// - Global Lock
//
// Called By:
// DVC_Disconnect
//
HRESULT CDirectVoiceClientEngine::Disconnect( DWORD dwFlags )
{
    HRESULT hr;

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Enter" );
    DPVF( DPVF_APIPARAM, "dwFlags = 0x%x", dwFlags );    

    DV_AUTO_LOCK(&m_CS);

    if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not initialized" );
        DPVF_EXIT();
        return DVERR_NOTINITIALIZED;
    }

    if( m_dwCurrentState == DVCSTATE_CONNECTING )
    {
    
        DPVF(  DPVF_INFOLEVEL, "DVCE::Disconnect() Abort connection" );

        // Handle Connect
        m_hrConnectResult = DVERR_CONNECTABORTED;

        SendConnectResult();

        DoSignalDisconnect( DVERR_CONNECTABORTED );     

        DPVF( DPVF_INFOLEVEL, "Returning DVERR_CONNECTABORTING" );
    
        DPVF_EXIT();
        return DVERR_CONNECTABORTING;
    }

    DPVF( DPVF_INFOLEVEL, "State Good.." );   
    
    if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
    {
        DPVF( DPVF_ERRORLEVEL, "Already disconnecting." );

        return DV_OK;
    }
    else if( m_dwCurrentState != DVCSTATE_CONNECTED )
    {
        DPVF(  DPVF_ERRORLEVEL, "Not Connected" );     
        DPVF( DPVF_APIPARAM, "Returning DVERR_NOTCONNECTED" );           
        DPVF_EXIT();
        return DVERR_NOTCONNECTED;
    }
    else
    {
        m_dwSynchBegin = GetTickCount();    

        // Set current state to disconnecting before we release the lock
        SetCurrentState( DVCSTATE_DISCONNECTING );      

        DPVF( DPVF_ERRORLEVEL, "Disconnect request about to be sent" );

        hr = Send_DisconnectRequest();

        DPVF( DPVF_INFOLEVEL, "Disconnect request transmitted hr=0x%x", hr );

        if( FAILED( hr ) )
        {
            DPVF(  DPVF_INFOLEVEL, "DVCE::Disconnect - Error on send 0x%x", hr );
            hr = DV_OK;

            return hr;

        }
        else
        {
            DPVF( DPVF_INFOLEVEL, "Disconnect sent" );
        }
    }

    DPVF( DPVF_INFOLEVEL, "Returning DVERR_PENDING" );

    DPVF_EXIT();

    return DVERR_PENDING;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetSessionDesc"
// GetSessionDesc
//
// Retrieves the current session description.
//
// Called By:
// DVC_GetSessionDesc
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceClientEngine::GetSessionDesc( PDVSESSIONDESC lpSessionDesc )
{
    
    HRESULT hr;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF(  DPVF_ENTRYLEVEL, "Enter" );

    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "lpSessionDescBuffer = 0x%p", lpSessionDesc ); 
#ifndef ASSUME_VALID_PARAMETERS
    if( lpSessionDesc == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Session desc pointer bad" );
        DPVF_EXIT();
        return DVERR_INVALIDPOINTER;
    }

    if( lpSessionDesc->dwSize != sizeof( DVSESSIONDESC ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid size on session desc" );
        DPVF_EXIT();
        return DVERR_INVALIDPARAM;
    }
#endif

    hr = CheckConnected();
    if( FAILED(hr))
    {
        DPVF( DPVF_ERRORLEVEL, "Object not initalized" );
        DPVF_EXIT();
        return hr;
    }

    memcpy( lpSessionDesc, &m_dvSessionDesc, sizeof( DVSESSIONDESC ) ); 

    DPVF( DPVF_APIPARAM, "Returning DV_OK" );

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetClientConfig"
// GetClientConfig
// 
// Retrieves the current client configuration.
//
// Called By:
// DVC_GetClientConfig
//
// Locks Required:
// - Global Read Lock
HRESULT CDirectVoiceClientEngine::GetClientConfig( LPDVCLIENTCONFIG lpClientConfig )
{
    HRESULT hr;
    DV_AUTO_LOCK(&m_CS);


    DPVF_ENTER();
    DPVF(  DPVF_ENTRYLEVEL, "Enter" );

    DPVF( DPVF_APIPARAM, "lpClientConfig = 0x%p", lpClientConfig );
#ifndef ASSUME_VALID_PARAMETERS
    if( lpClientConfig == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
        DPVF_EXIT();
        return E_POINTER;
    }

    if( lpClientConfig->dwSize != sizeof( DVCLIENTCONFIG ) )
    {
        DPVF(  DPVF_ERRORLEVEL, "Invalid Size on clientconfig" );
        DPVF_EXIT();
        return DVERR_INVALIDPARAM;
    }
#endif
    
    hr = CheckConnected();
    if(FAILED(hr))
    {
        DPVF( DPVF_ERRORLEVEL, "Object not initialized" );
        DPVF_EXIT();
        return hr;
    }

    memcpy( lpClientConfig, &m_dvClientConfig, sizeof( DVCLIENTCONFIG ) );

    if( lpClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED )
    {
        lpClientConfig->dwThreshold = DVTHRESHOLD_UNUSED;
    }

    DV_DUMP_CC( lpClientConfig );

    DPVF(  DPVF_ENTRYLEVEL, "End" );
    DPVF( DPVF_APIPARAM, "Returning DV_OK" );

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetClientConfig"
// SetClientConfig
//
// Sets the current client configuration.
//
// Called By:
// DVC_SetClientConfig
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceClientEngine::SetClientConfig( LPDVCLIENTCONFIG lpClientConfig )
{
    HRESULT hr;
    BOOL bPlaybackChange = FALSE,
         bRecordChange = FALSE,
         bSensitivityChange = FALSE;


    DV_AUTO_LOCK(&m_CS);
     

    DPVF_ENTER();
    DPVF(  DPVF_ENTRYLEVEL, "Enter" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "lpClientConfig=0x%p", lpClientConfig );

#ifndef ASSUME_VALID_PARAMETERS
    if(lpClientConfig == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
        DPVF_EXIT();
        return E_POINTER;
    }

    DV_DUMP_CC( lpClientConfig );

    if( lpClientConfig->dwSize != sizeof( DVCLIENTCONFIG ) )
    {
        DPVF(  DPVF_ERRORLEVEL, "DVCE::SetClientConfig() Error parameters" );
        DPVF_EXIT();
        return DVERR_INVALIDPARAM;
    }

    hr = DV_ValidClientConfig( lpClientConfig );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error validating Clientconfig hr=0x%x", hr );
        DPVF_EXIT();
        return hr;
    }       

#endif

    hr = CheckConnected();
    if(FAILED(hr))
    {
        DPVF_EXIT();
        return hr;
    }

    if( !(lpClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED ) )
    {
        m_dvClientConfig.dwThreshold = DVTHRESHOLD_UNUSED;
    }
    else if( m_dvClientConfig.dwThreshold != lpClientConfig->dwThreshold )
    {
        if( lpClientConfig->dwThreshold == DVTHRESHOLD_DEFAULT )
        {
            m_dvClientConfig.dwThreshold = s_dwDefaultSensitivity;
        }
        else
        {
            m_dvClientConfig.dwThreshold = lpClientConfig->dwThreshold;
        }
    }

#if DBG
    // If the settings have changed
    if( (m_dvClientConfig.dwFlags & DVCLIENTCONFIG_RECORDMUTE) !=
       (lpClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE) )
    {
        if( lpClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE )
        {
            DPVF( DPVF_INFOLEVEL, "Record Muted: Yielding focus" );
        }
        else
        {
            DPVF( DPVF_INFOLEVEL, "Record Un-Muted: Attempting to reclaim focus" );          
        }
    }
#endif

    //
    // if we were half duplex, and now theya re setting us to full duplex
    // we need to init the record subsystem
    //

    if((m_dvClientConfig.dwFlags & DVCLIENTCONFIG_HALFDUPLEX ) &&
       !(lpClientConfig->dwFlags & DVCLIENTCONFIG_HALFDUPLEX) )
    {

        //
        // remove half duplex flag
        //

        m_dvClientConfig.dwFlags &= ~DVCLIENTCONFIG_HALFDUPLEX;

        hr = InitializeSoundSystem();
        if (FAILED(hr)) {

            //
            // we failed, back to half duplex
            //

            m_dvClientConfig.dwFlags |= DVCLIENTCONFIG_HALFDUPLEX;

            DPVF_EXIT();
            return hr;

        }

    }

    m_dvClientConfig.dwFlags = lpClientConfig->dwFlags;
    
    DPVF(  DPVF_ENTRYLEVEL, "Returning DV_OK" );

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckForAndRemoveTarget"
//
// CheckForAndRemoveTarget
//
// Checks the current target list for the specified ID and removes it from
// the target list if it is in the target list.
//
HRESULT CDirectVoiceClientEngine::CheckForAndRemoveTarget( DVID dvidID )
{
    HRESULT hr = DV_OK;
    
    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    //
    // Search the list of targets
    //

    for( DWORD dwIndex = 0; dwIndex < m_dwNumTargets; dwIndex++ )
    {
        if( m_pdvidTargets[dwIndex] == dvidID )
        {
            if( m_dwNumTargets == 1 )
            {
                hr = InternalSetTransmitTarget( NULL, 0 );
            }
            // We'll re-use the current target array
            else
            {
                // Collapse the list by either ommiting the last element (if the
                // one we want to remove is last, or by moving last element into
                // the place in the list we're removing.
                if( dwIndex+1 != m_dwNumTargets )
                {
                    m_pdvidTargets[dwIndex] = m_pdvidTargets[m_dwNumTargets-1];
                }
                
                hr = InternalSetTransmitTarget( m_pdvidTargets, m_dwNumTargets-1 );
            }
            
            break;
        }
    }

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InternalSetTransmitTarget"
//
// InternalSetTransmitTarget
//
// Does the work of setting the target.  (Assumes values have been validated).
//
// This function is safe to pass a pointer to the current target array.  It works
// on a temporary.
// 
//
HRESULT CDirectVoiceClientEngine::InternalSetTransmitTarget( PDVID pdvidTargets, DWORD dwNumTargets )
{
    DWORD dwRequiredSize;
    PBYTE pbDataBuffer;
    PDVMSG_SETTARGETS pdvSetTarget;
    

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);
    // No targets? set list to NULL
    if( dwNumTargets == 0 )
    {
        // Close memory leak
        //
        // Hawk Bug #
        //
        if( m_pdvidTargets != NULL )
        {
            DV_POOL_FREE (m_pdvidTargets);
        }

        m_pdvidTargets = NULL;      
    }
    // Otherwise allocate new list and copy
    else
    {
        PDVID pTmpTargetList;
        
        pTmpTargetList = (DVID *) DV_POOL_ALLOC(sizeof(DVID)*dwNumTargets);

        if( pTmpTargetList == NULL )
        {
            DV_POOL_FREE (m_pdvidTargets);
            m_dwNumTargets = 0;
            DPVF( DPVF_ERRORLEVEL, "Memory alloc failure" );
            DPVF_EXIT();
            return DVERR_OUTOFMEMORY;
        }

        memcpy( pTmpTargetList, pdvidTargets, dwNumTargets*sizeof(DVID) );

        // Kill off old target list
        if( m_pdvidTargets != NULL )
            DV_POOL_FREE(m_pdvidTargets);   

        m_pdvidTargets = pTmpTargetList;
    }

    m_dwNumTargets = dwNumTargets;
    m_dwTargetVersion++;

    dwRequiredSize  = m_dwNumTargets * sizeof( DVID );
    dwRequiredSize += sizeof( DVMSG_SETTARGETS );

    pbDataBuffer = (PUCHAR)DV_POOL_ALLOC(dwRequiredSize);

    if( pbDataBuffer == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Error allocating memory!" );
        DPVF_EXIT();
        return TRUE;
    }

    pdvSetTarget = (PDVMSG_SETTARGETS) pbDataBuffer;

    pdvSetTarget->pdvidTargets = (PDVID) (pbDataBuffer+sizeof(DVMSG_SETTARGETS));
    pdvSetTarget->dwNumTargets = m_dwNumTargets;
    pdvSetTarget->dwSize = sizeof( DVMSG_SETTARGETS );

    memcpy( pdvSetTarget->pdvidTargets, m_pdvidTargets, sizeof(DVID)*m_dwNumTargets );

    NotifyQueue_Add(  DVMSGID_SETTARGETS, pdvSetTarget, dwRequiredSize );   

    DV_POOL_FREE(pbDataBuffer);

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetTransmitTarget"
//
// SetTransmitTarget
//
// Sets the current transmit target.
//
// Called by:
// - DVC_SetTransmitTarget
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceClientEngine::SetTransmitTarget( PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags )
{
    HRESULT hr;
    DWORD dwIndex;  
    
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Begin" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "Params: pdvidTargets = 0x%p dwNumTargets = %d dwFlags = 0x%x", pdvidTargets, dwNumTargets, dwFlags );

#ifndef ASSUME_VALID_PARAMETERS
    if( dwFlags != 0 )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid flags" );
        DPVF_EXIT();
        return DVERR_INVALIDFLAGS;
    }

    // Check that the target list is valid
    hr = DV_ValidTargetList( pdvidTargets, dwNumTargets );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Target list is not valid" );
        DPVF_EXIT();
        return hr;
    }

#endif

    hr = CheckConnected();
    if(FAILED(hr))
    {

        if(m_dwCurrentState != DVCSTATE_CONNECTING) {
           DPVF( DPVF_ERRORLEVEL, "Not connected" );
           DPVF_EXIT();
           return hr;
        }

    } 
    else
    {

        if( m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET )
        {
            DPVF( DPVF_ERRORLEVEL, "Denied.  Server controlled target" );
            DPVF_EXIT();
            return DVERR_NOTALLOWED;
        }

        if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
        {

            // Loop through target list, confirm they are valid entries
            for( dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
            {
                if( !m_voiceNameTable.IsEntry(pdvidTargets[dwIndex]) )
                {

                    if( !m_lpSessionTransport->ConfirmValidGroup( pdvidTargets[dwIndex] ) )
                    {
                        DPVF( DPVF_ERRORLEVEL, "Invalid target" );
                        return DVERR_INVALIDTARGET;
                    }
                    
                } 
            }

        }

    }

    hr = InternalSetTransmitTarget( pdvidTargets, dwNumTargets );

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetTransmitTarget"
//
// GetTransmitTarget
//
// Retrieves the current transmission target.  
//
// Called By:
// - DVC_GetTransmitTarget
//
// Locks Required: 
// - Read Lock Required
//
HRESULT CDirectVoiceClientEngine::GetTransmitTarget( LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags )
{
    HRESULT hr = DV_OK;
    
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Begin" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "Params: lpdvidTargets = 0x%p pdwNumElements = 0x%x dwFlags = 0x%x", lpdvidTargets, pdwNumElements, dwFlags );
#ifndef ASSUME_VALID_PARAMETERS
    if( pdwNumElements == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid pointer to num of elements" );
        DPVF_EXIT();
        return DVERR_INVALIDPOINTER;
    }

    if(pdwNumElements != NULL && 
       *pdwNumElements > 0)
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid target list buffer specified" );
        DPVF_EXIT();
        return DVERR_INVALIDPOINTER;
    }

    if( pdwNumElements == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Must specify a ptr for # of elements" );
        DPVF_EXIT();
        return DVERR_INVALIDPARAM;
    }
    
    if( dwFlags != 0 )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid flags" );
        return DVERR_INVALIDFLAGS;
    }
#endif

    hr = CheckConnected();
    if(FAILED(hr))
    {

        DPVF( DPVF_ERRORLEVEL, "error hr = %x",hr );
        DPVF_EXIT();
        return hr;
    }

    if( *pdwNumElements < m_dwNumTargets )
    {
        hr = DVERR_BUFFERTOOSMALL;
    }
    else
    {
        memcpy( lpdvidTargets, m_pdvidTargets,m_dwNumTargets*sizeof(DVID) );
    }
    
    *pdwNumElements = m_dwNumTargets;

    DPVF(  DPVF_ENTRYLEVEL, "Success" );

    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::FindSoundTarget"
//
// FindSoundTarget
//
// Look for sound target buffer for the specified user.
//
// If it exists, return it in lpcsTarget
//
// Called By:
// - CreateUserBuffer
//
// called at dpc
//
HRESULT CDirectVoiceClientEngine::FindSoundTarget( DVID dvidID, CSoundTarget **lpcsTarget, CVoicePlayer **ppPlayer)
{
    HRESULT hr;
    CVoicePlayer *p;
    
    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    hr = m_voiceNameTable.GetEntry( dvidID, ppPlayer, TRUE );

    p = *ppPlayer;

    if (FAILED(hr)) {

        ASSERT(*ppPlayer == NULL);
        DPVF_EXIT();
        return DVERR_INVALIDPLAYER;
    }

    //
    // we found the remote player, see if they have a SoundTarget
    //

    p->GetSoundTarget(lpcsTarget);

    if (*lpcsTarget!=NULL) {
        DPVF_EXIT();
        return DV_OK;
    }

    DPVF_EXIT();
    return DVERR_GENERIC;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CreateSoundTarget"
//
// Create3DSoundBuffer
//
// Creates a mixing buffer (a sound target) for the specified user ID.
//
// Called By:
// - DVC_CreateUserBuffer
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceClientEngine::CreateSoundTarget( DVID dvidID, PWAVEFORMATEX *ppwfx, XMediaObject **ppMediaObject)
{
    HRESULT hr;     
    LONG lResult;
    CSoundTarget *lpstTarget = NULL;
    CVoicePlayer *pPlayer;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Begin" );
    DPVF( DPVF_APIPARAM, "Params: dvidID = 0x%x", dvidID);

    ASSERT(ppMediaObject);

#ifndef ASSUME_VALID_PARAMETERS

    if( dvidID == m_dvidLocal )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot create buffer for local player!" );
        DPVF_EXIT();
        return DVERR_INVALIDPLAYER;
    }

#endif

    if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not initialized" );
        return DVERR_NOTINITIALIZED;
    }
    else if( m_dwCurrentState != DVCSTATE_CONNECTED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not connected" );
        return DVERR_NOTCONNECTED;
    }

    if( dvidID != DVID_ALLPLAYERS && 
        dvidID != DVID_REMAINING && 
        !m_voiceNameTable.IsEntry(dvidID)   )
    {
        if( !m_lpSessionTransport->ConfirmValidGroup( dvidID ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Invalid player/group ID" );
            
            return DVERR_INVALIDPLAYER;
        }

    }    

    if( dvidID == DVID_REMAINING )
    {
        //
        // dont support this mode.
        // if they want to mix in data
        // they can open the hawk or MCPX output device
        // and create a sound buffer on it
        //
        DPVF_EXIT();
        return DVERR_NOTSUPPORTED;
    }

    // Check for existing buffer.. if it already exists return it
    // (Note: Adds a reference to the player)
    hr = FindSoundTarget( dvidID, &lpstTarget, &pPlayer );

    if( hr == DV_OK )
    {
        pPlayer->Release();

        DPVF( DPVF_ERRORLEVEL, "CreateUserBuffer: Find of buffer failed. hr=0x%x", hr );
        DPVF_EXIT();
        return DVERR_ALREADYBUFFERED;

    } else if (hr == DVERR_INVALIDPLAYER) {
        return hr;
    }

    DPVF( DPVF_INFOLEVEL, "Creating buffer using user buffer" );

    hr = pPlayer->CreateSoundTarget(&lpstTarget);

    if (FAILED(hr)) {

        pPlayer->Release();

        DPVF( DPVF_ERRORLEVEL, "CreateUserBuffer: Failed allocating sound target" );
        return hr;
    }

    lpstTarget->AddRef();
    *ppMediaObject = (XMediaObject *) lpstTarget;

    //
    // tell them the format to expect audio data in
    //

    if (ppwfx) {

        *ppwfx = s_lpwfxPrimaryFormat;

    }

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DeleteSoundTarget"
//
// Delete3DSoundBuffer
//
// Removes the specified ID from the mixer buffer list.  Further speech from
// the specified player will be played in the remaining buffer.
//
// Called By:
// - DVC_DeleteUserBuffer
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceClientEngine::DeleteSoundTarget( DVID dvidID, XMediaObject **ppMediaObject )
{
    HRESULT hr; 
    DWORD dwMode;
    LONG lResult;
    CSoundTarget *lpstTarget;
    CVoicePlayer *pPlayer;    

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "Begin" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "Params: dvidID = 0x%x ppMediaObj = 0x%p", dvidID, ppMediaObject );
    
#ifndef ASSUME_VALID_PARAMETERS
    if( ppMediaObject == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
        return E_POINTER;
    }
    
#endif

    if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not initialized" );
        return DVERR_NOTINITIALIZED;
    }   
    else if( m_dwCurrentState != DVCSTATE_CONNECTED &&
             m_dwCurrentState != DVCSTATE_DISCONNECTING )
    {
        DPVF( DPVF_ERRORLEVEL, "Not connected" );
        return DVERR_NOTCONNECTED;
    }

    // Handle request to disable 3D on the main buffer
    if( dvidID == DVID_REMAINING )
    {
        DPVF_EXIT();
        return DVERR_NOTSUPPORTED;
    }   

    hr = FindSoundTarget( dvidID, &lpstTarget, &pPlayer );

    if( FAILED( hr ) )
    {

        if(hr != DVERR_INVALIDPLAYER)
        {
            pPlayer->Release();
            DPVF( DPVF_ERRORLEVEL, "Unable to retrieve sound target" );
            DPVF_EXIT();
            return DVERR_NOTBUFFERED;
        }

        DPVF( DPVF_ERRORLEVEL, "find of player failed. hr=0x%x", hr );
        DPVF_EXIT();
        return hr;
    }

    pPlayer->GetSoundTarget(&lpstTarget) ;
    if( lpstTarget != *ppMediaObject )
    {
        DPVF( DPVF_ERRORLEVEL, "Buffer passed in does not belong to specified id" );     
        pPlayer->Release();
        return DVERR_INVALIDPARAM;
    }

    DPVF( DPVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] DESTROY3DBUFFER ", dvidID );

    // Get rid of the initial reference CreateSoundTarget added
    lResult = lpstTarget->Release();

    // remove from player context
    pPlayer->DeleteSoundTarget();
    pPlayer->Release();

    *ppMediaObject = NULL;

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    DPVF_EXIT();
    return DV_OK;
    
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// DIRECTPLAY/NET --> DirectXVoiceClient Interface
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ReceiveSpeechMessage"
// ReceiveSpeechMessage
//
// Called by DirectPlay/DirectNet when a DirectXVoice message is received
//
// Called By:
// - DV_ReceiveSpeechMessage
//
// Locks Required:
// - None
//
BOOL CDirectVoiceClientEngine::ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize )
{
    BOOL fResult;
    PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage;

    DPVF_ENTER();
    ASSERT( lpMessage );
    ASSERT( dwSize > 0 );

    lpdvFullMessage = (PDVPROTOCOLMSG_FULLMESSAGE) lpMessage;

    switch( lpdvFullMessage->dvGeneric.dwType )
    {
    case DVMSGID_HOSTMIGRATELEAVE:
        fResult = HandleHostMigrateLeave( dvidSource, static_cast<PDVPROTOCOLMSG_HOSTMIGRATELEAVE>(lpMessage), dwSize );
        break;
    case DVMSGID_HOSTMIGRATED:
        fResult = HandleHostMigrated( dvidSource, static_cast<PDVPROTOCOLMSG_HOSTMIGRATED>(lpMessage),dwSize );
        break;
    case DVMSGID_CONNECTREFUSE:
        fResult = HandleConnectRefuse( dvidSource, static_cast<PDVPROTOCOLMSG_CONNECTREFUSE>(lpMessage), dwSize );
        break;
    case DVMSGID_CONNECTACCEPT:
        fResult = HandleConnectAccept( dvidSource, static_cast<PDVPROTOCOLMSG_CONNECTACCEPT>(lpMessage), dwSize );
        break;
    case DVMSGID_CREATEVOICEPLAYER:
        fResult = HandleCreateVoicePlayer( dvidSource, static_cast<PDVPROTOCOLMSG_PLAYERJOIN>(lpMessage), dwSize );
        break;
    case DVMSGID_DELETEVOICEPLAYER:
        fResult = HandleDeleteVoicePlayer( dvidSource, static_cast<PDVPROTOCOLMSG_PLAYERQUIT>(lpMessage), dwSize );
        break;
    case DVMSGID_SPEECH:
        fResult = HandleSpeech( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHHEADER>(lpMessage), dwSize );
        break;
    case DVMSGID_SPEECHBOUNCE:
        fResult = HandleSpeechBounce( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHHEADER>(lpMessage), dwSize );
        break;
    case DVMSGID_SPEECHWITHFROM:
        fResult = HandleSpeechWithFrom( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHWITHFROM>(lpMessage), dwSize );
        break;
    case DVMSGID_DISCONNECTCONFIRM:
        fResult = HandleDisconnectConfirm( dvidSource, static_cast<PDVPROTOCOLMSG_DISCONNECT>(lpMessage), dwSize);
        break;
    case DVMSGID_SETTARGETS:
        fResult = HandleSetTarget( dvidSource, static_cast<PDVPROTOCOLMSG_SETTARGET>(lpMessage), dwSize );
        break;
    case DVMSGID_SESSIONLOST:
        fResult = HandleSessionLost( dvidSource, static_cast<PDVPROTOCOLMSG_SESSIONLOST>(lpMessage), dwSize );
        break;
    case DVMSGID_PLAYERLIST:
        fResult = HandlePlayerList( dvidSource, static_cast<PDVPROTOCOLMSG_PLAYERLIST>(lpMessage), dwSize );
        break;
    default:
        DPVF(  DPVF_WARNINGLEVEL, "DVCE::ReceiveSpeechMessage() Ignoring non-speech message id=0x%x from=0x%x", 
             lpdvFullMessage->dvGeneric.dwType, dvidSource );
        DPVF_EXIT();
        return FALSE;
    }

    DPVF_EXIT();
    return fResult;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSetTarget"
// HandleSetTarget
//
// Handles server settarget messages.  Sets the local target.
//
BOOL CDirectVoiceClientEngine::HandleSetTarget( DVID dvidSource, PDVPROTOCOLMSG_SETTARGET lpdvSetTarget, DWORD dwSize )
{
    HRESULT hr;

    DPVF_ENTER();
    hr = InternalSetTransmitTarget( (DWORD *) &lpdvSetTarget[1], lpdvSetTarget->dwNumTargets );

    ASSERT( hr == DV_OK );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleHostMigrateLeave"
BOOL CDirectVoiceClientEngine::HandleHostMigrateLeave( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATELEAVE lpdvHostMigrateLeave, DWORD dwSize )
{
    // Call RemovePlayer with the ID of the person who sent this, 
    // which should be the host.
    
    DPVF_ENTER();
    DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Triggered by DVMSGID_HOSTMIGRATELEAVE" );
    MigrateHost_RunElection();

    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleHostMigrated"
BOOL CDirectVoiceClientEngine::HandleHostMigrated( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATED lpdvHostMigrated, DWORD dwSize )
{
    HRESULT hr;    

    // We're not yet connected, so we can't send our settings to the server yet.
    // However, because of the write lock we know that when the connection
    // completes we'll have the right host.  (Transparently to the client).
    //

    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);
    hr = CheckConnected();
    if( FAILED(hr))
    {
        DPVF( DPVF_WARNINGLEVEL, "Could not respond to new host yet, not yet initialized" );
        DPVF_EXIT();
        return TRUE;
    }

    if( dvidSource != m_dvidServer )
    {
        DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Ignoring host migration from 0x%x -- 0x%x is server", dvidSource, m_dvidServer );
        DPVF_EXIT();
        return TRUE;
    }

    DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Player 0x%x received host migrated message!", m_dvidLocal );
    DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Sending player confirm message" );
    DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: According to message Player 0x%x is new host", dvidSource );

    hr = Send_SettingsConfirm();

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Internal send failed hr=0x%x", hr );
    }
    else
    {
        hr=DV_OK;
    }

    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleConnectRefuse"
// HandleConnectRefuse
//
// Handles connection refusals
//
BOOL CDirectVoiceClientEngine::HandleConnectRefuse( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREFUSE lpdvConnectRefuse, DWORD dwSize )
{   
    
    ASSERT( dwSize == sizeof( DVPROTOCOLMSG_CONNECTREFUSE ) );

    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);
    m_hrConnectResult = lpdvConnectRefuse->hresResult;
    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoConnectResponse"
void CDirectVoiceClientEngine::DoConnectResponse()
{
    HANDLE hThread;
    HRESULT hr;
    

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    if( m_dwCurrentState != DVCSTATE_CONNECTING )
    {
        DPVF( DPVF_WARNINGLEVEL, "Aborting Connection & server response arrived" );
        DPVF_EXIT();
        return;
    }

    // Handle sound initialization
    m_hrConnectResult = InitializeSoundSystem();

    if( m_hrConnectResult != DV_OK )
    {
        DPVF( DPVF_ERRORLEVEL, "Sound Initialization Failed hr=0x%x", m_hrConnectResult );
        goto EXIT_ERROR;
    }

    m_hrConnectResult = SetupSpeechBuffer();

    if( FAILED( m_hrConnectResult ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Could not init speech buffers hr=0x%x", m_hrConnectResult );
        goto EXIT_ERROR;
    }

    DPVF(  DPVF_INFOLEVEL, "DVCE::HandleConnectAccept() - Sound Initialized" );

    // We need to make player available in client/server because there will be no indication
    if( m_dvSessionDesc.dwSessionType != DVSESSIONTYPE_PEER )
    {
        m_fLocalPlayerAvailable = TRUE;
    }

    SetCurrentState( DVCSTATE_CONNECTED );

    DPVF(  DPVF_ENTRYLEVEL, "DVCE::HandleConnectAccept() Success" );

    SendConnectResult();    

    hr = Send_SettingsConfirm();

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed to send connect confirmation hr=0x%x", hr );
        DPVF( DPVF_ERRORLEVEL, "Other threads will cleanup because connection must be gone" );
    }

    DPVF_EXIT();
    return;

EXIT_ERROR:

    DPVF( DPVF_ERRORLEVEL, "Initialize Failed hr=0x%x", m_hrConnectResult );
    DV_DUMP_GUID( m_dvSessionDesc.guidCT );

    SendConnectResult();
    
    Cleanup();
    
    DPVF_EXIT();
    return;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleConnectAccept"
// HandleConnectAccepts
//
// Handles connect accepts.  Sets connected flag, finishes initialization, informs the 
// connect function to proceed (if it's waiting).
//
BOOL CDirectVoiceClientEngine::HandleConnectAccept( DVID dvidSource, PDVPROTOCOLMSG_CONNECTACCEPT lpdvConnectAccept, DWORD dwSize )
{
    char tmpString[100];
    
    DVPROTOCOLMSG_FULLMESSAGE dvMessage;
    WAVEFORMATEX wfx;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    ASSERT( dwSize >= sizeof( DVPROTOCOLMSG_CONNECTACCEPT ) );

    DPVF(  DPVF_ENTRYLEVEL, "DVCE::HandleConnectAccept() Entry" );


    // We're already connected, server is responding to the earlier request
    if( m_dwCurrentState != DVCSTATE_CONNECTING )
    {
        DPVF_EXIT();
        return TRUE;
    }

    // Inform transport layer who the server is. (So it no longer thinks it's DPID_ALL).
    m_lpSessionTransport->MigrateHost( dvidSource );
    m_dvidServer = m_lpSessionTransport->GetServerID();
    
    m_hrConnectResult = DV_OK;

    DPVF(  DPVF_INFOLEVEL, "Connect Accept Received" );

    m_dvSessionDesc.dwSize = sizeof( DVSESSIONDESC );
    m_dvSessionDesc.dwBufferAggressiveness = 0;
    m_dvSessionDesc.dwBufferQuality = 0;
    m_dvSessionDesc.dwFlags = lpdvConnectAccept->dwSessionFlags;
    m_dvSessionDesc.guidCT = lpdvConnectAccept->guidCT;
    m_dvSessionDesc.dwSessionType = lpdvConnectAccept->dwSessionType;

    //
    // initialize decompressor
    //

    //
    // create an inbound converter. We will later give it to the first voice player we see
    // we need it now to get compression parameters
    //

    memcpy(&wfx, s_lpwfxPrimaryFormat,sizeof(wfx));
    m_hrConnectResult = DV_CreateConverter(m_dvSessionDesc.guidCT,
                            &m_pInBoundAudioConverter,
                            &wfx,
                            NULL,
                            0,
                            FALSE);

    //
    // extract info from converter
    //

    BuildCompressionInfo();

    if( FAILED(m_hrConnectResult ) )
    {

        DPVF( DPVF_ERRORLEVEL, "Invalid Compression Type" );

        SendConnectResult();
        Cleanup();                  

    }
    else
    {
        DoConnectResponse();
    }

    DPVF_EXIT();
    return TRUE;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandlePlayerList"
BOOL CDirectVoiceClientEngine::HandlePlayerList( DVID dvidSource, PDVPROTOCOLMSG_PLAYERLIST lpdvPlayerList, DWORD dwSize )
{
    DVPROTOCOLMSG_PLAYERJOIN dvMsgPlayerJoin;       // Used to fake out HandleCreateVoicePlayer
    DWORD dwIndex;
    DVPROTOCOLMSG_PLAYERLIST_ENTRY *pdvPlayerList = (DVPROTOCOLMSG_PLAYERLIST_ENTRY *) &lpdvPlayerList[1];
    

    DPVF_ENTER();
    // Check the size
    ASSERT( ((dwSize - sizeof( DVPROTOCOLMSG_PLAYERLIST )) % sizeof( DVPROTOCOLMSG_PLAYERLIST_ENTRY )) == 0 );

    DV_AUTO_LOCK(&m_CS);

    // Get our host order ID
    m_dwHostOrderID = lpdvPlayerList->dwHostOrderID;

    DPVF( DPVF_INFOLEVEL, "Received player list.  Unpacking %d entries", lpdvPlayerList->dwNumEntries );

    for( dwIndex = 0; dwIndex < lpdvPlayerList->dwNumEntries; dwIndex++ )
    {
        dvMsgPlayerJoin.dwType = DVMSGID_CREATEVOICEPLAYER;
        dvMsgPlayerJoin.dvidID =  pdvPlayerList[dwIndex].dvidID;
        dvMsgPlayerJoin.dwFlags = pdvPlayerList[dwIndex].dwPlayerFlags;
        dvMsgPlayerJoin.dwHostOrderID = pdvPlayerList[dwIndex].dwHostOrderID;

        if( !HandleCreateVoicePlayer( dvidSource, &dvMsgPlayerJoin, sizeof( DVPROTOCOLMSG_PLAYERJOIN ) ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Handle voice player failed during unpack" );
            
            DPVF_EXIT();
            return FALSE;
        }
    }

    DPVF_EXIT();
    return TRUE;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyComplete_RemotePlayer"
//
// NotifyComplete_RemotePlayer
//
// This is a completion function for when notification of a new remote player has been processed
//
void CDirectVoiceClientEngine::NotifyComplete_RemotePlayer( PVOID pvContext, CNotifyElement *pElement )
{
    CVoicePlayer *pPlayer = (CVoicePlayer *) pvContext;
    PDVMSG_CREATEVOICEPLAYER pCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) pElement->m_element.Data;

    ASSERT( pPlayer != NULL );
    ASSERT( pCreatePlayer->dwSize = sizeof( DVMSG_CREATEVOICEPLAYER ) );

    pPlayer->SetContext( pCreatePlayer->pvPlayerContext );
    pPlayer->SetAvailable( TRUE );
    
    pPlayer->Release();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyComplete_DeletePlayer"
//
// NotifyComplete_RemotePlayer
//
// This is a completion function for when notification of a new remote player has been processed
//
void CDirectVoiceClientEngine::NotifyComplete_DeletePlayer( PVOID pvContext, CNotifyElement *pElement )
{
    CVoicePlayer *pPlayer = (CVoicePlayer *) pvContext;
    PDVMSG_DELETEVOICEPLAYER pDeletePlayer = (PDVMSG_DELETEVOICEPLAYER) pElement->m_element.Data;

    ASSERT( pPlayer != NULL );
    ASSERT( pDeletePlayer->dwSize = sizeof( DVMSG_DELETEVOICEPLAYER ) );

    pPlayer->SetContext( pDeletePlayer->pvPlayerContext );
    pPlayer->SetAvailable( TRUE );
    
    pPlayer->Release();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyComplete_LocalPlayer"
//
// NotifyComplete_LocalPlayer
//
// This is a completion function for when notification of the local player has been processed
//
void CDirectVoiceClientEngine::NotifyComplete_LocalPlayer( PVOID pvContext, CNotifyElement *pElement )
{
    CDirectVoiceClientEngine *pvEngine = (CDirectVoiceClientEngine *) pvContext;
    PDVMSG_CREATEVOICEPLAYER pCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) pElement->m_element.Data;

    ASSERT( pCreatePlayer->dwSize = sizeof( DVMSG_CREATEVOICEPLAYER ) );

    pvEngine->m_pvLocalPlayerContext = pCreatePlayer->pvPlayerContext;
    pvEngine->m_fLocalPlayerAvailable = TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleCreateVoicePlayer"
//
// HandleCreateVoicePlayer
//
// Performs initialization required to create the specified user's record.
//
// 
// When a player is added they are added to the nametable as well as the
// pending lists for notify thread and playback thread.
//
// Both of these threads wakeup and:
// - Add any players on the "add list"
// - Remove any players who are marked disconnecting
//
BOOL CDirectVoiceClientEngine::HandleCreateVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERJOIN lpdvCreatePlayer, DWORD dwSize )
{
    CVoicePlayer *pNewPlayer;
    HRESULT hr;
    
    QUEUE_PARAMS queueParams;
    WAVEFORMATEX wfx;

    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);

    ASSERT( dwSize == sizeof( DVPROTOCOLMSG_PLAYERJOIN ) );

    hr = CheckConnected();
    if( FAILED(hr))
    {
        DPVF_EXIT();
        return TRUE;
    }


    hr = m_voiceNameTable.GetEntry( lpdvCreatePlayer->dvidID, &pNewPlayer, TRUE );

    // Ignore duplicate players
    if( hr == DV_OK )
    {
        pNewPlayer->Release();

        DPVF_EXIT();
        return TRUE;
    }

    DPVF( DPVF_INFOLEVEL, "Received Create for player ID 0x%x",lpdvCreatePlayer->dvidID );

    // Do not create a queue or a player entry for ourselves
    // Not needed
    if( lpdvCreatePlayer->dvidID != m_lpSessionTransport->GetLocalID() )
    {
        PLIST_ENTRY pEntry;           
        
        pEntry = RemoveTailList(&m_PlayerContextPool);
        pNewPlayer = (CVoicePlayer *) CONTAINING_RECORD(pEntry, CVoicePlayer, m_PoolEntry);        

        DPVF( DPVF_INFOLEVEL, "Creating player record %x",pNewPlayer );

        ASSERT(pNewPlayer);

        hr = pNewPlayer->Initialize(lpdvCreatePlayer->dvidID,
                                    lpdvCreatePlayer->dwHostOrderID,
                                    m_dvClientConfig.dwPort,
                                    lpdvCreatePlayer->dwFlags,
                                    NULL,
                                    &m_PlayerContextPool);


        if( FAILED( hr ) )
        {
            pNewPlayer->Release();
            DPVF( DPVF_ERRORLEVEL, "Unable to initialize player record hr=0x%x", hr );
            DPVF_EXIT();

            return TRUE;
        }
    
        //
        // create our queue
        //
    
        queueParams.wFrameSize = (USHORT)s_dwCompressedFrameSize;
        queueParams.bInnerQueueSize = DV_CT_INNER_QUEUE_SIZE;
        queueParams.wQueueId = lpdvCreatePlayer->dvidID;
        queueParams.wMSPerFrame = (WORD) (1000 * (WORD)s_dwCompressedFrameSize) / 
            ((WORD)s_lpwfxPrimaryFormat->nSamplesPerSec * 2);

        queueParams.pFramePool = m_pFramePool;

        hr = pNewPlayer->CreateQueue( &queueParams );

        if( FAILED( hr ) )
        {
            pNewPlayer->Release();
            DPVF( DPVF_ERRORLEVEL, "Unable to create queue for player hr=0x%x", hr );
            DPVF_EXIT();

            return TRUE;
        }
    
        //
        // create converter(decode) for playback data
        // its ok to pass null for pInBoundConverter. See below
        //

        memcpy(&wfx, s_lpwfxPrimaryFormat, sizeof(wfx));

        hr = pNewPlayer->CreateMediaObjects(
                     m_dvSessionDesc.guidCT,
                     &wfx,
                     s_dwUnCompressedFrameSize,
                     m_pInBoundAudioConverter,
                     (m_RecordSubSystem ? FALSE : TRUE)); //check half duplex mode, output to mcpx
        
        if ( m_pInBoundAudioConverter) {

            //
            // for the first player, we pass on the converter we created upon ConnectAccept
            // we did then to get compression info cached.
            // all players after the first will get a new converter (but same compression info..)
            //

            m_pInBoundAudioConverter = NULL;

        } 
                    
        
        if( FAILED( hr ) )
        {
            pNewPlayer->Release();
            DPVF( DPVF_ERRORLEVEL, "Unable to get create converter for player hr=0x%x", hr );
            DPVF_EXIT();

            return TRUE;
        }

        hr = m_voiceNameTable.AddEntry( lpdvCreatePlayer->dvidID, pNewPlayer );

        if( FAILED( hr ) )
        {
            // Main ref
            pNewPlayer->Release();

            DPVF( DPVF_ERRORLEVEL, "Unable to add entry to nametable hr=0x%x", hr );
            DPVF_EXIT();
            return TRUE;
        }

        if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
        {
            pNewPlayer->SetAvailable(TRUE);
        }

        // Add a reference for the player to the "Playback Add List"
        
        pNewPlayer->AddRef();
        pNewPlayer->AddToPlayList( &m_PlayAddPlayersList);

        // Add a reference for the player to the "Notify Add List"
        pNewPlayer->AddRef();
        pNewPlayer->AddToNotifyList( &m_NotifyAddPlayersList );        

        // This will now be released by the callback, unless this is multicast
        //
        // Release our personal reference
        if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
        {
            pNewPlayer->Release();
        }
    }
    else
    {
        DPVF( DPVF_SPAMLEVEL, "Local player, no player record required" );
    }

#ifdef DVC_ENABLE_PEER_SESSION
    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
    {
        DVMSG_CREATEVOICEPLAYER dvCreatePlayer;     
        dvCreatePlayer.dvidPlayer = lpdvCreatePlayer->dvidID;
        dvCreatePlayer.dwFlags = lpdvCreatePlayer->dwFlags; 
        dvCreatePlayer.dwSize = sizeof( DVMSG_CREATEVOICEPLAYER );
        dvCreatePlayer.pvPlayerContext = NULL;

        DPVF( DPVF_INFOLEVEL, "Queue Local player notification" );

        // Prevents double notification for local player
        if( lpdvCreatePlayer->dvidID != m_lpSessionTransport->GetLocalID() )
        {
            NotifyQueue_Add( DVMSGID_CREATEVOICEPLAYER, &dvCreatePlayer, sizeof( DVMSG_CREATEVOICEPLAYER ), 
                            pNewPlayer, NotifyComplete_RemotePlayer );
        } 
        else if( !m_fLocalPlayerNotify )
        {
            // Add local player flag to notification
            dvCreatePlayer.dwFlags |= DVPLAYERCAPS_LOCAL;

            // Notify of local player (don't create player record)
            NotifyQueue_Add( DVMSGID_CREATEVOICEPLAYER, &dvCreatePlayer, sizeof( DVMSG_CREATEVOICEPLAYER ), 
                            this, NotifyComplete_LocalPlayer );
            m_fLocalPlayerNotify = TRUE;
        } 
    }
#endif

    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::MigrateHost_RunElection"
//
// MigrateHost_RunElection
//
// Runs the host migration algorithm
//
HRESULT CDirectVoiceClientEngine::MigrateHost_RunElection(  )
{
    HRESULT hr;
    DWORD dwHostOrderID = DVPROTOCOL_HOSTORDER_INVALID;
    DVID dvidNewHost;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
    {
        DPVF( DPVF_WARNINGLEVEL, "HOST MIGRATION: We're disconnecting, no need to run algorithm" );
        DPVF_EXIT();
        return TRUE;
    }

    DWORD dwTransportSessionType, dwTransportFlags; 

    hr = m_lpSessionTransport->GetTransportSettings( &dwTransportSessionType, &dwTransportFlags );

    if( FAILED( hr ) )
    {
        ASSERT( FALSE );
        DPVF( DPVF_ERRORLEVEL, "Unable to retrieve transport settings hr=0x%x", hr );
        DPVF_EXIT();
        return DV_OK;
    }
    
    if( (m_dvSessionDesc.dwSessionType != DVSESSIONTYPE_PEER ) || 
        (m_dvSessionDesc.dwFlags & DVSESSION_NOHOSTMIGRATION) || 
        !(dwTransportFlags & DVTRANSPORT_MIGRATEHOST) )
    {
        DPVF( DPVF_WARNINGLEVEL, "HOST MIGRATION: Host migration is disabled." );
        DPVF( DPVF_WARNINGLEVEL, "HOST MIGRATION: Host is gone.  Session will exit soon."  );

        if( m_dwCurrentState == DVCSTATE_CONNECTING )
        {
            DPVF( DPVF_ERRORLEVEL, "Aborting connection..." );
            SendConnectResult();
        }

        DoSessionLost(DVERR_SESSIONLOST);

        DPVF_EXIT();
        return DV_OK;
    }   

    // This shortcut prevents problems if this is called twice.
    if( m_lpdvServerMigrated != NULL )
    {
        DPVF( DPVF_INFOLEVEL, "Skipping calling removeplayer again as host already migrated" );
        DPVF_EXIT();
        return DV_OK;
    }

    DPVF( DPVF_WARNINGLEVEL,"HOST MIGRATION: Player 0x%x is running election algorithm", this->m_dvidLocal );

    // Trust me.  Do this.
    dvidNewHost = m_dvidLocal;
    dwHostOrderID = m_voiceNameTable.GetLowestHostOrderID(&dvidNewHost);

    DPVF( DPVF_WARNINGLEVEL, "HOST MIGRATION: New Host is [0x%x]", dvidNewHost );

    m_lpSessionTransport->MigrateHost( dvidNewHost );
    m_dvidServer = m_lpSessionTransport->GetServerID();     

    DPVF( DPVF_WARNINGLEVEL, "HOST MIGRATION: Host is (2) [0x%x]", m_dvidServer );

    // No one was found and we're not properly connected yet
    if( dwHostOrderID == DVPROTOCOL_HOSTORDER_INVALID && m_dwCurrentState != DVCSTATE_CONNECTED )
    {
        DPVF( DPVF_ERRORLEVEL, "There is no one to take over session.  Disconnect" );

        // We're connecting.. expected behaviour
        if( m_dwCurrentState == DVCSTATE_CONNECTING )
        {
            DPVF( DPVF_ERRORLEVEL, "Aborting connection..." );
            
            SendConnectResult();
            DoSessionLost(DVERR_SESSIONLOST);
        }
        // We're already disconnecting
        else if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
        {
            DPVF( DPVF_ERRORLEVEL, "Already disconnecting.." );
        }
    }
    // Candidate was found, it's us!
    else if( m_dwHostOrderID <= dwHostOrderID )
    {

        HRESULT hr;

        m_lpSessionTransport->MigrateHost( m_dvidLocal );
        m_dvidServer = m_lpSessionTransport->GetServerID();     
        
        DPVF( DPVF_WARNINGLEVEL, "HOST MIGRATION: We think we're the host!  Our Host Order ID=0x%x", m_dwHostOrderID );
        
        hr = HandleLocalHostMigrateCreate();            

        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Host migrate failed hr=0x%x", hr );
        }
    }

    // Someone was elected -- not us!
    //
    // We send a settings confirm message in case we ignored host migration message
    // during our election.  (Small, but reproducable window).
    //
    // If we do get it after this host may get > 1 settings confirm from us (which is handled).
    //
    else if( dwHostOrderID != DVPROTOCOL_HOSTORDER_INVALID )
    {
        hr = Send_SettingsConfirm();

        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Settings confirm message failed! sent hr=0x%x", hr );
        }

        DVMSG_HOSTMIGRATED dvHostMigrated;
        dvHostMigrated.dvidNewHostID = m_dvidServer;
        dvHostMigrated.pdvServerInterface = NULL;
        dvHostMigrated.dwSize = sizeof( DVMSG_HOSTMIGRATED );

        DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Sending notification because of election" );        
        
        NotifyQueue_Add( DVMSGID_HOSTMIGRATED, &dvHostMigrated, sizeof( DVMSG_HOSTMIGRATED )  );    
    }

    DPVF_EXIT();
    return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleDeleteVoicePlayer"
//
// HandleDeleteVoicePlayer
//
// Handles the DVMSGID_DELETEVOICEPLAYER message.
//
BOOL CDirectVoiceClientEngine::HandleDeleteVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERQUIT lpdvDeletePlayer, DWORD dwSize )
{
    CVoicePlayer *pPlayer;
    HRESULT hr;    

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    ASSERT( dwSize == sizeof( DVPROTOCOLMSG_PLAYERQUIT ) );

    hr = m_voiceNameTable.GetEntry( lpdvDeletePlayer->dvidID, &pPlayer, TRUE );

    // If there is a player entry for the given ID, 
    // Handle removing them from the local player table
    if( pPlayer != NULL )
    {

        DPVF( DPVF_WARNINGLEVEL, "Deleting voice players %x, local id %x\n",
             lpdvDeletePlayer->dvidID,
             m_dvidLocal);

        // Remove the entry, this will also drop the reference count
        hr = m_voiceNameTable.DeleteEntry( lpdvDeletePlayer->dvidID );

        if( FAILED( hr ) )
        {
            DPVF( 0, "Error, could not find entry 0x%x to delete hr=0x%x", dvidSource, hr );
        }

        // Mark player record as disconnected
        pPlayer->SetDisconnected();

        CheckForAndRemoveTarget( lpdvDeletePlayer->dvidID );

        // If there are any buffers for this player, delete them
        // We don't need to destroy them, we want to save them so the user can call
        // Delete3DUserBuffer
        //

        if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
        {
#ifdef DVC_ENABLE_PEER_SESSION
            DVMSG_DELETEVOICEPLAYER dvMsgDeletePlayer;
            
            dvMsgDeletePlayer.dvidPlayer = lpdvDeletePlayer->dvidID;
            dvMsgDeletePlayer.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
            dvMsgDeletePlayer.pvPlayerContext = pPlayer->GetContext();

            pPlayer->SetContext( NULL );

            // By making this synchronous we ensure that the voice notification has completed before the dplay8 
            // callback is called. 
            // 
            NotifyQueue_Add( DVMSGID_DELETEVOICEPLAYER, &dvMsgDeletePlayer, sizeof( DVMSG_DELETEVOICEPLAYER ), pPlayer, NotifyComplete_DeletePlayer);
#endif
        } else {

            pPlayer->Release();

        }
        
    } else if (lpdvDeletePlayer->dvidID == m_dvidLocal) {

        //
        // local player notification
        //

        DVMSG_DELETEVOICEPLAYER dvMsgDelete;    
        dvMsgDelete.dvidPlayer = m_dvidLocal;
        dvMsgDelete.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
        dvMsgDelete.pvPlayerContext = m_pvLocalPlayerContext;

        m_pvLocalPlayerContext = NULL;
        m_fLocalPlayerNotify = FALSE;        
        m_fLocalPlayerAvailable = FALSE;

        TransmitMessage( DVMSGID_DELETEVOICEPLAYER, &dvMsgDelete, sizeof( DVMSG_DELETEVOICEPLAYER ) );

    }

    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::QueueSpeech"
//
// QueueSpeech
//
// Process and queue incoming audio
//
BOOL CDirectVoiceClientEngine::QueueSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize )
{
    CVoicePlayer *pPlayerInfo;
    HRESULT hr;

    DPVF_ENTER();
    // Only start receiving voice if the local player is active
    if( !m_fLocalPlayerAvailable )
    {
        DPVF( 1, "Ignoring incoming audio, local player has not been indicated" );
        DPVF_EXIT();
        return TRUE;
    }
    
    hr = m_voiceNameTable.GetEntry( dvidSource, &pPlayerInfo, TRUE );

    if( FAILED( hr ) )
    {
        DPVF( 1, "Received speech for player who is not in nametable hr=0x%x", hr );
        DPVF_EXIT();
        return TRUE;
    }

    if( !pPlayerInfo->IsAvailable() )
    {
        DPVF( 1, "Player is not yet available, ignoring speech" );
    }
    else
    {
        hr = pPlayerInfo->HandleReceive( pdvSpeechHeader, pbData, dwSize );

        if( FAILED( hr ) )
        {
            pPlayerInfo->Release();
            DPVF( 1, "Received speech could not be buffered hr=0x%x", hr );
            DPVF_EXIT();
            return TRUE;
        }

    }

    // Release our reference to the player
    pPlayerInfo->Release();
        
    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSpeechWithFrom"
//
// HandleSpeech
//
// Handles speech data messages
//
BOOL CDirectVoiceClientEngine::HandleSpeechWithFrom( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHFROM lpdvSpeech, DWORD dwSize )
{
    HRESULT hr;
    CVoicePlayer *pPlayerInfo;  

    DPVF_ENTER();
    ASSERT( dwSize >= sizeof( DVPROTOCOLMSG_SPEECHWITHFROM ) );

    DPVF( DPVF_INFOLEVEL, "Received multicast speech!" );

    if( lpdvSpeech->dvidFrom == m_dvidLocal )
    {
        DPVF( DPVF_SPAMLEVEL, "Ignoring loopback speech!" ); 
        DPVF_EXIT();
        return TRUE;
    }

    hr = m_voiceNameTable.GetEntry( lpdvSpeech->dvidFrom, &pPlayerInfo, TRUE );
    
    if( FAILED( hr ) )
    {
        DVPROTOCOLMSG_PLAYERJOIN dvPlayerJoin;
        dvPlayerJoin.dwFlags = 0;
        dvPlayerJoin.dvidID = lpdvSpeech->dvidFrom;
        HandleCreateVoicePlayer( lpdvSpeech->dvidFrom, &dvPlayerJoin, sizeof( DVPROTOCOLMSG_PLAYERJOIN ) );
    }
    else
    {
        pPlayerInfo->Release();
    }

    DPVF_EXIT();
    return QueueSpeech( lpdvSpeech->dvidFrom, &lpdvSpeech->dvHeader, (PBYTE) &lpdvSpeech[1], dwSize-sizeof(DVPROTOCOLMSG_SPEECHWITHFROM) );

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSpeechBounce"
//
// HandleSpeech
//
// Handles speech data messages
//
BOOL CDirectVoiceClientEngine::HandleSpeechBounce( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize )
{
    DPVF_ENTER();
    ASSERT( dwSize >= sizeof( DVPROTOCOLMSG_SPEECHHEADER ) );

    DPVF( DPVF_INFOLEVEL, "Received speech bounce!" );

    DPVF_EXIT();
    return QueueSpeech( dvidSource, lpdvSpeech, (PBYTE) &lpdvSpeech[1], dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSpeech"
//
// HandleSpeech
//
// Handles speech data messages
//
BOOL CDirectVoiceClientEngine::HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize )
{
    ASSERT( dwSize >= sizeof( DVPROTOCOLMSG_SPEECHHEADER ) );

    // Ignore speech from ourselves
    if( dvidSource == m_dvidLocal )
    {
        DPVF( DPVF_SPAMLEVEL, "Ignoring loopback speech!" );     
        DPVF_EXIT();
        return TRUE;
    }

    DPVF( DPVF_INFOLEVEL, "Received bare speech!" );

    DPVF_EXIT();
    return QueueSpeech( dvidSource, lpdvSpeech, (PBYTE) &lpdvSpeech[1], dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Cleanup"
//
// Cleanup
//
// WARNING: Do not call this function multiple times on the same object.
//
// This function shuts down the recording and playback threads, shuts down
// the sound system and unhooks the object from the dplay object.
// 
// Called By:
// - DoDisconnect
// - Destructor 
// - HandleConnectAccept
// - NotifyThread
//
// Locks Required:
// - Global Write Lock
//
void CDirectVoiceClientEngine::Cleanup()
{
   
    DPVF( DPVF_ERRORLEVEL, "Cleanup called!" );    

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    // We only need to cleanup if we're not idle
    if( m_dwCurrentState == DVCSTATE_IDLE )
    {
        DPVF( DPVF_INFOLEVEL, "Cleanup not required" );
        DPVF_EXIT();
        return;
    }
    
    // Disable notifications, no notifications after this point can be made
    NotifyQueue_Disable();  

    // The following code is extremely sensitive.
    //
    // Be careful about the order here, it's important.

    DPVF( DPVF_WARNINGLEVEL, "Waiting for outstanding sends" );  
    // Wait for outstanding buffer sends to complete before
    // continuing.  Otherwise you have potential crash / leak
    // condition
    WaitForBufferReturns();

    DPVF( DPVF_WARNINGLEVEL, "Disconnecting transport" );
    // After this function returns DirectPlay will no longer sends
    // us indication, but some may still be in progress.
    m_lpSessionTransport->DisableReceiveHook( );

    DPVF( DPVF_INFOLEVEL, "Flushing notification queue" );
    // Ensuring that all notifications have been sent 

    NotifyQueue_IndicateNext(); 

    // Waiting for transport to return all the threads it is indicating into us on.
    DPVF( DPVF_WARNINGLEVEL, "Waiting for transport threads to complete" );
    m_lpSessionTransport->WaitForDetachCompletion();

    // Re-enable notifications
    NotifyQueue_Enable();

    CleanupPlaybackLists();
    CleanupNotifyLists();

    // Inform player of their own exit if they were connected!
    if( m_fLocalPlayerNotify )
    {
        DVMSG_DELETEVOICEPLAYER dvMsgDelete;    
        dvMsgDelete.dvidPlayer = m_dvidLocal;
        dvMsgDelete.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
        dvMsgDelete.pvPlayerContext = m_pvLocalPlayerContext;

        m_pvLocalPlayerContext = NULL;
        m_fLocalPlayerNotify = FALSE;        
        m_fLocalPlayerAvailable = FALSE;

        
        TransmitMessage( DVMSGID_DELETEVOICEPLAYER, &dvMsgDelete, sizeof( DVMSG_DELETEVOICEPLAYER ) );
    }    

    m_voiceNameTable.DeInitialize( (m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER), m_lpUserContext, m_lpMessageHandler);

    //
    // Hold off on the shutdown of the sound system so user notifications
    // of delete players on unravel of nametable can be handled correctly. 
    // 

    ShutdownSoundSystem();

    DPVF( DPVF_WARNINGLEVEL, "Sound system shutdown" );

    FreeBuffers();

    if( m_pFramePool != NULL )
    {
        delete m_pFramePool;
        m_pFramePool = NULL;
    }

    SetCurrentState( DVCSTATE_IDLE );

    if( m_pdvidTargets != NULL )
    {
        DV_POOL_FREE(m_pdvidTargets);
        m_pdvidTargets = NULL;
        m_dwNumTargets = 0;
        m_dwTargetVersion = 0;
    }

    if( m_lpdvServerMigrated != NULL )
    {
        m_lpdvServerMigrated->Release();
        m_lpdvServerMigrated = NULL;
    }

    DPVF_EXIT();
}

// WaitForBufferReturns
//
// This function waits until oustanding sends have completed before continuing
// we use this to ensure we don't deregister with outstanding sends.
// 
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::WaitForBufferReturns"
void CDirectVoiceClientEngine::WaitForBufferReturns()
{
    ULONG cnt = 0;
    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);

    if((m_MsgBufferAllocs == 0) && (m_SpeechBufferAllocs == 0)) {
        DPVF_EXIT();                                         
        return;
    }        

    while( m_MsgBufferAllocs || m_SpeechBufferAllocs) 
    {
        //
        // call dplay do work
        //

        m_lpSessionTransport->DoWork();

        Sleep( 20 );

        if (cnt++ > 100) {
            break;
        }
    }

    DPVF_EXIT();
    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoDisconnect"
//
// DoDisconnect
//
// Performs a disconnection and informs the callback function.
//
// Used for both session lost and normal disconnects.
//
// Called By:
// - NotifyThread
// 
void CDirectVoiceClientEngine::DoDisconnect()
{
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    // Guard to prevent this function from being called more then once on the
    // same object
    if( m_dwCurrentState == DVCSTATE_IDLE ||
        m_dwCurrentState == DVCSTATE_NOTINITIALIZED ) {
        DPVF_EXIT();
        return;
    }
        
    m_dwCurrentState = DVCSTATE_DISCONNECTING;
    
    DPVF( DPVF_INFOLEVEL, "DoDisconnect called!" );
    
    if( m_fSessionLost )
    {
        DVMSG_SESSIONLOST dvSessionLost;
        dvSessionLost.hrResult = m_hrDisconnectResult;
        dvSessionLost.dwSize = sizeof( DVMSG_SESSIONLOST );
        
        NotifyQueue_Add( DVMSGID_SESSIONLOST, &dvSessionLost, sizeof( DVMSG_SESSIONLOST ) );
    }
    else
    {
        DPVF( DPVF_INFOLEVEL, "Signalling disconnect result" );
        SendDisconnectResult();
        DPVF( DPVF_INFOLEVEL, "Done signalling disconnect" );
    }

    Cleanup();
    DPVF( DPVF_INFOLEVEL, "Disconnect and Cleanup complete" );

    m_dwCurrentState = DVCSTATE_DISCONNECTED;

    DPVF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleDisconnect"
// HandleDisconnect
//
// This function is called when a disconnect message is received from the
// server.  
//
BOOL CDirectVoiceClientEngine::HandleDisconnectConfirm( DVID dvidSource, PDVPROTOCOLMSG_DISCONNECT lpdvDisconnect, DWORD dwSize )
{
    ASSERT( dwSize == sizeof( DVPROTOCOLMSG_DISCONNECT ) );

    DPVF_ENTER();
    DPVF(  DPVF_INFOLEVEL, "DisconnectConfirm received, signalling worker [res=0x%x]", lpdvDisconnect->hresDisconnect );

    DoSignalDisconnect( lpdvDisconnect->hresDisconnect );

    DPVF(  DPVF_SPAMLEVEL, "DisconnectConfirm received, signalled worker" );  

    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSessionLost"
BOOL CDirectVoiceClientEngine::HandleSessionLost( DVID dvidSource, PDVPROTOCOLMSG_SESSIONLOST lpdvSessionLost, DWORD dwSize )
{
    ASSERT( dwSize == sizeof( DVPROTOCOLMSG_SESSIONLOST ) );

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "DVCE::HandleSessionLost() begin" );

    DPVF( DPVF_ERRORLEVEL, "<><><><><><><> Session Host has shutdown - Voice Session is gone." );

    DoSessionLost( lpdvSessionLost->hresReason );

    DPVF_EXIT();
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::StartTransportSession"
HRESULT CDirectVoiceClientEngine::StartTransportSession( )
{
    DPVF_ENTER();
    DPVF_EXIT();
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::StopTransportSession"
// StopSession
//
// This function is called when the directplay session is lost or stops
// before DirectXVoice is disconnected.
//
HRESULT CDirectVoiceClientEngine::StopTransportSession()
{
    DPVF_ENTER();
    DoSessionLost( DVERR_SESSIONLOST );
    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::AddPlayer"
HRESULT CDirectVoiceClientEngine::AddPlayer( DVID dvID )
{
    DPVF_ENTER();
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleLocalHostMigrateCreate"
HRESULT CDirectVoiceClientEngine::HandleLocalHostMigrateCreate()
{
    LPDIRECTVOICESERVEROBJECT lpdvsServerObject = NULL;
    LPBYTE lpSessionBuffer = NULL;
    DWORD dwSessionSize = 0;
    HRESULT hr = DPN_OK;
    CDirectVoiceDirectXTransport *pTransport;

    DPVF_ENTER();
    DPVF( DPVF_ERRORLEVEL, ("Local client has become the new host.  Creating a host" ));

    hr = XDirectPlayVoiceCreate(IID_IDirectPlayVoiceServer,(PVOID *) &lpdvsServerObject );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to create server object. hr=0x%x", hr );
        DPVF_EXIT();
        goto HOSTCREATE_FAILURE;
    }

    lpdvsServerObject->lIntRefCnt++;

    DVMSG_LOCALHOSTSETUP dvMsgLocalHostSetup;
    dvMsgLocalHostSetup.dwSize = sizeof( DVMSG_LOCALHOSTSETUP );
    dvMsgLocalHostSetup.pvContext = NULL;
    dvMsgLocalHostSetup.pMessageHandler = NULL;

    TransmitMessage( DVMSGID_LOCALHOSTSETUP, &dvMsgLocalHostSetup,  sizeof( DVMSG_LOCALHOSTSETUP ) );                   

    //// BUGBUG: This should always be possible, but if we implement new transport
    ////         it won't be.
    ////
    pTransport = (CDirectVoiceDirectXTransport *) m_lpSessionTransport; 

    hr = DV_Initialize( lpdvsServerObject, pTransport->GetTransportInterface(), dvMsgLocalHostSetup.pMessageHandler, dvMsgLocalHostSetup.pvContext, NULL, 0 );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to initialize the server object hr=0x%x", hr );
        goto HOSTCREATE_FAILURE;
    }

    hr = lpdvsServerObject->lpDVServerEngine->HostMigrateStart( &m_dvSessionDesc, m_dwHostOrderID+DVMIGRATE_ORDERID_OFFSET );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error starting server object hr=0x%x", hr );
        goto HOSTCREATE_FAILURE;
    }

    // Grab a reference local of the new host interface
    m_lpdvServerMigrated = (LPDIRECTPLAYVOICESERVER) lpdvsServerObject;

    DVMSG_HOSTMIGRATED dvHostMigrated;
    dvHostMigrated.dvidNewHostID = m_lpSessionTransport->GetLocalID();
    dvHostMigrated.pdvServerInterface = (LPDIRECTPLAYVOICESERVER) lpdvsServerObject;
    dvHostMigrated.dwSize = sizeof( DVMSG_HOSTMIGRATED );

    NotifyQueue_Add( DVMSGID_HOSTMIGRATED, &dvHostMigrated, sizeof( DVMSG_HOSTMIGRATED )  );    
    
    DPVF_EXIT();
    return DV_OK;

HOSTCREATE_FAILURE:

    DPVF( DPVF_ERRORLEVEL, "Informing clients of our failure to create host" );

    Send_SessionLost();

    if( lpdvsServerObject != NULL )
    {
        IDirectPlayVoiceServer_Release((LPDIRECTPLAYVOICESERVER) lpdvsServerObject );
    }

    DPVF_EXIT();
    return hr;
}

// Handles remove player message
//
// This message triggers handling of host migration if the player
// who has dropped out happens to be the session host.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::RemovePlayer"
HRESULT CDirectVoiceClientEngine::RemovePlayer( DVID dvID )
{
    HRESULT hr;
    
    CVoicePlayer *pVoicePlayer;
    DVPROTOCOLMSG_PLAYERQUIT dvPlayerQuit;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
    {
        DPVF( DPVF_WARNINGLEVEL, "Ignoring transport disconnect for 0x%x -- client is disconnecting", dvID );
        DPVF_EXIT();
        return DV_OK;
    }

    dvPlayerQuit.dwType = DVMSGID_DELETEVOICEPLAYER;
    dvPlayerQuit.dvidID = dvID;

    HandleDeleteVoicePlayer( 0, &dvPlayerQuit, sizeof( DVPROTOCOLMSG_PLAYERQUIT ) );        

    // The person who dropped out was the server
    if( dvID == m_lpSessionTransport->GetServerID() )
    {
        DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Checking to see if remove of 0x%x is host 0x%x", dvID, m_lpSessionTransport->GetServerID() );
        DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Triggered by Remove Player Message" );

        MigrateHost_RunElection();
    }

    DPVF_EXIT();
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetCurrentState"
// SetCurrentState
//
// Sets the current state of the client engine
// 
// must alwaysbe called at DPC for synchronization
//
void CDirectVoiceClientEngine::SetCurrentState( DWORD dwState )
{
    DV_AUTO_LOCK(&m_CS);
    m_dwCurrentState = dwState;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckShouldSendMessage"
//
// CheckShouldSendMessage
//
// Checks the notification mask to see if the specified message type should
// be sent to the user. 
//
// called at DPC only
BOOL CDirectVoiceClientEngine::CheckShouldSendMessage( DWORD dwMessageType )
{
    BOOL fSend = FALSE;         

    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);
    if( m_lpMessageHandler == NULL )
    {
        DPVF_EXIT();
        return FALSE;
    }
    
    if( m_dwNumMessageElements == 0 )
    {
        DPVF_EXIT();
        return TRUE;
    }
    else
    {
        for( DWORD dwIndex = 0; dwIndex < m_dwNumMessageElements; dwIndex++ )
        {
            if( m_pMessageElements[dwIndex] == dwMessageType )
            {
                DPVF_EXIT();
                return TRUE;
            }
        }
    }

    DPVF_EXIT();
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::TransmitMessage"
//
// TransmitMessage
//
// Called to send a notification to the user.  
//
// Only the notify thread should call this function, all other threads should queue up 
// notifications by calling NotifyQueue_Add.
//
// Called By:
// - NotifyThread.
//
void CDirectVoiceClientEngine::TransmitMessage( DWORD dwMessageType, LPVOID lpData, DWORD dwSize )
{    

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    if( CheckShouldSendMessage( dwMessageType ) )
    {
        (*m_lpMessageHandler)( m_lpUserContext, dwMessageType, lpData );                
    }

    DPVF_EXIT();

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InitializeSoundSystem"
// InitializeSoundSystem
//
// Starts up the sound system based on the parameters.
//
HRESULT CDirectVoiceClientEngine::InitializeSoundSystem()
{
    HRESULT hr;
    ULONG temp;
    XMediaObject *pInboundConverter;

    DPVF_ENTER();
    DPVF( DPVF_ENTRYLEVEL, "DVCE::InitializeSoundSystem() Begin" );
    
    //
    // we dont initialize the playback subsystem explicitly.
    // instead, when voice from a remote user arrives, we then create
    // a streaming DS object for that users data
    // then each frame gets mixed in automatically by dsound
    //

    //
    // init record subsystem
    //

    if (!(m_dvClientConfig.dwFlags & DVCLIENTCONFIG_HALFDUPLEX)) {

        if (m_RecordSubSystem == NULL) {

            m_RecordSubSystem = new CClientRecordSubSystem( this );
            // Check that the converter is valid
            if( m_RecordSubSystem == NULL  )
            {
                DPVF(  DPVF_ERRORLEVEL, "Memory alloc failure" );
                return DVERR_RECORDSYSTEMERROR;
            }
    
            hr = m_RecordSubSystem->Initialize();
    
            if( FAILED( hr ) )
            {
                DPVF( DPVF_ERRORLEVEL, "Record Sub Error during init hr=0x%x", hr );
                SwitchToHalfDuplex();

            }

        }

    }

    if (m_pFramePool == NULL) {

        /////////////////////////////////////////////////////////////////////////////////////////
        // Build the frame pool
        m_pFramePool = new CFramePool( (USHORT)s_dwCompressedFrameSize );            
    
        if( m_pFramePool == NULL )
        {
            DPVF( DPVF_ERRORLEVEL, "Unable to allocate frame pool" );
            DPVF_EXIT();
            return DVERR_OUTOFMEMORY;
        }
    
        DPVF( DPVF_INFOLEVEL, "FULL DUPLEX INIT: End ==========" );

    }

    DPVF( DPVF_ENTRYLEVEL, "DVCE::InitializeSoundSystem() End" );

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ShutdownSoundSystem"
// ShutdownSoundSystem
//
// Stop the sound system
//
HRESULT CDirectVoiceClientEngine::ShutdownSoundSystem()
{
    HRESULT hr;    

    DPVF_ENTER();
    DPVF(  DPVF_ENTRYLEVEL, "DVCE::ShutdownSoundSystem() Begin" );

    //
    // delete the record subsystem, if it exists
    //

    DV_AUTO_LOCK(&m_CS);

    if (m_RecordSubSystem) {
        delete m_RecordSubSystem;
        m_RecordSubSystem = NULL;
    }    

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendConnectResult"
__inline HRESULT CDirectVoiceClientEngine::BuildCompressionInfo()
{

    ULONG temp;
    HRESULT hr;
    XMEDIAINFO xmi;
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    memset(&xmi,0,sizeof(xmi));
    xmi.dwInputSize = 1;

    //
    // get compressed size from record subsystem instance of decoder
    //

    hr = m_pInBoundAudioConverter->GetInfo(&xmi);

    if (FAILED(hr)) {
        DPVF_EXIT();
        return hr;
    }

    s_dwCompressedFrameSize = xmi.dwInputSize;
    s_dwUnCompressedFrameSize = xmi.dwOutputSize;

    DPVF(DPVF_INFOLEVEL, "CompressionInfo: Encode Frame %x, Decoded Frame %x",
        s_dwCompressedFrameSize,
        s_dwUnCompressedFrameSize);

    DPVF_EXIT();
    return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendConnectResult"
HRESULT CDirectVoiceClientEngine::SendConnectResult()
{
    DVMSG_CONNECTRESULT dvConnect;

    DPVF_ENTER();

    dvConnect.hrResult = m_hrConnectResult;
    dvConnect.dwSize = sizeof( DVMSG_CONNECTRESULT );

    DPVF_EXIT();
    return NotifyQueue_Add( DVMSGID_CONNECTRESULT, &dvConnect, sizeof( DVMSG_CONNECTRESULT ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendDisconnectResult"
HRESULT CDirectVoiceClientEngine::SendDisconnectResult()
{
    DPVF_ENTER();
    DVMSG_DISCONNECTRESULT dvDisconnect;
    dvDisconnect.hrResult = m_hrDisconnectResult;
    dvDisconnect.dwSize = sizeof( DVMSG_DISCONNECTRESULT );

    DPVF_EXIT();
    return NotifyQueue_Add( DVMSGID_DISCONNECTRESULT, &dvDisconnect, sizeof( DVMSG_DISCONNECTRESULT ) );
}

// DoWork routine
//
// All-purpose function that executes queued work items
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoWork"
HRESULT CDirectVoiceClientEngine::DoWork()
{
    DWORD dwWaitPeriod;
    LONG lWaitResult;
    DWORD dwPowerLevel;
    DWORD dwLastTimeoutCheck;
    
    DWORD dwCurTime;

    CNotifyElement *neElement;
    HRESULT hr;
    DVID  dvidMessageTarget;

    DVMSG_INPUTLEVEL dvInputLevel;        

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    dvInputLevel.dwSize = sizeof( DVMSG_INPUTLEVEL );

    if (m_dwCurrentState == DVCSTATE_NOTINITIALIZED) {

        return DVERR_NOTINITIALIZED;

    }

    // Setup last time we checked to right now.
    dwLastTimeoutCheck = GetTickCount();
    
    do
    {

        dwCurTime = GetTickCount();

        //
        // get a snapshot of the events
        // clear event flags at DPC
        // this is just like a driver DPC syncronizing with its ISR
        //

        if (m_dwCurrentState == DVCSTATE_DISCONNECTED) {

            return DVERR_CONNECTIONLOST;

        }

        hr = NotifyQueue_IndicateNext();

        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "NotifyQueue_IndicateNext Failed hr=0x%x", hr );
        }

        // If we're connecting, check for timeout on the connection
        // request.
        if((m_dwCurrentState == DVCSTATE_CONNECTING) && (m_dwSynchBegin != 0) )
        {
            
            if( ( dwCurTime - m_dwSynchBegin ) > DV_CLIENT_CONNECT_TIMEOUT )
            {
                DPVF( DPVF_ERRORLEVEL, "Connection Timed-Out.  Returning NOVOICESESSION" );
                m_hrConnectResult = DVERR_NOVOICESESSION;
                SendConnectResult();
                Cleanup();              
                continue;               
            }
            else if( ( dwCurTime - m_dwLastConnectSent ) > DV_CLIENT_CONNECT_RETRY_TIMEOUT )
            {
                DPVF( DPVF_WARNINGLEVEL, "Connect Request Timed-Out" );
                DPVF( DPVF_WARNINGLEVEL, "Re-sending connection request" );

                hr = Send_ConnectRequest();

                if( FAILED( hr ) )
                {
                    DPVF( DPVF_ERRORLEVEL, "Error sending connection request.  Send error hr=0x%x", hr );

                    m_hrConnectResult = DVERR_SENDERROR;

                    SendConnectResult();
                    Cleanup();                  
                    continue;
                }
                
                m_dwLastConnectSent = dwCurTime;
            }
        }
        // If we're disconnecting, check for timeout on the disconnect
        else if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
        {
            DPVF( DPVF_INFOLEVEL, "Checking timeout on disconnect.  Waited %d so far", dwCurTime - m_dwSynchBegin );
            
            if( ( dwCurTime - m_dwSynchBegin ) > DV_CLIENT_DISCONNECT_TIMEOUT )
            {
                DPVF( DPVF_WARNINGLEVEL, "Disconnect Request Timed-Out" );
                DoSignalDisconnect( DVERR_TIMEOUT );                
            }

            if (m_fSessionLost == TRUE) {

                //
                // disconnect has been signalled, cleanup
                //

                DoDisconnect();

            }

        }

        // Take care of the periodic checks
        if (m_dwCurrentState == DVCSTATE_CONNECTED)
        {
            dwCurTime = GetTickCount();

            // Update pending / other lists
            UpdateActiveNotifyPendingList( );
            
            // If we're running a multicast session.. check for timed-out users
            if(m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
            {
                if( ( dwCurTime - dwLastTimeoutCheck ) > DV_MULTICAST_USERTIMEOUT_PERIOD )
                {
                    CheckForUserTimeout(dwCurTime);

                    dwLastTimeoutCheck = dwCurTime;         
                }
            }

            if (m_fLocalPlayerAvailable &&
                CheckShouldSendMessage( DVMSGID_INPUTLEVEL )) {

                dvInputLevel.pvLocalPlayerContext = m_pvLocalPlayerContext; 
                dvInputLevel.dwPeakLevel = m_bLastPeak;

                NotifyQueue_Add( DVMSGID_INPUTLEVEL, &dvInputLevel, sizeof( DVMSG_INPUTLEVEL ) );

            }

            QueuePlayerLevelNotifications();

        }

        if(m_dwCurrentState == DVCSTATE_IDLE )
        {
            return DV_OK;
        }

    } while(FALSE);

    //
	// If the notification of the local player hasn't been processed and we're in peer to peer mode, don't
	// allow recording to start until after the player has been indicated
    //

	if((m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER) &&
       !m_fLocalPlayerAvailable )
	{
		DPVF( RRI_DEBUGOUTPUT_LEVEL, "Local player has not yet been indicated, not doing Record/Playback work" );
        DPVF_EXIT();
        return DV_OK;

	} 

    if (m_RecordSubSystem) {

        hr = m_RecordSubSystem->RecordFSM();
        if (FAILED(hr)) {
            
            //
            // hawk got removed, delete the record subsystem and switch to half duplex
            //

            SwitchToHalfDuplex();

            DPVF_EXIT();
            return DVERR_RECORDSYSTEMERROR;
        }
    
        dwCurTime = GetTickCount();
    
    }

    //
    // do some playback work
    //

    hr = DoPlaybackWork();
    if (FAILED(hr)) {

        ASSERT(!m_RecordSubSystem);
        if (!m_RecordSubSystem) {

            //
            // hmm race condition: either session really got lost
            // or hawk got removed between RecordFSM returning and DoPlaybackWork getting called
            // BUGBUG deal with this by doing a session disconnect for now.. Evenutally
            // we should ask USB if the hawk is still in , if it is dont loose the session, just switch
            // to half duplex
            //

            DoSessionLost(DVERR_SESSIONLOST);

        } else {

            SwitchToHalfDuplex();

        }

    }

    DPVF_EXIT();
    return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SwitchToHalfDuplex"
//
// SwitchToHalfDuplex
// 
VOID CDirectVoiceClientEngine::SwitchToHalfDuplex()
{

    PLIST_ENTRY         currentEntry;
    CVoicePlayer *      pCurrentPlayer;
    WAVEFORMATEX        wfx;
    HRESULT             hr;
    DVMSG_VOICEPERIPHERALNOTPRESENT dvVoiceNotPresent;

    DV_AUTO_LOCK(&m_CS);

    delete m_RecordSubSystem;

    DPVF( DPVF_ERRORLEVEL, "Switching to half duplex since no hawk available!!!!");

    memcpy(&wfx, s_lpwfxPrimaryFormat, sizeof(wfx));

    m_RecordSubSystem = NULL;
    m_dvClientConfig.dwFlags |= DVCLIENTCONFIG_HALFDUPLEX;

    //
    // now switch the playback output for each remote player from hawk, to MCPX
    //

    // Update list 
    UpdateActivePlayPendingList(  );

    currentEntry = m_PlayActivePlayersList.Flink;

    while( currentEntry != &m_PlayActivePlayersList ) {

        pCurrentPlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_PlayListEntry );
        currentEntry = currentEntry->Flink;

        //
        // switch player to use MCPX for audio output
        // mute playback if the caller specified the right flag
        //

        hr = pCurrentPlayer->SwitchInternalAudioTarget(
            &wfx,
            TRUE, 
            (m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MUTEIFNODEVICE) ? TRUE : FALSE);

        if (FAILED(hr)) {

            //
            // ok quit tryin, everythin is messed up
            // disconnect session
            //

            DoSessionLost(DVERR_SESSIONLOST);
            return;

        }

    }

    //
    // send a message to the user that the input device has been removed
    //

    dvVoiceNotPresent.dwSize = sizeof( DVMSG_VOICEPERIPHERALNOTPRESENT);
    NotifyQueue_Add( DVMSGID_VOICEPERIPHERALNOTPRESENT, &dvVoiceNotPresent, sizeof( DVMSG_VOICEPERIPHERALNOTPRESENT ) );                

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::QueuePlayerLevelNotifications"
//
// SendPlayerLevels
// 
// Send player level notifications, but only if there is a message handler
// and the player level message is active.
//
VOID CDirectVoiceClientEngine::QueuePlayerLevelNotifications()
{
    CVoicePlayer *pCurrentPlayer;
    DVMSG_PLAYEROUTPUTLEVEL dvPlayerLevel;
    PLIST_ENTRY currentEntry;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();

    if( CheckShouldSendMessage( DVMSGID_PLAYEROUTPUTLEVEL ))
    {

        currentEntry = m_NotifyActivePlayersList.Flink;

        while(currentEntry != &m_NotifyActivePlayersList )
        {
            pCurrentPlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_NotifyListEntry );

            ASSERT( pCurrentPlayer != NULL );

            if( pCurrentPlayer->IsReceiving() )
            {
                dvPlayerLevel.dwSize = sizeof( DVMSG_PLAYEROUTPUTLEVEL );
                dvPlayerLevel.dvidSourcePlayerID = pCurrentPlayer->GetPlayerID();
                dvPlayerLevel.dwPeakLevel = pCurrentPlayer->GetLastPeak();
                dvPlayerLevel.pvPlayerContext = pCurrentPlayer->GetContext();

                NotifyQueue_Add( DVMSGID_PLAYEROUTPUTLEVEL, &dvPlayerLevel, sizeof( DVMSG_PLAYEROUTPUTLEVEL ) );                
            }

            currentEntry = currentEntry->Flink;
        } 

    }   

    DPVF_EXIT();
    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckForUserTimeout"
//
// CheckForUserTimeout
//
// Run the list of users and check for user timeouts in multicast sessions
//
void CDirectVoiceClientEngine::CheckForUserTimeout( DWORD dwCurTime )
{
    PLIST_ENTRY currentEntry;
    CVoicePlayer *pCurrentPlayer;
    DVPROTOCOLMSG_PLAYERQUIT msgPlayerQuit;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    msgPlayerQuit.dwType = DVMSGID_DELETEVOICEPLAYER;
    currentEntry = m_NotifyActivePlayersList.Flink;

    while(currentEntry != &m_NotifyActivePlayersList)
    {   

        pCurrentPlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_NotifyListEntry );

        if( dwCurTime - pCurrentPlayer->GetLastPlayback() > DV_MULTICAST_USERTIMEOUT_PERIOD )
        {
            msgPlayerQuit.dvidID = pCurrentPlayer->GetPlayerID();
            HandleDeleteVoicePlayer( pCurrentPlayer->GetPlayerID(), &msgPlayerQuit, sizeof( DVPROTOCOLMSG_PLAYERQUIT ) );
        }

        currentEntry = currentEntry->Flink;

    };

    DPVF(  DPVF_INFOLEVEL, "Done Enum" );

    DPVF_EXIT();
    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CleanupPlaybackList"

// Cleanup any outstanding entries on the playback lists
void CDirectVoiceClientEngine::CleanupPlaybackLists()
{
    PLIST_ENTRY currentEntry;
    CVoicePlayer *pVoicePlayer;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    m_dwPlayActiveCount = 0;

    currentEntry = m_PlayActivePlayersList.Flink;

    while(currentEntry != &m_PlayActivePlayersList) 
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_PlayListEntry );
        pVoicePlayer->RemoveFromPlayList();
        pVoicePlayer->Release();
        currentEntry = m_PlayActivePlayersList.Flink;
    }; 

    currentEntry = m_PlayAddPlayersList.Flink;

    while(currentEntry != &m_PlayAddPlayersList)
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_PlayListEntry );
        pVoicePlayer->RemoveFromPlayList();
        pVoicePlayer->Release();
        currentEntry =  m_PlayAddPlayersList.Flink;
    };

    DPVF_EXIT();
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CleanupNotifyLists"

void CDirectVoiceClientEngine::CleanupNotifyLists(  )
{
    PLIST_ENTRY currentEntry;
    CVoicePlayer *pVoicePlayer;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    currentEntry = m_NotifyActivePlayersList.Flink;

    while( currentEntry != &m_NotifyActivePlayersList )
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_NotifyListEntry );
        pVoicePlayer->RemoveFromNotifyList();
        pVoicePlayer->Release();
        currentEntry = m_NotifyActivePlayersList.Flink;
    }

    currentEntry = m_NotifyAddPlayersList.Flink;

    while( currentEntry != &m_NotifyAddPlayersList )
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_NotifyListEntry );
        pVoicePlayer->RemoveFromNotifyList();
        pVoicePlayer->Release();
        currentEntry = m_NotifyAddPlayersList.Flink;
    }

    DPVF_EXIT();
    
}

// UpdateActivePendingList
//
// This function looks at the pending list and moves those elements on the pending list to the active list
//
// This function also looks at the active list and removes those players who are disconnected
//
// There are three four lists in the system:
// - Playback Thread
// - Notify Thread
// - Host Migration List
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::UpdateActivePlayPendingList"

void CDirectVoiceClientEngine::UpdateActivePlayPendingList( )
{
    PLIST_ENTRY currentEntry;
    CVoicePlayer *pVoicePlayer;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    // Add players who are pending
    currentEntry = m_PlayAddPlayersList.Flink;

    while( currentEntry != &m_PlayAddPlayersList )
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_PlayListEntry );

        pVoicePlayer->RemoveFromPlayList();
        pVoicePlayer->AddToPlayList( &m_PlayActivePlayersList );
        m_dwPlayActiveCount++;

        currentEntry = m_PlayAddPlayersList.Flink;
    }

    // Remove players who have disconnected
    currentEntry = m_PlayActivePlayersList.Flink;

    while( currentEntry != &m_PlayActivePlayersList )
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_PlayListEntry );

        currentEntry = currentEntry->Flink;

        // If current player has disconnected, remove them from active list
        // and release the reference the list has
        if( pVoicePlayer->IsDisconnected() )
        {
            m_dwPlayActiveCount--;            
            pVoicePlayer->RemoveFromPlayList();

            pVoicePlayer->Release();
        }
    }

    DPVF_EXIT();

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::UpdateActiveNotifePendingList"

void CDirectVoiceClientEngine::UpdateActiveNotifyPendingList( )
{
    PLIST_ENTRY currentEntry;
    CVoicePlayer *pVoicePlayer;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    // Add players who are pending
    currentEntry = m_NotifyAddPlayersList.Flink;

    while( currentEntry != &m_NotifyAddPlayersList )
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_NotifyListEntry );

        pVoicePlayer->RemoveFromNotifyList();
        pVoicePlayer->AddToNotifyList( &m_NotifyActivePlayersList );

        currentEntry = m_NotifyAddPlayersList.Flink;
    }

    // Remove players who have disconnected
    currentEntry = m_NotifyActivePlayersList.Flink;

    while( currentEntry != &m_NotifyActivePlayersList )
    {
        pVoicePlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_NotifyListEntry );

        currentEntry = currentEntry->Flink;

        // If current player has disconnected, remove them from active list
        // and release the reference the list has
        if( pVoicePlayer->IsDisconnected() )
        {
            pVoicePlayer->RemoveFromNotifyList();
            pVoicePlayer->Release();
        }
    }

    DPVF_EXIT();

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoPlaybackWork"
HRESULT CDirectVoiceClientEngine::DoPlaybackWork()
{

    DWORD               dwCurPlayer;
    BOOL                bContinueEnum;
    DVPROTOCOLMSG_PLAYERQUIT    dvPlayerQuit;
    HRESULT             hr = DV_OK;
    DWORD               dwTmp;
    DVMSG_PLAYERVOICESTART dvMsgPlayerVoiceStart;
    DVMSG_PLAYERVOICESTOP  dvMsgPlayerVoiceStop;
    CVoicePlayer        *pCurrentPlayer;
    PLIST_ENTRY         currentEntry;
    BOOL                fSilence, fLost;
    DWORD               dwSeqNum, dwMsgNum;
    CFrame              *frTmpFrame;
    DWORD               dwFrameFlags;
    BYTE                bHighPeak = 0;
    DWORD               dwCurrTime;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();

    //
    // BUGBUG make available time equal zero to force this function to do single quantum of work
    //

    dvMsgPlayerVoiceStart.dwSize = sizeof( DVMSG_PLAYERVOICESTART );
    dvMsgPlayerVoiceStop.dwSize = sizeof( DVMSG_PLAYERVOICESTOP );

    do
    {

        // Update list 
        UpdateActivePlayPendingList(  );

        currentEntry = m_PlayActivePlayersList.Flink;

        while( currentEntry != &m_PlayActivePlayersList )
        {
            pCurrentPlayer = CONTAINING_RECORD( currentEntry, CVoicePlayer, m_PlayListEntry );

            currentEntry = currentEntry->Flink;

            if( m_dvClientConfig.dwFlags & DVCLIENTCONFIG_PLAYBACKMUTE )
            {
                frTmpFrame = pCurrentPlayer->Dequeue();
                frTmpFrame->Return();
                continue;
            }

            hr = pCurrentPlayer->GetNextFrameAndDecompress(&dwFrameFlags, &dwSeqNum, &dwMsgNum );

            if( FAILED( hr ) )
            {
                DPVF( DPVF_ERRORLEVEL, "Unable to get frame from player hr=0x%x", hr );
                goto EXIT_PLAYBACK;
            }


            if( pCurrentPlayer->GetLastPeak() > bHighPeak )
            {
                bHighPeak = pCurrentPlayer->GetLastPeak();
            }

#if DBG
            if( dwFrameFlags & DV_FRAMEF_IS_LOST )
            {
                DPVF( DPVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Dequeue: Lost Frame" );  
                DPVF( DPVF_GLITCH_DEBUG_LEVEL, "GLITCH: Dequeue: Packet was lost.  Speech gap will occur." );
            }
            else if( dwFrameFlags & DV_FRAMEF_IS_SILENCE)
            {
                DPVF( DPVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Dequeue: Silent Frame" );    
            }
            else
            {
                DPVF( DPVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Dequeue: Msg [%d] Seq [%d]", dwMsgNum, dwSeqNum );
            }
#endif

            // If the player sent us silence, increment the silent count
            if( dwFrameFlags & DV_FRAMEF_IS_SILENCE )
            {

                //
                // If we're receiving on this user
                //

                if( pCurrentPlayer->IsReceiving() )
                {

                    //
                    // If it exceeds the max.
                    //

                    dwCurrTime = GetTickCount();

                    if( (dwCurrTime - pCurrentPlayer->GetLastPlayback()) > PLAYBACK_RECEIVESTOP_TIMEOUT )
                    {
                        pCurrentPlayer->SetReceiving(FALSE);

                        dvMsgPlayerVoiceStop.dwSize = sizeof( dvMsgPlayerVoiceStop );
                        dvMsgPlayerVoiceStop.dvidSourcePlayerID = pCurrentPlayer->GetPlayerID();
                        dvMsgPlayerVoiceStop.pvPlayerContext = pCurrentPlayer->GetContext();
                        NotifyQueue_Add( DVMSGID_PLAYERVOICESTOP, &dvMsgPlayerVoiceStop, sizeof( dvMsgPlayerVoiceStop ) );      
                    }
                }

                bHighPeak = 0;
            }
            else
            {
                //
                // We received data and this is the first one
                //

                if( !pCurrentPlayer->IsReceiving() )
                {

                    dvMsgPlayerVoiceStart.dvidSourcePlayerID = pCurrentPlayer->GetPlayerID();
                    dvMsgPlayerVoiceStart.pvPlayerContext = pCurrentPlayer->GetContext();
                    
                    NotifyQueue_Add( DVMSGID_PLAYERVOICESTART, &dvMsgPlayerVoiceStart, sizeof(DVMSG_PLAYERVOICESTART) );

                    pCurrentPlayer->SetReceiving(TRUE);

                }
            }

            
        } // for each player

        //
        // we go through this loop only once..
        //

    } while (FALSE);

    m_bLastPlaybackPeak = bHighPeak;

EXIT_PLAYBACK:

    DPVF_EXIT();
    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::MigrateHost"
// MigrateHost
// 
// This function is called by DV_HostMigrate when the local client has received a host
// migration notification.  
//
//
HRESULT CDirectVoiceClientEngine::MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer )
{
    return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_IndicateNext"
HRESULT CDirectVoiceClientEngine::NotifyQueue_IndicateNext()
{
    HRESULT hr = DV_OK; 
    CNotifyElement *neElement;

    while (!IsListEmpty(&m_NotifyList)) {

        neElement = (CNotifyElement *) DV_REMOVE_TAIL(&m_NotifyList);
    
        if( FAILED( neElement == NULL ))
        {
            DPVF( DPVF_ERRORLEVEL, "NotifyQueue Empty!");
        }
        else
        {
            DPVF( DPVF_SPAMLEVEL, "Sending notification type=0x%x", neElement->m_dwType );
    
            TransmitMessage( neElement->m_dwType, 
                             &neElement->m_element, 
                             neElement->m_dwDataSize );                 
    
            DPVF( DPVF_SPAMLEVEL, "Returning notification" );
    
            //
            // return element to pool
            //
    
            NotifyQueue_ElementFree( neElement );
        }

    }

    DPVF_EXIT();
    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Add"
// Queue up a notification for the user
HRESULT CDirectVoiceClientEngine::NotifyQueue_Add( DWORD dwMessageType, LPVOID lpData, DWORD dwDataSize, PVOID pvContext, CNotifyElement::PNOTIFY_COMPLETE pNotifyFunc )
{
    CNotifyElement *lpNewElement;
    HRESULT hr;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    if( !m_fNotifyQueueEnabled )
    {
        DPVF( DPVF_WARNINGLEVEL, "Ignoring indication, queue disabled" );
        DPVF_EXIT();
        return DV_OK;
    }

    lpNewElement = (CNotifyElement *) DV_REMOVE_TAIL(&m_NotificationElementPool);

    if( lpNewElement == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed to get a block for a notifier" );
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;
    }

    // Setup the notification callbacks, if there are ones
    lpNewElement->pvContext = pvContext; 
    lpNewElement->pNotifyFunc = pNotifyFunc;

#if DBG
    if( dwMessageType == DVMSGID_PLAYERVOICESTOP )
    {
        PDVMSG_PLAYERVOICESTOP pMsgStop = (PDVMSG_PLAYERVOICESTOP) lpData;

        ASSERT( pMsgStop->dwSize == sizeof( DVMSG_PLAYERVOICESTOP ) );
        ASSERT( dwDataSize == sizeof( DVMSG_PLAYERVOICESTOP ) );        
    }

    if( dwMessageType == DVMSGID_PLAYERVOICESTART )
    {
        PDVMSG_PLAYERVOICESTART pMsgStart = (PDVMSG_PLAYERVOICESTART) lpData;

        ASSERT( pMsgStart->dwSize == sizeof( DVMSG_PLAYERVOICESTART ) );
        ASSERT( dwDataSize == sizeof( DVMSG_PLAYERVOICESTART ) );       
    }

    if( dwMessageType == DVMSGID_PLAYEROUTPUTLEVEL )
    {
        PDVMSG_PLAYEROUTPUTLEVEL pMsgOutput = (PDVMSG_PLAYEROUTPUTLEVEL) lpData;

        ASSERT( pMsgOutput->dwSize == sizeof( DVMSG_PLAYEROUTPUTLEVEL ) );
        ASSERT( dwDataSize == sizeof( DVMSG_PLAYEROUTPUTLEVEL ) );      
    }
#endif

    lpNewElement->m_dwType = dwMessageType;
    lpNewElement->m_dwDataSize = dwDataSize;

    ASSERT(dwDataSize <= DV_CLIENT_NOTIFY_ELEMENT_SIZE);

    memcpy( &lpNewElement->m_element, lpData, dwDataSize ); 

    // Fixups for internal pointers 
    //
    // Required for certain message types (currently only DVMSGID_SETTARGETS)
    if( dwMessageType == DVMSGID_SETTARGETS )
    {
        PDVMSG_SETTARGETS pdvSetTarget;

        pdvSetTarget = (PDVMSG_SETTARGETS) lpNewElement->m_element.Data;

        pdvSetTarget->pdvidTargets = (PDVID) &pdvSetTarget[1];
        lpNewElement->m_dwDataSize = sizeof( DVMSG_SETTARGETS );
    }

    //
    // add this element to our pending notification list
    //

    DV_INSERT_HEAD(&m_NotifyList,lpNewElement);

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_ElementFree"
HRESULT CDirectVoiceClientEngine::NotifyQueue_ElementFree( CNotifyElement *lpElement )
{
    DPVF_ENTER();
    // Call the notification function, if there is one
    if( lpElement->pNotifyFunc )
    {
        (*lpElement->pNotifyFunc)(lpElement->pvContext,lpElement);
        lpElement->pNotifyFunc = NULL;
        lpElement->pvContext = NULL;
    }
        
    // Return notifier to the fixed pool manager

    DV_INSERT_TAIL(&m_NotificationElementPool,lpElement);

    DPVF_EXIT();
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Enable"
void CDirectVoiceClientEngine::NotifyQueue_Enable()
{
    DV_AUTO_LOCK(&m_CS);
    m_fNotifyQueueEnabled = TRUE;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Disable"
void CDirectVoiceClientEngine::NotifyQueue_Disable()
{
    DV_AUTO_LOCK(&m_CS);
    m_fNotifyQueueEnabled = FALSE;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Free"
HRESULT CDirectVoiceClientEngine::NotifyQueue_Free()
{
    CNotifyElement *lpTmpElement;
    CNotifyElement *lpIteratorElement;
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    lpIteratorElement = (CNotifyElement *)DV_GET_LIST_HEAD(&m_NotifyList);

    while( lpIteratorElement != NULL )
    {
        lpTmpElement = lpIteratorElement;
        lpIteratorElement = (CNotifyElement *) DV_GET_NEXT(&m_NotifyList, lpIteratorElement);

        //
        // elementFree calls notigfications functions
        // we lower irql so they are not done at DPC
        //

        NotifyQueue_ElementFree( lpTmpElement );
    }

    DV_FreeList(&m_NotificationElementPool, DVLAT_RAW);

    DPVF_EXIT();
    return DV_OK;
}

//
// HANDLERS FOR WHEN WE HANDLE REMOTE SERVERS
//
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CreateGroup"
HRESULT CDirectVoiceClientEngine::CreateGroup( DVID dvID )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DeleteGroup"
HRESULT CDirectVoiceClientEngine::DeleteGroup( DVID dvID )
{
    CheckForAndRemoveTarget( dvID );

    // If there are any buffers for this player, delete them
    //
    // Leave the buffer around so the user can call Delete3DSoundBuffer
    //
    // DeleteSoundTarget( dvID );

    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::AddPlayerToGroup"
HRESULT CDirectVoiceClientEngine::AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::RemovePlayerFromGroup"
HRESULT CDirectVoiceClientEngine::RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoSessionLost"
void CDirectVoiceClientEngine::DoSessionLost( HRESULT hrDisconnectResult )
{
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();
    DPVF( DPVF_ERRORLEVEL, "#### SESSION LOST [hr=0x%x]", hrDisconnectResult );
    m_fSessionLost = TRUE;
    SetCurrentState(DVCSTATE_DISCONNECTING);
    DoSignalDisconnect( hrDisconnectResult );

    DPVF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoSignalDisconnect"
void CDirectVoiceClientEngine::DoSignalDisconnect( HRESULT hrDisconnectResult )
{
    DPVF_ENTER();
    DPVF( DPVF_INFOLEVEL, "#### Disconnecting [hr=0x%x]", hrDisconnectResult );

    DV_AUTO_LOCK(&m_CS);

    m_hrDisconnectResult = hrDisconnectResult;
    DPVF_EXIT();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetTransmitBuffer"
PDVTRANSPORT_BUFFERDESC CDirectVoiceClientEngine::GetTransmitBuffer(DWORD dwSize, LPVOID *ppvSendContext, BOOLEAN bUseSpeechPool)
{
    PDVTRANSPORT_BUFFERDESC pNewBuffer = NULL;
    PLIST_ENTRY pEntry;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    pNewBuffer = (PDVTRANSPORT_BUFFERDESC)DV_REMOVE_TAIL(&m_BufferDescPool);

    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer desc address 0x%p", (void *) pNewBuffer );

    if( pNewBuffer == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Error getting transmit buffer" );
        goto GETTRANSMITBUFFER_ERROR;
    }

    pNewBuffer->lRefCount = 0;
    pNewBuffer->dwObjectType = DVTRANSPORT_OBJECTTYPE_CLIENT;
    pNewBuffer->dwFlags = 0;
    
    if (bUseSpeechPool) {

        m_SpeechBufferAllocs++;
        pNewBuffer->pvContext = &m_SpeechBufferPool;
        pNewBuffer->pBufferData = (PUCHAR)DV_REMOVE_TAIL(&m_SpeechBufferPool);
        
    } else {

        m_MsgBufferAllocs++;

        pNewBuffer->pvContext = &m_MessagePool;
        pNewBuffer->pBufferData = (PUCHAR)DV_REMOVE_TAIL(&m_MessagePool);

    }


    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer value at address 0x%p", (void *) pNewBuffer->pBufferData );

    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: nInUse  = %i", IsListEmpty(&m_BufferDescPool));  

    if( pNewBuffer->pBufferData == NULL )
    {
        DPVF( 0, "Error getting buffer for buffer desc" );
        goto GETTRANSMITBUFFER_ERROR;
    }
    
    pNewBuffer->dwBufferSize = dwSize;

    *ppvSendContext = pNewBuffer;

    DPVF_EXIT();
    return pNewBuffer;

GETTRANSMITBUFFER_ERROR:

    if (bUseSpeechPool) {

        m_SpeechBufferAllocs--;
        
    } else {

        m_MsgBufferAllocs--;

    }

    if( pNewBuffer != NULL && pNewBuffer->pBufferData != NULL )
    {
        DV_INSERT_TAIL((PLIST_ENTRY)pNewBuffer->pvContext,
                            pNewBuffer->pBufferData);
    }

    if( pNewBuffer != NULL )
    {
        DV_INSERT_TAIL(&m_BufferDescPool,
                            pNewBuffer);

    }

    DPVF_EXIT();
    return NULL;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ReturnTransmitBuffer"
// ReturnTransmitBuffer
//
// PDVTRANSPORT_BUFFERDESC pBufferDesc - Buffer description of buffer to return
// LPVOID lpvContext - Context value to be used when returning the buffer 
// 
void CDirectVoiceClientEngine::ReturnTransmitBuffer( PVOID pvContext )
{
    PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pvContext;
    PLIST_ENTRY pListHead = (PLIST_ENTRY) pBufferDesc->pvContext;

    DPVF_ENTER();
    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer desc at address 0x%p", (void *) pBufferDesc );
    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer at address 0x%p", (void *) pBufferDesc->pBufferData );

    DV_AUTO_LOCK(&m_CS);

    if (pListHead == &m_SpeechBufferPool) {
        m_SpeechBufferAllocs--;
    }
        
    if (pListHead == &m_MessagePool) {
        m_MsgBufferAllocs--;
    }

    // Release memory
    DV_INSERT_TAIL(pListHead, pBufferDesc->pBufferData);

    // Release buffer description
    DV_INSERT_TAIL(&m_BufferDescPool,pBufferDesc);

    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: nInUse  = %i", IsListEmpty(&m_BufferDescPool) );

    DPVF_EXIT();

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendComplete"
HRESULT CDirectVoiceClientEngine::SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete )
{
    ReturnTransmitBuffer( pSendComplete->pvUserContext );
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetupInitialBuffers"
// SetupBuffersInitial
//
// This function sets up the first transmit buffers which do not vary
// in size w/the compression type.
//
HRESULT CDirectVoiceClientEngine::SetupInitialBuffers()
{
    HRESULT hr = DV_OK;
    
    DPVF_ENTER();

    InitializeListHead(&m_BufferDescPool);
    hr = DV_InitializeList(&m_BufferDescPool,
                           m_lpSessionTransport->GetMaxPlayers()*DV_CT_FRAMES_PER_PERIOD,
                           sizeof(DVTRANSPORT_BUFFERDESC),
                           DVLAT_RAW);
    if (SUCCEEDED(hr)) {

        m_pBufferDescAllocation = m_BufferDescPool.Flink;

        InitializeListHead(&m_MessagePool);
        hr = DV_InitializeList(&m_MessagePool,
                          m_lpSessionTransport->GetMaxPlayers()*2,
                          sizeof(DVPROTOCOLMSG_FULLMESSAGE),
                          DVLAT_RAW);

    }

    if (SUCCEEDED(hr)) {

        m_pMessagePoolAllocation = m_MessagePool.Flink;

        InitializeListHead(&m_PlayerContextPool);
        hr = DV_InitializeList(&m_PlayerContextPool,
                          m_lpSessionTransport->GetMaxPlayers(),
                          1,
                          DVLAT_CVOICEPLAYER);

    }


    if (FAILED(hr)) {

        DPVF( 0, "Error buffer pools" );
        FreeBuffers();
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY; 
    }

    DPVF_EXIT();
    return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetupSpeechBuffer"
// SetupSpeechBuffer
//
// This function sets up the buffer pool for speech sends, whose size will
// depend on the compression type.  Must be done after we know CT but 
// before we do first speech transmission.
//
HRESULT CDirectVoiceClientEngine::SetupSpeechBuffer()
{
    ULONG size;
    HRESULT hr;
    DPVF_ENTER();

    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER)
    {
        size = sizeof( DVPROTOCOLMSG_SPEECHHEADER )+s_dwCompressedFrameSize+COMPRESSION_SLUSH;
    }
    else
    {
        size = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) + s_dwCompressedFrameSize + 
            (sizeof( DVID )*CLIENT_POOLS_NUM_TARGETS_BUFFERED)+COMPRESSION_SLUSH;
    }

    InitializeListHead(&m_SpeechBufferPool);
    hr = DV_InitializeList(&m_SpeechBufferPool,
                      m_lpSessionTransport->GetMaxPlayers()*DV_CT_FRAMES_PER_PERIOD,
                      size,
                      DVLAT_RAW);

    if(FAILED(hr))
    {
        DPVF( 0, "Error creating transmit buffers" );
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;
    }

    m_pSpeechBufferAllocation = m_SpeechBufferPool.Flink;

    DPVF_EXIT();
    return DV_OK;

}
  
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::FreeBuffers"
HRESULT CDirectVoiceClientEngine::FreeBuffers()
{

    DPVF_ENTER();

    DV_FreeList(&m_BufferDescPool, DVLAT_RAW);
    DV_FreeList(&m_MessagePool, DVLAT_RAW);
    DV_FreeList(&m_PlayerContextPool, DVLAT_CVOICEPLAYER);
    DV_FreeList(&m_SpeechBufferPool, DVLAT_RAW);

    DV_POOL_FREE(m_pBufferDescAllocation);
    DV_POOL_FREE(m_pMessagePoolAllocation);
    DV_POOL_FREE(m_pSpeechBufferAllocation);

    m_pBufferDescAllocation = NULL;
    m_pMessagePoolAllocation = NULL;
    m_pSpeechBufferAllocation = NULL;
    
    DPVF_EXIT();
    return DV_OK;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CheckConnected"

HRESULT CDirectVoiceClientEngine::CheckConnected()
{

    DPVF_ENTER();
    if(m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not initialized" );
        return DVERR_NOTINITIALIZED;
    }

    if(m_dwCurrentState != DVCSTATE_CONNECTED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not connected" );
        return DVERR_NOTCONNECTED;
    }

    DPVF_EXIT();
    return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvcleng.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvclientengine.h
 *  Content:	Definition of class for DirectXVoice Client
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created it
 * 09/01/2000  georgioc started rewrite for xbox
 ***************************************************************************/

#ifndef __DVCLIENTENGINE_H
#define __DVCLIENTENGINE_H

#include "dvengine.h"
#include "dvtran.h"
#include "frame.h"
#include "inqueue2.h"
#include "dvprot.h"
#include "vnametbl.h"

#include "dvsndt.h"

#define DVCSTATE_NOTINITIALIZED		0x00000000
#define DVCSTATE_IDLE				0x00000001
#define DVCSTATE_CONNECTING			0x00000002
#define DVCSTATE_CONNECTED			0x00000003
#define DVCSTATE_DISCONNECTING		0x00000004
#define DVCSTATE_DISCONNECTED       0x00000005
struct DIRECTVOICECLIENTOBJECT;

// Size in bytes of the fixed size elements
#define DV_CLIENT_NOTIFY_ELEMENT_SIZE	256

#if defined(DEBUG) || defined(DBG)
#define CHECKLISTINTEGRITY			CheckListIntegrity
#else
#define CHECKLISTINTEGRITY()		
#endif

#define VSIG_CLIENTENGINE		'ELCV'
#define VSIG_CLIENTENGINE_FREE	'ELC_'



// CDirectVoiceClientEngine
//
// This class represents the IDirectXVoiceClient interface.
//
//
volatile class CDirectVoiceClientEngine: public CDirectVoiceEngine
{
protected:

    typedef enum { NOTIFY_FIXED,   // Structure stored in fixed
    			   NOTIFY_DYNAMIC  // Memory allocated in dynamic
    			 } ElementType;

    struct CNotifyElement
    {
    	typedef VOID (*PNOTIFY_COMPLETE)(PVOID pvContext, CNotifyElement *pElement);		

    	DWORD			m_dwType;
    	struct _Element
    	{
    		BYTE			Data[DV_CLIENT_NOTIFY_ELEMENT_SIZE];
    	} m_element;

    	DWORD				m_dwDataSize;		
    	PVOID				pvContext;
    	PNOTIFY_COMPLETE	pNotifyFunc;

        __inline void *__cdecl operator new(size_t size)
        {
            return ExAllocatePoolWithTag(size, 'lcvd');
        }

        __inline void __cdecl operator delete(void *pv)
        {
            ExFreePool(pv);
        }

    };

	
public:
	CDirectVoiceClientEngine( DIRECTVOICECLIENTOBJECT *lpObject );
	~CDirectVoiceClientEngine();

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'lcvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }


public: // IDirectXVoiceClient Interface
	HRESULT Connect(LPDVCLIENTCONFIG lpClientConfig, DWORD dwFlags );
	HRESULT Disconnect( DWORD dwFlags );
	HRESULT GetSessionDesc( LPDVSESSIONDESC lpSessionDescBuffer );
	HRESULT GetClientConfig( LPDVCLIENTCONFIG lpClientConfig );
	HRESULT SetClientConfig( LPDVCLIENTCONFIG lpClientConfig );
	HRESULT GetCompressionTypes( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags );
	HRESULT SetTransmitTarget( PDVID dvidTarget, DWORD dwNumTargets, DWORD dwFlags );
	HRESULT GetTransmitTarget( LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags );
    HRESULT CreateSoundTarget( DVID dvidID, PWAVEFORMATEX *ppwfx, XMediaObject **ppMediaObject);
    HRESULT DeleteSoundTarget( DVID dvidID, XMediaObject **ppMediaObject);
	HRESULT SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );
    HRESULT DoWork();

public: // CDirectVoiceEngine Members
	HRESULT Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements );
	BOOL ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize );
	HRESULT StartTransportSession();
	HRESULT StopTransportSession();
	HRESULT AddPlayer( DVID dvID );
	HRESULT RemovePlayer( DVID dvID );
	HRESULT CreateGroup( DVID dvID );
	HRESULT DeleteGroup( DVID dvID );
	HRESULT AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer );

	HRESULT MigrateHost_RunElection();

	inline DWORD GetCurrentState() { return m_dwCurrentState; };	

protected: // Message handlers

	HRESULT InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );

	BOOL QueueSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize );

	BOOL HandleConnectRefuse( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREFUSE lpdvConnectRefuse, DWORD dwSize );
	BOOL HandleCreateVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERJOIN lpdvCreatePlayer, DWORD dwSize );
	BOOL HandleDeleteVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERQUIT lpdvDeletePlayer, DWORD dwSize );
	BOOL HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize );
	BOOL HandleSpeechWithFrom( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHFROM lpdvSpeech, DWORD dwSize );	
	BOOL HandleSpeechBounce( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize );
	BOOL HandleConnectAccept( DVID dvidSource, PDVPROTOCOLMSG_CONNECTACCEPT lpdvConnectAccept, DWORD dwSize );
	BOOL HandleDisconnectConfirm( DVID dvidSource, PDVPROTOCOLMSG_DISCONNECT lpdvDisconnect, DWORD dwSize );
	BOOL HandleSetTarget( DVID dvidSource, PDVPROTOCOLMSG_SETTARGET lpdvSetTarget, DWORD dwSize );
	BOOL HandleSessionLost( DVID dvidSource, PDVPROTOCOLMSG_SESSIONLOST lpdvSessionLost, DWORD dwSize );
	BOOL HandlePlayerList( DVID dvidSource, PDVPROTOCOLMSG_PLAYERLIST lpdvPlayerList, DWORD dwSize );
	BOOL HandleHostMigrated( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATED lpdvHostMigrated, DWORD dwSize );
	BOOL HandleHostMigrateLeave( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATELEAVE lpdvHostMigrateLeave, DWORD dwSize );
	HRESULT HandleLocalHostMigrateCreate();

	friend class CClientRecordSubSystem;

protected:

    HRESULT DoPlaybackWork();
    HRESULT CheckConnected();
	void CheckListIntegrity();

	void DoSessionLost(HRESULT hrReason);
	void DoSignalDisconnect(HRESULT hrDisconnectReason);

	// Actually send the message to the client app
	void TransmitMessage( DWORD dwMessageType, LPVOID lpData, DWORD dwSize );

	void Cleanup();
	void DoDisconnect();
	void DoConnectResponse();
	void WaitForBufferReturns();

	void SetCurrentState( DWORD dwState );

protected:

    //
    // sound related functions
    //

	HRESULT InitializeSoundSystem();
    HRESULT BuildCompressionInfo();
	HRESULT ShutdownSoundSystem();
    VOID SwitchToHalfDuplex();


	void CheckForUserTimeout( DWORD dwCurTime );
#if DVC_ENABLE_PLAYBACK_LEVEL_TRACKING
	VOID SendPlayerLevels();
#endif
	BOOL CheckShouldSendMessage( DWORD dwMessageType );
	
	void UpdateActivePlayPendingList();
	void UpdateActiveNotifyPendingList();
	void CleanupNotifyLists();
	void CleanupPlaybackLists();

	PDVTRANSPORT_BUFFERDESC GetTransmitBuffer( DWORD dwSize, LPVOID *ppvContext, BOOLEAN bUseSpeechPool );
    HRESULT SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete );
    void ReturnTransmitBuffer( PVOID pvContext );

    HRESULT Send_ConnectRequest();
    HRESULT Send_DisconnectRequest();
    HRESULT Send_SessionLost();
    HRESULT Send_SettingsConfirm();

	DWORD						m_dwSignature;

    CFramePool                  *m_lpFramePool;			// Pool of frames
    CDirectVoiceTransport		*m_lpSessionTransport;	// Transport for the session
	DVCLIENTCONFIG				m_dvClientConfig;		// Sound general config
	DVSESSIONDESC				m_dvSessionDesc;		// Session configuration
	LPDVMESSAGEHANDLER			m_lpMessageHandler;		// User message handler
	LPVOID						m_lpUserContext;		// User context for message handler
	DVID						m_dvidServer;			// DVID of the server

	PDVID						m_pdvidTargets;			// DVID of the current target(s) (Protected by m_csTargetLock)
	DWORD						m_dwNumTargets;			// # of targets (Protected by m_csTargetLock)
	DWORD						m_dwTargetVersion;		// Increment each time targets are changed

	HRESULT						InternalSetTransmitTarget( PDVID pdvidTargets, DWORD dwNumTargets );
	HRESULT						CheckForAndRemoveTarget( DVID dvidID );
	
	volatile DWORD    			m_dwCurrentState;		// Current engine state
	CFrame						*m_tmpFrame;			// Tmp frame for receiving
	LPDIRECTPLAYVOICESERVER		m_lpdvServerMigrated;	// Stores reference to migrated host

protected: // user attached sound targets

    HRESULT                     FindSoundTarget(DVID dvidID,
                                                CSoundTarget **lpcsTarget,
                                                CVoicePlayer **ppPlayer);

protected: // Notification queue 

	// Queue up a notification for the user
	HRESULT NotifyQueue_Add( DWORD dwMessageType, LPVOID lpData, DWORD dwDataSize, PVOID pvContext = NULL, CNotifyElement::PNOTIFY_COMPLETE pNotifyFunc = NULL );
	HRESULT NotifyQueue_Free();
	HRESULT NotifyQueue_ElementFree( CNotifyElement *lpElement );
	HRESULT NotifyQueue_IndicateNext();
	void NotifyQueue_Disable();
	void NotifyQueue_Enable();

	static void NotifyComplete_LocalPlayer( PVOID pvContext, CNotifyElement *pElement );
	static void NotifyComplete_RemotePlayer( PVOID pvContext, CNotifyElement *pElement );
    static void NotifyComplete_DeletePlayer(PVOID pvContext, CNotifyElement *pElement );

	BOOL						m_fNotifyQueueEnabled;
	LIST_ENTRY				    m_NotifyList;		// List of notifications

	HRESULT						SendConnectResult();
	HRESULT						SendDisconnectResult();
    VOID                        QueuePlayerLevelNotifications();

protected: 

	HRESULT SetupInitialBuffers();
	HRESULT SetupSpeechBuffer();
	HRESULT FreeBuffers();

protected: // Sound System Information


    CClientRecordSubSystem      *m_RecordSubSystem;       // record subsystem

	DWORD						m_dwEventFlags;		    // bitfield of event flags
	HRESULT						m_hrDisconnectResult;	// Result of the disconnect result
	HRESULT						m_hrConnectResult;		// Result of the connection request
	DVID						m_dvidLocal;			// Local DVID

protected:

    CRITICAL_SECTION            m_CS;
	// Compression Control Data
    XMediaObject               *m_pInBoundAudioConverter;

	CFramePool					*m_pFramePool;			// Frame pool

	DIRECTVOICECLIENTOBJECT		*m_lpObject;			// Cached pointer to the COM interface 

	DWORD 						m_dwSynchBegin;			// GetTickCount at Connect/Disconnect start

	LPDWORD						m_pMessageElements;	// Buffer with notifiers
	DWORD						m_dwNumMessageElements;	// Number of notifiers 

	DWORD						m_dwLastConnectSent;
	DWORD						m_dwHostOrderID;

	PVOID						m_pvLocalPlayerContext;

	BYTE						m_bLastPeak;			// Last frame peak
    BYTE                        m_bLastPlaybackPeak;    // last overall playback peak
	BYTE						m_bMsgNum;				// Last msg # transmitted
	BYTE						m_bSeqNum;				// Last sequence # transmitted
	
	BOOL						m_bLastTransmitted;		// Was last frame sent?
	BOOL						m_fSessionLost;			// Flag indicating session was lost
	BOOL						m_fLocalPlayerNotify;	// Has notification been sent for local player
	BOOL						m_fLocalPlayerAvailable;

    CVoiceNameTable             m_voiceNameTable;

	DWORD                       m_dwPlayActiveCount;
	LIST_ENTRY  				m_PlayActivePlayersList;
	LIST_ENTRY					m_PlayAddPlayersList;

	LIST_ENTRY					m_NotifyActivePlayersList;
	LIST_ENTRY					m_NotifyAddPlayersList;

	LIST_ENTRY     		      m_NotificationElementPool;		// Frame pool for notifications
    LIST_ENTRY                m_BufferDescPool;
    LIST_ENTRY                m_MessagePool;
    LIST_ENTRY                m_SpeechBufferPool;

    LIST_ENTRY                m_PlayerContextPool;

    PVOID                     m_pBufferDescAllocation;
    PVOID                     m_pMessagePoolAllocation;
    PVOID                     m_pSpeechBufferAllocation;


protected:

    DWORD                     m_SpeechBufferAllocs;
    DWORD                     m_MsgBufferAllocs;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvdxtran.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvdxtran.cpp
 *  Content:	Implementation of transport class providing DirectXVoice transport
 *              through the IDirectXVoiceTransport interface.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/23/99		rodtoll	Modified from dvdptran.cpp
 * 08/03/99		rodtoll	Modified to conform to new base class and minor fixes
 *						for dplay integration. 
 * 08/04/99		rodtoll	Modified to allow group targets
 * 08/10/99		rodtoll	Removed TODO pragmas
 * 08/25/99		rodtoll	Fixed group membership check
 * 08/30/99		rodtoll	Modified SendToServer to send to the server player in 
 *						client/server sessions.
 * 08/31/99		rodtoll	Updated to use new debug libs
 * 09/01/99		rodtoll	Updated so that constructor no longer calls into dplay
 * 				rodtoll	Added check for valid pointers in func calls  
 * 09/02/99		rodtoll	Added checks to handle case no local player created 
 * 09/20/99		rodtoll	Added memory alloc failure checks 
 * 09/21/99		rodtoll	Fixed memory leak
 * 10/05/99		rodtoll	Additional comments and DPF_MODNAMEs
 * 11/23/99		rodtoll	Split CheckForValid into Group and Player
 * 12/16/99		rodtoll Bug #122629 - As part of new host migration update how
 *						sends to server before first response are sent.
 * 01/14/2000	rodtoll	Renamed SendToID to SendToIDS and updated parameter list
 *						to accept multiple targets.
 *				rodtoll	Added GetNumPlayers call
 * 01/17/2000	rodtoll	Debug statement removed that limited max players to 30
 * 03/28/2000   rodtoll Moved nametable from here to upper level classes
 *              rodtoll Removed uneeded functions/members 
 * 04/07/2000   rodtoll Updated to support new DP <--> DPV interface
 *              rodtoll Updated to support no copy sends
 *              rodtoll Bug #32179 - Prevent multiple client/server registrations on transport 
 * 06/21/2000	rodtoll Bug #36820 - Host migrates to wrong client when client/server are on same interface
 *						Condition exists where host sends leave message, client attempts to start new host
 *						which fails because old host still registered.  Now deregistering is two step
 *						process DisableReceiveHook then DestroyTransport.  
 * 07/22/20000	rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  Now ensures that all threads from transport have left and that
 *					  all notificatinos have been processed before shutdown is complete.  
 *						
 ***************************************************************************/

#include "dvntos.h"
#include "in_core.h"
#include "dvdxtran.h"


//#pragma warning( disable : 4786 )  



#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::CDirectVoiceDirectXTransport"
CDirectVoiceDirectXTransport::CDirectVoiceDirectXTransport( LPDIRECTPLAYVOICETRANSPORT lpTransport
	):  m_lpTransport(NULL),
		m_dpidServer(DPNID_ALL_PLAYERS_GROUP),
		m_dpidLocalPlayer(0),
		m_bLocalServer(TRUE),
		m_bActiveSession(TRUE),
		m_dwTransportFlags(0),
		m_lpVoiceEngine(NULL),
		m_dwMaxPlayers(0),
		m_initialized(FALSE),
		m_dwObjectType(0),
		m_fAdvised(FALSE)
{

    lpTransport->AddRef();
    m_lpTransport = lpTransport;

	m_dvTransportInfo.dwSize = sizeof( DVTRANSPORTINFO );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::~CDirectVoiceDirectXTransport"
CDirectVoiceDirectXTransport::~CDirectVoiceDirectXTransport()
{
	if( m_lpTransport != NULL )
		m_lpTransport->Release();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DestroyTransport"
// DestroyTransport
//
// This method is used to remove last references to transport that transport 
// layer has.  There was a memory leak where 
//
// 
void CDirectVoiceDirectXTransport::DestroyTransport()
{

	if( m_lpTransport != NULL )
	{
		m_lpTransport->Release();
		m_lpTransport = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::Initialize"
//
// Initialize
//
// Called from the transport when Advise is called.
//
// Used to initialize this object.
//
HRESULT CDirectVoiceDirectXTransport::Initialize(  )
{
	HRESULT hr = DV_OK;
	hr = m_lpTransport->GetSessionInfo( &m_dvTransportInfo );
	if( FAILED( hr ) )
	{
		DPVF( 0, "DXVT::Initialize: GetSessionInfo() failed!  hr=0x%x", hr );
		return hr;
	}

	m_dwMaxPlayers = (m_dvTransportInfo.dwMaxPlayers==0) ? DV_MAX_REMOTE_PLAYERS : m_dvTransportInfo.dwMaxPlayers;
    ASSERT(m_dwMaxPlayers <= DV_MAX_REMOTE_PLAYERS);

	m_dpidLocalPlayer = m_dvTransportInfo.dvidLocalID;

//  No longer needed, the server may not bee the host of the dplay session
//	m_dpidServer = m_dvTransportInfo.dvidSessionHost;
	m_dpidServer = DPNID_ALL_PLAYERS_GROUP;

	m_initialized = TRUE;
	
    //
    // add one ref count on our selfs.. DisableReceivHook will release it
    //

    AddRef();


	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::GetMaxPlayers"
DWORD CDirectVoiceDirectXTransport::GetMaxPlayers( )
{
	return m_dwMaxPlayers;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendHelper"
HRESULT CDirectVoiceDirectXTransport::SendHelper( PDVID pdpidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	HRESULT hr=DV_OK;
    PAGED_CODE();

    if( dwNumTargets > 1 )
    {
#if DBG
        for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ ) { 
            DPVF( DPVF_SEND_DEBUG_LEVEL, "Using multitargetted send [From=0x%x To=0x%x]", m_dpidLocalPlayer, pdpidTargets[dwIndex] );	
        }
#endif
        hr = m_lpTransport->SendSpeechEx( m_dpidLocalPlayer, dwNumTargets, pdpidTargets, pBufferDesc, pvContext, dwFlags );		
    }
    else
    {

        DPVF( DPVF_SEND_DEBUG_LEVEL, "Single target for send [From=0x%x To=0x%x]", m_dpidLocalPlayer, pdpidTargets[0] );
        hr = m_lpTransport->SendSpeech( m_dpidLocalPlayer, *pdpidTargets, pBufferDesc, pvContext, dwFlags );
    }

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendToServer"
HRESULT CDirectVoiceDirectXTransport::SendToServer( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
    PAGED_CODE();
	if( m_dvTransportInfo.dwSessionType == DVTRANSPORT_SESSION_CLIENTSERVER )
	{
		DVID dvidTmp = DVID_SERVERPLAYER;

		DPVF( DPVF_SEND_DEBUG_LEVEL, "Sending to standard server player" );
		return SendHelper( &dvidTmp, 1, pBufferDesc, pvContext, dwFlags );
	}
	else
	{
		DPVF( DPVF_SEND_DEBUG_LEVEL, "Sending to server ID [ID=0x%x]", m_dpidServer );
		return SendHelper( &m_dpidServer, 1, pBufferDesc, pvContext, dwFlags );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendToIDS"
HRESULT CDirectVoiceDirectXTransport::SendToIDS( PDVID pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	return SendHelper( pdvidTargets, dwNumTargets, pBufferDesc, pvContext, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendToAll"
HRESULT CDirectVoiceDirectXTransport::SendToAll( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	DVID dvidTmp = DPNID_ALL_PLAYERS_GROUP;
	return SendHelper( &dvidTmp, 1, pBufferDesc, pvContext, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmValidGroup"
BOOL CDirectVoiceDirectXTransport::ConfirmValidGroup( DVID dvid )
{
    PAGED_CODE();
	if( dvid == DVID_ALLPLAYERS )
	{
		return TRUE;
	}
	else if( m_dvTransportInfo.dwSessionType == DVTRANSPORT_SESSION_CLIENTSERVER )
	{
		return TRUE;
	}
	else 
	{
		BOOL fResult;
		HRESULT hr;
		hr = m_lpTransport->IsValidGroup( dvid, &fResult );

		if( FAILED( hr ) )
		{
			DPVF( DPVF_ERRORLEVEL, "Error confirming valid group hr=0x%x", hr );
			return FALSE;
		}
		else
		{
			return fResult;
		}
	}	

	return FALSE;
	
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DoWork"
VOID CDirectVoiceDirectXTransport::DoWork( )
{

    m_lpTransport->DoWork(0);

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmValidEntity"
//
// ConfirmValidEntity
//
// Checks to ensure that the ID passed is a valid one for the session.
//
// Will return TRUE if the player iD is one of:
// DVID_ALLPLAYERS, DVID_NOTARGET, (any value in client/server mode),
// a player in the map, or a valid Transport group.
//
BOOL CDirectVoiceDirectXTransport::ConfirmValidEntity( DVID dvid )
{
    PAGED_CODE();
	if( m_dvTransportInfo.dwSessionType == DVTRANSPORT_SESSION_CLIENTSERVER )
	{
		return TRUE;
	}
	else 
	{
		BOOL fResult;
		m_lpTransport->IsValidEntity( dvid, &fResult );
		return fResult;

	}

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::EnableReceiveHook"
//
// EnableReceiveHook
//
// This is used to activate the connection between the transport
// and the transport class.
//
// We call advise, which will cause Initialize to be called on this
// class before we return from Advise.
//
HRESULT CDirectVoiceDirectXTransport::EnableReceiveHook( LPDIRECTVOICEOBJECT dvObject, DWORD dwObjectType )
{
	HRESULT hr;
	
    PAGED_CODE();
	m_lpVoiceEngine = dvObject->lpDVEngine;
	m_dwObjectType = dwObjectType;

	// The transport will call Initialize on our notification interface
	// before returning from this function.
	//
	// Once we've returned from this function we should be ok.
	//// BUGBUG: Should not just cast this, should do a QueryInterface
	hr = m_lpTransport->Advise( (LPUNKNOWN) &dvObject->dvNotify, m_dwObjectType );	

	if( FAILED( hr ) )
	{
		DPVF( DPVF_ERRORLEVEL, "Advise failed.  hr=0x%x", hr );
		m_fAdvised = FALSE;
	}
	else
	{
		m_fAdvised = TRUE;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::WaitForDetachCompletion"
HRESULT CDirectVoiceDirectXTransport::WaitForDetachCompletion()
{
    ULONG cnt = 0;
    DPVF_ENTER();
    PAGED_CODE();
	DPVF( DPVF_WARNINGLEVEL, "# of threads remaining: %d", m_lRefCount );

	// Loop until all threads are done inside our layer
	while( m_lRefCount > 0 ){	

        Sleep( 5 );	
        cnt++;

        //
        // call dplay do work..
        //

        m_lpTransport->DoWork(0);

        //
        // bugbug we cant really wait for threads here since the DplayDoWork
        // is not being called while we are in here...
        //

        if (cnt > 200) {
            break;
        }
    }
		

    DPVF( DPVF_INFOLEVEL, "threads gone");
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DisableReceiveHook"
//
// DisableReceiveHook
//
// Removes the hooks into the transport and releases the interface
// reference this object holds for the transport.
//
// Also responsible for destroying the list of players maintained
// by this object.
//
HRESULT CDirectVoiceDirectXTransport::DisableReceiveHook( )
{
    PAGED_CODE();
	if( m_fAdvised )
	{
		m_lpTransport->UnAdvise( m_dwObjectType );

		m_fAdvised = FALSE;
		m_initialized = FALSE;		

        Release();

		DPVF( DPVF_SPAMLEVEL, "Unhooking Transport" );
	}

	// When this is done no more indications will be waiting.  	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmLocalHost"
BOOL CDirectVoiceDirectXTransport::ConfirmLocalHost( )
{
    HRESULT hr;
    PAGED_CODE();

	if( !m_initialized ) {

        hr = Initialize();

        if (FAILED(hr)) {
            ASSERT(FALSE);
            return FALSE;
        }

    }
		
	
	if( m_dvTransportInfo.dwFlags & DVTRANSPORT_LOCALHOST )
		return TRUE;
	else
		return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmSessionActive"
BOOL CDirectVoiceDirectXTransport::ConfirmSessionActive( )
{
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::GetTransportSettings"
HRESULT CDirectVoiceDirectXTransport::GetTransportSettings( LPDWORD lpdwSessionType, LPDWORD lpdwFlags )
{
	HRESULT hr = DV_OK;
	
    PAGED_CODE();
	if( !m_initialized )
		hr = Initialize();

	if( FAILED( hr ) )
	{
		DPVF( DPVF_ERRORLEVEL, "Unable to retrieve transport settings" );
		return hr;
	}

	*lpdwSessionType = m_dvTransportInfo.dwSessionType;
	*lpdwFlags = m_dvTransportInfo.dwFlags;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::AddPlayerEntry"
HRESULT CDirectVoiceDirectXTransport::AddPlayerEntry( DVID dvidPlayer, LPVOID lpData )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DeletePlayerEntry"
HRESULT CDirectVoiceDirectXTransport::DeletePlayerEntry( DVID dvidPlayer )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::GetPlayerEntry"
//
// GetPlayerEntry
//
// Retrieves the player record for the specified player (if it exists).
//
HRESULT CDirectVoiceDirectXTransport::GetPlayerEntry( DVID dvidPlayer,  CVoicePlayer **lplpPlayer )
{
	return DVERR_NOTSUPPORTED;
}


////////////////////////////////////////////////////////////////////////
//
// USEFUL FOR REMOTE VOICE SESSIONS
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::CreateGroup"
HRESULT CDirectVoiceDirectXTransport::CreateGroup( LPDVID dvidGroup )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DeleteGroup"
HRESULT CDirectVoiceDirectXTransport::DeleteGroup( DVID dvidGroup )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::AddPlayerToGroup"
HRESULT CDirectVoiceDirectXTransport::AddPlayerToGroup( LPDVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::RemovePlayerFromGroup"
HRESULT CDirectVoiceDirectXTransport::RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::IsPlayerInGroup"
BOOL CDirectVoiceDirectXTransport::IsPlayerInGroup( DVID dvidGroup, DVID dvidPlayer )
{
    PAGED_CODE();
	if( dvidGroup == DVID_ALLPLAYERS )
	{
		return TRUE;
	}

	if( dvidGroup == dvidPlayer )
	{
		return TRUE;
	}
	return (m_lpTransport->IsGroupMember( dvidGroup, dvidPlayer )==DV_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::MigrateHost"
//
// MigrateHost
//
// Updates server DPID to match new host
//
HRESULT CDirectVoiceDirectXTransport::MigrateHost( DVID dvidNewHost )
{
	m_dpidServer = dvidNewHost;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::MigrateHost"
DVID CDirectVoiceDirectXTransport::GetLocalID() 
{ 
    m_dwDuumy = m_dpidLocalPlayer;
    return m_dpidLocalPlayer; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvntos.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvntos.h
 *  Content:	kernel defs
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/01/2000  georgioc 
 *
 ***************************************************************************/

#ifndef __DVNTOS_H
#define __DVNTOS_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define  NODSOUND
#include <xtl.h>
#include <xdbg.h>
#include "initguid.h"
#include <dsoundp.h>

#include "dplay8.h"
//#include "..\..\core\dncorei.h"

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))


class CDVAutoLock
{
private:
    CRITICAL_SECTION        *m_pCS;

public:
    CDVAutoLock(CRITICAL_SECTION *pCS);
    ~CDVAutoLock(void);
};

__inline CDVAutoLock::CDVAutoLock(CRITICAL_SECTION *pCS)
{
    m_pCS = pCS;
    EnterCriticalSection(pCS);
}

__inline CDVAutoLock::~CDVAutoLock(void)
{
    LeaveCriticalSection(m_pCS);
}

#define DV_AUTO_LOCK(pCS) \
    CDVAutoLock __AutoLock(pCS)


#define ENTER_CS(pCS) {\
    EnterCriticalSection(pCS);\
}

#define LEAVE_CS(pCS) {\
    LeaveCriticalSection(pCS);\
}

#define RIRQL(irql) { \
    irql = KeRaiseIrqlToDpcLevel();\
    }

#define LIRQL(irql) { \
    KeLowerIrql(irql); \
    }

#define DV_DISPATCH_CODE {ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);}

__inline void *__cdecl DV_POOL_ALLOC(size_t size)
{
    return ExAllocatePoolWithTag(size, '__vd');
}

__inline void __cdecl DV_POOL_FREE(void *pv)
{
    ExFreePool(pv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvdxtran.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvdxtran.h
 *  Content:	Definition of transport class providing DirectXVoice transport
 *              through the IDirectXVoiceTransport interface.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/23/99		rodtoll	Modified from dvdptran.h
 * 09/01/2000   georgioc started rewrite/port to xbox
 ***************************************************************************/
#ifndef __DVDPTRANSPORT_H
#define __DVDPTRANSPORT_H

#include "dvntos.h"
#include "dvtran.h"

// CDirectVoiceDirectXTransport
//
// Implements the transport system using the IDirectXVoiceTransport
// interface that will be implemented by both DirectPlay and 
// DirectNet.
//
// This class handles the interaction between an DirectPlayVoice engine
// and the transport level.
// 
volatile class CDirectVoiceDirectXTransport : public CDirectVoiceTransport
{
public:
	CDirectVoiceDirectXTransport( LPDIRECTPLAYVOICETRANSPORT lpTransport );
	~CDirectVoiceDirectXTransport();

	HRESULT Initialize();

public:
	HRESULT AddPlayerEntry( DVID dvidPlayer, LPVOID lpData );
	HRESULT DeletePlayerEntry( DVID dvidPlayer );
	HRESULT GetPlayerEntry( DVID dvidPlayer, CVoicePlayer **lplpPlayer );
	HRESULT MigrateHost( DVID dvidNewHost );	

	DWORD GetMaxPlayers( );

	inline LPDIRECTPLAYVOICETRANSPORT GetTransportInterface( ) { return m_lpTransport; };

    DVID GetLocalID();
	inline DVID GetServerID() { return m_dpidServer; };

public:
	HRESULT SendToServer( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags );
	HRESULT SendToAll( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags );
	HRESULT SendToIDS( PDVID pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags );

public: // Remote Server Synchronization functions
	HRESULT CreateGroup( LPDVID dvidGroup );
	HRESULT DeleteGroup( DVID dvidGroup );
	HRESULT AddPlayerToGroup( LPDVID dvidGroup, DVID dvidPlayer ); 
	HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer );
	BOOL ConfirmValidEntity( DVID dvid );
	BOOL ConfirmValidGroup( DVID dvid );
	BOOL ConfirmLocalHost( );
	BOOL ConfirmSessionActive();
    VOID DoWork();
	BOOL IsPlayerInGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT GetTransportSettings( LPDWORD lpdwSessionType, LPDWORD lpdwFlags );

	HRESULT EnableReceiveHook( LPDIRECTVOICEOBJECT dvObject, DWORD dwObjectType );
	HRESULT DisableReceiveHook(  );
	HRESULT WaitForDetachCompletion( );	
	void DestroyTransport( );

	// Debug / Test Only
	//HRESULT SetInfo( DPID dpidServer, DPID dpidClient );

protected:
	HRESULT SendHelper( PDVID pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, DWORD dwFlags );

protected:
	LPDIRECTPLAYVOICETRANSPORT m_lpTransport;		// Transport interface 
	DPNID m_dpidServer;								// DPID of the session host
	BOOL m_bLocalServer;							// Is the host on same interface as the client
	BOOL m_bActiveSession;							// Is there a session active on the transport
	DWORD m_dwTransportFlags;						// Flags describing the session
	CDirectVoiceEngine *m_lpVoiceEngine;			// Engine this transport is working for
	DWORD m_dwMaxPlayers;							// Maximum # of players this session can have
	BOOL  m_initialized;							// Has this object been initialized?
			
	DVTRANSPORTINFO m_dvTransportInfo;				// Information about the transport
	DPNID m_dpidLocalPlayer;							// DPID of the local client	
	DWORD m_dwDuumy;
	DWORD m_dwObjectType;

	BOOL	m_fAdvised;

	LIST_ENTRY m_PlayerList;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvrecsub.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ClientRecordSubSystem.h
 *  Content:	Recording sub-system.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/19/99		rodtoll	Modified from original
 * 09/01/2000  georgioc started rewrite for xbox
 ***************************************************************************/
#ifndef __CLIENTRECORDSUBSYSTEM_H
#define __CLIENTRECORDSUBSYSTEM_H
#include "dvcleng.h"
#include "va.h"

// CClientRecordSubSystem
//
// This class implements the recording subsystem for the BattleCom client.
// It works closely with the control CShadowClientControl object to 
// provide the recording / compression and transmissions portions of the
// client.  This includes addition of microphone clicks to outgoing
// audio streams when appropriate.
//
// The core of the recording system is a finite state machine which 
// is used to provide a way of managing the recording system's
// state and to provide smooth transitions between various 
// states.  
//
// It looks to the CShadowClientControl object to detect when keys
// are pressed and to provide neccessary parameters.
//
#define VSIG_CLIENTRECORDSYSTEM			'SRCV'
#define VSIG_CLIENTRECORDSYSTEM_FREE	'SRC_'
//


VOID DV_RecordSubSystemPacketCompletion(
    PVOID pThis,
    PVOID pContext,
    DWORD dwStatus);

class CClientRecordSubSystem
{
protected: // State Machine States
    typedef enum {
        RECORDSTATE_NOTSTARTED = 0, // we have not attached packets to hawk yet
        RECORDSTATE_IDLE,   	// Recording is idle, no transmissions required
        RECORDSTATE_VA,			// Voice activated mode
        RECORDSTATE_PTT			// Push to talk mode
    } RecordState;

public:
    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'srvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

    CClientRecordSubSystem( CDirectVoiceClientEngine *clientEngine );
    ~CClientRecordSubSystem();

    LIST_ENTRY                 m_PendingList;
    LIST_ENTRY                 m_CompletedList;

protected:

	friend class CDirectVoiceClientEngine;

	HRESULT Initialize();

	BOOL IsMuted();
	BOOL IsValidTarget();
    inline BOOL IsPTT() { return !IsVA(); };
    inline BOOL IsVA() { return (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED || m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED); };
    
    BOOL CheckVA();
    void EndMessage();
    void StartMessage();

    HRESULT TransmitFrame(PDVMEDIAPACKET pBuffer);

    void static PacketCompletion(PVOID Context);    // callback from hawk driver


protected: // FSM
	HRESULT BuildAndTransmitSpeechHeader(PDVMEDIAPACKET pBuffer);
	HRESULT BuildAndTransmitSpeechWithTarget(PDVMEDIAPACKET pBuffer);
    HRESULT RecordFSM();

protected: 

	DWORD					m_dwSilentTime;			// # of ms that the input has been silent
    DWORD					m_dwSilenceTimeout;  	// # of ms that the input has been silent
	DWORD					m_dwFrameTime;			// Amount of ms per frame
	CVoiceActivation1*		m_pVa;				    // Auto Gain control and Voice Activation algorithm

	void					DoFrameCheck();
	
protected:

    RecordState             m_recordState;          // Current state of the FSM
    XMediaObject            *m_pConverter;          // AudioConverter for outgoing data
    PWAVEFORMATEX           m_pwfxConverter;
    WAVEFORMATEX            m_wfxCapture;

    XMediaObject            *m_pCaptureMediaObject; // hawk xmo  

    CDirectVoiceClientEngine *m_clientEngine;       // The client engine this subsystem is for
    BOOL                    m_transmitFrame;        // Transmit Current frame?
	BOOL					m_lastFrameTransmitted; 
                                                    // Was the last frame transmitted
	unsigned char			m_msgNum;               // Current message number 
	unsigned char			m_seqNum;               // Current sequence #    	

    PVOID                   m_pMediaPacketBuffer;
	DWORD					m_dwCurrentPower;		// Power level of the last packet
	DWORD					m_dwLastTargetVersion;	// Version of target info on last frame (to check for changes)
	DWORD					m_dwResetCount;
	DWORD					m_dwNumSinceRestart;
	DWORD					m_dwLastFrameTime;		// GetTickCount() at last frame
	DWORD                   m_dwFrameCount;
    DWORD                   m_dwPort;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvprotocol.h
 *  Content:	Defines structures / types for DirectXVoice protocol
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/02/99	rodtoll	Created It
 *  07/21/99	rodtoll Added settings confirm message to protocol
 *  08/18/99	rodtoll	Changed the message type to a BYTE
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *  09/07/99	rodtoll	Moved definition of settarget message to dvoice.h
 *  09/30/99	rodtoll	Updated to include more comments
 *  12/16/99	rodtoll	Updated to include new messages used by host migration
 *						and update protocol number
 *  01/14/2000	rodtoll	Updated with new speech packets which optimize peer
 *						to peer and allow multiple targets in multicast/mixing
 *						and updated protocol number.
 *  04/07/2000  rodtoll Code cleanup, proper structure defs
 *
 ***************************************************************************/

#ifndef __DVPROTOCOL_H
#define __DVPROTOCOL_H

#include "dvoicep.h"

#pragma pack(push,1)

//// BUGBUG: Need to check for version info.

// DVPROTOCOL_VERSION_XXXXXX
//
// These are the values developers should use to send in the ucVersionMajor
// ucVersionMinor and dwVersionBuild (respectively) members of the ConnectRequest
// and connect accept messages.
#define DVPROTOCOL_VERSION_MAJOR			1
#define DVPROTOCOL_VERSION_MINOR			0
#define DVPROTOCOL_VERSION_BUILD			3

//
// PROTOCOL DESCRIPTION
//
// Connection Process
// ------------------
//
// Clients connect to the voice session by sending a DVPROTOCOLMSG_CONNECTREQUEST.  
// The host then determines if the client is allowed to join the session.  If
// the client's request is rejected, the client receives a DVPROTOCOLMSG_CONNECTREFUSE.
// If the client's request is accepted, the client receives a 
// DVPROTOCOLMSG_CONNECTACCEPT.  This packet contains all the information the client 
// requires to determine if they are compatible.  
// 
// The client will then attempt to initialize themselves using the compression
// type transmitted by the server.  If the client fails to initialize it takes
// no further action.  If the client initializes succesfully it transmits a
// DVPROTOCOLMSG_SETTINGSCONFIRM message and is added to the session.  All players 
// in the session will then receive a DVPROTOCOLMSG_PLAYERJOIN.
//
// Until a DVPROTOCOLMSG_SETTINGSCONFIRM message is received by the host, the client is 
// not considered to be part of the session.  As such it will not transmit 
// speech.  (However, it may receive speech).
//
// The server then sends DVPROTOCOLMSG_PLAYERLIST message(s) to give the client the
// current player table.  (Peer to peer only).
//
// Disconnection Process
// ---------------------
//
// If a client wishes to disconnect from the voice session, it sends a 
// DVPROTOCOLMSG_DISCONNECT message to the host.  The host will then transmit
// to all players  a DVPROTOCOLMSG_PLAYERQUIT message and will send a 
// DVPROTOCOLMSG_DISCONNECT message back to the player to confirm.
//
// If the client disconnects unexpectedly the voice host will detect this and 
// will automatically send DVPROTOCOLMSG_PLAYERQUIT messages to all the other clients 
// in the session. 
//
// Speech Messages
// ---------------
//
// Speech messages are described in detail in the description for DVPROTOCOLMSG_SPEECH.
//
// Messages sent from the host are sent with the DVMSGID_SPEECHBOUNCE instead 
// of DVMSGID_SPEECH so that whena host and client share a single dplay id 
// the client can ignore it's own speech packets. 
// 
// Host Migration
// --------------
//
// NEW HOST MIGRATION
//
// Pros/Cons:
//
// First, the advantages to the new system:
// - The new host migration mechanism allows DirectPlay Voice to have a host 
// -  seperate from the directplay host.
// - Shutting down the host without stopping the dplay interface causes voice host 
//   to migrate.
// - Minimizes changes to directplay.
// - Removes requirement that all clients had to run voice clients.  
// - You can prevent the host from migrating when you call stopsession by 
//   specifying the new DVFLAGS_NOHOSTMIGRATE which causes the session to be 
//   stopped.
//
// Disadvantages of the new system:
// - If there are no voice clients in the session when the host is lost, then the 
// voice session will be lost.
// 
// Host Election
// 
// In order to elect a new host, each client is given a "Host Order ID" when 
// they have completed their connection.  All clients are informed of an 
// individual's "Host Order ID" when they find out about the player.  These 
// identifiers start at 0, are a DWORD in size, and are incremented with each 
// new user.  Therefore the first player in the session will have ID 0, the 
// second will have ID 1, etc.
//
// By using this method we ensure that the client elected to be the host will be 
// the oldest client in the session.  This has the advantage (because of the way 
// the name table is distributed) if any client has any clients at all, they 
// will have the oldest clients.  Therefore everyone in the session will either 
// have just themselves, or at the very least the client who will become the new 
// host.  If a client doesn't have anyone in the session, it means they either 
// are the only ones in the session (in which case they become the new host) or 
// they haven't received the name table yet.  If they haven't received the name 
// table they will not yet have a "Host Order ID" and will therefore be 
// inelligable to become the new host.
//
// When the host migrates to a new host, the new host offsets a constant (in 
// this case defined in dvcleng.cpp as DVMIGRATE_ORDERID_OFFSET) from it's own 
// Host Order ID and uses it as the next Host Order ID to hand out.  (So 
// duplicate host order IDs are not handed out).
//
// Unless.. you get DVMIGRATE_ORDERID_OFFSET connects between when the new host 
// joined and a new player joins before a player with a higher ID joins.  (If a 
// player informs the server that it's Host Order ID is > then the seed the host 
// bumps the seed to be DVMIGRATE_ORDERID_OFFSET from the user's value).  In 
// this case you may end up with > 1 host.  (But this case is extremely unlikely).
//
// How It's Implemented
//
// Each client in the session knows the DPID of the host.  Therefore, to detect 
// the situation where the host will migrate the client looks at if the session 
// supports host migration and for one of two things: 
//
// - A DVPROTOCOLMSG_HOSTMIGRATELEAVE message - This is sent by the host when StopSession (
//   without the DVFLAGS_NOHOSTMIGRATE flag) or Release is called. 
// - DirectPlay informs DirectPlay Voice that the player ID belonging to the 
//   session host has left the session.
//
// Once one of the above occurs, each clients runs the new host election 
// algorithm.  Their action will depend on the situation:
//
// - If no clients are found that are elligible to become the new host.  Then the 
//   client will disconnect.
// - If clients are found that are elligible to become the new host but it is not 
//   the local client, the local client takes no action.
// - If the local client is to be the new host then it starts up a new host locally.
//
// Once the new host starts up, it will send a DVPROTOCOLMSG_HOSTMIGRATE message to all 
// the users in the session.  Each client in the session responds with their 
// current settings using a DVPROTOCOLMSG_SETTINGSCONFIRM message (which includes the 
// client's current "Host Order ID".  Using these messages the new host rebuilds 
// the player list.  Also, in response to the DVPROTOCOLMSG_SETTINGSCONFIRM message each 
// client receives a copy of the latest name table.  For players who respond to 
// the host migration after you, DVPROTOCOLMSG_CREATEVOICEPLAYER messages will be sent.  
// This player ensures that every client ends up with a proper and up to date 
// name table.  
//
// Each client in the session ignores duplicate CREATEVOICEPLAYER messages.  
// 
// The client object that creates the new host holds a reference to the new host 
// and will destroy it when the client is destroyed.  (Possibly causing the host 
// to migrate again).  
//
// Session Losses
//
// Using this new scheme it is possible to lose the voice session if there are 
// no voice clients elligeble to become the new voice host.  (Meaning there are 
// no clients properly connected).  All clients which are not yet completed 
// their connection will detect this situation and will disconnect from the 
// session.
//
// In addition, when the host goes to stop, it checks to see if there are any 
// clients elligeble to become the host.  If there are none it transmits a 
// DVPROTOCOLMSG_SESSIONLOST message to all players in the session.  
//
// Notes:
//
// One thing to watch for is since the DirectPlayVoice host may migrate to a 
// different client then the DirectPlay host does, just because you know who the 
// DirectPlay Host is doesn't mean you know who the voice host is.
//
// In order to implement this new mechanism the following related changes were 
// made:
//
// - Clients with differing major/minor/build protocol version numbers are 
//   rejected by the host now.  The result is that new clients may be able to 
//   connect to old hosts but may crash, and old clients are now rejected by new 
//   hosts.  (Handling of these cases on old clients was not good -- just don't do 
//   it).
// - DirectPlay host migration messages are ignored.
// - Connection requests are sent to everyone in the session.  The client 
//   determines who the host is by seeing who responded to their message.  
// - Handling of rejection messages now results in the connection failing.  (There 
//   was a bug).
// - The rejection message now contains the major/minor/build protocol version of 
//   the host.
// - Instead of sending individual messages for each user in the current session 
//   to a client when it first joins the host now sends a DVPROTOCOLMSG_PLAYERLIST which 
//   is a list of players in the session.  This reduces bandwidth and makes the 
//   connection process shorter.  

/////////////////////////////////////////////////////////////////////////////////
//
// PROTOCOL SPECIFIC DEFINES
//
/////////////////////////////////////////////////////////////////////////////////

// The maximum size in bytes that a single playerlist packet can be.
//
// (Holds about 120 entries / packet).
//
#define DVPROTOCOL_PLAYERLIST_MAXSIZE	1000

#define DVPROTOCOL_HOSTORDER_INVALID	0xFFFFFFFF

// DVMIGRATE_ORDERID_OFFSET
//
// This is the number to add to this client's Host Order ID to be the
// next value handed out by the host which the client is creating in
// response to host migration.
//
#define DVMIGRATE_ORDERID_OFFSET				256


/////////////////////////////////////////////////////////////////////////////////
//
// MESSAGE IDENTIFIERS
//
/////////////////////////////////////////////////////////////////////////////////

#define DVMSGID_INTERNALBASE		0x0050

#define DVMSGID_CONNECTREQUEST		DVMSGID_INTERNALBASE+0x0001
#define DVMSGID_CONNECTREFUSE		DVMSGID_INTERNALBASE+0x0003
#define DVMSGID_DISCONNECT			DVMSGID_INTERNALBASE+0x0004
#define DVMSGID_SPEECH				DVMSGID_INTERNALBASE+0x0005
#define DVMSGID_CONNECTACCEPT		DVMSGID_INTERNALBASE+0x0006
#define DVMSGID_SETTINGSCONFIRM		DVMSGID_INTERNALBASE+0x0008
#define DVMSGID_SETTINGSREJECT		DVMSGID_INTERNALBASE+0x0009
#define DVMSGID_DISCONNECTCONFIRM	DVMSGID_INTERNALBASE+0x000A
#define DVMSGID_SPEECHBOUNCE		DVMSGID_INTERNALBASE+0x0010
#define DVMSGID_PLAYERLIST			DVMSGID_INTERNALBASE+0x0011
#define DVMSGID_HOSTMIGRATELEAVE	DVMSGID_INTERNALBASE+0x0012
#define DVMSGID_SPEECHWITHTARGET	DVMSGID_INTERNALBASE+0x0013
#define DVMSGID_SPEECHWITHFROM		DVMSGID_INTERNALBASE+0x0014

/////////////////////////////////////////////////////////////////////////////////
//
// CONNECT MESSAGES
//
/////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_CONNECTREQUEST
//
// Session Types: ALL
// Message Flow : Voice Client -> Voice Host
//
// Requests a connection to the existing DirectXVoice session.
//
typedef struct _DVPROTOCOLMSG_CONNECTREQUEST
{
	BYTE	dwType;				// = DVMID_CONNECTREQUEST
	BYTE	ucVersionMajor;		// Client's protocol version (major)
	BYTE	ucVersionMinor;		// Client's protocol version (minor)
	DWORD	dwVersionBuild;		// Client's protocol version (build)
} DVPROTOCOLMSG_CONNECTREQUEST, *PDVPROTOCOLMSG_CONNECTREQUEST;

//
// DVPROTOCOLMSG_CONNECTREFUSE
//
// Session Types: ALL
// Message Flow : Voice Host -> Voice Clients
//
// Server responds with this if no voice session available or needs
// to refuse the connection.  E.g. out of memory or incompatible 
// version.
//
typedef struct _DVPROTOCOLMSG_CONNECTREFUSE
{
	BYTE	dwType;				// = DVMSGID_CONNECTREFUSE
	HRESULT hresResult;			// Reason for refusal (DVERR_XXXXXX)
	BYTE	ucVersionMajor;		// Server's protocol version (major)
	BYTE	ucVersionMinor;		// Server's protocol version (minor)
	DWORD	dwVersionBuild;		// Server's protocol version (build)
} DVPROTOCOLMSG_CONNECTREFUSE, *PDVPROTOCOLMSG_CONNECTREFUSE;

//
// DVPROTOCOLMSG_CONNECTACCEPT
//
// Session Types: ALL
// Message Flow : Voice Host -> Voice Clients
//
// Indicates to the client that their connect request was accepted.
// This message contains information about the voice session that
// the client needs to initialize.
//
typedef struct _DVPROTOCOLMSG_CONNECTACCEPT
{
	BYTE			dwType;				// = DVMSGID_CONNECTACCEPT
	DWORD			dwSessionType;		// Type of session = DVSESSIONTYPE_XXXXXX
	BYTE			ucVersionMajor;		// Server's protocol version (major)
	BYTE			ucVersionMinor;		// Server's protocol version (minor)
	DWORD			dwVersionBuild;		// Server's protocol version (build)
	DWORD			dwSessionFlags;		// Flags for the session (Combination of DVSESSION_XXXXXX values)
	GUID			guidCT;				// Compression Type (= DPVCTGUID_XXXXXX)
} DVPROTOCOLMSG_CONNECTACCEPT, *PDVPROTOCOLMSG_CONNECTACCEPT;

//
// DVPROTOCOLMSG_SETTINGSCONFIRM 
//
// Session Types: ALL
// Message Flow : Voice Client -> Voice Host
//
// Sent by client to confirm they can handle current compression
// settings.  This message is sent once the client has determined that
// they can support the specified compression type and the sound 
// system has succesfully initialized.
//
// This message is also sent from voice clients to the new voice host
// when a migration has taken place.
//
typedef struct _DVPROTOCOLMSG_SETTINGSCONFIRM
{
	BYTE	dwType;				// Message Type = DVMSGID_SETTINGSCONFIRM
	DWORD	dwFlags;			// Client Flags (Only valid one is half duplex)
	DWORD	dwHostOrderID;		// Host Order ID (=INVALID to assign new one)
} DVPROTOCOLMSG_SETTINGSCONFIRM, *PDVPROTOCOLMSG_SETTINGSCONFIRM;

//
// DVPROTOCOLMSG_PLAYERLIST
//
// Session Types: Peer to Peer
// Message Flow : Voice Host -> Voice Clients
//
// Builds a list of players in the session to be sent to the 
// client once they have confirmed they are connected.
//
// May be spread over multiple packets.
//
// These messages will be the following header followed by a
// list of DVPROTOCOLMSG_PLAYERLIST_ENTRY structures (the # will be 
// specified in dwNumEntries).
//
typedef struct _DVPROTOCOLMSG_PLAYERLIST
{
	BYTE 					dwType;				// = DVMSGID_PLAYERLIST
	DWORD					dwHostOrderID;		// Host migration sequence number (for client)
	DWORD					dwNumEntries;		// Number of DVPROTOCOLMSG_PLAYERLIST_ENTRY structures 
												// following this header in this packet
} DVPROTOCOLMSG_PLAYERLIST, *PDVPROTOCOLMSG_PLAYERLIST;

//
// DVPROTOCOLMSG_PLAYERLIST_ENTRY
//
// Sent as part of a DVPROTOCOLMSG_PLAYERLIST message.
//
// Peer to Peer Only
//
// Each of these structures represents a player in the session.
// They are sent as part of the DVPROTOCOLMSG_PLAYERLIST structure.
//
typedef struct _DVPROTOCOLMSG_PLAYERLIST_ENTRY
{
	DVID	dvidID;				// Player's DVID
	DWORD	dwPlayerFlags;		// Player's player flags (DVPLAYERCAPS_XXXXX)
	DWORD	dwHostOrderID;		// Host migration sequence number
} DVPROTOCOLMSG_PLAYERLIST_ENTRY, *PDVPROTOCOLMSG_PLAYERLIST_ENTRY;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - SPEECH
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_SPEECHHEADER
//
// This message is used for transporting speech. Speech packets contain
// one of these headers followed by the audio data.  After this header
// the audio data will be the remaining part of the packet.
//
// ----
//
// Session Types: Peer to Peer
// Message Flow : Voice Clients <-> Voice Clients
//
// Session Types: Mixing
// Message Flow : Voice Mixing Server --> Voice Clients
//
// Session Types: Echo
// Message Flow : Voice Host <-> Voice Clients
//
typedef struct _DVPROTOCOLMSG_SPEECHHEADER
{
	BYTE	dwType;				// = DVMSGID_SPEECH
	BYTE	bMsgNum;			// Message # for message
	BYTE	bSeqNum;			// Sequence # for message
} DVPROTOCOLMSG_SPEECHHEADER, *PDVPROTOCOLMSG_SPEECHHEADER;

//
// DVPROTOCOLMSG_SPEECHWITHTARGET
//
// This message is used for transporting speech. The message consists
// of this header followed by a single DVID for each target the packet
// is targetted at.  After the target list the audio data will be the
// remaining part of the packet.
//
// ----
// Sesssion Types: Mixing / Forwarding
// Message Flow  : Voice Clients --> Voice Host / Voice Mixing Server
//
typedef struct _DVPROTOCOLMSG_SPEECHWITHTARGET
{
	DVPROTOCOLMSG_SPEECHHEADER	dvHeader;
								// dwType = DVMSGID_SPEECHWITHTARGET
	DWORD dwNumTargets;			// # of targets following this header 
} DVPROTOCOLMSG_SPEECHWITHTARGET, *PDVPROTOCOLMSG_SPEECHWITHTARGET;

// 
// DVPROTOCOLMSG_SPEECHWITHFROM
//
// This message is used by forwarding servers when a speech packet is 
// bounced.  The packet contains this header followed by the audio 
// data.  The audio data will be the remaining part of the packet.
//
// ---
// Session Types: Forwarding 
// Message Flow : Forwarding Server --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_SPEECHWITHFROM
{
	DVPROTOCOLMSG_SPEECHHEADER	dvHeader;
								// dwType = DVMSGID_SPEECHWITHFROM
	DVID dvidFrom;				// DVID of the client that this packet originated.
} DVPROTOCOLMSG_SPEECHWITHFROM, *PDVPROTOCOLMSG_SPEECHWITHFROM;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - TARGET MANAGEMENT
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_SETTARGET
//
// Tells client to switch it's target to the specified value.  Used when 
// the server calls SetTransmitTarget for a particular player.  This message
// contains this header followed by dwNumTargets DWORDs containing the
// players / groups that the client is targetting.  
//
// ---
// Session Types: Sessions with Server Controlled Targetting Enabled
// Message Flow : Voice Host --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_SETTARGET
{
	BYTE			dwType;				// = DVMSGID_SETTARGETS
	DWORD			dwNumTargets;		// # of targets (Can be 0 for no targets).
} DVPROTOCOLMSG_SETTARGET, *PDVPROTOCOLMSG_SETTARGET;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - NAMETABLE MANAGEMENT
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_PLAYERJOIN
//
// This message is used to inform clients when a new client has connected
// to the session.  
//
// ---
// Session Types: Peer to Peer
// Message Flow : Voice Host --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_PLAYERJOIN
{
	BYTE			dwType;				// = DVMSGID_CREATEVOICEPLAYER
	DVID			dvidID;				// ID of the player
	DWORD			dwFlags;			// Player's player flags (DVPLAYERCAPS_XXXXX)
	DWORD			dwHostOrderID;		// Host Order ID
} DVPROTOCOLMSG_PLAYERJOIN, *PDVPROTOCOLMSG_PLAYERJOIN;

//
// DVPROTOCOLMSG_PLAYERQUIT
//
// This message is used to inform clients when a client has left the voice
// session.
//
// ---
// Session Types: Peer to Peer
// Message Flow : Voice Host --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_PLAYERQUIT
{
	BYTE			dwType;				// = DVMSGID_DELETEVOICEPLAYER
	DVID			dvidID;				// ID of the player
} DVPROTOCOLMSG_PLAYERQUIT, *PDVPROTOCOLMSG_PLAYERQUIT;

// 
// DVPROTOCOLMSG_GENERIC
//
// Used to determine the type of a DirectPlayVoice message.  Used in message
// cracking.
//
typedef struct _DVPROTOCOLMSG_GENERIC
{
	BYTE			dwType;
} DVPROTOCOLMSG_GENERIC, *PDVPROTOCOLMSG_GENERIC;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - HOST MIGRATION MESSAGES
//
/////////////////////////////////////////////////////////////////////////////////////

// 
// DVPROTOCOLMSG_HOSTMIGRATED
//
// This message is sent by the new host when a host migration has taken place.
// The message is sent by the new host once they have finished initialization.
// All clients should respond to this message with a DVPROTOCOLMSG_SETTINGSCONFIRM.
//
// ---
// Session Types: Peer to Peer (With host migration enabled).
// Message Flow : Voice Host (New) --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_HOSTMIGRATED
{
	BYTE			dwType; // = DVMSGID_HOSTMIGRATED
} DVPROTOCOLMSG_HOSTMIGRATED, *PDVPROTOCOLMSG_HOSTMIGRATED;

// 
// DVPROTOCOLMSG_HOSTMIGRATELEAVE
//
// This message is sent by a voice host if they are shutting down their interface
// and host migration is enabled.  It informs clients that they have to run their
// election algorithm.
//
// ---
// Session Types: Peer To Peer (With Host Migration Enabled)
// Message Flow : Voice Host (Old) --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_HOSTMIGRATELEAVE
{
	BYTE			dwType; // = DVMSGID_HOSTMIGRATELEAVE
} DVPROTOCOLMSG_HOSTMIGRATELEAVE, *PDVPROTOCOLMSG_HOSTMIGRATELEAVE;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - SESSION TERMINATION
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_SESSIONLOST
//
// This message is sent by the voice host when they are shutting down and
// host migration is not enabled or available.
//
// This message can also be sent if a host migration takes place and a 
// client encounters a fatal error when starting the new host.
// 
// ---
// Session Type: ALL
// Message Flow: Voice Host (New) --> Voice Clients
//				 Voice Host --> Voice Clients
//
typedef struct _DVPROTOCOLMSG_SESSIONLOST
{
	BYTE			dwType;				// = DVMSGID_SESSIONLOST
	HRESULT			hresReason;			// DVERR_XXXXXX or DV_OK
} DVPROTOCOLMSG_SESSIONLOST, *PDVPROTOCOLMSG_SESSIONLOST; 

//
// DVPROTOCOLMSG_DISCONNECT
//
// This message is sent by voice clients when they wish to disconnect 
// gracefully.  The host responds with the same message to confirm
// it received the request.  Once the client receives the response
// then it is free to disconnect.
//
// ---
// Session Type: ALL
// Message Flow: Voice Host --> Voice Client (dwType = DVPROTOCOLMSG_DISCONNECTCONFIRM)
//               Voice Client --> Voice Host (dwType = DVPROTOCOLMSG_DISCONNECT)
//
typedef struct _DVPROTOCOLMSG_DISCONNECT
{
	BYTE			dwType;				// = DVPROTOCOLMSG_DISCONNECTCONFIRM OR
										//   DVPROTOCOLMSG_DISCONNECT
	HRESULT			hresDisconnect;		// HRESULT that caused the disconnect
										// DV_OK or DVERR_XXXXXX
} DVPROTOCOLMSG_DISCONNECT, *PDVPROTOCOLMSG_DISCONNECT;

typedef union _DVPROTOCOLMSG_FULLMESSAGE
{
	DVPROTOCOLMSG_GENERIC			dvGeneric;
	DVPROTOCOLMSG_SESSIONLOST		dvSessionLost;
	DVPROTOCOLMSG_PLAYERJOIN		dvPlayerJoin;
	DVPROTOCOLMSG_PLAYERQUIT		dvPlayerQuit;
	DVPROTOCOLMSG_CONNECTACCEPT		dvConnectAccept;
	DVPROTOCOLMSG_CONNECTREFUSE		dvConnectRefuse;
	DVPROTOCOLMSG_CONNECTREQUEST	dvConnectRequest;
	DVPROTOCOLMSG_SPEECHHEADER		dvSpeech;
	DVPROTOCOLMSG_DISCONNECT		dvDisconnect;
	DVPROTOCOLMSG_SETTARGET			dvSetTarget;
	DVPROTOCOLMSG_SETTINGSCONFIRM	dvSettingsConfirm;
	DVPROTOCOLMSG_PLAYERLIST		dvPlayerList;
	DVPROTOCOLMSG_HOSTMIGRATED		dvHostMigrated;
	DVPROTOCOLMSG_HOSTMIGRATELEAVE	dvHostMigrateLeave;
	DVPROTOCOLMSG_SPEECHWITHTARGET		dvSpeechWithTarget;
	DVPROTOCOLMSG_SPEECHWITHFROM		dvSpeechWithFrom;
    DWORD                           Padding[DV_MAX_REMOTE_PLAYERS*sizeof(ULONG)+sizeof(DVPROTOCOLMSG_SETTARGET)]; // this is here to make the size of FULL_MESSAGE
                                                    // large enough for at least 30 SET_TARGET dwords
} DVPROTOCOLMSG_FULLMESSAGE, *PDVPROTOCOLMSG_FULLMESSAGE;

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvengine.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvdptransport.h
 *  Content:	Definition of base class for Transport --> DirectXVoice
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created It
 * 09/01/2000  georgioc started rewrite/port to xbox 
 *
 ***************************************************************************/

#ifndef __DVENGINE_H
#define __DVENGINE_H

#include "dvntos.h"
#include "dvoicep.h"
#include "dvtran.h"

// CDirectVoiceEngine
//
// This class is the base interface for DirectVoiceClientEngine and 
// DirectVoiceServerEngine.  This interface is used by DirectPlay/
// DirectNet to inform the DirectXVoice engine of new events.  
//
// Hooks are placed into DirectPlay that call these functions.
//
class CDirectVoiceEngine
{
public:
public: // Incoming messages
	virtual BOOL ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize ) = 0;

public: // Session Management
    virtual HRESULT StartTransportSession() = 0;
	virtual HRESULT StopTransportSession() = 0;

public: // Player information
	virtual HRESULT AddPlayer( DVID dvID ) = 0;
	virtual HRESULT RemovePlayer( DVID dvID ) = 0;

public: // Used by local voice server to hook player messages to send
	    // to the remote voice server
	virtual HRESULT Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements ) = 0;
	virtual HRESULT CreateGroup( DVID dvID ) = 0;
	virtual HRESULT DeleteGroup( DVID dvID ) = 0;
	virtual HRESULT AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;
	virtual HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;
	virtual HRESULT MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer ) = 0;
	virtual HRESULT SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete ) = 0;

public: // Compression Information Storage
	static HRESULT Startup();
    static DWORD s_dwCompressedFrameSize;           // default compressor values
    static DWORD s_dwUnCompressedFrameSize;         // should be the same for both server and client
	static LPWAVEFORMATEX s_lpwfxPrimaryFormat;		// Primary buffer format
	
protected:

	static DWORD s_dwDefaultSensitivity;			// Default system sensitivity

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvrecsub.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClientRecordSubSystem.cpp
 *  Content:    Recording sub-system.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 09/01/2000  georgioc started rewrite for xbox 
 *
 ***************************************************************************/
#include "dvrecsub.h"
#include "sndutils.h"
#include "in_core.h"
#include "dvengine.h"
#include "va.h"

#define RECORD_MAX_RESETS       10
#define RECORD_MAX_TIMEOUT      2000
#define TESTMODE_MAX_TIMEOUT    500
#define RECORD_NUM_TARGETS_INIT 0
#define RECORD_NUM_TARGETS_GROW 10

// RECORDTEST_MIN_POWER / RECORDTEST_MAX_POWER
//
// Define the max and min possible power values
//#define RECORDTEST_MIN_POWER                0
//#define RECORDTEST_MAX_POWER                100

// We have to double the # because IsMuted is called twice / pass
#define RECORDTEST_NUM_FRAMESBEFOREVOICE      6


#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::CClientRecordSubSystem"
// CClientRecordSubSystem
//
// This is the constructor for the CClientRecordSubSystem class. 
// It intiailizes the classes member variables with the appropriate
// values.
//
// Parameters:
// CDirectVoiceClientEngine *clientEngine -
//      Pointer to the client object which is using this object.
//
// Returns:
// N/A
//
CClientRecordSubSystem::CClientRecordSubSystem( 
    CDirectVoiceClientEngine *clientEngine 
    ): m_recordState(RECORDSTATE_NOTSTARTED),
       m_pConverter(NULL),
       m_pCaptureMediaObject(NULL),
       m_pwfxConverter(NULL),
       m_clientEngine(clientEngine),
       m_dwCurrentPower(0),
       m_dwSilentTime(0),
       m_lastFrameTransmitted(FALSE),
       m_msgNum(0),
       m_seqNum(0),
       m_dwLastTargetVersion(0),
       m_dwResetCount(0),
       m_dwNumSinceRestart(0), 
       m_pVa(NULL),
       m_dwFrameCount(0),
       m_dwPort(0),
       m_pMediaPacketBuffer(NULL)
{

    InitializeListHead(&m_PendingList);
    InitializeListHead(&m_CompletedList);    

}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::Initialize"
HRESULT CClientRecordSubSystem::Initialize()
{
    HRESULT hr;
    ULONG i;
    XMEDIAPACKET xmp;
    PDVMEDIAPACKET pPacket,pNextPacket;
    WAVEFORMATEX wfx;
    

    DPVF_ENTER();

    //
    // create encoder
    //

    memcpy(&wfx, m_clientEngine->s_lpwfxPrimaryFormat,sizeof(wfx));
    hr = DV_CreateConverter(m_clientEngine->m_dvSessionDesc.guidCT,
                            &m_pConverter,
                            &wfx,
                            &m_pwfxConverter,
                            m_clientEngine->s_dwUnCompressedFrameSize,
                            TRUE);

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to create converter.  hr = 0x%x", hr );
        return hr ;
    }

    m_transmitFrame     = FALSE;
    m_dwResetCount = 0;

    m_dwLastFrameTime   = GetTickCount();
    m_dwFrameTime       = ((PVOICECODECWAVEFORMAT)m_pwfxConverter)->dwMilliSecPerFrame;
    m_dwSilentTime      = ((PVOICECODECWAVEFORMAT)m_pwfxConverter)->dwTrailFrames*m_dwFrameTime + 1;    
    m_dwSilenceTimeout  = m_dwSilentTime-1;

    m_dwPort = m_clientEngine->m_dvClientConfig.dwPort;

    //
    // retrieve hawk output (microphone) XMO
    //
    
    memcpy(&wfx, m_clientEngine->s_lpwfxPrimaryFormat,sizeof(wfx));

    hr = XVoiceCreateMediaObjectInternal(
        XDEVICE_TYPE_VOICE_MICROPHONE,
        m_dwPort,
        DV_CT_FRAMES_PER_PERIOD,
        &wfx, // IN parameter
        DV_RecordSubSystemPacketCompletion,
        this,
        &m_pCaptureMediaObject);

    PAGED_CODE();

    if (FAILED(hr)) {
        DPVF( DPVF_ERRORLEVEL, "Could not instatiate hawk XMO!" );
        ASSERT(FALSE);
        return hr;
    }

    // create and init the AGC and VA algorithm class
    m_pVa = new CVoiceActivation1();
    if (m_pVa == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc failure" );
        DPVF_EXIT();

        return DVERR_OUTOFMEMORY;
    }

    hr = m_pVa->Init(
            m_clientEngine->m_dvClientConfig.dwFlags, 
            m_wfxCapture.nSamplesPerSec,
            m_clientEngine->m_dvClientConfig.dwThreshold);

    if (FAILED(hr))
    {
        DPVF( DPVF_ERRORLEVEL, "Error initializing AGC and/or VA algorithm, code: %i", hr);
        DPVF_EXIT();

        delete m_pVa;
        return hr;
    }
    
    m_dwLastTargetVersion = m_clientEngine->m_dwTargetVersion;

    //
    // Alloc a bunch of media buffers
    //

    hr = DV_InitializeList(&m_PendingList,
                          DV_CT_FRAMES_PER_PERIOD,
                          sizeof(DVMEDIAPACKET),
                          DVLAT_RAW);

    if (FAILED(hr)) {
        DPVF_EXIT();

        return hr;
    }

    m_pMediaPacketBuffer = m_PendingList.Flink;

    hr = DV_InitMediaPacketPool(&m_PendingList,
                                m_clientEngine->s_dwUnCompressedFrameSize,
                                TRUE);

    if (FAILED(hr)) {

        DPVF_EXIT();

        return hr;

    }

    DPVF_EXIT();

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::~CClientRecordSubSystem"
// CClientRecordSubSystem
//
// This is the destructor for the CClientRecordSubSystem
// class.  It cleans up the allocated memory for the class
// and stops the recording device.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CClientRecordSubSystem::~CClientRecordSubSystem()
{
    HRESULT hr;
    PDVMEDIAPACKET pPacket;

    DPVF_ENTER();

    if( m_pConverter != NULL )
        m_pConverter->Release();

    //
    // stop recording and force any pending buffers to complete
    //

    if (m_pCaptureMediaObject) {

        hr = m_pCaptureMediaObject->Flush();
        ASSERT(!FAILED(hr));
    
        //
        // free the capture device
        //
    
        m_pCaptureMediaObject->Release();

    }

    // Deinit and cleanup the AGC and VA algorthms
    if (m_pVa != NULL)
    {
        hr = m_pVa->Deinit();
        if (FAILED(hr))
        {
            DPVF(DPVF_ERRORLEVEL, "Deinit error on AGC and/or VA algorithm, code: %i", hr);
        }
        delete m_pVa;
    }

    //
    // delete all pending buffers and their data
    // all buffers should be in the pending pool...
    //

    DV_FreeMediaPacketPool(&m_PendingList,TRUE);

    DV_FreeList(&m_PendingList,DVLAT_RAW);
    DV_FreeList(&m_CompletedList, DVLAT_RAW);

    if (m_pMediaPacketBuffer) {

        DV_POOL_FREE(m_pMediaPacketBuffer);
        m_pMediaPacketBuffer = NULL;

    }

    DPVF_EXIT();

}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::IsMuted"

BOOL CClientRecordSubSystem::IsMuted()
{
    KIRQL irql;
    BOOL fMuted =  FALSE;

    DPVF_ENTER();

    if( m_dwFrameCount < RECORDTEST_NUM_FRAMESBEFOREVOICE )
    {
        DPVF( RRI_DEBUGOUTPUT_LEVEL, "Skipping first %d frames for startup burst", RECORDTEST_NUM_FRAMESBEFOREVOICE );
        m_dwFrameCount++;
        DPVF_EXIT();

        return TRUE;
    }
    
    fMuted = (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_RECORDMUTE);

    DPVF_EXIT();

    return fMuted;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::StartMessage()"
void CClientRecordSubSystem::StartMessage() 
{
    BYTE bPeakLevel;
    
    DPVF_ENTER();

    if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED || 
       m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED )
    {
        m_pVa->PeakResults(&bPeakLevel);
    }
    else
    {
        bPeakLevel = 0;
    }

    DVMSG_RECORDSTART dvRecordStart;
    dvRecordStart.dwPeakLevel = bPeakLevel;
    dvRecordStart.dwSize = sizeof( DVMSG_RECORDSTART );
    dvRecordStart.pvLocalPlayerContext = m_clientEngine->m_pvLocalPlayerContext;
    
    m_clientEngine->NotifyQueue_Add( DVMSGID_RECORDSTART, &dvRecordStart, sizeof( DVMSG_RECORDSTART ) );

    DPVF( RRI_DEBUGOUTPUT_LEVEL, "RRI, Starting Message" );

    DPVF_EXIT();

    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::EndMessage()"
void CClientRecordSubSystem::EndMessage()
{
    BYTE bPeakLevel;
    
    DPVF_ENTER();

    if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED || 
       m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED )
    {
        m_pVa->PeakResults(&bPeakLevel);
    }
    else
    {
        bPeakLevel = 0;
    }

    DVMSG_RECORDSTOP dvRecordStop;
    dvRecordStop.dwPeakLevel = bPeakLevel;
    dvRecordStop.dwSize = sizeof( DVMSG_RECORDSTOP );
    dvRecordStop.pvLocalPlayerContext = m_clientEngine->m_pvLocalPlayerContext; 
    
    m_clientEngine->NotifyQueue_Add( DVMSGID_RECORDSTOP, &dvRecordStop, sizeof( DVMSG_RECORDSTOP ) );

    m_msgNum++;
    m_seqNum = 0;   

    DPVF( RRI_DEBUGOUTPUT_LEVEL, "RRI, Ending Message" );
    DPVF_EXIT();

}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::CheckVA()"
BOOL CClientRecordSubSystem::CheckVA()
{
    BOOL m_fVoiceDetected;
    KIRQL irql;

    DPVF_ENTER();

    // We've been muted, turn off the VA
    if( IsMuted() )
    {
        RIRQL(irql);
        m_dwSilentTime = m_dwSilenceTimeout+1;  
        LIRQL(irql);

        DPVF_EXIT();

        return FALSE;
    }

    RIRQL(irql);
    m_pVa->VAResults(&m_fVoiceDetected);
    if (!m_fVoiceDetected)
    {
        // This prevents wrap-around on silence timeout
        if( m_dwSilentTime <= m_dwSilenceTimeout )
        {
            m_dwSilentTime += m_dwFrameTime;
        }

        DPVF( DPVF_SPAMLEVEL, "### Silence Time to %d", m_dwSilentTime );        

        if( m_dwSilentTime > m_dwSilenceTimeout )
        {
            DPVF( DPVF_SPAMLEVEL, "### Silence Time exceeded %d", m_dwSilenceTimeout );              
            LIRQL(irql);
            DPVF_EXIT();

            return FALSE;
        }
    }
    else
    {
        m_dwSilentTime = 0;
        DPVF( DPVF_SPAMLEVEL, "### Transmit!!!!" );
    }

    LIRQL(irql);
    DPVF_EXIT();

    return TRUE;
}

VOID DV_RecordSubSystemPacketCompletion(
    PVOID pThis,
    PVOID pContext,
    DWORD dwStatus)
{
    CClientRecordSubSystem *This = (CClientRecordSubSystem *) pThis;
    PDVMEDIAPACKET pPacket = (PDVMEDIAPACKET) pContext;

    DPVF( DPVF_SPAMLEVEL, "DV_recordsubSystemPacketCompletion(%x), Packet = %x",
         This,
         pPacket);

    //
    // add packet to the completed list, remove from pending list
    //

    DV_REMOVE_ENTRY(pPacket);
    DV_INSERT_HEAD(&This->m_CompletedList,pPacket);

}



#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::RecordFSM"
HRESULT CClientRecordSubSystem::RecordFSM() 
{
    DWORD fIsMuted;
    PDVMEDIAPACKET pPacket, pNextPacket;
    HRESULT hr;
    ULONG i;

    DPVF_ENTER();

    //
    // if this is the very first time we are called, attach packets to hawk and bail..
    //

    if (m_recordState == RECORDSTATE_NOTSTARTED) {

        DPVF( DPVF_WARNINGLEVEL, "Entering record for first time. attaching packets to Hawk" );

        pPacket = (PDVMEDIAPACKET) DV_GET_LIST_HEAD(&m_PendingList);
    
        for (i=0;
             i<DV_CT_FRAMES_PER_PERIOD;
             i++){
            
            //
            // before we attach get next link, since XMO might complete packet
            // an dinsert on another list..
            //
    
            pNextPacket = (PDVMEDIAPACKET) DV_GET_NEXT(&m_PendingList,pPacket);
            
            //
            // attach buffer to the XMO
            //
    
            hr = m_pCaptureMediaObject->Process(NULL,
                                                &pPacket->xmp);
    
            if (FAILED(hr)) {

                DPVF( DPVF_ERRORLEVEL, "Attach to voice xmo failed with %x\n",hr );

                
                DPVF_EXIT();

                return hr;
            }
    
            pPacket = pNextPacket;
            
    
        }

        m_recordState = RECORDSTATE_IDLE;
        DPVF_EXIT();

        return DV_OK;

    }

    do {

        //
        // get a buffer from the completed list
        //

        if (!IsListEmpty(&m_CompletedList)) {

            pPacket = (PDVMEDIAPACKET) DV_REMOVE_TAIL(&m_CompletedList);

        } else {

            //
            // we have no data
            //

            DPVF( DPVF_SPAMLEVEL, "### No data available from hawk yet!" );

            DPVF_EXIT();

            return DV_OK;

        }

        fIsMuted = IsMuted();

        //
        // In this case we NEVER transmit
        // Shortcut to simplify the other cases
        //

        if( fIsMuted || !IsValidTarget() )
        {
            //
            // Go immediately to IDLE
            //

            DPVF( DPVF_RECORDLEVEL, "### IsMuted || IsValidTarget --> IDLE" );
            m_recordState = RECORDSTATE_IDLE;

        }
    
        if( !fIsMuted )
        {
            //
            // before we analyze the data, push down the current
            // relevant portions of the client config structure.
            //

            m_pVa->SetSensitivity(m_clientEngine->m_dvClientConfig.dwFlags,
                                  m_clientEngine->m_dvClientConfig.dwThreshold);

            m_pVa->AnalyzeData((PUCHAR)pPacket->xmp.pvBuffer,
                               m_clientEngine->s_dwUnCompressedFrameSize);

        }

        m_transmitFrame = FALSE;    
    
        switch( m_recordState )
        {
        case RECORDSTATE_IDLE:
    
            DPVF( DPVF_RECORDLEVEL, "### STATE: IDLE" );
    
            if( !fIsMuted&& IsValidTarget() )
            {
                if( IsPTT() )
                {
                    m_recordState = RECORDSTATE_PTT;
                    m_transmitFrame = TRUE;
                }
                else
                {
                    m_transmitFrame = CheckVA();
    
                    if( m_transmitFrame )
                    {
                        m_recordState = RECORDSTATE_VA;
                    }
    
                }
            }
    
            break;
            
        case RECORDSTATE_VA:
    
            DPVF( DPVF_RECORDLEVEL, "### STATE: VA" ); 
    
            if( IsPTT() )
            {
                DPVF( DPVF_RECORDLEVEL, "### VA --> PTT" );                
                m_recordState = RECORDSTATE_PTT;
                m_transmitFrame = TRUE;
            }
            else
            {
                m_transmitFrame = CheckVA();
                if (!m_transmitFrame)
                {
                    DPVF( DPVF_RECORDLEVEL, "### !VA --> IDLE" );      
                    m_recordState = RECORDSTATE_IDLE;
                }
            }
    
            break;
    
        case RECORDSTATE_PTT:
    
            DPVF( DPVF_RECORDLEVEL, "### STATE: PTT" );
    
            if( IsVA() )
            {
                DPVF( DPVF_RECORDLEVEL, "### PTT --> VA" );                            
                m_recordState = RECORDSTATE_VA;
                m_transmitFrame = CheckVA();
            }
            else
            {
                m_transmitFrame = TRUE;
            }
    
            break;
        }
    
        // Message Ended
        if( m_lastFrameTransmitted && !m_transmitFrame )
        {
            EndMessage();
        }
        // Message Started
        else if( !m_lastFrameTransmitted && m_transmitFrame )
        {
            StartMessage();
        }
        // Message Continuing
        else
        {
            // If the target has changed since the last frame
            if( m_clientEngine->m_dwTargetVersion != m_dwLastTargetVersion )
            {
                // If we're going to be transmitting
                if( m_transmitFrame )
                {
                    EndMessage();
                    StartMessage();
                }
            }
        }
    
        m_lastFrameTransmitted = m_transmitFrame;
        m_dwLastTargetVersion = m_clientEngine->m_dwTargetVersion;
    
        // Save the peak level to propogate up to the app
        m_pVa->PeakResults(&(m_clientEngine->m_bLastPeak));

        hr = TransmitFrame(pPacket);
        if (FAILED(hr)) {
            DPVF( DPVF_ERRORLEVEL, "### TransmitFrame failed with hr %x! ###",hr);

            //
            // put packet back to pending list, we have to discard the hawk data..
            //

        }

        //
        // re-attach this buffer to hawk and return this buffer to the pending pool
        //

        pPacket->dwCompletedSize = 0;
        DV_INSERT_TAIL(&m_PendingList,pPacket);

        //
        // attach buffer to the XMO
        //

        hr = m_pCaptureMediaObject->Process(NULL,
                                            &pPacket->xmp);

        if (FAILED(hr)) {

            DPVF( DPVF_ERRORLEVEL, "Attach to voice xmo failed with %x\n",hr );            
            DPVF_EXIT();

            return hr;
        }

        //
        // we do a single quantum of work 
        //

    } while (FALSE);

    DPVF_EXIT();

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::TransmitFrame"
// TransmitFrame
//
// This function looks at the state of the FSM, and if the latest
// frame is to be transmitted it compresses it and transmits
// it to the server (cleint/server mode) or to all the players
// (or player if whispering) in peer to peer mode.  If the frame
// is not to be transmitted this function does nothing.  
//
// It is also responsible for ensuring any microphone clicks are
// mixed into the audio stream.
//
// This function also updates the transmission statisics and
// the current transmission status.  
//
// Parameters:
// N/A
//
// Returns:
// bool - always returns true at the moment
HRESULT CClientRecordSubSystem::TransmitFrame(PDVMEDIAPACKET pPacket) 
{
    HRESULT hr = DV_OK;

    DPVF_ENTER();

    if( m_transmitFrame) 
    {
        
        if( m_clientEngine->m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
        {
            hr = BuildAndTransmitSpeechHeader(pPacket);
        }
        else
        {
            hr = BuildAndTransmitSpeechWithTarget(pPacket);
        }
    }

    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::BuildAndTransmitSpeechHeader"
HRESULT CClientRecordSubSystem::BuildAndTransmitSpeechHeader(PDVMEDIAPACKET pPacket)
{
    PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader;
    HRESULT hr;
    DWORD dwTargetSize;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    LPVOID pvSendContext;
    XMEDIAPACKET dstMediaPacket;

    DPVF_ENTER();

    pBufferDesc = m_clientEngine->GetTransmitBuffer(
                      sizeof(DVPROTOCOLMSG_SPEECHHEADER)+\
                      COMPRESSION_SLUSH+m_clientEngine->s_dwCompressedFrameSize,
                      &pvSendContext, TRUE );

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed to get buffer for transmission" );
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;
    }

    pdvSpeechHeader = (PDVPROTOCOLMSG_SPEECHHEADER) pBufferDesc->pBufferData;

    pdvSpeechHeader->dwType = DVMSGID_SPEECH;       
    pdvSpeechHeader->bMsgNum = m_msgNum;
    pdvSpeechHeader->bSeqNum = m_seqNum;

    DPVF( DPVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Record:  Msg [%d] Seq [%d]", m_msgNum, m_seqNum );

    
    dwTargetSize = m_clientEngine->s_dwCompressedFrameSize;

    pPacket->dwCompletedSize = 0;

    //
    // prepare DST bufer
    //

    memset(&dstMediaPacket,0,sizeof(XMEDIAPACKET));
    dstMediaPacket.dwMaxSize = dwTargetSize;
    dstMediaPacket.pdwCompletedSize = &dwTargetSize;
    dstMediaPacket.pvBuffer = &pdvSpeechHeader[1];

    hr = m_pConverter->Process(&pPacket->xmp,
                               &dstMediaPacket);

    ASSERT(dwTargetSize == m_clientEngine->s_dwCompressedFrameSize);

    if( FAILED( hr ) )
    {
        m_clientEngine->ReturnTransmitBuffer( pvSendContext );        
        DPVF( DPVF_ERRORLEVEL, "Failed to perform conversion hr=0x%x", hr );
        DPVF_EXIT();
        return hr;
    }

    if( m_clientEngine->m_dwNumTargets == 0 )
    {
        DPVF( DPVF_INFOLEVEL, "Targets set to NONE since FSM.  Not transmitting" );
        m_clientEngine->ReturnTransmitBuffer( pvSendContext );
        DPVF_EXIT();
        return DV_OK;
    }
    else
    {
        pBufferDesc->dwBufferSize = sizeof(DVPROTOCOLMSG_SPEECHHEADER)+dwTargetSize;    
            
        DPVF( DPVF_RECORDLEVEL, "Transmitting %d bytes to target list", pBufferDesc->dwBufferSize );       
        hr = m_clientEngine->m_lpSessionTransport->SendToIDS( m_clientEngine->m_pdvidTargets, m_clientEngine->m_dwNumTargets,
                                                              pBufferDesc, pvSendContext, 0 );
        if( hr == DVERR_PENDING )
        {
            hr = DV_OK;
        }
        else if ( FAILED( hr ))
        {
            DPVF( DPVF_INFOLEVEL, "Send failed hr=0x%x", hr );
            m_clientEngine->ReturnTransmitBuffer( pvSendContext );
        }

        m_seqNum++; 
        
    }

    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::BuildAndTransmitSpeechWithTarget"
HRESULT CClientRecordSubSystem::BuildAndTransmitSpeechWithTarget(PDVMEDIAPACKET pPacket)
{
    PDVPROTOCOLMSG_SPEECHWITHTARGET pdvSpeechWithTarget;
    HRESULT hr;
    DWORD dwTargetSize;
    DWORD dwTransmitSize;
    DWORD dwTargetInfoSize;
    PBYTE pbBuilderLoc;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    LPVOID pvSendContext;
    XMEDIAPACKET dstMediaPacket;

    DPVF_ENTER();

    dwTransmitSize = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET );

    // Calculate size we'll need for storing the targets

    dwTargetInfoSize = sizeof( DVID ) * m_clientEngine->m_dwNumTargets;    

    if( dwTargetInfoSize == 0 )
    {
        DPVF( DPVF_INFOLEVEL, "Targets set to NONE since FSM.  Not transmitting" );

        DPVF_EXIT();
        return DV_OK;
    }
    else
    {
        dwTransmitSize += dwTargetInfoSize; 
    }

    DPVF( DPVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Record:  Msg [%d] Seq [%d]", m_msgNum, m_seqNum );   

    dwTransmitSize += m_clientEngine->s_dwCompressedFrameSize;

    pBufferDesc = m_clientEngine->GetTransmitBuffer(
                      sizeof(DVPROTOCOLMSG_SPEECHWITHTARGET)+\
                      m_clientEngine->s_dwCompressedFrameSize+COMPRESSION_SLUSH+dwTransmitSize,
                      &pvSendContext,TRUE);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed to get buffer for transmission" );
        DPVF_EXIT();
        return DVERR_OUTOFMEMORY;
    }

    pdvSpeechWithTarget = (PDVPROTOCOLMSG_SPEECHWITHTARGET) pBufferDesc->pBufferData;   
    pbBuilderLoc = (PBYTE) &pdvSpeechWithTarget[1];

    memcpy( pbBuilderLoc, m_clientEngine->m_pdvidTargets, dwTargetInfoSize );

    pdvSpeechWithTarget->dwNumTargets = m_clientEngine->m_dwNumTargets;

    pbBuilderLoc += dwTargetInfoSize;

    pdvSpeechWithTarget->dvHeader.dwType = DVMSGID_SPEECHWITHTARGET;        
    pdvSpeechWithTarget->dvHeader.bMsgNum = m_msgNum;
    pdvSpeechWithTarget->dvHeader.bSeqNum = m_seqNum;

    dwTargetSize = m_clientEngine->s_dwCompressedFrameSize;

    DPVF( DPVF_COMPRESSION_DEBUG_LEVEL, "COMPRESS: < %d --> %d ",m_clientEngine->s_dwUnCompressedFrameSize, dwTargetSize );

    memset(&dstMediaPacket,0,sizeof(XMEDIAPACKET));
    dstMediaPacket.dwMaxSize = dwTargetSize;
    dstMediaPacket.pdwCompletedSize = &dwTargetSize;
    dstMediaPacket.pvBuffer = pbBuilderLoc;

    hr = m_pConverter->Process(&pPacket->xmp,
                               &dstMediaPacket);

    ASSERT(dwTargetSize == m_clientEngine->s_dwCompressedFrameSize);

    if( FAILED( hr ) )
    {
        m_clientEngine->ReturnTransmitBuffer( pvSendContext );
        DPVF( DPVF_ERRORLEVEL, "Failed to perform conversion hr=0x%x", hr );
        DPVF_EXIT();
        return hr;
    }

    // We need to transmit header, target info and then speech data
    dwTransmitSize = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) + dwTargetInfoSize + dwTargetSize;

    pBufferDesc->dwBufferSize = dwTransmitSize;

    hr = m_clientEngine->m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, 0 );

    m_seqNum++; 

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        m_clientEngine->ReturnTransmitBuffer( pvSendContext );      
        DPVF( DPVF_INFOLEVEL, "Send failed hr=0x%x", hr );
    }

    DPVF_EXIT();
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::IsValidTarget"
BOOL CClientRecordSubSystem::IsValidTarget() 
{ 
    BOOL fValidTarget;
    KIRQL irql;
    
    RIRQL(irql);

    if( m_clientEngine->m_dwNumTargets > 0 )
    {
        fValidTarget = TRUE;
    }
    else
    {
        fValidTarget = FALSE;
    }

    LIRQL(irql);

    return fValidTarget;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvengine.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvengine.cpp
 *  Content:	Implementation of CDirectVoiceEngine's static functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/19/99		rodtoll	Created
 * 07/29/99		rodtoll	Added static members to load default settings
 * 08/10/99		rodtoll	Removed the TODOs
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 *						Added default parameter reads from the registry
 * 08/30/99		rodtoll	Distinguish between primary buffer format and
 *						playback format.
 *						Changed playback format to be 8Khz, 16Bit mono
 * 10/05/99		rodtoll	Additional comments/DPFs
 * 10/07/99		rodtoll	Updated to work in Unicode 
 * 02/08/2000	rodtoll	Bug #131496 - Selecting DVSENSITIVITY_DEFAULT results in voice
 *						never being detected
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 04/21/2000  rodtoll   Bug #32889 - Does not run on Win2k on non-admin account
 * 04/24/2000   rodtoll Bug #33203 - Aureal Vortex plays back at the wrong rate
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 *
 ***************************************************************************/
#include "dvengine.h"
#include "dvshared.h"
#include "sndutils.h"
#include "in_core.h"

// Registry settings and their defaults
#define DPVOICE_DEFAULT_DEFAULTAGGRESSIVENESS		15

#define DPVOICE_DEFAULT_DEFAULTQUALITY				15

//
// BUGBUG Tune this value OR tune the VA autoactivation parameters
//

#define DPVOICE_DEFAULT_DEFAULTSENSITIVITY			15

#define DPVOICE_DEFAULT_ASO							FALSE


#define DPVOICE_DEFAULT_PRIMARYFORMAT				CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 16 )



// Initialize static member variables

DWORD CDirectVoiceEngine::s_dwCompressedFrameSize = 0;
DWORD CDirectVoiceEngine::s_dwUnCompressedFrameSize = 0;
DWORD CDirectVoiceEngine::s_dwDefaultSensitivity = DPVOICE_DEFAULT_DEFAULTSENSITIVITY;

PWAVEFORMATEX CDirectVoiceEngine::s_lpwfxPrimaryFormat = DPVOICE_DEFAULT_PRIMARYFORMAT;

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceEngine::Startup"
//
// Startup
//
// Called to load global settings and compression info from the registry.  
//
HRESULT CDirectVoiceEngine::Startup()
{
	HRESULT hr;

    s_dwDefaultSensitivity = DPVOICE_DEFAULT_DEFAULTSENSITIVITY;
    s_lpwfxPrimaryFormat = DPVOICE_DEFAULT_PRIMARYFORMAT;

    s_dwCompressedFrameSize = 0;
    s_dwUnCompressedFrameSize = 0; 
    ASSERT(CDirectVoiceEngine::s_lpwfxPrimaryFormat);


	return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvsereng.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvserverengine.cpp
 *  Content:    Implements the CDirectVoiceServerEngine class.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/18/99    rodtoll Created It
 *  09/01/2000  georgioc rewrote/ported to xbox
 ***************************************************************************/
#include "dvsereng.h"
#include "dvntos.h"
#include "dvshared.h"
#include "dvserver.h"
#include "in_core.h"

#define SERVER_POOL_MESSAGE      1
#define SERVER_POOL_PLAYERLIST   2
#define SERVER_POOL_SPEECH       3

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CDirectVoiceServerEngine"
// 
// Constructor
// 
// Initializes the object into the uninitialized state
//
CDirectVoiceServerEngine::CDirectVoiceServerEngine( DIRECTVOICESERVEROBJECT *lpObject
):  m_dwSignature(VSIG_SERVERENGINE), 
    m_lpMessageHandler(NULL),
    m_lpUserContext(NULL),
    m_lpObject(lpObject),
    m_dvidLocal(0),
    m_dwCurrentState(DVSSTATE_NOTINITIALIZED),
    m_lpSessionTransport(NULL),
    m_lpdwMessageElements(NULL),
    m_dwNumMessageElements(0),
    m_dwNextHostOrderID(0)
{

    InitializeCriticalSection(&m_CS);
    m_SpeechBufferAllocs = 0;
    m_MsgBufferAllocs = 0;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::~CDirectVoiceServerEngine"
//
// Destructor
//
// Frees the resources associated with the server.  Shuts the server down
// if it is running.
//
// Server objects should never be destructed directly, the COM Release
// method should be used.
//
// Called By:
// DVS_Release (When reference count reaches 0)
//
// Locks Required:
// - Global Write Lock
//
CDirectVoiceServerEngine::~CDirectVoiceServerEngine()
{
    HRESULT hr;

    DV_AUTO_LOCK(&m_CS);    

    DPVF_ENTER();

    // Stop the session if it's running.
    hr = StopSession(0, FALSE , DV_OK );

    if( hr != DV_OK && hr != DVERR_NOTHOSTING )
    {
        DPVF( DPVF_ERRORLEVEL, "StopSession Failed hr=0x%x", hr );
    }

    if( m_lpdwMessageElements != NULL )
        delete [] m_lpdwMessageElements;

    m_dwSignature = VSIG_SERVERENGINE_FREE;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::TransmitMessage"
// 
// TransmitMessage
//
// This function sends a notification to the notification handler.  Before transmitting
// it, the notify elements are checked to ensure the specified notification is activated.
// (or notification array is NULL).
//
// Called By:
// - Multiple locations throughout dvsereng.cpp
// 
// Locks Required:
// - m_csNotifyLock - The notification lock
// 
void CDirectVoiceServerEngine::TransmitMessage( DWORD dwMessageType, LPVOID lpdvData, DWORD dwSize )
{
    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);
    if( m_lpMessageHandler != NULL )
    {
        BOOL fSend = FALSE;     

        if( m_dwNumMessageElements == 0 )
        {
            fSend = TRUE;
        }
        else
        {
            for( DWORD dwIndex = 0; dwIndex < m_dwNumMessageElements; dwIndex++ )
            {
                if( m_lpdwMessageElements[dwIndex] == dwMessageType )
                {
                    fSend = TRUE;
                    break;
                }
            }
        }

        if( fSend )
        {
            (*m_lpMessageHandler)( m_lpUserContext, dwMessageType,lpdvData );               
        }


    }

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartupMulticast"
//
// StartupMulticast
//
// This function is called to initialize the multicast portion of the server
// object.  
//
// Called By:
// - StartSession
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::StartupMulticast()
{
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ShutdownMulticast"
//
// ShutdownMulticast
//
// This function is called to shutdown the multicast portion of the server
// object.  
//
// Called By:
// - StartSession
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::ShutdownMulticast()
{

    return DV_OK;
}


// Handles initializing a server object for host migration
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HostMigrateStart"
//
// HostMigrateStart
//
// This function is called on the object which is to become the new host when 
// the host migrates.  It is used instead of the traditional startup to 
// ensure that the object is initialized correctly in the migration case.
//
// Called By:
// - DV_HostMigrate
//
// Locks Required:
// - None
// 
HRESULT CDirectVoiceServerEngine::HostMigrateStart(LPDVSESSIONDESC lpSessionDesc, DWORD dwHostOrderIDSeed )
{
    HRESULT hr;
    
    DPVF_ENTER();

    DPVF(  DPVF_ENTRYLEVEL, "DVSE::HostMigrateStart() Begin" );

    // Start 
    hr = StartSession( lpSessionDesc, 0, dwHostOrderIDSeed );

    // Fail
    if( hr != DV_OK ) 
    {
        DPVF( DPVF_ERRORLEVEL, "CDirectVoiceServerEngine::HostMigrateStart Failed Hr=0x%x", hr );
        return hr;
    }

    hr = InformClientsOfMigrate();

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to inform users of host migration hr=0x%x", hr );
    }

    return hr;
}

#ifdef DVS_ENABLE_PEER_SESSION
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_CreatePlayer"
HRESULT CDirectVoiceServerEngine::Send_CreatePlayer( DVID dvidTarget, CVoicePlayer *pPlayer )
{
    PDVPROTOCOLMSG_PLAYERJOIN pdvPlayerJoin;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;
                          
    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_PLAYERJOIN ), &pvSendContext,SERVER_POOL_MESSAGE );

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvPlayerJoin = (PDVPROTOCOLMSG_PLAYERJOIN) pBufferDesc->pBufferData;

    pdvPlayerJoin->dwType = DVMSGID_CREATEVOICEPLAYER;
    pdvPlayerJoin->dvidID = pPlayer->GetPlayerID();
    pdvPlayerJoin->dwFlags = pPlayer->GetTransportFlags();
    pdvPlayerJoin->dwHostOrderID = pPlayer->GetHostOrder();

    hr = m_lpSessionTransport->SendToIDS( &dvidTarget, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending create player to 0x%x hr=0x%x", dvidTarget, hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;    
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_ConnectRefuse"
HRESULT CDirectVoiceServerEngine::Send_ConnectRefuse( DVID dvidID, HRESULT hrReason )
{
    PDVPROTOCOLMSG_CONNECTREFUSE pdvConnectRefuse;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_CONNECTREFUSE ), &pvSendContext, SERVER_POOL_MESSAGE);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvConnectRefuse = (PDVPROTOCOLMSG_CONNECTREFUSE) pBufferDesc->pBufferData;

    pdvConnectRefuse->dwType = DVMSGID_CONNECTREFUSE;
    pdvConnectRefuse->hresResult = hrReason;
    pdvConnectRefuse->ucVersionMajor = DVPROTOCOL_VERSION_MAJOR;
    pdvConnectRefuse->ucVersionMinor = DVPROTOCOL_VERSION_MINOR;
    pdvConnectRefuse->dwVersionBuild = DVPROTOCOL_VERSION_BUILD;    

    hr = m_lpSessionTransport->SendToIDS( &dvidID, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending disconnect confirm migrated to all hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_DisconnectConfirm"
HRESULT CDirectVoiceServerEngine::Send_DisconnectConfirm( DVID dvidID, HRESULT hrReason )
{
    PDVPROTOCOLMSG_DISCONNECT pdvDisconnectConfirm;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_DISCONNECT ), &pvSendContext, SERVER_POOL_MESSAGE );

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvDisconnectConfirm = (PDVPROTOCOLMSG_DISCONNECT) pBufferDesc->pBufferData;

    pdvDisconnectConfirm->dwType = DVMSGID_DISCONNECTCONFIRM;
    pdvDisconnectConfirm->hresDisconnect = hrReason;

    hr = m_lpSessionTransport->SendToIDS( &dvidID, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending disconnect confirm migrated to all hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_ConnectAccept"
HRESULT CDirectVoiceServerEngine::Send_ConnectAccept( DVID dvidID )
{
    PDVPROTOCOLMSG_CONNECTACCEPT pdvConnectAccept;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_CONNECTACCEPT ), &pvSendContext, SERVER_POOL_MESSAGE );

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvConnectAccept = (PDVPROTOCOLMSG_CONNECTACCEPT) pBufferDesc->pBufferData;

    pdvConnectAccept->dwType = DVMSGID_CONNECTACCEPT;
    pdvConnectAccept->dwSessionFlags = m_dvSessionDesc.dwFlags;
    pdvConnectAccept->dwSessionType = m_dvSessionDesc.dwSessionType;
    pdvConnectAccept->ucVersionMajor = DVPROTOCOL_VERSION_MAJOR;
    pdvConnectAccept->ucVersionMinor = DVPROTOCOL_VERSION_MINOR;
    pdvConnectAccept->dwVersionBuild = DVPROTOCOL_VERSION_BUILD;
    pdvConnectAccept->guidCT = m_dvSessionDesc.guidCT;

    hr = m_lpSessionTransport->SendToIDS( &dvidID, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending connect accept to player hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}


#ifdef DVS_ENABLE_PEER_SESSION
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_DeletePlayer"
HRESULT CDirectVoiceServerEngine::Send_DeletePlayer( DVID dvidID )
{
    PDVPROTOCOLMSG_PLAYERQUIT pdvPlayerQuit;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_PLAYERQUIT ), &pvSendContext, SERVER_POOL_MESSAGE);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvPlayerQuit = (PDVPROTOCOLMSG_PLAYERQUIT) pBufferDesc->pBufferData;

    pdvPlayerQuit->dwType = DVMSGID_DELETEVOICEPLAYER;
    pdvPlayerQuit->dvidID = dvidID;

    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending delete player migrated to all hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}
#endif
        
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_SessionLost"
HRESULT CDirectVoiceServerEngine::Send_SessionLost( HRESULT hrReason )
{
    PDVPROTOCOLMSG_SESSIONLOST pdvSessionLost;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_SESSIONLOST ), &pvSendContext, SERVER_POOL_MESSAGE);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvSessionLost = (PDVPROTOCOLMSG_SESSIONLOST) pBufferDesc->pBufferData;

    pdvSessionLost->dwType = DVMSGID_SESSIONLOST;
    pdvSessionLost->hresReason = hrReason;

    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending host migrated to all hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_HostMigrateLeave"
HRESULT CDirectVoiceServerEngine::Send_HostMigrateLeave( )
{
    PDVPROTOCOLMSG_HOSTMIGRATELEAVE pdvHostMigrateLeave;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_HOSTMIGRATELEAVE ), &pvSendContext, SERVER_POOL_MESSAGE);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvHostMigrateLeave = (PDVPROTOCOLMSG_HOSTMIGRATELEAVE) pBufferDesc->pBufferData;

    pdvHostMigrateLeave->dwType = DVMSGID_HOSTMIGRATELEAVE;

    // Send this message with sync.  Sync messages do not generate callbacks
    //
    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED | DVTRANSPORT_SEND_SYNC );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending host migrated to all hr=0x%x", hr );
    }

    ReturnTransmitBuffer( pvSendContext );        

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_HostMigrated"
HRESULT CDirectVoiceServerEngine::Send_HostMigrated()
{
    PDVPROTOCOLMSG_HOSTMIGRATED pvMigrated;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    DPVF_ENTER();

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_HOSTMIGRATED ), &pvSendContext, SERVER_POOL_MESSAGE );

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pvMigrated = (PDVPROTOCOLMSG_HOSTMIGRATED) pBufferDesc->pBufferData;

    pvMigrated->dwType = DVMSGID_HOSTMIGRATED;

    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending host migrated to all hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}

#undef DPF_MODNAME 
#define DPF_MODNAME "CDirectVoiceServerEngine::InformClientsOfMigrate"
//
//
// This function will 
//  
HRESULT CDirectVoiceServerEngine::InformClientsOfMigrate()
{
    DPVF( DPVF_ERRORLEVEL, "Informing clients of migration" );

    return Send_HostMigrated();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartSession"
//
// StartSession
//
// This function handles starting the directplayvoice session in the associated directplay/net
// session.  It also handles startup for a new host when the host migrates.  (Called by 
// HostMigrateStart in this case).
//
// Called By:
// - DV_StartSession
// - HostMigrateStart
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceServerEngine::StartSession(LPDVSESSIONDESC lpSessionDesc, DWORD dwFlags, DWORD dwHostOrderIDSeed )
{
    HRESULT hr;
    XMediaObject *pConverter;
    XMEDIAINFO xmi;
    WAVEFORMATEX wfx;

    DPVF_ENTER();

    DPVF( DPVF_ENTRYLEVEL, "Enter" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "Param: lpSessionDesc = 0x%p  dwFlags = 0x%x", lpSessionDesc, dwFlags );

#if DBG
    if( dwFlags !=0 )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid flags specified" );
        return DVERR_INVALIDFLAGS;
    }

    hr = DV_ValidSessionDesc( lpSessionDesc );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error validating session description.  hr=0x%x", hr );
        return hr;
    }

    DV_DUMP_SD( lpSessionDesc );    
#endif

    DV_AUTO_LOCK(&m_CS);

    switch( m_dwCurrentState )
    {
    case DVSSTATE_SHUTDOWN:
    case DVSSTATE_RUNNING:
    case DVSSTATE_STARTUP:
        DPVF( DPVF_ERRORLEVEL, "Session is already in progress." );
        return DVERR_HOSTING;
    case DVSSTATE_NOTINITIALIZED:
        DPVF( DPVF_ERRORLEVEL, "Object not initialized" );
        return DVERR_NOTINITIALIZED;
    }

    if( m_lpSessionTransport == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid transport" );
        return DVERR_INVALIDOBJECT;
    }

    // Retrieve the information about the dplay/dnet session
    hr = m_lpSessionTransport->GetTransportSettings( &m_dwTransportSessionType, &m_dwTransportFlags );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Could not retrieve transport settings hr=0x%x", hr );
        return hr;
    }

    // Peer-to-peer mode not available in client/server mode
    if( m_dwTransportSessionType == DVTRANSPORT_SESSION_CLIENTSERVER &&
        (lpSessionDesc->dwSessionType == DVSESSIONTYPE_PEER) )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot host peer session in client/server transport" );
        return DVERR_NOTSUPPORTED;
    }

    // Server control target not available if host migration is enabled
    if( (m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST) &&
        (lpSessionDesc->dwFlags & DVSESSION_SERVERCONTROLTARGET) )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot support host migration with server controlled targetting" );
        return DVERR_NOTSUPPORTED;
    }

    //
    // get compresssion info but instantiating a decode XMO for this guid..
    // then we will kill it..
    //

    memcpy(&wfx, s_lpwfxPrimaryFormat,sizeof(wfx));

    hr = DV_CreateConverter(lpSessionDesc->guidCT,
                            &pConverter,
                            &wfx,
                            NULL,
                            s_dwUnCompressedFrameSize,
                            FALSE);

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Compression type not supported. hr=0x%x", hr );
        return DVERR_COMPRESSIONNOTSUPPORTED;
    }

    memset(&xmi,0,sizeof(xmi));
    xmi.dwInputSize = 1;

    //
    // get compressed size from record subsystem instance of decoder
    //

    hr = pConverter->GetInfo(&xmi);

    if (FAILED(hr)) {
        return hr;
    }

    s_dwCompressedFrameSize = xmi.dwInputSize;
    s_dwUnCompressedFrameSize = xmi.dwOutputSize;


    DPVF(DPVF_INFOLEVEL, "Compressed frame size 0x%x, unCompressedSize 0x%x\n",
        s_dwCompressedFrameSize,
        s_dwUnCompressedFrameSize);

    //
    // delete converter XMO
    //

    ASSERT(pConverter->Release() == 0);

    SetCurrentState( DVSSTATE_STARTUP );

    // Scrub the session description

    memcpy( &m_dvSessionDesc, lpSessionDesc, sizeof( DVSESSIONDESC ) );

    m_dwNextHostOrderID = dwHostOrderIDSeed;

    hr = SetupBuffers();

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed to setup buffer pools hr=0x%x", hr );
        SetCurrentState( DVSSTATE_IDLE );        
        goto STARTSESSION_RETURN;
    }
#ifdef DVS_ENABLE_MULTICAST_SESSION
    if( lpSessionDesc->dwSessionType == DVSESSIONTYPE_FORWARDING )
    {
        hr = StartupMulticast();
                       
        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Unable to initializing multicast hr=0x%x", hr );
            SetCurrentState( DVSSTATE_IDLE );
            FreeBuffers();
            
            goto STARTSESSION_RETURN;
        }
    }
#endif

    // Setup name table
    m_voiceNameTable.Initialize();

    InitializeListHead(&m_PlayerActiveList);
    SetCurrentState( DVSSTATE_RUNNING );

    // Tell DirectPlay we're alive and want to see incoming traffic
    hr = m_lpSessionTransport->EnableReceiveHook( m_lpObject, DVTRANSPORT_OBJECTTYPE_SERVER );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed on call to EnableReceiveHook hr=0x%x", hr );
#ifdef DVS_ENABLE_MULTICAST_SESSION
        if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
        {
            ShutdownMulticast();
        }
#endif
        m_voiceNameTable.DeInitialize(TRUE, m_lpUserContext,m_lpMessageHandler);
        
        FreeBuffers();
        
        SetCurrentState( DVSSTATE_IDLE );
                
        goto STARTSESSION_RETURN;
    }

STARTSESSION_RETURN:

    DPVF( DPVF_ENTRYLEVEL, "Success" );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CheckForMigrate"
BOOL CDirectVoiceServerEngine::CheckForMigrate( DWORD dwFlags, BOOL fSilent )
{
    DPVF_ENTER();

    // We should shutdown the session if:
    //
    // 1. We're not in peer to peer mode
    // 2. "No host migration" flag was specified in session description
    // 3. "No host migrate" flag was specified on call to StopSession
    // 4. We were not asked to be silent
    // 5. There isn't a host migrate
    // 
    if( (m_dvSessionDesc.dwSessionType != DVSESSIONTYPE_PEER ) || 
        (m_dvSessionDesc.dwFlags & DVSESSION_NOHOSTMIGRATION) || 
        (dwFlags & DVFLAGS_NOHOSTMIGRATE) ||
        fSilent ||
        !(m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST) )
    {
        DPVF( DPVF_ERRORLEVEL, "Destroying session." );
        return FALSE;
    }
    // A migration is possible
    else
    {
        return TRUE;
    }
}



#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StopSession"
//
// StopSession
//
// This function is responsible for shutting down the directplayvoice session.  In sessions 
// without host migration, this function will simply cleanup the memory and detach itself
// from directplay.  This way directplay will take care of the host migration.  To use this
// option, specify fSilent = TRUE.
// 
// In addition, this function is called when an fatal error occurs while the session is 
// running.  
//
// It is also called when the user calls StopSession.
//
// Called By:
// - HandleMixerThreadError
// - HandleStopTransportSession
// - DVS_StopSession
// 
// Locks Required:
// - Global Write Lock
// 
HRESULT CDirectVoiceServerEngine::StopSession(DWORD dwFlags, BOOL fSilent, HRESULT hrResult )
{
    DPVF_ENTER();

    DPVF( DPVF_ENTRYLEVEL, "Begin" );
    DPVF( DPVF_APIPARAM, "Param: dwFlags = 0x%x", dwFlags );


    if( dwFlags & ~(DVFLAGS_NOHOSTMIGRATE) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid flags specified" );
        return DVERR_INVALIDFLAGS;
    }

    DV_AUTO_LOCK(&m_CS);

    // We need to be initialized
    if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not Initialized" );
        return DVERR_NOTINITIALIZED;
    }   

    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        DPVF( DPVF_ERRORLEVEL, "Session is not running" );
        return DVERR_NOTHOSTING;
    }

    // Check to see if there is migration going on.  If a migration should
    // happen then we do not transmit a session lost message
    //
    if( !FAILED( hrResult ) )
    {
        if( !CheckForMigrate( dwFlags, fSilent ) )
        {
            Send_SessionLost( DVERR_SESSIONLOST );
        }
        // Host is migrating.  Inform the users
        else if( m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST )
        {
            Send_HostMigrateLeave();
        }
    }

    // Wait until all the outstanding sends have completed  
    WaitForBufferReturns();

    // Disable receives
    m_lpSessionTransport->DisableReceiveHook( );

    // Waits for transport threads to be done inside our layer
    m_lpSessionTransport->WaitForDetachCompletion();    

    SetCurrentState( DVSSTATE_SHUTDOWN );

    // Kill name table
    m_voiceNameTable.DeInitialize(TRUE,m_lpUserContext,m_lpMessageHandler);

    // Cleanup the active list
    CleanupActiveList();

#ifdef DVS_ENABLE_MULTICAST_SESSION
    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
    {
        ShutdownMulticast();
    }
#endif
    FreeBuffers();
    
    SetCurrentState( DVSSTATE_IDLE );

    // Check to see if the transport session was closed
    if( hrResult == DVERR_SESSIONLOST )
    {
        DVMSG_SESSIONLOST dvMsgLost;
        dvMsgLost.dwSize = sizeof( DVMSG_SESSIONLOST );
        dvMsgLost.hrResult = hrResult;

        TransmitMessage( DVMSGID_SESSIONLOST, &dvMsgLost, sizeof( DVPROTOCOLMSG_SESSIONLOST ) );
    }

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    return DV_OK;
}

// WaitForBufferReturns
//
// This function waits until oustanding sends have completed before continuing
// we use this to ensure we don't deregister with outstanding sends.
// 
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::WaitForBufferReturns"
void CDirectVoiceServerEngine::WaitForBufferReturns()
{
    ULONG cnt = 0;
    DV_AUTO_LOCK(&m_CS);

    if((m_MsgBufferAllocs == 0) && (m_SpeechBufferAllocs == 0)) {
        DPVF_EXIT();                                         
        return;
    }        

    while( m_MsgBufferAllocs || m_SpeechBufferAllocs) 
    {
        m_lpSessionTransport->DoWork();
        Sleep( 20 );
        if (cnt ++ > 100) {
            break;
        }
    }

    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetSessionDesc"
//
// GetSessionDesc
//
// Called to retrieve the description of the current session.  
//
// Called By:
// - DVS_GetSessionDesc
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceServerEngine::GetSessionDesc( LPDVSESSIONDESC lpSessionDesc )
{
    DPVF_ENTER();

    DPVF( DPVF_ENTRYLEVEL, "Enter" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "Param: lpSessionDesc = 0x%p", lpSessionDesc );
#ifndef ASSUME_VALID_PARAMETERS
    if( lpSessionDesc == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Session desc pointer bad" );
        return DVERR_INVALIDPOINTER;
    }

    if( lpSessionDesc->dwSize != sizeof( DVSESSIONDESC ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid size on session desc" );
        return DVERR_INVALIDPARAM;
    }   
#endif

    DV_AUTO_LOCK(&m_CS);

    // We need to be initialized
    if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not Initialized" );
        return DVERR_NOTINITIALIZED;
    }   

    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        DPVF( DPVF_ERRORLEVEL, "No host running" );
        return DVERR_NOTHOSTING;
    }

    memcpy( lpSessionDesc, &m_dvSessionDesc, sizeof( DVSESSIONDESC ) );     
    
    DV_DUMP_SD( (LPDVSESSIONDESC) lpSessionDesc );
    DPVF( DPVF_ENTRYLEVEL, "Done, Returning DV_OK" );

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetTransmitTarget"
//
// SetTransmitTarget
//
// This function sets the transmit target for the specified user.  Only available in sessions with the 
// DVSESSION_SERVERCONTROLTARGET flag specified.
//
// Called By:
// - DVS_SetTransmitTarget
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceServerEngine::SetTransmitTarget(DVID dvidSource, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags)
{
    HRESULT hr;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    DPVF( DPVF_APIPARAM, "Param: dvidSource: 0x%x pdvidTargets: 0x%p  dwNumTargets: %d dwFlags: 0x%x", dvidSource, pdvidTargets, dwNumTargets, dwFlags );

#ifndef ASSUME_VALID_PARAMETERS
    hr = DV_ValidTargetList( pdvidTargets, dwNumTargets );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid target list hr=0x%x", hr );
        return hr;
    }

    // Flags must be 0.
    if( dwFlags != 0 )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid flags" );
        return DVERR_INVALIDFLAGS;
    }
#endif

    // We need to be initialized
    if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not Initialized" );
        return DVERR_NOTINITIALIZED;
    }

    // We need to be running
    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        DPVF( DPVF_ERRORLEVEL, "Not hosting" );
        return DVERR_NOTCONNECTED;
    }

    // Only if servercontroltarget is active
    if( !(m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET) )
    {
        DPVF( DPVF_ERRORLEVEL, "Only available with the DVSESSION_SERVERCONTROLTARGET session flag" );
        return DVERR_NOTALLOWED;
    }

    // Parameter checks
    if( !m_voiceNameTable.IsEntry( dvidSource ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid source player" );
        return DVERR_INVALIDPLAYER;
    }

    if( dwNumTargets > 0 )
    {
        for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
        {
            if( !m_voiceNameTable.IsEntry( pdvidTargets[dwIndex] ) )
            {
                if( !m_lpSessionTransport->ConfirmValidGroup( pdvidTargets[dwIndex] ) )
                {
                    DPVF( DPVF_ERRORLEVEL, "Invalid target player/group" );
                    return DVERR_INVALIDTARGET;
                }
            } 
        }
    }

    if( dvidSource == DVID_ALLPLAYERS )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot set the target for all or none" );
        return DVERR_INVALIDPLAYER;
    }   

    // Grab the player and set the target field
    CVoicePlayer *pPlayerInfo;

    hr = m_voiceNameTable.GetEntry( dvidSource, (CVoicePlayer **) &pPlayerInfo, TRUE ); 

    if( FAILED( hr ) || pPlayerInfo == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to lookup player entry.  hr=0x%x", hr );
        return DVERR_INVALIDPLAYER;
    }

    hr = pPlayerInfo->SetPlayerTargets( pdvidTargets, dwNumTargets );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to set player target hr=0x%x", hr );
        pPlayerInfo->Release();
        return hr;
    }
    
    hr = BuildAndSendTargetUpdate( dvidSource, pPlayerInfo );

    pPlayerInfo->Release();

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::BuildAndSendTargetUpdate"
//
// BuildAndSendTargetUpdate
//
// This function builds and sends a message with a target list to the specified
// user.
//
HRESULT CDirectVoiceServerEngine::BuildAndSendTargetUpdate( DVID dvidSource,CVoicePlayer *pPlayerInfo )
{
    // Grab the player and set the target field
    HRESULT hr;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    DWORD dwTransmitSize;
    PDVPROTOCOLMSG_SETTARGET pSetTargetMsg;
    PVOID pvSendContext;

    DPVF_ENTER();

    // Protect target information
    DV_AUTO_LOCK(&m_CS);

    dwTransmitSize = sizeof( DVPROTOCOLMSG_SETTARGET ) + (pPlayerInfo->GetNumTargets()*sizeof(DVID));

    pBufferDesc = GetTransmitBuffer( dwTransmitSize, &pvSendContext,SERVER_POOL_MESSAGE);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Failed to alloc memory" );
        return DVERR_BUFFERTOOSMALL;
    }

    pSetTargetMsg = (PDVPROTOCOLMSG_SETTARGET) pBufferDesc->pBufferData;

    // Send the message to the player
    pSetTargetMsg->dwType = DVMSGID_SETTARGETS;
    pSetTargetMsg->dwNumTargets = pPlayerInfo->GetNumTargets();
    
    memcpy( &pSetTargetMsg[1], pPlayerInfo->GetTargetList(), sizeof( DVID ) * pPlayerInfo->GetNumTargets() );

    hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to send target set message hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetTransmitTarget"
//
// GetTransmitTarget
//
// This function returns the current transmission target of the specified user.  
//
// Only available in sessions with the DVSESSION_SERVERCONTROLTARGET flag.
//
// Called By:
// - DVS_GetTransmitTarget
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceServerEngine::GetTransmitTarget(DVID dvidSource, LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags )
{
    HRESULT hr; 
    CVoicePlayer *pPlayerInfo;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();

    DPVF( DPVF_APIPARAM, "Param: dvidSource = 0x%x lpdvidTargets = 0x%p pdwNumElements = 0x%p dwFlags = 0x%x", dvidSource, lpdvidTargets, pdwNumElements, dwFlags );

#ifndef ASSUME_VALID_PARAMETERS
    if( pdwNumElements == NULL)
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
        return DVERR_INVALIDPOINTER;
    }

    if( pdwNumElements != NULL && 
        *pdwNumElements > 0 )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid target list buffer specified" );
        return DVERR_INVALIDPOINTER;
    }   

    if( pdwNumElements == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "You must provider a ptr # of elements" );
        return DVERR_INVALIDPARAM;
    }   

    // Flags must be 0.
    if( dwFlags != 0 )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid flags specified" );
        return DVERR_INVALIDFLAGS;
    }
#endif

    // We need to be initialized
    if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Object not initialized" );
        return DVERR_NOTINITIALIZED;
    }

    // We need to be running
    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        DPVF( DPVF_ERRORLEVEL, "No session running" );
        return DVERR_NOTCONNECTED;
    }

    // Only if servercontroltarget is active
    if( !(m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET) )
    {
        DPVF( DPVF_ERRORLEVEL, "Only available with the DVSESSION_SERVERCONTROLTARGET session flag" );
        return DVERR_NOTALLOWED;
    }

    if( dvidSource == DVID_ALLPLAYERS )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot get target for all or none" );
        return DVERR_INVALIDPLAYER;
    }

    // Parameter checks
    if( !m_voiceNameTable.IsEntry( dvidSource ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Specified player does not exist" );
        return DVERR_INVALIDPLAYER;
    } 

    // Grab the player and set the target field

    hr = m_voiceNameTable.GetEntry( dvidSource, (CVoicePlayer **) &pPlayerInfo, TRUE ); 

    if( FAILED( hr ) || pPlayerInfo == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Unable to lookup player entry.  hr=0x%x", hr );
        return DVERR_INVALIDPLAYER;
    }

    if( *pdwNumElements < pPlayerInfo->GetNumTargets() )
    {
        hr = DVERR_BUFFERTOOSMALL;
    }
    else
    {
        memcpy( lpdvidTargets, pPlayerInfo->GetTargetList(), pPlayerInfo->GetNumTargets()*sizeof(DVID) );
    }
    
    *pdwNumElements  = pPlayerInfo->GetNumTargets();

    pPlayerInfo->Release();

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Initialize"
//
// Initialize
//
// This function is responsible for connecting the DirectPlayVoiceServer object
// to the associated transport session.  It sets up the object and makes
// it ready for a call to StartSession.
//
// Called By:
// - DV_Initialize
//
// Locks Required:
// - Global Write Lock
// 
HRESULT CDirectVoiceServerEngine::Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{
    HRESULT hr;

    DPVF_ENTER();

    DPVF( DPVF_ENTRYLEVEL, "Begin" );
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "Param: lpTransport = 0x%p lpdvHandler = 0x%p lpUserContext = 0x%p ", lpTransport, lpdvHandler, lpUserContext );

    if( lpTransport == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
        return E_POINTER;
    }   

    DPVF( DPVF_ENTRYLEVEL, "Enter" );    
    DPVF( DPVF_APIPARAM, "lpdwMessages = 0x%p dwNumElements = %d", lpdwMessages, dwNumElements );

#ifndef ASSUMME_VALID_PARAMETERS
    hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, TRUE );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid message array hr=0x%x", hr );
        return hr;
    }
#endif
    DPVF( DPVF_APIPARAM, "Message IDs=%d", dwNumElements );

    if( lpdwMessages != NULL )
    {
        for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
        {
            DPVF( DPVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
        }
    }

    DV_AUTO_LOCK(&m_CS);
    
    if( m_dwCurrentState != DVSSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Already initialized");
    }

    if( lpdvHandler == NULL && lpdwMessages != NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
        return DVERR_NOCALLBACK;
    }

    SetCurrentState( DVSSTATE_IDLE );   

    m_lpMessageHandler = lpdvHandler;

    hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

    if( FAILED( hr ) )
    {
        SetCurrentState( DVSSTATE_NOTINITIALIZED ); 
        DPVF( DPVF_ERRORLEVEL, "SetNotifyMask Failed hr=0x%x", hr );
        return hr;
    }   

    m_lpSessionTransport = lpTransport;
    m_lpUserContext = lpUserContext;

    hr = m_lpSessionTransport->Initialize();
    if (FAILED(hr)) {

        return hr;

    }

    m_dvidLocal = m_lpSessionTransport->GetLocalID();

    DPVF( DPVF_ENTRYLEVEL, "DVSE::Initialize() End" );

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ReceiveSpeechMessage"
//
// ReceiveSpeechMessage
//
// Responsible for processing a speech message when it is received.  
//
// Called By:
// - DV_ReceiveSpeechMessage
//
// Locks Required:
// - None 
//
BOOL CDirectVoiceServerEngine::ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize )
{
    PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage;
    DPVF_ENTER();

    ASSERT( lpMessage );
    ASSERT( dwSize > 0 );

    lpdvFullMessage = (PDVPROTOCOLMSG_FULLMESSAGE) lpMessage;

    switch( lpdvFullMessage->dvGeneric.dwType )
    {
    case DVMSGID_SPEECHBOUNCE:
        // Ignore speech bounces, only reason we get is because we're sending to all or targetting
        // a client on the same ID as us.
        return TRUE;
    case DVMSGID_CONNECTREQUEST:
        return HandleConnectRequest( dvidSource, static_cast<PDVPROTOCOLMSG_CONNECTREQUEST>(lpMessage), dwSize );
    case DVMSGID_DISCONNECT:
        return HandleDisconnect( dvidSource, static_cast<PDVPROTOCOLMSG_DISCONNECT>(lpMessage), dwSize);
    case DVMSGID_SETTINGSCONFIRM:
        return HandleSettingsConfirm( dvidSource, static_cast<PDVPROTOCOLMSG_SETTINGSCONFIRM>(lpMessage), dwSize );
    case DVMSGID_SETTINGSREJECT:
        return HandleSettingsReject( dvidSource, static_cast<PDVPROTOCOLMSG_GENERIC>(lpMessage), dwSize );
    case DVMSGID_SPEECHWITHTARGET:
#ifdef DVS_ENABLE_MULTICAST_SESSION
        return HandleSpeechWithTarget( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHWITHTARGET>(lpMessage), dwSize );
#else
        ASSERT(FALSE);
        return FALSE;
#endif
    case DVMSGID_SPEECH:
        return HandleSpeech( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHHEADER>(lpMessage), dwSize );
    default:
        DPVF(  DPVF_WARNINGLEVEL, "DVSE::ReceiveSpeechMessage() Ignoring Non-Speech Message id=0x%x from=0x%x", 
             lpdvFullMessage->dvGeneric.dwType, dvidSource );
        return FALSE;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSpeech"
// HandleSpeech
//
// Handles processing of incoming speech packets (in echo server mode).
//
// How speech is handled depends on session type.  If the session is client/server, the 
// packet is buffered in the appropriate user's queue.  If the session is multicast,
// the packet is forwarded to the packet's target.
//
BOOL CDirectVoiceServerEngine::HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize )
{
    HRESULT hr = DV_OK;
    
    DPVF(DPVF_SPAMLEVEL, "(mixin/echo mode not supported)Ignoring Speech Message from=0x%x", 
         dvidSource );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSpeechWithTarget"
// HandleSpeechWithTarget
//
// Handles processing of incoming speech packets.
//
// How speech is handled depends on session type.  If the session is client/server, the 
// packet is buffered in the appropriate user's queue.  If the session is multicast,
// the packet is forwarded to the packet's target.
//

#ifdef DVS_ENABLE_MULTICAST_SESSION

BOOL CDirectVoiceServerEngine::HandleSpeechWithTarget( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHTARGET lpdvSpeech, DWORD dwSize )
{
    DPVF_ENTER();

    DPVF(DPVF_ENTRYLEVEL, "Enter");

    DWORD dwSpeechSize;     // Size of speech portion in bytes
    DWORD dwTargetSize;     // Size of targetting info in bytes
    PBYTE pSourceSpeech;    // Pointer to speech within the packet
    HRESULT hr;
                                                                                 
    ASSERT( dwSize >= sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) );

    dwTargetSize = lpdvSpeech->dwNumTargets*sizeof(DVID);

    ASSERT( dwSize >= (dwTargetSize + sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )+dwTargetSize ) );
    
    dwSpeechSize = dwSize - sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) - dwTargetSize;

    pSourceSpeech = (PBYTE) lpdvSpeech;
    pSourceSpeech += sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) + dwTargetSize;
    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
    {
        PDVTRANSPORT_BUFFERDESC pBufferDesc;
        PDVPROTOCOLMSG_SPEECHWITHFROM pdvSpeechWithFrom;
        PVOID pvSendContext;

        DWORD dwTransmitSize = (dwSize - dwTargetSize - sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )) + sizeof( DVPROTOCOLMSG_SPEECHWITHFROM );
                               
        ASSERT(dwTransmitSize <= s_dwCompressedFrameSize + sizeof( DVPROTOCOLMSG_SPEECHWITHFROM ) );

        pBufferDesc = GetTransmitBuffer( dwTransmitSize, &pvSendContext,SERVER_POOL_SPEECH );

        if( pBufferDesc == NULL )
        {
            DPVF( DPVF_ERRORLEVEL, "Error allocating memory" );
            return FALSE;
        }

        pdvSpeechWithFrom = (PDVPROTOCOLMSG_SPEECHWITHFROM) pBufferDesc->pBufferData;

        pdvSpeechWithFrom->dvHeader.dwType = DVMSGID_SPEECHWITHFROM;
        pdvSpeechWithFrom->dvHeader.bMsgNum = lpdvSpeech->dvHeader.bMsgNum;
        pdvSpeechWithFrom->dvHeader.bSeqNum = lpdvSpeech->dvHeader.bSeqNum;
        pdvSpeechWithFrom->dvidFrom = dvidSource;

        memcpy( &pdvSpeechWithFrom[1], pSourceSpeech, dwSpeechSize );
        
        hr = m_lpSessionTransport->SendToIDS( (PDVID) &lpdvSpeech[1], lpdvSpeech->dwNumTargets, pBufferDesc, pvSendContext, 0 );

        if( hr == DVERR_PENDING )
        {
            hr = DV_OK;
        }
        else if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Failed sending to ID hr=0x%x", hr );
            ReturnTransmitBuffer( pvSendContext );
        }       
    }

    DPVF(DPVF_ENTRYLEVEL, "Exit");

    return TRUE;
}

#endif


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::DoPlayerDisconnect"
//
// Performs the work of removing the specified player from the session.
//
// Optionally informs the specified player of their disconnection.  
//
// Called By:
// - HandleDisconnect (Player requests disconnect)
// - RemovePlayer (Dplay tells us player disconnected)
//
// Locks Required:
// - Global Write Lock
//
void CDirectVoiceServerEngine::DoPlayerDisconnect( DVID dvidPlayer, BOOL bInformPlayer ) 
{
    CVoicePlayer *pPlayerInfo = NULL;
    HRESULT hr;

    DPVF_ENTER();

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Disconnecting player 0x%x", dvidPlayer );

    DV_AUTO_LOCK(&m_CS);
    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        DPVF( DPVF_ERRORLEVEL, "Player disconnect ignored, not running" );
        return;
    }

    hr = m_voiceNameTable.GetEntry( dvidPlayer, &pPlayerInfo, TRUE );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_WARNINGLEVEL, "Error retrieving player entry. hr=0x%x Player may have dropped", hr );
        return;
    }
    else
    {
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Retrieved record" );   
    }

    // Mark record as disconnected
    pPlayerInfo->SetDisconnected();

    // Release reference and remove from the nametable
    m_voiceNameTable.DeleteEntry( dvidPlayer );

    // Remove player from the "active" list!
    pPlayerInfo->RemoveFromNotifyList();
    pPlayerInfo->Release();

#ifdef DVS_ENABLE_PEER_SESSION
    // If we're peer to peer session, inform players of disconnection
    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
    {
        hr = Send_DeletePlayer( dvidPlayer );

        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Error sending deleteplayer to all hr=0x%x", hr );
        }

        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent player Quit to all" );                
    }
#endif
    // If specified, send a message to the user to inform them of the disconnection
    if( bInformPlayer )
    {
        hr = Send_DisconnectConfirm( dvidPlayer, DV_OK );

        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Error sending disconnect confirm hr=0x%x", hr );
        }
        else
        {
            DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent disconnect confirm to player" );                          
        }
    }

    DVMSG_DELETEVOICEPLAYER dvDeletePlayer;
    dvDeletePlayer.dvidPlayer = dvidPlayer;
    dvDeletePlayer.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
    dvDeletePlayer.pvPlayerContext = pPlayerInfo->GetContext();
    pPlayerInfo->SetContext( NULL );

    // Release reference for find
    pPlayerInfo->Release(); 

    TransmitMessage( DVMSGID_DELETEVOICEPLAYER, &dvDeletePlayer, sizeof( DVMSG_DELETEVOICEPLAYER ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleDisconnect"
//
// HandleDisconnect
//
// Called when a DVMSGID_DISCONNECT message is received.
//
// Called By:
// - ReceiveSpeechMessage
//
// Locks Required:
// - None
//
BOOL CDirectVoiceServerEngine::HandleDisconnect( DVID dvidSource, PDVPROTOCOLMSG_DISCONNECT lpdvDisconnect, DWORD dwSize )
{
    DoPlayerDisconnect( dvidSource, TRUE );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CreatePlayerEntry"
// 
// CreatePlayerEntry
//
// Performs the actual work of creating a player entity.  The work performed depends on the 
// type of session.
//
// Called By:
// - HandleSettingsConfirm
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::CreatePlayerEntry( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwHostOrderID, CVoicePlayer **ppPlayer )
{
    HRESULT hr;
    CVoicePlayer *pNewPlayer;
    PLIST_ENTRY pEntry;

    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Requesting create [ID=0x%x]",dvidSource );

    pEntry = RemoveTailList(&m_PlayerContextPool);
    pNewPlayer = (CVoicePlayer *) CONTAINING_RECORD(pEntry, CVoicePlayer, m_PoolEntry);


    if( pNewPlayer == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "CDirectVoiceServerEngine::CreatePlayerEntry() Alloc failure on player struct" );
        return DVERR_OUTOFMEMORY;
    }

    hr = pNewPlayer->Initialize( dvidSource, dwHostOrderID, 0, lpdvSettingsConfirm->dwFlags, NULL, &m_PlayerContextPool);

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error initializing new player record hr=0x%x", hr );
        return hr;
    }

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Created regular player" );     

    hr = m_voiceNameTable.AddEntry( dvidSource, pNewPlayer );

    // Add failed.. release our entry, destroying player
    if( FAILED( hr ) )
    {
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Error adding player to nametable hr=0x%x", hr );
        pNewPlayer->Release();
        return hr;
    }

    // Add player to the "active" list!

    pNewPlayer->AddToNotifyList(&m_PlayerActiveList);
    pNewPlayer->AddRef();

    *ppPlayer = pNewPlayer;

    return DV_OK;
}

#ifdef DVS_ENABLE_PEER_SESSION
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SendPlayerList"
//
// SendPlayerList
//
// This function sends a bunch of DVMSGID_PLAYERLIST messages to the 
// client containing the list of current players.
//
// This will send multiple structues if the number 
// 
HRESULT CDirectVoiceServerEngine::SendPlayerList( DVID dvidSource, DWORD dwHostOrderID )
{
    BOOL bContinueEnum = FALSE;
    CVoicePlayer *lpPlayer;     
    LIST_ENTRY *pSearch;

    HRESULT hr = DV_OK;

    BOOL  fAtLeastOneSent = FALSE;
    DWORD dwCurrentBufferLoc;
    DWORD dwNumInCurrentPacket;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PDVPROTOCOLMSG_PLAYERLIST lpdvPlayerList;
    DVPROTOCOLMSG_PLAYERLIST_ENTRY *pdvPlayerEntries;
    PVOID pvSendContext;
    
    DPVF_ENTER();

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Building player list" );

    pBufferDesc = GetTransmitBuffer(DVPROTOCOL_PLAYERLIST_MAXSIZE, &pvSendContext,SERVER_POOL_PLAYERLIST);

    if( pBufferDesc == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Out of memory!" );
        return DVERR_OUTOFMEMORY;
    }

    lpdvPlayerList = (PDVPROTOCOLMSG_PLAYERLIST) pBufferDesc->pBufferData;

    pdvPlayerEntries = (DVPROTOCOLMSG_PLAYERLIST_ENTRY *) &lpdvPlayerList[1];

    lpdvPlayerList->dwType = DVMSGID_PLAYERLIST;
    lpdvPlayerList->dwHostOrderID = dwHostOrderID;  
    
    dwNumInCurrentPacket = 0;
    dwCurrentBufferLoc = sizeof(DVPROTOCOLMSG_PLAYERLIST); 

    DV_AUTO_LOCK(&m_CS);

    pSearch = m_PlayerActiveList.Flink;

    while( pSearch != &m_PlayerActiveList )
    {
        lpPlayer = CONTAINING_RECORD( pSearch, CVoicePlayer, m_NotifyListEntry );

        // We need to split the packet, start a new packet, transmit this one.
        if( (dwCurrentBufferLoc+sizeof(DVPROTOCOLMSG_PLAYERLIST_ENTRY)) > DVPROTOCOL_PLAYERLIST_MAXSIZE )
        {
            // Wrap up current packet and transmit
            lpdvPlayerList->dwNumEntries = dwNumInCurrentPacket;

            pBufferDesc->dwBufferSize = dwCurrentBufferLoc;
            
            hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1,pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );             

            if( hr == DVERR_PENDING )
            {
                hr = DV_OK;
            }
            else if( FAILED( hr ) )
            {
                DPVF( DPVF_WARNINGLEVEL, "Error on internal send hr=0x%x (Didn't get playerlist)", hr );
                ReturnTransmitBuffer( pvSendContext );
                return hr;
            }               

            // Reset for further players

            DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Transmitting playerlist chunk %d players", dwNumInCurrentPacket );

            pBufferDesc = GetTransmitBuffer(DVPROTOCOL_PLAYERLIST_MAXSIZE, &pvSendContext, SERVER_POOL_PLAYERLIST);

            if( pBufferDesc == NULL )
            {
                DPVF( DPVF_ERRORLEVEL, "Out of memory!" );
                return DVERR_OUTOFMEMORY;
            }

            lpdvPlayerList = (PDVPROTOCOLMSG_PLAYERLIST) pBufferDesc->pBufferData;
            pdvPlayerEntries = (DVPROTOCOLMSG_PLAYERLIST_ENTRY *) &lpdvPlayerList[1];
            lpdvPlayerList->dwType = DVMSGID_PLAYERLIST;
            lpdvPlayerList->dwHostOrderID = dwHostOrderID;  
            dwCurrentBufferLoc = sizeof(DVPROTOCOLMSG_PLAYERLIST);          
            dwNumInCurrentPacket = 0;
            fAtLeastOneSent = TRUE;

        }

        pdvPlayerEntries[dwNumInCurrentPacket].dvidID = lpPlayer->GetPlayerID();
        pdvPlayerEntries[dwNumInCurrentPacket].dwPlayerFlags = lpPlayer->GetTransportFlags();
        pdvPlayerEntries[dwNumInCurrentPacket].dwHostOrderID = lpPlayer->GetHostOrder();

        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Adding player ID 0x%x", lpPlayer->GetPlayerID() );     

        dwNumInCurrentPacket++;
        dwCurrentBufferLoc += sizeof(DVPROTOCOLMSG_PLAYERLIST_ENTRY);

        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Got next player" );                    
        pSearch = pSearch->Flink;
    }

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Build Complete" ); 

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Total of %d entries", dwNumInCurrentPacket );

    // Remaining entries to be sent
    // 
    // (Or empty packet just so user gets their ID)
    // 
    if( !fAtLeastOneSent  )
    {
        // Wrap up current packet and transmit
        lpdvPlayerList->dwNumEntries = dwNumInCurrentPacket;

        pBufferDesc->dwBufferSize = dwCurrentBufferLoc;     
                
        hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );                    

        if( hr == DVERR_PENDING || hr == DV_OK )
        {
            DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Playerlist sent" );
        }
        else
        {
            ReturnTransmitBuffer( pvSendContext );
            DPVF( DPVF_ERRORLEVEL, "Error on internal send hr=0x%x (Didn't get playerlist)", hr );
        }
    }

    return hr;
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSettingsConfirm"
//
// HandleSettingsConfirm
//
// Called to handle the DVMSGID_SETTINGSCONFIRM message.  Creates a player entry for
// the specified player and optionally informs all players in the session.
//
// Called By:
// - ReceiveSpeechMessage
//
// Locks Required:
// - Global Write Lock
//
BOOL CDirectVoiceServerEngine::HandleSettingsConfirm( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwSize )
{
    HRESULT hr;
    CVoicePlayer *pPlayer;
    
    DPVF_ENTER();

    DPVF( DPVF_ENTRYLEVEL, "Start [ID=0x%x]", dvidSource );
    
    DV_AUTO_LOCK(&m_CS);
    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        DPVF( DPVF_ERRORLEVEL, "Ignoring settings confirm message, not hosting" );
        return TRUE;
    }

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Received settings confirm [ID=0x%x]", dvidSource );

    DWORD dwHostOrderID;    

    // This is a host migration version of this message, so re-use existing 
    // host order ID
    //
    if( lpdvSettingsConfirm->dwHostOrderID != DVPROTOCOL_HOSTORDER_INVALID )
    {
        dwHostOrderID = lpdvSettingsConfirm->dwHostOrderID; 

        // Further reduce chances of duplicate ID, if we received a host order ID > then
        // the last ID offset the next value by offset again.
        if( dwHostOrderID > m_dwNextHostOrderID )
        {
            m_dwNextHostOrderID += DVMIGRATE_ORDERID_OFFSET;
        }
    }
    else
    {
        dwHostOrderID = m_dwNextHostOrderID;        
        m_dwNextHostOrderID++;
    }

    hr = CreatePlayerEntry( dvidSource, lpdvSettingsConfirm, dwHostOrderID, &pPlayer );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_WARNINGLEVEL, "Error creating player entry. [ID=0x%x] hr=0x%x", dvidSource, hr );
        DPVF( DPVF_WARNINGLEVEL, "Normal during host migration" );
        return TRUE;
    }
    else
    {
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Player Created [ID=0x%x]", dvidSource );
    }
#ifdef DVS_ENABLE_PEER_SESSION
    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
    {
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Sending current player list [ID=0x%x]", dvidSource );
        
        hr = SendPlayerList( dvidSource, dwHostOrderID );

        if( FAILED( hr ) )
        {
            DPVF( DPVF_WARNINGLEVEL, "Unable to send player list to player [ID=0x%x] hr=0x%x", dvidSource, hr );
        }
        else
        {
            DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Playerlist sent [[ID=0x%x]", dvidSource );
        }

        hr = Send_CreatePlayer( DVID_ALLPLAYERS, pPlayer );

        if( FAILED( hr ) )
        {
            DPVF( DPVF_ERRORLEVEL, "Send to all for new player failed hr=0x%x", hr );
        }
        else
        {
            DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Informed players of join of [ID=0x%x]", dvidSource );
        }
    }
#endif
    DVMSG_CREATEVOICEPLAYER dvCreatePlayer;
    dvCreatePlayer.dvidPlayer = dvidSource;
    dvCreatePlayer.dwFlags = lpdvSettingsConfirm->dwFlags;
    dvCreatePlayer.dwSize = sizeof( DVMSG_CREATEVOICEPLAYER );
    dvCreatePlayer.pvPlayerContext = NULL;

    TransmitMessage( DVMSGID_CREATEVOICEPLAYER, &dvCreatePlayer, sizeof( DVMSG_CREATEVOICEPLAYER ) );

    pPlayer->SetContext( dvCreatePlayer.pvPlayerContext );

    // Release our reference to the player 
    pPlayer->Release();

    DPVF( DPVF_ENTRYLEVEL, "Done processing [ID=0x%x]", dvidSource );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSettingsReject"
//
// HandleSettingsReject
//
// This message type is ignored.
//
BOOL CDirectVoiceServerEngine::HandleSettingsReject( DVID dvidSource, PDVPROTOCOLMSG_GENERIC lpdvGeneric, DWORD dwSize )
{
    return TRUE;
}

BOOL CDirectVoiceServerEngine::CheckProtocolCompatible( BYTE ucMajor, BYTE ucMinor, DWORD dwBuild ) 
{
    /*
    if( ucMajor != DVPROTOCOL_VERSION_MAJOR ||
        ucMinor != DVPROTOCOL_VERSION_MINOR ||
        dwBuild != DVPROTOCOL_VERSION_BUILD )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }*/
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleConnectRequest"
//
// HandleConnectRequest
//
// This function is responsible for responding to user connect requests.  It is the server's
// oportunity to reject or accept players.  Called in response to a DVMSGID_CONNECTREQUEST
// message.
//
// Called By:
// - ReceiveSpeechMessage
//
// Locks Required:
// - Global Read Lock
// 
BOOL CDirectVoiceServerEngine::HandleConnectRequest( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREQUEST lpdvConnectRequest, DWORD dwSize )
{
    HRESULT hr;

    DPVF_ENTER();

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Receive Connect Request.. From [ID=0x%x]", dvidSource );
    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Processing Request.. [ID=0x%x]", dvidSource );

    // Handle case where we've shutdown or starting up and we
    // receive this message
    //
    if( m_dwCurrentState != DVSSTATE_RUNNING )
    {
        hr = Send_ConnectRefuse( dvidSource, DVERR_NOTHOSTING );

        if( FAILED( hr ) )
        {
            DPVF( DPVF_WARNINGLEVEL, "Error! Failed on internal send hr=0x%x", hr );
        }

        return TRUE;
    }

    if( !CheckProtocolCompatible( lpdvConnectRequest->ucVersionMajor, 
                               lpdvConnectRequest->ucVersionMinor, 
                               lpdvConnectRequest->dwVersionBuild ) )
    {
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Protocol is not compatible.  [ID=0x%x] Current=%d.%d b%d User=%d.%d b%d", dvidSource,
                            DVPROTOCOL_VERSION_MAJOR, 
                            DVPROTOCOL_VERSION_MINOR,
                            DVPROTOCOL_VERSION_BUILD,
                            lpdvConnectRequest->ucVersionMajor, 
                            lpdvConnectRequest->ucVersionMinor, 
                            lpdvConnectRequest->dwVersionBuild );
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Rejecting connection request. [ID=0x%x]", dvidSource );

        hr = Send_ConnectRefuse( dvidSource, DVERR_INCOMPATIBLEVERSION );

        if( FAILED( hr ) )
        {
            DPVF( DPVF_WARNINGLEVEL, "Error! Failed on internal send hr=0x%x", hr );
        }       

        return TRUE;
    }

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Processing Request..2 [ID=0x%x]", dvidSource );

    hr = Send_ConnectAccept( dvidSource );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Error sending player's connect request: hr=0x%x", hr );
        //// TODO: Handle this case better
    }
    else
    {
        DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent connect request [ID=0x%x]", dvidSource );
    }

    DPVF( DPVF_PLAYERMANAGE_DEBUG_LEVEL, "Processing Request..4 [ID=0x%x]", dvidSource );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StopTransportSession"
//
// StopTransportSession
// 
// This function is called by the transport when the transport session
// is stopped.
//
// Called By:
// - DV_NotifyEvent
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::StopTransportSession()
{
    StopSession(0,FALSE,DVERR_SESSIONLOST);
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartTransportSession"
HRESULT CDirectVoiceServerEngine::StartTransportSession( )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::AddPlayer"
HRESULT CDirectVoiceServerEngine::AddPlayer( DVID dvID )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::RemovePlayer"
HRESULT CDirectVoiceServerEngine::RemovePlayer( DVID dvID )
{
    if( m_voiceNameTable.IsEntry( dvID ) )
    {
        DoPlayerDisconnect( dvID, FALSE );
    }

    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CreateGroup"
HRESULT CDirectVoiceServerEngine::CreateGroup( DVID dvID )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::DeleteGroup"
HRESULT CDirectVoiceServerEngine::DeleteGroup( DVID dvID )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::AddPlayerToGroup"
HRESULT CDirectVoiceServerEngine::AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::RemovePlayerFromGroup"
HRESULT CDirectVoiceServerEngine::RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer )
{
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetCurrentState"
// SetCurrentState
//
// Sets the current state of the client engine
// 
void CDirectVoiceServerEngine::SetCurrentState( DWORD dwState )
{
    DV_AUTO_LOCK(&m_CS);
    m_dwCurrentState = dwState;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::MigrateHost"
//
// MigrateHost
//
// This function is responsible for stoping the host in the case where the host
// suddenly migrates from this client.
//
// In most cases the session will be lost before this occurs on the local object
// and this will never get called.
// 
HRESULT CDirectVoiceServerEngine::MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer )
{
    // Cleanup... 
//  return StopSession( DVFLAGS_SYNC, TRUE );
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::InternalSetNotifyMask"
// 
// SetNotifyMask
//
HRESULT CDirectVoiceServerEngine::InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    if( m_lpdwMessageElements != NULL )
    {
        delete [] m_lpdwMessageElements;
    }

    m_dwNumMessageElements = dwNumElements;

    // Make copies of the message elements into our own message array.
    if( m_dwNumMessageElements > 0 )
    {
        m_lpdwMessageElements = new DWORD[m_dwNumMessageElements];

        if( m_lpdwMessageElements == NULL )
        {
            DPVF( DPVF_ERRORLEVEL, "Initialize: Error allocating memory" );
            return DVERR_OUTOFMEMORY;
        }

        memcpy( m_lpdwMessageElements, lpdwMessages, sizeof(DWORD)*m_dwNumMessageElements );
    }
    else
    {
        m_lpdwMessageElements = NULL;
    }   

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetNotifyMask"
// 
// SetNotifyMask
//
// This function sets the notification mask for the DirectPlayVoice object.
//
// The array passed in lpdwMessages specify the ID's of the notifications the user wishes to
// receive.  This or specifying NULL for the array turns on all notifications.
//
// Called By:
// - DVS_SetNotifyMask
//
// Locks Required:
// - m_csNotifyLock (Notification array lock)
//
HRESULT CDirectVoiceServerEngine::SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{
    HRESULT hr;

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    DPVF( DPVF_ENTRYLEVEL, "Enter" );    
    // 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
    DPVF( DPVF_APIPARAM, "lpdwMessages = 0x%p dwNumElements = %d", lpdwMessages, dwNumElements );

#ifndef ASSUME_VALID_PARAMETERS
    hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, TRUE );

    if( FAILED( hr ) )
    {
        DPVF( DPVF_ERRORLEVEL, "Invalid message array hr=0x%x", hr);
        return hr;
    }
#endif
    DPVF( DPVF_APIPARAM, "Message IDs=%d", dwNumElements );

    if( lpdwMessages != NULL )
    {
        for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
        {
            DPVF( DPVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
        }
    }

    if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
    {
        DPVF( DPVF_ERRORLEVEL, "Not initialized" );
        return DVERR_NOTINITIALIZED;
    }

    if( m_lpMessageHandler == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
        return DVERR_NOCALLBACK;
    }   

    hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

    DPVF( DPVF_ENTRYLEVEL, "Done" );

    return hr;

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CleanupActiveList"
void CDirectVoiceServerEngine::CleanupActiveList()
{
    LIST_ENTRY *pSearch;
    CVoicePlayer *pVoicePlayer;

    DPVF_ENTER();

    DV_AUTO_LOCK(&m_CS);

    pSearch = m_PlayerActiveList.Flink;

    while( pSearch != &m_PlayerActiveList )
    {
        pVoicePlayer = CONTAINING_RECORD( pSearch, CVoicePlayer, m_NotifyListEntry );

        pSearch = pSearch->Flink;

        pVoicePlayer->RemoveFromNotifyList();
        pVoicePlayer->Release();
    }

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetTransmitBuffer"
PDVTRANSPORT_BUFFERDESC CDirectVoiceServerEngine::GetTransmitBuffer( DWORD dwSize, LPVOID *ppvSendContext, DWORD dwPoolNumber )
{
    PDVTRANSPORT_BUFFERDESC pNewBuffer = NULL;
    DWORD dwFPMIndex = 0xFFFFFFFF;
    DWORD dwWastedSpace = 0xFFFFFFFF;
    DWORD dwSearchFPMIndex;    
    PLIST_ENTRY  pListHead;    

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);


    pNewBuffer = (PDVTRANSPORT_BUFFERDESC) DV_REMOVE_TAIL(&m_BufferDescPool);

    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer desc address 0x%p", (void *) pNewBuffer );

    if( pNewBuffer == NULL )
    {
        DPVF( DPVF_ERRORLEVEL, "Error getting transmit buffer" );
        goto GETTRANSMITBUFFER_ERROR;
    }

    pNewBuffer->lRefCount = 0;
    pNewBuffer->dwObjectType = DVTRANSPORT_OBJECTTYPE_SERVER;
    pNewBuffer->dwFlags = 0;
    
    switch (dwPoolNumber) {
    case SERVER_POOL_MESSAGE:
        m_MsgBufferAllocs++;
        pListHead = &m_MessagePool;
        break;
    case SERVER_POOL_PLAYERLIST:
        pListHead = &m_PlayerListPool;
        break;
    case SERVER_POOL_SPEECH:
        m_SpeechBufferAllocs++;
        pListHead = &m_SpeechBufferPool;
        break;
    }

    pNewBuffer->pvContext = pListHead;    
    pNewBuffer->pBufferData = (PBYTE) DV_REMOVE_TAIL(pListHead);    

    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer value at address 0x%p", (void *) pNewBuffer->pBufferData );

    if( pNewBuffer->pBufferData == NULL )
    {
        DPVF( 0, "Error getting buffer for buffer desc" );
        goto GETTRANSMITBUFFER_ERROR;
    }
    
    pNewBuffer->dwBufferSize = dwSize;
    *ppvSendContext = pNewBuffer;

    return pNewBuffer;

GETTRANSMITBUFFER_ERROR:
   
    if (dwPoolNumber == SERVER_POOL_MESSAGE) {

        m_SpeechBufferAllocs--;
        
    } else if (dwPoolNumber == SERVER_POOL_SPEECH) {

        m_MsgBufferAllocs--;

    }

    if( pNewBuffer != NULL && pNewBuffer->pBufferData != NULL )
    {
        DV_INSERT_TAIL(pListHead,pNewBuffer->pBufferData );
    }

    if( pNewBuffer != NULL )
    {
        DV_INSERT_TAIL(&m_BufferDescPool,pNewBuffer );
    }    

    return NULL;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ReturnTransmitBuffer"
// ReturnTransmitBuffer
//
// PDVTRANSPORT_BUFFERDESC pBufferDesc - Buffer description of buffer to return
// LPVOID lpvContext - Context value to be used when returning the buffer 
// 
void CDirectVoiceServerEngine::ReturnTransmitBuffer( PVOID pvContext )
{
    PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pvContext;
    PLIST_ENTRY pPool = (PLIST_ENTRY) pBufferDesc->pvContext;    

    DPVF_ENTER();

    if (pPool == &m_SpeechBufferPool) {
        m_SpeechBufferAllocs--;
    }
        
    if (pPool == &m_MessagePool) {
        m_MsgBufferAllocs--;
    }

    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer desc at address 0x%p", (void *) pBufferDesc );
    DPVF( DPVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer at address 0x%p", (void *) pBufferDesc->pBufferData );    

    // Release memory
    DV_INSERT_TAIL(pPool,pBufferDesc->pBufferData );

    // Release buffer description
    DV_INSERT_TAIL(&m_BufferDescPool,pBufferDesc);
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SendComplete"
HRESULT CDirectVoiceServerEngine::SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete )
{
    DPVF_ENTER();
    ReturnTransmitBuffer( pSendComplete->pvUserContext );
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetupBuffers"
HRESULT CDirectVoiceServerEngine::SetupBuffers()
{
    HRESULT hr = DV_OK;    

    DPVF_ENTER();
    DV_AUTO_LOCK(&m_CS);

    InitializeListHead(&m_BufferDescPool);
    hr = DV_InitializeList(&m_BufferDescPool,
                      m_lpSessionTransport->GetMaxPlayers()*DV_CT_FRAMES_PER_PERIOD,
                      sizeof(DVTRANSPORT_BUFFERDESC),
                      DVLAT_RAW);
    if (SUCCEEDED(hr)) {

        m_pBufferDescAllocation = m_BufferDescPool.Flink;

        InitializeListHead(&m_MessagePool);
        hr = DV_InitializeList(&m_MessagePool,
                          m_lpSessionTransport->GetMaxPlayers()*2,
                          sizeof(DVPROTOCOLMSG_FULLMESSAGE),
                          DVLAT_RAW);

    }

    if (SUCCEEDED(hr)) {

        m_pMessagePoolAllocation = m_MessagePool.Flink;

        InitializeListHead(&m_PlayerListPool);
        hr = DV_InitializeList(&m_PlayerListPool,
                          m_lpSessionTransport->GetMaxPlayers(),
                          DVPROTOCOL_PLAYERLIST_MAXSIZE,
                          DVLAT_RAW);

    }

    if (SUCCEEDED(hr)) {

        DWORD size;

        m_pPlayerListPoolAllocation = m_PlayerListPool.Flink;

        size = sizeof(DVPROTOCOLMSG_SPEECHWITHFROM) + \
            s_dwCompressedFrameSize + COMPRESSION_SLUSH;

        InitializeListHead(&m_SpeechBufferPool);
        hr = DV_InitializeList(&m_SpeechBufferPool,
                          m_lpSessionTransport->GetMaxPlayers()*DV_CT_FRAMES_PER_PERIOD,
                          size,
                          DVLAT_RAW);
        
    }

    if (SUCCEEDED(hr)) {

        m_pSpeechBufferAllocation = m_SpeechBufferPool.Flink;

        InitializeListHead(&m_PlayerContextPool);
        hr = DV_InitializeList(&m_PlayerContextPool,
                          m_lpSessionTransport->GetMaxPlayers(),
                          1,
                          DVLAT_CVOICEPLAYER);

    }


    if (FAILED(hr)) {

        DPVF( 0, "Error buffer pools" );
        FreeBuffers();
        return DVERR_OUTOFMEMORY; 
    }

    return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::FreeBuffers"
HRESULT CDirectVoiceServerEngine::FreeBuffers()
{

    DPVF_ENTER();

    DV_FreeList(&m_BufferDescPool, DVLAT_RAW);
    DV_FreeList(&m_MessagePool, DVLAT_RAW);
    DV_FreeList(&m_PlayerListPool, DVLAT_RAW);
    DV_FreeList(&m_PlayerContextPool, DVLAT_CVOICEPLAYER);
    DV_FreeList(&m_SpeechBufferPool, DVLAT_RAW);

    DV_POOL_FREE(m_pBufferDescAllocation);
    DV_POOL_FREE(m_pMessagePoolAllocation);
    DV_POOL_FREE(m_pSpeechBufferAllocation);
    DV_POOL_FREE(m_pPlayerListPoolAllocation);

    m_pPlayerListPoolAllocation = NULL;
    m_pBufferDescAllocation = NULL;
    m_pMessagePoolAllocation = NULL;
    m_pSpeechBufferAllocation = NULL;


    return DV_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvserver.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvserver.h
 *  Content:	Defines functions for the DirectXVoiceServer interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	02/07/99	rodtoll	Created It
 *  09/01/2000  georgioc started rewrite/port to xbox
 ***************************************************************************/
#ifndef __DVSERVER__
#define __DVSERVER__

#include "dvntos.h"
#include <dvoicep.h>
#include "dvsereng.h"
#include "dvshared.h"
#include "trnotify.h"
#include "dvdxtran.h"


volatile struct DIRECTVOICESERVEROBJECT : public DIRECTVOICEOBJECT
{
	CDirectVoiceServerEngine	*lpDVServerEngine;
};

typedef DIRECTVOICESERVEROBJECT *LPDIRECTVOICESERVEROBJECT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvsndt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvsndt.cpp
 *  Content:	Implementation of CSoundTarget class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/02/99		rodtoll	Created
 * 09/01/2000   georgioc  started complete rewrite to use xmos
 ***************************************************************************/

#include "dvsndt.h"
#include <stdio.h>

#define SOUNDTARGET_WRITEAHEAD			2

// Max # of restarts to attempt on a buffer
#define SOUNDTARGET_MAX_RESTARTS		10

// Max # of frames of silence which are written ahead of the latest frame
// of audio
#define SOUNDTARGET_MAX_WRITEAHEAD		3


#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::Initialize"
//
// Initialize
//
HRESULT CSoundTarget::Initialize(
    DWORD dwFrameSize
    )
{

	m_dwFrameSize = dwFrameSize;
    return Flush();

}

HRESULT STDMETHODCALLTYPE CSoundTarget::Flush()    
{
    PDVMEDIAPACKET pEntry;
    HRESULT hr;
    
    DV_AUTO_LOCK(&m_CS);

    //
    // if there are any pending buffers, release them
    //

   
    if (!IsListEmpty(&m_PendingList)) {

        DV_FreeList(&m_PendingList, DVLAT_RAW);
        DV_FreeList(&m_AvailableList, DVLAT_RAW);

    }

    if (m_pMediaPacketBuffer) {

        DV_POOL_FREE(m_pMediaPacketBuffer);
        m_pMediaPacketBuffer = NULL;

    }

    InitializeListHead(&m_PendingList);

    if (IsListEmpty(&m_AvailableList)) {

        hr = DV_InitializeList(&m_AvailableList,
                               ST_MAX_FREE_BUFFER_CONTEXTS,
                               sizeof(XMEDIAPACKET),
                               DVLAT_RAW);
        if (FAILED(hr)) {            
            return hr;
        }

        m_pMediaPacketBuffer = m_AvailableList.Flink;

    }
    
    return NOERROR;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::MixInSingle"

HRESULT CSoundTarget::MixInSingle( LPBYTE lpbBuffer )
{
	HRESULT hr;
    PXMEDIAPACKET pXmp;

    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();

    //
    // check if we have any pending XMO output buffers
    //

    if (IsListEmpty(&m_PendingList)) {

        //
        // no buffers available, we have to discard the data..
        //

        DPVF(DPVF_WARNINGLEVEL,"No pending buffers, throwing away data!");
        return S_OK; 
    }

    //
    // take a context out, and complete it
    //

    pXmp = (PXMEDIAPACKET) DV_REMOVE_TAIL(&m_PendingList);
    memcpy((PUCHAR)pXmp->pvBuffer,
           lpbBuffer,
           m_dwFrameSize);


    DPVF(DPVF_SPAMLEVEL,"Mixing single frame, context %x",pXmp);

    if (pXmp->pdwCompletedSize) {

        *pXmp->pdwCompletedSize = m_dwFrameSize;

    }
    
    if (pXmp->pdwStatus) {

        *pXmp->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

    }

    if (pXmp->hCompletionEvent) {

        SetEvent(pXmp->hCompletionEvent);

    }

    DV_INSERT_TAIL(&m_AvailableList,pXmp);
    return DV_OK;

}

HRESULT STDMETHODCALLTYPE CSoundTarget::GetStatus( 
    /* [out] */ DWORD __RPC_FAR *dwFlags)
{
    DV_AUTO_LOCK(&m_CS);
    *dwFlags = 0;

    if (!IsListEmpty(&m_AvailableList)) {

        *dwFlags = XMO_STATUSF_ACCEPT_OUTPUT_DATA;

    }

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::Process"

HRESULT CSoundTarget::Process( 
    LPCXMEDIAPACKET pSrc,
    LPCXMEDIAPACKET pDst
    )
{
    PXMEDIAPACKET pXmp;
    DV_AUTO_LOCK(&m_CS);
    DPVF_ENTER();

    //
    // they are only supposed to call us async..
    //

    ASSERT (pDst->dwMaxSize >= m_dwFrameSize);
    ASSERT (pSrc==NULL);

    //
    // add this buffer to our media buffer list
    // next time the DVClientEngine has data 
    // a queued buffer will get the data and get released...
    //

    ASSERT(!IsListEmpty(&m_AvailableList));

    pXmp = (PXMEDIAPACKET) DV_REMOVE_TAIL(&m_AvailableList);

    DPVF(DPVF_SPAMLEVEL,"adding context %x to pending list!",pXmp);

    //
    // pending pool is a FIFO. Queue at head, dequeue at tail
    //

    memcpy(pXmp,pDst,sizeof(XMEDIAPACKET));
    *pXmp->pdwStatus = XMEDIAPACKET_STATUS_PENDING;  

    DV_INSERT_HEAD(&m_PendingList,pXmp);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvshared.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvshared.h
 *  Content:	Utility functions for DirectXVoice structures.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created It
 * 09/01/2000   georgioc started rewrite/port to xbox
 ***************************************************************************/

#ifndef __DVSHARED_H
#define __DVSHARED_H

#include "dvntos.h"
#include <dvoicep.h>
#include <string.h>
#include "in_core.h"
#include "dvengine.h"


//
// added when talking to compressors since they tend to overrun memory
//

#define COMPRESSION_SLUSH			2
#define DV_CT_FRAMES_PER_PERIOD     32
#define DV_CT_INNER_QUEUE_SIZE		64
#define DV_CT_MAXHIGHWATERMARK	    32

#define DV_FRAMEF_IS_SILENCE        0x00000001
#define DV_FRAMEF_IS_LOST           0x00000002


#define DVLAT_RAW      0x00000001
#define DVLAT_CVOICEPLAYER  0x00000002

struct DIRECTVOICEOBJECT;

volatile struct DIRECTVOICENOTIFYOBJECT
{
	LPVOID						lpNotifyVtble;
	DIRECTVOICEOBJECT			*lpDV;
	LONG						lRefCnt;
};

volatile struct DIRECTVOICEOBJECT
{
	LONG						lIntRefCnt;
	CDirectVoiceEngine			*lpDVEngine;
	CDirectVoiceTransport		*lpDVTransport;
	DIRECTVOICENOTIFYOBJECT		dvNotify;
};

typedef DIRECTVOICEOBJECT *LPDIRECTVOICEOBJECT;
typedef DIRECTVOICENOTIFYOBJECT *LPDIRECTVOICENOTIFYOBJECT;

//
// used to track XMO packets
//

typedef struct _DVMEDIAPACKET  
{

    XMEDIAPACKET xmp;
    DWORD dwCompletedSize;
    DWORD dwStatus;
    PVOID pvReserved;

} DVMEDIAPACKET, *PDVMEDIAPACKET;


typedef struct _DVPOOLALLOC  
{

    LIST_ENTRY ListEntry;
    UCHAR Data[4];

} DVPOOLALLOC, *PDVPOOLALLOC;

VOID DV_INSERT_TAIL(PLIST_ENTRY pListHead, PVOID data);
VOID DV_REMOVE_ENTRY(PVOID pData);
PVOID DV_GET_LIST_HEAD(PLIST_ENTRY pListHead);
PVOID DV_GET_NEXT(PLIST_ENTRY pListHead, PVOID pData);
PVOID DV_REMOVE_TAIL(PLIST_ENTRY pListHead);
VOID DV_INSERT_HEAD(PLIST_ENTRY pListHead, PVOID data);

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// function declarations
/////////////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT DV_InitializeList(PLIST_ENTRY pListHead, DWORD dwNumElements,DWORD dwSize, DWORD dwType);
VOID DV_FreeList(PLIST_ENTRY pListHead, DWORD dwType);


HRESULT
DV_InitMediaPacketPool(
    LIST_ENTRY *pPool,
    DWORD dwBufferSize,
    DWORD   bAlloc
    );

VOID
DV_FreeMediaPacketPool(
    LIST_ENTRY *pPool,
    DWORD   bFree
    );



STDAPI DV_Initialize( LPDIRECTVOICEOBJECT lpdvObject, PVOID lpTransport, LPDVMESSAGEHANDLER lpMessageHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements );

HRESULT DV_CreateConverter(
    GUID guidCT,
    XMediaObject **pConverter,
    WAVEFORMATEX *pwfxUnencodedFormat,
    WAVEFORMATEX **ppwfxEncodedFormat,
    DWORD dwUncompressedSize,
    BOOLEAN bCreateEncoder
    );

HRESULT DV_CopySessionDescToBuffer( LPVOID lpTarget, LPDVSESSIONDESC lpdvSessionDesc, LPDWORD lpdwSize );

BOOL DV_ValidBufferAggresiveness( DWORD dwValue );
BOOL DV_ValidBufferQuality( DWORD dwValue );
BOOL DV_ValidSensitivity( DWORD dwValue );

HRESULT DV_ValidClientConfig( LPDVCLIENTCONFIG lpClientConfig );
HRESULT DV_ValidSessionDesc( LPDVSESSIONDESC lpSessionDesc );
HRESULT DV_ValidTargetList( PDVID pdvidTargets, DWORD dwNumTargets );

BOOL DV_ValidDirectVoiceObject( LPDIRECTVOICEOBJECT lpdv );
BOOL DV_ValidDirectXVoiceClientObject( LPDIRECTVOICEOBJECT lpdvc );
BOOL DV_ValidDirectXVoiceServerObject( LPDIRECTVOICEOBJECT lpdvs );
HRESULT DV_ValidMessageArray( LPDWORD lpdwMessages, DWORD dwNumMessages, BOOL fServer );

void DV_DUMP_SessionDesc( LPDVSESSIONDESC lpdvSessionDesc );
void DV_DUMP_ClientConfig( LPDVCLIENTCONFIG lpdvClientConfig );
void DV_DUMP_WaveFormatEx( LPWAVEFORMATEX lpwfxFormat );
void DV_DUMP_GUID( GUID guid );

#ifdef _DEBUG
#define DV_DUMP_SD( sd )		DV_DUMP_SessionDesc( sd )
#define DV_DUMP_CC( cc )		DV_DUMP_ClientConfig( cc )
#define DV_DUMP_CIF( cif, ne )	DV_DUMP_FullCompressionInfo( cif, ne )
#else 
#define DV_DUMP_CIF( cif, ne )
#define DV_DUMP_CI( ci, ne )
#define DV_DUMP_SD( sd )
#define DV_DUMP_SDC( sdc )
#define DV_DUMP_CC( cc )
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvshared.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvshared.cpp
 *  Content:	Utility functions for DirectXVoice structures.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/06/99	rodtoll	Created It
 *  09/01/2000  georgioc started port/re-write for xbox
 ***************************************************************************/
#pragma warning( disable : 4786 )  

#include "dvntos.h"
#include "dvshared.h"

#include "dvserver.h"
#include "dvclient.h"

#include "dvdxtran.h"

// Useful macros for checking record/suppression volumes
#define DV_ValidRecordVolume( x ) DV_ValidPlaybackVolume( x )
#define DV_ValidSuppressionVolume( x ) DV_ValidPlaybackVolume( x )

#if DBG

__inline VOID
DPVF
(
    DWORD                   dwLevel,
    LPCSTR                  pszFormat,
    ...
)
{
    CHAR                    szString[0x400];
    va_list                 va;

    if(g_DVDebugLevel & dwLevel)
    {
        va_start(va, pszFormat);
        vsprintf(szString, pszFormat, va);
        va_end(va);

        DebugPrint("%s:(%x): %s\n",g_ModName,g_This, szString);
                
    }
}

#endif

//
// LINKED list and pool functions
//


PVOID DV_REMOVE_TAIL(PLIST_ENTRY pListHead)
{
    KIRQL irql;
    PDVPOOLALLOC pEntry;

    ASSERT(pListHead->Flink);
    ASSERT(pListHead->Blink);

    RIRQL(irql);

    if (IsListEmpty(pListHead)) {

        LIRQL(irql);
        DPVF( DPVF_ERRORLEVEL, "Attempted Empty List dequeue on list %x!",pListHead );
        return NULL;

    }

    pEntry = (PDVPOOLALLOC)RemoveTailList(pListHead);
    LIRQL(irql);

    ASSERT(pEntry);
    ASSERT(pListHead->Flink);
    ASSERT(pListHead->Blink);

    return  &pEntry->Data;
}
    
PVOID DV_REMOVE_HEAD(PLIST_ENTRY pListHead)
{
    PDVPOOLALLOC pEntry;
    KIRQL irql;

    RIRQL(irql);

    if (IsListEmpty(pListHead)) {

        LIRQL(irql);
        DPVF( DPVF_ERRORLEVEL, "Attempted Empty List dequeue on list %x!",pListHead );        
        return NULL;

    }

    pEntry = (PDVPOOLALLOC) RemoveHeadList(pListHead);
    LIRQL(irql);

    ASSERT(pListHead->Flink);
    ASSERT(pListHead->Blink);

    return  &pEntry->Data;
}


PVOID DV_GET_NEXT(PLIST_ENTRY pListHead, PVOID pData)
{
    PDVPOOLALLOC pEntry;
    KIRQL irql;

    RIRQL(irql);

    pEntry = (PDVPOOLALLOC) ((PUCHAR)pData - FIELD_OFFSET(DVPOOLALLOC,Data));
    pEntry = (PDVPOOLALLOC) pEntry->ListEntry.Flink;

    if ((PLIST_ENTRY)pEntry == pListHead) {
        LIRQL(irql);
        return NULL;
    }

    LIRQL(irql);

    return &pEntry->Data;
}

PVOID DV_GET_LIST_HEAD(PLIST_ENTRY pListHead)
{
    PDVPOOLALLOC pEntry;
    KIRQL irql;

    RIRQL(irql);
    pEntry = (PDVPOOLALLOC)pListHead->Flink;
    LIRQL(irql);

    ASSERT(pListHead->Flink);
    ASSERT(pListHead->Blink);

    return &pEntry->Data;
}


VOID DV_REMOVE_ENTRY(PVOID pData)
{
    PLIST_ENTRY pEntry;
    KIRQL irql;

    RIRQL(irql);
    pEntry = (PLIST_ENTRY) ((PUCHAR)pData - FIELD_OFFSET(DVPOOLALLOC,Data));
    RemoveEntryList(pEntry);
    LIRQL(irql);
}


VOID DV_INSERT_TAIL(PLIST_ENTRY pListHead, PVOID data)
{

    PLIST_ENTRY pEntry;
    KIRQL irql;

    RIRQL(irql);
    pEntry = (PLIST_ENTRY) ((PUCHAR)data - FIELD_OFFSET(DVPOOLALLOC,Data));
    InsertTailList(pListHead,pEntry);
    LIRQL(irql);

    ASSERT(pListHead->Flink);
    ASSERT(pListHead->Blink);

}
 
VOID DV_INSERT_HEAD(PLIST_ENTRY pListHead, PVOID data)
{

    PLIST_ENTRY pEntry;
    KIRQL irql;

    RIRQL(irql);
    pEntry = (PLIST_ENTRY) ((PUCHAR)data - FIELD_OFFSET(DVPOOLALLOC,Data));
    InsertHeadList(pListHead,pEntry);
    LIRQL(irql);

    ASSERT(pListHead->Flink);
    ASSERT(pListHead->Blink);

}



HRESULT DV_InitializeList(PLIST_ENTRY pListHead, DWORD dwNumElements,DWORD dwSize, DWORD dwType)
{
    ULONG i;
    
    PUCHAR buffer;
    PDVPOOLALLOC pAlloc;


    InitializeListHead(pListHead);

    if (dwType != DVLAT_CVOICEPLAYER) {

        ASSERT(dwSize >= sizeof(DVPOOLALLOC));

        buffer = (PUCHAR)DV_POOL_ALLOC((dwSize+sizeof(DVPOOLALLOC))*dwNumElements);

        ASSERT(buffer);

        if (!buffer) {
            return E_OUTOFMEMORY;
        }
    

    }

    for (i=0;i<dwNumElements;i++) {

        switch (dwType) {
        case DVLAT_RAW:

            pAlloc = (PDVPOOLALLOC) ((PUCHAR)buffer + i*(dwSize+sizeof(DVPOOLALLOC)));
            InsertTailList(pListHead,&pAlloc->ListEntry);

            break;

        case DVLAT_CVOICEPLAYER:

            CVoicePlayer *pPlayer = new CVoicePlayer();
            ASSERT(pPlayer);
            InsertTailList(pListHead,&pPlayer->m_PoolEntry);
            break;

        }
        
    }

    return NOERROR;

}


VOID DV_FreeList(PLIST_ENTRY pListHead, DWORD dwType)
{

    PDVPOOLALLOC pAlloc,pNextAlloc;
    KIRQL irql;

    RIRQL(irql);

    if (IsListEmpty(pListHead)) {

        LIRQL(irql);
        return;

    }

    pAlloc = (PDVPOOLALLOC) pListHead->Flink;

    switch (dwType) {
    case DVLAT_RAW:

        //
        // raw allocations use a single buffer pointed to by the head.
        // the caller is supposed to keep track of it and free it
        //

        InitializeListHead(pListHead);

        break;

    case DVLAT_CVOICEPLAYER:

        while ((PLIST_ENTRY)pAlloc != pListHead) {
    
            CVoicePlayer *pPlayer = CONTAINING_RECORD(pAlloc, CVoicePlayer,m_PoolEntry);
            pNextAlloc = (PDVPOOLALLOC) pAlloc->ListEntry.Flink;
            delete pPlayer;
            pAlloc = pNextAlloc;
    
        }

        break;

    }

    LIRQL(irql);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



#undef DPF_MODNAME
#define DPF_MODNAME "DV_Initialize"
//
// DV_Initialize
//
// Responsible for initializing the specified directvoice object with the specified parameters.
//
STDAPI DV_Initialize( LPDIRECTVOICEOBJECT lpdvObject, PVOID lpTransport, LPDVMESSAGEHANDLER lpMessageHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{
	HRESULT hr = S_OK;

	LPDIRECTPLAYVOICETRANSPORT lpdvDplayTransport=NULL;
	CDirectVoiceDirectXTransport *lpdxTransport;

	if( lpTransport == NULL )
	{
		DPVF( DPVF_ERRORLEVEL, "Bad pointer" );
		return DVERR_NOTRANSPORT;
	}

	// Fix a memory leak if you Connect/Disconnect and then reconnect.  
	if( lpdvObject->lpDVTransport )
	{
		delete lpdvObject->lpDVTransport;
		lpdvObject->lpDVTransport = NULL;
	}

	// Try and retrieve transport interface from the object we got.
	lpdvDplayTransport = (LPDIRECTPLAYVOICETRANSPORT) lpTransport;

	lpdxTransport = new CDirectVoiceDirectXTransport(lpdvDplayTransport);

	if( lpdxTransport == NULL )
	{
		DPVF( DPVF_ERRORLEVEL, "Unable to allocate transport" );
		lpdvDplayTransport->Release();
		return DVERR_OUTOFMEMORY;
	}

	hr = lpdvObject->lpDVEngine->Initialize( static_cast<CDirectVoiceTransport *>(lpdxTransport), lpMessageHandler, lpUserContext, lpdwMessages, dwNumElements  );

	if( FAILED( hr ) )
	{
		delete lpdxTransport;

		return hr;
	}

	lpdvObject->lpDVTransport = static_cast<CDirectVoiceTransport *>(lpdxTransport);

	return S_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DV_CreateConverter"
HRESULT DV_CreateConverter(
    GUID guidCT,
    XMediaObject **ppConverter,
    WAVEFORMATEX *pwfxUnencodedFormat,
    WAVEFORMATEX **ppwfxEncodedFormat,
    DWORD dwUncompressedPacketSize,
    BOOLEAN bCreateEncoder
    )
{

    WORD tag;
    HRESULT hr = NOERROR;

    //
    // get format tag from GUID
    //

    if (guidCT == DSCTID_SC03) {    

        //
        // vox sc03
        //

        tag = WAVE_FORMAT_VOXWARE_SC03;

    } else if (guidCT == DSCTID_SC06){

        //
        // vox sc06
        //

        tag = WAVE_FORMAT_VOXWARE_SC06;

    }  else if (guidCT == DSCTID_VR12){

        //
        // vox vr12
        //

        tag = WAVE_FORMAT_VOXWARE_VR12;

    } else {

        //
        // no compression, return NULL
        //                

        *ppConverter = NULL;

        //
        // not a supported format!
        //

        DPVF( DPVF_ERRORLEVEL, "Request to create compressor for unssuported compressor!!");
        ASSERT(FALSE);
        return DVERR_NOTSUPPORTED;

    }

    PVOICECODECWAVEFORMAT pwfxVox;

    if (ppwfxEncodedFormat) {

        pwfxVox = new VOICECODECWAVEFORMAT; 
        *ppwfxEncodedFormat = (PWAVEFORMATEX) pwfxVox;

    } else {

        pwfxVox = NULL;

    }

    //
    // instantiate the proper vox compressor
    //


    hr = VoxwareCreateConverter(tag,
                                bCreateEncoder,
                                ((pwfxVox == NULL) ? NULL : pwfxVox),
                                pwfxUnencodedFormat,
                                ppConverter);

    return hr;

}




HRESULT
DV_InitMediaPacketPool(
    PLIST_ENTRY pPool,
    DWORD dwBufferSize,
    DWORD   bAlloc
    )
{
    PDVMEDIAPACKET pPacket;

    pPacket = (PDVMEDIAPACKET) DV_GET_LIST_HEAD(pPool);

    while (pPacket) {
    
        if (bAlloc) {
    
            pPacket->xmp.pvBuffer = (PBYTE) DV_POOL_ALLOC(dwBufferSize);
            ASSERT(pPacket->xmp.pvBuffer);
            if (!pPacket->xmp.pvBuffer) {

                return DVERR_OUTOFMEMORY;

            }
            
        }

        pPacket->dwCompletedSize = 0;
        pPacket->dwStatus = XMEDIAPACKET_STATUS_PENDING;
        pPacket->xmp.pdwCompletedSize = &pPacket->dwCompletedSize;
        pPacket->xmp.pdwStatus = &pPacket->dwStatus;
        pPacket->xmp.dwMaxSize = dwBufferSize;
        pPacket->xmp.pContext = pPacket;
        pPacket->xmp.prtTimestamp = NULL;

        pPacket = (PDVMEDIAPACKET) DV_GET_NEXT(pPool,pPacket);

    }

    return DV_OK;

}


VOID
DV_FreeMediaPacketPool(
    LIST_ENTRY *pPool,
    DWORD   bFree
    )
{
    PDVMEDIAPACKET pPacket;
    KIRQL irql;

    RIRQL(irql);

    if (IsListEmpty(pPool)) {
        LIRQL(irql);
        return;
    }

    pPacket = (PDVMEDIAPACKET) DV_GET_LIST_HEAD(pPool);

    while (pPacket) {
    
        if (bFree) {
    
            DV_POOL_FREE(pPacket->xmp.pvBuffer);
            
        }

        pPacket->dwCompletedSize = 0;
        pPacket->dwStatus = XMEDIAPACKET_STATUS_FLUSHED;

        pPacket = (PDVMEDIAPACKET) DV_GET_NEXT(pPool, pPacket);

    }

    LIRQL(irql);

}





/******************************************************************************
/ VALIDATION ROUTINES
/*****************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidTargetList"
HRESULT DV_ValidTargetList( PDVID pdvidTargets, DWORD dwNumTargets )
{
	if( (pdvidTargets != NULL && dwNumTargets == 0) ||
	    (pdvidTargets == NULL && dwNumTargets > 0 ) )
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid params" );
		return DVERR_INVALIDPARAM;
	}

	if( dwNumTargets == 0 )
		return DV_OK;
	
	if( pdvidTargets == NULL)
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid array of player targets" );
		return DVERR_INVALIDPOINTER;
	}

	// Search for duplicates in the targets
	for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
	{
		if( pdvidTargets[dwIndex] == DVID_ALLPLAYERS && dwNumTargets > 1 )
		{
			DPVF( DPVF_ERRORLEVEL, "Cannot specify allplayers (or noplayers) in addition to other ids" );
			return DVERR_INVALIDPARAM;
		}

		for( DWORD dwInnerIndex = dwIndex+1; dwInnerIndex < dwNumTargets; dwInnerIndex++ )
		{
			if( pdvidTargets[dwInnerIndex] == pdvidTargets[dwIndex] )
			{
				DPVF( DPVF_ERRORLEVEL, "Duplicate found in target list" );
				return DVERR_INVALIDPARAM;
			}
		}
	}

	return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidClientConfig"
// DV_ValidClientConfig
//
// Checks the valid client configuration structure to ensure it's valid
//
HRESULT DV_ValidClientConfig( LPDVCLIENTCONFIG lpClientConfig )
{
	if( lpClientConfig == NULL)
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}

	if( lpClientConfig->dwSize != sizeof( DVCLIENTCONFIG ) )
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid size" );
		return DVERR_INVALIDPARAM;
	}

	if( lpClientConfig->dwFlags & 
	    ~(DVCLIENTCONFIG_RECORDMUTE | DVCLIENTCONFIG_PLAYBACKMUTE | 
	      DVCLIENTCONFIG_AUTOVOICEACTIVATED | DVCLIENTCONFIG_MUTEGLOBAL |
          DVCLIENTCONFIG_MANUALVOICEACTIVATED) 
	  )
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	if( lpClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED && 
	   lpClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED )
	{
		DPVF( DPVF_ERRORLEVEL, "Cannot specify manual AND auto voice activated" );
		return DVERR_INVALIDFLAGS;
	}

	// If it's NOT manual, this parameter must be 0.
	if( !(lpClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED) )
	{
		if( lpClientConfig->dwThreshold != DVTHRESHOLD_UNUSED )
		{
			DPVF( DPVF_ERRORLEVEL, "Invalid sensitivity w/auto" );
			return DVERR_INVALIDPARAM;
		}

	}
	else
	{
		if( !DV_ValidSensitivity( lpClientConfig->dwThreshold ) )
		{
			DPVF( DPVF_ERRORLEVEL, "Invalid sensitivity" );
			return DVERR_INVALIDPARAM;
		}
	}

    if (!lpClientConfig->dwFlags) {

        DPVF( DPVF_ERRORLEVEL, "You must specify at least one flag!" );
	    return DVERR_INVALIDPARAM;
    }

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidSessionDesc"
// DV_ValidSessionDesc
//
// Checks the specified session description to ensure it's valid.
//
HRESULT DV_ValidSessionDesc( LPDVSESSIONDESC lpSessionDesc )
{
	if( lpSessionDesc == NULL)
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );				
		return E_POINTER;
	}


	if( lpSessionDesc->dwSessionType != DVSESSIONTYPE_PEER &&
	    lpSessionDesc->dwSessionType != DVSESSIONTYPE_FORWARDING)
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid session type" );	
		return DVERR_INVALIDPARAM;
	}

	if( lpSessionDesc->dwFlags & ~(DVSESSION_SERVERCONTROLTARGET | DVSESSION_NOHOSTMIGRATION) )
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	return DV_OK;

}

// DV_ValidSensitivity
//
// Checks the sensitivity to ensure it's valid
//
BOOL DV_ValidSensitivity( DWORD dwValue )
{
	if( dwValue != DVTHRESHOLD_DEFAULT &&
	    (// Commented out because min is currently 0 (dwValue < DVTHRESHOLD_MIN) || 
	     (dwValue > DVTHRESHOLD_MAX) ) )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_CopySessionDescToBuffer"
//
// DV_CopySessionDescToBuffer
//
// Checks the parameters for validity and then copies the specified session description
// to the specified buffer.  (If it will fit).
//
HRESULT DV_CopySessionDescToBuffer( LPVOID lpTarget, LPDVSESSIONDESC lpdvSessionDesc, LPDWORD lpdwSize )
{ 
	LPDVSESSIONDESC lpSessionDesc = (LPDVSESSIONDESC) lpTarget;

	if( lpdwSize == NULL)
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}

	if( (*lpdwSize) < sizeof( DVSESSIONDESC ) )
	{
		*lpdwSize = sizeof( DVSESSIONDESC );	

		DPVF(  DPVF_INFOLEVEL, "Error size" );
		return DVERR_BUFFERTOOSMALL;
	}

	*lpdwSize = sizeof( DVSESSIONDESC );	

	if( lpTarget == NULL)
	{
		DPVF( DPVF_ERRORLEVEL, "Target buffer pointer bad" );
		return E_POINTER;
	}

	memcpy( lpTarget, lpdvSessionDesc, sizeof( DVSESSIONDESC ) ); 

	DPVF(  DPVF_ENTRYLEVEL, "DVCE::GetSessionDesc() Success" );

	return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_GUID"
void DV_DUMP_GUID( GUID guid )
{
    DPVF( DPVF_INFOLEVEL, "{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guid.Data1, guid.Data2, guid.Data3, 
               guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
               guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_SessionDesc"
void DV_DUMP_SessionDesc( LPDVSESSIONDESC lpdvSessionDesc )
{
	ASSERT( lpdvSessionDesc != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPVF( DPVF_STRUCTUREDUMP, "DVSESSIONDESC Dump Addr=0x%p", lpdvSessionDesc );
	DPVF( DPVF_STRUCTUREDUMP, "dwSize = %d", lpdvSessionDesc->dwSize );
	DPVF( DPVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvSessionDesc->dwFlags );
	DPVF( DPVF_STRUCTUREDUMP, "          %s", (lpdvSessionDesc->dwFlags & DVSESSION_SERVERCONTROLTARGET) ? "DVSESSION_SERVERCONTROLTARGET," : "");

	switch( lpdvSessionDesc->dwSessionType )
	{
	case DVSESSIONTYPE_PEER:
		DPVF( DPVF_STRUCTUREDUMP, "dwSessionType = DVSESSIONTYPE_PEER" );
		break;
	case DVSESSIONTYPE_FORWARDING: 
		DPVF( DPVF_STRUCTUREDUMP, "dwSessionType = DVSESSIONTYPE_FORWARDING" );
		break;
	default:
		DPVF( DPVF_STRUCTUREDUMP, "dwSessionType = Unknown" );
		break;
	}

	DPVF( DPVF_STRUCTUREDUMP, "guidCT = " );
	DV_DUMP_GUID( lpdvSessionDesc->guidCT );

}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_DSBDESC"
void DV_DUMP_DSBDESC( LPDSBUFFERDESC lpdsBufferDesc )
{
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPVF( DPVF_STRUCTUREDUMP, "DSBUFFERDESC DUMP Addr=0x%p", lpdsBufferDesc );

	DPVF( DPVF_STRUCTUREDUMP, "dwSize = %d", lpdsBufferDesc->dwSize );
	DPVF( DPVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdsBufferDesc->dwFlags );
	DPVF( DPVF_STRUCTUREDUMP, "dwBufferBytes = %d", lpdsBufferDesc->dwBufferBytes );

	if( lpdsBufferDesc->lpwfxFormat == NULL )
	{
		DPVF( DPVF_STRUCTUREDUMP, "lpwfxFormat = NULL" );
	}
	else
	{
		DPVF( DPVF_STRUCTUREDUMP, "lpwfxFormat = " );	
		DV_DUMP_WaveFormatEx(lpdsBufferDesc->lpwfxFormat);
	}
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_ClientConfig"
void DV_DUMP_ClientConfig( LPDVCLIENTCONFIG lpdvClientConfig )
{
	ASSERT( lpdvClientConfig != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPVF( DPVF_STRUCTUREDUMP, "DVCLIENTCONFIG Dump Addr = 0x%p", lpdvClientConfig );
	DPVF( DPVF_STRUCTUREDUMP, "dwSize = %d", lpdvClientConfig->dwSize );
	DPVF( DPVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvClientConfig->dwFlags );
	DPVF( DPVF_STRUCTUREDUMP, "          %s%s%s%s%s%s", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE) ? "DVCLIENTCONFIG_RECORDMUTE," : "", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_PLAYBACKMUTE) ? "DVCLIENTCONFIG_PLAYBACKMUTE," : "",
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED) ? "DVCLIENTCONFIG_MANUALVOICEACTIVATED," : "", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED) ? "DVCLIENTCONFIG_AUTOVOICEACTIVATED," : "",
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_MUTEGLOBAL) ? "DVCLIENTCONFIG_MUTEGLOBAL," : "");


}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_WaveFormatEx"
void DV_DUMP_WaveFormatEx( LPWAVEFORMATEX lpwfxFormat )
{
	ASSERT( lpwfxFormat != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPVF( DPVF_STRUCTUREDUMP, "WAVEFORMATEX Dump Addr = 0x%p", lpwfxFormat );
	DPVF( DPVF_STRUCTUREDUMP, "wFormatTag = %d", lpwfxFormat->wFormatTag );
	DPVF( DPVF_STRUCTUREDUMP, "nSamplesPerSec = %d", lpwfxFormat->nSamplesPerSec );
	DPVF( DPVF_STRUCTUREDUMP, "nChannels = %d", lpwfxFormat->nChannels );
	DPVF( DPVF_STRUCTUREDUMP, "wBitsPerSample = %d", lpwfxFormat->wBitsPerSample );
	DPVF( DPVF_STRUCTUREDUMP, "nAvgBytesPerSec = %d", lpwfxFormat->nAvgBytesPerSec );
	DPVF( DPVF_STRUCTUREDUMP, "nBlockAlign = %d", lpwfxFormat->nBlockAlign );
	DPVF( DPVF_STRUCTUREDUMP, "cbSize = %d", lpwfxFormat->cbSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidMessageArray"
// Validate message mask.
//
// May be too strict to enforce server only or client/only.
//
HRESULT DV_ValidMessageArray( LPDWORD lpdwMessages, DWORD dwNumMessages, BOOL fServer )
{
	if( dwNumMessages > 0 &&
	    (lpdwMessages == NULL))
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid pointer passed for the lpdwMessages parameter." );
		return DVERR_INVALIDPOINTER;
	}

	if( lpdwMessages != NULL && dwNumMessages == 0 )
	{
		DPVF( DPVF_ERRORLEVEL, "Non-NULL notification array with 0 size" );
		return DVERR_INVALIDPARAM;
	}

	DWORD dwIndex, dwSubIndex;

	for( dwIndex = 0; dwIndex < dwNumMessages; dwIndex++ )
	{
		if( lpdwMessages[dwIndex] < DVMSGID_MINBASE || lpdwMessages[dwIndex] > DVMSGID_MAXBASE )
		{
			DPVF( DPVF_ERRORLEVEL, "Invalid message specified in notification array" );
			return DVERR_INVALIDPARAM;
		}
			
		switch( lpdwMessages[dwIndex] )
		{
		// Player only messages
		case DVMSGID_PLAYERVOICESTART:
		case DVMSGID_PLAYERVOICESTOP:
		case DVMSGID_RECORDSTART:
		case DVMSGID_RECORDSTOP:
		case DVMSGID_CONNECTRESULT:
		case DVMSGID_DISCONNECTRESULT:
		case DVMSGID_INPUTLEVEL:
		case DVMSGID_SETTARGETS:
		case DVMSGID_PLAYEROUTPUTLEVEL:
		case DVMSGID_HOSTMIGRATED:
			if( fServer )
			{
				DPVF( 0, "Client-only notification ID specified in server notification mask" );
				return DVERR_INVALIDPARAM;
			}
			break;
		}

		for( dwSubIndex = 0; dwSubIndex < dwNumMessages; dwSubIndex++ )
		{	
			if( dwIndex != dwSubIndex && 
			    lpdwMessages[dwIndex] == lpdwMessages[dwSubIndex] ) 
			{
				DPVF( 0, "Duplicate IDs specified in notification mask" );
				return DVERR_INVALIDPARAM;
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvserver.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvserver.cpp
 *  Content:	Implements functions for the IDirectXVoiceServer interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/02/99	rodtoll	Created It
 *  07/26/99	rodtoll	Updated QueryInterface to support IDirectXVoiceNotify
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added parameter to the GetCompressionTypes func
 *  09/10/99	rodtoll	Object validity checking 
 *  09/14/99	rodtoll	Added DVS_SetNotifyMask  
 *  10/05/99	rodtoll	Reversed destruction order to destroy object before
 *						transport.  Fixes crash on host migration shutdown.  
 *  10/18/99	rodtoll	Fix: Passing NULL in QueryInterface casues crash 
 *				rodtoll	Fix: Calling Initialize twice passes 
 *  10/19/99	rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if stopsession should be called from release
 *  10/25/99	rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 *  01/14/2000	rodtoll	Updated with new parameters for Set/GetTransmitTarget
 *				rodtoll	Removed DVFLAGS_SYNC from StopSession call
 *
 ***************************************************************************/


#include "dvserver.h"


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_Initialize"
HRESULT WINAPI IDirectPlayVoiceServer_Initialize(LPDIRECTPLAYVOICESERVER lpDV, PVOID lpTransport, LPDVMESSAGEHANDLER lpMessageHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{

    //
    // call the common routine
    //

    return DV_Initialize((LPDIRECTVOICEOBJECT) lpDV, lpTransport,lpMessageHandler, lpUserContext, lpdwMessages, dwNumElements);

}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_AddRef"
ULONG WINAPI IDirectPlayVoiceServer_AddRef(LPDIRECTPLAYVOICESERVER This )
{
    LPDIRECTVOICESERVEROBJECT lpDV  = (LPDIRECTVOICESERVEROBJECT) This;
	LONG rc;
    KIRQL irql;
	RIRQL(irql); 

	rc = ++lpDV->lIntRefCnt;

    LIRQL(irql); 
	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_Release"
ULONG WINAPI IDirectPlayVoiceServer_Release(LPDIRECTPLAYVOICESERVER  lpDV )
{
    HRESULT hr=S_OK;
    LONG rc;
    KIRQL irql;
    LPDIRECTVOICESERVEROBJECT pDVS = (LPDIRECTVOICESERVEROBJECT) lpDV;

	ASSERT( pDVS );

	RIRQL(irql);
	
	if (pDVS->lIntRefCnt == 0)
	{
		LIRQL(irql);
		return 0;
	}

	// dec the interface count
	pDVS->lIntRefCnt--;

	// Special case: Releasing object without stopping session
	if( (pDVS->lIntRefCnt == 0) && pDVS->lpDVServerEngine->GetCurrentState() != DVSSTATE_IDLE )
	{
		DPVF( DPVF_ERRORLEVEL, "Releasing interface without calling StopSession" );

		pDVS->lIntRefCnt = 0;

		// We must release the lock because stopsession may call back into this function
        LIRQL(irql);

		hr = pDVS->lpDVServerEngine->StopSession( 0 );

        RIRQL(irql);

		if( hr != DV_OK && hr != DVERR_SESSIONLOST  )
		{
			DPVF( DPVF_ERRORLEVEL, "StopSession Failed hr=0x%x", hr );
		}

	}

	rc = pDVS->lIntRefCnt;

	if ( pDVS->lIntRefCnt == 0 )
	{
		// Leave the critical section, we may call back into this func.
		// (Shouldn't though).

		ASSERT( pDVS->lpDVServerEngine );

		delete pDVS->lpDVServerEngine;
		pDVS->lpDVServerEngine = NULL;

		if( pDVS->lpDVTransport != 0 )
		{
			ASSERT( pDVS->lpDVTransport->m_lRefCount == 0 );				
			delete pDVS->lpDVTransport;
			pDVS->lpDVTransport = NULL;
		}

        LIRQL(irql);

		free(pDVS);
	} 
	else
	{
        LIRQL(irql);
	}
   	
    return rc;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_StartSession"
STDMETHODIMP IDirectPlayVoiceServer_StartSession(LPDIRECTPLAYVOICESERVER This, LPDVSESSIONDESC lpdvSessionDesc, DWORD dwFlags )
{
	ASSERT( This != NULL );
	ASSERT( ((LPDIRECTVOICESERVEROBJECT)This)->lpDVEngine != NULL );
	return ((LPDIRECTVOICESERVEROBJECT)This)->lpDVServerEngine->StartSession( lpdvSessionDesc, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_StopSession"
STDMETHODIMP IDirectPlayVoiceServer_StopSession(LPDIRECTPLAYVOICESERVER This, DWORD dwFlags )
{    
	ASSERT( This != NULL );
	ASSERT( ((LPDIRECTVOICESERVEROBJECT)This)->lpDVEngine != NULL );
	return ((LPDIRECTVOICESERVEROBJECT)This)->lpDVServerEngine->StopSession( dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_GetSessionDesc"
STDMETHODIMP IDirectPlayVoiceServer_GetSessionDesc(LPDIRECTPLAYVOICESERVER This, LPDVSESSIONDESC lpdvSessionDesc )
{
	ASSERT( This != NULL );
	ASSERT( ((LPDIRECTVOICESERVEROBJECT)This)->lpDVEngine != NULL );
	return ((LPDIRECTVOICESERVEROBJECT)This)->lpDVServerEngine->GetSessionDesc( lpdvSessionDesc );
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_SetTransmitTargets"
STDMETHODIMP IDirectPlayVoiceServer_SetTransmitTargets( LPDIRECTPLAYVOICESERVER This, DVID dvidSource, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags)
{
    
	ASSERT( This != NULL );
	ASSERT( ((LPDIRECTVOICESERVEROBJECT)This)->lpDVEngine != NULL );
	return ((LPDIRECTVOICESERVEROBJECT)This)->lpDVServerEngine->SetTransmitTarget( dvidSource, pdvidTargets, dwNumTargets, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_GetTransmitTargets"
STDMETHODIMP IDirectPlayVoiceServer_GetTransmitTargets( LPDIRECTPLAYVOICESERVER This, DVID dvidSource, LPDVID pdvidTargets, PDWORD pdwNumElements, DWORD dwFlags)
{    
	ASSERT( This != NULL );
	ASSERT( ((LPDIRECTVOICESERVEROBJECT)This)->lpDVEngine != NULL );
	return ((LPDIRECTVOICESERVEROBJECT)This)->lpDVServerEngine->GetTransmitTarget( dvidSource, pdvidTargets, pdwNumElements, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirectPlayVoiceServer_SetNotifyMask"
STDMETHODIMP IDirectPlayVoiceServer_SetNotifyMask( LPDIRECTPLAYVOICESERVER This, LPDWORD lpdwMessages, DWORD dwNumElements )
{
    
	ASSERT( This != NULL );
	ASSERT( ((LPDIRECTVOICESERVEROBJECT)This)->lpDVEngine != NULL );
	return ((LPDIRECTVOICESERVEROBJECT)This)->lpDVServerEngine->SetNotifyMask( lpdwMessages, dwNumElements );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvsereng.h ===
/*==========================================================================
 * Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 * File:       dvserverengine.h
 * Content:    Definition of class for DirectXVoice Server
 * History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/06/99	rodtoll	Created It
 * 09/01/2000  georgioc started rewrite/port to xbox 
 ***************************************************************************/
#ifndef __DVSERVERENGINE_H
#define __DVSERVERENGINE_H

#include "dvengine.h"
#include "dvtran.h"
#include "frame.h"
#include "inqueue2.h"
#include "dvprot.h"
#include "vnametbl.h"

struct DIRECTVOICESERVEROBJECT;

#define DVSSTATE_NOTINITIALIZED		0x00000000
#define DVSSTATE_IDLE				0x00000001
#define DVSSTATE_STARTUP			0x00000002
#define DVSSTATE_RUNNING			0x00000003
#define DVSSTATE_SHUTDOWN			0x00000004

// CDirectVoiceClientEngine
//
// This class represents the IDirectXVoiceServer interface.
//
#define VSIG_SERVERENGINE		'EVSV'
#define VSIG_SERVERENGINE_FREE	'EVS_'
//
volatile class CDirectVoiceServerEngine: public CDirectVoiceEngine
{

public:
	CDirectVoiceServerEngine( DIRECTVOICESERVEROBJECT *lpObject );
	~CDirectVoiceServerEngine();

public: // IDirectXVoiceServer Interface

	HRESULT HostMigrateStart(LPDVSESSIONDESC lpSessionDesc, DWORD dwHostOrderIDSeed = 0 );
    virtual HRESULT StartSession(LPDVSESSIONDESC lpSessionDesc, DWORD dwFlags, DWORD dwHostOrderIDSeed = 0 );
    virtual HRESULT StopSession(DWORD dwFlags, BOOL fSilent=FALSE, HRESULT hrResult = DV_OK );
    virtual HRESULT GetSessionDesc(LPDVSESSIONDESC lpSessionDescBuffer );
    virtual HRESULT SetTransmitTarget(DVID dvidSource, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags);
    virtual HRESULT GetTransmitTarget(DVID dvidSource, LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags );
	virtual HRESULT MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer );    
	virtual HRESULT SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );	

public: // CDirectVoiceEngine Members
	HRESULT Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements );
	virtual BOOL ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize );
	HRESULT StartTransportSession();
	HRESULT StopTransportSession();
	HRESULT AddPlayer( DVID dvID );
	HRESULT RemovePlayer( DVID dvID );
	HRESULT CreateGroup( DVID dvID );
	HRESULT DeleteGroup( DVID dvID );
	HRESULT AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer );

	inline DWORD GetCurrentState() { return m_dwCurrentState; };	

protected:

    HRESULT Send_SessionLost( HRESULT hrReason );
    HRESULT Send_HostMigrateLeave( );
    HRESULT Send_HostMigrated();
    HRESULT Send_DisconnectConfirm( DVID dvid, HRESULT hrReason );
#ifdef DVS_ENABLE_PEER_SESSION
    HRESULT Send_DeletePlayer( DVID dvid );
    HRESULT Send_CreatePlayer( DVID dvidTarget, CVoicePlayer *pPlayer );
#endif
    HRESULT Send_ConnectRefuse( DVID dvid, HRESULT hrReason );
    HRESULT Send_ConnectAccept( DVID dvid );

protected:

	BOOL CheckProtocolCompatible( BYTE ucMajor, BYTE ucMinor, DWORD dwBuild );

#ifdef DVS_ENABLE_PEER_SESSION
	HRESULT SendPlayerList( DVID dvidSource, DWORD dwHostOrderID );
#endif

	HRESULT InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );	

	void DoPlayerDisconnect( DVID dvidPlayer, BOOL bInformPlayer );
	void TransmitMessage( DWORD dwMessageType, LPVOID lpdvData, DWORD dwSize );
	void SetCurrentState( DWORD dwState );
	HRESULT CreatePlayerEntry( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwHostOrderID, CVoicePlayer **ppPlayer );

	BOOL HandleDisconnect( DVID dvidSource, PDVPROTOCOLMSG_DISCONNECT lpdvDisconnect, DWORD dwSize );
	BOOL HandleConnectRequest( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREQUEST lpdvConnectRequest, DWORD dwSize );
	BOOL HandleSettingsConfirm( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwSize );
	BOOL HandleSettingsReject( DVID dvidSource, PDVPROTOCOLMSG_GENERIC lpdvGeneric, DWORD dwSize );

#ifdef DVS_ENABLE_MULTICAST_SESSION
	BOOL HandleSpeechWithTarget( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHTARGET lpdvSpeech, DWORD dwSize );
#endif
	BOOL HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize );	

	PDVTRANSPORT_BUFFERDESC GetTransmitBuffer( DWORD dwSize, LPVOID *ppvContext, DWORD PoolIndex );
    HRESULT SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete );
    void ReturnTransmitBuffer( PVOID pvContext );

	HRESULT BuildAndSendTargetUpdate( DVID dvidSource, CVoicePlayer *pPlayerInfo );

	BOOL CheckForMigrate( DWORD dwFlags, BOOL fSilent );
	HRESULT InformClientsOfMigrate();
	void WaitForBufferReturns();

	DWORD					m_dwSignature;			// Signature 

	LPDVMESSAGEHANDLER		m_lpMessageHandler;		// User message handler
	LPVOID					m_lpUserContext;		// User context for message handler
	DVID					m_dvidLocal;			// DVID of the transport player for this host
	DWORD					m_dwCurrentState;		// Current state of the engine
    CDirectVoiceTransport	*m_lpSessionTransport;	// Transport for the session
	DVSESSIONDESC			m_dvSessionDesc;		// Description of session
	DWORD					m_dwTransportFlags;		// Flags for the transport session
	DWORD					m_dwTransportSessionType;
													// Type of transport session (client/server or peer to peer)
protected: // Client Server specific information

	HRESULT SetupBuffers();
	HRESULT FreeBuffers();

	HRESULT StartupMulticast();
	HRESULT ShutdownMulticast();
    void CleanupActiveList();

protected:
    
    CRITICAL_SECTION         m_CS;
	DIRECTVOICESERVEROBJECT *m_lpObject;			// Pointer to the COM object this is running in 

	LPDWORD					m_lpdwMessageElements;	// Array containing the DVMSGID_XXXX values for all the
													// notifications developer wishes to receive.
													// If this is NULL all notifications are active
	DWORD					m_dwNumMessageElements;	// # of elements in the m_lpdwMessageElements array
	DWORD					m_dwNextHostOrderID;
	HRESULT					m_hrStopSessionResult;	// Reason that the session was stopped

	BYTE					m_padding[3];    

	LIST_ENTRY				m_PlayerActiveList;

    CVoiceNameTable         m_voiceNameTable;

    LIST_ENTRY   m_PlayerContextPool;
    LIST_ENTRY   m_MessagePool;
    LIST_ENTRY   m_PlayerListPool;
    LIST_ENTRY   m_SpeechBufferPool;

    LIST_ENTRY   m_BufferDescPool;

    PVOID                     m_pBufferDescAllocation;
    PVOID                     m_pMessagePoolAllocation;
    PVOID                     m_pSpeechBufferAllocation;
    PVOID                     m_pPlayerListPoolAllocation;


    DWORD        m_MsgBufferAllocs;
    DWORD        m_SpeechBufferAllocs;

public:
    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'esvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvtran.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvtransport.h
 *  Content:	Base class for dp/dnet abstraction
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created It
 *
 ***************************************************************************/

#ifndef __DVTRANSPORT_H
#define __DVTRANSPORT_H

class CDirectVoiceEngine;
class CVoicePlayer;
class CDirectVoiceTransport;

struct DIRECTVOICEOBJECT;

#include "dvshared.h"

// CDirectVoiceTransport
//
// Abstracts the transport system so that the sends and group management 
// features of DPlay/DirectNet are indpendent.
class CDirectVoiceTransport 
{
// Voice player table management
public:
	CDirectVoiceTransport(): m_lRefCount(0) {};
	virtual ~CDirectVoiceTransport() {};

	inline void Release() { InterlockedDecrement( &m_lRefCount ); };
	inline void AddRef() { InterlockedIncrement( &m_lRefCount ); };

	virtual HRESULT AddPlayerEntry( DVID dvidPlayer, LPVOID lpData ) = 0;
	virtual HRESULT DeletePlayerEntry( DVID dvidPlayer ) = 0;
	virtual HRESULT GetPlayerEntry( DVID dvidPlayer, CVoicePlayer **lplpPlayer ) = 0;
	virtual HRESULT Initialize() = 0;
	virtual HRESULT MigrateHost( DVID dvidNewHost ) = 0;

	virtual DVID GetLocalID() = 0;
	virtual DVID GetServerID() = 0;

public:
	virtual HRESULT SendToServer( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags ) = 0;
	virtual HRESULT SendToAll( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags ) = 0;
	virtual HRESULT SendToIDS( PDVID pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags ) = 0;

	virtual DWORD GetMaxPlayers( )= 0;

public: // Remote Server Synchronization functions
	virtual HRESULT CreateGroup( LPDVID dvidGroup ) = 0;
	virtual HRESULT DeleteGroup( DVID dvidGroup ) = 0;
	virtual HRESULT AddPlayerToGroup( LPDVID dvidGroup, DVID dvidPlayer ) = 0; 
	virtual HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;

public: // Hooks into the transport

    virtual VOID DoWork() = 0;
	virtual BOOL IsPlayerInGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;
	virtual BOOL ConfirmValidEntity( DVID dvid ) = 0;
	virtual BOOL ConfirmValidGroup( DVID dvid ) = 0;
	virtual HRESULT EnableReceiveHook( DIRECTVOICEOBJECT *dvObject, DWORD dwObjectType ) = 0;
	virtual HRESULT DisableReceiveHook( ) = 0;
	virtual HRESULT WaitForDetachCompletion() = 0;
	virtual void DestroyTransport() = 0;
	virtual BOOL ConfirmLocalHost( ) = 0;
	virtual BOOL ConfirmSessionActive( ) = 0;
	virtual HRESULT GetTransportSettings( LPDWORD lpdwSessionType, LPDWORD lpdwFlags ) = 0;

public:

	LONG	m_lRefCount;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\dvsndt.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvsndt.h
 *  Content:	definition of CSoundTarget class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/02/99		rodtoll	Created
 * 09/01/2000  georgioc started rewrite/port to xbox
 ***************************************************************************/
 
#ifndef __DVSNDT_H
#define __DVSNDT_H

#define NODSOUND

#include "dvntos.h"
#include "in_core.h"
#include <dsoundp.h>
#include <dvoicep.h>

#include "dvshared.h"

// CSoundTarget
//
// This class represents a single mixer target within the DirectPlayClient system.  Normally there
// is only a single mixer target ("main") for all incoming audio.  However, using the CreateUserBuffer and
// DeleteUserBuffer APIs the developer can specify that they wish to seperate a group or a player
// from the main mixer target.  In this manner they can control the 3d spatialization of the group/player's
// incoming audio stream.  
//
// This class handles all the details related to a mixer target.  It encapsulates the mixing of single 
// or multiple source audio frames and then commiting them to the corresponding directsound buffer.  It also
// handles timing errors in the directsoundbuffer.
//
// For example, if the directsoundbuffer stops running, it will attempt to reset the buffer.
//
// If the directsoundbuffer slows down (because of high CPU), it moves the read pointer forward.  In short
// it ensures that there is always 1 or 2 frames of mixed audio present in the buffer in advance of the 
// read pointer.
//
// In addition the class provides reference counting to prevent premature deletion of the class.  If you 
// wish to take a reference to the class, call AddRef and you MUST then call Release when you are done.
//
// Do not destroy the object directly.  When the last reference to the object is released the object will
// destroy itself.
//
// This class is not multithread safe (except for AddRef and Release).  Only one thread should be 
// accessing it.
//

#define ST_MAX_FREE_BUFFER_CONTEXTS 0x10

class CVoicePlayer;

class CSoundTarget : public XMediaObject
{
public:    

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'lcvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

    CSoundTarget()
    {
        m_pMediaPacketBuffer = NULL;
        m_cRef = 0;
        InitializeCriticalSection(&m_CS);

        InitializeListHead(&m_PendingList);
        InitializeListHead(&m_AvailableList);

    }
    ~CSoundTarget()
    {
        DV_AUTO_LOCK(&m_CS);

        if (!IsListEmpty(&m_PendingList)) {
    
            DV_FreeList(&m_PendingList, DVLAT_RAW);

        }

        if (m_pMediaPacketBuffer) {
    
            DV_POOL_FREE(m_pMediaPacketBuffer);
            m_pMediaPacketBuffer = NULL;
    
        }

    }

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
       long l = InterlockedDecrement((long*)&m_cRef);
       if (l == 0)
          delete this;
       return l;
    }

    HRESULT STDMETHODCALLTYPE GetInfo( 
        PXMEDIAINFO pInfo
        )
    {
        pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_WHOLE_SAMPLES |
                    XMO_STREAMF_DISCARDABLE;

        //
        // align values to our block size. In gets CEILed, out gets FLOORed
        //
    
        pInfo->dwOutputSize = m_dwFrameSize;
        
        pInfo->dwMaxLookahead = 0;

        return NOERROR;
    }    
    
    HRESULT STDMETHODCALLTYPE Discontinuity()
    {
        return NOERROR;
    }
        
    HRESULT STDMETHODCALLTYPE Flush();

    HRESULT STDMETHODCALLTYPE GetStatus( 
        /* [out] */ DWORD __RPC_FAR *dwFlags);
    
    HRESULT STDMETHODCALLTYPE Process( 
        LPCXMEDIAPACKET pSrcBuffer,
        LPCXMEDIAPACKET pDstBuffer);    


protected:
   
    friend class CVoicePlayer;
    HRESULT MixInSingle( LPBYTE lpbBuffer );    
    HRESULT Initialize(DWORD dwFrameSize);

    CRITICAL_SECTION        m_CS;
    DWORD                   m_dwFrameSize;
    ULONG m_cRef;

    PVOID                    m_pMediaPacketBuffer;
    LIST_ENTRY               m_PendingList;
    LIST_ENTRY               m_AvailableList;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\in_core.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		in_core.h
 *  Content:	Instrumentation for voice core.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 ***************************************************************************/
#ifndef __IN_CORE_H
#define __IN_CORE_H

#ifdef DBG
#include <stdio.h>
#define NUM_CORE_SECTIONS		 14

// Defines for modules 
#define RRI_DEBUGOUTPUT_LEVEL									0x0001
#define RECORD_SWITCH_DEBUG_LEVEL								0x0002
#define PLAYBACK_SWITCH_DEBUG_LEVEL								0x0004
#define PWI_DEBUGOUTPUT_LEVEL									0x0008
#define DPVF_SEND_DEBUG_LEVEL		                            0x0020

#define DPVF_PLAYERMANAGE_DEBUG_LEVEL							0x0040
#define DPVF_GLITCH_DEBUG_LEVEL									0x0080
#define DPVF_CLIENT_SEQNUM_DEBUG_LEVEL							0x0100
#define DPVF_HOSTMIGRATE_DEBUG_LEVEL                             0x0200
#define DPVF_COMPRESSION_DEBUG_LEVEL								0x0400
#define DPVF_BUFFERDESC_DEBUG_LEVEL								0x0800
#define DPVF_SOUNDTARGET_DEBUG_LEVEL								0x1000



#ifndef DPVF_ERRORLEVEL
#define DPVF_ERRORLEVEL                                          0x2000
#endif
#ifndef DPVF_ENTRYLEVEL
#define DPVF_ENTRYLEVEL                                          0x4000
#endif
#ifndef DPVF_INFOLEVEL
#define DPVF_INFOLEVEL                                           0x8000  // share same level
#endif
#ifndef DPVF_APIPARAM
#define DPVF_APIPARAM                                            0x8000
#endif
#ifndef DPVF_STRUCTUREDUMP
#define DPVF_STRUCTUREDUMP                                       0x8000
#endif
#ifndef DPVF_WARNINGLEVEL
#define DPVF_WARNINGLEVEL                                       0x10000
#endif
#ifndef DPVF_RECORDLEVEL
#define DPVF_RECORDLEVEL                                        0x20000
#endif

#ifndef DPVF_SPAMLEVEL
#define DPVF_SPAMLEVEL                                          0x40000
#endif

#ifndef DPVF_QUEUELEVEL
#define DPVF_QUEUELEVEL                                         0x80000
#endif

#define DPVL_ERRORS_ONLY                                         (DPVF_ERRORLEVEL | DPVF_WARNINGLEVEL)
#define DPVL_INFO                                                (DPVF_ERRORLEVEL | DPVF_WARNINGLEVEL | \
                                                                 DPVF_INFOLEVEL)

#define DPVL_SPAM                                                (DPVL_INFO | DPVF_ENTRYLEVEL | DPVF_INFOLEVEL) 


typedef struct _DVDEBUGSTACK {

    UCHAR ModName[256];
    PVOID This;

} DVDEBUGSTACK;

typedef struct _DVDEBUGDATA {

    DVDEBUGSTACK Stack[20];
    ULONG StackLevel;

} DVDEBUGDATA;

extern ULONG g_DVDebugLevel;
extern DVDEBUGDATA g_DVDbgData;
extern UCHAR g_ModName[256];
extern PVOID g_This;

#endif

#if DBG
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

#ifndef DPF_FNAME
#define DPF_FNAME DPF_MODNAME
#endif

void
DPVF
(
    DWORD                   dwLevel,
    LPCSTR                  pszFormat,
    ...
);

#define DPVF_ENTER()  {\
    if (g_DVDbgData.StackLevel > 3) {\
        g_DVDbgData.StackLevel = 0;\
    }\
    memcpy(g_DVDbgData.Stack[0].ModName,g_ModName,sizeof(g_ModName));\
    memcpy(g_ModName,DPF_MODNAME,sizeof(g_ModName));g_This = this;\
    }


#define DPVF_EXIT()  {\
    memcpy(g_ModName,g_DVDbgData.Stack[0].ModName,sizeof(g_ModName));\
    }


#else // DEBUG

#pragma warning(disable:4002)

#define DPVF()
#define DPVF_ENTER()
#define DPVF_EXIT()
#endif // DEBUG


#endif // _IN_CORE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\inqueue2.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       inqueue2.cpp
 *  Content:
 *      
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 07/16/99     pnewson Created
 * 02/08/2000   georgioc redone from scratch to make queueing work with our dowork model/simplify it
 *
 ***************************************************************************/

#include "dvntos.h"
#include "in_core.h"
#include "inqueue2.h"

#include <math.h>

#define MODULE_ID   INPUTQUEUE2

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::CInputQueue2"
CInputQueue2::CInputQueue2( )
        : m_dwSignature(VSIG_INPUTQUEUE2)
        , m_bCurMsgNum(0)
        , m_wQueueId(0)
        , m_dwTotalFrames(0)
        , m_dwTotalMessages(0)
        , m_dwTotalBadMessages(0)
        , m_dwDiscardedFrames(0)
        , m_dwDuplicateFrames(0)
        , m_dwLostFrames(0)
        , m_dwLateFrames(0)
        , m_dwOverflowFrames(0)
        , m_wMSPerFrame(0)
        , m_pFramePool(NULL)
{
    InitializeCriticalSection(&m_CS);
}

HRESULT CInputQueue2::Initialize( PQUEUE_PARAMS pParams )
{
    m_wQueueId = (USHORT)pParams->wQueueId;
    m_dwTotalFrames = 0;
    m_dwTotalMessages = 0;
    m_dwTotalBadMessages = 0;
    m_dwDiscardedFrames = 0;
    m_dwDuplicateFrames = 0;
    m_dwLostFrames = 0;
    m_dwLateFrames = 0;
    m_dwOverflowFrames = 0;
    m_wMSPerFrame = pParams->wMSPerFrame;
    m_pFramePool = pParams->pFramePool;

    InitializeListHead (&m_FrameQueue);

    DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** CInputQueue2::CInputQueue2() pFramePool: %p"), m_wQueueId, m_pFramePool);

    // set the queue to an empty state
    Reset();

    return DV_OK;
}

void CInputQueue2::GetStatistics( PQUEUE_STATISTICS pQueueStats )
{
    pQueueStats->dwTotalFrames = GetTotalFrames();
    pQueueStats->dwTotalMessages = GetTotalMessages();
    pQueueStats->dwTotalBadMessages = GetTotalBadMessages();
    pQueueStats->dwDiscardedFrames = GetDiscardedFrames();
    pQueueStats->dwDuplicateFrames = GetDuplicateFrames();
    pQueueStats->dwLostFrames = GetLostFrames();
    pQueueStats->dwLateFrames = GetLateFrames();
    pQueueStats->dwOverflowFrames = GetOverflowFrames();
}

void CInputQueue2::DeInitialize()
{
    PLIST_ENTRY pEntry;
    CFrame *pFrame;

    DV_AUTO_LOCK(&m_CS);

    pEntry = m_FrameQueue.Flink;
    while (pEntry != &m_FrameQueue) {
        
        pFrame = CONTAINING_RECORD(pEntry, CFrame, m_FramePoolEntry);
        RemoveEntryList(&pFrame->m_FramePoolEntry);
        pFrame->Return();
        pEntry = m_FrameQueue.Flink;
        
    }

}

// The destructor. Release all the resources we acquired in the
// constructor
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::~CInputQueue2"
CInputQueue2::~CInputQueue2()
{
    DeInitialize();
    m_dwSignature = VSIG_INPUTQUEUE2_FREE;
}

//
// This function clears all the input buffers and 
// resets the other class information to an initial
// state. The queue should not be in use when this 
// function is called. i.e. there should not be any
// locked frames.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Reset"
void CInputQueue2::Reset()
{
    PLIST_ENTRY pEntry;
    CFrame *pFrame;

    // make sure no one is using the queue right now
    DV_AUTO_LOCK(&m_CS);

    #if defined(DPVOICE_QUEUE_DEBUG)
    DPVF( DPVF_INFOLEVEL, ("** QUEUE ** %i ** CInputQueue2::Reset()"), m_wQueueId);
    #endif

    //
    // return all queued frames to the frame pool
    //

    pEntry = m_FrameQueue.Flink;
    while (pEntry != &m_FrameQueue) {
        
        pFrame = CONTAINING_RECORD(pEntry, CFrame, m_FramePoolEntry);
        RemoveEntryList(&pFrame->m_FramePoolEntry);
        pFrame->Return();
        pEntry = m_FrameQueue.Flink;
        
    }

    InitializeListHead(&m_FrameQueue);

    // we don't yet know the first message number, so just use zero
    m_bCurMsgNum = 0;


    // reset all the other stats too
    m_dwDiscardedFrames = 0;
    m_dwDuplicateFrames = 0;
    m_dwLateFrames = 0;
    m_dwLostFrames = 0;
    m_dwOverflowFrames = 0;
    m_dwQueueErrors = 0;
    m_dwTotalBadMessages = 0;
    m_dwTotalFrames = 0;
    m_dwTotalMessages = 0;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Enqueue"
BOOLEAN CInputQueue2::Enqueue(const CFrame& fr)
{
    PLIST_ENTRY pEntry;
    CFrame *pFrame = NULL;

    DV_AUTO_LOCK(&m_CS);

    DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** ******************************************"), m_wQueueId);
    DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** CInputQueue2::Enqueue() MsgNum[%i] SeqNum[%i]"), m_wQueueId, fr.GetMsgNum(), fr.GetSeqNum());

    //
    // first get our tail frame.
    // if the frame we are trying to enqueue is out of order (older than whats in our tail),
    // drop new one on the floor
    //


    if (!IsListEmpty(&m_FrameQueue)) {

        pEntry = m_FrameQueue.Blink;
        pFrame = CONTAINING_RECORD(pEntry, CFrame, m_FramePoolEntry);
    
        if ((pFrame->GetMsgNum() > fr.GetMsgNum()) ||
            (pFrame->GetSeqNum() > fr.GetSeqNum()) ) {

            DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** CInputQueue2::Enqueue() MsgNum[%i] SeqNum[%i], droping out of order frame"), m_wQueueId, fr.GetMsgNum(), fr.GetSeqNum());

            m_dwLateFrames++;

            return FALSE;

        }

    } 

    //
    // Get a frame from the frame pool.
    // Then enqueue the frame at the tail of our queue
    //

    if ((pFrame = m_pFramePool->Get())) {

        pFrame->SetEqual(fr);

        InsertTailList(&m_FrameQueue,
                       &pFrame->m_FramePoolEntry);

        m_bCurMsgNum = fr.GetMsgNum();
        m_dwTotalFrames++;

    } else {

        DPVF( DPVF_ERRORLEVEL, ("** QUEUE ** %i ** CInputQueue2::Enqueue() MsgNum[%i] SeqNum[%i],failed to get frame"), m_wQueueId, fr.GetMsgNum(), fr.GetSeqNum());
        return FALSE;

    }

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CInputQueue2::Dequeue"
CFrame* CInputQueue2::Dequeue()
{
    DV_AUTO_LOCK(&m_CS);
    CFrame* pfrReturn = 0;
    PLIST_ENTRY pEntry;

    DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** ******************************************"), m_wQueueId);
    DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** CInputQueue2::Dequeue()"), m_wQueueId);

    if (IsListEmpty(&m_FrameQueue)) {

        DPVF( DPVF_QUEUELEVEL, ("** QUEUE ** %i ** CInputQueue2::Dequeue() nothing available in inner queues, returning empty frame"), m_wQueueId);
    
        pfrReturn = m_pFramePool->Get();

        if (pfrReturn) {

            pfrReturn->SetIsSilence(TRUE);
            pfrReturn->SetIsLost(false);

        }

        return pfrReturn;

    }

    //
    // we got frames queued.. dequeue at the head so we get oldest frames out first (FIFO)
    //

    pEntry = RemoveHeadList(&m_FrameQueue);
    pfrReturn = CONTAINING_RECORD(pEntry, CFrame, m_FramePoolEntry);

    return pfrReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\inqueue2.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		inqueue2.h
 *  Content:	Definition of the CInputQueue2 class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 02/05/2001   georgioc rewrote it , replacing queuing scheme with very simple version
 *
 ***************************************************************************/

#ifndef _INPUTQUEUE2_H_
#define _INPUTQUEUE2_H_

#include "Frame.h"

typedef struct _QUEUE_PARAMS
{
    WORD wFrameSize;
	BYTE bInnerQueueSize;
	DWORD wQueueId;
    CFramePool* pFramePool;
	WORD wMSPerFrame;
    	
} QUEUE_PARAMS, *PQUEUE_PARAMS;

typedef struct _QUEUE_STATISTICS
{
    DWORD dwTotalFrames;
    DWORD dwTotalMessages;
    DWORD dwTotalBadMessages;
    DWORD dwDiscardedFrames;
    DWORD dwDuplicateFrames;
    DWORD dwLostFrames;
    DWORD dwLateFrames;
    DWORD dwOverflowFrames;
} QUEUE_STATISTICS, *PQUEUE_STATISTICS;

// This class manages a queue of frames. It is designed
// to allow a client class to remove frames from the queue
// at regular intervals, and to hide any out of order
// frame reception, or dropped frames from the caller.
// If for whatever reason there is no frame available
// to give a client, this class will still provide a
// frame marked as silent.  This allows the client to
// simply call the dequeue function once per period, and
// consume the data at the agreed rate.  So for example,
// the client to this class could be a thread which
// is consuming input data and passing it to DirectSound
// for playback. It can simply get a frame every 1/10 of
// a second (or however long a frame is), and play it.
//
// This is the second generation of input queue. It 
// manages a set of inner queues, each of which is used
// for a "message". The stream of speech is divided into
// a series of messages, using silence as the divider.
// This class will not function well if the audio stream
// is not divided into separate messages.
//
#define VSIG_INPUTQUEUE2		'QNIV'
#define VSIG_INPUTQUEUE2_FREE	'QNI_'
//
volatile class CInputQueue2
{
private:

    CRITICAL_SECTION m_CS;
	DWORD m_dwSignature; // Debug signature

	// The message number currently at the head of the queue
	BYTE m_bCurMsgNum;
	WORD m_wMSPerFrame;

	// Some statistics to track.
	DWORD m_dwTotalFrames;
	DWORD m_dwTotalMessages;
	DWORD m_dwTotalBadMessages;
	DWORD m_dwDiscardedFrames;
	DWORD m_dwDuplicateFrames;
	DWORD m_dwLostFrames;
	DWORD m_dwLateFrames;
	DWORD m_dwOverflowFrames;
	DWORD m_dwQueueErrors;

	// An abritrary queue ID, provided to the constructor, 
	// used to identify which queue an instrumentation message
	// is coming from. It serves no other purpose, and can be
	// ignored except for debug purposes.
	WORD m_wQueueId;

	// the frame pool to manage the frames so we don't have to
	// allocate a huge number of them when only a few are 
	// actually in use.
	CFramePool* m_pFramePool;

    //
    // our doubly linked list representing the frame FIFO
    //

    LIST_ENTRY m_FrameQueue;

public:

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'lcvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

	// The constructor. 
	CInputQueue2();
    
    HRESULT Initialize( PQUEUE_PARAMS pQueueParams );
    void DeInitialize();

    void GetStatistics( PQUEUE_STATISTICS pStats );

	// The destructor. Release all the resources we acquired in the
	// constructor
	~CInputQueue2();

	// This function clears all buffers and resets the other class 
	// information to an initial state. DO NOT CALL THIS FUNCTION
	// IF THE QUEUE IS IN USE! i.e. do not call it if you have
	// not called Return() on every frame that you have
	// taken from this queue.
	void Reset();

	// Call this function to add a frame to the queue.  I 
	// considered returning a reference to a frame which 
	// the caller could then stuff, but because the frames
	// will not always arrive in order, that would mean I would have
	// to copy the frame sometimes anyway.  So, for simplicity, the
	// caller has allocated a frame, which it passes a reference
	// to, and this function will copy that frame into the
	// appropriate place in the queue, according to its
	// message number and sequence number.
	BOOLEAN Enqueue(const CFrame& fr);

	// This function retrieves the next frame from the head of
	// the queue. For speed, it does not copy the data out of the
	// buffer, but instead returns a pointer to the actual
	// frame from the queue. Of course, there is the danger
	// that the CInputQueue2 object which returns a reference to the
	// frame may try to reuse that frame before the caller is 
	// finished with it. The CFrame's lock and unlock member functions
	// are used to ensure this does not happen.  When the caller
	// is finished with the CFrame object, it should call vUnlock()
	// on it. If the caller doesn't unlock the frame, bad things
	// will happen when the input queue tries lock it again when 
	// it wants to reuse that frame. In any case, the caller
	// should always unlock the returned frame before it attempts
	// to dequeue another frame.
	CFrame* Dequeue();

	// get stats
	DWORD GetDiscardedFrames() { return m_dwDiscardedFrames; }
	DWORD GetDuplicateFrames() { return m_dwDuplicateFrames; }
	DWORD GetLateFrames() { return m_dwLateFrames; }
	DWORD GetLostFrames() { return m_dwLostFrames; }
	DWORD GetOverflowFrames() { return m_dwOverflowFrames; }
	DWORD GetQueueErrors() { return m_dwQueueErrors; }
	DWORD GetTotalBadMessages() { return m_dwTotalBadMessages; }
	DWORD GetTotalFrames() { return m_dwTotalFrames; }
	DWORD GetTotalMessages() { return m_dwTotalMessages; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\frame.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		frame.h
 *  Content:	declaration of the CFrame and CFramePool classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 09/01/2000   georgioc started xbox port/rewrite
 ***************************************************************************/

#ifndef _FRAME_H_
#define _FRAME_H_

#include <dvoicep.h>
#include "dvshared.h"

// forward declaration
class CFramePool;

//
// we need to be able to return 0 length frames for silence. SO the number of frames
// we preallocate needs to be larger than the max number of speech frames we expect
// buffered at any time
//

#define FRAME_POOL_MAX_FRAMES   DV_CT_FRAMES_PER_PERIOD*2

#define VSIG_FRAME		'MRFV'
#define VSIG_FRAME_FREE	'MRF_'

// This class is designed to manage one frame of sound data.
//
// tag: fr
volatile class CFrame
{
private:

	DWORD				m_dwSignature;

    // Length of the data within the frame.  There may be less then a whole
    // frame worth of data in the buffer due to compression/decompression may
    // result in a slightly different size buffer.
    WORD m_wFrameLength;

	// The size of this frame.  It would be easier to make
	// this a class constant, but we're probably going to want to 
	// toy with the frame sizes while we're optimizing, and
	// we may even get really fancy in the future and have
	// the client and server negotiate the frame size at connection
	// time, all of which will be easier if we bite the bullet now
	// and make this a member variable.  Note this is constant,
	// so once a frame is instantiated, it's size is permanently set.
	WORD m_wFrameSize;

	// The client number this frame is coming from or
	// going to.
	WORD m_wClientId;

	// The frame sequence number.
	BYTE m_wSeqNum;

	// The message number the frame is part of
    BYTE m_bMsgNum;

    // The target of the frame
    PDVID m_pdvidTargets;
    DWORD m_dwNumTargets;
    DWORD m_dwMaxTargets;

    bool m_fOwned;

	// A flag to specify that this frame contains nothing but silence.
	// When this flag is set, the data in the frame buffer should not 
	// be used - it's probably not valid.
	BYTE m_bIsSilence;

	// A pointer to the frame's data
	BYTE* m_pbData;

	// If this frame is part of a managed frame pool, this
	// member will be non-null.
	CFramePool* m_pFramePool;

	// A flag to indicate if this frame was "lost". This is
	// used to distinguish the silent frames pulled from the
	// queue between messages from the dead space caused by 
	// a known lost packet.
	bool m_fIsLost;


	// don't allow copy construction or assignment of these
	// structures, as this would kill our performance, and
	// we don't want to do it by accident
	CFrame(const CFrame& fr);
	CFrame& operator=(const CFrame& fr);

public:

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'etnv');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

    LIST_ENTRY  m_FramePoolEntry;

	// This constructor sets all the frame's info, and allocates
	// the data buffer, but does not set the data inside the buffer
	// to anything.  Defaults are provided for all the parameters
	// except for the frame size.  Note: no default constructor,
	// since you must specify the frame size.
	CFrame(WORD wFrameSize, 
		WORD wClientNum = 0,
		BYTE wSeqNum = 0,
        BYTE bMsgNum = 0,
		BYTE bIsSilence = 0,
		CFramePool *pFramePool = NULL);

	// A frame which manages user ownded memory
	CFrame();

	// The destructor cleans up the memory allocated by the
	// constructor
	~CFrame();

	inline DWORD GetNumTargets() const { return m_dwNumTargets; };
	inline const PDVID GetTargetList() const { return m_pdvidTargets; };

    // Length of the data within the buffer
    WORD GetFrameLength() const { return m_wFrameLength; }

	// returns the frame size, (the length of the data buffer)
	WORD GetFrameSize() const { return m_wFrameSize; }

	HRESULT SetEqual( const CFrame &frSourceFrame );

	// These are just a bunch of set and get functions for 
	// the simple parts of the class, the client id, the
	// sequence number, the silence flag, etc.
    HRESULT GetTargets( PDVID pdvidTargets, PDWORD pdwNumTargets ) const;
    HRESULT SetTargets( PDVID pdvidTargets, DWORD dwNumTargets );
    
    BYTE GetMsgNum() const { return m_bMsgNum; }
    void SetMsgNum( BYTE msgNum ) { m_bMsgNum = msgNum; }
	void SetClientId(WORD wClientId) {	m_wClientId = wClientId; }
	WORD GetClientId() const {	return m_wClientId;	}
	void SetSeqNum(BYTE wSeqNum) {	m_wSeqNum = wSeqNum; }
	BYTE GetSeqNum() const { return m_wSeqNum; }
	void SetIsSilence(BYTE bIsSilence) { m_bIsSilence = bIsSilence; }
    void SetFrameLength(const WORD &length) { m_wFrameLength = length; }
	BYTE GetIsSilence() const { return m_bIsSilence; }
	bool GetIsLost() const { return m_fIsLost;	}
	void SetIsLost(bool fIsLost) {	m_fIsLost = fIsLost; }
	
	// Now we have the functions which handle the data.  This
	// class is pretty trusting, because it will give out the
	// pointer to it's data.  This is to avoid all non-required
	// buffer copies.  For example, when you hand a buffer to
	// a wave in function, you can give it the pointer to this
	// buffer, and it will fill in the frame's buffer directly.
	// Between this function and the GetFrameSize() and 
	// GetFrameLength() functions, you can do anything you want 
	// with the buffer.
	BYTE* GetDataPointer() const { return m_pbData; }

	// This copies the data from another frame into this frame
	void CopyData(const CFrame& fr)
	{
		memcpy(m_pbData, fr.GetDataPointer(), fr.GetFrameLength() );
        m_wFrameLength = fr.GetFrameLength();
	}

	void UserOwn_SetData( BYTE *pbData, DWORD dwLength )
	{
		m_pbData = pbData;
		m_wFrameLength = (WORD)dwLength;
		m_wFrameSize = (WORD)dwLength;
	}

	void UserOwn_SetTargets( PDVID pdvidTargets, DWORD dwNumTargets )
	{
		m_pdvidTargets = pdvidTargets;
		m_dwNumTargets = dwNumTargets;
		m_dwMaxTargets = dwNumTargets;
	}

	// This copies data from a buffer into this frame's
	// buffer.
	void CopyData(const BYTE* pbData, WORD wFrameLength);

	// If this frame is part of a frame pool managed by a
	// CFramePool object, then call this function when you 
	// are done with the frame and want to return it to the
	// pool.
    void Return();

	void SetFramePool(CFramePool* pFramePool) { m_pFramePool = pFramePool;	}
};

// This class manages a pool of frames, to reduce memory requirements.
// Only a few buffers are actually in use at any time by the queue
// class, and yet it may have to allocate hundreds of them unless 
// a class such as this is used to manage their reuse.
volatile class CFramePool
{
private:
	// the pool is simply a vector of frame objects
    
    LIST_ENTRY m_FramePool;

	// All the frames in the pool must be the same size,
	// which is stored here.
	WORD m_wFrameSize;

	#if defined(DEBUG) || defined(DBG)
    // Used to detect runaway frame pool usage.
    LONG m_lCount;
    #endif
	
public:

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'etnv');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }



	// Each frame pool manages frames of a certain size,
	// so they can be easily reused. If you need multiple
	// different frame sizes, you'll need more than one 
	// frame pool.
	CFramePool(WORD wFrameSize); 
	~CFramePool();

	// Use Get to retrieve a frame from the pool.
	CFrame* Get();

	// Call Return to give a frame back to the frame pool. 
	// This may set a pointer to null and enter a critical
	// section, as described in Get() above.
	void Return(CFrame* pFrame);
};


#endif /* _FRAME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\mixutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MixerUtils.cpp
 *  Content:	Utility functions for mixing audio 
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/06/99	rodtoll	Created It
 *
 ***************************************************************************/
#include "dvntos.h"
#include "mixutils.h"
#include "in_core.h"

#define DPV_MAX_SHORT   ((SHORT)32767)
#define DPV_MIN_SHORT   ((SHORT)-32768)

#define DPV_MAX_BYTE    127
#define DPV_MIN_BYTE    0

// "Mixer Buffer"
//
// Throughout this module we refer to a "mixer buffer".  A mixer buffer is a 
// buffer of higher resolution then a traditional audio buffer which is used
// for mixing audio.  In the case of this module a mixer buffer promotes 
// each sample to a DWORD.  So audio is mixed in a "mixer buffer" and then
// converted back to the approrpriate sample size.

#undef DPF_MODNAME
#define DPF_MODNAME "FillBufferWithSilence"
// FillBufferWithSilence
//
// This function fills a mixer buffer with the appropriate bytes to make it
// equivalent to silence.  
//
// Parameters:
// LONG *buffer -
//		Pointer to the mixer buffer which will be filled with silence.
// BOOL eightBit -
//		Is the audio we're mixing 8 bit?  (Set to TRUE for 8 bit)
// LONG frameSize -
//		The number of samples the mixer buffer consists of.  
//
// Returns:
// N/A
//
void FillBufferWithSilence( LONG *buffer, LONG frameSize )
{
    LONG mixerSize = frameSize;

	// If we're working with 16 bit then the number of samples is half the 
	// number of bytes in a frame.
    mixerSize >>= 1;

    BYTE silenceByte = 0x00;

	// Set the mixer buffer to silence
    memset( buffer, silenceByte, mixerSize << 2 );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MixIn16BitBuffer"
// MixIn16BitBuffer
//
// This function mixes a 16-bit buffer with an existing mixer buffer.  
//
// Parameters:
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// SHORT *sourceBuffer -
//		Pointer to the buffer which will be mixed into the mixer buffer
// LONG frameSize -
//		The size, in bytes of the source Buffer.  (Since the sourceBuffer
//		is 16 bit, the number of samples is # of bytes / 2).
//
// Returns:
// N/A
//
void MixIn16BitBuffer( LONG *mixerBuffer, SHORT *sourceBuffer, LONG frameSize )
{
    LONG mixerSize = frameSize >> 1;

    for( int index = 0; index < mixerSize; index++ )
    {
        mixerBuffer[index] += sourceBuffer[index];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MixInBuffer"
// MixInBitBuffer
//
// This function mixes an 8 or 16-bit buffer with an existing mixer buffer.  
//
// Parameters:
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// BYTE *sourceBuffer -
//		Pointer to the buffer which will be mixed into the mixer buffer
// LONG frameSize -
//		The size, in bytes of the source Buffer.  
//
// Returns:
// N/A
//
void MixInBuffer( LONG *mixerBuffer, BYTE *sourceBuffer, LONG frameSize )
{
    MixIn16BitBuffer( mixerBuffer, (SHORT *) sourceBuffer, frameSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Normalize16BitBuffer"
// Normalize16BitBuffer
//
// This function takes the "mixer buffer" and transfers the result of
// the mix back to a 16-bit audio buffer.
//
// Parameters:
// SHORT *targetBuffer -
//		Pointer to the buffer which where the mixed audio will be placed
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// LONG frameSize -
//		The size, in bytes of the target buffer.  
//
// Returns:
// N/A
//
void Normalize16BitBuffer( SHORT *targetBuffer, LONG *mixerBuffer, LONG frameSize )
{
    LONG mixerSize = frameSize >> 1;

    for( int index = 0; index < mixerSize; index++ )
    {
        // Clip mixed audio, ensure it does not exceed range
        if( mixerBuffer[index] >= DPV_MAX_SHORT )
            targetBuffer[index] = DPV_MAX_SHORT;
        else if( mixerBuffer[index] <= DPV_MIN_SHORT )
            targetBuffer[index] = DPV_MIN_SHORT;
        else
            targetBuffer[index] = (SHORT) mixerBuffer[index]; // / noiseCount;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "NormalizeBuffer"
// NormalizeBuffer
//
// This function takes the "mixer buffer" and transfers the result of
// the mix back to an 8-bit or 160bit audio buffer.
//
// Parameters:
// BYTE *targetBuffer -
//		Pointer to the buffer which where the mixed audio will be placed
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// BOOL eightBit -
//		If the buffer is 8-bit, set this to TRUE, set to FALSE for 16-bit
// LONG frameSize -
//		The size, in bytes of the target buffer.  
//
// Returns:
// N/A
//
void NormalizeBuffer( BYTE *targetBuffer, LONG *mixerBuffer, BOOL eightBit, LONG frameSize )
{
    Normalize16BitBuffer( (SHORT *) targetBuffer, mixerBuffer, frameSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\mixutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		MixerUtils.h
 *  Content:	Base class for dp/dnet abstraction
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Utility functions for mixing audio 
 *
 ***************************************************************************/

#ifndef __MIXERUTILS_H
#define __MIXERUTILS_H

void FillBufferWithSilence( LONG *buffer, LONG frameSize );
void MixInBuffer( LONG *mixerBuffer, BYTE *sourceBuffer, LONG frameSize );
void NormalizeBuffer( BYTE *targetBuffer, LONG *mixerBuffer, LONG frameSize );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\frame.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		wirecd.cpp
 *  Content:
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		pnewson	Created
 * 08/03/99		pnewson General clean up, updated target to DVID
 * 01/14/2000	rodtoll	Updated to support multiple targets.  Frame will 
 *						automatically allocate memory as needed for targets.
 *				rodtoll	Added SetEqual function to making copying of frame
 *						in Queue easier. 
 *				rodtoll	Added support for "user controlled memory" frames.
 *						When the default constructor is used with the UserOwn_XXXX
 *						functions the frames use user specified buffers.  
 *						(Removes a buffer copy when queueing data). 
 *  01/31/2000	pnewson replace SAssert with DNASSERT
 *  02/17/2000	rodtoll	Updated so sequence/msg numbers are copied when you SetEqual
 *  07/09/2000	rodtoll	Added signature bytes 
 *
 ***************************************************************************/

#include "dvntos.h"
#include "in_core.h"

#include "frame.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CFrame"

// SetEqual        
//
// This function sets the current frame to match the data in frSourceFrame
//
HRESULT CFrame::SetEqual( const CFrame &frSourceFrame )
{
	HRESULT hr;
	
	SetClientId( frSourceFrame.GetClientId());
	SetSeqNum(frSourceFrame.GetSeqNum());
	SetMsgNum(frSourceFrame.GetMsgNum());
	CopyData(frSourceFrame);
	SetIsSilence(frSourceFrame.GetIsSilence());

	hr = SetTargets( frSourceFrame.GetTargetList(), frSourceFrame.GetNumTargets() );

	if( FAILED( hr ) )
	{
		DPVF( DPVF_ERRORLEVEL, "Error copying frame for queue" );
	}

	return hr;
}

// GetTargets
//
// This program gets the targets for this frame
HRESULT CFrame::GetTargets( PDVID pdvidTargets, PDWORD pdwNumTargets ) const
{
	ASSERT( pdwNumTargets != NULL );
		
	if( pdwNumTargets != NULL )
	{
		DPVF( DPVF_ERRORLEVEL, "Invalid param" );
		return DVERR_INVALIDPARAM;
	}

	if( *pdwNumTargets < m_dwNumTargets || pdvidTargets == NULL )
	{
		*pdwNumTargets = m_dwNumTargets;
		return DVERR_BUFFERTOOSMALL;
	}

	*pdwNumTargets = m_dwNumTargets;

	memcpy( pdvidTargets, m_pdvidTargets, sizeof(DVID)*m_dwNumTargets );

	return DV_OK;
}

// SetTargets
//
// This program sets the targets for this frame.  It will expand the 
// target list (if required) or use a subset of the current buffer.
//
HRESULT CFrame::SetTargets( PDVID pdvidTargets, DWORD dwNumTargets )
{
	ASSERT( m_fOwned );
	
	if( dwNumTargets > m_dwMaxTargets )
	{
        //
        // we should never be here. The session must never exceed
        // the pre-allocated max target size in dvprot.h
        //
        ASSERT(FALSE);
		if( m_pdvidTargets != NULL )
		{
			delete [] m_pdvidTargets;
		}

		m_pdvidTargets = (DVID *)DV_POOL_ALLOC(sizeof(DVID)*dwNumTargets);

		if( m_pdvidTargets == NULL )
		{
			DPVF( DPVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}
		
		m_dwMaxTargets = dwNumTargets;
	}

	m_dwNumTargets = dwNumTargets;

	memcpy( m_pdvidTargets, pdvidTargets, sizeof(DVID)*dwNumTargets );

	return DV_OK;
}

// This function is called to return a frame to the frame
// pool that is managing it. If a primary pointer was 
// provided, it will be set to NULL.
void CFrame::Return()
{
    KIRQL irql;

    RIRQL(irql);

	// this frame is supposed to be part of a frame pool if
	// this function is called
	ASSERT(m_pFramePool != NULL);

	// return the frame to the pool, and set the primary
	// frame pointer to null to signal to the caller that
	// this frame is now gone. Note that this pointer update
	// is done within the critical section passed to this
	// class, and so the caller should also use this 
	// critical section to check the pointer value. This
	// is true for CInputQueue, which uses the critical
	// section for Reset, Enqueue and Dequeue.
	m_pFramePool->Return(this);

    LIRQL(irql);
}

// CFrame Constructor
//
// This is the primary constructor which is used for creating frames
// that are used by the frame pool.
//
// If you want to create a non-pooled frame then use the default constructor
//
CFrame::CFrame(WORD wFrameSize, 
	WORD wClientNum,
	BYTE wSeqNum,
    BYTE bMsgNum,
	BYTE bIsSilence,
	CFramePool* pFramePool)
	: m_dwSignature(VSIG_FRAME),
	m_wFrameSize(wFrameSize),
	m_wClientId(wClientNum),
	m_wSeqNum(wSeqNum),
	m_bMsgNum(bMsgNum),
	m_bIsSilence(bIsSilence),
    m_wFrameLength(wFrameSize),
	m_pFramePool(pFramePool),
	m_fIsLost(false),
	m_pdvidTargets(NULL),
	m_dwNumTargets(0),
	m_dwMaxTargets(0),
	m_fOwned(true)
{
	m_pbData = (PBYTE)DV_POOL_ALLOC(m_wFrameSize);
}

// CFrame Constructor
//
// This is the constructor to use when creating a standalone frame.  This 
// type of frame can take an external buffer to eliminate a buffer copy.
//
// The frame doesn't "own" the buffer memory so it doesn't attempt to 
// free it.
//
// To set the data for the frame use the UserOwn_SetData member.
//
// Target information can be handled the same way by using UserOwn_SetTargets 
//
CFrame::CFrame(
	): 	m_dwSignature(VSIG_FRAME),
		m_wFrameSize(0),
		m_wClientId(0),
		m_wSeqNum(0),
		m_bMsgNum(0),
		m_bIsSilence(true),
	    m_wFrameLength(0),
		m_pFramePool(NULL),
		m_fIsLost(false),
		m_pdvidTargets(NULL),
		m_dwNumTargets(0),
		m_dwMaxTargets(0),
		m_fOwned(false)
{
}

CFrame::~CFrame() 
{	
	if( m_fOwned )
	{
        if (m_pbData) {

            DV_POOL_FREE(m_pbData); 

        }
		
        m_pbData = NULL;

		if( m_pdvidTargets != NULL )
		{
			DV_POOL_FREE(m_pdvidTargets);
		}

        m_pdvidTargets = NULL;
	}


	m_dwSignature = VSIG_FRAME_FREE;
}

void CFrame::CopyData(const BYTE* pbData, WORD wFrameLength)
{
	ASSERT(pbData != 0);
	memcpy(m_pbData, pbData, wFrameLength);
    m_wFrameLength = wFrameLength;
}

CFramePool::CFramePool(WORD wFrameSize)
	: m_wFrameSize(wFrameSize)
{
    ULONG i;
    CFrame * pFrame;

	#if defined(DEBUG) || defined(DBG)
	m_lCount = 0;
	#endif

    InitializeListHead(&m_FramePool);

    //
	// Push a few frames into the pool to start with
    // this must tuned to be enough for the lifetime of the session
    //

    for (i=0;i<FRAME_POOL_MAX_FRAMES;i++) {

        pFrame = new CFrame(m_wFrameSize);
        InsertHeadList(&m_FramePool,&pFrame->m_FramePoolEntry);
    }
	

	return;
}

CFramePool::~CFramePool()
{
    CFrame *pFrame;
    PLIST_ENTRY pEntry;

    pEntry = m_FramePool.Flink;
    while (pEntry != &m_FramePool) {

        pFrame = CONTAINING_RECORD(pEntry, CFrame, m_FramePoolEntry);
        pEntry = pFrame->m_FramePoolEntry.Flink;

        delete pFrame;

    }

}

CFrame* CFramePool::Get()
{

    KIRQL irql;
    RIRQL(irql);

    ASSERT( m_lCount < 300 );

	CFrame* pfr;
	if (IsListEmpty(&m_FramePool) )
	{
        ASSERT(FALSE);
        LIRQL(irql);
		return NULL;
		
	}
	else
	{
        PLIST_ENTRY pEntry = RemoveTailList(&m_FramePool);
        pfr = CONTAINING_RECORD(pEntry,CFrame,m_FramePoolEntry);
	}

	pfr->SetFramePool(this);

	// clear up the rest of the flags, but don't bother messing
	// with the data.
	pfr->SetIsLost(false);
	pfr->SetMsgNum(0);
	pfr->SetSeqNum(0);
	pfr->SetIsSilence(FALSE);

	#ifdef DEBUG
    m_lCount++;
    #endif

    LIRQL(irql);
	return pfr;
}

void CFramePool::Return(CFrame* pFrame)
{

    KIRQL irql;
    RIRQL(irql);
    ASSERT( m_lCount < 300 );

	// drop this frame on the back for reuse
	InsertHeadList(&m_FramePool,&pFrame->m_FramePoolEntry);

	#ifdef DEBUG
    m_lCount--;
    #endif
    LIRQL(irql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\sndutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		micutils.cpp
 *  Content:
 *		This module contains the implementation of sound related utility
 *		functions.  Functions in this module manipulate WAVEFORMATEX
 *		structures and provide full duplex initialization / testing
 *		facilities.
 *
 *		This module also contains the routines used to measure peak
 *		of an audio buffer and for voice activation.
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated util functions to take GUIDs and allow for 
 *                      users to pre-create capture/playback devices and
 *						pass them into InitXXXXDuplex
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 * 08/30/99		rodtoll	Added new playback format param to sound init 
 * 09/03/99		rodtoll	Fixed return codes on InitFullDuplex
 * 09/20/99		rodtoll	Now checks for invalid GUIDs for playback/record
 * 10/05/99		rodtoll	Added DPF_MODNAMEs
 * 10/29/99		rodtoll	Bug #113726 - Fixed memory leak when full duplex
 *						fails caused by architecture update.
 * 11/12/99		rodtoll	Updated full duplex test to use new abstracted recording
 *						and playback systems.  
 *				rodtoll	Updated to allow passing of sounddeviceconfig flags in dwflags
 *						parameter to init is effected by the flags specified by user
 *				rodtoll	Sound buffers (rec and playback) are now set to silence before
 *						recording/playback is started.
 * 11/22/99		rodtoll	Removed unnessessary set of recording buffer to silence.
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Updated for new parameters added by above bug.
 * 12/08/99		rodtoll	Bug #121054 - Support for capture focus and removed flags
 *						from buffer, allow dsound to manage buffer location.
 * 01/21/2000	pnewson	Fixed error cleanup code in InitHalfDuplex
 * 01/27/2000	rodtoll	Updated tests to accept buffer descriptions and play flags/priority  
 * 02/10/2000	rodtoll	Removed more capture focus
 * 02/23/2000	rodtoll	Fix to allow to run on dsound7.  
 * 05/19/2000   rodtoll Bug #35395 - Unable to run two copies of DPVHELP on same system without 
 *                      DirectX 8 installed.
 * 06/21/2000	rodtoll Bug #35767 - Must implement ability to use effects processing on voice buffers
 *						Updated sound initialization routines to handle buffers being passed in.
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 *
 ***************************************************************************/
#define NODSOUND
#include "dvntos.h"
#include "dsoundp.h"

#include "sndutils.h"
#include "in_core.h"

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak16Bit"
// FindPeak16Bit
//
// This function determines what the peak for a buffer
// of 16 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak16Bit( short *data, DWORD frameSize )
{
    int peak,       
        tmpData;

    frameSize /= 2;
    peak = 0;
    
    for( int index = 0; index < (LONG)frameSize; index++ )
    {
        tmpData = data[index];

        if( tmpData < 0 )
        {
            tmpData *= -1;
        }

        if( tmpData > peak )
        {
            peak = tmpData;
        }
    }

    tmpData = (peak * 100) / 0x7FFF;

    return (BYTE) tmpData;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindPeak"
// FindPeak
//
// This function determines what the peak for a buffer
// of 8 or 16 bit audio is.  Peak is defined as the loudest 
// sample in a set of audio data rated on a scale of 
// between 0 and 100.  
//
// Parameters:
// BYTE *data -
//		Pointer to the buffer containing the audio data
//      to find the peak of. 
// DWORD frameSize -
//		The size in bytes of the audio data we are
//      checking.
// BOOL eightBit -
//		Determins if the buffer is 8 bit or not.  Set to 
//      TRUE for 8 bit data, FALSE for 16 bit data.  
//
// Returns:
// BYTE -
// The peak of the audio buffer, a value between 0 and 100.
//		
BYTE FindPeak( BYTE *data, DWORD frameSize, BOOL eightBit )
{
    return FindPeak16Bit( (signed short *) data, frameSize );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CreateWaveFormat"
// CreateWaveFormat
//
// This utility function is used to allocate and fill WAVEFORMATEX 
// structures for the various formats used. This function
// currently supports the following formats:
//
// WAVE_FORMAT_DSPGROUP_TRUESPEECH
// WAVE_FORMAT_GSM610
// WAVE_FORMAT_LH_CODEC
// WAVE_FORMAT_PCM
//
// The function will allocate the required memory for the sturcture
// (including extra bytes) as required by the format and will fill
// in all the members of the sturcture.  The structure which is 
// returned belongs to the caller and must be deallocated by the
// caller.
//
// Parameters:
// short formatTag -
//		The format tag for the wav format.
//
// BOOL stereo -
//		Specify TRUE for stereo, FALSE for mono
//
// int hz - 
//		Specify the sampling rate of the format.  E.g. 22050
//
// int bits - 
//		Specify the number of bits / sample.  E.g. 8 or 16
//
// Returns:
// WAVEFORMATEX * - 
//		A pointer to a newly allocated WAVEFORMATEX structure 
//      for the specified format, or NULL if format is not supported
//
WAVEFORMATEX *CreateWaveFormat( short formatTag, BOOL stereo, int hz, int bits ) 
{

	switch( formatTag ) {
	case WAVE_FORMAT_PCM:
		{
			WAVEFORMATEX *format		= new WAVEFORMATEX;

            if( format == NULL )
            {
				goto EXIT_MEMALLOC_CREATEWAV;            
			}
			
			format->wFormatTag			= WAVE_FORMAT_PCM;
			format->nSamplesPerSec		= hz;
			format->nChannels			= (stereo) ? 2 : 1;
			format->wBitsPerSample		= (WORD) bits;
			format->nBlockAlign			= (bits * format->nChannels / 8);
			format->nAvgBytesPerSec		= format->nSamplesPerSec * format->nBlockAlign;
			format->cbSize				= 0;
			return format;
		}
		break;
    default:
        ASSERT( TRUE );
	}

EXIT_MEMALLOC_CREATEWAV:

	DPVF( DPVF_ERRORLEVEL, "Unable to alloc buffer for waveformat, or invalid format" );
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\trnotify.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		trnotify.h
 *  Content:	Definitions of the IDirectXVoiceNotify interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/26/99		rodtoll	Created
 * 09/01/2000 georgioc started port to xbox
 ***************************************************************************/
#ifndef __TRNOTIFY_H
#define __TRNOTIFY_H

#define NODSOUND
#include <xtl.h>
#include <dsoundp.h>
#include "dvoicep.h"
#include "dvshared.h"

#ifdef __cplusplus
extern "C" {
#endif

STDAPI DV_NotifyEvent( LPDIRECTVOICENOTIFYOBJECT lpDVN, DWORD dwType, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
STDAPI DV_ReceiveSpeechMessage( LPDIRECTVOICENOTIFYOBJECT lpDVN, DVID dvidSource, DVID dvidTo, LPVOID lpMessage, DWORD dwSize );
STDAPI DV_Notify_Initialize( LPDIRECTVOICENOTIFYOBJECT lpDVN );

STDAPI DV_Notify_AddRef(LPDIRECTVOICENOTIFYOBJECT lpDVN );
STDAPI DVC_Notify_Release(LPDIRECTVOICENOTIFYOBJECT lpDVN );
STDAPI DVC_Notify_QueryInterface(LPDIRECTVOICENOTIFYOBJECT lpDVN, REFIID riid, LPVOID * ppvObj );
STDAPI DVS_Notify_QueryInterface(LPDIRECTVOICENOTIFYOBJECT lpDVN, REFIID riid, LPVOID * ppvObj );
STDAPI DVS_Notify_Release(LPDIRECTVOICENOTIFYOBJECT lpDVN );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\sndutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		sndutils.h
 *  Content:	Declares sound related untility functions
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/01/2000   georgioc started port to xbox
 ***************************************************************************/

//
// This module contains the definition of sound relatedt utility
// functions.  Functions in this module manipulate WAVEFORMATEX
// structures and provide full duplex initialization / testing
// facilities.
//
// This module also contains the routines used to measure peak
// of an audio buffer and for voice activation.
//
//
#ifndef __SOUNDUTILS_H
#define __SOUNDUTILS_H

BYTE FindPeak( BYTE *data, DWORD frameSize, BOOL eightBit );    
WAVEFORMATEX *CreateWaveFormat( short formatTag, BOOL stereo, int hz, int bits );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\trnotify.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		trnotify.cpp
 *  Content:	Implementation of the IDirectXVoiceNotify interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/26/99		rodtoll	Created
 * 08/03/99		rodtoll	Updated with new parameters for Initialize
 *						Updated for new initialization order
 * 08/05/99		rodtoll	Added hook for host migration
 * 08/05/99		rodtoll	Added new receive parameter
 * 08/10/99		rodtoll	Initial host migration
 * 08/31/99		rodtoll	Updated to use new debug libs
 * 09/14/99		rodtoll	Updated to reflect new parameters for Initialize call
 * 09/20/99		rodtoll	Updated to check for out of memory errors
 * 09/28/99		rodtoll	Added release on server interface created by host migration
 * 10/05/99		rodtoll	Additional comments
 * 10/19/99		rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if stopsession should be called from release
 *						- Fixed host migration break caused by Fix.
 * 10/25/99		rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 * 12/16/99		rodtoll Fix: Bug #122629 - Updated for new host migration
 * 04/07/2000   rodtoll Updated to match changes in DP <--> DPV interface 
 * 07/22/20000	rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  Now ensures that all threads from transport have left and that
 *					  all notificatinos have been processed before shutdown is complete. 
 *						
 ***************************************************************************/
#include "dvntos.h"
#include "trnotify.h"
#include "dvclient.h"
#include "dvserver.h"
#include "dvshared.h"
#include <dvoicep.h>
#include "dvdxtran.h"
#include "in_core.h"

extern HRESULT DVC_Create(LPDIRECTVOICECLIENTOBJECT *piDVC);
extern HRESULT DVS_Create(LPDIRECTVOICESERVEROBJECT *piDVS);


#undef DPF_MODNAME
#define DPF_MODNAME "DV_NotifyEvent"
STDMETHODIMP IDirectPlayVoiceNotify_NotifyEvent( LPDIRECTPLAYVOICENOTIFY This, DWORD dwNotifyType, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    LPDIRECTVOICENOTIFYOBJECT lpDVN = (LPDIRECTVOICENOTIFYOBJECT) This;

	switch( dwNotifyType )
	{
	case DVEVENT_MIGRATEHOST:
		lpDVN->lpDV->lpDVEngine->MigrateHost( 0, NULL );
		break;
	case DVEVENT_STARTSESSION:
		lpDVN->lpDV->lpDVEngine->StartTransportSession();
		break;
	case DVEVENT_STOPSESSION:
		lpDVN->lpDV->lpDVEngine->StopTransportSession();
		break;
	case DVEVENT_ADDPLAYER:
		lpDVN->lpDV->lpDVEngine->AddPlayer( (DVID) dwParam1 );
		break;
	case DVEVENT_REMOVEPLAYER:
		lpDVN->lpDV->lpDVEngine->RemovePlayer( (DVID) dwParam1 );
		break;
	case DVEVENT_CREATEGROUP:
		lpDVN->lpDV->lpDVEngine->CreateGroup( (DVID) dwParam1 );
		break;
	case DVEVENT_DELETEGROUP:
		lpDVN->lpDV->lpDVEngine->DeleteGroup( (DVID) dwParam1 );
		break;
	case DVEVENT_ADDPLAYERTOGROUP:
		lpDVN->lpDV->lpDVEngine->AddPlayerToGroup( (DVID) dwParam1, (DVID) dwParam2 );
		break;
	case DVEVENT_REMOVEPLAYERFROMGROUP:
		lpDVN->lpDV->lpDVEngine->RemovePlayerFromGroup( (DVID) dwParam1, (DVID) dwParam2 );
		break;
	case DVEVENT_SENDCOMPLETE:
	    lpDVN->lpDV->lpDVEngine->SendComplete( (PDVEVENTMSG_SENDCOMPLETE) dwParam1 );
	    break;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ReceiveSpeechMessage"
STDMETHODIMP IDirectPlayVoiceNotify_ReceiveSpeechMessage( LPDIRECTPLAYVOICENOTIFY This, DVID dvidSource, DVID dvidTo, LPVOID lpMessage, DWORD dwSize )
{
    LPDIRECTVOICENOTIFYOBJECT lpDVN = (LPDIRECTVOICENOTIFYOBJECT) This;
	lpDVN->lpDV->lpDVEngine->ReceiveSpeechMessage( dvidSource, lpMessage, dwSize );
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_Notify_Initialize"
STDMETHODIMP IDirectPlayVoiceNotify_Initialize( LPDIRECTPLAYVOICENOTIFY This ) 
{
    LPDIRECTVOICENOTIFYOBJECT lpDVN = (LPDIRECTVOICENOTIFYOBJECT) This;
	return lpDVN->lpDV->lpDVTransport->Initialize();
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_Notify_AddRef"
ULONG WINAPI IDirectPlayVoiceNotify_AddRef( LPDIRECTPLAYVOICENOTIFY This )
{
    LPDIRECTVOICENOTIFYOBJECT lpDVN = (LPDIRECTVOICENOTIFYOBJECT) This;
	lpDVN->lpDV->lpDVTransport->AddRef();
	return 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Notify_Release"
ULONG WINAPI IDirectPlayVoiceNotify_Release( LPDIRECTPLAYVOICENOTIFY This )
{
    LPDIRECTVOICENOTIFYOBJECT lpDVN = (LPDIRECTVOICENOTIFYOBJECT) This;
	lpDVN->lpDV->lpDVTransport->Release();	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

TARGETNAME=XVOICE$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=LIBRARY

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES= ..\inc;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\public\ddk\inc;\
    ..\..\inc;..\..\dxvutils;$(BASEDIR)\public\sdk\inc;\..\..\..\core;..\..\..\common;..\..\..\protocol;


SOURCES=..\dvcleng.cpp \
        ..\vplayer.cpp \
	..\dvengine.cpp \
	..\mixutils.cpp \
	..\dvclient.cpp \
	..\dvdxtran.cpp \
	..\dvrecsub.cpp \
	..\dvsereng.cpp \
	..\dvserver.cpp \
	..\dvshared.cpp \
	..\trnotify.cpp \
        ..\dvcreate.cpp\
	..\dvsndt.cpp \
	..\vnametbl.cpp\
        ..\frame.cpp\
        ..\inqueue2.cpp\
        ..\va.cpp\
        ..\sndutils.cpp


LINKLIBS = $(SDK_LIB_PATH)\voxcodec$(D).lib

#
# Next specify options for the compiler.
#

C_DEFINES= $(C_DEFINES) /DDIRECTSOUND_VERSION=0x0800

C_DEFINES = $(C_DEFINES) -DKERNEL_MODE 

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /FAcs

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DASSUME_VALID_PARAMETERS
!else
C_DEFINES=$(C_DEFINES) -DDEBUG
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Od
!endif

USER_C_FLAGS=-nologo $(USER_C_FLAGS)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\va.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva1.h
 *  Content:	Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	pnewson Created it
 *  09/01/2000 georgioc started port to xbox
 ***************************************************************************/

#ifndef _AGCVA1_H_
#define _AGCVA1_H_

#include "dvntos.h"

class CVoiceActivation1
{
protected:
	DWORD m_dwFlags;
	DWORD m_dwSensitivity;
	int m_iSampleRate;

	int m_iEnvelopeSampleRate;
	int m_iCurSampleNum;
	int m_iCurEnvelopeValueFast;
	int m_iCurEnvelopeValueSlow;
	int m_iPrevEnvelopeSample;
	int m_iHangoverSamples;
	int m_iCurHangoverSamples;
	int m_iShiftConstantFast;
	int m_iShiftConstantSlow;

	BYTE m_bPeak;

	BOOL m_fVoiceDetectedNow;
	BOOL m_fVoiceHangoverActive;
	BOOL m_fVoiceDetectedThisFrame;

	
   
public:

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'lcvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

	CVoiceActivation1() 
		: m_bPeak(0)
		, m_fVoiceDetectedThisFrame(FALSE)
		, m_fVoiceDetectedNow(FALSE)
		{};

	virtual ~CVoiceActivation1() {};
	
	virtual HRESULT Init(
		DWORD dwFlags, 
		int iSampleRate, 
		DWORD dwSensitivity);
	virtual HRESULT Deinit();
	virtual HRESULT SetSensitivity(DWORD dwFlags, DWORD dwSensitivity);
	virtual HRESULT GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity);
	virtual HRESULT AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize/*, DWORD dwFrameTime*/);
	virtual HRESULT VAResults(BOOL* pfVoiceDetected);
	virtual HRESULT PeakResults(BYTE* pbPeakValue);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\xboxfull\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\va.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva1.cpp
 *  Content:	Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	pnewson Created it
 *  01/14/2000	rodtoll	Plugged memory leak
 *  01/21/2000	pnewson	Fixed false detection at start of audio stream
 *  					Raised VA_LOW_ENVELOPE from (2<<8) to (3<<8)
 *  01/24/2000	pnewson	Fixed return code on Deinit
 *  01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 *  02/08/2000	rodtoll	Bug #131496 - Selecting DVSENSITIVITY_DEFAULT results in voice
 *						never being detected 
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/20/2000  rodtoll Bug #32889 - Unable to run on non-admin accounts on Win2k
 *  04/20/2000	pnewson Tune AGC algorithm to make it more agressive at 
 *						raising the recording volume.
 *  04/25/2000  pnewson Fix to improve responsiveness of AGC when volume level too low
 *  07/12/2000	rodtoll	Analyze Data needs optimization
 *
 ***************************************************************************/

/*

How this voice activation code works:

The idea is this. The power of the noise signal is pretty much constant over
time. The power of a voice signal varies considerably over time. The power of
a voice signal is not always high however. Weak frictive noises and such do not
generate much power, but since they are part of a stream of speech, they represent
a dip in the power, not a constant low power like the noise signal. We therefore 
associate changes in power with the presence of a voice signal.

If it works as expected, this will allow us to detect voice activity even
when the input volume, and therefore the total power of the signal, is very
low. This in turn will allow the auto gain control code to be more effective.

To estimate the power of the signal, we run the absolute value of the input signal
through a recursive digital low pass filter. This gives us the "envelope" signal.
[An alternative way to view this is a low frequency envelope signal modulated by a 
higher frequency carrier signal. We're extracting the low frequency envelope signal.]

*/


#include "dvntos.h"
#include "in_core.h"
#include <dvoicep.h>

#include "va.h"


// The following VA parameters were optimized for what I believe to be
// the hardest configuration: A cheap open stick mic with external speakers,
// with Echo Suppression turned on. Echo suppression penalizes false positives
// harshly, since the receiver cannot send which receiving the "noise". If 
// the VA parameters work for this case, then they should be fine for the 
// much better signal to noise ratio provided by a headset or collar mic.
// (As long as the user does not breathe directly on the headset mic.)
//
// Two source-to-mic distances were tested during tuning.
//
// 1) Across an enclosed office (approx 8 to 10 feet)
// 2) Seated at the workstation (approx 16 to 20 inches)
//
// At distance 1, the AGC was never invoked, gain was at 100%
// At distance 2, the AGC would take the mic down a few ticks.
//
// The office enviroment had the background noise from 3 computers,
// a ceiling vent, and a surprisingly noisy fan from the ethernet
// hub. There is no background talking, cars, trains, or things of
// that nature.
//
// Each parameter was tuned separately to reject 100% of the 
// background noise for case 1 (gain at 100%).
//
// Then they were tested together to see if they could detect
// across the room speech.
//
// Individually, none of the detection criteria could reliably
// detect all of the across the room speech. Together, they did
// not do much better. They even missed some speech while seated.
// Not very satifactory.
//
// Therefore, I decided to abandon the attempt to detect across
// the room speech. I retuned the parameters to reject noise 
// after speaking while seated (which allowed AGC to reduce
// the volume a couple of ticks, thereby increasing the signal
// to noise ratio) and to reliably detect seated speech.
//
// I also found that the "fast" envelope signal was better at
// detecting speech than the "slow" one in a straight threshold
// comparison, so it is used in the VA tests.
//

/// rodtoll
// Changing range so instead of 0 - 100 we have 0 - 128
// 
// The factor is the value we need to shift right by to get this division
// 
#define VA_MEASUREMENT_RANGE		128
#define VA_MEASUREMENT_RANGE_FACTOR	7

// VA_HIGH_PERCENT
//
// If the fast envelope signal is more than this percentage
// higher than the slow envelope signal, speech is detected.
//
// rodtoll : Modifying so that high and low values are factor of 2 values
//			 so that divisions can be removed.  Used 170 as reference point
//			 128 as the range.
//
#define VA_HIGH_PERCENT					218	

// Cannot have a factor because 218 cannot be factored by 2.
//
// #define VA_HIGH_PERCENT_FACTOR		

// Macro for doing x * VA_HIGH_PERCENT / VA_MEASUREMENT_RANGE
#define CALC_HIGH_PERCENT_RANGE(x)		((x*VA_HIGH_PERCENT)>>VA_MEASUREMENT_RANGE_FACTOR)
// #define VA_HIGH_PERCENT 170 // rejects most noise, still catches some.
							// decent voice detection. Catches the beginning
							// of speech a majority of the time, but does miss
							// once in a while. Will often drop out partway 
							// into a phrase when used alone. Must test in 
							// conjunction with VA_LOW_PERCENT.
							//
							// After testing in conjunction with VA_LOW_PERCENT,
							// the performance is reasonable. Low input volume
							// signals are usually detected ok, but dropouts are
							// a bit common. However, noise is sometimes still
							// detected, so making these parameters more sensitive
							// would not be useful.
//#define VA_HIGH_PERCENT 165 // catches occational noise
//#define VA_HIGH_PERCENT 160 // catches too much noise
//#define VA_HIGH_PERCENT 150 // catches most noise
//#define VA_HIGH_PERCENT 140 // catches almost all noise
//#define VA_HIGH_PERCENT 0x00007fff // select this to factor out this VA parameter

// VA_LOW_PERCENT
//
// If the fast envelope signal is more than this percentage
// lower than the slow envelope signal, speech is detected.
//
#define VA_LOW_PERCENT					64

// rodtoll -- Factor for shifting left instead of multiplying
#define VA_LOW_PERCENT_FACTOR			6

// Combination of shift left by low then right by VA_MEASUREMENT_RANGE_FACTOR, 
#define VA_LOW_PERCENT_RANGE_FACTOR		1

// Macro for doing x * VA_LOW_PERCENT / VA_MEASUREMENT_RANGE
#define CALC_LOW_PERCENT_RANGE(x)		(x>>VA_LOW_PERCENT_RANGE_FACTOR)

// Shift Right by 7

//#define VA_LOW_PERCENT 50 // excellent noise rejection. poor detection of speech.
						  // when used alone, could miss entire phrases. Must evaluate
						  // in conjunction with tuned VA_HIGH_PERCENT
						  //
						  // See note above re: testing in conjunction with VA_HIGH_PERCENT
//#define VA_LOW_PERCENT 55 // still catches too much noise
//#define VA_LOW_PERCENT 60 // catches most noise
//#define VA_LOW_PERCENT 65 // catches most noise
//#define VA_LOW_PERCENT 70 // still catches almost all noise
//#define VA_LOW_PERCENT 75 // catches almost all noise
//#define VA_LOW_PERCENT 80 // catches all noise
//#define VA_LOW_PERCENT 0 // select this to factor out this VA parameter

// VA_HIGH_ENVELOPE
//
// If the 16 bit normalized value of the envelope exceeds
// this number, the signal is considered voice.
//
//#define VA_HIGH_ENVELOPE (15 << 8) // still catches high gain noise, starting to get 
								   // speech dropouts, when "p" sounds lower the gain
//#define VA_HIGH_ENVELOPE (14 << 8) // Noise immunity good at "seated" S/N ratio. No speech
								   // dropouts encountered. Still catches noise at full gain.
//#define VA_HIGH_ENVELOPE (13 << 8) // Noise immunity not as good as expected (new day).
//#define VA_HIGH_ENVELOPE (12 << 8) // Good noise immunity. Speech recognition excellent.
								   // Only one dropout occured in the test with a 250ms
								   // hangover. I think the hangover time should be increased
								   // above 250 however, because a comma (properly read) tends 
								   // to cause a dropout. I'm going to tune the hangover time, 
								   // and return to this test.
								   //
								   // Hangover time is now 400ms. No dropouts occur with
								   // "seated" speech.
//#define VA_HIGH_ENVELOPE (11 << 8) // Catches almost no noise at "seated" gain
								   // however, if the gain creeped up a bit, noise would
								   // be detected. I therefore think a slightly higher 
								   // threshold would be a good idea. The speech recognition
								   // based on only this parameter at this level was flawless.
								   // No dropouts at all with a 250 ms hangover time. (commas
								   // excepted).
#define VA_HIGH_ENVELOPE (10 << 8) // catches some noise at "seated" gain - getting very close
//#define VA_HIGH_ENVELOPE (9 << 8) // catches some noise at "seated" gain - getting close
//#define VA_HIGH_ENVELOPE (8 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (7 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (0x7fffffff) // select this to factor out this VA parameter

// VA_LOW_ENVELOPE
//
// If the 16 bit normalized value of the envelope is below
// this number, the signal will never be considered voice.
// This reduces some false positives on the delta checks
// at very low signal levels
//#define VA_LOW_ENVELOPE (3 << 8)
//#define VA_LOW_ENVELOPE (2 << 8) // causes false VA at low input volumes
#define VA_LOW_ENVELOPE (1 << 8) // causes false VA at low input volumes

// VA_HANGOVER_TIME
//
// The time, in milliseconds, that voice activation sticks in
// the ON position following a voice detection. E.g. a value of 500
// means that voice will always be transmitted in at least 1/2 second
// bursts.
//
// I am trying to tune this so that a properly read comma will not cause
// a dropout. This will give the user a bit of leeway to pause in the
// speech stream without losing the floor when in Echo Suppression mode.
// It will also prevent dropouts even when not in Echo Suppression mode

#define VA_HANGOVER_TIME 500 // more forgiving

//#define VA_HANGOVER_TIME 400 // this gives satisfying performance
//#define VA_HANGOVER_TIME 375 // almost there, longest commas still goners
//#define VA_HANGOVER_TIME 350 // still drops long commas
//#define VA_HANGOVER_TIME 325 // does not drop fast commas, drops long ones
//#define VA_HANGOVER_TIME 300 // drops almost no commas, quite good
//#define VA_HANGOVER_TIME 275 // drops about half of the commas
//#define VA_HANGOVER_TIME 250 // commas are always dropped

// macros to avoid clib dependencies
#define DV_ABS(a) ((a) < 0 ? -(a) : (a))
#define DV_MAX(a, b) ((a) > (b) ? (a) : (b))
#define DV_MIN(a, b) ((a) < (b) ? (a) : (b))

// A function to lookup the log of n base 1.354 (sort of)
// where 0 <= n <= 127
//
// Why the heck do we care about log n base 1.354???
//
// What we need is a function that maps 0 to 127 down to 0 to 15
// in a nice, smooth non-linear fashion that has more fidelity at
// the low end than at the high end.
//
// The function is actually floor(log(n, 1.354), 1) to keep things
// in the integer realm.
//
// Why 1.354? Because log(128, 1.354) = 16, so we are using the full
// range from 0 to 15.
// 
// This function also cheats and just defines fn(0) = 0 and fn(1) = 1
// for convenience.
BYTE DV_LOG_1_354_lookup_table[95] = 
{
	 0,  1,  2,  3,  4,  5,  5,  6,	//   0..  7
	 6,  7,  7,  7,  8,  8,  8,  8, //   8.. 15
	 9,  9,  9,  9,  9, 10, 10, 10, //  16.. 23
	10, 10, 10, 10, 10, 11, 11, 11,	//  24.. 31
	11, 11, 11, 11, 11, 11, 12, 12, //  32.. 39
	12, 12, 12, 12, 12, 12, 12, 12, //  40.. 47
	12, 12, 12, 12, 13, 13, 13, 13, //  48.. 55
	13, 13, 13, 13, 13, 13, 13, 13, //  56.. 63
	13, 13, 13, 13, 13, 13, 14, 14, //  64.. 71
	14, 14, 14, 14, 14, 14, 14, 14, //  72.. 79
	14, 14, 14, 14, 14, 14, 14, 14, //  80.. 87
	14, 14, 14, 14, 14, 14, 14		//  88.. 94 - stop table at 94 here, everything above is 15
};

BYTE DV_log_1_354(BYTE n)
{
	if (n > 94) return 15;
	return DV_LOG_1_354_lookup_table[n];
}

// function to lookup the base 2 log of (n) where n is 16 bits unsigned
// except that we cheat and say that log_2 of zero is zero
// and we chop of any decimals.
BYTE DV_log_2(WORD n)
{
	if (n & 0x8000)
	{
		return 0x0f;
	}
	if (n & 0x4000)
	{
		return 0x0e;
	}
	if (n & 0x2000)
	{
		return 0x0d;
	}
	if (n & 0x1000)
	{
		return 0x0c;
	}
	if (n & 0x0800)
	{
		return 0x0b;
	}
	if (n & 0x0400)
	{
		return 0x0a;
	}
	if (n & 0x0200)
	{
		return 0x09;
	}
	if (n & 0x0100)
	{
		return 0x08;
	}
	if (n & 0x0080)
	{
		return 0x07;
	}
	if (n & 0x0040)
	{
		return 0x06;
	}
	if (n & 0x0020)
	{
		return 0x05;
	}
	if (n & 0x0010)
	{
		return 0x04;
	}
	if (n & 0x0008)
	{
		return 0x03;
	}
	if (n & 0x0004)
	{
		return 0x02;
	}
	if (n & 0x0002)
	{
		return 0x01;
	}
	return 0x00;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::Init"
//
// Init - initializes the AGC and VA algorithms, including loading saved
// values from registry.
//
// dwFlags - the dwFlags from the dvClientConfig structure
// guidCaptureDevice - the capture device we're performing AGC for
// plInitVolume - the initial volume level is written here
//
HRESULT CVoiceActivation1::Init(
	DWORD dwFlags, 
	int iSampleRate,
	DWORD dwSensitivity)
{

	// Remember the flags
	m_dwFlags = dwFlags;

	// Remember the sensitivity
	m_dwSensitivity = dwSensitivity;

	// Figure out the shift constants for this sample rate
	m_iShiftConstantFast = (DV_log_2((iSampleRate * 2) / 1000) + 1);

	// This gives the slow filter a cutoff frequency 1/4 of 
	// the fast filter
	m_iShiftConstantSlow = m_iShiftConstantFast + 2;

	// Start the envelope signal at zero
	m_iCurEnvelopeValueFast = 0;
	m_iCurEnvelopeValueSlow = 0;
	m_iPrevEnvelopeSample = 0;
	m_iCurSampleNum = 0;

	// We're not clipping now
	//m_fClipping = 0;
	//m_iClippingCount = 0;

	DPVF(DPVF_INFOLEVEL, "AGCVA1:INIT:%i,%i,%i,%i", 
		iSampleRate,
		m_iShiftConstantFast,
		m_iShiftConstantSlow);
	
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::Deinit"
//
// Deinit - saves the current AGC and VA state to the registry for use next session
//
HRESULT CVoiceActivation1::Deinit()
{
	HRESULT hr = DV_OK;

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::SetSensitivity"
HRESULT CVoiceActivation1::SetSensitivity(DWORD dwFlags, DWORD dwSensitivity)
{
	if (dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED)
	{
		m_dwFlags |= DVCLIENTCONFIG_AUTOVOICEACTIVATED;
	}
	else
	{
		m_dwFlags &= ~DVCLIENTCONFIG_AUTOVOICEACTIVATED;
	}
	m_dwSensitivity = dwSensitivity;
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::GetSensitivity"
HRESULT CVoiceActivation1::GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity)
{
	*pdwSensitivity = m_dwSensitivity;
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::AnalyzeData"
//
// AnaylzeData - performs the AGC & VA calculations on one frame of audio
//
// pbAudioData - pointer to a buffer containing the audio data
// dwAudioDataSize - size, in bytes, of the audio data
//
HRESULT CVoiceActivation1::AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize /*, DWORD dwFrameTime*/)
{
	int iMaxValue;
	//int iValue;
	int iValueAbs;
	//int iZeroCrossings;
	int iIndex;
	int iMaxPossiblePeak;
	int iNumberOfSamples;
	//BYTE bPeak255;

	//m_dwFrameTime = dwFrameTime;

	if (dwAudioDataSize < 1)
	{
		DPVF(DPVF_ERRORLEVEL, "Error: Audio Data Size < 1");
		return DVERR_INVALIDPARAM;
	}

	// new algorithm...

	// cast the audio data to signed 16 bit integers
	signed short* psiAudioData = (signed short *)pbAudioData;

    // 16 bits per sample assumed!!
	iNumberOfSamples = dwAudioDataSize / 2;

    //
    // BUGBUG the hawk certainly regulates the volume so the max value is never above 600
    // we got to figure this out tho
    //

	iMaxPossiblePeak = 500;
	

	m_fVoiceDetectedThisFrame = FALSE;
	iMaxValue = 0;
	for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)
	{
		++m_iCurSampleNum;

        iValueAbs = DV_ABS((int)psiAudioData[iIndex]);

		// see if it is the new peak value
		iMaxValue = DV_MAX(iValueAbs, iMaxValue);

		// do the low pass filtering, but only if we are in autosensitivity mode
		int iNormalizedCurEnvelopeValueFast;
		int iNormalizedCurEnvelopeValueSlow;
		if (m_dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED)
		{
			m_iCurEnvelopeValueFast = 
				iValueAbs + 
				(m_iCurEnvelopeValueFast - (m_iCurEnvelopeValueFast >> m_iShiftConstantFast));
			iNormalizedCurEnvelopeValueFast = m_iCurEnvelopeValueFast >> m_iShiftConstantFast;

			m_iCurEnvelopeValueSlow = 
				iValueAbs + 
				(m_iCurEnvelopeValueSlow - (m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow));
			iNormalizedCurEnvelopeValueSlow = m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow;

			// check to see if we consider this voice
			if (iNormalizedCurEnvelopeValueFast > VA_LOW_ENVELOPE &&
				(iNormalizedCurEnvelopeValueFast > VA_HIGH_ENVELOPE ||
				CALC_HIGH_PERCENT_RANGE( iNormalizedCurEnvelopeValueSlow ) ||
				CALC_LOW_PERCENT_RANGE( iNormalizedCurEnvelopeValueSlow ) ) )
			{
				m_fVoiceDetectedNow = TRUE;
				m_fVoiceDetectedThisFrame = TRUE;
				m_fVoiceHangoverActive = TRUE;
				m_iCurHangoverSamples = 0;
			}
			else
			{
				m_fVoiceDetectedNow = FALSE;
				++m_iCurHangoverSamples;
				if (m_iCurHangoverSamples > m_iHangoverSamples)
				{
					m_fVoiceHangoverActive = FALSE;
				}
				else
				{
					m_fVoiceHangoverActive = TRUE;
					m_fVoiceDetectedThisFrame = TRUE;

                    DPVF(DPVF_INFOLEVEL, "VA1:ANA, VOiceDetected %i,%i", 
                         m_bPeak,
                         iMaxValue);

				}
			}
		}
	}

	// Normalize the peak value to the range DVINPUTLEVEL_MIN to DVINPUTLEVEL_MAX
	// This is what is returned for caller's peak meters...
	m_bPeak = (BYTE)(DVINPUTLEVEL_MIN + 
		((iMaxValue * (DVINPUTLEVEL_MAX - DVINPUTLEVEL_MIN)) / iMaxPossiblePeak));

	// if we are in manual VA mode (not autovolume) check the peak against
	// the sensitivity threshold
	if (!(m_dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED))
	{
		if (m_bPeak > m_dwSensitivity)
		{
			m_fVoiceDetectedThisFrame = TRUE;
            DPVF(DPVF_INFOLEVEL, "VA1:ANA, VOiceDetetced %i,%i", 
                 m_bPeak,
                 iMaxValue);

		}
	}

    //
    // BUGBUG add a ahck that will not allow buffers with saturated volumes
    // to be send as voice. Until we figure why hawk does this..
    //

    if (m_bPeak == 240) {

        m_fVoiceDetectedThisFrame = FALSE;
        m_fVoiceDetectedNow = FALSE;
        m_fVoiceHangoverActive = FALSE;

    }

	DPVF(DPVF_SPAMLEVEL, "VA1:ANA,%i,%i,%i", 
		m_bPeak,
		iMaxValue,
		m_fVoiceDetectedThisFrame);
	
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::VAResults"
//
// VAResults - returns the VA results from the previous AnalyzeFrame call
//
// pfVoiceDetected - stuffed with TRUE if voice was detected in the data, FALSE otherwise
//
HRESULT CVoiceActivation1::VAResults(BOOL* pfVoiceDetected)
{
	if (pfVoiceDetected != NULL)
	{
		*pfVoiceDetected = m_fVoiceDetectedThisFrame;
	}
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceActivation1::PeakResults"
//
// PeakResults - returns the peak sample value from the previous AnalyzeFrame call,
// 				 normalized to the range 0 to 99
//
// pfPeakValue - pointer to a byte where the peak value is written
//
HRESULT CVoiceActivation1::PeakResults(BYTE* pbPeakValue)
{
	DPVF(DPVF_SPAMLEVEL, "VA1: peak value: %i" , m_bPeak);
	*pbPeakValue = m_bPeak;
	return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\vnametbl.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vnametbl.h
 *  Content:	Voice Name Table Routines
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/26/00  rodtoll    Created
 *  09/01/2000 georgioc started rewrite/port to xbox
 ***************************************************************************/

#ifndef __NAMETABLE_H
#define __NAMETABLE_H

#include "dvoicep.h"
#include "vplayer.h"
#include "in_core.h"

#define VSIG_VOICENAMETABLE			'BTNV'
#define VSIG_VOICENAMETABLE_FREE	'BTN_'

volatile class CVoiceNameTable
{
public:
	CVoiceNameTable( )
	{
		m_fInitialized = FALSE;
	};
	
	~CVoiceNameTable()
	{
		DeInitialize(FALSE, NULL, NULL);
	}

    HRESULT Initialize();
	HRESULT DeInitialize(BOOL fUnRavel, PVOID pvContext, LPDVMESSAGEHANDLER pvMessageHandler);
	DWORD GetLowestHostOrderID(DVID *pdvidHost);

    BOOL IsEntry( const DVID dvidID );
    HRESULT GetEntry( const DVID dvidID, CVoicePlayer **ppEntry, BOOL fAddReference );
    HRESULT DeleteEntry( const DVID dvidID );
    HRESULT AddEntry( const DVID dvidID, CVoicePlayer *pEntry );

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'btnv');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

protected:

	LIST_ENTRY	                    m_NameTableList;
	BOOL							m_fInitialized;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\vnametbl.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vnametbl.h
 *  Content:    Voice Player Name Table
 *              
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/26/00    rodtoll Created
 *  06/02/00    rodtoll  Updated so host migration algorithm returns ID as well as order ID 
 *  07/01/2000  rodtoll Bug #38280 - DVMSGID_DELETEVOICEPLAYER messages are being sent in non-peer to peer sessions
 *                      Nametable will now only unravel with messages if session is peer to peer.
 *  07/09/2000  rodtoll Added signature bytes 
 ***************************************************************************/

#include "dvntos.h"
#include "in_core.h"
#include <dvoicep.h>
#include "dvprot.h"
#include "vplayer.h"
#include "sndutils.h"
#include "vnametbl.h"

#undef DPF_FNAME
#define DPF_FNAME "CVoiceNameTable::Initialize"

HRESULT CVoiceNameTable::Initialize()
{
    BOOL fResult;
    ULONG i;
    HRESULT hr;

    InitializeListHead(&m_NameTableList);

    m_fInitialized = TRUE;

    return DV_OK;
};

// DeInitialize
//
// Cleanup the name table
HRESULT CVoiceNameTable::DeInitialize(BOOL fUnRavel, PVOID pvContext, LPDVMESSAGEHANDLER pvMessageHandler )
{
    CVoicePlayer *pPlayer;
    DVID dvID;
    PVOID pvPlayerContext;
    DVMSG_DELETEVOICEPLAYER dvMsgDelete;
    KIRQL irql;
    PLIST_ENTRY pEntry;

    if( !m_fInitialized )
        return DV_OK;

    RIRQL(irql);

    if (IsListEmpty(&m_NameTableList)) {
        LIRQL(irql);
        return DV_OK;
    }

    pEntry = m_NameTableList.Flink;

    while (pEntry != &m_NameTableList) {

        pPlayer = (CVoicePlayer *) CONTAINING_RECORD(pEntry, CVoicePlayer, m_PoolEntry);

        //
        // Mark it as disconnected
        //

        pPlayer->SetDisconnected();

        dvID = pPlayer->GetPlayerID();
        pvPlayerContext = pPlayer->GetContext();

        if( pvMessageHandler != NULL )
        {
            if( fUnRavel )
            {
                //
                // Drop locks to call up to user
                //

                LIRQL(irql);                    

                dvMsgDelete.dvidPlayer = dvID;
                dvMsgDelete.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
                dvMsgDelete.pvPlayerContext = pvPlayerContext;

                (*pvMessageHandler)( pvContext, DVMSGID_DELETEVOICEPLAYER, &dvMsgDelete );
           
                RIRQL(irql);
            }
        }

        //
        // remove player from this first, because release will stick it in the pool
        //

        RemoveEntryList(&pPlayer->m_PoolEntry);

        //
        // Release the player record reference we had
        //

        LIRQL(irql);
        pPlayer->Release();
        RIRQL(irql);

        pEntry = m_NameTableList.Flink;
    }

    LIRQL(irql);    

    m_fInitialized = FALSE;

    return DV_OK;
}

DWORD CVoiceNameTable::GetLowestHostOrderID(DVID *pdvidHost)
{
    DWORD dwLowestID = DVPROTOCOL_HOSTORDER_INVALID;
    KIRQL irql;
    CVoicePlayer *pPlayer;
    PLIST_ENTRY pEntry;
    
    RIRQL(irql);

    pEntry = m_NameTableList.Flink;

    while ( pEntry != &m_NameTableList)
    {
        pPlayer = (CVoicePlayer *) CONTAINING_RECORD(pEntry, CVoicePlayer, m_PoolEntry);

        DPVF(DPVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: ID [0x%x] ORDERID [0x%x]", 
             pPlayer->GetPlayerID(),
             pPlayer->GetHostOrder() );

        if( pPlayer->GetPlayerID() < dwLowestID )
        {
            DPVF( DPVF_HOSTMIGRATE_DEBUG_LEVEL,
                  "HOST MIGRATION: ID [0x%x] IS CURRENT CANDIDATE",
                  pPlayer->GetPlayerID() );

            dwLowestID = pPlayer->GetHostOrder();

            *pdvidHost = pPlayer->GetPlayerID();
        }

        pEntry = pEntry->Flink;
    }

    LIRQL(irql);

    return dwLowestID;
}


BOOL CVoiceNameTable::IsEntry( const DVID dvidID )
{
    CVoicePlayer *pEntry;

    if (GetEntry(dvidID,&pEntry,FALSE) != DV_OK) {
        return FALSE;
    } else {
        return TRUE;
    }
}

HRESULT CVoiceNameTable::GetEntry( const DVID dvidID, CVoicePlayer **ppEntry, BOOL fAddReference )
{
    BOOL fFound = FALSE;
    KIRQL irql;
    CVoicePlayer *pPlayer;
    PLIST_ENTRY pEntry;    

    RIRQL(irql);

    if (IsListEmpty(&m_NameTableList)) {

        *ppEntry = NULL;
        LIRQL(irql);
        return DVERR_INVALIDPLAYER;

    }

    pEntry = m_NameTableList.Flink;

    while ( pEntry != &m_NameTableList)
    {
        pPlayer = (CVoicePlayer *) CONTAINING_RECORD(pEntry, CVoicePlayer, m_PoolEntry);

        if( pPlayer->GetPlayerID() == dvidID )
        {
            *ppEntry = pPlayer;
            fFound = TRUE;

        }

        pEntry = pEntry->Flink;
    }

    LIRQL(irql);

    if( !fFound )
    {
        *ppEntry = NULL;
        LIRQL(irql);
        return DVERR_INVALIDPLAYER;
    }

    ASSERT( *ppEntry != NULL );

    if( fAddReference )
    {
        (*ppEntry)->AddRef();
    }

    LIRQL(irql)

    return DV_OK;
}

HRESULT CVoiceNameTable::AddEntry( const DVID dvidID, CVoicePlayer *pEntry )
{
    HRESULT hr;
    CVoicePlayer *pTmpEntry;
    KIRQL irql;

    hr = GetEntry( dvidID, &pTmpEntry, FALSE);

    if(SUCCEEDED(hr))
    {
        return DVERR_GENERIC;
    }

    pEntry->AddRef();

    RIRQL(irql);

    InsertTailList(&m_NameTableList,&pEntry->m_PoolEntry);

    LIRQL(irql);

    return DV_OK;
}

HRESULT CVoiceNameTable::DeleteEntry( const DVID dvidID )
{
    BOOL fFound;
    CVoicePlayer *pTmpEntry;
    KIRQL irql;
    HRESULT hr;

    hr = GetEntry( dvidID, &pTmpEntry, FALSE);

    if(FAILED(hr))
    {
        return hr;
    }

    pTmpEntry->Release();

    RIRQL(irql);

    RemoveEntryList(&pTmpEntry->m_PoolEntry);

    LIRQL(irql);

    return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\vplayer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vplayer.h
 *  Content:    Voice Player Entry
 *              
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/26/00    rodtoll Created
 * 09/01/2000  georgioc started rewrite for xbox 
 ***************************************************************************/

#include "vplayer.h"
#include "dvprot.h"
#include "in_core.h"
#include "sndutils.h"
#include "Dvengine.h"

//
// BUGBUG use dsound eventually
//

#define DV_USE_HAWK_HEADPHONE 1

CVoicePlayer::CVoicePlayer()
{

    Reset();
}

CVoicePlayer::~CVoicePlayer()
{
    if( IsInitialized() )
        DeInitialize();

}

void CVoicePlayer::Reset()
{
    m_dwFlags = 0;
    m_dvidPlayer = 0;
    m_lRefCount = 0;
    m_pInBoundAudioConverter = NULL;
    m_lpInputQueue = NULL;
    m_dwLastData = 0;
    m_dwHostOrderID = 0xFFFFFFFF;
    m_bLastPeak = 0;
    m_dwLastPlayback = 0;
    m_dwNumSilentFrames = 0;
    m_dwTransportFlags = 0;
    m_dwNumLostFrames = 0;
    m_dwNumSpeechFrames = 0;
    m_dwNumReceivedFrames = 0;
    m_pvPlayerContext = NULL;
    m_dwNumTargets = 0;
    m_pdvidTargets = NULL;
    m_pPlaybackMediaObject = NULL;
    m_pSoundTarget = NULL;
    m_pMediaPacketBuffer = NULL;

    InitializeListHead(&m_AvailableList);
    InitializeListHead(&m_PendingList);
    InitializeCriticalSection(&m_CS);

}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::SetPlayerTargets"
//
// Assumes the array has been checked for validity
// 
HRESULT CVoicePlayer::SetPlayerTargets( PDVID pdvidTargets, DWORD dwNumTargets )
{
    DV_AUTO_LOCK(&m_CS);

    delete [] m_pdvidTargets;

    if( dwNumTargets == 0 )
    {
        m_pdvidTargets = NULL;
    }
    else
    {
        m_pdvidTargets = new DVID[dwNumTargets];

        if( m_pdvidTargets == NULL )
        {
            m_pdvidTargets = NULL;
            m_dwNumTargets = 0;
            DPVF( DPVF_ERRORLEVEL, "Error allocating memory" );
            return DVERR_OUTOFMEMORY;
        }

        memcpy( m_pdvidTargets, pdvidTargets, sizeof(DVID)*dwNumTargets );
    }

    m_dwNumTargets = dwNumTargets;
    
    return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::Initialize"

HRESULT CVoicePlayer::Initialize(
    const DVID dvidPlayer,
    const DWORD dwHostOrder,
    const DWORD dwPortNumber,
    DWORD dwFlags,
    PVOID pvContext, 
    PLIST_ENTRY pOwner) 
{

    DV_AUTO_LOCK(&m_CS);

    m_lRefCount = 1;
    m_pOwner = pOwner;
    m_dvidPlayer = dvidPlayer;
    m_dwHostOrderID = dwHostOrder;
    m_dwLastData = GetTickCount();
    m_dwLastPlayback = 0;
    m_dwTransportFlags = dwFlags;
    m_pvPlayerContext = pvContext;

    ASSERT(dwPortNumber <= 255);
    m_bPortNumber = (UCHAR)dwPortNumber;

    m_dwFlags |= VOICEPLAYER_FLAGS_INITIALIZED;

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::CreateSoundTarget"

HRESULT CVoicePlayer::CreateSoundTarget(CSoundTarget **ppSoundTarget)
{
    HRESULT hr;

    DPVF_ENTER();

    ASSERT(ppSoundTarget);

    DV_AUTO_LOCK(&m_CS);
    if (m_pSoundTarget) {
        return DVERR_ALREADYBUFFERED;
    }

    m_pSoundTarget = new CSoundTarget();

    hr = m_pSoundTarget->Initialize(m_dwUnCompressedFrameSize);
    if (FAILED(hr)) {

        return hr;
    }

    *ppSoundTarget = m_pSoundTarget;


    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::DeleteSoundTarget"

void CVoicePlayer::DeleteSoundTarget()
{
    HRESULT hr;

    DV_AUTO_LOCK(&m_CS);
    m_pSoundTarget = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::CreateQueue"

HRESULT CVoicePlayer::CreateQueue( PQUEUE_PARAMS pQueueParams )
{
    HRESULT hr;
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();

    m_lpInputQueue = new CInputQueue2();
    
    if( m_lpInputQueue == NULL )
    {
        DPVF( 0, "Error allocating memory" );
        return DVERR_OUTOFMEMORY;
    }
    
    hr = m_lpInputQueue->Initialize( pQueueParams );

    if( FAILED( hr ) )
    {
        DPVF(0, "Failed initializing queue hr=0x%x", hr );
        delete m_lpInputQueue;
        m_lpInputQueue = NULL;

        return hr;
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::CreateMediaObjects"

HRESULT CVoicePlayer::CreateMediaObjects(
    const GUID &guidCT,
    PWAVEFORMATEX pwfxTargetFormat,
    DWORD dwUncompressedFrameSize,
    XMediaObject *pConverter,
    BOOLEAN fUseMcpx
    )
{
    HRESULT hr;
    DPVF_ENTER();

    //
    // create decompressor
    //

    if (pConverter == NULL) {

        hr = DV_CreateConverter(guidCT,
                                &m_pInBoundAudioConverter,
                                pwfxTargetFormat,
                                NULL,
                                dwUncompressedFrameSize,
                                FALSE);
    
        if( FAILED( hr ) )
        {
            DPVF( 0, "Error creating audio converter hr=0x%x" , hr );
            return hr;
        }

    } else {

        m_pInBoundAudioConverter = pConverter;
        hr = NOERROR;
    }

    m_dwUnCompressedFrameSize = dwUncompressedFrameSize;

    //
    // instantiate our playback XMO. By default this is the voice peripheral's headphone
    //

    hr = SwitchInternalAudioTarget(pwfxTargetFormat,fUseMcpx, FALSE);
    return hr;
}

HRESULT CVoicePlayer::DeInitialize()
{
    KIRQL irql;
    FreeResources();

    RIRQL(irql);
    InsertHeadList(m_pOwner,&m_PoolEntry);
    LIRQL(irql);

    return DV_OK;
}


HRESULT CVoicePlayer::SwitchInternalAudioTarget(
    PWAVEFORMATEX pwfxTargetFormat,
    BOOL fUseMcpx,
    BOOL fMute
    )
{

    HRESULT hr = S_OK;
    LPDSSTREAMDESC pDsStreamDesc;

#ifdef SILVER

    DWORD deviceId;

#endif // SILVER

    XMEDIAINFO xmi;

    ULONG i;
    DVMEDIAPACKET *pBuffer;


    if( m_pPlaybackMediaObject != NULL )
    {

        ASSERT(m_pPlaybackMediaObject->Release() == 0);
        m_pPlaybackMediaObject = NULL;

        DV_FreeMediaPacketPool(&m_PendingList,TRUE);
        DV_FreeMediaPacketPool(&m_AvailableList,TRUE);

        if (m_pMediaPacketBuffer) {
    
            DV_POOL_FREE(m_pMediaPacketBuffer);
            m_pMediaPacketBuffer = NULL;
    
        }

    }

    if (fMute) {

        //
        // do not create any playback object
        // they dont want us to send any data for playback
        //


        return S_OK;

    }

    if (fUseMcpx) {

        //
        // switch from hawk to mcpx
        //


#ifdef SILVER

        deviceId = DSDEVID_MCPX;

#endif // SILVER

    } else {

#ifdef SILVER

        deviceId = DSDEVID_VOICE(m_bPortNumber);

#endif // SILVER

#if DV_USE_VOICE_HEADPHONE
        //
        // hawk output
        //
    
        hr = XVoiceCreateMediaObjectInternal(
            XDEVICE_TYPE_VOICE_HEADPHONE,
            m_bPortNumber,
            DV_CT_FRAMES_PER_PERIOD,
            pwfxTargetFormat,
            DV_VoicePlayerPlaybackPacketCompletion,
            this,
            &m_pPlaybackMediaObject);
    
        if (FAILED(hr)) {
            DPVF( DPVF_ERRORLEVEL, "Could not instatiate hawk XMO!" );
            DPVF_EXIT();
    
            return hr;
        }
#endif

    }

    pDsStreamDesc =(LPDSSTREAMDESC) DV_POOL_ALLOC(sizeof(DSSTREAMDESC));
    ASSERT(pDsStreamDesc);

    memset(pDsStreamDesc, 0, sizeof(DSSTREAMDESC));

#ifdef SILVER

    pDsStreamDesc->dwSize = sizeof(DSSTREAMDESC);

#endif // SIVER

    pDsStreamDesc->lpwfxFormat = pwfxTargetFormat;
    pDsStreamDesc->dwMaxAttachedPackets = DV_CT_FRAMES_PER_PERIOD;
    pDsStreamDesc->lpfnCallback = DV_VoicePlayerPlaybackPacketCompletion;
    pDsStreamDesc->lpvContext = this;

#ifdef SILVER

    hr = DirectSoundCreateStream(deviceId, pDsStreamDesc, (LPDIRECTSOUNDSTREAM *)&m_pPlaybackMediaObject, NULL);

#else // SILVER

    hr = DirectSoundCreateStream(pDsStreamDesc, (LPDIRECTSOUNDSTREAM *)&m_pPlaybackMediaObject);

#endif // SILVER

    if (FAILED(hr)) {

        DPVF(DPVF_ERRORLEVEL,"DirectSoundCreateStream for mcpx!!!");
        ASSERT(FALSE);
        return hr;

    }

    DV_POOL_FREE(pDsStreamDesc);


#if DBG

    //
    // get the minimum input requirements for the playback XMO
    //

    memset(&xmi,0,sizeof(xmi));

    xmi.dwInputSize = 1;
    hr = m_pPlaybackMediaObject->GetInfo(&xmi);

    ASSERT(!FAILED(hr));

    //
    // make sure decompressed frames are integer multiples
    //

    if (xmi.dwFlags & XMO_STREAMF_FIXED_PACKET_ALIGNMENT) {
        ASSERT((m_dwUnCompressedFrameSize%xmi.dwInputSize) == 0);
    }

#endif

    //
    // init our pool of media buffers
    //
    
    InitializeListHead(&m_AvailableList);    

    hr =DV_InitializeList(&m_AvailableList,
                          DV_CT_FRAMES_PER_PERIOD,
                          sizeof(DVMEDIAPACKET),
                          DVLAT_RAW);

    //
    // save the single pool allocation done for this list
    //

    m_pMediaPacketBuffer = m_AvailableList.Flink;


    ASSERT(SUCCEEDED(hr));
    hr = DV_InitMediaPacketPool(&m_AvailableList,m_dwUnCompressedFrameSize, TRUE);

    ASSERT(SUCCEEDED(hr));

    return hr;

}


#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::HandleReceive"

HRESULT CVoicePlayer::HandleReceive( PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize )
{
    CFrame tmpFrame;
    DV_AUTO_LOCK(&m_CS);

    DPVF_ENTER();

    tmpFrame.SetSeqNum( pdvSpeechHeader->bSeqNum );
    tmpFrame.SetMsgNum( pdvSpeechHeader->bMsgNum );
    tmpFrame.SetIsSilence( FALSE );
    tmpFrame.SetFrameLength( (WORD)dwSize );
    tmpFrame.UserOwn_SetData( pbData, dwSize );

    DPVF( DPVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Receive: Msg [%d] Seq [%d]", pdvSpeechHeader->bMsgNum, pdvSpeechHeader->bSeqNum );       

    // STATSBLOCK: Begin
    //m_stats.m_dwPRESpeech++;
    // STATSBLOCK: End
        
    if (m_lpInputQueue->Enqueue( tmpFrame )) {

        m_dwLastData = GetTickCount();
        DPVF( DPVF_INFOLEVEL, "Received speech is buffered!" );
        m_dwNumReceivedFrames++;

    } else {

        DPVF( DPVF_ERRORLEVEL, "Received speech could not be queued!!!!" );

    }

    return DV_OK;
}

CFrame *CVoicePlayer::Dequeue()
{
    CFrame *frTmpFrame;     
    frTmpFrame = m_lpInputQueue->Dequeue(); 

    return frTmpFrame;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::DecompressInbound"

HRESULT CVoicePlayer::DeCompressInBound(PDVMEDIAPACKET pBuffer)
{
    HRESULT hr;
    CFrame *pCurrentFrame = (CFrame *)pBuffer->pvReserved;
    XMEDIAPACKET xmp;
    DWORD dwResultSize;

    DPVF( DPVF_INFOLEVEL, "Decompressing packet %x",pBuffer );

    //
    // prepare input buffer
    //

    xmp.dwMaxSize = pCurrentFrame->GetFrameLength();
    xmp.pdwStatus = NULL;
    xmp.pdwCompletedSize = NULL;
    xmp.pvBuffer = pCurrentFrame->GetDataPointer();

    if (pCurrentFrame->GetIsSilence()) {

        //
        // assume 16 bit pcm. pre init with silence
        //

        memset( pBuffer->xmp.pvBuffer,0x00, pBuffer->dwCompletedSize );

    }

    hr = m_pInBoundAudioConverter->Process(&xmp,
                                           &pBuffer->xmp);

    if( FAILED( hr ) )
    {
        DPVF( 0, "Failed converting audio hr=0x%x", hr );
        return hr;
    }

    ASSERT(pBuffer->dwCompletedSize == m_dwUnCompressedFrameSize);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::GetNextFrameAndDecompress"

HRESULT CVoicePlayer::GetNextFrameAndDecompress(PDWORD pdwReturnFlags, DWORD *pdwSeqNum, DWORD *pdwMsgNum )
{    
    BYTE bLastPeak;
    HRESULT hr;
    PDVMEDIAPACKET pBuffer;

    DV_AUTO_LOCK(&m_CS);
    CFrame *frTmpFrame;

    //
    // dequeue frame
    //

    frTmpFrame = Dequeue();
   
    if( frTmpFrame->GetIsLost() )
    {
        *pdwReturnFlags |= DV_FRAMEF_IS_LOST;
        m_dwNumLostFrames++;

        frTmpFrame->Return();

        return DV_OK;
    }

    //
    // get media buffer
    //

    pBuffer = (PDVMEDIAPACKET)DV_REMOVE_TAIL(&m_AvailableList);
    if (!pBuffer) {

        frTmpFrame->Return();
        return DV_OK;

    }

    pBuffer->pvReserved = (PVOID)frTmpFrame;


    //
    // if we have received no frames, an attempt to dequeue will produce a
    // a silent frame. In that case we bail..
    //

    if( !frTmpFrame->GetIsSilence() )
    {
        m_dwLastPlayback = GetTickCount();
        m_dwNumSpeechFrames++;
        m_bLastPeak = FindPeak( (PBYTE) pBuffer->xmp.pvBuffer, m_dwUnCompressedFrameSize, FALSE );
    }
    else
    {
        m_dwNumSilentFrames++;
        *pdwReturnFlags |= DV_FRAMEF_IS_SILENCE;
        m_bLastPeak = 0;

        //
        // return frame and buffer and bail
        //

        DV_INSERT_TAIL(&m_AvailableList,pBuffer);
        frTmpFrame->Return();
        return DV_OK;

    }

    *pdwSeqNum = frTmpFrame->GetSeqNum();
    *pdwMsgNum = frTmpFrame->GetMsgNum();

    // If the frame was not silence, decompress it and then 
    // mix it into the mixer buffer
    DPVF(  DPVF_INFOLEVEL, "Player: 0x%x getting frame.. it's speech", GetPlayerID() );

    hr = DeCompressInBound(pBuffer);

    if( FAILED( hr ) )
    {
        frTmpFrame->Return();

        DV_INSERT_TAIL(&m_AvailableList,pBuffer);

        DPVF( 0, "Failed converting audio hr=0x%x", hr );
        return hr;
    }

    *pdwReturnFlags = 0;

    //
    // if the current player has a Sound Target, send it this data..
    //

    if( m_pSoundTarget !=NULL )
    {
        hr = m_pSoundTarget->MixInSingle((PUCHAR)pBuffer->xmp.pvBuffer);

        frTmpFrame->Return();
        DV_INSERT_TAIL(&m_AvailableList,pBuffer);

        return hr;

    } else {

        if (m_pPlaybackMediaObject) {

            //
            // add this media buffer on our pending pool
            //
    
            DV_INSERT_TAIL(&m_PendingList,pBuffer);
    
            //
            // If we didn't mix into any user created buffers, then
            // submit this packet to the dsound xmo
            //
                        
            hr = m_pPlaybackMediaObject->Process( 
                     &pBuffer->xmp, //pBuffer
                     NULL);
            
            if( FAILED( hr ) )
            {
                DPVF( DPVF_ERRORLEVEL, "Unable to ProcessIn frame." );
                return hr;
            }

        } else {

            //
            // no playback, return frame
            //

            frTmpFrame->Return();

        }

    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_PlaybackPacketCompletion"

VOID DV_VoicePlayerPlaybackPacketCompletion(PVOID pThis, PVOID pContext2, DWORD dwStatus)
{
    PDVMEDIAPACKET pPacket = (PDVMEDIAPACKET)pContext2;
    CVoicePlayer *This = (CVoicePlayer *) pThis;

    //
    // check previous buffer completions.
    //

    DPVF(DPVF_INFOLEVEL, "PlaybackPacketCOmpletion:Voice player(%x) playback packet (%x) done.",
        pThis,
        pContext2);

    //
    // return frame to frame queue
    //

    ((CFrame *)pPacket->pvReserved)->Return();

    //
    // remove context from pending pool
    //

    DV_REMOVE_ENTRY(pPacket);
    DV_INSERT_TAIL(&This->m_AvailableList,pPacket);

}

void CVoicePlayer::FreeResources()
{

    DV_AUTO_LOCK(&m_CS);

    if( m_lpInputQueue != NULL )
    {
        delete m_lpInputQueue;
        m_lpInputQueue = NULL;
    }

    if( m_pInBoundAudioConverter != NULL )
    {
        ASSERT(m_pInBoundAudioConverter->Release() == 0);
        m_pInBoundAudioConverter = NULL;
    }

    if( m_pPlaybackMediaObject != NULL )
    {
        ASSERT(m_pPlaybackMediaObject->Release() == 0);
        m_pPlaybackMediaObject = NULL;
    }

    if( m_pdvidTargets != NULL )
    {
        delete [] m_pdvidTargets;
        m_pdvidTargets = NULL;
    }

    if (m_pMediaPacketBuffer) {

        DV_FreeMediaPacketPool(&m_PendingList,TRUE);
        DV_FreeMediaPacketPool(&m_AvailableList,TRUE);

        DV_POOL_FREE(m_pMediaPacketBuffer);
        m_pMediaPacketBuffer = NULL;

    }

    Reset();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\backend.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Backend.c
 *  Content:	This file contains the backend (mostly timer- and captive thread-based
 *				processing for the send pipeline.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *
 ****************************************************************************/

/*
**		NOTE ABOUT CRITICAL SECTIONS
**
**		It is legal to enter multiple critical sections concurrently,  but to avoid
**	deadlocks,  they must be entered in the correct order.
**
**		MSD CommandLocks should be entered first. That is,  do not attempt to take
**	a command lock with the PD ListLock or HashLock held,  or an EPD StateLock held
**	because you may deadlock the protocol.
**
**		ORDER OF PRECEDENCE -  Never take a low # lock while holding a higher # lock
**	
**		1 - CommandLock		// guards an MSD
**		2 - EPLock			// guards EPD queues (and retry timer stuff)
**		3 - SP QueueLock	// guards an SP send queue (and Listen command)
**
**		ANOTHER NOTE ABOUT CRIT SECs
**
**		It is also legal in WIN32 for a thread to take a CritSec multiple times, but in
**	this implementation we will NEVER do that.  The debug code will ASSERT that a thread
**	never re-enters a locked critsec even though the OS would let her do it.
*/


#include "dnproti.h"

PFMD	CopyFMD(PFMD, PEPD);

#ifdef	DEBUG
//	I will simulate dropped frames from the sender side.  This allows us to better analyse the
//	behavior because we can mark the frames that will be "dropped" so we can see them on the sniffer.

INT		BadFrames = 0;		// Zero is none,  else number is the range for dropping (drop 1 packet in N)
BOOL	UseRetry = 1;		// Retry reliable sends?
BOOL	KeepAlive = 1;		// Check for idle links?
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "LockEPD"

#ifdef DEBUG
BOOL LockEPD(PEPD pEPD, PCHAR Buf)
{
#else
BOOL LockEPD(PEPD pEPD)
{
#endif

	if (INTER_INC(pEPD) == 0)
	{
		INTER_DEC(pEPD);
		return FALSE;
	}
	else
	{
		LOGPF(8, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->uiRefCnt);
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseEPD"

#ifdef DEBUG
VOID ReleaseEPD(PEPD pEPD, PCHAR Buf)
{
#else
VOID ReleaseEPD(PEPD pEPD)
{
#endif

	ASSERT(pEPD->uiRefCnt >= 0); 
	
	if(INTER_DEC(pEPD) < 0) 
	{ 
		ReleaseEndPoint(pEPD, 0); 
	} 
	
	LOGPF(8, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->uiRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseEPDLocked"

#ifdef DEBUG
VOID ReleaseEPDLocked(PEPD pEPD, PCHAR Buf)
{
#else
VOID ReleaseEPDLocked(PEPD pEPD)
{
#endif

	ASSERT(pEPD->uiRefCnt >= 0); 

	if(INTER_DEC(pEPD) < 0) 
	{ 
		ReleaseEndPoint(pEPD, 1); 
	} 
	
	LOGPF(8, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->uiRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "LockMSD"

#ifdef DEBUG
VOID LockMSD(PMSD pMSD, PCHAR Buf)
{
#else
VOID LockMSD(PMSD pMSD)
{
#endif

	if(INTER_INC(pMSD) == 0) 
	{ 
		ASSERT(0); 
	}

	LOGPF(8, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->uiRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseMSD"

#ifdef DEBUG
VOID ReleaseMSD(PMSD pMSD, PCHAR Buf)
{
#else
VOID ReleaseMSD(PMSD pMSD)
{
#endif

	ASSERT(pMSD->uiRefCnt >= 0); 
	
	if(INTER_DEC(pMSD) < 0)
	{ 
		MSDPool->Release(MSDPool, pMSD); 
	}
	else 
	{ 
		Unlock(&pMSD->CommandLock); 
	}
	
	LOGPF(8, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->uiRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecrementMSD"

#ifdef DEBUG
VOID DecrementMSD(PMSD pMSD, PCHAR Buf)
{
#else
VOID DecrementMSD(PMSD pMSD)
{
#endif

	ASSERT(pMSD->uiRefCnt > 0); 
	INTER_DEC(pMSD);
	
	LOGPF(8, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->uiRefCnt);
}


/*
**		DNSP Command Complete
**
**		Service Provider calls us here to indicate completion of an asynchronous
**	command.  This may be called before the actual command returns,  so we must
**	make sure that our Context value is valid and accessible before calling SP.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_CommandComplete"

HRESULT WINAPI DNSP_CommandComplete(IDP8SPCallback *pIDNSP, HANDLE Handle, HRESULT hr, PVOID Context)
{
	PSPD		pSPD = (PSPD) pIDNSP;
	PFMD		pFMD = (PFMD) Context;
	PMSD		pMSD;

	ASSERT_SPD(pSPD);

	LOGPF(9, "COMMAND COMPLETE  (%p)", Context);

	// If we did not specify a context,  then we are not waiting for completion.
	if(Context != NULL)
	{		
		switch(pFMD->CommandID)
		{
			case COMMAND_ID_SEND_DATAGRAM:
				ASSERT_FMD(pFMD);
				ASSERT(pFMD->bSubmitted);
				LOGPF(6, "CommandComplete called for COMMAND_ID_SEND_DATAGRAM, pEPD[%p], pFMD[%p]", pFMD->pEPD, pFMD);
				
				Lock(&pSPD->SendQLock);
				pFMD->blQLinkage.RemoveFromList();				// Unlink from SPD Pending Queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SendQLock
				pFMD->SendDataBlock.hCommand = NULL;
				RELEASE_EPD_LOCKED(pFMD->pEPD, "UNLOCK (DG Frame Complete)");
				Unlock(&pSPD->SendQLock);

				pMSD = pFMD->pMSD;

				ASSERT(pMSD->uiRefCnt != -1);
				
				RELEASE_FMD(pFMD);								// Release reference on frame from SP submission

				Lock(&pMSD->CommandLock);

				pMSD->uiFrameCount--;
				pFMD->blMSDLinkage.RemoveFromList();			// Unlink from message
				RELEASE_FMD(pFMD);								// release reference from frame list

				if(pMSD->uiFrameCount == 0)
				{
					CompleteDatagramSend(pSPD, pMSD, hr);		// Datagram completes when SP says its xmited
				}
				else 
				{
					ASSERT(!pMSD->blFrameList.IsEmpty());
					Unlock(&pMSD->CommandLock);
				}

				break;

			case COMMAND_ID_SEND_RELIABLE:
				// Its possible for RelySends to go away before the individual frames complete (either pokey
				// SPs or dropped links).  Therefore,  we will make no assumptions about the parent MSD in this
				// routine.  If the MSD is gone,  the FMD will be freed when we RELEASE_FMD at the end of this handler.
				//
				// Only reason a Send can fail is if the endpoint goes away.  We will let the Endpoint cleanup stuff
				// take care of pending sends in that case and we wont worry about it here.  This avoids duplicating
				// code...
				
				ASSERT_FMD(pFMD);
				ASSERT(pFMD->bSubmitted);
				LOGPF(6, "CommandComplete called for COMMAND_ID_SEND_RELIABLE, pEPD[%p], pFMD[%p]", pFMD->pEPD, pFMD);

				Lock(&pSPD->SendQLock);
				pFMD->blQLinkage.RemoveFromList();				// but they dont wait on the PENDING queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SendQLock
				RELEASE_EPD_LOCKED(pFMD->pEPD, "UNLOCK (Rely Frame Complete)");
				Unlock(&pSPD->SendQLock);
				RELEASE_FMD(pFMD);								// Dec ref count

				break;

			case COMMAND_ID_CONNECT:

				pMSD = (PMSD) Context;

				LOGPF(2, "CommandComplete called for COMMAND_ID_CONNECT, pMSD[%p]", pMSD);

				ASSERT_MSD(pMSD);
				ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER);

				Lock(&pMSD->CommandLock);						// must do this before clearing IN_SP flag

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag
				DECREMENT_MSD(pMSD, "SP Ref");							// Dec ref count w/o release lock
				CompleteSPConnect((PMSD) Context, pSPD, hr);

				break;		

			case COMMAND_ID_CFRAME:
				
				ASSERT_FMD(pFMD);
				ASSERT_EPD(pFMD->pEPD);
				ASSERT(pFMD->bSubmitted);
				LOGPF(6, "CommandComplete called for COMMAND_ID_CFRAME, pEPD[%p], pFMD[%p]", pFMD->pEPD, pFMD);
				
				Lock(&pSPD->SendQLock);
				pFMD->blQLinkage.RemoveFromList();				// Take the frame off of the pending queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SendQLock
				RELEASE_EPD_LOCKED(pFMD->pEPD, "UNLOCK (CFrame Cmd Complete)");	// Release EndPoint before releasing frame
				Unlock(&pSPD->SendQLock);

				RELEASE_FMD(pFMD);								// Release Frame

				break;

			case COMMAND_ID_LISTEN:
				pMSD = (PMSD) Context;

				LOGPF(2, "CommandComplete called for COMMAND_ID_LISTEN, pMSD[%p]", pMSD);

				ASSERT_MSD(pMSD);
				ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER);

				Lock(&pMSD->CommandLock);

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag

				Lock(&pSPD->SendQLock);

				pMSD->blQLinkage.RemoveFromList();					// Remove from SP's ListenList
				
				// Cancel code will remove this from PD list.  Otherwise we do it here.
				if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
				{
					pMSD->blSPLinkage.RemoveFromList();
					pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
				}

				if(pSPD->blListenList.IsEmpty())
				{
					pSPD->ulSPFlags &= ~(SPFLAGS_LISTENING);		// Indicate new status in SPD
				}
				Unlock(&pSPD->SendQLock);

				LOGPF(3, "Calling Core->CompleteListenTerminate, hr[%x]", hr);
				pSPD->pPData->pfVtbl->CompleteListenTerminate(pSPD->pPData->Parent, pMSD->Context, hr);
				RELEASE_MSD(pMSD, "SP Ref");

				break;

			case COMMAND_ID_COPIED_RETRY:
				ASSERT_FMD(pFMD);
				ASSERT_EPD(pFMD->pEPD);
				ASSERT(pFMD->bSubmitted);
				LOGPF(6, "CommandComplete called for COMMAND_ID_COPIED_RETRY, pEPD[%p], pFMD[%p]", pFMD->pEPD, pFMD);
				
				Lock(&pSPD->SendQLock);
				pFMD->blQLinkage.RemoveFromList();				// but they dont wait on the PENDING queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SendQLock
				RELEASE_EPD_LOCKED(pFMD->pEPD, "UNLOCK (Rely Frame Complete (Copy))");
				RELEASE_EPD_LOCKED(pFMD->pEPD, "UNLOCK (Copy Complete)");
				Unlock(&pSPD->SendQLock);
				RELEASE_FMD(pFMD);								// Dec ref count

				break;

			case COMMAND_ID_ENUM:
			{
				pMSD = static_cast<PMSD>( Context );

				ASSERT_MSD( pMSD );
				ASSERT( pMSD->hCommand == Handle );
				ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

				LOGPF(2, "CommandComplete called for COMMAND_ID_ENUM, pMSD[%p]", pMSD);
				
				Lock( &pMSD->CommandLock );

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

				Lock( &pSPD->SendQLock );
				if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
				{
					pMSD->blSPLinkage.RemoveFromList();
					pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
				}
				Unlock( &pSPD->SendQLock );

				LOGPF(3, "Calling Core->CompleteEnumQuery, hr[%x]", hr);
				pSPD->pPData->pfVtbl->CompleteEnumQuery(pSPD->pPData->Parent, pMSD->Context, hr);

				DECREMENT_MSD( pMSD, "SP Ref");				// SP is done
				RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

				break;
			}

			case COMMAND_ID_ENUMRESP:
			{
				pMSD = static_cast<PMSD>( Context );

				ASSERT_MSD( pMSD );
				ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

				LOGPF(2, "CommandComplete called for COMMAND_ID_ENUMRESP, pMSD[%p]", pMSD);

				Lock( &pMSD->CommandLock );

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

				Lock( &pSPD->SendQLock );
				if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
				{
					pMSD->blSPLinkage.RemoveFromList();
					pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
				}
				Unlock( &pSPD->SendQLock );

				LOGPF(3, "Calling Core->CompleteEnumResponse, hr[%x]", hr);
				pSPD->pPData->pfVtbl->CompleteEnumResponse(pSPD->pPData->Parent, pMSD->Context, hr);

				DECREMENT_MSD( pMSD, "SP Ref" );			// SP is done
				RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

				break;
			}

			default:
				LOGPF(0, "CommandComplete called with unknown CommandID");
				ASSERT(0);
				break;

		} // SWITCH
	} // IF NOT NULL CONTEXT	
	else 
	{
		LOGPF(0, "CommandComplete called with NULL Context");
		ASSERT(0);
	}

	return DPN_OK;
}

/*
**		Update Xmit State
**
**		There are two elements to the remote rcv state delivered in each frame.  There is
**	the NSeq number which acknowledges ALL frames with smaller sequence numbers,
**	and there is the bitmask which acknowledges specific frames starting with NSeq+1.
**
**		Frames prior to NSeq can be removed from the SendWindow.  Frames acked by bits
**	should be marked as acknowledged,  but left in the window until covered by NSeq
**	(because a protocol can renege on bit-acked frames).
**
**		We will walk through the send window queue,  starting with the oldest frame,
**	and remove each frame that has been acknowledged by NSeq.  As we hit EOM frames,
**	we will indicate SendComplete for the message.  If the bitmask is non-zero we may
**	trigger retransmission of the missing frames.  I say 'may' because we dont want
**	to send too many retranmissions of the same frame...
**
**	SOME MILD INSANITY:  Doing the DropLink code now.  There are several places where
**	we release the EPD Locks in the code below,  and any time we arent holding the locks
**	someone can start terminating the link.  Therefore,  whenever we retake either EPD lock
**	(State or SendQ) after yielding them,  we must re-verify that EPFLAGS_CONNECTED is still
**	set and be prepared to abort if it is not.  Happily,  the whole EPD wont go away on us
**	because we have a RefCnt on it,  but once CONNECTED has been cleared we dont want to go
**	setting any more timers or submitting frames to the SP.
**
**	RE_WRITE TIME:  We can be re-entered while User Sends are being completed.  This is okay
**	except for the chance that the second thread would blow through here and hit the rest
**	of CrackSequential before us.  CrackSeq would think it got an out of order frame (it had)
**	and would issue a NACK before we could stop him.  Easiest solution is to delay the callback
**	of complete sends until the end of the whole receive operation (when we indicate receives
**	for instance).  Incoming data should have priority over completing sends anyhow...
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateXmitState"

VOID
UpdateXmitState(PEPD pEPD, BYTE bNRcv, PSACKFRAME pSackFrame, ULONG RcvMaskLow, ULONG RcvMaskHigh, DWORD tNow)
{
	PSPD	pSPD = pEPD->pSPD;
	PFMD	pFMD;
	PMSD	pMSD;
	CBilink	*pLink;
	UINT	tDelay;
	UINT	uiRTT;
	UINT	timestamp;
	UINT	delta;
	BOOL	ack = FALSE;
	BOOL	retransmit = FALSE;
	BOOL	logged_drop = FALSE;
	ULONG	Mask;
	BYTE	diff;

	if(RcvMaskLow | RcvMaskHigh)
	{
		LOGPF(7, "(%p) *NACK RCVD* NRcv=%x, MaskL=%x, MaskH=%x", pEPD, bNRcv, RcvMaskLow, RcvMaskHigh);
	}

	if((pEPD->ulEPFlags & EPFLAGS_CONNECTED)==0)
	{
		LOGPF(7, "(%p) Not Connected, exiting", pEPD);
		return;
	}

	#ifdef	DEBUG			// There should always be a timer running on the first frame in window
	if(UseRetry){
		if(!pEPD->blSendWindow.IsEmpty()){
			pFMD = CONTAINING_RECORD((pLink = pEPD->blSendWindow.GetNext()), FMD, blWindowLinkage);
			ASSERT_FMD(pFMD);
			ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);
		}
	}
	#endif
	
	while(!pEPD->blSendWindow.IsEmpty())
	{
		pFMD = CONTAINING_RECORD((pLink = pEPD->blSendWindow.GetNext()), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);

		// Let's try taking one sample from every group of acknowledgements
		// ALWAYS SAMPLE THE HIGHEST NUMBERED FRAME COVERED BY THIS ACK
		if(((PDFRAME) pFMD->ImmediateData)->bSeq == (bNRcv - 1))
		{	
			// Don't take sample if frame was retry because we don't know
			if(pFMD->uiRetry == 0)
			{									
				uiRTT = tNow - pFMD->tTimestamp[0];					// which instance to correlate the response with
				if(uiRTT & 0x80000000)
				{
					LOGPF(7, "(%p) We calced a negative RTT", pEPD);
					uiRTT = 1;
				}
				UpdateEndPoint(pEPD, uiRTT, pFMD->uiFrameLength, -1, tNow);
			}
		}		
		if( (BYTE)  ((bNRcv) - (((PDFRAME) pFMD->ImmediateData)->bSeq + 1)) < (BYTE) pEPD->iUnackedFrames) 
		{
			ASSERT(pFMD->ulFFlags & FFLAGS_IN_SEND_WINDOW);
			LOGPF(7, "(%p) Removing Frame %x from send window", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq);
			pLink->RemoveFromList();							// Remove frame from send window
			pFMD->ulFFlags &= ~(FFLAGS_IN_SEND_WINDOW);			// Clear flag

			if(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET)
			{
				ASSERT(ack == FALSE);
				ASSERT(pEPD->RetryTimer != 0);
				LOGPF(7, "(%p) Cancelling Retry Timer", pEPD);
				if(CancelMyTimer(pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
				{
					RELEASE_EPD(pEPD, "UNLOCK (cancel retry timer)"); // SendQLock not already held
				}
				else
				{
					LOGPF(7, "(%p) Cancelling Retry Timer Failed", pEPD);
				}
				pEPD->RetryTimer = 0;							// This will cause event to be ignored if it runs
				pFMD->ulFFlags &= ~(FFLAGS_RETRY_TIMER_SET);
			}

			pEPD->iUnackedFrames--;								// track size of window
			ASSERT(pEPD->iUnackedFrames >= 0);
			pEPD->iUnackedBytes -= pFMD->uiFrameLength;
			ASSERT(pEPD->iUnackedBytes >= 0);
			if(pFMD->uiFrameLength > 0)
			{
				pEPD->uiFramesAcked++;
				pEPD->uiBytesAcked += pFMD->uiFrameLength;
			}

			// One more send complete
			if((pFMD->CommandID != COMMAND_ID_SEND_DATAGRAM) && (pFMD->ulFFlags & (FFLAGS_END_OF_MESSAGE | FFLAGS_END_OF_STREAM)))
			{	
				pMSD = pFMD->pMSD;
				pMSD->ulMsgFlags2 |= MFLAGS_TWO_COMPLETE;		// Mark this complete
				pEPD->ulEPFlags |= EPFLAGS_COMPLETE_SENDS;
			}
			
			RELEASE_FMD(pFMD);									// Release reference for send window
			ack = TRUE;
		}
		else 
		{
			break;												// First unacked frame,  we can stop checking list
		}
	}					// WHILE (send window not empty)

	// At this point we have completed all of the frames ack'd by NRcv.  We would now like to re-transmit
	// any frames NACK'd by bitmask (and mark the ones ACK'd by bitmask). Now remember,  the first frame in
	// the window is automatically missing by the implied first zero-bit.
	//
	//	We will retransmit ALL frames that appear to be missing.  There may be a timer running on
	//	the first frame,  but only if we did not ACK any frames in the code above (ack == 0).
	//
	//	Hmmm,  if the partner has a fat pipeline we could see this bitmap lots of times.  We need to make
	//	sure we don't trigger a retransmission here a quarter-zillion times during the Ack latency period.
	//	To solve this we will only re-xmit the first time we see this bit.  After that,  we will have to
	//	wait around for the next RetryTimeout.  I think that's just the way its going to have to be.
	//
	//	OTHER THINGS WE KNOW:
	//
	//	There must be at least two frames remaining in the SendWindow. At minimum, first frame missing (always)
	//  and then at least one SACK'd frame after.
	//
	//	pLink = first queue element in SendWindow
	//	pFMD = first frame in SendWindow
	//
	//	We are still Holding EPD->SendQLock.  It is okay to take SPD->SendQLock while holding it.
	//
	//  One More Problem:  Since SP has changed its receive buffer logic mis-ordering of frames has become
	// quite commonplace.  This means that our assumptions about the state of the SendWindow are not necessarily true.
	// This means that frames NACKed by bitmask may have been acknowleged by a racing frame.  This means that the
	// SendWindow may not be in sync with the mask at all.  This means we need to synchronize the bitmask with the
	// actual send window.  This is done by right-shifting the mask for each frame that's been acknowleged since the
	// bitmask was minted before beginning the Selective Ack process.


	if((RcvMaskLow | RcvMaskHigh)&&(pEPD->iUnackedFrames > 1))
	{
		if(bNRcv != ((PDFRAME) pFMD->ImmediateData)->bSeq)
		{
			// This SACK frame must have been delivered late behind a frame ACKing more stuff.  We must get the mask in synch
			// with the current send window,  and then see if there is still anything this mask is NACKing

			LOGPF(7, "(%p) SACK frame out of sync with local state. (frame)bNRcv=%x, (local)nSeq=%x, ML=%x, MH=%x", pEPD, bNRcv, ((PDFRAME) pFMD->ImmediateData)->bSeq, RcvMaskLow, RcvMaskHigh);
		
			while((RcvMaskLow | RcvMaskHigh) && (bNRcv != ((PDFRAME) pFMD->ImmediateData)->bSeq) )
			{
				RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);		// 64 bit logical shift right
				bNRcv++;										// shift once for each frame prior to the window
			}

			LOGPF(7, "(%p) After adjusting, NRCV=%x, ML=%x, MH=%x", pEPD, bNRcv, RcvMaskLow, RcvMaskHigh);
		}
		
#ifdef	DEBUG
		if((ack == 0) && (UseRetry)){
#else
		if(ack == 0){											// If we did NOT Ack a frame,  then retry timer is still running
#endif
			ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);

			// We will reset the retry timer since we are retrying now

			LOGPF(7, "(%p) Resetting Retry Timer for %dms", pEPD, pEPD->uiRetryTimeout);
			if(CancelMyTimer(pEPD->RetryTimer, pEPD->RetryTimerUnique) != DPN_OK)
			{
				LOCK_EPD(pEPD, "LOCK (cant cancel retry)");		// Could not cancel- therefore we must balance RefCnt
			}
			SetMyTimer(pEPD->uiRetryTimeout, 100, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique );
		}

		while(RcvMaskLow | RcvMaskHigh)
		{
			pFMD = CONTAINING_RECORD(pLink, FMD, blWindowLinkage);
			ASSERT_FMD(pFMD);
			if((pFMD->ulFFlags & (FFLAGS_NACK_RETRANSMIT_SENT | FFLAGS_RETRY_QUEUED)) == 0)
			{
				// Check time since last retry was sent
				// Don't retry if we *just* sent one...
				if(((tNow - pFMD->tTimestamp[pFMD->uiRetry]) > 0)&&(pFMD->uiRetry < (MAX_RETRIES - 1)))
				{	
#ifdef	FRAME_NAMES
					((PDFRAME) pFMD->ImmediateData)->Name = SELECT_NAME;
#endif	// FRAME_NAMES
					((PDFRAME) pFMD->ImmediateData)->bNRcv = pEPD->bNextReceive;	// Use up-to-date ACK info

					pFMD->uiRetry++;
					pFMD->ulFFlags |= FFLAGS_NACK_RETRANSMIT_SENT;
					pFMD->tTimestamp[pFMD->uiRetry] = tNow;
					
					// Unreliable frame!
					if(pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM)
					{
						// When an unreliable frame is NACKed we will not retransmit the data.  We will instead send
						// a cancel mask telling the receiver to ignore this sequence number.

						LOGPF(7, "(%p) SELECTIVE RETRY REQUESTED for UNRELIABLE FRAME Seq=%x", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq);

						pEPD->iUnackedBytes -= pFMD->uiFrameLength;

						if(pFMD->uiRetry == 1)
						{
							pEPD->uiDatagramFramesDropped++;	// Only count a datagram drop on the first occurance
							pEPD->uiDatagramBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength); // Only user bytes
							EndPointDroppedFrame(pEPD, tNow);
						}

						delta = (BYTE) (pEPD->bNextSend - ((PDFRAME) pFMD->ImmediateData)->bSeq); // Diff between next send and this send.

						ASSERT(delta != 0);
						ASSERT(delta < (MAX_RECEIVE_RANGE + 1));

						if(delta < 33)
						{
							pEPD->ulSendMask |= (1 << (delta - 1));
						}
						else
						{
							pEPD->ulSendMask2 |= (1 << (delta - 33));
						}

						pFMD->uiFrameLength = 0;			// Frame has been credited to the send window, don't want to credit again on ACK

						if((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)
						{
							pEPD->ulEPFlags |= EPFLAGS_DELAYED_SENDMASK;

							if(pEPD->DelayedMaskTimer == 0)
							{
								LOGPF(7, "(%p) Setting Delayed Ack Timer", pEPD);
								SetMyTimer(DELAYED_SEND_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
								LOCK_EPD(pEPD, "LOCK (Delayed Mask Timer)");
							}
						}
					}

					// Reliable Frame -- Issue a retry of frame
					else 
					{		
						retransmit = TRUE;
						
						pEPD->uiGuaranteedFramesDropped++;													// Keep count of lost frames
						pEPD->uiGuaranteedBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);	// Keep count of lost frames
				
						if(pFMD->bSubmitted)
						{
							// In the heat of battle,  its possible that this FMD has not completed from the last
							// send.  In this case,  we will make a temporary copy of the FMD and submit the clone.
							// We will mark the clone as a RETRY_COPY which will be immediately freed upon completion,
							// and we will leave the retry timestamp in the original FMD.

							LOGPF(7, "(%p) SELECTIVE RETRY while FMD busy; Seq=0x%x", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq);
							pFMD = CopyFMD(pFMD, pEPD);
						}
						else 
						{
							LOGPF(7, "(%p) SELECTIVE RETRY Seq=0x%x,  FMD=0x%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
							LOCK_FMD(pFMD);						// Make sure this frame survives until transmitted
						}

						// Only call this once per NACK received
						if(logged_drop == FALSE)
						{					
							EndPointDroppedFrame(pEPD, tNow);
							logged_drop = TRUE;
						}

						//	EPD->EPLock is already held so we can slam frame right into rexmit queue

						// If CopyFMD failed we won't have an FMD here
						if(pFMD)
						{								
							LOGPF(7, "(%p) Queueing frame on retry queue FMD[%p]", pEPD, pFMD);
							LOCK_EPD(pEPD, "LOCK (selective retry)");
							pEPD->ulEPFlags |= EPFLAGS_RETRIES_QUEUED;
							pFMD->ulFFlags |= FFLAGS_RETRY_QUEUED;
							pFMD->blQLinkage.InsertBefore( &pEPD->blRetryQueue);		// Place frame on Send queue
						}
					}
				}
				else 
				{
					// Last retry was less then 1 ms past -- we will ignore this for now
					LOGPF(7, "(%p) ***BLOWING OFF NACK***", pEPD);
				}
			}

			pLink = pLink->GetNext();							// Advance pLink to next frame in SendWindow

			// Move through bitmask and SendWindow until find missing frame
			while(RcvMaskLow & 1)
			{								
				pLink = pLink->GetNext();
				RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);		// 64 bit logical shift right
			}
			RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);			// 64 bit logical shift right, skip the zero
		}					// END WHILE (WORK MASKS NON-ZERO)


		if(retransmit)
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

			// Stop delayed ack timer
			if(pEPD->DelayedAckTimer != 0)
			{						
				LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
				if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
				{
					RELEASE_EPD(pEPD, "UNLOCK (cancel DelayAckTimer)"); // SendQLock not already held
					pEPD->DelayedAckTimer = 0;
				}
				else
				{
					LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
				}
			}

			if((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
			{
				LOGPF(7, "(%p) Scheduling Send", pEPD);
				pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
				LOCK_EPD(pEPD, "LOCK (pipeline)");
				ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
			}
		}
	}


	// If we acked a frame above and there is more data outstanding then we may need to start a new Retry timer.
	//
	// Of course,  we want to set the timer on whatever frame is the first in the SendWindow.

	if( (pEPD->iUnackedFrames > 0) && (pEPD->RetryTimer == 0)) 
	{
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);		
		tDelay = GETTIMESTAMP() - pFMD->tTimestamp[pFMD->uiRetry];	// How long has this frame been enroute?

		tDelay = (tDelay > pEPD->uiRetryTimeout) ? 0 : pEPD->uiRetryTimeout - tDelay; // Calc time remaining for frame

	#ifdef DEBUG
		if(UseRetry)
		{
	#endif
			LOGPF(7, "(%p) Setting Retry Timer for %dms on N(S)=[%x], FMD=[%p]", pEPD, tDelay, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
			ASSERT(ack);
			LOCK_EPD(pEPD, "LOCK (retry timer)");						// bump RefCnt for timer
			SetMyTimer(tDelay, 0, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique );
			pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;
	#ifdef DEBUG
		}
	#endif
	}

	// See if we need to unblock this session

	if((pEPD->iUnackedFrames < pEPD->iWindowF) && (pEPD->iUnackedBytes < pEPD->iWindowB))
	{
		pEPD->ulEPFlags |= EPFLAGS_STREAM_UNBLOCKED;
		if((pEPD->ulEPFlags & EPFLAGS_SDATA_READY) && ((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0))
		{
			LOGPF(7, "(%p) UpdateXmit: ReEntering Pipeline", pEPD);

			pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
			LOCK_EPD(pEPD, "LOCK (pipeline)");
			ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
		}
	}
}


/*
**		Complete Datagram Frame
**
**		A datagram frame has been successfully transmitted.  Free the descriptor and
**	see if the entire send is ready to complete.  Reliable sends are not freed until
**	they are acknowledged,  so they must be handled elsewhere.
**
**		**  This is called with the CommandLock in MSD held **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteDatagramSend"

VOID CompleteDatagramSend(PSPD pSPD, PMSD pMSD, HRESULT hr)
{
	PVOID	Context;

	ASSERT(pMSD->blFrameList.IsEmpty());				// Was this the last frame in the message?
	ASSERT(pMSD->uiFrameCount == 0);
	ASSERT((pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED)==0);

	
	Lock(&pMSD->pEPD->EPLock);
	LOGPF(7, "(%p) DG MESSAGE COMPLETE pMSD=%p", pMSD->pEPD, pMSD);
	
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_COMPLETE;				// Mark this complete
	
	if(pMSD->TimeoutTimer != NULL)
	{
		LOGPF(7, "(%p) Cancelling Timeout Timer", pMSD->pEPD);
		if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
		{
			pMSD->TimeoutTimer = NULL;
			DECREMENT_MSD(pMSD, "Send Timeout Timer");
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Timeout Timer Failed", pMSD->pEPD);
		}
	}

	Lock(&pSPD->SendQLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();						// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
	}
	Unlock(&pSPD->SendQLock);

	if(hr == DPNERR_USERCANCEL)
	{
		if(pMSD->ulMsgFlags1 & MFLAGS_ONE_TIMEDOUT)
		{
			hr = DPNERR_TIMEDOUT;
		}
	}

	pMSD->blQLinkage.RemoveFromList();							// Remove from CompleteSendQueue
	Unlock(&pMSD->pEPD->EPLock);

	Context = pMSD->Context;
	
	RELEASE_EPD(pMSD->pEPD, "UNLOCK (Complete DG)");	// Every send command bumps the refcnt..., SendQLock not already held
	RELEASE_MSD(pMSD, "Release On Complete");			// Finished with this one

	LOGPF(6, "(%p) Calling Core->CompleteSend, hr[%x]", pMSD->pEPD, hr);
	pSPD->pPData->pfVtbl->CompleteSend(pSPD->pPData->Parent, Context, hr);
}

/*
**		Complete Reliable Send
**
**		A reliable send has completed processing.  Indicate this
**	to the user and free the resources.  This will either take
**	place on a cancel,  error,  or when ALL of the message's frames
**	have been acknowledged.
**
**		**  This is called with CommandLock in MSD held  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteReliableSend"

VOID
CompleteReliableSend(PSPD pSPD, PMSD pMSD, HRESULT hr)
{
	PEPD	pEPD;
	PVOID	Context;
	BOOL	bCallUser;

	// NORMAL SEND COMPLETES
	if(pMSD->CommandID == COMMAND_ID_SEND_RELIABLE)
	{	
		LOGPF(7, "(%p) Reliable Send Complete pMSD=%p", pMSD->pEPD, pMSD);

		ASSERT((pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED)==0);

		if(pMSD->TimeoutTimer != NULL)
		{
			LOGPF(7, "(%p) Cancelling Timeout Timer", pMSD->pEPD);
			if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
			{
				pMSD->TimeoutTimer = NULL;
				DECREMENT_MSD(pMSD, "Send Timeout Timer");
			}
			else
			{
				LOGPF(7, "(%p) Cancelling Timeout Timer Failed", pMSD->pEPD);
			}
		}

		Lock(&pSPD->SendQLock);
		if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
		{
			pMSD->blSPLinkage.RemoveFromList();					// Remove MSD from master command list
			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
		}
		RELEASE_EPD_LOCKED(pMSD->pEPD, "UNLOCK (complete rely send)");	// release hold on EPD for this send
		Unlock(&pSPD->SendQLock);
		Context = pMSD->Context;
		RELEASE_MSD(pMSD, "Release On Complete");				// Return resources,  including all frames

		LOGPF(6, "(%p) Calling Core->CompleteSend, hr[%x]", pMSD->pEPD, hr);
		pSPD->pPData->pfVtbl->CompleteSend(pSPD->pPData->Parent, Context, hr);
	}

	// END OF STREAM -OR- KEEPALIVE COMPLETES
	else 
	{												
		// Partner has just ACKed our End Of Stream frame.  Doesn't necessarily mean we are done.
		// Both sides need to send (and have acknowledged) EOS frames before the link can be
		// dropped.  Therefore,  we check to see if we have seen our partner's DISC before
		// releasing the RefCnt on EPD allowing the link to drop.  If partner was idle, his EOS
		// might be the same frame which just ack'd us.  Luckily,  this code will run first so we
		// will not have noticed his EOS yet,  and we will not drop right here.

		ASSERT(pMSD->ulMsgFlags2 & (MFLAGS_TWO_END_OF_STREAM | MFLAGS_TWO_KEEPALIVE));

		pEPD = pMSD->pEPD;

		Lock(&pEPD->EPLock);
		
		if(pMSD->ulMsgFlags2 & MFLAGS_TWO_KEEPALIVE)
		{
			LOGPF(7, "(%p) Keepalive Complete pMSD=%p", pMSD->pEPD, pMSD);
			
			pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST));
			
			pEPD->uiDatagramFramesSent--;					// This would have been counted as a user-datagram...
			
			Unlock(&pEPD->EPLock);
			RELEASE_EPD(pEPD, "UNLOCK (rel KeepAlive)");	// Release ref for this MSD, SendQLock not already held
			RELEASE_MSD(pMSD, "Release On Complete");		// Done with this message
		}
		else 
		{
			LOGPF(7, "(%p) EndOfStream Complete pMSD=%p", pMSD->pEPD, pMSD);

			pEPD->ulEPFlags |= EPFLAGS_DISCONNECT_ACKED;

			if(pEPD->ulEPFlags & EPFLAGS_RECEIVED_DISCONNECT)
			{
				LOGPF(7, "(%p) Disconnect has been received, killing connection", pMSD->pEPD);

				// We are clear to blow this thing down

				bCallUser = !(pEPD->ulEPFlags & EPFLAGS_INDICATED_DISCONNECT);
				pEPD->ulEPFlags |= EPFLAGS_INDICATED_DISCONNECT; // This must happen prior to DropLink

				DropLink(pEPD); // This unlocks the EPLock

				if(pMSD->CommandID == COMMAND_ID_DISCONNECT)
				{
					Lock(&pSPD->SendQLock);
					if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
					{
						pMSD->blSPLinkage.RemoveFromList();			// Remove MSD from master command list
						pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
					}
					RELEASE_EPD_LOCKED(pEPD, "UNLOCK (rel DISCONNECT)");// release hold on EPD for this command
					Unlock(&pSPD->SendQLock);
					Context = pMSD->Context;
					RELEASE_MSD(pMSD, "Release On Complete");			// Return resources,  including all frames

					if(bCallUser)
					{
						LOGPF(3, "(%p) Calling Core->CompleteDisconnect, hr[%x]", pMSD->pEPD, hr);
						pSPD->pPData->pfVtbl->CompleteDisconnect(pSPD->pPData->Parent, Context, hr);
					}
					else
					{
						LOGPF(3, "(%p) Calling Core->CompleteDisconnect, hr[DPNERR_CONNECTIONLOST]", pMSD->pEPD);
						pSPD->pPData->pfVtbl->CompleteDisconnect(pSPD->pPData->Parent, Context, DPNERR_CONNECTIONLOST);
					}
				}
				else 
				{
					RELEASE_MSD(pMSD, "Release On Complete");			// Return resources,  including all frames
					Context = pEPD->Context;
					RELEASE_EPD(pEPD, "UNLOCK (rel DISCONNECT)");// release hold on EPD for this command, SendQLock not already held
					if(bCallUser)
					{
						LOGPF(3, "(%p) Calling Core->IndicateConnectionTerminated, hr[%x]", pMSD->pEPD, hr);
						pSPD->pPData->pfVtbl->IndicateConnectionTerminated(pSPD->pPData->Parent, Context, hr);
					}
				}
			}
			else 
			{
				// Our Disconnect frame has been acknowledged but we must wait until we see his DISC before
				// completing this command and dropping the connection.  We will let it sit on the RelySendQ
				// for lack of anyplace else to keep it.  This queue should otherwise remain empty until we
				// close.
				//
				//	We will use the pCommand pointer to track this disconnect command until we see partner's DISC frame
				//
				//	ALSO,  since our engine has now shutdown,  we might wait forever now for the final DISC from partner
				// if he crashes before transmitting it.  One final safeguard here is to set a timer which will make sure
				// this doesnt happen. * NOTE * no timer is actually being set here, we're depending on the keepalive
				// timeout, see EndPointBackgroundProcess.

				LOGPF(7, "(%p) Disconnect has not yet been received", pMSD->pEPD);
				
				ASSERT(pEPD->blHighPriSendQ.IsEmpty());
				ASSERT(pEPD->blNormPriSendQ.IsEmpty());
				ASSERT(pEPD->blLowPriSendQ.IsEmpty());

				ASSERT(pEPD->pCommand == NULL);
				pEPD->pCommand = pMSD;
					
				Unlock(&pEPD->EPLock);

				Unlock(&pMSD->CommandLock);
			}
		}
	}
}


/*
**		Build Data Frame
**
**		Setup the actual network packet header for transmission with our current link state info (Seq, NRcv).
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDataFrame"

VOID	BuildDataFrame(PEPD pEPD, PFMD pFMD)
{
	ULONG		UserFlags;
	PDFBIG		pFrame;
	UINT		index = 0;

	pFrame = (PDFBIG) pFMD->ImmediateData;
#ifdef	FRAME_NAMES
	pFrame->Name = (pFMD->ulFFlags & FFLAGS_RELIABLE) ? RELY_NAME : DG_NAME;
#endif
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;
	pFMD->uiRetry = 0;

	pFrame->bCommand = pFMD->bPacketFlags;
	pFrame->bControl = 0;	// this sets retry count to zero as well as clearing flags
	
	if (pFMD->ulFFlags & FFLAGS_END_OF_STREAM) 
	{
#ifdef	FRAME_NAMES
		pFrame->Name = DISCON_NAME;
#endif
		pFrame->bControl |= (PACKET_CONTROL_END_STREAM | PACKET_CONTROL_CORRELATE);
	}

	//  See if we are desiring an immediate response

	if(pFMD->ulFFlags & FFLAGS_CHECKPOINT)
	{
		pFrame->bCommand |= PACKET_COMMAND_POLL;
#ifdef POLL_COUNT	
		pEPD->uiPollCount = pEPD->uiPollFrequency;
#endif
#ifdef	FRAME_NAMES
		if(pFMD->ulFFlags & FFLAGS_KEEPALIVE)
		{
			pFrame->Name = KEEPALIVE_NAME;
		}
#endif
	}
#ifdef POLL_COUNT	
	else if(--pEPD->uiPollCount == 0)
	{
		LOGPF(7, "(%p) +++ Polling by POLL COUNT Seq=%x", pEPD, pEPD->bNextSend);
		pFrame->bCommand |= PACKET_COMMAND_POLL;						// Its time to ask for a response we can correlate
		pFMD->ulFFlags |= FFLAGS_CHECKPOINT;							// This way we will POLL on retries also

		pEPD->uiPollCount = pEPD->uiPollFrequency;						// reset counter for next checkpoint
	}
#endif

	pFrame->bSeq = pEPD->bNextSend++;
	pFrame->bNRcv = pEPD->bNextReceive;		// Acknowledges all previous frames

	LOGPF(7, "(%p) N(S) incremented to %x", pEPD, pEPD->bNextSend);

	//	Piggyback NACK notes
	//
	//		Since the SP is now frequently mis-ordering frames we are enforcing a back-off period before transmitting a NACK after
	// a packet is received out of order. Therefore we have the Delayed Mask Timer which stalls the dedicated NACK.  Now we must
	// also make sure that the new NACK info doesnt get piggybacked too soon.  Therefore we will test the tReceiveMaskDelta timestamp
	// before including piggyback NACK info here,  and make sure the mask is at least 5ms old.

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		if((GETTIMESTAMP() - pEPD->tReceiveMaskDelta) > 4)
		{
			LOGPF(7, "(%p) Installing NACK in DFRAME Seq=%x, NRcv=%x Low=%x High=%x", pEPD, pFrame->bSeq, pFrame->bNRcv, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
			if(pEPD->ulReceiveMask)
			{
				pFrame->rgMask[index++] = pEPD->ulReceiveMask;
				pFrame->bControl |= PACKET_CONTROL_SACK_MASK1;
			}
			if(pEPD->ulReceiveMask2)
			{
				pFrame->rgMask[index++] = pEPD->ulReceiveMask2;
				pFrame->bControl |= PACKET_CONTROL_SACK_MASK2;
			}

			pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
		}
		else
		{
			LOGPF(7, "(%p) DECLINING TO PIGGYBACK NACK WITH SMALL TIME DELTA", pEPD);
		}
	}
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)
	{
		LOGPF(7, "(%p) Installing SENDMASK in DFRAME Seq=%x, Low=%x High=%x", pEPD, pFrame->bSeq, pEPD->ulSendMask, pEPD->ulSendMask2);
		if(pEPD->ulSendMask)
		{
			pFrame->rgMask[index++] = pEPD->ulSendMask;
			pFrame->bControl |= PACKET_CONTROL_SEND_MASK1;
			pEPD->ulSendMask = 0;
		}
		if(pEPD->ulSendMask2)
		{
			pFrame->rgMask[index++] = pEPD->ulSendMask2;
			pFrame->bControl |= PACKET_CONTROL_SEND_MASK2;
			pEPD->ulSendMask2 = 0;
		}
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_SENDMASK);
	}
	
	pFMD->uiImmediateLength = sizeof(DFRAME) + (index * sizeof(ULONG));
	
	pFMD->tTimestamp[0] = GETTIMESTAMP();

	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

	// Stop delayed mask timer
	if((pEPD->DelayedMaskTimer != 0)&&((pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)==0))
	{
		LOGPF(7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedMaskTimer)"); // SendQLock not already held
			pEPD->DelayedMaskTimer = 0;
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
	}
	
	// Stop delayed ack timer
	if(pEPD->DelayedAckTimer != 0)
	{					
		LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedAckTimer)"); // SendQLock not already held
			pEPD->DelayedAckTimer = 0;
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
	}
	
	pFMD->uiFrameLength += pFMD->uiImmediateLength;
}

/*
**		Build Retry Frame
**
**		Reinitialize those fields in the packet header that need to be recalculated for a retransmission.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildRetryFrame"

VOID
BuildRetryFrame(PEPD pEPD, PFMD pFMD)
{
	PDFMASKS	pMasks;
	UINT		index = 0;

	((PDFRAME) pFMD->ImmediateData)->bNRcv = pEPD->bNextReceive;		// Use up-to-date ACK info
	
	((PDFRAME) pFMD->ImmediateData)->bControl &= PACKET_CONTROL_END_STREAM;	// Preserve EOS bit from original
	((PDFRAME) pFMD->ImmediateData)->bControl |= PACKET_CONTROL_RETRY;		// clamp retry value at size of field in packet

	pMasks = (PDFMASKS) (pFMD->ImmediateData + sizeof(DFRAME));			// pointer to mask space after protocol header

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		if(pEPD->ulReceiveMask)
		{
			pMasks->rgMask[index++] = pEPD->ulReceiveMask;
			((PDFRAME) pFMD->ImmediateData)->bControl |= PACKET_CONTROL_SACK_MASK1;
		}
		if(pEPD->ulReceiveMask2)
		{
			pMasks->rgMask[index++] = pEPD->ulReceiveMask2;
			((PDFRAME) pFMD->ImmediateData)->bControl |= PACKET_CONTROL_SACK_MASK2;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
	}

	//	MUST NOT transmit the SendMasks with a retry because they are based on the CURRENT bNextSend value which is not
	// the N(S) that appears in this frame.  We could theoretically shift the mask to agree with this frame's sequence
	// number,  but that might shift relevent bits out of the mask.  Best thing to do is to let the next in-order send carry
	// the bit-mask or else wait for the timer to fire and send a dedicated packet.
	
	//	PLEASE NOTE -- Although we may change the size of the immediate data below we did not update the FMD->uiFrameLength
	// field.  This field is used to credit the send window when the frame is acknowledged,  and we would be wise to credit
	// the same value that we debited back when this frame was first sent.  We could adjust the debt now to reflect the new
	// size of the frame, but seriously, why bother?
	
	pFMD->uiImmediateLength = sizeof(DFRAME) + (index * 4);
	
	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

	// Stop delayed ack timer
	if(pEPD->DelayedAckTimer != 0)
	{						
		LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedAckTimer)"); // SendQLock not already held
			pEPD->DelayedAckTimer = 0;
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
	}
	// Stop delayed mask timer
	if(((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)&&(pEPD->DelayedMaskTimer != 0))
	{	
		LOGPF(7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedMaskTimer)"); // SendQLock not already held
			pEPD->DelayedMaskTimer = 0;
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
	}
}

/*
**			Service Command Traffic
**
**		Presently this transmits all CFrames and Datagrams queued to the specific
**	Service Provider.  We may want to split out the datagrams from this so that
**	C frames can be given increased send priority but not datagrams.  With this
**	implementation DGs will get inserted into reliable streams along with Cframes.
**	This may or may not be what we want to do...
**
**	WE ENTER AND EXIT WITH SPD->SENDLOCK HELD,  although we release it during actual
**	calls to the SP.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "ServiceCmdTraffic"

#ifdef DEBUG
LONG g_FramesSent=0;
#endif

VOID ServiceCmdTraffic(PSPD pSPD)
{
	CBilink	*pFLink;
	PFMD	pFMD;
	HRESULT	hr;

	// WHILE there are frames ready to send
	while((pFLink = pSPD->blSendQueue.GetNext()) != &pSPD->blSendQueue)
	{	
		pFLink->RemoveFromList();												// Remove frame from queue

		pFMD = CONTAINING_RECORD(pFLink,  FMD,  blQLinkage);		// get ptr to frame structure

		ASSERT_FMD(pFMD);

		// Place frame on pending queue before making call in case it completes really fast

		ASSERT(!pFMD->bSubmitted);
		pFMD->bSubmitted = TRUE;
		pFMD->blQLinkage.InsertBefore( &pSPD->blPendingQueue);		// Place frame on pending queue
		Unlock(&pSPD->SendQLock);

#ifdef	FRAME_DROPS
		((PPacketHeader) pFMD->ImmediateData)->State = GOOD_STATE;

		if(BadFrames)
			if((rand() % BadFrames) == 0)
				((PPacketHeader) pFMD->ImmediateData)->State = DROP_STATE;
#endif
#ifdef DEBUG
		InterlockedIncrement(&g_FramesSent);
#endif
		
		LOGPF(6, "Calling SP->SendData for FMD[%p]", pFMD);
/*send*/if((hr = IDP8ServiceProvider_SendData(pSPD->IISPIntf, &pFMD->SendDataBlock)) != DPNERR_PENDING)
		{
			LOGPF(6, "Calling our own CommandComplete since SP did not return DPNERR_PENDING");
			(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, (PVOID) pFMD);
		}

		Lock(&pSPD->SendQLock);
	}	// While SENDs are on QUEUE
}

/*
**		Run Send Thread
**
**		There is work for this SP's send thread.  Keep running until
**	there is no more work to do.
**
**		Who gets first priority, DG or Seq traffic?  I will  say DG b/c its
**	advertised as lowest overhead...
**
**		Datagram packets get Queued on the SP when they are ready to ship.
**	Reliable packets are queued on the EPD.  Therefore,  we will queue the
**	actual EPD on the SPD when they have reliable traffic to send,  and then
**	we will service individual EPDs from this loop.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RunSendThread"

VOID RunSendThread(PVOID uID, UINT Unique, PVOID pvUser)
{
	PEPD	pEPD;
	CBilink	*pELink;
	PSPD	pSPD = (PSPD) pvUser;

	LOGPF(7, "Send Thread Runs pSPD[%p]", pSPD);
	Lock(&pSPD->SendQLock);

	pSPD->SendHandle = NULL;

	if(!pSPD->blSendQueue.IsEmpty())
	{
		ServiceCmdTraffic(pSPD);
	}

	while((pELink = pSPD->blPipeQueue.GetNext()) != &pSPD->blPipeQueue)
	{
		pEPD = CONTAINING_RECORD(pELink, EPD, blSPLinkage);
		ASSERT(pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE);

		pEPD->blSPLinkage.RemoveFromList();							// Remove next EPD from pipeline
		
		Unlock(&pSPD->SendQLock);

		Lock(&pEPD->EPLock);

		ServiceEPD(pSPD, pEPD);								// Drain one burst from this Endpoint

		Lock(&pSPD->SendQLock);

		// Transmit CFrames between each EPD
		if(!pSPD->blSendQueue.IsEmpty())
		{				
			ServiceCmdTraffic(pSPD);
		}
	}

	pSPD->ulSPFlags &= ~(SPFLAGS_SEND_THREAD_SCHEDULED);
	Unlock(&pSPD->SendQLock);
}

/*
**		Scheduled Send
**
**		If this EPD is still unentitled to send, start draining frames.  Otherwise transition
**	link to IDLE state.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ScheduledSend"

VOID CALLBACK
ScheduledSend(PVOID uID, UINT Unique, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;
	PSPD	pSPD = pEPD->pSPD;

	Lock(&pEPD->EPLock);
	
	pEPD->SendTimer = 0;

	LOGPF(7, "(%p) Scheduled Send Fires", pEPD);

	ASSERT(pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE);

	// Test that all three flags are set before starting to transmit

	if( (pEPD->ulEPFlags & EPFLAGS_CONNECTED) && (
			((pEPD->ulEPFlags & (EPFLAGS_STREAM_UNBLOCKED | EPFLAGS_SDATA_READY)) == (EPFLAGS_STREAM_UNBLOCKED | EPFLAGS_SDATA_READY))
			|| (pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED))) 
	{

		ServiceEPD(pEPD->pSPD, pEPD);
	}
	else
	{
		LOGPF(7, "(%p) Session leaving pipeline", pEPD);
		
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);
		pEPD->ulEPFlags |= EPFLAGS_IDLED_PIPELINE;
		pEPD->tStartIdle = GETTIMESTAMP();
		Unlock(&pEPD->EPLock);
		
		RELEASE_EPD(pEPD, "UNLOCK (SchedSend done)"); // SendQLock not already held
	}
}

/*
**		Service EndPointDescriptor
**
**		Drain up to BurstSizeBytes from this Endpoint,  where BurstSizeBytes is determined
**	by our adaptive throttling algorithm.  This includes reliable,  datagram,  and re-transmit
**	frames.  Retransmissions are ALWAYS transmitted first,  regardless of the orginal message's
**	priority.  After that datagrams and reliable messages are taken in priority order, in FIFO
**	order within a priority class.
**
**		The number of frames drained depends upon the measured link speed.  If the burst gap is
**	larger then 10ms we will only send one frame,  and then scale down the burst gap according
**	to the fraction of the available byte-window that was used.
**
**	CODEWORK->  if they send < 1/8th of the burst allowance,  maybe let them send another frame
**
**		If the burst gap is small (<10ms) then we will routinely allow multiple sends per burst.
**	If the burst is not filled precisely we can remember the difference and either credit or debit
**	the next burst accordingly.  Now, we dont want to credit too much or we start to mess up the
**	throttle concept of spreading out the load.  But we can still debit for overloads.  Here is
**	what we'd like to do:  If we have almost filled the burst,  do not send another max size frame
**	and create a really big debit.  Instead,  credit the leftover and maybe an extra will fit next time.
**	Otherwise,  allow us to send into debt (say up to 25% over).
**
**
**		If the pipeline goes idle or the stream gets blocked will we still schedule the next
**	send.  This way if we unblock or un-idle before the gap has expired we will not get to cheat
**	and defeat the gap.  The shell routine above us (ScheduledSend) will take care of removing us
**	from the pipeline if the next burst gets scheduled and we are still not ready to send.
**
**
**	** CALLED WITH EPD->EPLock HELD;  Returns with EPLock RELEASED **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ServiceEPD"

VOID ServiceEPD(PSPD pSPD, PEPD pEPD)
{
	PMSD		pMSD;
	PFMD		pFMD;
	CBilink		*pLink, *pFLink;
	INT			iBurstAvail;
	INT			iBurstSent = 0;
	INT			iDelta;
	INT			iHalf, iQuarter, iEighth;
	UINT		uiFramesSent = 0;
	UINT		uiUseBurstGap;
	HRESULT		hr;
	DWORD		tNow = GETTIMESTAMP();


	/*
	** 		Now we will drain reliable traffic from EPDs on the pipeline list
	*/

	if( ( pEPD->ulEPFlags & EPFLAGS_CONNECTED ) == 0 )
	{
		LOGPF(7, "(%p) Not connected", pEPD);
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (Discon in ServiceEPD)"); // SendQLock not already held
		return;
	}
/*
	tBurstDelta = tNow - pEPD->tLastBurst;					// Calculate actual frequency of bursts
	pEPD->tLastBurst = tNow;

	pEPD->fpAvgBurstGap -= pEPD->fpAvgBurstGap / 8;			// let average decay
	pEPD->fpAvgBurstGap += TO_FP(tBurstDelta) / 8;			// add new data
*/
	// Burst Credit can either be positive or negative depending upon how much of our last transmit slice we used

	if(pEPD->uiBurstGap == 0)
	{
		iBurstAvail = 0x7FFFFFFF;							// If no packet gap enforced,  allow unlimited transmission
		uiUseBurstGap = 0;
		LOGPF(7, "(%p) BEGIN UNLIMITED BURST", pEPD);
	}
	else
	{
		iBurstAvail = pEPD->iBurstSizeBytes + pEPD->iBurstCredit;
		uiUseBurstGap = pEPD->uiBurstGap;
		LOGPF(7, "(%p) BEGIN CONTROLLED BURST: Gap(%d) %d bytes avail (%d BurstSize; %d credit)", pEPD, uiUseBurstGap, iBurstAvail, pEPD->iBurstSizeBytes, pEPD->iBurstCredit);
	}

	//	 Transmit a burst from this EPD,  as long as its unblocked and has data ready.  We do not re-init
	// burst counter since any retries sent count against our burst limit
	//
	//	This has become more complex now that we are interleaving datagrams and reliable frames.  There are two
	// sets of priority-based send queues.  The first is combined DG and Reliable and the second is datagram only.
	// when the reliable stream is blocked we will feed from the DG only queues,  otherwise we will take from the
	// interleaved queue.
	//	This is further complicated by the possibility that a reliable frame can be partially transmitted at any time.
	// So before looking at the interleaved queues we must check for a partially completed reliable send (EPD.pCurrentSend).
	//
	//	** pEPD->EPLock is held **

	while( 		(((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED) && (pEPD->ulEPFlags & EPFLAGS_SDATA_READY)) 
				|| (pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED))
				&& (iBurstSent < iBurstAvail))
	{


		// When burstsize is large we will decrease the next burst gap instead of sending additional
		// frames to fill the burst.

		if((pEPD->uiBurstGap > 10) && (uiFramesSent > 0))
		{
			LOGPF(7, "(%p) Burst Gap is large", pEPD);
			// BurstGap is large enough that we can subdivide it to credit the balance of this burst
			break;
		}

		// Always give preference to shipping retries before new data

		if(pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED)
		{
			pLink = pEPD->blRetryQueue.GetNext();
			pFMD = CONTAINING_RECORD(pLink, FMD, blQLinkage);
			pLink->RemoveFromList();
			pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue
			if(pEPD->blRetryQueue.IsEmpty())
			{
				pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
			}

			BuildRetryFrame(pEPD, pFMD);							// Place currect state information in retry frame
			
			LOGPF(7, "(%p) Shipping RETRY frame: Seq=%x, FMD=%p Size=%d", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD, pFMD->uiFrameLength);

			iBurstSent += pFMD->uiFrameLength;
			uiFramesSent++;
		}
		else 
		{
			if((pMSD = pEPD->pCurrentSend) != NULL)
			{
				ASSERT_MSD(pMSD);
				pFMD = pEPD->pCurrentFrame;						// Get the next frame due to send
				ASSERT_FMD(pFMD);
				ASSERT((pFMD->ulFFlags & FFLAGS_TRANSMITTED)==0);
			}
			else 
			{
				if( (pLink = pEPD->blHighPriSendQ.GetNext()) == &pEPD->blHighPriSendQ)
				{
					if( (pLink = pEPD->blNormPriSendQ.GetNext()) == &pEPD->blNormPriSendQ)
					{
						if( (pLink = pEPD->blLowPriSendQ.GetNext()) == &pEPD->blLowPriSendQ)
						{
							break;								// All finished sending for now
						}
					}
				}
				pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
				ASSERT_MSD(pMSD);
				ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
				pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);

				pLink->RemoveFromList();
				ASSERT(pEPD->uiQueuedMessageCount > 0);
				--pEPD->uiQueuedMessageCount;						// keep count of MSDs on all send queues
				
				pMSD->ulMsgFlags2 |= MFLAGS_TWO_TRANSMITTING;		// We have begun to transmit frames from this Msg

				pEPD->pCurrentSend = pMSD;
				pFMD = pEPD->pCurrentFrame = CONTAINING_RECORD(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
				ASSERT_FMD(pFMD);
				ASSERT((pFMD->ulFFlags & FFLAGS_TRANSMITTED)==0);
				pFMD->bPacketFlags |= PACKET_COMMAND_NEW_MSG;
				pMSD->blQLinkage.InsertBefore( &pEPD->blCompleteSendList);	// Place this on PendingList now so we can keep track of it
			}

			BuildDataFrame(pEPD, pFMD);								// place current state info in frame
			
			pFMD->blWindowLinkage.InsertBefore( &pEPD->blSendWindow); // Place at trailing end of send window
			pFMD->ulFFlags |= FFLAGS_IN_SEND_WINDOW;
			LOCK_FMD(pFMD);											// Add reference for send window

			pEPD->iUnackedBytes += pFMD->uiFrameLength;				// Track the unacknowleged bytes in the pipeline

			// We can always go over the limit, but will be blocked until we drop below the limit again.
			if(pEPD->iUnackedBytes >= pEPD->iWindowB)
			{				
				pEPD->ulEPFlags &= ~(EPFLAGS_STREAM_UNBLOCKED);	
				pEPD->ulEPFlags |= EPFLAGS_FILLED_WINDOW_BYTE;		// Tells us to increase window if all is well
				
	  			((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; // Request immediate reply
#ifdef POLL_COUNT	
				pEPD->uiPollCount = pEPD->uiPollFrequency;
#endif
			}
			
			// Count frames in the send window
			if((++pEPD->iUnackedFrames) >= pEPD->iWindowF)
			{			
				pEPD->ulEPFlags &= ~(EPFLAGS_STREAM_UNBLOCKED);
				((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; // Request immediate reply
#ifdef POLL_COUNT	
				pEPD->uiPollCount = pEPD->uiPollFrequency;
#endif
				pEPD->ulEPFlags |= EPFLAGS_FILLED_WINDOW_FRAME;		// Tells us to increase window if all is well
			}
			
			// We will only run one retry timer for each EndPt.  If we already have one running then do nothing.

			// If there was already a frame in the pipeline it should already have a clock running
#ifdef	DEBUG
			if((pEPD->iUnackedFrames == 1) && (UseRetry))
#else
			if(pEPD->iUnackedFrames == 1)
#endif
			{
				ASSERT(pEPD->RetryTimer == 0);
				pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;			// This one is being measured
				LOCK_EPD(pEPD, "LOCK (set retry)");										// bump RefCnt for timer
				LOGPF(7, "(%p) Setting Retry Timer on N(R)=0x%x, FMD=%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
				SetMyTimer(pEPD->uiRetryTimeout, 0, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique);
			}
			else
			{
				ASSERT((pEPD->RetryTimer != 0)||(UseRetry == 0));
			}
			LOCK_EPD(pEPD, "LOCK (Send Data Frame)");				// Keep EPD around while xmitting frame

			pFLink = pFMD->blMSDLinkage.GetNext();						// Get next frame in Msg

			// Was this the last frame in Msg?
			if(pFLink == &pMSD->blFrameList)
			{						
				// Last frame in message has been sent.
				//
				// We used to setup the next frame now,  but with the multi-priority queues it makes more sense to look for the
				// highest priority send when we are ready to send it.
				
				pEPD->pCurrentSend = NULL;
				pEPD->pCurrentFrame = NULL;

				// When completing a send,  set the POLL flag if there are no more sends on the queue

				// Request immediate reply if no more data to send
				if(pEPD->uiQueuedMessageCount == 0)
				{					
					((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; 
				}
			}
			else 
			{
				pEPD->pCurrentFrame = CONTAINING_RECORD(pFLink, FMD, blMSDLinkage);
			}
			LOGPF(7, "(%p) Shipping Dataframe: Seq=%x, NRcv=%x FMD=%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, ((PDFRAME) pFMD->ImmediateData)->bNRcv, pFMD);
			
			uiFramesSent++;											// Count frames sent this burst
			pEPD->uiFramesSent++;									// Count total data transmitted
			pEPD->uiBytesSent += pFMD->uiFrameLength;
			iBurstSent += pFMD->uiFrameLength;

			// KEEPING DETAILED STATS REQUIRES EXTRA CONDITIONAL

			if(pFMD->ulFFlags & FFLAGS_RELIABLE)
			{
				pEPD->uiGuaranteedFramesSent++;
				pEPD->uiGuaranteedBytesSent += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
			}
			else 
			{
				pEPD->uiDatagramFramesSent++;
				pEPD->uiDatagramBytesSent += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
			}
			LOCK_FMD(pFMD);											// Bump RefCnt when submitting Rely Sends
		}

		// PROCEED WITH TRANSMISSION...

		Lock(&pSPD->SendQLock);
		ASSERT(!pFMD->bSubmitted);
		pFMD->ulFFlags |= FFLAGS_TRANSMITTED;					// Frame will be owned by SP
		pFMD->bSubmitted = TRUE;
		pFMD->blQLinkage.InsertBefore( &pSPD->blPendingQueue);	// Place frame on pending queue
		Unlock(&pSPD->SendQLock);

		pEPD->fpDropsPer128Frames -= pEPD->fpDropsPer128Frames >> 8;

		Unlock(&pEPD->EPLock);

#ifdef	FRAME_DROPS
		((PPacketHeader) pFMD->ImmediateData)->State = GOOD_STATE;

		if(BadFrames)
			if((rand() % BadFrames) == 0)
				((PPacketHeader) pFMD->ImmediateData)->State = DROP_STATE;
#endif

#ifdef DEBUG
		InterlockedIncrement(&g_FramesSent);
#endif

		LOGPF(6, "Calling SP->SendData for FMD[%p]", pFMD);
/*send*/if((hr = IDP8ServiceProvider_SendData(pSPD->IISPIntf, &pFMD->SendDataBlock)) != DPNERR_PENDING)
		{
			LOGPF(6, "Calling our own CommandComplete since SP did not return DPNERR_PENDING");
			(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, (PVOID) pFMD);
		}

		Lock(&pEPD->EPLock);
		
	}	// WHILE (unblocked, undrained, & bandwidth credit avail)

	if((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED)==0)
	{
		pEPD->uiWindowFilled++;								// Count the times we filled the window
	}

	// Clear data-ready flag if everything is sent
	if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
	{	
		pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
	}

	// Determine how much of our transmit allowance we used and either credit or debit our next cycle.
	// However,  if we are only crediting one send/burst then we can modify the Gap instead

	iDelta = iBurstAvail - iBurstSent;							// Did we send too much or too little

	if(pEPD->uiBurstGap > 10)
	{
		if(iDelta > 0)
		{
			// We did not use our full burst credit to transmit.  Therefore we will schedule our next burst early.
			// We will aproximate this with quarters...

			iHalf = iBurstAvail >> 1;							// One half allocation
			iQuarter = iBurstAvail >> 2;						// One quarter of our allocation
			iEighth = iBurstAvail >> 4;							// One Eighth allocation

			// binary search to find which (octile or quartile) our send load falls into
			if(iBurstSent > (iHalf))
			{
				// used over 50% of credit
				if(iBurstSent > (iQuarter + iHalf))
				{
					// used 75 - 100%
					if(iBurstSent > (iBurstAvail - iEighth))
					{
						// Use Full Gap:  over 88% used
					}
					else
					{
						uiUseBurstGap -= (uiUseBurstGap >> 3);	// subtract 12% from gap
					}
				}
				else 
				{
					// used 50 - 75%
					if(iBurstSent > (iHalf + iEighth))
					{
						uiUseBurstGap -= (uiUseBurstGap >> 2);	// subtract 25% from gap
					}
					else
					{
						uiUseBurstGap -= ((uiUseBurstGap >> 2) + (uiUseBurstGap >> 3)); // subtract 33% from gap
					}
				}
			}
			else 
			{
				// used less then 50% of send credit
				if(iBurstSent > (iQuarter))
				{
					if(iBurstSent > (iQuarter + iEighth))
					{
						// used 25 - 50%
						uiUseBurstGap >>= 1;					// subrtact 50% from gap
					}
					else
					{
						uiUseBurstGap -= ((uiUseBurstGap >> 1) + (uiUseBurstGap >> 3));	// subtract 62%
					}
				}
				else 
				{
					// used 1 - 25%
					if(iBurstSent > iEighth)
					{
						uiUseBurstGap >>= 2;					// subtract 75% from gap
					}
					else
					{
						uiUseBurstGap >>= 3;					// subtract 88% from gap
					}
				}
			}

			pEPD->iBurstCredit = 0;
			LOGPF(7, "(%p) Short Burst Completed (%d bytes); Reducing gap from %d to %d", pEPD, iBurstSent, pEPD->uiBurstGap, uiUseBurstGap);
		}
		else if (iDelta < 0)
		{
			LOGPF(7, "(%p) Burst completed with debt of %d bytes", pEPD, iDelta);
			pEPD->iBurstCredit = iDelta;						// For large bursts,  simply carry extra forward to next cycle
		}
		
	}
	else if (iDelta < 0)
	{
		LOGPF(7, "(%p) Incurring debt of %d bytes against next burst", pEPD, iDelta);
		
		pEPD->iBurstCredit = iDelta;						// For large bursts,  simply carry extra forward to next cycle
	}
	else
	{
		LOGPF(7, "(%p) Short burst interval, dropping left-over burst credit", pEPD);
		// We will drop left-over credit when we are using short burst intervals...
		pEPD->iBurstCredit = 0;								// For large bursts,  simply carry extra forward to next cycle
	}
	
	// As commented in procedure-header above,  we will remain on the pipeline for one timer-cycle
	// so that if we unblock or un-idle we will not send until the gap is fullfilled.

	if((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED)) ==
							(EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED))
	{		// IF BOTH flags are set
		LOGPF(7, "(%p) %d frame BURST COMPLETED - Sched next send in %dms, N(Seq)=%x", pEPD, uiFramesSent, uiUseBurstGap, pEPD->bNextSend);
	}
	else if((pEPD->ulEPFlags & EPFLAGS_SDATA_READY)==0)
	{
		LOGPF(7, "(%p) %d frame BURST COMPLETED  (%d / %d)- LINK IS IDLE N(Seq)=%x", pEPD, uiFramesSent, pEPD->iUnackedFrames, pEPD->iWindowF, pEPD->bNextSend);
	}
	else
	{
		ASSERT((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED)==0);
		LOGPF(7, "(%p) %d frame BURST COMPLETED (%d / %d) - STREAM BLOCKED N(Seq)=%x", pEPD, uiFramesSent, pEPD->iUnackedFrames, pEPD->iWindowF, pEPD->bNextSend);
	}

	pEPD->tNextSend = tNow + pEPD->uiBurstGap;	// Record when we are next allowed to transmit (for now this is info only)
	ASSERT(pEPD->SendTimer == 0);

	if(pEPD->uiBurstGap != 0)
	{
		LOGPF(7, "(%p) Setting Scheduled Send Timer for %d ms", pEPD, uiUseBurstGap);
		SetMyTimer(uiUseBurstGap, 4, ScheduledSend, (PVOID) pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
		Unlock(&pEPD->EPLock);
	}
	else 
	{
		LOGPF(7, "(%p) Session leaving pipeline", pEPD);
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);
		pEPD->ulEPFlags |= EPFLAGS_IDLED_PIPELINE;
		pEPD->tStartIdle = GETTIMESTAMP();
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (leaving pipeline)"); // SendQLock not already held
	}
}	

/*
**			Retry Timeout
**
**		Retry timer fires when we have not seen an acknowledgement for a packet
**	we sent in more then twice (actually 1.25 X) our measured RTT.  Actually,  that is
**	just our base calculation.  We will also measure empirical ACK times and adjust our timeout
**	to some multiple of that.  Remember that our partner may be delaying his Acks to wait for back-traffic.
**
**  Or we can measure avg deviation of Tack and base retry timer on that.
**
**		In any case,  its time to re-transmit the base frame in our send window...
**
**		Important note:  Since we can generate retries via bitmask in return traffic,  it is possible that
**	we have just retried when the timer fires.
**
**		Note on Locks:  Since the retry timer is directly associated with an entry on the EPD SendQueue,
**	we always protect retry-related operations with the EPD->SendQLock.   We only hold the EPD->StateLock
**	when we mess with link state variables (NRcv,  DelayedAckTimer).
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RetryTimeout"

#ifdef DEBUG
LONG g_RetryCount[MAX_RETRIES+1]={0,0,0,0,0,0,0,0,0,0,0};
#endif

VOID CALLBACK
RetryTimeout(PVOID uID, UINT Unique, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;
	PFMD	pFMD;
	DWORD	tNow = GETTIMESTAMP(), tDelta;
	UINT	delta;

	Lock(&pEPD->EPLock);

	LOGPF(7, "(%p) Retry Timeout fires", pEPD);

	if((pEPD->ulEPFlags & EPFLAGS_CONNECTED) == 0)
	{				// Make sure link is still active
		LOGPF(7, "(%p) Not connected, exiting", pEPD);
		pEPD->RetryTimer = 0;
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (retry timer not-CONN)");		// Decrement RefCnt for timer, SendQLock not already held
		return;
	}

	// Its possible when we schedule a new retry timer that the previous timer cannot be cancelled. In this
	// case the timer Handle &| Unique field will be different,  and we do not want to run the event.

	if((pEPD->RetryTimer != uID) || (pEPD->RetryTimerUnique != Unique))
	{	// Make sure this isnt a leftover event
		LOGPF(7, "(%p) Stale retry timer, exiting", pEPD);
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (stale retry timer)"); // SendQLock not already held
		return;
	}

	pEPD->RetryTimer = 0;

	// Make sure that we still have transmits in progress

	if(pEPD->iUnackedFrames > 0) 
	{
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);	// Top frame in window

		ASSERT_FMD(pFMD);
		ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);

		//	First we must make sure that the TO'd packet is still hanging around.  Since the first packet
		// in the window might have changed while the TO was being scheduled,  the easiest thing to do is
		// just recalculate the top packets expiration time and make sure its really stale.

		tDelta = tNow - pFMD->tTimestamp[pFMD->uiRetry];		// When did we last send this frame?

		if(tDelta > pEPD->uiRetryTimeout)
		{
			// Its a genuine timeout.  Lets retransmit the frame!

			LOGPF(7, "(%p) RETRY TIMEOUT %d on N(S)=%x, pFMD=0x%p", pEPD, (pFMD->uiRetry + 1), ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);

			// Count a retry
			if(++pFMD->uiRetry > MAX_RETRIES)
			{					
				// BOOM!  No more retries.  We are finished.  Link is going DOWN!
				LOGPF(1, "(%p) DROPPING LINK,  retries exhausted", pEPD);
				DropLink(pEPD);									// releases SendQLock
				RELEASE_EPD(pEPD, "UNLOCK (retry timer drop)");// Release reference for this timer, SendQLock not already held
				return;
			}

#ifdef DEBUG
			InterlockedIncrement(&g_RetryCount[pFMD->uiRetry]); 
#endif

			// calculate timeout for next retry
			if(pFMD->uiRetry == 1)
			{
				// do a retry at the same timeout - this is games after all.
				tDelta = pEPD->uiRetryTimeout;
			} 
			else if (pFMD->uiRetry <= 3) 
			{
				// do a couple of linear backoffs - this is a game after all
				tDelta = pEPD->uiRetryTimeout * pFMD->uiRetry;
			}
			else if (pFMD->uiRetry < 8)
			{
				// doh, bad link, bad bad link, do exponential backoffs
				tDelta = pEPD->uiRetryTimeout * (1 << pFMD->uiRetry);
			} 
			else 
			{
				// don't give up too quickly.
				tDelta = MAX_RETRY_INTERVAL;
			}
			
			if(tDelta >= MAX_RETRY_INTERVAL)
			{
				// CAP TOTAL DROP TIME AT 50 seconds.
				tDelta = MAX_RETRY_INTERVAL;
				if(tDelta < pEPD->uiRTT)
				{
					tDelta = pEPD->uiRTT;
				}
			}

			// Unreliable frame!
			if(pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM)
			{		
				// When an unreliable frame is NACKed we will not retransmit the data.  We will instead send
				// an empty frame with its Seq number so the reliable engine knows it can move on

				LOGPF(7, "(%p) RETRY TIMEOUT for UNRELIABLE FRAME", pEPD);

				// We get to credit the data portion of the frame as out of the window,  but not the header which we are
				// retransmitting.  Now,  we may not want to do this.  It provides tighter congestion control if we dont
				// yield the window space until the acknowledge succeeds.

				pEPD->iUnackedBytes -= pFMD->uiFrameLength;

				// Only count a datagram drop on the first occurance
				if(pFMD->uiRetry == 1)
				{
					pEPD->uiDatagramFramesDropped++;	
					pEPD->uiDatagramBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
					EndPointDroppedFrame(pEPD, tNow);
				}

				// Diff between next send and this send.
				delta = (pEPD->bNextSend - ((PDFRAME) pFMD->ImmediateData)->bSeq) & 0xFF ; 

				ASSERT(delta != 0);
				ASSERT(delta < (MAX_RECEIVE_RANGE + 1));

				if(delta < 33)
				{
					pEPD->ulSendMask |= (1 << (delta - 1));
				}
				else
				{
					pEPD->ulSendMask2 |= (1 << (delta - 33));
				}

				pFMD->uiFrameLength = 0;
				pEPD->ulEPFlags |= EPFLAGS_DELAYED_SENDMASK;
				
				if(pEPD->DelayedMaskTimer == 0)
				{
					LOGPF(7, "(%p) Setting Delayed Mask Timer", pEPD);
					LOCK_EPD(pEPD, "LOCK (delayed mask timer - send retry)");
					SetMyTimer(DELAYED_SEND_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
				}
			}

			// RELIABLE FRAME -- Send a retry	
			else 
			{		
				pEPD->uiGuaranteedFramesDropped++;							// Keep count of lost frames
				pEPD->uiGuaranteedBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);	// Keep count of lost frames
#ifdef	FRAME_NAMES
				((PDFRAME) pFMD->ImmediateData)->Name = RETRY_NAME;
#endif	// FRAME_NAMES
				pFMD->tTimestamp[pFMD->uiRetry] = tNow;

				pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);		// No longer waiting to send Ack info

				// Stop delayed ack timer
				if(pEPD->DelayedAckTimer != 0)
				{
					LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
					if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
					{
						RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedAck)"); // SendQLock not already held
					}
					else
					{
						LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					}
					pEPD->DelayedAckTimer = 0;
				}

				EndPointDroppedFrame(pEPD, tNow);

				if(pFMD->ulFFlags & FFLAGS_RETRY_QUEUED)
				{
					// It's still on the Retry Queue.  This should not happen when everything is working
					// properly.  Timeouts should be greater then RTT and the BurstGap should be less then RTT.

					LOGPF(1, "(%p) RETRY FIRES WHILE FMD IS STILL IN RETRY QUEUE pFMD=%p", pEPD, pFMD);
					LOGPF(1, "(%p) BurstGap = %d; RTT = %d", pEPD, pEPD->uiBurstGap, pEPD->uiRTT);

					pFMD = NULL;
				}
				else if(pFMD->bSubmitted)
				{
					// Woe on us.  We would like to retry a frame that has not been completed by the SP!
					//
					//		This will most typically happen when we are debugging which delays processing
					//	of the Complete,  but it could also happen if the SP is getting hammered.  We need
					//	to copy the FMD into a temporary descriptor which can be discarded upon completion...

					LOGPF(1,"(%p) RETRYING %p but its still busy. Substituting new FMD", pEPD, pFMD);
					pFMD = CopyFMD(pFMD, pEPD);							// We will substitute new FMD in rest of procedure
				}
				else 
				{
					LOGPF(7, "(%p) Sending Retry of N(S)=%x, pFMD=0x%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
					LOCK_FMD(pFMD);
				}

				if(pFMD)
				{
					LOCK_EPD(pEPD, "LOCK (retry rely frame)");
					pEPD->ulEPFlags |= EPFLAGS_RETRIES_QUEUED;
					pFMD->ulFFlags |= FFLAGS_RETRY_QUEUED;
					pFMD->blQLinkage.InsertBefore( &pEPD->blRetryQueue);		// Place frame on Send queue

					if((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
					{
						LOGPF(7, "(%p) Scheduling Send", pEPD);
						pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
						LOCK_EPD(pEPD, "LOCK (pipeline)");
						ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
					}
				}
			}	// ENDIF RETRY
			
		}
		else 
		{
			tDelta = pEPD->uiRetryTimeout - tDelta;
		}

		LOGPF(7, "(%p) Setting Retry Timer for %d ms", pEPD, tDelta); 
		//	Dont LOCK_EPD here because we never released the lock from the timer which scheduled us here
		SetMyTimer(tDelta, 20, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique);
	}
	else 
	{
		RELEASE_EPD(pEPD, "UNLOCK (RetryTimer no frames out)");				// drop RefCnt since we dont restart timer, SendQLock not already held
	}

	Unlock(&pEPD->EPLock);
}

/*
**		Copy FMD
**
**			This routine allocates a new Frame Descriptor and copies all fields from the provided
**		FMD into it.  All fields except CommandID,  RefCnt,  and Flags.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CopyFMD"

PFMD CopyFMD(PFMD pFMD, PEPD pEPD)
{
	PFMD	pNewFMD;

	if((pNewFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{
		LOGPF(0, "Failed to allocate new FMD");
		return NULL;
	}

	LOCK_EPD(pEPD, "LOCK (CopyFMD)");

	memcpy(pNewFMD, pFMD, sizeof(FMD));
	pNewFMD->CommandID = COMMAND_ID_COPIED_RETRY;
	pNewFMD->uiRefCnt = 1;
	pNewFMD->ulFFlags = FFLAGS_IN_USE;
	pNewFMD->bSubmitted = FALSE;

	pNewFMD->lpImmediatePointer = (LPVOID) pNewFMD->ImmediateData;
	pNewFMD->SendDataBlock.pBuffers = (PBUFFERDESC) &pNewFMD->uiImmediateLength;
	pNewFMD->SendDataBlock.pvContext = pNewFMD;
	pNewFMD->SendDataBlock.hCommand = 0;
	ASSERT(	pNewFMD->pEPD == pEPD ) ;

	LOGPF(7, "COPYFMD -- replacing FMD %p with copy %p", pFMD, pNewFMD);

	return pNewFMD;
}

/*			
**			Send Command Frame
**
**		Build a CFrame addressed to the specified EndPoint, and Queue it on the SPD
**	to be sent.
**
**	** THIS FUNCTION CALLED AND RETURNS WITH EPD->EPLOCK HELD **
*/

#ifdef	FRAME_NAMES
DWORD	NameTable[] = 
{
	POLL_NAME,			// NOP	(we will overwrite RESP frames)
	CONNECT_NAME,
	CONNECTED_NAME,
	DISCON_NAME,
	DISCONED_NAME,
	0,					// REJECT
	ACK_NAME,
	DG_ACK_NAME,
};
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "SendCommandFrame"

HRESULT	SendCommandFrame(PEPD pEPD, BYTE ExtOpcode, BYTE RspID)
{
	PSPD		pSPD = pEPD->pSPD;
	PFMD		pFMD;
	PCFRAME		pCFrame;
	PCHKPT		pChkPt;
	DWORD		tNow = GETTIMESTAMP();

	// Frame already initialized to 1 buffer
	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{				
		LOGPF(0, "(%p) Failed to allocate new FMD", pEPD);
		return DPNERR_OUTOFMEMORY;
	}

	pFMD->pEPD = pEPD;										// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (Prep Cmd Frame)");				// Bump RefCnt on EPD until send is completed
	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;										// this will indicate a NON-Data frame
	pFMD->uiImmediateLength = sizeof(CFRAME);				// standard size for C Frames
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;			// Place address in frame
	pFMD->uiFrameLength = sizeof(CFRAME);					// Never have user data in Cframe

	pCFrame = (PCFRAME) pFMD->ImmediateData;

#ifdef	FRAME_NAMES
	pCFrame->Name = NameTable[ExtOpcode];
#endif
	pCFrame->bCommand = PACKET_COMMAND_CFRAME;
	pCFrame->bExtOpcode = ExtOpcode;
	pCFrame->dwVersion = DNET_VERSION_NUMBER;
	pCFrame->bRspID = RspID;
	pCFrame->dwSessID = pEPD->dwSessID;
	pCFrame->tTimestamp = tNow;

	// If this frame requires a response (or if we are specifically asked to) we will build
	// a Checkpoint structure which will be stored to correlate the eventual response with
	// the original frame.

	if(	(pEPD->ulEPFlags & EPFLAGS_CHECKPOINT_INIT)||
		(ExtOpcode == FRAME_EXOPCODE_CONNECT)) 
	{
		if((pChkPt = static_cast<PCHKPT>( ChkPtPool->Get(ChkPtPool) )) != NULL)
		{
			pChkPt->bMsgID = pEPD->bNextMsgID;				// Note next ID in CP structure
			pCFrame->bCommand |= PACKET_COMMAND_POLL;		// make this frame a CP
			pEPD->ulEPFlags &= ~EPFLAGS_CHECKPOINT_INIT;
			pChkPt->tTimestamp = tNow;
			pChkPt->blLinkage.InsertBefore( &pEPD->blChkPtQueue);
		}
	}
	pCFrame->bMsgID = pEPD->bNextMsgID++;					// include MsgID in frame

	Lock(&pSPD->SendQLock);							// Place SACK frame on send queue
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
	if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
	{
		LOGPF(7, "(%p) Scheduling Send Thread", pEPD);
		pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
		ScheduleTimerThread(RunSendThread, pSPD, &pSPD->SendHandle, &pSPD->SendHandleUnique);	
	}
	Unlock(&pSPD->SendQLock);

	return DPN_OK;
}


/*
**		Send Ack Frame
**
**		This routine is called to immediately transmit our current receive
**	state to the indicated EndPoint.  This is equivalent to acknowledging
**	all received frames.  We may want to change this routine so that it
**	will attempt to piggyback the ack if there is data waiting to be sent.
**
**		THIS ROUTINE IS CALLED WITH EDP->EPLOCK HELD, BUT RELEASES IT IF DirectFlag IS SET
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendAckFrame"

VOID SendAckFrame(PEPD pEPD, BOOL DirectFlag)
{
	PSPD		pSPD = pEPD->pSPD;
	PFMD		pFMD;
	UINT		index = 0;
	PSFBIG		pFrame;

	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL){		// Frame already initialized to 1 buffer
		LOGPF(0, "(%p) Failed to allocate new FMD", pEPD);
		return;
	}

	// We can stop all delayed Ack timers since we are sending full status here.
	if(pEPD->DelayedAckTimer != 0)
	{
		LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedAck timer)"); // SendQLock not already held
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
		pEPD->DelayedAckTimer = 0;
	}
	if(pEPD->DelayedMaskTimer != 0)
	{
		LOGPF(7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedMask timer)"); // SendQLock not already held
		}
		else
		{
			LOGPF(7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
		pEPD->DelayedMaskTimer = 0;
	}

	pFMD->pEPD = pEPD;								// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (SendAckFrame)");			// Bump RefCnt on EPD until send is completed

	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;								// this will indicate a NON-Data frame
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;

	// Now that DG and S have been merged,  there are no longer 3 flavors of ACK frame.  We are back to only
	// one flavor that may or may not have detailed response info on one frame.  Actually,  I think we can
	// always include response info on the last ack'd frame.
	
	pFrame = (PSFBIG) pFMD->ImmediateData;
#ifdef	FRAME_NAMES
	pFrame->Name = ACK_NAME;
#endif
	pFrame->bCommand = PACKET_COMMAND_CFRAME;
	pFrame->bExtOpcode = FRAME_EXOPCODE_SACK;
	
	//pFrame->bFlags = 0;
	pFrame->bNSeq = pEPD->bNextSend;
	pFrame->bNRcv = pEPD->bNextReceive;
	pFrame->bFlags = 0;

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		LOGPF(7, "(%p) SENDING SACK WITH *NACK* N(R)=%x Low=%x High=%x", pEPD, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
		if(pEPD->ulReceiveMask)
		{
			pFrame->rgMask[index++] = pEPD->ulReceiveMask;
			pFrame->bFlags |= SACK_FLAGS_SACK_MASK1;
		}
		if(pEPD->ulReceiveMask2)
		{
			pFrame->rgMask[index++] = pEPD->ulReceiveMask2;
			pFrame->bFlags |= SACK_FLAGS_SACK_MASK2;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
	}
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)
	{
		LOGPF(7, "(%p) SENDING SACK WITH SEND MASK N(S)=%x Low=%x High=%x", pEPD, pEPD->bNextSend, pEPD->ulSendMask, pEPD->ulSendMask2);
		if(pEPD->ulSendMask)
		{
			pFrame->rgMask[index++] = pEPD->ulSendMask;
			pFrame->bFlags |= SACK_FLAGS_SEND_MASK1;
			pEPD->ulSendMask = 0;
		}
		if(pEPD->ulSendMask2)
		{
			pFrame->rgMask[index++] = pEPD->ulSendMask2;
			pFrame->bFlags |= SACK_FLAGS_SEND_MASK2;
			pEPD->ulSendMask2 = 0;
		}
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_SENDMASK);
	}
	
	pFMD->uiFrameLength = pFMD->uiImmediateLength = sizeof(SACKFRAME) + (index * sizeof(ULONG));
	
	pFrame->bFlags |= SACK_FLAGS_RESPONSE;			// time fields are always valid now

	ASSERT(pEPD->bLastDataSeq == (BYTE) (pEPD->bNextReceive - 1));

	pFrame->bRetry = pEPD->bLastDataRetry;
	pFrame->tTimestamp = pEPD->tLastDataFrame;
	
	LOGPF(7, "(%p) SEND SACK FRAME N(Rcv)=%x, EPD->LDRetry=%d, pFrame->Retry=%d pFMD=%p", pEPD, pEPD->bNextReceive, pEPD->bLastDataRetry, pFrame->bRetry, pFMD);
		
	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);

	// We can either schedule a worker thread to do the send or else we can do the work ourselves.  
	// The DirectFlag tells us whether we are in a time-crit section,  like processing
	// receive data, or whether we are free to call the SP ourselves.

	Lock(&pSPD->SendQLock);								// Place SACK frame on send queue
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
	
	if(DirectFlag)
	{
		// ServiceCmdTraffic will call into the SP so we must not hold the EPD lock
		Unlock(&pEPD->EPLock);
		ServiceCmdTraffic(pSPD);
	}
	else 
	{
		if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
		{
			LOGPF(7, "(%p) Scheduling Send Thread", pEPD);
			pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
			ScheduleTimerThread(RunSendThread, pSPD, &pSPD->SendHandle, &pSPD->SendHandleUnique);	
		}
	}
	Unlock(&pSPD->SendQLock);
}

/*
**		Delayed Ack Timeout
**
**			We are waiting for a chance to piggyback a reliable frame acknowledgement,
**		but the sands have run out.  Its time to send a dedicated Ack now.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DelayedAckTimeout"

VOID CALLBACK DelayedAckTimeout(PVOID uID, UINT uMsg, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;

	Lock(&pEPD->EPLock);

	LOGPF(7, "(%p) Delayed Ack Timer fires", pEPD);
	if((pEPD->DelayedAckTimer == uID)&&(pEPD->DelayedAckTimerUnique == uMsg))
	{
		pEPD->DelayedAckTimer = 0;
	}
	else if((pEPD->DelayedMaskTimer == uID)&&(pEPD->DelayedMaskTimerUnique == uMsg))
	{
		pEPD->DelayedMaskTimer = 0;
	}
	else
	{
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (DelayedAck complete)");	// release reference for timer, SendQLock not already held
		return;
	}

	if( (pEPD->ulEPFlags & EPFLAGS_CONNECTED) && (pEPD->ulEPFlags & (EPFLAGS_DELAY_ACKNOWLEDGE | EPFLAGS_DELAYED_NACK | EPFLAGS_DELAYED_SENDMASK)))
	{
		SendAckFrame(pEPD, 1); // This unlocks the EPLock since param 2 is 1
	}	
	else
	{
		Unlock(&pEPD->EPLock);
	}

	RELEASE_EPD(pEPD, "UNLOCK (DelayedAck complete)");		// release reference for timer, SendQLock not already held
}

/*
**		Send Disconnected Frame
**
**		When we abort a link abnormally and we cannot conduct the proper
**	Disconnect protocol,  we will still fire off a DISCONNECTED frame to
**	inform the partner that we are no longer participating in the link.
**	This will allow partner to stop timing out and retrying which can take
**	a rather long time.
**
**		Due to the high internet drop rates (~5%) we may want to
**	always resend an abort frame 2 or 3 times for good measure.  The pain
**	of forcing the partner to retry/TO if he misses the DISC frame is quite
**	significant...
**
**	/* CODE WORK
**		There is code in the loop below to wait for each send to complete
**	before continueing.  This is because we cant really ditch the link until
**	then.  BUT, now that we bump the EPD RefCnt for each pending CFrame we
**	can probably let that go.  I wont,  however, until I confirm that the
**	shutdown code will properly wait for the EPDs to exit before unloading
**	the SP.
**
**	** THIS ROUTINE IS CALLED AND RETURNS WITH EPD->EPLOCK HELD **
*/

#define		DISC_REDUNDANCY_COUNT		3

#undef DPF_MODNAME
#define DPF_MODNAME "SendDisconnectedFrame"

VOID
SendDisconnectedFrame(PEPD pEPD)
{
	UINT	i;

	for(i=0; i < DISC_REDUNDANCY_COUNT; i++)
	{	
		LOGPF(7, "(%p) Sending DISCONNECTED Frame", pEPD);
		SendCommandFrame(pEPD, FRAME_EXOPCODE_DISCONNECTED, 0);
	}
}

/*
**		Send Keep Alive
**
**		When we have not received anything from an endpoint in a long time (default 60 sec)
**	will will initiate a checkpoint to make sure that the partner is still connected.  We do
**	this by inserting a zero-data frame into the reliable pipeline.  Thereby,  the standard
**	timeout & retry mechanisms will either confirm or drop the link as appropriate.  Logic above
**	this routine will have already verified that we are not already sending reliable traffic, which
**	would eliminate the need for a keep alive frame.
**
**	*** EPD->EPLock is held on Entry and return
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendKeepAlive"

VOID
SendKeepAlive(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;

	if(pEPD->ulEPFlags & EPFLAGS_KEEPALIVE_RUNNING)
	{
		LOGPF(7, "Ignoring duplicate KeepAlive");
		return;
	}

	pEPD->ulEPFlags |= EPFLAGS_KEEPALIVE_RUNNING;

	if( (pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		LOGPF(0, "(%p) Failed to allocate new MSD");
		pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
		return;
	}

	pMSD->uiFrameCount = 1;
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_KEEPALIVE;
	pMSD->pEPD = pEPD;

	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{
		LOGPF(0, "(%p) Failed to allocate new FMD");
		Lock(&pMSD->CommandLock);								// An MSD must be locked to be released
		RELEASE_MSD(pMSD, "Release On FMD Get Failed");
		pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
		return;
	}
	
	LOCK_EPD(pEPD, "LOCK (SendKeepAlive)");						// Add a reference for this checkpoint
	pFMD->ulFFlags |= FFLAGS_CHECKPOINT | FFLAGS_KEEPALIVE | FFLAGS_END_OF_MESSAGE;
	pFMD->bPacketFlags = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_END_MSG;
	pFMD->uiFrameLength = 0;									// No user data in this frame
	pFMD->blMSDLinkage.InsertAfter( &pMSD->blFrameList);		// Attach frame to MSD
	pFMD->pMSD = pMSD;											// Link frame back to message
	pFMD->pEPD = pEPD;
	pFMD->CommandID = COMMAND_ID_SEND_RELIABLE;
	pMSD->CommandID = COMMAND_ID_KEEPALIVE;	// Mark MSD for completion handling
	pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_LOW_PRIORITY; // Priority is LOW so all previously submitted traffic will be sent
	
	LOGPF(7,"(%p) Sending KEEPALIVE", pEPD);
	
	EnqueueMessage(pMSD, pEPD);									// Insert this message into the stream
}

/*
**			Perform Checkpoint
**
**		We would like to take a measurement of Round-Trip latency using the
**	reliable pipeline.  We either need to mark the next outgoing frame in our
**	SendQ with a POLL bit OR we need to create a special purpose frame if
**	the pipeline is idle.
**
**		We have a routine (above) which will insert a special frame,  so THIS
**	procedure will check for an idle link and either call out or mark the
**	next frame.
**
**		** CALLED AND RETURNS WITH EPD->EPLOCK HELD
*/


#undef DPF_MODNAME
#define DPF_MODNAME "PerformCheckpoint"

VOID
PerformCheckpoint(PEPD pEPD)
{
	LOGPF(7,"(%p) Performing Checkpoint", pEPD);
	
	if(pEPD->ulEPFlags & EPFLAGS_SDATA_READY)
	{
		ASSERT(pEPD->pCurrentFrame != NULL);					// DATA_READY flag means pCurrentFrame is valid
		pEPD->pCurrentFrame->ulFFlags |= FFLAGS_CHECKPOINT;
	}
	else
	{														// We do not have data in our pipeline
		SendKeepAlive(pEPD);									// Keepalive doubles as a checkpoint
	}
}


/*
**		Endpoint Background Process
**
**		This routine is run for each active endpoint every minute or so.  This will initiate
**	a KeepAlive exchange if the link has been idle since the last run of the procedure.  We
**	will also look for expired timeouts and perhaps this will be an epoch delimiter for links
**	in a STABLE state of being.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EndPointBackgroundProcess"

VOID CALLBACK
EndPointBackgroundProcess(PVOID uID, UINT Unique, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;
	DWORD	tNow = GETTIMESTAMP();
	DWORD	Expiration;
	CBilink	*pLink;
	PCHKPT	pCP;
	DWORD	dwIdleInterval;

	LOGPF(7, "(%p) BACKGROUND PROCESS for EPD; RefCnt=%d; WindowF=%d; WindowB=%d", 
										pEPD, pEPD->uiRefCnt, pEPD->iWindowF, pEPD->uiWindowBIndex);

	Lock(&pEPD->EPLock);

	if(pEPD->ulEPFlags & (EPFLAGS_ABORT | EPFLAGS_KILLED))
	{
		LOGPF(7, "Killing Background Process, endpoint is aborted or killed. Flags = 0x%x", pEPD->ulEPFlags);
		pEPD->BGTimer = 0;
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (release BG timer)");			// release reference for this timer, SendQLock not already held
		return;
	}

	//	Do we want to filter our Checkpoint list looking for expired ChkPts?  Now would be the time...

	pLink = pEPD->blChkPtQueue.GetNext();

	Expiration = tNow - ((pEPD->uiRTT * 8) + 500);				// time to live for checkpoint structures
	
	while(pLink != &pEPD->blChkPtQueue)
	{
		pCP = CONTAINING_RECORD(pLink, CHKPT, blLinkage);
		pLink = pLink->GetNext();

		if( (pCP->tTimestamp - Expiration) & 0x80000000)
		{
			LOGPF(7, "(%p) Removing ancient Checkpoint on EPD MsgID=%x", pEPD, pCP->bMsgID);
			pCP->blLinkage.RemoveFromList();
			ChkPtPool->Release(ChkPtPool, pCP);
		}
		else 
		{
			break;			// Since oldest are listed first,  we can stop scanning when we find a young one...
		}
	}


	dwIdleInterval = pEPD->pSPD->pPData->tIdleThreshhold;

	// Do we need to start a KeepAlive cycle?

	if(	((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_KEEPALIVE_RUNNING))==0) &&
		((tNow - pEPD->tLastPacket) > dwIdleInterval)) 
	{
		// We are not sending data and we havent heard from our partner in a long time.
		// We will send a keep alive packet which he must respond to.  We will insert a
		// NULL data packet into the reliable stream so ack/retry mechanisms will either
		// clear the keep-alive or else timeout the link.
		//
		// There's also the special case where we've started a graceful disconnect and
		// our request has been acknowledged, but somehow our partner's got lost.
		// There currently is no timer set for that, so if we detect the link in that
		// condition, our keepalive will almost certainly fail; the other side knows
		// we're shutting down, so has probably already dropped the link and wouldn't
		// respond.  So to prevent the person from having to wait for the entire idle
		// timeout _plus_ reliable message timeout, just drop the link now.
		if ((pEPD->ulEPFlags & (EPFLAGS_SENT_DISCONNECT | EPFLAGS_DISCONNECT_ACKED)) == (EPFLAGS_SENT_DISCONNECT | EPFLAGS_DISCONNECT_ACKED))
		{
			// If all three parts happened, why is the link still up!?
			ASSERT(! (pEPD->ulEPFlags & EPFLAGS_RECEIVED_DISCONNECT));


			LOGPF(1, "(%p) EPD has been waiting for partner disconnect for %u ms (idle threshold = %u ms), dropping link.",
					pEPD, (tNow - pEPD->tLastPacket), dwIdleInterval);
			
			// We don't need to reschedule a timer, so clear it.  This also prevents
			// drop link from trying to cancel the one we're in now.  That error is
			// ignored, but no point in doing it.
			pEPD->BGTimer = 0;

			// Since we're just hanging out waiting for partner to send his disconnect,
			// he's probably gone now.  Drop the link.
			DropLink(pEPD);									// releases EPLock

			RELEASE_EPD(pEPD, "UNLOCK (release BGTimer)");
			return;
		}


#ifdef	DEBUG
		if(KeepAlive)
#endif
		{
			SendKeepAlive(pEPD);					// This call releases EPD->StateLock
		}
	}

	// Reschedule next interval
	//
	// Since we released the StateLock if we started a Checkpoint,  we ought to verify now that we're
	// locked again that we still need to reschedule this timer

	if(pEPD->ulEPFlags & EPFLAGS_CONNECTED)
	{
		// Cap the background process interval at this value.
		if (dwIdleInterval > ENDPOINT_BACKGROUND_INTERVAL)
			dwIdleInterval = ENDPOINT_BACKGROUND_INTERVAL;

		LOGPF(7, "(%p) Setting Endpoint Background Timer for %u ms", pEPD, dwIdleInterval);
		SetMyTimer(dwIdleInterval, 1000, EndPointBackgroundProcess, (PVOID) pEPD, &pEPD->BGTimer, &pEPD->BGTimerUnique);
	}
	else 
	{
		LOGPF(7, "(%p) Not renewing BACKGROUND timer because CONNECTED flag is clear", pEPD);
		pEPD->BGTimer = 0;
		RELEASE_EPD(pEPD, "UNLOCK (release BGTimer)"); // SendQLock not already held
	}
	Unlock(&pEPD->EPLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\dvoice\dxvoice\vplayer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vplayer.h
 *  Content:	Voice Player Entry
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/26/00	rodtoll Created
 *  09/01/2000  georgioc started rewrite/port to xbox
 ***************************************************************************/

#ifndef __VPLAYER_H
#define __VPLAYER_H

#define NODSOUND
#include "dvntos.h"
#include <dsoundp.h>
#include <dvoicep.h>

#include "dvshared.h"

#include "inqueue2.h"
#include "dvprot.h"
#include "dvsndt.h"

#define VOICEPLAYER_FLAGS_DISCONNECTED          0x00000001  // Player has disconnected
#define VOICEPLAYER_FLAGS_INITIALIZED           0x00000002  // Player is initialized
#define VOICEPLAYER_FLAGS_ISRECEIVING           0x00000004  // Player is currently receiving audio
#define VOICEPLAYER_FLAGS_ISSERVERPLAYER        0x00000008  // Player is the server player
#define VOICEPLAYER_FLAGS_ISAVAILABLE			0x00000020	// Is player available

#define VSIG_VOICEPLAYER		'YLPV'
#define VSIG_VOICEPLAYER_FREE	'YLP_'

VOID DV_VoicePlayerPlaybackPacketCompletion(PVOID pThis, PVOID pContext2, DWORD dwStatus);

class CVoicePlayer
{
public: // Init / destruct

    CVoicePlayer();
    virtual ~CVoicePlayer();

    HRESULT Initialize(const DVID dvidPlayer,
                       const DWORD dwHostOrder, 
                       const DWORD dwPortNumber,
                       DWORD dwFlags, 
                       PVOID pvContext,
                       LIST_ENTRY *pOwner );

    HRESULT CreateQueue( PQUEUE_PARAMS pQueueParams );

    HRESULT CreateMediaObjects(
        const GUID &guidCT,
        PWAVEFORMATEX pwfxTargetFormat,
        DWORD dwUnCompressedFrameSize,
        XMediaObject *pConverter,
        BOOLEAN fUseMcpx);

    virtual HRESULT DeInitialize();
	void FreeResources();
	HRESULT SetPlayerTargets( PDVID pdvidTargets, DWORD dwNumTargets );

    HRESULT SwitchInternalAudioTarget(
        PWAVEFORMATEX pwfxTargetFormat,
        BOOL fUseMcpx,
        BOOL fMute
        );

    inline void AddRef()
    {
        InterlockedIncrement( &m_lRefCount );
    }

    inline void Release()
    {
        if( InterlockedDecrement( &m_lRefCount ) == 0 )
        {
            DeInitialize();
        }
    }

public: // Speech Handling 

    __inline void *__cdecl operator new(size_t size)
    {
        return ExAllocatePoolWithTag(size, 'lcvd');
    }

    __inline void __cdecl operator delete(void *pv)
    {
        ExFreePool(pv);
    }

    HRESULT HandleReceive( PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize );
	HRESULT GetNextFrameAndDecompress(DWORD *pdwReturnFlags, DWORD *pdwSeqNum, DWORD *pdwMsgNum );
	HRESULT DeCompressInBound( PDVMEDIAPACKET pBuffer );
	CFrame *Dequeue();

    inline DVID GetPlayerID()
    {
        return m_dvidPlayer;
    }

    inline DWORD GetFlags()
    {
        return m_dwFlags;
    }
    
    inline BOOL IsReceiving()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_ISRECEIVING);
    }

    inline void SetReceiving( const BOOL fReceiving )
    {
        KIRQL irql;
        RIRQL(irql);
        if( fReceiving )
            m_dwFlags |= VOICEPLAYER_FLAGS_ISRECEIVING;
        else
            m_dwFlags &= ~VOICEPLAYER_FLAGS_ISRECEIVING;
        LIRQL(irql);
    }

    inline void SetAvailable( const BOOL fAvailable )
    {
        KIRQL irql;
        RIRQL(irql);
		if( fAvailable )
			m_dwFlags |= VOICEPLAYER_FLAGS_ISAVAILABLE;
		else 
			m_dwFlags &= ~VOICEPLAYER_FLAGS_ISAVAILABLE;
    	LIRQL(irql);
    }

    inline BOOL IsAvailable()
    {
    	return (m_dwFlags & VOICEPLAYER_FLAGS_ISAVAILABLE);
   	}

    inline BOOL IsInitialized()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_INITIALIZED);
    }

    inline BOOL IsServerPlayer()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_ISSERVERPLAYER);
    }

    inline void SetServerPlayer()
    {
        KIRQL irql;
        RIRQL(irql);
        m_dwFlags |= VOICEPLAYER_FLAGS_ISSERVERPLAYER;
        LIRQL(irql);
    }

    inline BOOL IsDisconnected()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_DISCONNECTED);
    }

    inline void SetDisconnected()
    {
        KIRQL irql;
        RIRQL(irql);
        m_dwFlags |= VOICEPLAYER_FLAGS_DISCONNECTED;
        LIRQL(irql);
    }

    inline void SetHostOrder( const DWORD dwHostOrder )
    {
        KIRQL irql;
        RIRQL(irql);
        m_dwHostOrderID = dwHostOrder;
        LIRQL(irql);
    }

    inline DWORD GetHostOrder() 
    {
        return m_dwHostOrderID;
    }

    inline void *GetContext()
    {
        return m_pvPlayerContext;
    }

    inline void SetContext( void *pvContext )
    {
        KIRQL irql;
        RIRQL(irql);
        m_pvPlayerContext = pvContext;
        LIRQL(irql);
    }

    inline BYTE GetLastPeak()
    {
        return m_bLastPeak;
    }

    inline DWORD GetTransportFlags()
    {
        return m_dwTransportFlags;
    }

    inline void AddToPlayList( PLIST_ENTRY ListHead )
    {
        InsertTailList(ListHead,&m_PlayListEntry);
    }

	inline void AddToNotifyList( PLIST_ENTRY ListHead )
	{
        InsertTailList( ListHead, &m_NotifyListEntry);

	}

    inline void RemoveFromNotifyList()
    {
        RemoveEntryList(&m_NotifyListEntry );
    }

	inline void RemoveFromPlayList()
	{
		RemoveEntryList(&m_PlayListEntry);
	}

	inline DWORD_PTR GetLastPlayback()
	{
		return m_dwLastPlayback;
	}

	inline DWORD GetNumTargets()
	{
		return m_dwNumTargets;
	}

	inline PDVID GetTargetList()
	{
		return m_pdvidTargets;
	}

    HRESULT GetSoundTarget(CSoundTarget **ppTarget) {*ppTarget = m_pSoundTarget;return NOERROR;}

    HRESULT CreateSoundTarget(CSoundTarget **ppSoundTarget);
    void DeleteSoundTarget();

	LIST_ENTRY			m_NotifyListEntry;
	LIST_ENTRY			m_PlayListEntry;
    LIST_ENTRY          m_PoolEntry;

    LIST_ENTRY          m_AvailableList;
    LIST_ENTRY          m_PendingList;

protected:

    virtual void Reset();

    CRITICAL_SECTION    m_CS;
    LONG		        m_lRefCount;		// Reference count on the player
	PDVID				m_pdvidTargets;		// The player's current target
	DWORD				m_dwNumTargets;

    DWORD               m_dwUnCompressedFrameSize;
    DWORD               m_dwTransportFlags;
    DWORD               m_dwFlags;
    DWORD               m_dwNumSilentFrames;
    DWORD               m_dwNumSpeechFrames;
    DWORD               m_dwNumReceivedFrames;
    DWORD               m_dwNumLostFrames;
	DVID		        m_dvidPlayer;		// Player's ID
	DWORD				m_dwHostOrderID;	// Host ORDER ID	

	XMediaObject        *m_pInBoundAudioConverter; // Converter for this player's audio    
    XMediaObject	    *m_pPlaybackMediaObject;   // Dsound playback XMO    

    PWAVEFORMATEX       m_pwfxEncodedFormat;

    CSoundTarget        *m_pSoundTarget;    // XMO we provide to calle rin responce to DVC_CreateSoundTarget

	CInputQueue2		*m_lpInputQueue;	// Input queue for this player's audio
    PVOID               m_pvPlayerContext;
    PLIST_ENTRY         m_pOwner;          // owner linked list where this player goes after we DeInitialize

    PVOID               m_pMediaPacketBuffer;

	DWORD_PTR			m_dwLastData;		// GetTickCount() value when last data received
    DWORD_PTR			m_dwLastPlayback;	// GetTickCount() when last non-silence from this player

    BYTE				m_bLastPeak;		// Last peak value for this player.
    UCHAR               m_bPortNumber;      // hawk port number..

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\connectp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Connect.c
 *  Content:	This file contains support for the CONNECT/DISCONNECT protocol in DirectNet.
 *				It is organized with FrontEnd routines first (Connect, Listen),
 *				and Backend handlers (timeouts,  frame crackers) after.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/11/98	ejs		Created
 *	03/22/00	ejs		Changed address structures to Dplay8Address
 *
 ****************************************************************************/


#include "dnproti.h"

/***  FRONT END  ***/

/*
**		Connect
**
**			This function attempts to make a connection to a specified address.
**		The function establishes the existance of a DirectNet entity and maps
**		an EndPoint handle.  Then we exchange CONNECT packets which allows each
**		side to establish a baseline RTT.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPConnect"

HRESULT DNPConnect(	PProtocolData pPData,
							IDirectPlay8Address *const lpaLocal,
							IDirectPlay8Address *const lpaRemote,
							//IDP8ServiceProvider* pISP,
							const HANDLE hSPHandle,
							const DWORD dwTimeout,
							const ULONG ulFlags,
							void *const Context,
							PHANDLE phHandle)
{
	PMSD			pMSD;
	SPCONNECTDATA	ConnData;					// Parameter Block
	PSPD			pSPD;						// Service Provider to handle this connect
	HRESULT			hr;
	UINT			i;


	// Determine which SP will take this call
	//

	LOGPF(2, "Parameters: pPData[%p], paLocal[%p], paRemote[%p], hSPHandle[%x], dwTimeout[%x], ulFlags[%x], Context[%p], phHandle[%p]", pPData, lpaLocal, lpaRemote, hSPHandle, dwTimeout, ulFlags, Context, phHandle);

	pSPD = (PSPD) hSPHandle;
	ASSERT(pSPD != NULL);
	
	if(pSPD == NULL)
	{
		LOGPF(0, "Returning DPNERR_NOTREADY - hSPHandle is NULL");
		return DPNERR_NOTREADY;
	}

	ASSERT_SPD(pSPD);

	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		LOGPF(0, "Returning DPNERR_NOTREADY - SP is terminating");
		return DPNERR_NOTREADY;
	}

	// We use an MSD to describe this op even though it isn't technically a message
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{	
		LOGPF(0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
		return DPNERR_OUTOFMEMORY;	
	}

	pMSD->CommandID = COMMAND_ID_CONNECT;
	pMSD->pSPD = pSPD;
	pMSD->Context = Context;
	pMSD->tSubmitTime = GETTIMESTAMP();
	pMSD->pEPD = NULL;

	// Prepare to call SP to map the endpoint.
	ConnData.pAddressDeviceInfo = lpaLocal;
	ConnData.pAddressHost = lpaRemote;
	ConnData.dwTimeout = dwTimeout;

	ConnData.dwFlags = 0;

	ConnData.pvContext = pMSD;
	ConnData.hCommand = 0;

	// Hook up MSD before calling into SP
	Lock(&pMSD->pSPD->SendQLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);	// Put this on cmd list, not timer list
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	Unlock(&pMSD->pSPD->SendQLock);

	*phHandle = pMSD;

	// SP Connect call is guarenteed to return immediately

	LOCK_MSD(pMSD, "SP Ref");												// Add reference for call into SP

	LOGPF(3, "Calling SP->Connect");
/**/hr = IDP8ServiceProvider_Connect(pSPD->IISPIntf, &ConnData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// SP Connect should always be asynchronous so if it isnt PENDING then it must have failed
		LOGPF(0, "SP->Connect did not return DPNERR_PENDING, assuming failure, hr[%x]", hr);

		ASSERT(hr != DPN_OK);

		Lock(&pMSD->CommandLock);								// This will be unlocked by final RELEASE_MSD

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);		// clear InSP flag
		pMSD->ulMsgFlags1 |= MFLAGS_ONE_CANCELLED;				// In case timer cannot be cancelled

		Lock(&pMSD->pSPD->SendQLock);
		pMSD->blSPLinkage.RemoveFromList();								// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pMSD->pSPD->SendQLock);

		DECREMENT_MSD(pMSD, "SP Ref");									// Remove one ref for SP call
		RELEASE_MSD(pMSD, "Release On Fail");							// Remove one ref to free resource

		LOGPF(0, "Returning hr[%x]", hr);
		return hr;
	}

	pMSD->hCommand = ConnData.hCommand;							// retain SP command handle
	pMSD->dwCommandDesc = ConnData.dwCommandDescriptor;

	// This cannot be called until after pMSD->hCommand and pMSD->dwCommandDesc are
	// valid or it will try to cancel with bogus handles for the SP
	if(dwTimeout != 0)
	{
		LOGPF(5, "Setting Connect Timeout Timer");
		LOCK_MSD(pMSD, "Connect Timeout Timer");			// Add reference for timer
		SetMyTimer(dwTimeout, 100, TimeoutConnect, pMSD, &pMSD->TimeoutTimer, &pMSD->TimeoutTimerUnique);
	}

	LOGPF(2, "Returning DPNERR_PENDING, pMSD[%p]", pMSD);
	return DPNERR_PENDING;
}

/*
**		Listen
**
**		This command tells DN that it should start to accept connection requests.
**	This command will return pending,  and will continue to indicate connections
**	until it is explicitly cancelled.  It may be desireable to establish a limit
**	mechanism of some sort,  but for the time being this will do.
**
**		Now it is desirable to Listen on multiple ports on a single adapter.  This
**	means that we need to accept multiple concurrent Listen commands on each adapter.
**	Another fact of life is that we need to crack the Target address far enough to
**	determine which SP to submit the Listen on.
*/



#undef DPF_MODNAME
#define DPF_MODNAME "DNPListen"

HRESULT DNPListen(	PProtocolData pPData,
							IDirectPlay8Address *const lpaTarget,
							// IDP8ServiceProvider* pISP,
							const HANDLE hSPHandle,
							ULONG ulFlags,
							PVOID Context,
							PHANDLE phHandle)
{
	PSPD			pSPD;
	PMSD			pMSD;
	SPLISTENDATA	ListenData;
	UINT			i;
	HRESULT			hr;

	LOGPF(2, "Parameters: pPData[%p], paTarget[%p], hSPHandle[%x], ulFlags[%x], Context[%p], phHandle[%p]", pPData, lpaTarget, hSPHandle, ulFlags, Context, phHandle);

	pSPD = (PSPD) hSPHandle;
	
	ASSERT(pSPD != NULL);
	if(pSPD == NULL)
	{
		LOGPF(0, "Returning DPNERR_NOTREADY - hSPHandle is NULL");
		return DPNERR_NOTREADY;
	}

	ASSERT_SPD(pSPD);

	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		LOGPF(0, "Returning DPNERR_NOTREADY - SP is terminating");
		return DPNERR_NOTREADY;
	}

	// We use an MSD to describe this op even though it isn't technically a message
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{	
		LOGPF(0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
		return DPNERR_OUTOFMEMORY;	
	}

	pMSD->CommandID = COMMAND_ID_LISTEN;
	pMSD->pSPD = pSPD;
	pMSD->Context = Context;

	ListenData.pAddressDeviceInfo = lpaTarget;
	ListenData.dwFlags = 0;
	ListenData.pvContext = pMSD;
	ListenData.hCommand = 0;

	*phHandle = pMSD;

	// SP Listen call is guarenteed to return immediately
	Lock(&pSPD->SendQLock);
	pSPD->ulSPFlags |= SPFLAGS_LISTENING;
	pMSD->blQLinkage.InsertBefore( &pSPD->blListenList);

	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);		// Dont support timeouts for Listen
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	Unlock(&pMSD->pSPD->SendQLock);

	LOCK_MSD(pMSD, "SP Ref");											// AddRef for SP

	LOGPF(3, "Calling SP->Listen");
/**/hr = IDP8ServiceProvider_Listen(pSPD->IISPIntf, &ListenData);		/** CALL SP **/

	if(hr != DPNERR_PENDING){

		// SP Listen should always be asynchronous so if it isnt PENDING then it must have failed
		LOGPF(0, "SP->Listen did not return DPNERR_PENDING, assuming failure, hr[%x]", hr);

		ASSERT(hr != DPN_OK);

		Lock(&pSPD->SendQLock);

		pMSD->blQLinkage.RemoveFromList();

		if(pSPD->blListenList.IsEmpty())
		{
			pSPD->ulSPFlags &= ~(SPFLAGS_LISTENING);
		}
		
		Unlock(&pSPD->SendQLock);

		Lock(&pMSD->CommandLock);

		Lock(&pSPD->SendQLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SendQLock);

		DECREMENT_MSD(pMSD, "SP Ref");						// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");				// release again to return resource

		LOGPF(0, "Returning hr[%x]", hr);
		return hr;
	}

	pMSD->hCommand = ListenData.hCommand;			// retail SP command handle
	pMSD->dwCommandDesc = ListenData.dwCommandDescriptor;

	LOGPF(2, "Returning DPNERR_PENDING, pMSD[%p]", pMSD);
	return DPNERR_PENDING;
}

/***  BACKEND ROUTINES  ***/

/*
**		Complete Connect
**
**		The user's Connect operation has completed.  Clean everything up
**	and signal the user.
**
**		THIS IS ALWAYS CALLED WITH THE COMMAND LOCK HELD IN MSD
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteConnect"

VOID CompleteConnect(PMSD pMSD, PSPD pSPD, PEPD pEPD, HRESULT hr)
{
	PVOID	Context;

	if(pMSD->TimeoutTimer != NULL)
	{
		LOGPF(5, "Cancelling Connect Timeout Timer");
		if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
		{
			DECREMENT_MSD(pMSD, "Connect Timeout Timer");
			pMSD->TimeoutTimer = NULL;
		}
		else
		{
			LOGPF(5, "Cancelling Connect Timeout Timer Failed");
		}
	}

	Lock(&pSPD->SendQLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();							// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
	}
	Unlock(&pSPD->SendQLock);

	if(pEPD)
	{
		if(hr != DPN_OK)
		{
			LOGPF(0, "SP returned Connect failed, hr[%x]", hr);
			KillConnection(pEPD);
			pEPD = NULL;
		}
	}
	Context = pMSD->Context;
	RELEASE_MSD(pMSD, "Final Release On Complete");					// Finished with this one

	if(pEPD)
	{
		LOGPF(3, "Calling Core->CompleteConnect");
		pSPD->pPData->pfVtbl->CompleteConnect(pSPD->pPData->Parent, Context, hr, (PHANDLE) pEPD, (PVOID *) &pEPD->Context);
		Lock(&pEPD->EPLock);
		pEPD->ulEPFlags &= ~(EPFLAGS_CALLING | EPFLAGS_CONNECTING);
		ReceiveComplete(pEPD);								// Complete any
	}
	else
	{
		LOGPF(3, "Calling Core->CompleteConnect with NULL EPD");
		pSPD->pPData->pfVtbl->CompleteConnect(pSPD->pPData->Parent, Context, hr, NULL, NULL);
	}
}

/*
**		Timeout Connect
**
**		Connect Command's user-set timeout has fired.  Need to nip this operation.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "TimeoutConnect"

VOID CALLBACK
TimeoutConnect(PVOID uID, UINT uMsg, PVOID dwUser)
{
	PMSD	pMSD = (PMSD) dwUser;

	Lock(&pMSD->CommandLock);
	
	if( (pMSD->TimeoutTimer == uID)&&(pMSD->TimeoutTimerUnique == uMsg))
	{
		LOGPF(5, "Connect Timed Out");

		pMSD->TimeoutTimer = NULL;

		if((pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_TIMEDOUT)) || (pMSD->ulMsgFlags2 & MFLAGS_TWO_COMPLETE))
		{
			LOGPF(5, "MSD is cancelled, timed-out, or complete");
			RELEASE_MSD(pMSD, "Connect Timeout Timer");
			return;
		}

		pMSD->ulMsgFlags1 |= MFLAGS_ONE_TIMEDOUT;

		DECREMENT_MSD(pMSD, "Connect Timeout Timer");			// Release Ref for timer

		DoCancel(pMSD, DPNERR_TIMEDOUT);
	}
	else
	{
		LOGPF(5, "Connect Timed Out - Timer already cancelled");
		RELEASE_MSD(pMSD, "Connect Timeout Timer");
	}
}


/*
**		Complete SP Connect
**
**		A Connect Command has completed in the Service Provider.  This does not mean our
**	work is done...  this means we now have a mapped EndPoint so we can exchange packets
**	with this partner.  We will now ping this partner to get an initial RTT and make sure
**	there really is a protocol over there that will talk to us.
**
**		Of course,  if SP does not return success then we can nip this whole thing in
**	the proverbial bud.
**
**		**  COMMAND LOCK is held on entry  **
*/


#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSPConnect"

VOID CompleteSPConnect(PMSD pMSD, PSPD pSPD, HRESULT hr)
{
	PEPD		pEPD;
	PFMD		pFMD;

	LOGPF(5, "SP Completes Connect (Endpoint Opened (0x%p))", pMSD->pEPD);

	if(hr != DPN_OK)
	{
		LOGPF(5, "(%p) Connect was not successful, Complete Connect", pMSD->pEPD);
		CompleteConnect(pMSD, pSPD, NULL, hr);				// SP failed the connect call
		return;
	}

	pEPD = pMSD->pEPD;

	ASSERT_EPD(pEPD);
	ASSERT(pEPD->pCommand == pMSD);

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_TIMEDOUT))
	{
		DECREMENT_MSD(pMSD, "SP Ref");						// Release Reference from SP
		
		ASSERT(pEPD->pCommand != NULL);

		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "EPD Ref");						// Release Reference from EPD
		
		LOGPF(5, "(%p) Command is cancelled or timed out, Complete Connect", pMSD->pEPD);
		CompleteConnect(pMSD, pSPD, pEPD, ((pMSD->ulMsgFlags1 & MFLAGS_ONE_TIMEDOUT) ? DPNERR_TIMEDOUT : DPNERR_USERCANCEL));
		return;
	}


	Lock(&pEPD->EPLock);

	if(pEPD->ulEPFlags & (EPFLAGS_CONNECTING | EPFLAGS_CONNECTED))
	{
		// Otherside beat us to it!   Let him finish...
		LOGPF(5, "SP Completes CONNECT but partner is already in process, Complete Connect");
		Unlock(&pEPD->EPLock);
		CompleteConnect(pMSD, pSPD, NULL, DPNERR_CONNECTING);
		return;
	}

	// Set up End Point Data

	pEPD->ulEPFlags &= ~(EPFLAGS_END_POINT_DORMANT);
	pEPD->ulEPFlags |= EPFLAGS_CONNECTING | EPFLAGS_CALLING;
	pMSD->pEPD = pEPD;										// Link new EPD to command descriptor

	// Send Ping

	pEPD->dwSessID = pSPD->pPData->dwNextSessID++;

	LOGPF(5, "(%p) Sending CONNECT Frame", pEPD);
	if(SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECT, 0) != DPN_OK)
	{
		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "SP Ref");								// Release Reference from SP
		Unlock(&pEPD->EPLock);
		LOGPF(5, "(%p) Sending CONNECT Frame Failed, Complete Connect", pEPD);
		CompleteConnect(pMSD, pSPD, pEPD, DPNERR_OUTOFMEMORY);
		return;
	}

	// Set timer for reply,  then wait for reply or TO.  We will do this first against the
	// loopback possibility of the response arriving before the timer is set
	//
	// CODEWORK - we should scale the initial TO according to local linkspeed

	pEPD->uiRetryTimeout = pSPD->pPData->dwConnectTimeout;
	pEPD->uiRetryCount = pSPD->pPData->dwConnectRetries;	

	LOCK_EPD(pEPD, "LOCK (CONN Retry Timer)");						// Create reference for timer
	LOGPF(5, "(%p) Setting Connect Retry Timer", pEPD);
	SetMyTimer(pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, &pEPD->ConnectTimer, &pEPD->ConnectTimerUnique);

	Unlock(&pEPD->EPLock);
	Unlock(&pMSD->CommandLock);
}

/*
**		Connect Retry Timeout
**
**		Retry timer has expired on a Connect operation.  This one function
**	is shared by Calling and Listening partners.  Complexity is due to the
**	fact that cancel code cannot always ensure that this handler will not
**	run,  so there are flags to signal various edge conditions (cancel, abort,
**	completion, high-level timeout).
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ConnectRetryTimeout"

VOID CALLBACK
ConnectRetryTimeout(PVOID pvHandle, UINT uiUnique, PVOID pvUser)
{
	PMSD	pMSD;
	PEPD	pEPD = (PEPD) pvUser;
	HRESULT	hr = DPNERR_NORESPONSE;

	LOGPF(5, "ENTER Connect Retry Timeout pEPD=%p", pEPD);

	ASSERT_EPD(pEPD);

	if((pEPD->ConnectTimer != pvHandle)||(pEPD->ConnectTimerUnique != uiUnique))
	{
		// Timer been reset!  This is a spurious fire and should be ignored.
		RELEASE_EPD(pEPD, "UNLOCK: (Spurious (ie late) firing of CONNECT timer)"); // SendQLock not already held
		LOGPF(5, "(%p) Ignoring late CONNECT timer", pEPD);
		return;
	}
	
	pMSD = pEPD->pCommand;

	if(pMSD == NULL)
	{
		pEPD->ConnectTimer = 0;
		RELEASE_EPD(pEPD, "UNLOCK: (CONNECT timer after completion)"); // SendQLock not already held
		return;
	}
	
	ASSERT_MSD(pMSD);

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	pEPD->ConnectTimer = 0;

	if(		(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED) || 
			(pMSD->ulMsgFlags2 & (MFLAGS_TWO_COMPLETE | MFLAGS_TWO_ABORT)) || 
			((pEPD->ulEPFlags & EPFLAGS_CONNECTING)==0))
	{

		pEPD->pCommand = NULL;									// Remove EPD Link
		RELEASE_MSD(pMSD, "EPD Ref");							// Remove reference for EPD Link
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (Conn Retry Timer)");			// Remove reference for timer, SendQLock not already held
		return;													// and thats all for now
	}

	// IF more retries are allowed and command is still active, send another CONNECT frame

	if(	(pEPD->uiRetryCount-- > 0) && ((pMSD->ulMsgFlags1 & MFLAGS_ONE_TIMEDOUT)==0) && ((pMSD->ulMsgFlags2 & MFLAGS_TWO_COMPLETE)==0))
	{	
		pEPD->uiRetryTimeout *= 2;		// exp backoff until we establish our first RTT

		if(pMSD->CommandID == COMMAND_ID_CONNECT)
		{
			LOGPF(5, "(%p) Sending CONNECT Frame", pEPD);
			if((hr = SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECT, 0)) != DPN_OK)
			{
				LOGPF(5, "(%p) Sending CONNECT Frame Failed", pEPD);
				goto Failure;
			}
		}
		// Listen -- retry CONNECTED frame
		else 
		{
			pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;	// We will expect a reply to this frame
			LOGPF(5, "(%p) Sending CONNECTED Frame", pEPD);
			if((hr = SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, 0)) != DPN_OK)
			{
				LOGPF(5, "(%p) Sending CONNECTED Frame Failed", pEPD);
				goto Failure;
			}
		}

		// Send the next ping
		LOGPF(5, "(%p) Setting Connect Retry Timer", pEPD);
		SetMyTimer(pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, &pEPD->ConnectTimer, &pEPD->ConnectTimerUnique);

		Unlock(&pEPD->EPLock);
		Unlock(&pMSD->CommandLock);

		return;											// Since we have re-started timer, we dont adjust refcnt
	}

	/*
	** 	Failure - there are a couple failure scenarios.  Most likely is that we get no response and timed out.
	*/

Failure:

	RELEASE_EPD(pEPD, "UNLOCK: (Connect Timer (Failure Path))");// Dec Ref for this timer, SendQLock not already held

	if(pMSD->CommandID == COMMAND_ID_CONNECT)
	{
		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "EPD Ref");					// Release Reference from EPD
		
		if (pMSD->ulMsgFlags1 & MFLAGS_ONE_TIMEDOUT)
		{
			hr = DPNERR_TIMEDOUT;
		}
		else if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
		{
			hr = DPNERR_USERCANCEL;
		}
		Unlock(&pEPD->EPLock);
		LOGPF(5, "Connect Retry Failed, Complete Connect");
		CompleteConnect(pMSD, pEPD->pSPD, pEPD, hr);			// releases CommandLock
	}

	// Listen - clean up associated state info,  then blow away end point
	else 
	{

		LOGPF(5, "Connect Retry Failed on Listen, Kill Connection");

		if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();							// Unlink EPD from Listen Queue
		}

		pEPD->pCommand = NULL;										// Unlink listen from EPD
		RELEASE_MSD(pMSD, "EPD Ref");								// release reference for link to EPD and CommandLock
		
		Unlock(&pEPD->EPLock);
		KillConnection(pEPD);									// Remove 'base' reference from End Point
	}
}

/*
**		Process Connection Request
**
**		Somebody wants to connect to us.  If we have a listen posted we will
**	fill out a checkpoint structure to correlate his response and we will fire
**	off a CONNECTED frame ourselves
**
**		In the case of concurrent connection requests from both partners,  the
**  partner with the LOWER Session ID will backoff in favor of the HIGHER session ID.
**	This means that if we receive a lower request we can ignore it.  If we receive a
**	higher request we must abort our CONNECT in progress...
**
**		Since our connection will not be up until we receive a CONNECTED response
**	to our response we will need to set up a retry timer ourselves.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectRequest"

VOID ProcessConnectRequest(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame)
{
	PMSD	pMSD = NULL;

	LOGPF(2, "CONNECT REQUEST RECEIVED; EPD=%p SessID=%x", pEPD, pCFrame->dwSessID);

	// Verify Listen
	//
	//		We have already referenced the Listen MSD in the IndicateConnection code so we know that the
	// listen has not evaporated...  unless,  of course,  this ConnectRequest arrived on an already connected
	// endpoint.  In this case,  the pCommand pointer in the EPD will be NULL indicated that there was no
	// Listen command involved.  Now here is the rub...  We need to make sure that we are still accepting
	// CONNECT commands on the port that this connection came in on,  but when no listen was involved we have
	// no way of knowing this.  It is insufficent to track whether our original Listen is still active because
	// it may or may not have been replaced with an equivalent listen.  The easiest (perhaps only sensible) way
	// to ensure we are still listening on this guy's port is to Disconnect the endpoint (ignoring this CONNECT
	// request) and continue when partner's RETRY triggers an IndicateConnect (or else is never heard from again).

	if((pMSD = pEPD->pCommand) == NULL)
	{
		// This must be a re-init of an existing connection
		Lock(&pEPD->EPLock);
		
		if(pEPD->dwSessID == pCFrame->dwSessID)
		{
			// Partner is retransmitting a CONN request that we have already seen & responded to.
			//
			//		Since he is calling with the correct SessID,  the odds are good that is he re-transmitting
			// because he dropped our original response.

			LOGPF(5, "(%p) CONNECT Frame received on CONNECTED link, Re-Sending CONNECTED Frame", pEPD);
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID);	// If this fails we have no remedy...

			Unlock(&pEPD->EPLock);
			return;
		}

		LOGPF(5, "EXISTING CONNECTION RE-INITED BY PARTNER (%p)", pEPD);

		if((pEPD->ulEPFlags & EPFLAGS_TERMINATING)==0){				// Make sure DropLink never gets called more then once
			LOGPF(5, "(%p) Endpoint is terminating, Drop Link", pEPD);
			DropLink(pEPD);											// This call releases EPLock
		}
		else
		{
			Unlock(&pEPD->EPLock);
		}
		DisconnectConnection(pEPD);									// Force this EP closed early!
		return;
	}

	ASSERT_MSD(pMSD);

	Lock(&pMSD->CommandLock);

	Lock(&pEPD->EPLock);											// Serialize access to EPD (this may not really be new sess)

	if(pMSD->CommandID == COMMAND_ID_CONNECT)
	{
		LOGPF(0, "(%p) PROTOCOL RECEIVED CONNECT REQUEST ON A CONNECTING (NOT LISTENING) ENDPOINT, IGNORING", pEPD);
		Unlock(&pEPD->EPLock);
		Unlock(&pMSD->CommandLock);
		return;
	}

	if((pCFrame->dwVersion >> 16) != (DNET_VERSION_NUMBER >> 16))
	{
		LOGPF(0, "(%p) PROTOCOL RECEIVED CONNECT REQUEST FROM AN INCOMPATIBLE VERSION, DROPPING LINK", pEPD);
		Unlock(&pMSD->CommandLock);
		pEPD->ulEPFlags |= EPFLAGS_ABORT;	// This will prevent Core notification for a connection it has never seen
		DropLink(pEPD);		// This releases the EPLock
		return;
	}

	if((pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED)) || (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT))
	{
		LOGPF(0, "(%p) PROTOCOL RECEIVED CONNECT REQUEST ON A COMMAND THAT IS ABORTED OR CANCELLED, DROPPING LINK", pEPD);
		pEPD->ulEPFlags |= EPFLAGS_CONNECTING;						// This will allow proper cleanup to occur in DropLink
		DropLink(pEPD);												// releases SendQLock
		return;														// Not interested in CONNECT frames w/o listen pending
	}

	// If we are already connected to this guy,  then there are two possibilities:
	// There is a left-over Connect frame,  which should be ignored;  or
	// The partner has rebooted and is trying to re-connect,  in which case we need to reset the link

	// If we are already in CONNECTING state then either this is not the first CONNECT frame we have seen,  both sides
	// issued CONNECT commands concurrently,  or maybe partner has ABORTED and re-started with a new ConnID.
	//
	// If the ConnID is consistant then we should send a new CONNECTED response because he probably lost our first one.
	// Although we retry,  he needs a correlatable response to get an accurate RTT and clock Bias.
	//
	// If the ConnID in different then we follow the Concurrent Connect Rules,  which say that the higher SessID will
	// be used.


	if(pEPD->ulEPFlags & EPFLAGS_CONNECTED) 
	{						// Are we already connected?
		// If connection has been completed then we dont need to do more work
		Unlock(&pEPD->EPLock);
		Unlock(&pMSD->CommandLock);
		return;
	}

	if(pEPD->ulEPFlags & EPFLAGS_CONNECTING) 
	{						// Is this not the first frame we've seen?
		if(pEPD->dwSessID != pCFrame->dwSessID)
		{
			// Looks like a simultaneous CONNECT scenario.  High ID wins...

			if(pCFrame->dwSessID < pEPD->dwSessID)
			{
				// Our larger session number wins.  We ignore this guy's request
				LOGPF(1, "(%p) Received synchronous CONNECT request. Lower ID is IGNORED", pEPD);
				Unlock(&pEPD->EPLock);
				Unlock(&pMSD->CommandLock);
				return;
			}
			else 
			{
				// Will use partner's SessID.
				//
				// We will fall thru and let EPD get reset with new SessID and then we
				// will become an eerie hybrid Connect/Listen MSD.

				LOGPF(1, "(%p) Received synchronous CONNECT request. We will YIELD", pEPD);
				
				if(pEPD->ConnectTimer != 0)
				{
					LOGPF(5, "(%p) Cancelling Connect Timer", pEPD);
					if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
					{
						RELEASE_EPD(pEPD, "UNLOCK (Stop Connect Timer)");	// release lock for timer, SendQLock not already held
						pEPD->ConnectTimer = 0;						// stop timer from previous CONNECT
					}
					else
					{
						LOGPF(5, "(%p) Cancelling Connect Timer Failed", pEPD);
					}
				}
				// FALLTHRU and we will be re-initialized to reflect the new SessID
			}
		} // SESSID !=  CFrame->SESSID
		else 
		{
			// Unexpected CONNECT Frame has same Session ID.  Partner probably lost our response.  We will
			// respond again to this one.
			
			LOGPF(1, "(%p) Received duplicate CONNECT request. Sending another response...", pEPD);

			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID);
			Unlock(&pEPD->EPLock);
			Unlock(&pMSD->CommandLock);
			return;
		}
	}
	else 
	{
		// This IS a new connection.  We need to hook the EPD up to the Listen.

		ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);
		ASSERT((pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)==0);

		pEPD->blSPLinkage.InsertBefore( &pMSD->blFrameList);
		pEPD->ulEPFlags |= EPFLAGS_LINKED_TO_LISTEN;
		pMSD->pEPD = pEPD;
	}

	pEPD->ulEPFlags |= EPFLAGS_CONNECTING;
	pEPD->ulEPFlags &= ~(EPFLAGS_END_POINT_DORMANT);

	pEPD->dwSessID = pCFrame->dwSessID;							// Use this SessID in all C-traffic
	pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;					// We will expect a reply to this frame

	LOGPF(5, "(%p) Sending CONNECTED Frame", pEPD);
	if(SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID) != DPN_OK)
	{
		LOGPF(0, "(%p) Sending CONNECTED Frame Failed", pEPD);
		pEPD->pCommand = NULL;									// Unlock Cmd from EPD

		ASSERT(pEPD->ConnectTimer == NULL);
		
		if(pMSD->CommandID == COMMAND_ID_LISTEN)
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();
		
			Unlock(&pEPD->EPLock);
			KillConnection(pEPD);
			RELEASE_MSD(pMSD, "EPD Ref");						// releases CommandLock & ref for EPD Link
			return;
		}
		else
		{
			DECREMENT_MSD(pMSD, "EPD Ref");						// release reference for EPD link
			Unlock(&pEPD->EPLock);
			CompleteConnect(pMSD, pSPD, pEPD,  DPNERR_OUTOFMEMORY);
			return;
		}
	}

	pEPD->uiRetryTimeout = pSPD->pPData->dwConnectTimeout;		// Got to start somewhere
	pEPD->uiRetryCount = pSPD->pPData->dwConnectRetries;		// w/exponential wait,  we will have ~22 minutes unless user times out first

	LOCK_EPD(pEPD, "LOCK: (CONNECT RETRY TIMER)");				// Create reference for timer
	LOGPF(5, "(%p) Setting Connect Timer", pEPD);
	SetMyTimer(pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, &pEPD->ConnectTimer, &pEPD->ConnectTimerUnique);

	Unlock(&pEPD->EPLock);
	Unlock(&pMSD->CommandLock);
}

/*
**		Process Connected Response
**
**		A response to a connection request has arrived (or a response to
**	our connection response).  Now the connection is officially up (on
**	our end of the circuit).  Set the link-state according to our first
**	RT sample and get ready to party.
**
**		If we are the originating party,  we will want to send a
**	CONNECTED frame to our partner, even though the connection is
**	complete from our perspective.  This will allow partner to establish
**	his baseline RTT and clock bias as we can do here.  In this case,  he
**	will have his POLL bit set in the frame we just received.
**
**		Now,  we might get additional CONNECTED frames after the first one
**	where we startup the link.  This would most likely be due to our CONNECTED
**	response getting lost.  So if we get a CONNECTED frame with POLL set
**	after our link is up,  we will just go ahead and respond again without
**	adjusting our state.
**
**		Note about Locks:
**
**		This code is complicated by the precedence of CritSec ownership.  To simplify
**	as much as possible we will take the Listen command lock at the very start of the
**	procedure (when appropriate) because it has the highest level lock.  This prevents
**	us from completing the whole connection process and then finding that the Listen
**	went away so we cant indicate it to the user.
**
**		DELTA:  We now keep a RefCnt on the Listen so it wont go away while a new session
**	is pending on it.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectedResponse"

VOID ProcessConnectedResponse(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame)
{
	PCHKPT		pCP;
	PMSD		pMSD = NULL;
	DWORD		tNow = GETTIMESTAMP();
	PVOID		Context;

	LOGPF(2, "CONNECT RESPONSE RECEIVED (pEPD=0x%p)", pEPD);

	if((pEPD->dwSessID != pCFrame->dwSessID)||(pEPD->ulEPFlags & EPFLAGS_END_POINT_DORMANT))
	{	// We can ignore these babies...
		LOGPF(0, "CONNECTED response received with bad SessID");

		if((pEPD->ulEPFlags & (EPFLAGS_CONNECTING | EPFLAGS_CONNECTED))==0)
		{
			LOGPF(0, "(%p) CONNECTED response received with on Endpoint that is not connecting or connected, rejecting connection", pEPD);
			RejectConnection(pEPD);
		}
		return;
	}

	//	If we have completed our side of the connection then our only responsibility is to send responses
	// if our partner is still POLLING us.
	
	if(pEPD->ulEPFlags & EPFLAGS_CONNECTED)
	{
		if(pCFrame->bCommand & PACKET_COMMAND_POLL)
		{	// Is partner asking for immediate resp?
			Lock(&pEPD->EPLock);
			LOGPF(5, "(%p) Sending CONNECTED Frame", pEPD);
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID);
			Unlock(&pEPD->EPLock);
		}

		return;
	}

	//	Since we are not CONNECTED yet,  we must be in a CONNECTING_STATE in order to receive a CONNECTED response.
	// If not,  then we are outof sync with our partner and we can ignore this frame.
	
	if((pEPD->ulEPFlags & EPFLAGS_CONNECTING)==0)
	{
		// Should we send a DISC frame to let him know we are not communicating?  Dont think we need to..
		// We MAY want to KillEndpoint,  unless we do garbage collection for dormant Endpoints.
		LOGPF(0, "Received a CONNECTED RESPONSE but we are not in CONNECTING state!");
		return;
	}

	Lock(&pEPD->EPLock);						// Protect the pCommand field
	pMSD = pEPD->pCommand;			
	if(pMSD == NULL)
	{
		Unlock(&pEPD->EPLock);
		return;
	}

	LOCK_MSD(pMSD, "Hold For Lock");		// Place reference on Cmd until we can lock it
	Unlock(&pEPD->EPLock);					// Protect the pCommand field

 	Lock(&pMSD->CommandLock);

	if((pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED)) || (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT))
	{
		LOGPF(1, "Connect/Listen command toasted; Disregarding CONNECTED frame");

		// Whoever cancelled the Listen should be disconnecting this connection too
		// so all we have to do here is bail out.

		RELEASE_MSD(pMSD, "Hold For Lock");
		
		return;
	}
		
	// Next, take care of this guy's reply if we still owe him one

	Lock(&pEPD->EPLock);
	
	if(pCFrame->bCommand & PACKET_COMMAND_POLL)
	{				// Is partner asking for immediate resp?
		LOGPF(5, "(%p) Sending CONNECTED Frame", pEPD);
		if(SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID) != DPN_OK)
		{
			LOGPF(5, "(%p) Sending CONNECTED Frame Failed", pEPD);

			// We cannot complete the connection...  we will just let things time out
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);					// Protect the pCommand field
			return;
		}
	}

	// Now we can setup our new link,  but only if this frame Correlates to a checkpoint we have outstanding
	// so we can seed our state variables.

	// Can we correlate resp?
	if((pCP = LookupCheckPoint(pEPD, pCFrame->bRspID)) != NULL)
	{
		// We are connected, so shut off retry timer
		if(pEPD->ConnectTimer != 0)
		{
			LOGPF(5, "(%p) Cancelling Connect Timer", pEPD);
			if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
			{
				RELEASE_EPD(pEPD, "UNLOCK: (Release CONN Timer)");		//  remove reference for timer, SendQLock not already held

				// If we cannot cancel the timer then we must leave the MSD pointer in the EPD so that the timer
				// will find out that the command is complete and will finish cleaning this up
				pEPD->pCommand = NULL;
				DECREMENT_MSD(pMSD, "EPD Ref");							// Release reference for EPD link

				pEPD->ConnectTimer = 0;								// This will prevent timer from trying to do any work if it couldnt cancel
			}
			else 
			{
				LOGPF(5, "(%p) Cancelling Connect Timer Failed", pEPD);
			}
		}
		else 
		{
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");							// Release reference for EPD link
		}
		
		pEPD->ulEPFlags |= EPFLAGS_CONNECTED | EPFLAGS_STREAM_UNBLOCKED;// Link is open for business

		if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();							// Unlink EPD from Listen Queue
		}
		
		InitLinkParameters(pEPD, (tNow - pCP->tTimestamp), sizeof(CFRAME), (pCP->tTimestamp - pCFrame->tTimestamp));
		ChkPtPool->Release(ChkPtPool, pCP);

		LOGPF(5, "(%p) N(R) = 0, N(S) = 0", pEPD);
		pEPD->bNextSend = 0;
		pEPD->bNextReceive = 0;

		FlushCheckPoints(pEPD);									// Make sure we do this before the InitCheckPoint
		
		/*
		**	It turns out that the first RTT measurement is a very bad one (slow) because because
		**	it includes overhead for opening and binding a new socket,  endpoint creation,  etc.
		**	Therefore each side will take another quick sample right away.  The initial calculations
		**	above will still serve as an initial RTT until this better sample is available
		*/

		PerformCheckpoint(pEPD);								// Take another RTT sample

		// Cleanup connect operation
		if(pEPD->ulEPFlags & EPFLAGS_CALLING)
		{
			// There was a CONNECT Command issued that now must be completed
			
			pMSD->ulMsgFlags2 |= MFLAGS_TWO_COMPLETE;

			Unlock(&pEPD->EPLock);
			
			ASSERT(pMSD->CommandID == COMMAND_ID_CONNECT);
			
			DECREMENT_MSD(pMSD, "Hold For Lock");					// Remove temporary reference from above.
			
			CompleteConnect(pMSD, pSPD, pEPD, DPN_OK);
		}
		else 
		{		// LISTENING
			// We were the listener.  We will indicate a Connect event on the listen
			// command w/o completing the Listen

			ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);

			Context = pMSD->Context;
			RELEASE_MSD(pMSD, "Hold For Lock");					// release temp MSD (releases lock)
			LOGPF(3, "(%p) Calling Core->IndicateConnect", pEPD);
			pSPD->pPData->pfVtbl->IndicateConnect(pSPD->pPData->Parent, Context, (PHANDLE) pEPD, (PVOID *) &pEPD->Context);
			pEPD->ulEPFlags &= ~(EPFLAGS_CONNECTING);				// Reset opening state
			ReceiveComplete(pEPD);									// Complete any receives that queued while waiting for IndicateConnect
		}		
	}
	else 
	{
		/*
		**		Uncorrelated CONNECTED frame.  How can this happen?  Parter's response must
		**	have been dropped,  so he is retrying his CONN frame.  Since we are trying to
		**	measure an accurate RTT we dont want to use his retry against our original
		**	request,  so he zeros out his Resp correlator.  We will eventually retry with
		**	new correlator and hopefully that frame will get through.
		*/

		LOGPF(1, "(%p) Uncorrelated CONNECTED frame arrives", pEPD);
		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock");
	}
}

/*
**		Drop Link
**
**			For whatever reason we are dropping an active link.  This requires us to
**		Cancel any outstanding commands and give an indication to the user.
**
**
**		**  CALLED WITH EPD->EPLOCK HELD;  RETURNS WITH LOCK RELEASED  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DropLink"

VOID DropLink(PEPD pEPD)
{
	PRCD				pRCD;
	PRCD				pNext;
	CBilink				*pLink;
	PSPRECEIVEDBUFFER	pRcvBuff = NULL;
	PMSD				pMSD;					// Ptr for connection in progress
	PMSD				pListen = NULL;
	PProtocolData		pPData;
	PVOID				Context;

	LOGPF(5, "Drop Link %p (refcnt=%d)", pEPD, pEPD->uiRefCnt);

	ASSERT_EPD(pEPD);

	//	First set/clear flags to prevent any new commands from issueing

	pEPD->ulEPFlags &= ~(EPFLAGS_CONNECTED | EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED);	// Link is now down
	pEPD->ulEPFlags |= EPFLAGS_TERMINATING;							// Accept no new commands

	// I am creating a RefCnt bump for the send pipeline,  which means we will no longer pull EPDs off
	// the pipeline here.  The clearing of the flags above will cause the EPD to be dropped from the
	// pipeline the next time it is due to be serviced.  We CAN still clean up all the frames'n'stuff
	// because the send loop doesnt need to actually DO anything with this EPD.  This behavior allows
	// the SendThread to loop through the pipeline queue, surrendering locks, without having the queue
	// changing beneath it.

	//  Stop all timers (there are five now)

	if(pEPD->RetryTimer)
	{
		if(CancelMyTimer(pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (DROP RETRY)"); // SendQLock not already held
		}
		pEPD->RetryTimer = 0;
	}
	if(pEPD->ConnectTimer)
	{
		if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (DROP RETRY)"); // SendQLock not already held
		}
		pEPD->ConnectTimer = 0;
	}
	if(pEPD->DelayedAckTimer)
	{
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (DROP DELAYEDACK)"); // SendQLock not already held
		}
		pEPD->DelayedAckTimer = 0;
	}
	if(pEPD->DelayedMaskTimer)
	{
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (DROP DELAYED MASK)"); // SendQLock not already held
		}
		pEPD->DelayedMaskTimer = 0;
	}
	if(pEPD->SendTimer)
	{
		if(CancelMyTimer(pEPD->SendTimer, pEPD->SendTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (DROP SENDTIMER)"); // SendQLock not already held
			pEPD->SendTimer = 0;
			// BUGBUG: Do we want to NULL this and the one below in the else case as above?
		}
	}
	if(pEPD->BGTimer)
	{
		if(CancelMyTimer(pEPD->BGTimer, pEPD->BGTimerUnique) == DPN_OK)
		{
			RELEASE_EPD(pEPD, "UNLOCK (DROP BG TIMER)"); // SendQLock not already held
			pEPD->BGTimer = 0;
		}
	}

	AbortSendsOnConnection(pEPD);									// Cancel pending commands; releases SendQLock

	Lock(&pEPD->EPLock);
	
	// Are we still opening this connection?
	// After IndicateConnect we will be dormant, but not connecting
	if(pEPD->ulEPFlags & (EPFLAGS_CONNECTING | EPFLAGS_END_POINT_DORMANT))
	{
		pMSD = pEPD->pCommand;

		if(pMSD != NULL)
		{
			ASSERT_MSD(pMSD);

			Unlock(&pEPD->EPLock);										// To avoid deadlock we must release SendQLock before taking cmd lock
			Lock(&pMSD->CommandLock);
			Lock(&pEPD->EPLock);

			// We left the lock, so ensure there is still something to clean up
			if (pEPD->pCommand)
			{
				if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
				{
					pEPD->ulEPFlags &= ~EPFLAGS_LINKED_TO_LISTEN;
					pEPD->blSPLinkage.RemoveFromList();						// Unlink EPD from Listen Queue
				}
				
				pEPD->pCommand = NULL; // Tell everyone after us this is cleaned up

				if(pMSD->CommandID == COMMAND_ID_CONNECT)
				{
					Unlock(&pEPD->EPLock);
					DECREMENT_MSD(pMSD, "EPD Ref");		// Remove temporary reference, placed in IndicateConnect
					CompleteConnect(pMSD, pEPD->pSPD, pEPD, DPNERR_ABORTED); // This unlocks the MSD Lock
					Lock(&pEPD->EPLock);
				}
				else
				{
					// This unlocks the MSD lock
					RELEASE_MSD(pMSD, "EPD Ref");		// Remove temporary reference, placed in IndicateConnect
				}
			}
		}
	}


	// Now we clean up any receives in progress.  We throw away any partial or mis-ordered messages.
	while((pRCD = pEPD->pNewMessage) != NULL)
	{
		pEPD->pNewMessage = pRCD->pMsgLink;
		if(pRCD->pRcvBuff)
		{
			pRCD->pRcvBuff->pNext = pRcvBuff;
			pRcvBuff = pRCD->pRcvBuff;
		}
		else
		{
			ASSERT(pRCD->ulRFlags & (RFLAGS_FRAME_INDICATED_NONSEQ | RFLAGS_FRAME_LOST));
		}
		RELEASE_RCD(pRCD);
	}

	while(!pEPD->blOddFrameList.IsEmpty())
	{
		pLink = pEPD->blOddFrameList.GetNext();
		pRCD = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
		pLink->RemoveFromList();
		if(pRCD->pRcvBuff)
		{
			pRCD->pRcvBuff->pNext = pRcvBuff;
			pRcvBuff = pRCD->pRcvBuff;
		}
		else
		{
			ASSERT(pRCD->ulRFlags & (RFLAGS_FRAME_INDICATED_NONSEQ | RFLAGS_FRAME_LOST));
		}
		RELEASE_RCD(pRCD);
	}

	while(!pEPD->blCompleteList.IsEmpty())
	{
		pLink = pEPD->blCompleteList.GetNext();
		pRCD = CONTAINING_RECORD(pLink, RCD, blCompleteLinkage);
		pLink->RemoveFromList();
		
		ASSERT(pEPD->uiCompleteMsgCount > 0);
		pEPD->uiCompleteMsgCount--;
		
		while(pRCD != NULL)
		{
			pNext = pRCD->pMsgLink;
			
			RELEASE_SP_BUFFER(pRCD->pRcvBuff);
			
			RELEASE_RCD(pRCD);
			pRCD = pNext;
		}
	}

	Unlock(&pEPD->EPLock);

	if(pRcvBuff)
	{
		LOGPF(3, "(%p) Calling SP->ReturnReceiveBuffers", pEPD);
		IDP8ServiceProvider_ReturnReceiveBuffers(pEPD->pSPD->IISPIntf, pRcvBuff);
	}

	pPData = pEPD->pSPD->pPData;
	Context = pEPD->Context;

	KillConnection(pEPD);
	
	// Tell user that session is over

	Lock(&pEPD->EPLock);

	if(( (pEPD->ulEPFlags & (EPFLAGS_ABORT | EPFLAGS_INDICATED_DISCONNECT | EPFLAGS_CONNECTING)) == 0))
	{
		pEPD->ulEPFlags |= EPFLAGS_INDICATED_DISCONNECT;
		Unlock(&pEPD->EPLock);
		LOGPF(3, "(%p) Calling Core->IndicateConnectionTerminated", pEPD);
		pEPD->pSPD->pPData->pfVtbl->IndicateConnectionTerminated(pEPD->pSPD->pPData->Parent, Context, DPNERR_CONNECTIONLOST);
	}
	else 
	{
		Unlock(&pEPD->EPLock);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\command.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Command.c
 *  Content:	This file contains code which implements assorted APIs for the
 *				DirectNet protocol.  APIs implemented in this file are: CANCEL_COMMAND
 *				DISCONNECT_CONNECTION,  ABORT_CONNECTION.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *
 ****************************************************************************/


#include "dnproti.h"

#undef		DPF_MODNAME
#define		DPF_MODNAME		"PROTOCOL"

VOID		AbortDatagramSend(PMSD, HRESULT);

/*
**		Cancel Command
**
**			This procedure is passed a HANDLE returned from a previous asynchronous
**	DPLAY command.  At the moment,  the handle is a pointer to an internal data
**	structure.  Problem with this is that due to FPM's (fixed pool manager) design
**	they will get recycled very quickly and frequently.  We might want to map them
**	into an external handle table which will force them to recycle much more slowly.
**	Perhaps,  I will let the upper DN layer do this mapping...
**
**		Anyway,  the only check I can do right now is that the HANDLE is currently
**	allocated to something.
**
**		We do not expect cancels to happen very often.  Therefore,  I do not feel
**	bad about walking the global command list to find the Handle.  Of course,  if
**	we do go to a handle mapped system then we should not need to do this walk.
**
**	I THINK - That any cancellable command will be on either MessageList or TimeoutList!
**
**		Things we can cancel and their possible states:
**
**		SEND Datagram
**			On SPD Send Queue
**			On EPD Send Queue
**			In SP call
**			
**		SEND Reliable
**			We can only cancel if it has not started transmitting.  Once its started, the
**				user program must Abort the link to cancel the send.
**
**		CONNECT
**			In SP call
**			On PD list
**
**		LISTEN
**			In SP call
**			On PD list
**
**		Remember,  if we cancel a command in SP then the CommandComplete is supposed to
**	occur.  This means that we should not have to explicitly free the MSD, etc in these
**	cases.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "DNPCancelCommand"

HRESULT
DNPCancelCommand(PProtocolData pPData,  HANDLE hCommand)
{
	PMSD	pMSD = (PMSD) hCommand;
	HRESULT	hr;

	LOGPF(2, "Parameters: pPData[%p], hCommand[%x]", pPData, hCommand);

	if(pMSD->Sign != MSD_SIGN)
	{
		LOGPF(0, "Cancel called with invalid handle");
		return DPNERR_INVALIDHANDLE;
	}

	Lock(&pMSD->CommandLock);								// Take this early to freeze state of command
	
	// validate instance of MSD
	if(pMSD->uiRefCnt == -1)
	{	
		LOGPF(0, "Cancel called with invalid handle");
		Unlock(&pMSD->CommandLock);
		return DPNERR_INVALIDHANDLE;
	}

	hr = DoCancel(pMSD, DPNERR_USERCANCEL);

	return hr;
}


/*
**		Do Cancel
**
**		This function implements the meat of the cancel asynch operation.  It gets called from
**	two places.  Either from the User cancel API right above,  or from the global timeout handler.
**	This code requires the MSD->CommandLock to be help upon entry.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DoCancel"

HRESULT
DoCancel(PMSD pMSD, HRESULT CompletionCode)
{
	PMSD	pMSD1;
	PFMD	pFMD;
	PEPD	pEPD;
	HANDLE	hCommand;
	DWORD	dwDesc;
	HRESULT	hr = DPN_OK;

	LOGPF(7, "Cancelling pMSD=%p", pMSD);

	if((pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED) || (pMSD->ulMsgFlags2 & MFLAGS_TWO_COMPLETE))
	{
		LOGPF(7, "(%p) MSD is Cancelled or Complete, returning DPNERR_CANNOTCANCEL MSD=%p", pMSD->pEPD, pMSD);
		Unlock(&pMSD->CommandLock);
		return DPNERR_CANNOTCANCEL;
	}

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_CANCELLED;
	
	switch(pMSD->CommandID)
	{
		case COMMAND_ID_SEND_DATAGRAM:

			pEPD = pMSD->pEPD;
			
			Lock(&pEPD->EPLock);
			
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_ABORT | MFLAGS_TWO_TRANSMITTING))
			{				
				LOGPF(7, "(%p) MSD is Aborted or Transmitting, returning DPNERR_CANNOTCANCEL MSD=%p", pMSD->pEPD, pMSD);
				Unlock(&pEPD->EPLock);					// Link is dropping or DNET is terminating
				hr = DPNERR_CANNOTCANCEL;						// To cancel an xmitting reliable send you
				break;											// must Abort the connection.
			}
			
			pMSD->blQLinkage.RemoveFromList();							// Remove from SendQueue (whichever one)

			ASSERT(pEPD->uiQueuedMessageCount > 0);
			--pEPD->uiQueuedMessageCount;								// keep count of MSDs on all send queues

			// Clear data-ready flag if everything is sent
			if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
			{	
				pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
			}

			ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
			pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);

			Unlock(&pEPD->EPLock);						// release lock on queue

			LOGPF(7, "(%p) Aborting Datagram send MSD=%p", pEPD, pMSD);

			AbortDatagramSend(pMSD, CompletionCode);
			return hr;
			
/**

			// CODE WORK -- We can improve the datagram CANCEL code by allowing a partially transmitted DG to be
			//	cancelled. There are two steps to this.  First,  we can try to cancel a Send that is submitted but
			//  not completed,  something which may be useful in limited situations,  AND second we can abort a DG send
			//  if all frames have not been submitted to the SP yet. In this case,  we would have to modify the receive code
			//  to pitch a partial DG receive if a new message is started before the partial message is completed.  It may
			//  very well work this way alredy.  but we would certainly want to verify it...


				Unlock(&pEPD->SendQLock);					// Release lock on EPD's send queues
				
				pFMD = CONTAINING_RECORD(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
				ASSERT_FMD(pFMD);
				LOCK_FMD(pFMD);

				if(pFMD->bSubmitted){
					hCommand = pFMD->SendDataBlock.hCommand;
					dwDesc = pFMD->SendDataBlock.dwCommandDescriptor;

					if(hCommand != NULL){
						Unlock(&pMSD->CommandLock);						// Release lock on command structure
						LOGPF(3, "Submitting Cancel on DG pFMD=%p", pFMD);
						hr = IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, hCommand, dwDesc);
						RELEASE_FMD(pFMD);

						return hr;
					}
				}
				
				hr = DPNERR_CANNOTCANCEL;
				RELEASE_FMD(pFMD);
				break;
**/			
			
		case COMMAND_ID_SEND_RELIABLE:
		
			pEPD = pMSD->pEPD;
			
			Lock(&pEPD->EPLock);
			
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_ABORT | MFLAGS_TWO_TRANSMITTING))
			{				
				LOGPF(7, "(%p) MSD is Aborted or Transmitting, returning DPNERR_CANNOTCANCEL MSD=%p", pMSD->pEPD, pMSD);
				Unlock(&pEPD->EPLock);						// Link is dropping or DNET is terminating
				hr = DPNERR_CANNOTCANCEL;						// To cancel an xmitting reliable send you
				break;											// must Abort the connection.
			}
			
			if(pMSD->TimeoutTimer != NULL)
			{
				LOGPF(7, "(%p) Cancelling Timeout Timer", pEPD);
				if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
				{
					pMSD->TimeoutTimer = NULL;
					DECREMENT_MSD(pMSD, "Send Timeout Timer");
				}
				else
				{
					LOGPF(7, "(%p) Cancelling Timeout Timer Failed", pEPD);
				}
			}
			
			pMSD->blQLinkage.RemoveFromList();							// Remove cmd from queue

			ASSERT(pEPD->uiQueuedMessageCount > 0);
			--pEPD->uiQueuedMessageCount;								// keep count of MSDs on all send queues

			// Clear data-ready flag if everything is sent
			if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
			{	
				pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
			}

			ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
			pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);

			// This only gets complex if the cancelled send was the "on deck" send for the endpoint.
			//
			// New Logic!  With advent of priority sending,  we can no longer prepare the On Deck send before we are
			// ready to transmit since the arrival of a higher priority send should be checked for before starting to
			// send a new message. This means that pCurrentSend != pMSD unless the MFLAGS_TRANSMITTING flag has also
			// been set,  rendering the message impossible to cancel.

			ASSERT(pEPD->pCurrentSend != pMSD);
			
			Unlock(&pEPD->EPLock);

			LOGPF(7, "(%p) Completing Reliable Send", pEPD);
			CompleteReliableSend(pMSD->pSPD, pMSD, CompletionCode);
			
			return hr;
			
		case COMMAND_ID_CONNECT:
			
			if(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER)
			{
				// SP owns the command - issue a cancel and let CompletionEvent clean up command
				
				Unlock(&pMSD->CommandLock);				// We could deadlock if we cancel with lock held

				LOGPF(3, "Calling SP CancelCommand on Connect, pMSD[%p]", pMSD);
				(void) IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
				
					// If the SP Cancel fails it should not matter.  It would usually mean we are
					// in a race with the command completing,  in which case the cancel flag will
					// nip it in the bud.

				return DPN_OK;
			}

			// Once we are past the call to SP,  we are either waiting on a timer or processing
			// a timer event.  If waiting on timer,  we can cancel timer and clean up.  If cancel
			// indicates that event will run,  then we bail out and let the timer event clean up.
			// If the event was processing already,  then we would have blocked on CommandLock so
			// it will be waiting for the next event by the time we reach this code.

			pEPD = pMSD->pEPD;
			Lock(&pEPD->EPLock);
			
			if (pEPD->ConnectTimer != NULL)
			{
				LOGPF(5, "(%p) Cancelling Connect Timer", pEPD);
				if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
				{
					pEPD->ConnectTimer = 0;
					RELEASE_EPD(pEPD, "UNLOCK: (Free Connect Timer in CancelConnect)");	// Remove reference for timer, SendQLock not already held
				}
				else
				{
					LOGPF(5, "(%p) Cancelling Connect Timer Failed", pEPD);
				}
			}

			if(pMSD->TimeoutTimer != NULL)
			{
				LOGPF(5, "Cancelling Timeout Timer, pMSD[%p]", pMSD);
				if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
				{
					pMSD->TimeoutTimer = NULL;
					DECREMENT_MSD(pMSD, "Connect Timeout Timer");
				}
				else
				{
					LOGPF(5, "Cancelling Timeout Timer Failed, pMSD[%p]", pMSD);
				}
			}

			if(pEPD->pCommand != NULL)
			{
				pEPD->pCommand = NULL;
				DECREMENT_MSD(pMSD, "EPD Ref");
			}

			Unlock(&pEPD->EPLock);
			
			LOGPF(5, "Completing Connect, pMSD[%p]", pMSD);
			CompleteConnect(pMSD, pMSD->pSPD, pMSD->pEPD, CompletionCode); // releases command lock

			return DPN_OK;
			
		case COMMAND_ID_LISTEN:

			/*
			**		Cancel Listen
			**
			**		SP will own parts of the MSD until the SPCommandComplete function is called.  We will
			**	defer much of our cancel processing to this handler.
			*/

			// Stop listening in SP -- This will prevent new connections from popping up while we are
			// closing down any left in progress.  Only problem is we need to release command lock to
			// do it.

			Unlock(&pMSD->CommandLock);								// We can deadlock if we hold across this call

			LOGPF(3, "Calling SP CancelCommand on Listen, pMSD[%p]", pMSD);
			if (FAILED(IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc)))
			{
				LOGPF(6, "Calling our own CommandComplete since SP->CancelCommand failed");
				(void) DNSP_CommandComplete((IDP8SPCallback *) pMSD->pSPD, NULL, CompletionCode, (PVOID) pMSD);
			}

			Lock(&pMSD->CommandLock);								// Lock this down again.
			
			// Are there any connections in progress?
			while(!pMSD->blFrameList.IsEmpty())
			{				
				pEPD = CONTAINING_RECORD(pMSD->blFrameList.GetNext(), EPD, blSPLinkage);

				LOGPF(1, "FOUND CONNECT IN PROGRESS ON CANCELLED LISTEN, EPD=%p", pEPD);

				Lock(&pEPD->EPLock);

				ASSERT(pEPD->pCommand == pMSD);						// This should be pointing back to this listen

				pEPD->ulEPFlags |= (EPFLAGS_TERMINATING | EPFLAGS_ABORT);
				pEPD->ulEPFlags &= ~(EPFLAGS_CONNECTING);

				LOGPF(7, "(%p) Cancelling Connect Timer", pEPD);
				if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
				{
					pEPD->ConnectTimer = 0;							// mark timer as cancelled
					RELEASE_EPD(pEPD, "UNLOCK (Free Retry Timer in CancelListen)");		// remove reference for timer, SendQLock not already held

					if(pEPD->pCommand != NULL)
					{
						pEPD->pCommand = NULL;
						DECREMENT_MSD(pMSD, "EPD Ref");				// Unlink from EPD and release associated reference
					}
				}
				else
				{
					LOGPF(7, "(%p) Cancelling Connect Timer Failed", pEPD);
				}

				if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
				{
					pEPD->ulEPFlags &= ~EPFLAGS_LINKED_TO_LISTEN;
					pEPD->blSPLinkage.RemoveFromList();						// Unlink EPD from Listen Queue
				}
				
				SendDisconnectedFrame(pEPD);						// Tell partner that we are giving up
				
				Unlock(&pEPD->EPLock);
				
				KillConnection(pEPD);								// Make it go away...
			}	// for each connection in progress
			
			RELEASE_MSD(pMSD, "Release On Cancel");					// release base reference
			
			return DPN_OK;
	
		case COMMAND_ID_ENUM:
		{
			Unlock(&pMSD->CommandLock);

			LOGPF(3, "Calling SP->CancelCommand on Enum, pMSD[%p]", pMSD);
			return IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
			
			// We will pass HRESULT from SP directly to user
		}
		case COMMAND_ID_ENUMRESP:			
		{
			Unlock(&pMSD->CommandLock);

			LOGPF(3, "Calling SP->CancelCommand on EnumResp, pMSD[%p]", pMSD);
			return IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
			
			// We will pass HRESULT from SP directly to user
		}

		case COMMAND_ID_DISCONNECT:
		case COMMAND_ID_COPIED_RETRY:		// This should be on FMD's only
		case COMMAND_ID_CFRAME:				// This should be on FMD's only
		case COMMAND_ID_DISC_RESPONSE:		// These are never placed on the global list and aren't cancellable
		case COMMAND_ID_KEEPALIVE:			// These are never placed on the global list and aren't cancellable
		default:
			ASSERT(0);		// Should never get here
			break;
	}

	Unlock(&pMSD->CommandLock);
	
	return hr;
}


/*
**		Get Listen Info
**
**		Return a buffer full of interesting and provokative tidbits about a particular Listen command.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetListenAddressInfo"

HRESULT
DNPGetListenAddressInfo(HANDLE hCommand, PSPGETADDRESSINFODATA pSPData)
{
	PMSD	pMSD = (PMSD) hCommand;
	HRESULT	hr = DPNERR_INVALIDHANDLE;

	LOGPF(2, "Parameters: hCommand[%x], pSPData[%p]", hCommand, pSPData);

	ASSERT(pMSD != NULL);
	ASSERT_MSD(pMSD);

	if((pMSD->CommandID == COMMAND_ID_LISTEN) && (pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER))
	{
		pSPData->hEndpoint = pMSD->hListenEndpoint;

		LOGPF(3, "Calling SP->GetAddressInfo");
		hr = IDP8ServiceProvider_GetAddressInfo(pMSD->pSPD->IISPIntf, pSPData);
	}

	return hr;
}

/*
**		Validate End Point
**
**		This routine checks standard flags,  validates the Service
**	Provider,  and bumps the reference count on an end point descriptor
**	which is passed in.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateEndPoint"

HRESULT
ValidateEndPoint(PProtocolData pPData,  PEPD pEPD)
{
	PSPD	pSPD;

	if(pEPD == NULL)
		return DPNERR_INVALIDENDPOINT;
		
	ASSERT_EPD(pEPD);
	
	// Bump reference count on this baby
	if(!LOCK_EPD(pEPD, "LOCK (ValidateEndPoint)"))
	{
		LOGPF(1, "Validate EndPoint Fails on unreferenced EPD (%p)", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	if( (pEPD->ulEPFlags & (EPFLAGS_END_POINT_IN_USE | EPFLAGS_CONNECTED)) !=
							(EPFLAGS_END_POINT_IN_USE | EPFLAGS_CONNECTED))
	{
		RELEASE_EPD(pEPD, "UNLOCK (Validate EP fails)"); // SendQLock not already held
		LOGPF(1, "Validate Endpoint Fails on unconnected EP (%p)", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	pSPD = pEPD->pSPD;
	
	return DPN_OK;
}

/*
**		Disconnect End Point
**
**		This function is called when the client no longer wishes
**	to communicate with the specified end point.  We will initiate
**	the disconnect protocol with the endpoint,  and when it is
**	acknowleged,  we will disconnect the SP and release the handle.
**
**		Disconnect is defined in Direct Net to allow all previously
**	submitted sends to complete,  but no additional sends to be submitted.
**	Also, any sends the partner has in progress will be delivered,  but
**	no additional sends will be accepted following the indication that
**	a disconnect is in progress on the remote end.
**
**		This implies that two indications will be generated on the remote
**	machine,  Disconnect Initiated and Disconnect Complete.  Only the
**	Complete will be indicated on the issueing side.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPDisconnectEndPoint"

HRESULT
DNPDisconnectEndPoint(PProtocolData pPData,  HANDLE hEndPoint, PVOID pvContext, PHANDLE phCommand)
{
	PEPD	pEPD;
	PMSD	pMSD;
	HRESULT	hr;

	LOGPF(2, "Parameters: pPData[%p], hEndPoint[%x], pvContext[%p], phCommand[%p]", pPData, hEndPoint, pvContext, phCommand);

	if((pEPD = (PEPD) hEndPoint) == NULL)
	{
		LOGPF(0, "Attempt to disconnect NULL endpoint");
		return DPNERR_INVALIDENDPOINT;
	}

	ASSERT_EPD(pEPD);

	// This bumps REFCNT
	if((hr = ValidateEndPoint(pPData, pEPD)) != DPN_OK)
	{
		LOGPF(0, "Attempt to disconnect invalid endpoint");
		return hr;
	}

	Lock(&pEPD->EPLock);

	if(pEPD->ulEPFlags & (EPFLAGS_TERMINATING | EPFLAGS_SENT_DISCONNECT))
	{
		RELEASE_EPD(pEPD, "UNLOCK (Disconnect EP fails)"); // SendQLock not already held
		Unlock(&pEPD->EPLock);
		LOGPF(1, "Attempt to disconnect already disconnecting endpoint");
		return DPNERR_ALREADYDISCONNECTING;
	}

	pEPD->ulEPFlags |= (EPFLAGS_TERMINATING | EPFLAGS_SENT_DISCONNECT); 	// Accept no more sends, but dont scrap link yet

	if((pMSD = BuildDisconnectFrame(pEPD)) == NULL)
	{
		Unlock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (no memory)"); // SendQLock not already held
		LOGPF(0, "Failed to build disconnect frame");
		return DPNERR_OUTOFMEMORY;								// The educated user will next try an Abort command
	}
	
	pMSD->CommandID = COMMAND_ID_DISCONNECT;
	pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_LOW_PRIORITY; // Priority is LOW so all previously submitted traffic will be sent
	pMSD->pSPD = pEPD->pSPD;
	pMSD->Context = pvContext;									// retain user's context value
	*phCommand = pMSD;											// pass back command handle

	Lock(&pMSD->pSPD->SendQLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;// BUGBUG: Is command lock held?
	Unlock(&pMSD->pSPD->SendQLock);

	LOGPF(5, "(%p) Queueing DISCONNECT message", pEPD);
	EnqueueMessage(pMSD, pEPD);									// Enqueue Disc frame on SendQ
	
	Unlock(&pEPD->EPLock);
	
	return DPNERR_PENDING;
}

/*
**		Get/Set Protocol Caps
**
**		Return or Set information about the entire protocol.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetProtocolCaps"

HRESULT
DNPGetProtocolCaps(PProtocolData pPData, PDPN_CAPS pData)
{
	LOGPF(2, "Parameters: pPData[%p], pData[%p]", pPData, pData);
	
	ASSERT(pData->dwSize == sizeof(DPN_CAPS));
	ASSERT(pData->dwFlags == 0);

	pData->dwConnectTimeout = pPData->dwConnectTimeout;
	pData->dwConnectRetries = pPData->dwConnectRetries;
	pData->dwTimeoutUntilKeepAlive = pPData->tIdleThreshhold;
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNPSetProtocolCaps"

HRESULT
DNPSetProtocolCaps(PProtocolData pPData, const DPN_CAPS * const pData)
{
	LOGPF(2, "Parameters: pPData[%p], pData[%p]", pPData, pData);

	ASSERT(pData->dwSize == sizeof(DPN_CAPS));
	ASSERT(pData->dwFlags == 0);
	
	pPData->dwConnectTimeout = pData->dwConnectTimeout;
	pPData->dwConnectRetries = pData->dwConnectRetries;
	pPData->tIdleThreshhold = pData->dwTimeoutUntilKeepAlive;

	return DPN_OK;
}

/*
**		Get Endpoint Caps
**
**		Return information and statistics about a particular endpoint.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetEPCaps"

HRESULT
DNPGetEPCaps(HANDLE hEndpoint, PDPN_CONNECTION_INFO pBuffer)
{
	PEPD	pEPD;

	LOGPF(6, "Parameters: hEndpoint[%x], pBuffer[%p]", hEndpoint, pBuffer);

	pEPD = (PEPD) hEndpoint;
	
	if(pEPD == NULL || !(pEPD->ulEPFlags & EPFLAGS_CONNECTED))
	{
		LOGPF(0, "Returning DPNERR_INVALIDENDPOINT - hEndpoint is NULL or Enpoint is not connected");
		return DPNERR_INVALIDENDPOINT;
	}
	if(pBuffer == NULL)
	{
		LOGPF(0, "Returning DPNERR_INVALIDPARAM - pBuffer is NULL");
		return DPNERR_INVALIDPARAM;
	}
	
	ASSERT_EPD(pEPD);
	ASSERT(pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO));

    pBuffer->dwSize = sizeof(DPN_CONNECTION_INFO);
    pBuffer->dwRoundTripLatencyMS = pEPD->uiRTT;
    pBuffer->dwThroughputBPS = pEPD->uiPeriodRateB * 4;				// Convert to apx of bytes/second (really bytes/1024 ms)
    pBuffer->dwPeakThroughputBPS = pEPD->uiPeakRateB * 4;

	pBuffer->dwBytesSentGuaranteed = pEPD->uiGuaranteedBytesSent;
	pBuffer->dwPacketsSentGuaranteed = pEPD->uiGuaranteedFramesSent;
	pBuffer->dwBytesSentNonGuaranteed = pEPD->uiDatagramBytesSent;
	pBuffer->dwPacketsSentNonGuaranteed = pEPD->uiDatagramFramesSent;

	pBuffer->dwBytesRetried = pEPD->uiGuaranteedBytesDropped;
	pBuffer->dwPacketsRetried = pEPD->uiGuaranteedFramesDropped;
	pBuffer->dwBytesDropped = pEPD->uiDatagramBytesDropped;
	pBuffer->dwPacketsDropped = pEPD->uiDatagramFramesDropped;

	pBuffer->dwMessagesTransmittedHighPriority = pEPD->uiMsgSentHigh;
	pBuffer->dwMessagesTimedOutHighPriority = pEPD->uiMsgTOHigh;
	pBuffer->dwMessagesTransmittedNormalPriority = pEPD->uiMsgSentNorm;
	pBuffer->dwMessagesTimedOutNormalPriority = pEPD->uiMsgTONorm;
	pBuffer->dwMessagesTransmittedLowPriority = pEPD->uiMsgSentLow;
	pBuffer->dwMessagesTimedOutLowPriority = pEPD->uiMsgTOLow;

	pBuffer->dwBytesReceivedGuaranteed = pEPD->uiGuaranteedBytesReceived;
	pBuffer->dwPacketsReceivedGuaranteed = pEPD->uiGuaranteedFramesReceived;
	pBuffer->dwBytesReceivedNonGuaranteed = pEPD->uiDatagramBytesReceived;
	pBuffer->dwPacketsReceivedNonGuaranteed = pEPD->uiDatagramFramesReceived;
		
	pBuffer->dwMessagesReceived = pEPD->uiMessagesReceived;

	return DPN_OK;
}

/*		
**		Build Disconnect Frame
**
**		Build a DISC frame, a Message actually, because we return an MSD which can be inserted into
**	our reliable stream and will trigger one-side of the disconnect protocol when it is received
**	by a partner.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDisconnectFrame"

PMSD
BuildDisconnectFrame(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;

	// Allocate and fill out a Message Descriptor for this operation
	
	if( (pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		LOGPF(0, "Failed to allocate MSD");
		return NULL;
	}

	pMSD->uiFrameCount = 1;
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_END_OF_STREAM;
	pMSD->pEPD = pEPD;
	
	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{
		LOGPF(0, "Failed to allocate FMD");
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Release On FMD Get Failed");
		return NULL;
	}

	pFMD->CommandID = COMMAND_ID_SEND_RELIABLE;
	pFMD->ulFFlags |= FFLAGS_END_OF_STREAM;								// Mark this frame as Disconnect
	pFMD->bPacketFlags = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_END_MSG;
	pFMD->uiFrameLength = 0;											// No user data in this frame
	pFMD->blMSDLinkage.InsertAfter( &pMSD->blFrameList);				// Attach frame to MSD
	pFMD->pMSD = pMSD;													// Link frame back to message
	pFMD->pEPD = pEPD;

	return pMSD;
}

/*
**		Abort End Point
**
**		This function closes an EndPoint without performing the
**	disconnect protocol.  This allows the data structures to
**	be cleaned up immediately,  and therefore completes
**	synchronously.  We will attempt to notify the remote endpoint
**	although we dont guarentee delivery.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPAbortEndPoint"

HRESULT
DNPAbortEndPoint(PProtocolData pPData,  HANDLE hEndPoint)
{
	PEPD	pEPD;
	HRESULT	hr;

	pEPD = (PEPD) hEndPoint;

	LOGPF(2, "Paramters: pPData[%p], hEndPoint[%x]", pPData, hEndPoint);
	
	// This will add a reference to the endpoint
	if((hr = ValidateEndPoint(pPData, pEPD)) != DPN_OK)
	{		
		LOGPF(0, "(%p) Attempt to Abort invalid Endpoint", pEPD);
		return hr;
	}

	Lock(&pEPD->EPLock);

	pEPD->ulEPFlags |= EPFLAGS_TERMINATING;						// Accept no more sends, but dont scrap link yet
	pEPD->ulEPFlags &= ~(EPFLAGS_CONNECTED);
	
	LOGPF(5, "(%p) Sending Disconnected Frame", pEPD);
	SendDisconnectedFrame(pEPD);							// Tell partner that we've buggered off

	LOGPF(5, "(%p) Dropping Link", pEPD);
	DropLink(pEPD);											// releases SendQLock
	
	RELEASE_EPD(pEPD, "UNLOCK (Abort done)");				// Release THIS reference, SendQLock not already held

	return DPN_OK;
}

/*
**		Abort Sends on Connection
**
**		Walk the EPD's send queues and cancel all sends awaiting service.  We might add
**	code to issue Cancel commands to the SP for frames still owned by SP.  On one hand,
**	we are not expecting a big backlog to develop in SP,  but on the other hand it still
**	might happen.  Esp, if we dont fix behavior I have observed with SP being really pokey
**	about completing transmitted sends.
**
**	**  CALLED WITH EPD->SENDQLOCK HELD;  RETURNS WITH LOCK RELEASED  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "AbortSendsOnConnection"

VOID
AbortSendsOnConnection(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;
	CBilink	*pLink;
	CBilink	TempList;
	PVOID	Context;
	UINT	counter;

	TempList.Initialize();										// We will empty all send queues onto this temporary list

	do 
	{
		if( (pLink = pEPD->blHighPriSendQ.GetNext()) == &pEPD->blHighPriSendQ)
		{
			if( (pLink = pEPD->blNormPriSendQ.GetNext()) == &pEPD->blNormPriSendQ)
			{
				if( (pLink = pEPD->blLowPriSendQ.GetNext()) == &pEPD->blLowPriSendQ)
				{
					if( (pLink = pEPD->blCompleteSendList.GetNext()) == &pEPD->blCompleteSendList)
					{
						break;										// ALL DONE - No more sends
					}
				}
			}
		}

		// We have found another send on one of our send queues.

		pLink->RemoveFromList();											// Remove it from the queue
		pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
		ASSERT(pMSD);
		pMSD->ulMsgFlags2 |= MFLAGS_TWO_ABORT;						// Do no further processing
		pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);

		LOGPF(5, "ABORT SENDS.  Found 0x%p", pMSD);

		pMSD->blQLinkage.InsertBefore( &TempList);				// Place on the temporary list
	} 
	while (1);

	pEPD->uiQueuedMessageCount = 0;								// keep count of MSDs on all send queues

	if((pMSD = pEPD->pCommand) != NULL)
	{
		// There may be a DISCONNECT command waiting on this special pointer for the final DISC frame
		// from partner to arrive

		if(pMSD->CommandID == COMMAND_ID_DISCONNECT)
		{
			pEPD->pCommand = NULL;

			pMSD->blQLinkage.InsertBefore( &TempList);
		}
	}

	//	If we clear out our SendWindow before we cancel the sends,  then we dont need to differentiate
	//	between sends that have or have not been transmitted.

	while(!pEPD->blSendWindow.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		pFMD->ulFFlags &= ~(FFLAGS_IN_SEND_WINDOW);
		pEPD->blSendWindow.GetNext()->RemoveFromList();						// Eliminate each frame from the Send Window
		RELEASE_FMD(pFMD);
		LOGPF(5, "(%p) ABORT CONN:  Release frame from Window: pFMD=0x%p", pEPD, pFMD);
	}
	
	pEPD->pCurrentSend = NULL;
	pEPD->pCurrentFrame = NULL;

	while(!pEPD->blRetryQueue.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pEPD->blRetryQueue.GetNext(), FMD, blQLinkage);
		pFMD->blQLinkage.RemoveFromList();
		pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue
		RELEASE_EPD(pEPD, "UNLOCK (Releasing Retry Frame)"); // SendQLock not already held
		RELEASE_FMD(pFMD);
	}
	pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
		
	//	Now that we have emptied the EPD's queues we will release the SendQLock,  so we can lock each
	//	MSD before we complete it.
	
	Unlock(&pEPD->EPLock);

	while(!TempList.IsEmpty())
	{
		pMSD = CONTAINING_RECORD(TempList.GetNext(), MSD, blQLinkage);
		pMSD->blQLinkage.RemoveFromList();							// remove this send from temporary queue
		Lock(&pMSD->CommandLock);							// Complete call will Unlock MSD

		if((pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_USE) == 0)
		{
			ASSERT(0);
			Unlock(&pMSD->CommandLock);
		}
		else if (pMSD->CommandID == COMMAND_ID_SEND_RELIABLE)
		{
			CompleteReliableSend(pMSD->pSPD, pMSD, DPNERR_CONNECTIONLOST);
		}
		else if (pMSD->CommandID == COMMAND_ID_SEND_DATAGRAM) 
		{
			AbortDatagramSend(pMSD, DPNERR_CONNECTIONLOST);
		}
		else if (pMSD->CommandID == COMMAND_ID_KEEPALIVE) 
		{
			RELEASE_EPD(pEPD, "UNLOCK (Aborted KeepAlive)"); // SendQLock not already held
			RELEASE_MSD(pMSD, "Release On Abort");
		}
		else if (pMSD->CommandID == COMMAND_ID_DISCONNECT)
		{
			Lock(&pMSD->pSPD->SendQLock);
			if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
			{
				pMSD->blSPLinkage.RemoveFromList();					// Remove MSD from master command list
				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
			}
			RELEASE_EPD_LOCKED(pMSD->pEPD, "UNLOCK (ABORT DISC COMMAND)");	// release hold on EPD for this send, SendQLock is held already
			Unlock(&pMSD->pSPD->SendQLock);
			Context = pMSD->Context;
			RELEASE_MSD(pMSD, "Release On Complete");			// Return resources,  including all frames
			LOGPF(3, "Calling Core->CompleteDisconnect - DPNERR_CONNECTIONLOST");
			pMSD->pSPD->pPData->pfVtbl->CompleteDisconnect(pMSD->pSPD->pPData->Parent, Context, DPNERR_CONNECTIONLOST);
		}
		else if (pMSD->CommandID == COMMAND_ID_DISC_RESPONSE)
		{
			RELEASE_EPD(pEPD, "UNLOCK (ABORT DISC RESP)"); // SendQLock not already held
			RELEASE_MSD(pMSD, "Release On Abort");
		}
		else 
		{
			LOGPF(0, "UNKNOWN COMMAND FOUND ON SEND Q");	
			ASSERT(0);
		}
	}
}

/*
**		Abort Datagram Send
**
**
**	THIS IS ENTERED WITH MSD->COMMANDLOCK HELD
*/

#undef DPF_MODNAME
#define DPF_MODNAME "AbortDatagramSend"

VOID
AbortDatagramSend(PMSD pMSD, HRESULT CompletionCode)
{
	PFMD	pFMD;
	CBilink	*pLink;

	if(pMSD->TimeoutTimer != NULL)
	{
		LOGPF(7, "Cancelling Timeout Timer");
		if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
		{
			pMSD->TimeoutTimer = NULL;
			DECREMENT_MSD(pMSD, "Timeout Timer");
		}
		else
		{
			LOGPF(7, "Cancelling Timeout Timer Failed");
		}
	}
					
	pLink = pMSD->blFrameList.GetNext();

	while(pLink != &pMSD->blFrameList)
	{
		pFMD = CONTAINING_RECORD(pLink, FMD, blMSDLinkage);
		pLink = pLink->GetNext();
		if((pFMD->ulFFlags & FFLAGS_TRANSMITTED)==0)
		{
			pFMD->blMSDLinkage.RemoveFromList();
			RELEASE_FMD(pFMD);
			pMSD->uiFrameCount--;
		}
	}

	if(pMSD->blFrameList.IsEmpty())
	{
		CompleteDatagramSend(pMSD->pSPD, pMSD, CompletionCode);
	}
	else
	{
		Unlock(&pMSD->CommandLock);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetLinkParms"

VOID SetLinkParms(PEPD pEPD, PINT Data)
{
	if(Data[0])
	{
		pEPD->iGoodWindowF = pEPD->iWindowF = Data[0];
		pEPD->uiGoodWindowBI = pEPD->uiWindowBIndex = Data[0];
		
		pEPD->iWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
		LOGPF(7, "** ADJUSTING WINDOW TO %d FRAMES", Data[0]);
	}
	if(Data[1])
	{
		pEPD->uiGoodBurstSize = pEPD->uiBurstSize = Data[1];
		LOGPF(7, "** ADJUSTING BURST SIZE TO %d FRAMES", Data[1]);
	}
	if(Data[2])
	{
		pEPD->uiGoodBurstGap = pEPD->uiBurstGap = Data[2];
		LOGPF(7, "** ADJUSTING GAP TO %d ms", Data[2]);
	}
#ifdef POLL_COUNT	
	if(Data[3])
	{
		pEPD->uiPollFrequency = Data[3];
		LOGPF(7, "** ADJUSTING POLL FREQ TO %d", Data[3]);
	}
#endif

	pEPD->uiPeriodAcksBytes = 0;
	pEPD->uiPeriodXmitTime = 0;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNP_Debug"

HRESULT WINAPI DNP_Debug(PProtocolData pPData, UINT OpCode, HANDLE EndPoint, PVOID Data)
{
	PEPD	pEPD = (PEPD) EndPoint;

	switch(OpCode){
		case	1:
			// Inquire current RTT calculation for Endpoint
			*((UINT *) Data) = pEPD->uiRTT;
			break;

		case	5:
			/* Manually set link parameters */
			SetLinkParms(pEPD, (int *) Data);
			break;

		case	6:
			/* Toggle Dynamic/Static Link control */

			pEPD->ulEPFlags ^= EPFLAGS_LINK_STABLE;
			pEPD->ulEPFlags ^= EPFLAGS_LINK_FROZEN;
			break;

		default:
			return DPNERR_GENERIC;
	}

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\dnproti.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    DirectPlayAddress master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *  09/11/00	mgere	Converted to DPlay
 *
 ***************************************************************************/

#ifndef __DNPROTI_H__
#define __DNPROTI_H__

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xdbg.h>
#include <xtl.h>
#ifdef ENABLE_DPLAY_VOICE
#include <dvoicep.h>
#endif
#include <dplay8p.h>
#include <DPSP8p.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

//
// Private includes
//

class DIRECTNETOBJECT;
class CHandleTable;
class CNameTable;
class CAsyncOp;
class CConnection;
class CNameTableEntry;
class CSyncEvent;
class CNameTableOp;
class CGroupConnection;
class CGroupMember;
class CPendingDeletion;
class CQueuedMsg;
class CWorkerJob;
class CMemoryBlockTiny;
class CMemoryBlockSmall;
class CMemoryBlockMedium;
class CMemoryBlockLarge;
class CMemoryBlockHuge;

typedef	struct DPN_APPLICATION_DESC_INFO DPN_APPLICATION_DESC_INFO;
typedef struct _HANDLETABLE_ARRAY_ENTRY HANDLETABLE_ARRAY_ENTRY;

#include "dndbg.h"
#include "DNetErrors.h"
#include "OSInd.h"
#include "handletable.h"
#include "guidutil.h"
#include "bilink.h"
#include "Classbilink.h"
#include "fpm.h"
#include "PackBuff.h"
#include "LockedCCfpm.h"
#include "RCBuffer.h"
#include "StrUtils.h"
#include "Queue.h"
#include "LockedCCfpm.h"
#include "appdesc.h"
#include "nametable.h"
#include "MessageStructures.h"
#include "jobqueue.h"
#include "locals.h"
#include "iodata.h"
#include "contextcfpm.h"
#include "threadpool.h"
#include "createin.h"
#include "comutil.h"
#include "DNProt.h"
#include "frames.h"
#include "internal.h"
#include "DNPExtern.h"
#include "mytimer.h"
#include "DNCore.h"


#endif // __DNPROTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\dnprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DnProt.h
 *  Content:	This file contains structure definitions for the Direct Net protocol
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *                      (Include of mmsystem for timeGetTime)
 *   7/31/2000  RichGr  IA64: FPM_Release() overwrites first 8 bytes of chunk of memory on IA64.
 *                      Rearrange positions of members of affected structs so that's OK.  
 *
 ****************************************************************************/

#ifndef	_DNPROT_INCLUDED_
#define	_DNPROT_INCLUDED_

//#define	DPF_MODNAME		"DNET PROTOCOL"

class DIRECTNETOBJECT;


#define	VOL		volatile
/*
**		Internal Constants
*/

#define		DNP_MAX_HEADER_SIZE				36
#define		MAX_BUFFERS_IN_FRAME			12			// This is somewhat arbitrary. If someone wants more we can deal
#define		MAX_SEND_DATA_SIZE				(1024 * 16)	// Also arbitrary (16K)
#define		MAX_RETRIES						10
#define		MAX_RETRY_INTERVAL				5000		// clamp each single retry iteration at 5 seconds

#define		SMALL_BUFFER_SIZE				(1024 * 2)
#define		MEDIUM_BUFFER_SIZE				(1024 * 4)
#define		LARGE_BUFFER_SIZE				(1024 * 16)

#define		COARSE_GRAIN_TIMER_RATE			500	// millisecs


/*
**		Signatures for data structures
*/

#define		PD_SIGN			' SDP'					// Protocol Data
#define		SPD_SIGN		' DPS'					// Service Provider Descriptor
#define		EPD_SIGN		' DPE'					// End Point Descriptor
#define		MSD_SIGN		' DSM'					// Message Descriptor
#define		FMD_SIGN		' DMF'					// Frame Descriptor
#define		RCD_SIGN		' DCR'					// Receive Descriptor

/*
**		Function prototypes.
*/

void  Pools_Pre_Init();
void  Pools_Deinit();

/*
**		Internal Data Structures
**
*/

#ifdef	MICHAEL
//typedef	HRESULT	(*UserCallback)(LPVOID,DWORD, HANDLE, PCHAR, DWORD, LPVOID, HANDLE, HRESULT);	// Added LPVOID as first param
typedef HRESULT	(*UserCallback)(PVOID const pv,
								const DWORD dwMsgId,
								const HANDLE hEndPt,
								PBYTE const pData,
								const DWORD dwDataSize,
								PVOID const pvUserContext,
								const HANDLE hProtocol,
								const HRESULT hr);

#else
typedef	HRESULT	(*UserCallback)(DWORD, HANDLE, PBYTE, DWORD, LPVOID, HANDLE, HRESULT);
#endif	// MICHAEL


typedef	struct	protocoldata	ProtocolData, *PProtocolData;
typedef struct	spdesc			SPD, *PSPD;
typedef	struct	endpointdesc 	EPD, *PEPD;
typedef struct	checkptdata		CHKPT, *PCHKPT;
typedef	struct	hashtable		HashTable, *PHashTable;
typedef struct	messagedesc 	MSD, *PMSD;
typedef struct	framedesc		FMD, *PFMD;
typedef struct	recvdesc		RCD, *PRCD;

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

//	COM Object data structures

typedef struct _DNPI_INT DNPI_INT, *PDNPI_INT;


struct _DNPI_INT {
	LPVOID 				lpVtbl;
	DWORD				dwRefCnt;
	PProtocolData		pPData;
	UserCallback		pfUserCB;
};

/*	
**	Protocol Data
**
**		This structure contains all of the global state information for the
**	operating protocol.  It is grouped into a structure for (in)convenience
**	against the unlikely possibility that we ever need to run multiple instances
**	out of the same code.
*/


#define		PFLAGS_PROTOCOL_INITIALIZED			0x00000001

struct protocoldata {
	ULONG				ulProtocolFlags;	// State info about DN protocol
	PVOID				Parent;				// Direct Play Object
	DWORD				Sign;
	LONG				lSPActiveCount;	// Number of SPs currently bound to protocol

	DWORD				dwNextSessID;		// ID to assign to next session request

	DWORD				tIdleThreshhold;	// How long will we allow a link to be idle before Checkpointing
	
	DWORD				dwConnectTimeout;	// These two parameter control new connection commands
	DWORD				dwConnectRetries;
	
	PDN_PROTOCOL_INTERFACE_VTBL		pfVtbl;	//  Table of indication entry points in CORE
};

/*
**	Service Provider Descriptor
**
**		This structure describes a Service Provider that we are bound to.  It
**	contains at a minimum the vector table to call the SP,  and the SPID that
**	is combined with player IDs to make external DPIDs.  The SPID should also
**	be the index in the SPTable where this descriptor lives.
**
**		We will have one send thread per service provider,  so the thread handle
**	and its wait-event will live in this structure too.
**
**		Lower Edge Protocol Object
**
**		We will also use the SPD as the COM Object given to SP for our lower edge
**	interface.  This means that our Lower Vector Table must be the first field in
**	this structure,  and ref count must be second.
*/

#define	SPFLAGS_BYPASS_PROTOCOL			0x0001		// SP will provide protocol services

#define	SPFLAGS_LISTENING				0x0010		// SP is listening for Connection Requests
#define	SPFLAGS_SEND_THREAD_SCHEDULED	0x0020		// SP has scheduled a thread to service command frames

#define	SPFLAGS_TERMINATING				0x4000				// SP is being removed
#define	SPFLAGS_TERMINATED				0x8000				// SP is ready to shutdown

struct spdesc {
	IDP8SPCallbackVtbl	*LowerEdgeVtable;	// table used by this SP to call into us
	UINT				reserved;			// this is actually the ref count for our pretend COM object
	UINT				Sign;
	ULONG				ulSPFlags;			// Flags describing this service provider
	IDP8ServiceProvider	*IISPIntf;			// ptr to SP Object
	PProtocolData		pPData;				// Ptr to owning protocol object
	UINT				uiFrameLength;		// Frame size available to us
	UINT				uiUserFrameLength;	// Frame size available to application
	UINT				uiLinkSpeed;		// Local link speed in BPS

	DNCRITICAL_SECTION	SendQLock;			// Guard access to sendQ
	CBilink				blSendQueue;		// List of wire-ready packets to transmit over this SP
	CBilink				blPendingQueue;		// List of packets owned by SP - Shares Lock w/SendQ
	CBilink				blPipeQueue;		// List of EPD that are in the reliable send pipeline
	CBilink				blListenList;		// List of active Listen command descriptors on this SP
	CBilink				blMessageList;		// List of in use Message Descriptors
	PVOID				SendHandle;			// Handle of send thread
	UINT				SendHandleUnique;	// Same

	CBilink				blEPDActiveList;	// List of in use End Point Descriptors for this SP
};

/*
**	End Point Descriptor
**
**		An 'EPD' describes a Direct Network instance that we can communicate with.
**	This structure includes all session related information, statistics,  queues,  etc.
**	It will manage any of the three types of service simultaneously.
*/

#define	EPFLAGS_END_POINT_IN_USE		0x0001	// This EndPoint is allocated
#define	EPFLAGS_END_POINT_DORMANT		0x0002	// Connection protocol has not yet run
#define	EPFLAGS_CONNECTING				0x0004	// Attempting to establish reliable link
#define	EPFLAGS_CONNECTED				0x0008	// Reliable link established

#define	EPFLAGS_CALLING					0x0010	// This end point issued the connect command
#define	EPFLAGS_TERMINATING				0x0020	// This end point is being closed down
#define	EPFLAGS_IN_RECEIVE_COMPLETE		0x0040	// A thread is running in ReceiveComplete routine
#define	EPFLAGS_LINKED_TO_LISTEN		0x0080	// During CONNECT this EPD is linked into the Listen MSD's queue

#define	EPFLAGS_LINK_STABLE				0x0100	// We think we have found the best current transmit parameters
#define	EPFLAGS_STREAM_UNBLOCKED		0x0200	// Reliable traffic is stopped (window or throttle)
#define	EPFLAGS_SDATA_READY				0x0400	// Reliable traffic in the pipe
#define	EPFLAGS_IN_PIPELINE				0x0800	// Indicates that EPD is in the SPD pipeline queue

#define	EPFLAGS_CHECKPOINT_INIT			0x1000	// Need to send a check point packet
#define	EPFLAGS_DELAYED_SENDMASK		0x2000	// unacked check point on wire
#define	EPFLAGS_DELAYED_NACK			0x4000	// Need to send masks for missing receives
#define	EPFLAGS_DELAY_ACKNOWLEDGE		0x8000	// We are waiting for back-traffic before sending ACK frame

#define	EPFLAGS_KEEPALIVE_RUNNING	0x00010000	// Checkpoint is running
#define	EPFLAGS_SENT_DISCONNECT		0x00020000	// We have sent a DISCONNECT and are waiting for confirm
#define	EPFLAGS_RECEIVED_DISCONNECT	0x00040000	// We have received a DISCONNECT and will send confirm when done sending
#define	EPFLAGS_DISCONNECT_ACKED	0x00080000	// We sent a DISCONNECT and it has been confirmed

#define	EPFLAGS_COMPLETE_SENDS		0x00100000	// There are Reliable MSDs waiting to be called back
#define	EPFLAGS_FILLED_WINDOW_BYTE	0x00200000	// Filled Byte-Based send window
#define	EPFLAGS_FILLED_WINDOW_FRAME	0x00400000	// We have filled the frame-based SendWindow at least once during last period
#define EPFLAGS_USE_POLL_DELAY		0x00800000	// We have two-way traffic,  so wait 5ms before responding to POLL frame

#define	EPFLAGS_IDLED_PIPELINE		0x01000000	// Transmit pipeline was idle at least once during last period
#define	EPFLAGS_RETRIES_QUEUED		0x02000000	// Frames are waiting for retransmission
#define	EPFLAGS_THROTTLED_BACK		0x04000000	// temporary throttle is engaged to relieve congestion
#define	EPFLAGS_SECOND_SAMPLE		0x08000000	// We are sampling thruput a second time before switching to stable state

#define	EPFLAGS_INDICATED_DISCONNECT	0x10000000	// Ensure that we onlly call CORE once to indicate disconnection
#define	EPFLAGS_LINK_FROZEN				0x20000000	// DEBUG FLAG -- Do not run dynamic algorithm on this link
#define	EPFLAGS_ABORT					0x40000000	// Endpoint being closed by system at CloseAdapter time
#define	EPFLAGS_KILLED					0x80000000	// Someone has removed the 'base' reference to make this go away
													// We dont want to let this happen twice...

#define	MAX_RECEIVE_RANGE			64		// largest # of frames we will retain past a missing frame
#define MAX_FRAME_OFFSET			(MAX_RECEIVE_RANGE - 1)

#define	INITIAL_STATIC_PERIOD		(60 * 1000)		// How long does link remain static after finding set-point.
													// This value will double every time link finds the same set-point.

struct endpointdesc {
	HANDLE				hEndPt;				// Together with SP index uniquely defines an End Point we can reach
	UINT				Sign;				// Signature to validate data structure
	INT 				uiRefCnt;			// Reference count
	PSPD				pSPD;				// specifies the SP on which this remote instance lives
//	EPSTATE				State;				// high-level state indicator (STATIC/DYANMIC; LAN/WAN)
	ULONG VOL			ulEPFlags;			// End Point Flags
	PVOID				Context;			// Context value returned with all indications
	PMSD				pCommand;			// Connect or Listen command with which this end point was created or Disconnect cmd
	CBilink				blActiveLinkage;	// linkage for SPD list of active EndPoints
	CBilink				blSPLinkage;		// linkage for SPD (reliable) Pipeline
	CBilink				blChkPtQueue;		// linkage for active CheckPoints

	UINT				uiUserFrameLength;	// Largest frame we can transmit

	BYTE VOL			bNextMsgID;			// Next ID for datagram frames ! NOW USED FOR CFRAMES ONLY
	
	DNCRITICAL_SECTION	EPLock;				// Serialize all access to Endpoint
	

	UINT				uiRTT;				// Current RTT --  Integer portion
	UINT				fpRTT;				// Fixed Point 16.16 RTT
	
	UINT				uiDropCount;		// localized packet drop count (recent drops)
//	DWORD				tDropInterval;		// timestamp when drop count was started
//	UINT				uiDropEvents;		// count of "recent" drop events (1 DE can be multiple drops in short interval)
	DWORD				tThrottleTime;		// Timestamp when last Checking occured
	UINT				uiThrottleEvents;	// count of temporary backoffs for all reasons
#ifdef	DEBUG
	UINT				uiTotalThrottleEvents;
#endif
#ifdef POLL_COUNT	
	UINT				uiPollFrequency;	// How many frames to transmit until we POLL
	UINT				uiPollCount;		// Number of frames left to send before we POLL
#endif
	
//	DWORD				tNextRunAdaptAlg;	// Next time we will run the adaptive algorith for this EPD
	UINT				uiAdaptAlgCount;	// Acknowledge count remaining before running adaptive algorithm
	DWORD				tLastPacket;		// Timestamp when last packet arrived
	
	UINT				uiWindowFilled;		// Count of times we fill the send window
	
	UINT				uiPeriodAcksBytes;	// frames acked since change in tuning
	UINT				uiPeriodXmitTime;	// time link has been transmitting since change in tuning
	UINT				uiPeriodRateB;
	UINT				uiPeakRateB;		// Largest sample we ever measure
	
	DWORD				tStartIdle;			// Timestamp when link went idle
	UINT				uiTotalIdleTime;	// Time link has spent idle this period (since last run of DynAlg)

	// While we are in DYNAMIC state we want to remember stats from our previous xmit parameters,  at this
	// point that means RTT and AvgSendRate.  This lets us compare the measurements at our new rate so we can
	// ensure that thruput increases with sendrate,  and that RTT is not growing out of proportion.
	//
	//   If either thru-put stops improving or RTT grows unreasonably then we can plateau our xmit parameters
	// and transition to STABLE state.

//	UINT				fpLastRTT;
	UINT				uiLastRateB;
	UINT				uiLastBytesAcked;
	DWORD				tLastThruPutSample;

	UINT				uiStaticPeriod;		// How long to remain static when link stabilizes.  This should grow as link remains stable.
	DWORD				dwSetPoint;			// Hash-value representing link values where it last stabilized (not currently used ao 9/19/00)
	
	// Connection State		-	 State of reliable connection
	//
	//	Send Queuing is getting somewhat complex.  Let me spell it out in Anglish.
	//
	//	blXPriSendQ		is the list of MSDs awaiting shipment (and being shipped)
	//	CurrentSend		pts to the MSD we are currently pulling frames out of.
	//  CurrentFrame 	pts to the next FMD that we will put on the wire.
	//	blSendWindow	is a bilinked list of transmitted but unacknowledged frames.  This list may span multi MSDs
	//
	//	WindowF			is our current MAX window size expressed in frames
	//	WindowB			is our current MAX window size expressed in bytes
	//
	//	UnAckedFrames	is the count of unacknowledged frames on the wire (actual window size)
	//	UnAckedBytes	is the count of unacknowledged bytes on the wire

	DWORD				uiQueuedMessageCount;	// How many MSDs are waiting on all three send queues

	CBilink				blHighPriSendQ;		// These are now mixed Reliable and Datagram traffic
	CBilink				blNormPriSendQ;
	CBilink				blLowPriSendQ;
	CBilink				blCompleteSendList;	// Reliable messages completed and awaiting indication to user

	DWORD				dwSessID;			// Session ID so we can detect re-started links
	PMSD				pCurrentSend;		// Head of queue is lead edge of window.  window can span multiple frames.
	PFMD				pCurrentFrame;		// frame currently transmitting. this will be trailing edge of window
	CBilink				blSendWindow;
	CBilink				blRetryQueue;		// Packets waiting for re-transmission

	//		Lost Packet Lists
	//
	//		When we need to retry a packet and we discover that it is not reliable,  then we need to inform partner
	//	that he can stop waiting for the data.  We will piggyback this info on another frame if possible

	//		Current Transmit Parameters:
	
	INT					iWindowF;			// window size (frames)
	INT					iWindowB;			// window size (bytes)
	UINT				uiWindowBIndex;		// index (scaler) for byte-based window
	INT					iUnackedFrames;		// outstanding frame count
	INT					iUnackedBytes;		// outstanding byte count

	UINT				uiBurstSize;		// number of packets to send in each transmit interval
	INT					iBurstSizeBytes;	// number of bytes to send each transmit interval
	UINT				uiBurstGap;			// number of ms to wait between bursts
	INT					iBurstCredit;		// Either credit or deficit from previous Transmit Burst
	DWORD				tNextSend;			// time when next burst may be sent

	// 		Last Known Good Transmit Parameters --  Values which we believe are safe...

	UINT				iGoodWindowF;
	UINT				uiGoodWindowBI;
	UINT				uiGoodBurstSize;
	UINT				uiGoodBurstGap;
	UINT				uiLastBadGap;
	
	UINT				iRestoreWindowF;
	UINT				uiRestoreWindowBI;
	UINT				uiRestoreBurstSize;
	UINT				uiRestoreBurstGap;
	DWORD				tLastDelta;			// Timestamp when we last modified xmit parms

	// 		Reliable Link State

	BYTE VOL			bNextSend;			// Next serial number to assign
	BYTE VOL			bNextReceive;		// Next frame serial we expect to receive

	//	The following fields are all for tracking reliable receives

	//  The next two fields allow us to return more state with every ACK packet.  Since each ack explicitly
	// names one frame,  the highest in-sequenced packet received so far,  we want to remember the arrival time
	// and the Retry count of this packet so we can report it in each ACK.  It will be the transmitter's
	// responsibility to ensure that a single data-point never gets processed more then once,  skewing our calcs.
	
	DWORD				tLastDataFrame;		// Timestamp from the arrival of N(R) - 1
	BYTE				bLastDataRetry;		// Retry count on frame N(R) - 1
#ifdef	DEBUG
	BYTE				bLastDataSeq;		// for DEBUG porpoises
#endif

	ULONG				ulReceiveMask;		// mask representing first 32 frames in our rcv window
	ULONG				ulReceiveMask2;		// second 32 frames in our window
	DWORD				tReceiveMaskDelta;	// timestamp when a new bit was last set in ReceiveMask (full 64-bit mask)

	ULONG				ulSendMask;			// mask representing unreliable send frames that have timed out and need
	ULONG				ulSendMask2;		// to be reported to receiver as missing.

	PRCD				pNewMessage;		// singly linked list of message elements
	PRCD				pNewTail;			// tail pointer for singly linked list of msg elements
	CBilink				blOddFrameList;		// Out Of Order frames
	CBilink				blCompleteList;		// List of MESSAGES ready to be indicated
	UINT				uiCompleteMsgCount;	// Count of messages on the CompleteList

	PVOID				SendTimer;			// Timer for next send-burst opportunity
	UINT				SendTimerUnique;

	UINT				uiRetryCount;		// This count is used during CONNECT processing
	UINT				uiRetryTimeout;		// Current T1 timer value
	
	PVOID				ConnectTimer;		// We used to share RetryTimer for connecting but we hit some race conditions when timers
	UINT				ConnectTimerUnique;	// would fire as connections completed.  This will close these windows at cost of 8 bytes/EPD
	
	PVOID				RetryTimer;			// window to receive Ack
	UINT				RetryTimerUnique;	
	
	PVOID				DelayedAckTimer;	// wait for piggyback opportunity before sending Ack
	UINT				DelayedAckTimerUnique;

	PVOID				DelayedMaskTimer;	// wait for piggyback opportunity before sending
	UINT				DelayedMaskTimerUnique;
	
	PVOID				BGTimer;			// Periodic background timer
	UINT				BGTimerUnique;		// serial for background timer


	//	Link statistics
	//
	//	All of the following stuff is calculated and stored here for the purpose of reporting in the ConnectionInfo structure
	
	UINT				uiBytesReceived;	// data xfered over this link
	UINT				uiFramesReceived;
	UINT				uiFramesSent;
	UINT				uiBytesSent;		// data xfered over this link
	UINT				uiFramesAcked;		// frames actually acknowledged by partner
	UINT				uiBytesAcked;
	
	UINT 				uiMsgSentHigh;
	UINT 				uiMsgSentNorm;
	UINT 				uiMsgSentLow;
	UINT 				uiMsgTOHigh;
	UINT 				uiMsgTONorm;
	UINT 				uiMsgTOLow;
	
	UINT 				uiMessagesReceived;

	UINT				uiGuaranteedFramesSent;
	UINT				uiGuaranteedBytesSent;
	UINT				uiDatagramFramesSent;
	UINT				uiDatagramBytesSent;

	UINT				uiGuaranteedFramesReceived;
	UINT				uiGuaranteedBytesReceived;
	UINT				uiDatagramFramesReceived;
	UINT				uiDatagramBytesReceived;

	UINT				uiDatagramFramesDropped;	// datagram frame we failed to  deliver
	UINT				uiDatagramBytesDropped;		// datagram bytes we didnt deliver
	UINT				uiGuaranteedFramesDropped;
	UINT				uiGuaranteedBytesDropped;

	UINT				fpDropsPer128Frames;		// 8.24 fixed point counter;

#ifdef DEBUG
	CHAR				LastPacket[32]; 			// record last packet received on EPD
#endif	
};

/*
**		Check Point Data
**
**		Keeps track of local-end info about a checkpoint in-progress.
*/

struct checkptdata {
	CBilink			blLinkage;				// Linkage for list of CPs on an EndPoint
	DWORD			tTimestamp;				// Local time at start of checkpoint
	UINT			uiFrameLength;			// Size of frame being checkpointed
	UCHAR			bMsgID;					// Msg ID expected in CP response
};

/*
**	Descriptor IDs
**
**		Any Descriptor that may be submitted to an SP as a context must have
**	a field which allows us to determine which structure is returned in a
**	completion call.  This field must obviously be in a uniform place in all
**	structures,  and could be expanded to be a command specifier as well.
**	Done!  Lets call it a command ID.
*/

typedef enum CommandID {
COMMAND_ID_NONE,
COMMAND_ID_SEND_RELIABLE,
COMMAND_ID_SEND_DATAGRAM,
COMMAND_ID_CONNECT,
COMMAND_ID_LISTEN,
COMMAND_ID_ENUM,
COMMAND_ID_ENUMRESP,
COMMAND_ID_DISCONNECT,
COMMAND_ID_DISC_RESPONSE,
COMMAND_ID_CFRAME,
COMMAND_ID_KEEPALIVE,
COMMAND_ID_COPIED_RETRY,
} COMMANDID;

/*
#define		COMMAND_ID_SEND_RELIABLE	1
#define		COMMAND_ID_SEND_DATAGRAM	2
#define		COMMAND_ID_CONNECT			3
#define		COMMAND_ID_LISTEN			4
#define		COMMAND_ID_ENUM				5
#define		COMMAND_ID_ENUMRESP			6
#define		COMMAND_ID_DISCONNECT		7
#define		COMMAND_ID_DISC_RESPONSE	8
#define		COMMAND_ID_CFRAME			9
#define		COMMAND_ID_KEEPALIVE		10
#define		COMMAND_ID_COPIED_RETRY		11
*/

/*	Message Descriptor
**
**		An 'MSD' describes a message being sent or received by the protocol.  It keeps track
**	of the message elements, tracking which have been sent/received/acknowledged.
*/

//	Flags ONE field is protected by the MSD->CommandLock

#define		MFLAGS_ONE_IN_USE				0x0001
#define		MFLAGS_ONE_IN_SERVICE_PROVIDER	0x0002	// This MSD is inside an SP call
#define		MFLAGS_ONE_CANCELLED			0x0004	// command was cancelled while owned by SP
#define		MFLAGS_ONE_TIMEDOUT				0x0008	// command timed out while event was scheduled
#define		MFLAGS_ONE_ON_GLOBAL_LIST		0x0010

// Flags TWO field is protected by the EPD->EPLock

#define		MFLAGS_TWO_TRANSMITTING			0x0001
#define		MFLAGS_TWO_COMPLETE				0x0002	// command completed while event was scheduled
#define		MFLAGS_TWO_ABORT				0x0004	// Command has been aborted. Do no further processing
#define		MFLAGS_TWO_END_OF_STREAM		0x0008	// This MSD is an EOS frame. Could be a user cmd or a response
#define		MFLAGS_TWO_KEEPALIVE			0x0010	// This MSD is an empty frame to exercise the reliable engine

#define		MFLAGS_TWO_ENQUEUED				0x1000	// This MSD is on one of the EPD SendQs

struct messagedesc {
	COMMANDID			CommandID;				// THIS MUST BE FIRST FIELD
	INT					uiRefCnt;				// Reference count
	ULONG VOL			ulMsgFlags1;			// State info serialized by MSD->CommandLock
	UINT				Sign;					// Signature
	ULONG VOL			ulMsgFlags2;			// State info serialized by EPD->EPLock
	DNCRITICAL_SECTION	CommandLock;
	PEPD				pEPD;					// Destination End Point
	PSPD				pSPD;					// SP fielding this command
	PVOID				Context;				// User provided context value
	ULONG VOL			ulSendFlags;			// Flags submitted by User in send call
	DWORD				tSubmitTime;			// Timestamp upon submission
	INT					iMsgLength;				// Total length of user data
	UINT				uiFrameCount;			// Number of frames needed to xmit data
	CBilink				blFrameList;			// List of frames to transport this message
	CBilink				blQLinkage;				// linkage for various sendQs
	CBilink				blSPLinkage;			// linkage for SP command list, protected by SP->SendQLock
	PMSD				Link;					// Utility link

	HANDLE				hCommand;				// handle when submitted to SP (used for connect & listen)
	DWORD				dwCommandDesc;			// Descriptor associated with hCommand
	HANDLE				hListenEndpoint;
	
	PVOID				TimeoutTimer;
	UINT				TimeoutTimerUnique;
};

/*
**		Frame Descriptor
**
**		There are two non-obvious things about the FMD structure.  First is that the built-in Buffer Descriptor array
**	has two elements defined in front of it.  The first element,  Reserved1 and Reserved2 are present to allow the Service
**	Provider to pre-pend a header buffer,  and the second element,  ImmediateLength and ImmediatePointer are for this
**	protocol to prepend its header.  The ImmediatePointer is initialized to point to the ImmediateData field.
**
**		The second thing is that the ulFFlags field is serialized with the ENDPOINTLOCK of the EPD which this frame is linked to.
**	This is good because every time the FFlags fields is modified we have already taken the EPLock already.  The exception to this
**	rule is when we are initializing the FMD.  In this case the FMD has not been loosed on the world yet so there cannot be any
**	contention for it.  We have seperated out the one flag,  FRAME_SUBMITTED, into its own BOOL variable because this one is
**	protected by the SP's SendQLock,  and like the EPLock above,  it is already claimed when this flag gets modified.
*/

#define		FFLAGS_IN_USE				0x0001
#define		FFLAGS_TRANSMITTED			0x0002
#define		FFLAGS_END_OF_MESSAGE		0x0004
#define		FFLAGS_END_OF_STREAM		0x0008

//#define		FFLAGS_FRAME_SUBMITTED		0x0010	// SP Currently owns this frame
#define		FFLAGS_RETRY_TIMER_SET		0x0020	// Just what it sounds like
#define		FFLAGS_NACK_RETRANSMIT_SENT	0x0040	// We sent a NACK initiated retry.
#define		FFLAGS_IN_SEND_WINDOW		0x0080	// This reliable frame has been transmitted and is waiting for Ack

#define		FFLAGS_CHECKPOINT			0x0100	// We are asking for a response
#define		FFLAGS_KEEPALIVE			0x0200
#define		FFLAGS_ACKED_BY_MASK		0x0400	// This has been acked out-of-order so its still in the SendWindow
#define		FFLAGS_RETRY_QUEUED			0x0800	// Frame currently sitting on the retry queue


#define		FFLAGS_NEW_MESSAGE			0x10000
#define		FFLAGS_RELIABLE				0x20000
#define		FFLAGS_SEQUENTIAL			0x40000

struct framedesc {
	UINT			CommandID;					// THIS MUST BE FIRST FIELD
	UINT			uiFrameLength;
	ULONG VOL		ulFFlags;
	BOOL VOL		bSubmitted;					// Pull out this one flag for protection
	UINT			Sign;
	UINT			uiRefCnt;					// Reference count
	PMSD			pMSD;						// owning message
	PEPD			pEPD;						// owning link;  ONLY VALID ON COMMAND FRAMES!
	BYTE			bPacketFlags;
	CBilink			blMSDLinkage;
	CBilink			blQLinkage;
	CBilink			blWindowLinkage;	
	
	UINT			uiRetry;					// number of times this frame has been transmitted
	DWORD			tTimestamp[MAX_RETRIES+1];	// timestamp of frame's transmission
	
	SPSENDDATA		SendDataBlock;				// Block to submit frame to SP
	CHAR			ImmediateData[DNP_MAX_HEADER_SIZE];

	// DO NOT MODIFY LAST FIVE FIELDS IN FRAME STRUCTURE

	UINT			uiReserved1;		// two resv fields are buf..
	LPVOID			lpReserved2;		// ..desc for SP to add header
	UINT			uiImmediateLength;			// These two lines constitute buffer descriptor
	LPVOID			lpImmediatePointer;			// for immediate data (our protocol headers)
	BUFFERDESC	 	rgBufferList[MAX_BUFFERS_IN_FRAME];	// KEEP THIS FIELD AT END SO WE CAN ADD BUFFERS DYNAMICALLY
};


/*
**		Receive Descriptor
**
**		This data structure tracks a  single buffer received from the network.
**	It may or may not constitute an entire message.
*/

typedef	enum {
	RBT_SERVICE_PROVIDER_BUFFER,
	RBT_PROTOCOL_BUFFER,
	RBT_DYNAMIC_BUFFER
}	BUFFER_TYPE;

#define		RFLAGS_FRAME_OUT_OF_ORDER		0x0001	// This buffer was received out-of-order
#define		RFLAGS_FRAME_INDICATED_NONSEQ	0x0002	// This buffer was indicated out of order, but is still in Out of Order list
#define		RFLAGS_ON_OUT_OF_ORDER_LIST		0x0004	//
#define		RFLAGS_IN_COMPLETE_PROCESS		0x0008
#define		RFLAGS_FRAME_LOST				0x0010	// This RCD represents and Unreliable frame that has been lost

struct recvdesc {
	DWORD				tTimestamp;					// timestamp upon packets arrival
	UINT				uiDataSize;					// data in this frame
	UINT				uiFrameCount;				// frames in message
	UINT				uiMsgSize;					// total byte count of message
	UINT				Sign;						// Signature to identify data structure
	UINT				uiRefCnt;
	BYTE				bSeq;						// Sequence number of this frame
	BYTE				bFrameFlags;				// Flag field from actual frame
	BYTE				bFrameControl;
	PBYTE				pbData;						// pointer to actual data
	UINT				ulRFlags;					// Receive flags
	CBilink				blOddFrameLinkage;			// BILINKage for queues
	CBilink				blCompleteLinkage;			// 2nd Bilink so RCD can remain in Out Of Order Queue after indication
	PRCD				pMsgLink;					// Single link for frame in message
	PSPRECEIVEDBUFFER	pRcvBuff;					// ptr to SP's receive data structure
};

typedef	struct buf		BUF, *PBUF;
typedef struct medbuf	MEDBUF, *PMEDBUF;
typedef	struct bigbuf	BIGBUF, *PBIGBUF;
typedef	struct dynbuf	DYNBUF, *PDYNBUF;

struct buf {
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[SMALL_BUFFER_SIZE];		// 2K small buffer for combining multi-frame sends
};

struct medbuf {
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[MEDIUM_BUFFER_SIZE];		// 4K mid size buffer
};

struct bigbuf {
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[LARGE_BUFFER_SIZE];		// ARBITRARY SIZE OF MAX SEND (16K)
};

struct dynbuf {
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\dnpextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnpextern.h
 *  Content:    This header exposes protocol entry points to the rest of Direct Network
 *@@BEGIN_MSINTERNAL
 *  History:
 *  Date		By      Reason
 *  ====		==      ======
 *  ??/??/??	ES		Created
 *	31/08/99	MJN		Changed first parameter to DNPProtocolInitialize to LPVOID
 *	03/22/00	mjn		Changed IDirectPlayAddress8 references to IDirectPlay8Address
 *  03/31/00    rmt     Added const to declarations of DNPSetProtocolCaps
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	_DNPEXTERN_INCLUDED_
#define	_DNPEXTERN_INCLUDED_

#include "dnprot.h"

#ifdef	__cplusplus
extern	"C"
{
#endif	// __cplusplus

//	FOLLOWING FLAGS GO INTO PUBLIC HEADER FILE

#define	DN_SENDFLAGS_RELIABLE			0x00000001			// Deliver Reliably
#define	DN_SENDFLAGS_NON_SEQUENTIAL		0x00000002			// Deliver Upon Arrival
#define	DN_SENDFLAGS_HIGH_PRIORITY		0x00000004
#define	DN_SENDFLAGS_LOW_PRIORITY		0x00000008
#define	DN_SENDFLAGS_SET_USER_FLAG		0x00000040			// Protocol will deliver these two...
#define	DN_SENDFLAGS_SET_USER_FLAG_TWO	0x00000080			// ...flags to receiver

//	END OF PUBLIC FLAGS


/*
**		User Callback
**
**		This defines an all-purpose callback routine which clients
**	must provide to DNet.  I assume this will be replaced by something
**	official at a later date,  but for the time being this will
**	do the trick for debugging
**
**	parms are:  Opcode, EndPt, Data, Length, Context, Result
*/

//typedef	HRESULT	(*UserCallback)(DWORD, HANDLE, PCHAR, DWORD, LPVOID, HRESULT);
typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;


//	USER CALLBACK OPCODES

#define	DN_USER_INDICATE_DATA					1
#define	DN_USER_INDICATE_SENDCOMPLETE			2
#define	DN_USER_INDICATE_CONNECTCOMPLETE		3
#define	DN_USER_INDICATE_NEW_CONNECTION			4
#define	DN_USER_INDICATE_CONNECTION_TERMINATED	5			// Connection has been aborted (abnormal discon)
#define	DN_USER_INDICATE_PARTNER_DISCONNECTING	6			// Orderly disconnect has been initiated
#define	DN_USER_INDICATE_DISCONNECT_COMPLETE	7			// Orderly disconnect has been completed
#define	DN_USER_INDICATE_ENUM_QUERY				8
#define	DN_USER_INDICATE_ENUM_QUERY_RESPONSE	9

//
// structure used to pass enum data from the protocol to DPlay
//
typedef	struct	_PROTOCOL_ENUM_DATA
{
	IDirectPlay8Address	*pSenderAddress;		//
	IDirectPlay8Address	*pDeviceAddress;		//
	BUFFERDESC			ReceivedData;			//
	HANDLE				hEnumQuery;				// handle of this query, returned in enum response

} PROTOCOL_ENUM_DATA;


typedef	struct	_PROTOCOL_ENUM_RESPONSE_DATA
{
	IDirectPlay8Address	*pSenderAddress;
	IDirectPlay8Address	*pDeviceAddress;
	BUFFERDESC			ReceivedData;
	DWORD				dwRoundTripTime;

} PROTOCOL_ENUM_RESPONSE_DATA;

// Pass per-endpoint data to DPlay

typedef struct _PROTOCOL_ENDPOINT_DATA
{
	UINT				uiMaxDatagramSize;				// Largest datagram allowed on this link
	UINT				uiMeasuredLatency;				// Approximate measured latency in milliseconds
	
} PROTOCOL_ENDPOINT_DATA, *PPROTOCOL_ENDPOINT_DATA;

// Protocol interface
typedef struct _DNPI_INT DNPI_INT, *PDNPI_INT;
// Protocol data
typedef	struct	protocoldata	ProtocolData, *PProtocolData;
// Protocol endpoint descriptor
typedef	struct	endpointdesc 	EPD, *PEPD;

// Service Provider interface
typedef struct IDP8ServiceProvider       IDP8ServiceProvider;
// Service Provider info data strucure
typedef	struct	_SPGETADDRESSINFODATA SPGETADDRESSINFODATA, *PSPGETADDRESSINFODATA;
// Service Provider event type
typedef enum _SP_EVENT_TYPE SP_EVENT_TYPE;

// Init/Term calls
#ifdef DPLAY_DOWORK
DWORD TimerWorkerThread(VOID);
void PeriodicTimer (void);
#endif

extern HRESULT DNPProtocolInitialize(PVOID, PProtocolData, PDN_PROTOCOL_INTERFACE_VTBL);
extern HRESULT DNPAddServiceProvider(PProtocolData, IDP8ServiceProvider*, HANDLE *);
extern HRESULT DNPRemoveServiceProvider(PProtocolData, HANDLE);
extern HRESULT DNPProtocolShutdown(PProtocolData);

// Data Transfer

extern HRESULT DNPConnect(PProtocolData, IDirectPlay8Address *const, IDirectPlay8Address *const, const HANDLE, const DWORD, const ULONG, PVOID, PHANDLE);
extern HRESULT DNPListen(PProtocolData, IDirectPlay8Address *const, const HANDLE, ULONG, PVOID, PHANDLE);
extern HRESULT DNPSendData(PProtocolData, HANDLE, UINT, PBUFFERDESC, UINT, UINT, ULONG, PVOID, PHANDLE);
extern HRESULT DNPDisconnectEndPoint(PProtocolData, HANDLE, PVOID, PHANDLE);
extern HRESULT DNPAbortEndPoint(PProtocolData, HANDLE);

// Misc Commands

extern HRESULT DNPCrackEndPointDescriptor(HANDLE, PSPGETADDRESSINFODATA);
extern HRESULT DNPCancelCommand(PProtocolData, HANDLE);
//extern HRESULT DNPSetEndPointContext(HANDLE, PVOID);

extern HRESULT DNPEnumQuery( PProtocolData pPData,
							 IDirectPlay8Address *const pHostAddress,
							 IDirectPlay8Address *const pDeviceAddress,
							 const HANDLE,
							 BUFFERDESC *const pBuffers,
							 const DWORD dwBufferCount,
							 const DWORD dwRetryCount,
							 const DWORD dwRetryInterval,
							 const DWORD dwTimeout,
							 const DWORD dwFlags,
							 void *const pUserContext,
							 HANDLE *const pCommandHandle );

extern HRESULT DNPEnumRespond( PProtocolData pPData,
						       const HANDLE hSPHandle,
							   const HANDLE hQueryHandle,				// handle of enum query being responded to
							   BUFFERDESC *const pResponseBuffers,	
							   const DWORD dwResponseBufferCount,
							   const DWORD dwFlags,
							   void *const pUserContext,
							   HANDLE *const pCommandHandle );

extern HRESULT DNPReleaseReceiveBuffer(HANDLE);

extern HRESULT DNPGetListenAddressInfo(HANDLE hCommand, PSPGETADDRESSINFODATA pSPData);
extern HRESULT DNPGetEPCaps(HANDLE, PDPN_CONNECTION_INFO);
extern HRESULT DNPSetProtocolCaps(PProtocolData pPData, const DPN_CAPS * const pData);
extern HRESULT DNPGetProtocolCaps(PProtocolData pPData, PDPN_CAPS pData);

extern HRESULT WINAPI DNP_Debug(ProtocolData *, UINT OpCode, HANDLE EndPoint, PVOID Data);

//	Lower Edge Entries

extern HRESULT WINAPI DNSP_IndicateEvent(IDP8SPCallback *, SP_EVENT_TYPE, PVOID);
extern HRESULT WINAPI DNSP_CommandComplete(IDP8SPCallback *, HANDLE, HRESULT, PVOID);

//	PLAY MODE
//
//	I am defining these here for the time being.  I figure these will be defined
//	elsewhere eventually

#define		DN_PLAYMODE_CLIENT				0
#define		DN_PLAYMODE_SERVER				1
#define		DN_PLAYMODE_PEER				2


//	NEW V-TABLE FOR CALLS INTO CORE LAYER

typedef HRESULT (*PFN_PINT_INDICATE_LISTEN_TERMINATED)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_INDICATE_ENUM_QUERY)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	const HANDLE hCommand,
	void *const pvEnumQueryData,
	const DWORD dwEnumQueryDataSize);
typedef HRESULT (*PFN_PINT_INDICATE_ENUM_RESPONSE)
	(void *const pvUserContext,
	const HANDLE hCommand,
	void *const pvCommandContext,
	void *const pvEnumResponseData,
	const DWORD dwEnumResponseDataSize);
typedef HRESULT (*PFN_PINT_INDICATE_CONNECT)
	(void *const pvUserContext,
	void *const pvListenContext,
	const HANDLE hEndPt,
	void **const ppvEndPtContext);
typedef HRESULT (*PFN_PINT_INDICATE_DISCONNECT)
	(void *const pvUserContext,
	void *const pvEndPtContext);
typedef HRESULT (*PFN_PINT_INDICATE_CONNECTION_TERMINATED)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_INDICATE_RECEIVE)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	void *const pvData,
	const DWORD dwDataSize,
	const HANDLE hBuffer,
	const DWORD dwFlags);
typedef HRESULT (*PFN_PINT_COMPLETE_LISTEN)
	(void *const pvUserContext,
	void **const ppvCommandContext,
	const HRESULT hr,
	const HANDLE hEndPt);
typedef HRESULT (*PFN_PINT_COMPLETE_LISTEN_TERMINATE)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_ENUM_QUERY)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_ENUM_RESPONSE)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_CONNECT)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr,
	const HANDLE hEndPt,
	void **const ppvEndPtContext);
typedef HRESULT (*PFN_PINT_COMPLETE_DISCONNECT)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_SEND)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_CONNECT)
	(void *const pvUserContext,
	 void *const pvCommandContext,
	 const HRESULT hr,
	 IDirectPlay8Address *const pHostAddress,
	 IDirectPlay8Address *const pDeviceAddress );
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_ENUM)
	(void *const pvUserContext,
	 void *const pvCommandContext,
	 const HRESULT hr,
	 IDirectPlay8Address *const pHostAddress,
	 IDirectPlay8Address *const pDeviceAddress );
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_LISTEN)
	(void *const pvUserContext,
	 void *const pvCommandContext,
	 const HRESULT hr,
	 IDirectPlay8Address *const pDeviceAddress );

struct _DN_PROTOCOL_INTERFACE_VTBL
{
	PFN_PINT_INDICATE_LISTEN_TERMINATED		IndicateListenTerminated;
	PFN_PINT_INDICATE_ENUM_QUERY			IndicateEnumQuery;
	PFN_PINT_INDICATE_ENUM_RESPONSE			IndicateEnumResponse;
	PFN_PINT_INDICATE_CONNECT				IndicateConnect;
	PFN_PINT_INDICATE_DISCONNECT			IndicateDisconnect;
	PFN_PINT_INDICATE_CONNECTION_TERMINATED	IndicateConnectionTerminated;
	PFN_PINT_INDICATE_RECEIVE				IndicateReceive;
	PFN_PINT_COMPLETE_LISTEN				CompleteListen;
	PFN_PINT_COMPLETE_LISTEN_TERMINATE		CompleteListenTerminate;
	PFN_PINT_COMPLETE_ENUM_QUERY			CompleteEnumQuery;
	PFN_PINT_COMPLETE_ENUM_RESPONSE			CompleteEnumResponse;
	PFN_PINT_COMPLETE_CONNECT				CompleteConnect;
	PFN_PINT_COMPLETE_DISCONNECT			CompleteDisconnect;
	PFN_PINT_COMPLETE_SEND					CompleteSend;
	PFN_PINT_ADDRESS_INFO_CONNECT			AddressInfoConnect;
	PFN_PINT_ADDRESS_INFO_ENUM				AddressInfoEnum;
	PFN_PINT_ADDRESS_INFO_LISTEN			AddressInfoListen;
};

#ifdef	__cplusplus
}
#endif	// __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\endpt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		EndPt.c
 *  Content:	This file contains EndPoint management routines.
 *				An End Point is a DirectNet instance that we know about and may communicate
 *				with.  An End Point Descriptor (EPD) tracks each known End Point and was mapped
 *				onto an hEndPoint by a hash table. Now, the SP maintains the mapping and hands
 *				us our EPD address as a context with each indication ReceiveEvent.
 *
 *				In addition to EndPoint creation and destruction,  this file contains routines
 *				which handle link tuning.  This is described in detailed comments below.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *	07/14/99	ejs		Removed all of our hashing support (most of this file)
 *
 ****************************************************************************/

#include "dnproti.h"

VOID	BackOff(PEPD);
VOID	IncreaseTransmitRate(PEPD, DWORD);
VOID	RunAdaptiveAlg(PEPD, DWORD);
VOID	ThrottleBack(PEPD, DWORD);

#define 	USE_BURST_GAP		TRUE

/*
**		Crack EndPoint Descriptor
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPCrackEndPointDescriptor"

HRESULT DNPCrackEndPointDescriptor(HANDLE hEndPoint, PSPGETADDRESSINFODATA pSPData)
{
	PEPD	pEPD = (PEPD) hEndPoint;
	HRESULT	hr = DPNERR_INVALIDENDPOINT;

	LOGPF(2, "Parameters: hEndPoint[%x], pSPData[%p]", hEndPoint, pSPData);
	
	ASSERT_EPD(pEPD);

	if(LOCK_EPD(pEPD, "LOCK (Crack EPD)"))
	{
		if(pEPD->ulEPFlags & EPFLAGS_CONNECTED)
		{
			pSPData->hEndpoint = pEPD->hEndPt;
			LOGPF(3, "(%p) Calling SP->GetAddressInfo", pEPD);
			hr = IDP8ServiceProvider_GetAddressInfo(pEPD->pSPD->IISPIntf, pSPData);
		}
		
		RELEASE_EPD(pEPD, "UNLOCK (Crack EPD)"); // SendQLock not already held
	}
	return hr;
}

/*
**		INTERNAL - EndPoint management functions
*/

/*
**		New End Point
**
**		Everytime a packet is indicated with an address that we dont recognize we will allocate
**	an EPD for it and add it to our tables.  It is a higher layer's responsibility to tell
**	us when it no longer wants to talk to the EP so that we can clear it out of our
**	(and the SP's) table.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "NewEndPoint"

PEPD NewEndPoint(PSPD pSPD, HANDLE hEP)
{
	PEPD	pEPD;

	if((pEPD = static_cast<PEPD> (EPDPool->Get(EPDPool))) == NULL)
	{	
		LOGPF(0, "Failed to allocate new EPD");
		return NULL;
	}

	ASSERT(hEP != INVALID_HANDLE_VALUE);

	pEPD->hEndPt = hEP;								// Record ID in structure
	pEPD->pSPD = pSPD;

	pEPD->bNextMsgID = 0;
//	pEPD->bNextRcvID = 0;
	
	pEPD->uiRTT = 0;
	pEPD->uiBytesReceived = 0;
	pEPD->uiBytesSent = 0;
	pEPD->uiFramesSent = 0;
	pEPD->uiFramesReceived = 0;
	pEPD->uiFramesAcked = 0;
	pEPD->uiBytesAcked = 0;

	pEPD->uiQueuedMessageCount = 0;
#ifdef	DEBUG
	pEPD->bLastDataSeq = 0xFF;
#endif

	// We track a byte-window and a frame-window separately.  Start with 2 discreet frames,  but only 1 FULL frame.
													
	pEPD->iWindowF = 2;								// start with 1 full-frame window (this could still be many frames)
	pEPD->uiWindowBIndex = 1;
	pEPD->iWindowB = pSPD->uiFrameLength;			// ditto for bytes
	pEPD->iUnackedFrames = 0;						// outstanding frame count
	pEPD->iUnackedBytes = 0;						// outstanding byte count
	pEPD->uiBurstSize = 1;							// start at 1 frame/interval (we never increase this any more ao 9/19/00)
	pEPD->iBurstSizeBytes = (INT) pSPD->uiFrameLength;
	pEPD->uiBurstGap = 100;							// starting point 100ms/burst
	pEPD->tNextSend = 0;							// next send is anytime!
	pEPD->dwSessID = 0;

	// ReceiveComplete flag prevents received data from being indicated to core until after new connection is indicated
	pEPD->ulEPFlags = EPFLAGS_END_POINT_IN_USE | EPFLAGS_END_POINT_DORMANT | EPFLAGS_IN_RECEIVE_COMPLETE;

	ASSERT(pEPD->uiRefCnt == 0);					// WE NOW HAVE A -1 BASED REFCNT INSTEAD OF ZERO BASED (FOR EPDs)

	pEPD->SendTimer = 0;							// Timer for next send-burst opportunity
	pEPD->RetryTimer = 0;							// window to receive Ack
	pEPD->ConnectTimer = 0;
	pEPD->DelayedAckTimer = 0;						// wait for piggyback opportunity before sending Ack
	pEPD->DelayedMaskTimer = 0;						// wait for piggyback opportunity before sending Mask frame
	pEPD->BGTimer = 0;								// Periodic background timer
	pEPD->uiCompleteMsgCount = 0;

	pEPD->fpDropsPer128Frames = 0x04000000;			// start looking like we have a 4% drop rate to make more sensitive.
	
	Lock(&pEPD->pSPD->SendQLock);
	pEPD->blActiveLinkage.InsertAfter( &pEPD->pSPD->blEPDActiveList); // Place this guy in active list
	Unlock(&pEPD->pSPD->SendQLock);

	
	return pEPD;
}

/*
**		Initial Link Parameters
**
**		we have kept a checkpoint structure matching everying frame we sent in the Connect
**	handshake so that we can match a response to a specific frame or retry.  This allows us
**	to measure a single sample Round Trip Time (RTT),  which we will use below to generate
**	initial values for our link-state variables.
**
**	BurstSize will always init to 1.  BurstGap will init to (RTT/2). When BurstGap reaches
**	a minimum of 5 or 10 ms,  we will start increasing the BurstSize.  However,  here for
**	initial values we will max out a one frame/10ms.  This should quickly increase for
**	speedsters.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "InitLinkParameters"

VOID InitLinkParameters(PEPD pEPD, UINT uiRTT, UINT normal_load, UINT bias)
{
	DWORD	tNow = GETTIMESTAMP();
	DWORD	dwTimerInterval;

	if(uiRTT == 0)
	{
		uiRTT = 1;
	}
		
	pEPD->uiRTT = uiRTT;										// we know the base RTT
	pEPD->fpRTT = TO_FP(uiRTT);									// 16.16 fixed point version
//	pEPD->fpFastRTT = TO_FP(uiRTT);								// 16.16 fast-moving avg
//	pEPD->fpDev = 0;											// 16.16 avg deviation
//	pEPD->uiRTTgrowing = 0;										// numbers of consecutive samples with avg RTT growing
//	pEPD->uiRecoveryBGap = 0;
//	pEPD->uiRecoveryBSize = 0;
	pEPD->uiDropCount = 0;
//	pEPD->tDropInterval = 0;
//	pEPD->uiDropEvents = 0;
	pEPD->uiThrottleEvents = 0;									// Count times we throttle-back for all reasons
#ifdef	DEBUG
	pEPD->uiTotalThrottleEvents = 0;
#endif
	
//	pEPD->uiBurstGap = MAX((uiRTT+1)/2, 5);						// Initially send frames twice per RTT
																// but no more then 1 every 5 seconds

	pEPD->uiBurstGap = 0;	// For now assume we dont need a burst gap
	pEPD->uiBurstSize = 1;
	pEPD->iBurstSizeBytes = (INT) pEPD->pSPD->uiFrameLength;
#ifdef POLL_COUNT	
	pEPD->uiPollFrequency = 1;									// POLL early,  POLL often for new links
	pEPD->uiPollCount = 1;										// We will POLL on our first sequential frame
#endif

	pEPD->uiMsgSentHigh = 0;
	pEPD->uiMsgSentNorm = 0;
	pEPD->uiMsgSentLow = 0;
	pEPD->uiMsgTOHigh = 0;
	pEPD->uiMsgTONorm = 0;
	pEPD->uiMsgTOLow = 0;
	
	pEPD->uiMessagesReceived = 0;

	pEPD->uiGuaranteedFramesSent = 0;
	pEPD->uiGuaranteedBytesSent = 0;
	pEPD->uiDatagramFramesSent = 0;
	pEPD->uiDatagramBytesSent = 0;
	
	pEPD->uiGuaranteedFramesReceived = 0;
	pEPD->uiGuaranteedBytesReceived = 0;
	pEPD->uiDatagramFramesReceived = 0;
	pEPD->uiDatagramBytesReceived = 0;
	
	pEPD->uiGuaranteedFramesDropped = 0;
	pEPD->uiGuaranteedBytesDropped = 0;
	pEPD->uiDatagramFramesDropped = 0;
	pEPD->uiDatagramBytesDropped = 0;

	pEPD->uiGoodBurstSize = 1;
	pEPD->uiGoodBurstGap = 0;									// No Known Good Gap!
	pEPD->iGoodWindowF = 1;
	pEPD->uiGoodWindowBI = 1;
	pEPD->iBurstCredit = 0;
	pEPD->uiLastBadGap = 0;
	pEPD->tLastDelta = tNow;//
	pEPD->uiWindowFilled = 0;
	
	pEPD->tStartIdle = tNow;									// Timestamp when link went idle
	pEPD->uiTotalIdleTime = 0;									// Time link has spent idle this period (since last run of DynAlg)
	pEPD->tLastThruPutSample = tNow;

	pEPD->uiLastBytesAcked = 0;
	pEPD->uiPeriodAcksBytes = 0;
	pEPD->uiPeriodXmitTime = 0;
	pEPD->uiPeriodRateB = 0;
	pEPD->uiPeakRateB = 0;
	
	pEPD->uiLastRateB = 0;
//	pEPD->fpLastRTT = -1;
	
	pEPD->ulReceiveMask = 0;
	pEPD->ulReceiveMask2 = 0;
	pEPD->tReceiveMaskDelta = 0;
	
	pEPD->ulSendMask = 0;
	pEPD->ulSendMask2 = 0;
	
	pEPD->Context = NULL;
	pEPD->dwSetPoint = 0;
	
//	pEPD->bLastAckID = pEPD->bNextMsgID;
	
//	pEPD->uiNormalSize = (UINT) normal_load * 1.25;  			// this wont compile
//	pEPD->uiNormalSize = normal_load + (normal_load >> 2);		// Normal Size = normal_load * 1.25
//	pEPD->uiNormalBias = bias;
	
//	pEPD->iPeriodBiasDelta = 0;
//
//	pEPD->uiLoadedBias = 0;
//	pEPD->uiLoadedSize = 0;
//	pEPD->tLoadedSample = 0;
	
//	pEPD->uiMidLoadBias = 0;
//	pEPD->tMidLoadSample = 0;

	LOGPF(7, "CONNECTION ESTABLISHED pEPD = 0x%p RTT = %dms, BurstGap=%dms", pEPD, pEPD->uiRTT, pEPD->uiBurstGap);

	// We set the IdleThreshhold very low to generate a little bit of traffic for initial link tuning in case the
	// application doesnt do any right away

	pEPD->ulEPFlags |= EPFLAGS_USE_POLL_DELAY;					// always assume balanced traffic at start-up
	
	pEPD->uiAdaptAlgCount = 4;									// start running adpt alg fairly often
//	pEPD->State = (uiRTT < 25) ? EP_STATE_LAN_DYNAMIC : EP_STATE_WAN_DYNAMIC; // Start in DYNAMIC state
	
	//pEPD->tIdleThreshhold = pEPD->pSPD->pPData->tIdleThreshhold;// THIS IS CONTROLLED BY GLOBAL VAR FOR EVERYONE
	
	pEPD->uiRetryTimeout = (pEPD->uiRTT + (pEPD->uiRTT >> 2) + DELAYED_ACK_TIMEOUT) * 2;
	// don't want to get more aggressive because we drop a frame.
	if(pEPD->uiRetryTimeout < pEPD->uiBurstGap)
	{
		pEPD->uiRetryTimeout = pEPD->uiBurstGap;	
	}
	

	pEPD->uiUserFrameLength = pEPD->pSPD->uiUserFrameLength;
	
	if(pEPD->BGTimer == 0)
	{
		if (pEPD->pSPD->pPData->tIdleThreshhold > ENDPOINT_BACKGROUND_INTERVAL)
			dwTimerInterval = ENDPOINT_BACKGROUND_INTERVAL;
		else
			dwTimerInterval = pEPD->pSPD->pPData->tIdleThreshhold;

		LOGPF(7, "(%p) Setting Endpoint Background Timer for %u ms", pEPD, dwTimerInterval);
		SetMyTimer(dwTimerInterval, 1000, EndPointBackgroundProcess, (PVOID) pEPD, &pEPD->BGTimer, &pEPD->BGTimerUnique);
		LOCK_EPD(pEPD, "LOCK (BG Timer)");												// create reference for this timer
	}
}

/*
**		Kill Connection
**
**		This routine shall release the 'base' reference on an endpoint,  taking pains to ensure
**	that this reference only gets released once.  We will also attempt to cancel the Background Timer
**	for the endpoint too.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "KillConnection"

VOID
KillConnection(PEPD pEPD)
{
	
	Lock(&pEPD->EPLock);
	
	LOGPF(7, "Kill Connection %p (refcnt=%d)", pEPD, pEPD->uiRefCnt);

	ASSERT((pEPD->pCommand == NULL)||(pEPD->ulEPFlags & EPFLAGS_ABORT));
	
	pEPD->ulEPFlags &= ~(EPFLAGS_CONNECTED);
	
	if(!(pEPD->ulEPFlags & EPFLAGS_KILLED))
	{
		pEPD->ulEPFlags |= EPFLAGS_KILLED;
		if(pEPD->BGTimer != 0)
		{
			LOGPF(7, "(%p) Cancelling Endpoint Background Timer", pEPD);
			if(CancelMyTimer(pEPD->BGTimer, pEPD->BGTimerUnique)== DPN_OK)
			{
				RELEASE_EPD(pEPD, "UNLOCK (KILL BG TIMER)"); // SendQLock not already held
				pEPD->BGTimer = 0;
			}
			else
			{
				LOGPF(7, "(%p) Cancelling Endpoint Background Timer Failed", pEPD);
			}
		}
		
		Unlock(&pEPD->EPLock);

		RELEASE_EPD(pEPD, "UNLOCK (KILLCONN)");					// RELEASE the EPD, SendQLock not already held
	}
	else{
		Unlock(&pEPD->EPLock);
	}

}

/*
**		Disconnect Connection
**
**		Pull the actual plug in the service provider.  After this call we may no longer send or receive
**	on this endpoint.  Typically we will want to do this when our refcnt reaches zero,  but there are
**	cases where we want to abort things abnormally (partner has re-initialized the link) and do this
**	right away.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DisconnectConnection"

VOID
DisconnectConnection(PEPD pEPD)
{
	SPDISCONNECTDATA	Block;
	HRESULT				hr;

	Lock(&pEPD->EPLock);
	
	if(pEPD->hEndPt != INVALID_HANDLE_VALUE)
	{
		Block.hEndpoint = pEPD->hEndPt;
		Block.dwFlags = 0;
		Block.pvContext = NULL;

		pEPD->hEndPt = INVALID_HANDLE_VALUE;
		
		Unlock(&pEPD->EPLock);

		LOGPF(3, "(%p) Calling SP->Disconnect", pEPD);
		hr = IDP8ServiceProvider_Disconnect(pEPD->pSPD->IISPIntf, &Block);
	}
	else 
	{
		Unlock(&pEPD->EPLock);
	}
}

/****************
*
*			Link Tuning
*
*		Here are current ideas about link tuning.  Idea is to track Round Trip Time of key-frames and throttle
*	based upon changes in this measured RTT when possible.  This would benefit us in determining link saturation
*	before packet loss occurs, instead of waiting for the inevitable packet loss before throttling back.
*
*		On high-speed media,  the average RTT is small compared to the standard deviations making it hard to
*	predict anything useful from them.  In these cases,  we must look at packet drops.  Except for one exception:
*	We will look for large spikes in RTT and we will respond to these with an immediate, temporary throttle back.
*	This will allow a bottle-neck to clear hopefully without packet-loss.  So far,  I have not been able to verfify
*	any benefit from this behavior on reliable links.  It is more likely to be beneficial with datagram traffic
*	where send windows do not limit write-ahead.
*
*		I would like to take a measurement of the through-put acheived compared to the transmission rate,  but I
*	havent yet come up with a good way to measure this.  What I do calculate is packet acknowledgement rate,  which
*	can be calculated without any additional input from the remote side.  We will store AckRates acheived at the
*	previous transmission rate,  so we can look for improvements in Acks as we increase Transmissions.  When we
*	no longer detect AckRate improvements then we assume we have plateaued and we stop trying to increase the rate.
*
*	TRANSMISSION RATE
*
*		Transmission rate is controlled by two distinct parameters: Insertion Rate and Window Size.  Where a
*	conventional protocol would dump a window full of packets onto the wire in one burst,  we would like to
*	spread the packet insertions out over the full RTT so that the window never completely fills and hence
*	blocks the link from transmitting.  This has a wide array of potential benefits:  Causes less congestions
*	throughout the network path; Allows more balenced access to the wire to all Endpoints (especially on
*	slower media); Allows MUCH more accurate measurements to be made of trasmission times when packets
*	spend less time enqueued locally;  Allows retry timers to be set much lower giving us quicker error
*	recovery (because there is less queue time fudged into the timer);  Allows recovery to be made more
*	quickly when we dont have a lot of data enqueued in SP (both our own data and other Endpoint's data).
*	...And I am sure there are more.
*
*		So,  we would like to trickle out packets just fast enough to fill the window as the next ACK is received.
*	We will grow the window fairly liberally and let the burst rate increase more cautiously.
*	
*		On high-speed media the insertion time becomes fairly small (near zero) and we are less likely to queue
*	up large quantities of data.  Therefore we may allow insertion rate to go max and use the window alone to
*	control flow. I will experiment with this more.
*
******************/

#define		RTT_SLOW_WEIGHT					8					// fpRTT gain = 1/8
#define		RTT_FAST_WEIGHT					4					// fpFastRTT gain = 1/4
#define		THROTTLE_EVENT_THRESHOLD		20

/*
**		NEW REDUCED-FAT UPDATE ENDPOINT
**
**		This is the first draft of the simplified UpdateEndpoint suite.  Here we stop trying to divine mysterious
**	truths through chicken entrails and latency fluctuations,  etc.  We will let the sliding window control the flow
**	and increase the window as long as through-put continues to increase and frames continue to get delivered without
**	excessive droppage.
**	
**		We still calculate RTT for the purpose of determining RetryTimer values.  For cases with large RTTs we may still
**	implement an inter-packet gap,  but we will try to make it an aggressive gap (conservatively small) because we would
**	rather feed the pipe too quickly then artificially add latency by letting the pipe go idle with data ready to be sent.
**
**		** CALLED WITH EPD STATELOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateEndPoint"

VOID UpdateEndPoint(PEPD pEPD, UINT uiRTT, UINT payload, UINT bias, DWORD tNow)
{
	UINT	fpRTT;
	INT		fpDiff;
	
	// Don't allow zero RTTs
	if(uiRTT == 0)
	{												
		uiRTT = 1;
	}
	
	// Filter out HUGE samples,  they often popup during debug sessions
	else if(uiRTT > (pEPD->uiRTT * 128))
	{
		LOGPF(7, "Tossing huge sample (%dms)", uiRTT);
		return;
	}

	// Perform next iteration of math on new RTT sample in 16.16 fixed point

	fpRTT = TO_FP(uiRTT);										// Fixed point sample
	fpDiff = fpRTT - pEPD->fpRTT;								// Current Delta (signed)

	pEPD->fpRTT = pEPD->fpRTT + (fpDiff / RTT_SLOW_WEIGHT);		// .0625 weighted avg
	pEPD->uiRTT = FP_INT(pEPD->fpRTT);							// Store integer portion

//	fpDiff = fpRTT - pEPD->fpRTTFast;
//	pEPD->fpRTTFast += (fpDiff / RTT_FAST_WEIGHT);				// .250 weighted avg
	
	// Calc a retry timeout value based upon the measured RTT (2.5 * RTT) + MAX_DELAY
	
	pEPD->uiRetryTimeout = ((pEPD->uiRTT * 4) + DELAYED_ACK_TIMEOUT);
	pEPD->uiRetryTimeout += (pEPD->uiRetryTimeout >> 2);	// 1.25 X
	// don't want to get more aggressive because we drop a frame.
	if(pEPD->uiRetryTimeout < pEPD->uiBurstGap)
	{
		pEPD->uiRetryTimeout = pEPD->uiBurstGap;	
	}
	
	LOGPF(7, "(%p) RTT SAMPLE: Size = %d; RTT = %d, Avg = %d <<<<", pEPD, payload, uiRTT, FP_INT(pEPD->fpRTT));

	// If throttle is engaged we will see if we can release it yet
	
	if(pEPD->ulEPFlags & EPFLAGS_THROTTLED_BACK)
	{
		if((tNow - pEPD->tThrottleTime) > (pEPD->uiRTT * 8)) 
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_THROTTLED_BACK);
			pEPD->uiDropCount = 0;
			pEPD->uiBurstGap = pEPD->uiRestoreBurstGap;
			pEPD->uiBurstSize = pEPD->uiRestoreBurstSize;
			pEPD->iBurstSizeBytes = (INT) pEPD->uiBurstSize * pEPD->pSPD->uiFrameLength;
			pEPD->iWindowF =  pEPD->iRestoreWindowF;
			pEPD->uiWindowBIndex = pEPD->uiRestoreWindowBI;
			pEPD->iWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;

			LOGPF(7, "** (%p) RECOVER FROM THROTTLE EVENT: Window(F:%d,B:%d); Gap=%d; Size=%d", pEPD, pEPD->iWindowF, pEPD->uiWindowBIndex, pEPD->uiBurstGap, pEPD->uiBurstSize);
			pEPD->tLastDelta = tNow;							// Enforce waiting period after back-off before tuning up again
		}
	}
	// Throttle Event tracks how often a packet-drop has caused us to throttle back transmission rate.  We will let this value
	// decay over time.  If throttle events happen faster then the decay occurs then this value will grow un-bounded.  This
	// growth is what causes a decrease in the actual send window/transmit rate that will persist beyond the throttle event.
	
	else if(pEPD->uiThrottleEvents)
	{
		pEPD->uiThrottleEvents--;								// Let this decay...
	}

	if(--pEPD->uiAdaptAlgCount == 0)
	{
		RunAdaptiveAlg(pEPD, tNow);
	}
}

/*
**		Grow Send Window
**
**		The two parallel send windows,  frame-based and byte-based,  can grow and shrink independently.  In this
**	routine we will grow one or both windows.  We will grow each window providing that it has been filled in the
**	last period, during which we have determined that thru-put has increased.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "GrowSendWindow"

VOID
GrowSendWindow(PEPD pEPD, DWORD tNow)
{
	UINT	delta = 0;

#ifdef USE_BURST_GAP
	if(pEPD->uiBurstGap)
	{
		// first store current good values for a restore
		pEPD->uiGoodBurstGap=pEPD->uiBurstGap;
		pEPD->uiGoodBurstSize=pEPD->uiBurstSize;
		
		// cut the burst gap by 25% if less than 3 ms go to 0.
		if(pEPD->uiBurstGap > 3)
		{
			pEPD->uiBurstGap -= pEPD->uiBurstGap >> 2;
		} 
		else 
		{
			pEPD->uiBurstGap = 0;
		}
		LOGPF(7, "(%p), burst gap set to %d ms", pEPD, pEPD->uiBurstGap);
		pEPD->tLastDelta = tNow;
	} 
	else 
	{
		pEPD->uiGoodBurstGap=pEPD->uiBurstGap;
		pEPD->uiGoodBurstSize=pEPD->uiBurstSize;
#endif
	
		pEPD->ulEPFlags &= ~(EPFLAGS_SECOND_SAMPLE);
		pEPD->tLastDelta = tNow;
		
		pEPD->iGoodWindowF = pEPD->iWindowF;
		pEPD->uiGoodWindowBI = pEPD->uiWindowBIndex;

		if((pEPD->ulEPFlags & EPFLAGS_FILLED_WINDOW_FRAME) && (pEPD->iWindowF < MAX_RECEIVE_RANGE))
		{
			pEPD->iWindowF++;
			delta = 1;
		}
		if((pEPD->ulEPFlags & EPFLAGS_FILLED_WINDOW_BYTE) && (pEPD->uiWindowBIndex < MAX_RECEIVE_RANGE))
		{
			pEPD->uiWindowBIndex++;
			pEPD->iWindowB += pEPD->pSPD->uiFrameLength;
			delta = 1;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE);
		pEPD->uiWindowFilled = 0;

		if(delta)
		{
			pEPD->uiLastRateB = pEPD->uiPeriodRateB;
			pEPD->uiPeriodRateB = 0;
			pEPD->uiPeriodAcksBytes = 0;
			pEPD->uiPeriodXmitTime = 0;
			LOGPF(7, "(%p) ** GROW SEND WINDOW to %d frames and %d (%d) bytes", pEPD, pEPD->iWindowF, pEPD->iWindowB, pEPD->uiWindowBIndex);
		}
		else 
		{
			LOGPF(7, "(%p) GROW SEND WINDOW -- Nothing to grow. Transition to Stable!", pEPD);
			pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;
		}

#ifdef POLL_COUNT	
		pEPD->uiPollFrequency = pEPD->iWindowF * 2;
#endif

#ifdef USE_BURST_GAP
	}
#endif	
}


#undef DPF_MODNAME
#define DPF_MODNAME "RunAdaptiveAlg"

VOID
RunAdaptiveAlg(PEPD pEPD, DWORD tNow)
{
	LONG	tDelta;											// Time the link was transmitting since last run of AdaptAlg
	UINT	fpRealRate;
	DWORD	dwSetPoint;
	UINT	uiBytesAcked;
	UINT	uiNewSum;
	UINT	uiThreshhold;
#ifdef	DEBUG
//	UINT	fpAcks;
//	INT		fpAckRate;
#endif

	// Calculate the time during which this link was actually transmitting to make sure we have enough
	// data to run the Adaptive Alg.  This is easy unless we are currently idle...

	tDelta = tNow - pEPD->tLastThruPutSample;

	if((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_IN_PIPELINE))==0)
	{
		ASSERT(pEPD->tStartIdle != -1);
		pEPD->uiTotalIdleTime += (tNow - pEPD->tStartIdle);
		pEPD->tStartIdle = tNow;
	}
	
	LOGPF(7, "Adaptive Alg tDelta = %d; Idle Time = %d (diff = %d)", tDelta, pEPD->uiTotalIdleTime, tDelta - pEPD->uiTotalIdleTime);

	tDelta -= pEPD->uiTotalIdleTime;

	// THIS PROBABLY IS UNNECESSARY NOW...
	if(tDelta <= 0)
	{
		LOGPF(7, "DELAYING Adaptive Alg");
		pEPD->uiAdaptAlgCount = 4;
		return;
	}

	//  Calculate current throughput acheived
	//
	//		We will determine the amount of time the link was not idle and then number of bytes (& frames) which
	//	was acknowleged by our partner.
	//
	//	tDelta = Time since last calculation minus the time the link was idle.
	
	uiBytesAcked = pEPD->uiBytesAcked - pEPD->uiLastBytesAcked;
	uiNewSum = pEPD->uiPeriodAcksBytes + (uiBytesAcked * 256);

	if(uiNewSum < pEPD->uiPeriodAcksBytes)
	{
		LOGPF(7, "THRUPUT is about to wrap. Correcting...");
		pEPD->uiPeriodAcksBytes /= 2;
		pEPD->uiPeriodXmitTime /= 2;
		pEPD->uiPeriodAcksBytes += (uiBytesAcked * 256);
	}
	else 
	{
		pEPD->uiPeriodAcksBytes = uiNewSum;
	}
	
	pEPD->uiPeriodXmitTime += tDelta;								// Track complete values for this period
	pEPD->uiTotalIdleTime = 0;
	pEPD->tLastThruPutSample = tNow;
	
	pEPD->uiLastBytesAcked = pEPD->uiBytesAcked;
	pEPD->uiPeriodRateB = pEPD->uiPeriodAcksBytes / pEPD->uiPeriodXmitTime;

	if(pEPD->uiPeriodRateB > pEPD->uiPeakRateB)
	{
		pEPD->uiPeakRateB = pEPD->uiPeriodRateB;					// Track the largest value we ever measure
	}
	
	LOGPF(7, "(%p) PERIOD COUNT BYTES = %d, XmitTime = %d  (%x)", pEPD, pEPD->uiPeriodAcksBytes, pEPD->uiPeriodXmitTime, pEPD->uiPeriodRateB);

	if(pEPD->ulEPFlags & EPFLAGS_LINK_STABLE)
	{
		/*		We are in a STABLE state,  meaning we think we are transmitting at an optimal
		**	rate for the current network conditions.  Conditions may change.  If things slow down
		**	or grow congested a Backoff will trigger normally.  Since conditions might also change
		**	for the better,  we will still want to periodically probe higher rates,  but much less
		**	often then when we are in DYNAMIC mode,  which means we are searching for an optimal rate.
		*/
		
		pEPD->uiAdaptAlgCount = 32;										// tNow + (pEPD->uiRTT * 32) + 32;
#ifdef POLL_COUNT	
		pEPD->uiPollFrequency = pEPD->iWindowF * 4;
#endif

		if((pEPD->ulEPFlags & EPFLAGS_LINK_FROZEN) == 0)
		{
			// BUGBUG we want this factor to grow as we continue to
			if((tNow - pEPD->tLastDelta) > pEPD->uiStaticPeriod)
			{
				if(pEPD->ulEPFlags & (EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE))
				{
					LOGPF(7, "(%p) RETURNING LINK TO DYNAMIC MODE", pEPD);
					
					pEPD->ulEPFlags &= ~(EPFLAGS_LINK_STABLE);

					pEPD->uiLastRateB = 0;
					pEPD->uiPeriodRateB = 0;
					pEPD->uiPeriodAcksBytes = 0;
					pEPD->uiPeriodXmitTime = 0;

					pEPD->uiWindowFilled = 0;
					pEPD->ulEPFlags &= ~(EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE);
					pEPD->uiAdaptAlgCount = 12;
				}
				else 
				{
					// SHRINK WINDOW HERE!!!! BUGBUG

					LOGPF(7, "(%p) NO WINDOWS FILLED,  Not returning to Dynamic Mode", pEPD);
					pEPD->uiStaticPeriod = MIN(pEPD->uiStaticPeriod * 2, INITIAL_STATIC_PERIOD * 8);
				}
			
			}
		}
	}

	// DYNAMIC STATE LINK
	else 
	{  
		pEPD->uiAdaptAlgCount = 8;

		// Possibly increase transmission rates.  We will not do this if we have had a ThrottleEvent
		// in recent memory,  or if we have not been actually transmitting for enough of the interval
		// to have collected worthwhile data
		//
		//		Also,  we dont want to even consider growing the send window unless we are consistantly
		// filling it.  Since one job of the window is to prevent us from flooding the net during a backup,
		// we dont want to grow the window following each backup.  The best way to distinguish between a 
		// backup and too small of a window is that the small window should fill up regularly while the
		// backups should only occur intermittantly.  The hard part is coming up with the actual test.
		// Truth is,  we can be fairly lax about allowing growth because it will also have to meet the increased
		// bandwidth test before the larger window is accepted.  So a crude rule would be to fix a number like 3.
		// Yes, crude but probably effective.  Perhaps a more reasonable figure would be a ratio of the total
		// number of packets sent divided by the window size.  I.e., if your window size is 10 frames then one
		// packet in ten should fill the window.  Of course, this would have to be calculated in bytes...

		if((pEPD->uiWindowFilled > 12)&&(pEPD->uiThrottleEvents == 0))
		{
			LOGPF(7, "(%p) DYNAMIC ALG: Window Fills: %d; B-Ack = (%x vs %x)", pEPD, pEPD->uiWindowFilled, pEPD->uiPeriodRateB, pEPD->uiLastRateB);
									
			pEPD->uiWindowFilled = 0;	
			
			// GETTING HERE means that we have used our current transmit parameters long enough
			// to have an idea of their performance.  We will now compare this to the performance
			// of the previous transmit parameters and we will either Revert to the previous set if
			// the perf is not improved,  or else we will advance to faster parameters if we did see
			// a jump.

			uiThreshhold = pEPD->uiLastRateB;	// BUGBUG -- scale this up by some small factor like 1/8 or 1/16
			if( pEPD->uiPeriodRateB > uiThreshhold)
			{
				GrowSendWindow(pEPD, tNow);
			}
			else 
			{
				// We did not see a thru-put improvement so we will back off the previous value
				// and transition the link to STABLE state. (actually we will try twice before stabilizing).

				LOGPF(7, "(%p) INSUFFICENT INCREASE IN THRUPUT", pEPD);

				if(pEPD->ulEPFlags & EPFLAGS_SECOND_SAMPLE)
				{
					LOGPF(7, "(%p) BACK OFF AND TRANSITION TO STABLE", pEPD);

#ifdef USE_BURST_GAP					
					pEPD->uiBurstGap = pEPD->uiGoodBurstGap;
					pEPD->uiBurstSize = pEPD->uiGoodBurstSize;
					pEPD->iBurstSizeBytes = (INT) (pEPD->uiBurstSize * pEPD->pSPD->uiFrameLength);
#endif					
					
					pEPD->iWindowF = pEPD->iGoodWindowF;
					pEPD->uiWindowBIndex = pEPD->uiGoodWindowBI;
					pEPD->iWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;

					pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;				// TRANSITION TO STABLE STATE
					
					pEPD->ulEPFlags &= ~(EPFLAGS_SECOND_SAMPLE);

					dwSetPoint = (pEPD->iWindowF << 16) | pEPD->uiWindowBIndex;

					if(pEPD->dwSetPoint == dwSetPoint)
					{
						pEPD->uiStaticPeriod *= 2;
						LOGPF(7, "(%p) STABILIZED AT REPEATED SET-POINT.  New Static Period = %dms", pEPD, pEPD->uiStaticPeriod);
					}
					else 
					{
						pEPD->uiStaticPeriod = INITIAL_STATIC_PERIOD;
						pEPD->dwSetPoint = dwSetPoint;
						LOGPF(7, "(%p) Static Period = %dms", pEPD, pEPD->uiStaticPeriod);
					}
					
					pEPD->uiPeriodAcksBytes = 0;
					pEPD->uiPeriodXmitTime = 0;
					
					LOGPF(7, "(%p) ** TUNING LINK:  BurstGap=%d; BurstSize=%d; FWindow=%d, BWindow=%d (%d)",pEPD, pEPD->uiBurstGap, 	pEPD->uiBurstSize, pEPD->iWindowF, pEPD->iWindowB, pEPD->uiWindowBIndex);
				}
				else
				{
					//	We did not detect a significant increase in thruput since we last increased
					// our transmit rate.  Since there are variables in internet response and in client
					// behavior we will take another sample before determining that we have reached
					// a ceiling.  We will not toss our first data completely but we will scale back
					// both values in order to weight the new samples higher.
					//
					// Alternatively we could just zero them altogether...

					pEPD->ulEPFlags |= EPFLAGS_SECOND_SAMPLE;
					pEPD->uiPeriodAcksBytes = 0;
					pEPD->uiPeriodXmitTime = 0;
				}
			}
		}
		else 
		{
			LOGPF(7, "(%p) DYN ALG -- Not trying to increase:  WindowFills = %d, ThrottleCount = %d", pEPD, pEPD->uiWindowFilled, pEPD->uiThrottleEvents);
		}
	}	// END IF DYNAMIC STATE LINK
	
	pEPD->ulEPFlags &= ~(EPFLAGS_IDLED_PIPELINE);
}


/*
**		End Point Dropped Frame
**
**		We have two levels of Backoff.  We have an immediate BackOff implemented
**	upon first detection of a drop-event in order to relieve the congestion which
**	caused the drop.  An immediate backoff will resume transmitting at the original
**	rate without going through slow-start again after the congestion event has passed.
**	If we have multiple immediate-backoffs in a certain interval we will have a
**	hard backoff which will not restore.
**
**		The title says it all.  Keep books for EPD re: drop event.
**
**	CALLED WITH EPD->SendQLock held (and sometimes with StateLock held too)
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EndPointDroppedFrame"

VOID
EndPointDroppedFrame(PEPD pEPD, DWORD tNow)
{
	pEPD->fpDropsPer128Frames += 0x01000000;

	// If this is first drop in short interval
	if(!pEPD->uiDropCount++)
	{	
		LOGPF(7, "DROP EVENT INITIATED: Throttling Back");
		ThrottleBack(pEPD, tNow);
	}
	
	// Multiple drops reported in short order
	else 
	{		

		// There are two possibilities and trick is to distinguish them.  Either we are still xmitting too fast
		// OR we are seeing additional drops caused by the previous xmit rate.  In first case we must back off
		// further.  In second case we should do nothing.  As a heuristic,  we can say we will ignore the second
		// and third drop,  but backoff further by the fourth.  Kinda kludgy but will probably work pretty well.
		// Robust solution would be to try to calculate back-log ala aaron,  but I am not convinced that we could
		// do that efficiently.  Alternatively,  we could just fake the calc for the back-off and back off some
		// fudge based upon RTT and outstanding frames.

		// Throttle back every fourth drop!
		if((pEPD->uiDropCount & 3) == 0)
		{			
			LOGPF(7, "(%p) THROTTLING BACK FURTHER", pEPD);
			ThrottleBack(pEPD, tNow);
		}
	}
}

/*
**		Throttle Back
**
**		We suspect network congestion due to dropped frames ((or a spike in latency)).  We want
**	to quickly scale back our transmit rate to releive the congestion and avoid further packet drops.
**	This is a temporary backoff and we will resume our current transmit rate when the congestions
**	clears.
**
**		If we find that we are throttling back frequently then we may conclude that our current xmit
**	rate is higher then optimal and we will BackOff to a lower rate,  and transition to a STABLE link
**	state (if not already there) to indicate that we have plateaued.
**
**		A note on convergence.  The ThrottleEvents variable is incremented 10 points each time a throttle
**	event is triggered.  This variable also decays slowly when the link is running without events.  So if
**	the variable grows faster then it decays we will eventually trigger a switch to STABLE state
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ThrottleBack"

VOID
ThrottleBack(PEPD pEPD, DWORD tNow)
{
	pEPD->ulEPFlags |= EPFLAGS_THROTTLED_BACK;		// Set link to THROTTLED state
	pEPD->uiThrottleEvents += 10;					// Count times we throttle-back for all reasons
	pEPD->tThrottleTime = tNow;						// Remember time that throttle was engaged
	
#ifdef	DEBUG
	pEPD->uiTotalThrottleEvents++;					// Count times we throttle-back for all reasons
#endif

	pEPD->uiRestoreBurstSize = pEPD->uiBurstSize;
	pEPD->uiRestoreBurstGap = pEPD->uiBurstGap;
	pEPD->iRestoreWindowF = pEPD->iWindowF;
	pEPD->uiRestoreWindowBI = pEPD->uiWindowBIndex;

#ifdef USE_BURST_GAP
	if(pEPD->iWindowF == 1)
	{
		// Don't backoff any more if the drop rate is not at least 5%

		if(pEPD->fpDropsPer128Frames < 0x06000000)
		{
			// BUGBUG: we might want to apply the 5% criteria even when not at 1 frame.
			
			if(pEPD->uiBurstGap == 0)
			{
				pEPD->uiBurstGap = MAX(1,pEPD->uiRTT/2);
				LOGPF(7, "(%p), first burst gap, set to %d ms", pEPD, pEPD->uiBurstGap);
			} 
			else 
			{
				pEPD->uiBurstGap = pEPD->uiBurstGap*2;						
				LOGPF(7, "(%p), burst gap doubled to %d ms", pEPD, pEPD->uiBurstGap);
			}
			pEPD->uiBurstGap = MIN(pEPD->uiBurstGap, MAX_RETRY_INTERVAL/2);
			LOGPF(7, "(%p), burst gap is now %d ms", pEPD, pEPD->uiBurstGap);
		} 
		else 
		{
			LOGPF(7, "(%p) Not increasing burst gap in throttle back because drop rate < 5 currently %d ms%", pEPD, pEPD->uiBurstGap);
		}
	}
#endif

	pEPD->iWindowF = MAX(pEPD->iWindowF / 2, 1);	// be sure window remains > 0.
	pEPD->uiWindowBIndex = MAX(pEPD->uiWindowBIndex / 2, 1);
	pEPD->iWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
	LOGPF(7, "(%p) THROTTLE ENGAGED (%d):  Backoff to Window=%d; Gap=%d; Size=%d", pEPD, pEPD->uiThrottleEvents, pEPD->iWindowF, pEPD->uiBurstGap, pEPD->uiBurstSize);
	
	if(pEPD->uiThrottleEvents > THROTTLE_EVENT_THRESHOLD)
	{
		LOGPF(7, "(%p) ** DETECT TRANSMIT CEILING ** Reducing 'good' speed and marking link STABLE", pEPD);

		// We have already reduced our current transmit rates.  Here we will reduce the "good" rates that
		// we will restore to when we clear the throttled state.
		
		pEPD->uiThrottleEvents = 0;

		pEPD->iRestoreWindowF = MAX((pEPD->iRestoreWindowF - 1), 1);
		pEPD->uiRestoreWindowBI = MAX((pEPD->uiRestoreWindowBI - 1), 1);

#ifdef USE_BURST_GAP		
		// If we are sending multi-bursts,  make them smaller
		if( pEPD->uiRestoreBurstSize > 1 )
		{			
			pEPD->uiRestoreBurstSize -= 1;				// Reduce burst!
			pEPD->iRestoreWindowF = pEPD->uiRestoreBurstSize;
		}
		else if (pEPD->uiRestoreBurstGap)
		{
			UINT t;
			t=pEPD->uiRestoreBurstGap;
			pEPD->uiRestoreBurstGap = (t+1) + (t >> 2); // 1.25*pEPD->uiRestoreBurstGap
		}
#endif
		LOGPF(7, "(%p) New Restore Values:  Window=%d; Gap=%d; Size = %d", pEPD, pEPD->iRestoreWindowF, pEPD->uiRestoreBurstGap, pEPD->uiRestoreBurstSize);

		pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;
	}
}


/*
**		Update End Point
**
**		We have just received a correlated response on a particular endpoint.
**	This means we can adjust our link calculations.  
**
**		Link timing calcs:  We are now calculating two different intervals for each data-point
**	packet.  We are calculating the total Round Trip Time (RTT) which is useful for calculating
**	retry timeout values,  and we are also attempting to calculate *changes* in the outbound
**	transit latency.  We can only calculate changes because we never truely synchronize clocks with
**	our partner.  We do track the clock bias though,  so we can infer a larger or shorter transmit latency
**	by a growing or shrinking clock bias.  I believe that we can ignore clock drift because we are more
**	interested in dramitic jumps or drops and can ignore a gradual change.
**
**		RTT Math - We will do our RTT math in fixed point 16.16 to allow for more
**	granularity in our moving averages.  So every time we compute a new RTT we will
**	also store the integer portion which is used in calculating timeouts.
**
**		Payload - Since on WANs the packet size can have a dramatic effect on the transmission latency,
**	we would like to factor it into our calculations (but only on links in WAN state).  We will track the
**	latency bias for minimal frames and for the largest frames that we see.  We will expect to see latencies
**	distributed over this range in proportion to the additional data in the frame.  I hope this works...
**
**		** CALLED WITH EPD STATELOCK HELD **
*/

#define		RTT_GROWTH_THRESHOLD			6					// consective samples of RTT incr to trigger BackOff
#define		RECOVERY_THRESHHOLD				3					// consecutive AdaptAlg runs before clearing BackOff state
#define		CEILING_THRESHHOLD				3					// ceiling hit occurances before switch to STABLE mode

#define		BURST_GAP_TOLERANCE				5					// Smallest increment to use for burst gaps


/*
**		Release End Point
**
**			We are finished communicating with this end point.  If this was the
**		last reference then we should free the descriptor and Disconnect the SP.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseEndPoint"

VOID ReleaseEndPoint(PEPD pEPD, BOOL Locked)
{
	PSPD				pSPD = pEPD->pSPD;

	ASSERT((pEPD->ulEPFlags & EPFLAGS_CONNECTED)==0);	// clear connected state,  just is case...

	DisconnectConnection(pEPD);							// Close the endpoint in the Service Provider
	
	if(!Locked)
		Lock(&pEPD->pSPD->SendQLock);
	pEPD->blActiveLinkage.RemoveFromList(); 					// remove guy from active list
	if(!Locked)
		Unlock(&pEPD->pSPD->SendQLock);

	EPDPool->Release(EPDPool, pEPD);
}



/*
**		EPD Pool Support Routines
**
**		These are the functions called by Fixed Pool Manager as it handles EPDs.
*/

//	Allocate is called when a new EPD is first created

#define	pELEMENT	((PEPD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Allocate"

BOOL EPD_Allocate(PVOID pElement)
{
	//pELEMENT->blDatagramQueue.Initialize();
	//pELEMENT->blRelySendQ.Initialize();
	
	pELEMENT->blHighPriSendQ.Initialize();				// Can you beleive there are SIX send queues per Endpoint?
	pELEMENT->blNormPriSendQ.Initialize();				// Six send queues.  
	pELEMENT->blLowPriSendQ.Initialize();				// Well,  it beats sorting the sends into the queues upon submission.
	pELEMENT->blCompleteSendList.Initialize();
	
	pELEMENT->blSendWindow.Initialize();
	pELEMENT->blRetryQueue.Initialize();
	pELEMENT->blCompleteList.Initialize();
	pELEMENT->blOddFrameList.Initialize();
	pELEMENT->blChkPtQueue.Initialize();
	INITCRITSEC(&pELEMENT->EPLock);
	pELEMENT->Sign = EPD_SIGN;
	pELEMENT->pCurrentSend = NULL;
	pELEMENT->pCurrentFrame = NULL;
	pELEMENT->pCommand = NULL;

	pELEMENT->RetryTimer = 0;
	pELEMENT->ConnectTimer = 0;
	pELEMENT->DelayedAckTimer = 0;


	return TRUE;
}

//	Get is called each time an EPD is used

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Get"

VOID EPD_Get(PVOID pElement)
{
	LOGPF(5, "CREATING EPD %p", pELEMENT);

	pELEMENT->pNewMessage = NULL;
	pELEMENT->pNewTail = NULL;
	
	pELEMENT->ulEPFlags = 0;	// This line can go away...  can this function go away???
	pELEMENT->uiRefCnt = 0;

	ASSERT_EPD(pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Release"

VOID EPD_Release(PVOID pElement)
{
	PCHKPT pCP;

	ASSERT_EPD(pELEMENT);

	LOGPF(5, "RELEASING EPD %p", pELEMENT);

	ASSERT((pELEMENT->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)==0);

	// These lists should be empty before End Point is released...

	ASSERT(pELEMENT->blOddFrameList.IsEmpty());
	ASSERT(pELEMENT->blSendWindow.IsEmpty());
	ASSERT(pELEMENT->blHighPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blNormPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blLowPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blRetryQueue.IsEmpty());
	ASSERT(pELEMENT->pCurrentSend == NULL);
	ASSERT(pELEMENT->pCurrentFrame == NULL);
	
	// Clear any checkpoints still waiting on EP

	while(!pELEMENT->blChkPtQueue.IsEmpty()){
		pCP = CONTAINING_RECORD(pELEMENT->blChkPtQueue.GetNext(), CHKPT, blLinkage);
		pCP->blLinkage.RemoveFromList();
		ChkPtPool->Release(ChkPtPool, pCP);
	}
	pELEMENT->ulEPFlags = 0;
	pELEMENT->pCommand = NULL;
	pELEMENT->Context = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Free"

VOID EPD_Free(PVOID pElement)
{
	DELETECRITSEC(&pELEMENT->EPLock);
}

#undef	ELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\frames.h ===
/*===
		Direct Network Protocl   --   Frame format header file


		Evan Schrier	10/98

*/



/*	
		Direct Network Protocol

| MEDIA HEADER | Var Len DN Header | Client Data |

There are two types of packets that may be exchanged between Direct Network
endpoints:

	Data Packets				(D Frame)	User data transmission
	Control Packets				(C Frame)	Internal link-state packets with no user data



*/

/*
	COMMAND FIELD

		The command field is the first byte of all frames.  The first BIT of the command frame is always
	the COMMAND FRAME vs DATA FRAME opcode.  The seven high bits of the Command field are flags.  We have
	a requirement that the command field of all protocol packets must never be all zeros.  Therefore,  when
	the opcode bit is zero (COMMAND FRAME) we must be sure that one flag bit is always set.  The highest flag bit,
	the USER2 flag is not relevant to COMMAND frames so we will always set the most significant bit when the opcode
	bit is zero.

		The seven command field flag bits are defined as follows:

	RELIABLE	-	Data delivery of this frame is guarenteed
	SEQUENTIAL	-	Data in this frame must be delivered in the order it was sent, with respect to other SEQ frames
	POLL		-	Protocol requests an immediate acknowledgement to this frame
	NEW MESSAGE	-	This frame is the first or only frame in a message
	END MESSAGE -	This frame is the last or only frame in a message
	USER1		-	First flag controlled by the higher layer (direct play core)
	USER2		-	Second flag controlled by core.  These flags are specified in the send API and are delivered with the data


	DATA FRAMES

		Data frames are between 4 and 20 bytes in length.  They should typically be only 4 bytes.  Following the
	Command byte in all data frames in the Control byte.  This byte contains a 3-bit retry counter and 5 additional
	flags.  The Control byte flags are defined as follows:

	END OF STREAM	-	This frame is the last data frame the transmitting partner will send.
	SACK_MASK_ONE	-	The low 32-bit Selective Acknowledgment mask is present in this header
	SACK_MASK_TWO	-	The high 32-bit Selective Acknowledgment mask is present in this header
	SEND_MASK_ONE	-	The low 32-bit Cancel Send mask is present in this header
	SEND_MASK_TWO	-	The high 32-bit Cancel Send mask is present in this header

		After Control byte come two one byte values:  Sequence number for this frame, and Next Receive sequence number
	expected by this partner.  After these two bytes comes zero through four bitmasks as specified by the control flags.
	After the bitmasks,  the rest of the frame is user data to be delivered to the direct play core.
*/
#ifndef	_DNET_FRAMES_
#define	_DNET_FRAMES_

//#define		FRAME_NAMES
//#define		FRAME_DROPS

#ifdef	FRAME_NAMES

#define		DG_NAME			'MRGD'
#define		RELY_NAME		'DNES'
#define		RETRY_NAME		'YRTR'
#define		ACK_NAME		' KCA'
#define		DG_ACK_NAME		'KCAD'
#define		COMBI_ACK_NAME	'KCAC'
#define		CONNECT_NAME	'LLAC'
#define		CONNECTED_NAME	'NNOC'
#define		DISCON_NAME		'CSID'
#define		DISCONED_NAME	'ENOD'

#define		POLL_NAME		'LLOP'
#define		RESPONSE_NAME	'PSER'

#define		SELECT_NAME		'YTRS'				// Selective Ack
#define		KEEPALIVE_NAME	'EKOP'	

#endif
#ifdef	FRAME_DROPS

#define		GOOD_STATE		'DOOG'
#define		DROP_STATE		'PORD'

#endif

/*
	Command FRAME Extended Opcodes

	A CFrame without an opcode is a vehicle for non-piggybacked acknowledgement
	information.  The following sub-commands are defined at this time:

	NOP				- Only Ack/Nack info present
	CONNECT 		- Initialize a reliable connection
	CONNECTED		- Response to CONNECT request
	DISCONNECT		- Closing previous connection
	DISCONNECTED	- Response to DISCONNECT request
	REJECT			- Command rejected (connection refused,  invalid connection)
*/

#define		FRAME_EXOPCODE_CONNECT			1
#define		FRAME_EXOPCODE_CONNECTED		2
#define		FRAME_EXOPCODE_DISCONNECTED		4
#define		FRAME_EXOPCODE_SACK			6


typedef struct packetheader			PacketHeader, *PPacketHeader;
typedef struct dataframe			DFRAME, *PDFRAME;
typedef struct cframe				CFRAME, *PCFRAME;
typedef struct sackframe			SACKFRAME, *PSACKFRAME;
typedef struct sackframe_big		SFBIG, *PSFBIG;

typedef	struct dataframe_masks		DFMASKS, *PDFMASKS;
typedef	struct dataframe_big		DFBIG, *PDFBIG;

//	Packet Header is common to all frame formats

#define	PACKET_COMMAND_DATA			0x01		// Frame contains user data
#define	PACKET_COMMAND_RELIABLE		0x02		// Frame should be delivered reliably
#define	PACKET_COMMAND_SEQUENTIAL	0x04		// Frame should be indicated sequentially
#define	PACKET_COMMAND_POLL			0x08		// Partner should acknowlege immediately
#define	PACKET_COMMAND_NEW_MSG		0x10		// Data frame is first in message
#define	PACKET_COMMAND_END_MSG		0x20		// Data frame is last in message
#define	PACKET_COMMAND_USER_1		0x40		// First user controlled flag
#define	PACKET_COMMAND_USER_2		0x80		// Second user controlled flag
#define	PACKET_COMMAND_CFRAME		0x80		// Set high-bit on command frames because first byte must never be zero

#define	PACKET_CONTROL_RETRY		0x01		// This flag designates this frame as a retry of a previously xmitted frame
#define	PACKET_CONTROL_CORRELATE	0x02		// Respond to this frame with a dedicated reply
#define	PACKET_CONTROL_RESPONSE		0x04		// THIS IS NOT CURRENTLY IMPLEMENTED - CORR RESPONSES WILL USE DEDICATED FRAMES
#define	PACKET_CONTROL_END_STREAM	0x08		// This packet serves as Disconnect frame.
#define	PACKET_CONTROL_SACK_MASK1	0x10		// The low 32-bit SACK mask is included in this frame.
#define	PACKET_CONTROL_SACK_MASK2	0x20		// The high 32 bit SACK mask is present
#define	PACKET_CONTROL_SEND_MASK1	0x40		// The low 32-bit SEND mask is included in this frame
#define	PACKET_CONTROL_SEND_MASK2	0x80		// The high 32-bit SEND mask is included in this frame

#define	PACKET_CONTROL_VARIABLE_MASKS	0xF0	// All four mask bits above

struct	packetheader {
#ifdef	FRAME_NAMES
	DWORD		Name;				// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD		State;
#endif
	BYTE		bCommand;
};

/*		NEW DATA FRAMES
**
**		Here in the new unified world we have only two frame types!  CommandFrames and DataFrames...
**
*/

struct	dataframe {
#ifdef	FRAME_NAMES
	DWORD	Name;
#endif
#ifdef	FRAME_DROPS
	DWORD	State;
#endif
	BYTE	bCommand;
	BYTE	bControl;
	BYTE	bSeq;
	BYTE	bNRcv;
};

//	Following the 4 byte dataframe header will be between zero and four 32-bit masks,  as defined by the CONTROL flags,
// representing either Specific Acks (SACK) or unreliable dropped sends (SEND MASK).

struct	dataframe_masks {
	ULONG	rgMask[1];			// Zero to four 32-bit masks of either SACK info or SEND info
};

struct dataframe_big {
#ifdef	FRAME_NAMES
	DWORD	Name;
#endif
#ifdef	FRAME_DROPS
	DWORD	State;
#endif
	BYTE	bCommand;
	BYTE	bControl;
	BYTE	bSeq;
	BYTE	bNRcv;
	ULONG	rgMask[4];
};

/*	
**		COMMAND FRAMES
**
**		Command frames are everything that is not part of the reliable stream.  This is most of the control traffic
**	although some control traffic is part of the stream (keep-alive, End-of-Stream)
*/

struct	cframe {
#ifdef	FRAME_NAMES
	DWORD	Name;					// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD	State;
#endif
	BYTE	bCommand;
	BYTE	bExtOpcode;				// CFrame sub-command
	BYTE	bMsgID;					// Correlator in case ExtOpcode requires a response
	BYTE	bRspID;					// Correlator in case this is a response
	DWORD	dwVersion;				// Protocol version #
	DWORD	dwSessID;				// Session identifier
	DWORD	tTimestamp;				// local tick count
};

/*	
**	Selective Acknowledgement packet format
**
**		When a specific acknowledgement frame is sent there may be two additional pieces
**	of data included with the frame.  One is a bitmask allowing selective acknowledgment
**	of non-sequential frames.  The other is timing information about the last frame acked
**  by this ACK (NRcv - 1).  Specifically,  it includes the lowest Retry number that this
**  node received,  and the ms delay between that packets arrival and the sending of this
**	Ack.
*/


#define		SACK_FLAGS_RESPONSE			0x01	// indicates that Retry and Timestamp fields are valid
#define		SACK_FLAGS_SACK_MASK1		0x02
#define		SACK_FLAGS_SACK_MASK2		0x04
#define		SACK_FLAGS_SEND_MASK1		0x08
#define		SACK_FLAGS_SEND_MASK2		0x10

//	First format is used when DATAGRAM_INFO flag is clear

struct	sackframe {	
#ifdef	FRAME_NAMES
	DWORD		Name;					// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD		State;
#endif
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;
	BYTE		bNSeq;					// Since this frame has no sequence number, this is the next Seq we will send
	BYTE		bNRcv;					// As above
	DWORD		tTimestamp;				// Local timestamp when packet (NRcv - 1) arrived
};

struct sackframe_big {
#ifdef	FRAME_NAMES
	DWORD		Name;					// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD		State;
#endif
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;
	BYTE		bNSeq;					// Since this frame has no sequence number, this is the next Seq we
	BYTE		bNRcv;					// As above
	DWORD		tTimestamp;				// Local stamp when packet arrived
	ULONG		rgMask[4];
};

#ifdef	OLD_CODE

//	Reliable Stream packet format
//
//	If the SACK Flag is set in an SFrame then a DWORD of ack flags are present
//	after N(S) & N(R) and before the payload.

struct	sframe {
#ifdef	FRAME_NAMES
	DWORD		Name;				// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD		State;				// DEBUG Allow frames to be "damaged" to simulate drops
#endif
	BYTE		bCommand;
	BYTE		bRetry;
	USHORT		usSeq;				// Sequence number of this frame N(S)
	USHORT		usNRcv;				// Next in-order sequence number expected N(R)
	USHORT		usDrops;			// Total number of datagrams detected as dropped by this station
};

//	Unreliable Datagram - single frame message limit means less state needed in message...

struct	uframe {
#ifdef	FRAME_NAMES
	DWORD		Name;				// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD		State;
#endif
	BYTE	bCommand;
	BYTE	bMsgID;					// Used to correlate replies and to detect lost frames, even tho they're not acked
};

//	Unreliable response frame - additional fields in a UFrame if RESP flag is set

struct respframe {
	BYTE	bRspID;					// valid if RESP flag is set: Msg ID of paired Poll
	BYTE	bResv;					// reserved byte
	USHORT	usDrops;				// total number of frames detected as lost (partner will compute difference)
	USHORT	usDelay;				// ms delay between arrival of POLL frame and transmission of this RESP
	DWORD	tTimestamp;
//	BYTE	data[];
};

struct uframe_rsp {
	UFRAME		UFrame;
	RESPFRAME	Resp;
};


//	This format is used when DATAGRAM_INFO flag is set

struct	sackframe_datagram {
#ifdef	FRAME_NAMES
	DWORD		Name;					// DEBUG FRAME NAME.  I will remove this when I have a sniffer parser
#endif
#ifdef	FRAME_DROPS
	DWORD		State;
#endif
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;					// Retry code of frame we are acknowledging
	USHORT		usNSeq;					// As above
	USHORT		usNRcv;					// As above
	DWORD		tTimestamp;				// Local stamp when packet arrived
	DWORD		dwDelay;				// ms count since identified frame arrived
	ULONG		ulMask;					// Bitmask SACKing frames to left of bNSeq
	ULONG		ulMaskHigh;				// 2nd 32 bits of out of order mask
	RESPFRAME	DatagramResp;
};

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\enum.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Enum.cpp
 *  Content:	This file contains support enuming sessions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  01/10/00	jtk		Created
 *	03/22/00	mjn		Changed IDirectPlayAddress8 references to IDirectPlay8Address
 *
 ****************************************************************************/


#include "dnproti.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNPEnumQuery - enum sessions
//
// Entry:		Pointer to this interface
//				Pointer to device address
//				Pointer to host address
//				Pointer to user data buffers
//				Count of user data buffers
//				Retry count
//				Retry interval (milliseconds)
//				Timeout (milliseconds)
//				Command flags
//				Pointer to user context
//				Pointer to command handle destination
//
// Exit:		Boolean inficating whether the GUID is a serial GUID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNPEnumQuery"

HRESULT DNPEnumQuery( PProtocolData pPData,
					  IDirectPlay8Address *const pHostAddress,
					  IDirectPlay8Address *const pDeviceAddress,
					  const HANDLE hSPHandle,
					  BUFFERDESC *const pBuffers,
					  const DWORD dwBufferCount,
					  const DWORD dwRetryCount,
					  const DWORD dwRetryInterval,
					  const DWORD dwTimeout,
					  const DWORD dwFlags,
					  void *const pUserContext,
					  HANDLE *const pCommandHandle )
{
	PSPD			pSPD;
	PMSD			pMSD;
	SPENUMQUERYDATA	EnumData;
	UINT			i;
	HRESULT			hr;

	LOGPF(2, "Parameters: pPData[%p], pHostAddr[%p], pDeviceAddr[%p], hSPHandle[%x], pBuffers[%p], dwBufferCount[%x], dwRetryCount[%x], dwRetryInterval[%x], dwTimeout[%x], dwFlags[%x], pUserContext[%p], pCommandHandle[%p]", pPData, pHostAddress, pDeviceAddress, hSPHandle, pBuffers, dwBufferCount, dwRetryCount, dwRetryInterval, dwTimeout, dwFlags, pUserContext, pCommandHandle);

	pSPD = (PSPD) hSPHandle;
	ASSERT(pSPD != NULL);
	if(pSPD == NULL)
	{
		return DPNERR_NOTREADY;
	}
	ASSERT_SPD(pSPD);

	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		LOGPF(0, "SP is terminating, returning DPNERR_NOTREADY");
		return DPNERR_NOTREADY;
	}

	// We use an MSD to describe this Op even tho it
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{	
		LOGPF(0, "Failed to allocate MSD");
		Unlock(&pSPD->SendQLock);
		return DPNERR_OUTOFMEMORY;				// .. isnt technically a message
	}

	pMSD->CommandID = COMMAND_ID_ENUM;
	pMSD->pSPD = pSPD;
	pMSD->Context = pUserContext;

	EnumData.pAddressHost = pHostAddress;
	EnumData.pAddressDeviceInfo = pDeviceAddress;
	EnumData.pBuffers = pBuffers;
	EnumData.dwBufferCount = dwBufferCount;
	EnumData.dwTimeout = dwTimeout;
	EnumData.dwRetryCount = dwRetryCount;
	EnumData.dwRetryInterval = dwRetryInterval;

	EnumData.dwFlags = 0;

	if ( ( dwFlags & DPNENUMHOSTS_NOBROADCASTFALLBACK ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_NOBROADCASTFALLBACK;
	}

	EnumData.pvContext = pMSD;
	EnumData.hCommand = NULL;

	*pCommandHandle = pMSD;

	Lock(&pMSD->pSPD->SendQLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);		// Dont support timeouts for Listen
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pMSD->pSPD->SendQLock);

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	LOCK_MSD(pMSD, "SP Ref");											// AddRef for SP

	LOGPF(3, "Calling SP->EnumQuery");
/**/hr = IDP8ServiceProvider_EnumQuery(pSPD->IISPIntf, &EnumData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// This should always Pend or else be in error
		LOGPF(0, "Calling SP->EnumQuery Failed, return is not DPNERR_PENDING, hr[%x]", hr);

		Lock(&pMSD->CommandLock);

		Lock(&pSPD->SendQLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST | MFLAGS_ONE_IN_SERVICE_PROVIDER);
		Unlock(&pSPD->SendQLock);

		DECREMENT_MSD(pMSD, "SP Ref");				// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");		// release again to return resource

		return hr;
	}

	pMSD->hCommand = EnumData.hCommand;			// retain SP command handle
	pMSD->dwCommandDesc = EnumData.dwCommandDescriptor;

	return DPNERR_PENDING;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNPEnumRespond - respond to an enum query
//
// Entry:		Pointer to this interface
//				Handle of enum to respond to (pointer to SPIE_ENUMQUERY structure)
//				Pointer data buffers to send
//				Count of data buffers to send
//				Flags
//				User context for this operation
//				Pointer to command handle destination
//
// Exit:		Boolean inficating whether the GUID is a serial GUID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNPEnumRespond"

HRESULT DNPEnumRespond( PProtocolData pPData,
					    const HANDLE hSPHandle,
						const HANDLE hQueryHandle,				// handle of enum query being responded to
						BUFFERDESC *const pResponseBuffers,	
						const DWORD dwResponseBufferCount,
						const DWORD dwFlags,
						void *const pUserContext,
						HANDLE *const pCommandHandle )
{
	PSPD				pSPD;
	PMSD				pMSD;
	SPENUMRESPONDDATA	EnumRespondData;
	UINT				i;
	HRESULT				hr;

	LOGPF(2, "Parameters: pPData[%p], hSPHandle[%x], hQueryHandle[%x], pResponseBuffers[%p], dwResponseBufferCount[%x], dwFlags[%x], pUserContext[%p], pCommandHandle[%p]", pPData, hSPHandle, hQueryHandle, pResponseBuffers, dwResponseBufferCount, dwFlags, pUserContext, pCommandHandle);
	EnumRespondData.pQuery = static_cast<SPIE_QUERY*>( hQueryHandle );
	DNASSERT( EnumRespondData.pQuery != NULL );

	pSPD = (PSPD) hSPHandle;
	ASSERT(pSPD != NULL);
	if(pSPD == NULL)
	{
		LOGPF(0, "SP is NULL, returning DPNERR_NOTREADY");
		return DPNERR_NOTREADY;
	}
	ASSERT_SPD(pSPD);

	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		LOGPF(0, "SP is terminating, returning DPNERR_NOTREADY");
		return DPNERR_NOTREADY;
	}

	// We use an MSD to describe this Op even tho it
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		LOGPF(0, "Failed to allocate MSD");
		Unlock(&pSPD->SendQLock);
		return DPNERR_OUTOFMEMORY;				// .. isnt technically a message
	}

	pMSD->CommandID = COMMAND_ID_ENUMRESP;
	pMSD->pSPD = pSPD;
	pMSD->Context = pUserContext;

	EnumRespondData.pBuffers = pResponseBuffers;
	EnumRespondData.dwBufferCount = dwResponseBufferCount;
	EnumRespondData.dwFlags = dwFlags;
	EnumRespondData.pvContext = pMSD;
	EnumRespondData.hCommand = NULL;

	*pCommandHandle = pMSD;

	Lock(&pMSD->pSPD->SendQLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pMSD->pSPD->SendQLock);

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	LOCK_MSD(pMSD, "SP Ref");										// AddRef for SP

	LOGPF(3, "Calling SP->EnumRespond");
/**/hr = IDP8ServiceProvider_EnumRespond(pSPD->IISPIntf, &EnumRespondData);		/** CALL SP **/

	// This should always Pend or else be in error
	if(hr != DPNERR_PENDING)
	{
		LOGPF(0, "Calling SP->EnumRespond, return is not DPNERR_PENDING, hr[%x]", hr);

		Lock(&pMSD->CommandLock);

		Lock(&pSPD->SendQLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST | MFLAGS_ONE_IN_SERVICE_PROVIDER);
		Unlock(&pSPD->SendQLock);

		DECREMENT_MSD(pMSD, "SP Ref");				// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");		// release again to return resource

		return hr;
	}

	pMSD->hCommand = EnumRespondData.hCommand;				// retain SP command handle
	pMSD->dwCommandDesc = EnumRespondData.dwCommandDescriptor;

	return DPNERR_PENDING;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\lower_mn.cpp ===
#include "dnproti.h"

//	Now, a little bit of probably unnecesary junk for our lower edge

/*
 * DNP_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

STDMETHODIMP DNSP_QueryInterface(
				IDP8SPCallback	*pDNPI,
                REFIID riid,
                LPVOID *ppvObj )
{
	HRESULT hr;

    *ppvObj = NULL;


        ((PDNPI_INT) pDNPI)->dwRefCnt++;
        *ppvObj = pDNPI;
		hr = S_OK;


	return hr;

} /* DNP_QueryInterface */


/*
 * DNP_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8SPCallback *pDNPI)
{
    ((PDNPI_INT) pDNPI)->dwRefCnt++;
    return ((PDNPI_INT) pDNPI)->dwRefCnt;
} /* DNP_AddRef */



/*
 * DNP_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8SPCallback *pDNPI )
{
    ((PDNPI_INT) pDNPI)->dwRefCnt--;

    return ((PDNPI_INT) pDNPI)->dwRefCnt;
} /* DNP_Release */

IDP8SPCallbackVtbl DNPLowerEdgeVtbl =
{
        DNSP_QueryInterface,
        DNSP_AddRef,
        DNSP_Release,
		DNSP_IndicateEvent,
		DNSP_CommandComplete
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\initialize.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Initialize.c
 *  Content:	This file contains code to both initialize and shutdown the
 *				protocol,  as well as to Add and Remove service providers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  08/15/00    RichGr  Bug #41363: Trigger timer and memory pool initialization at DLL startup,
 *                      but actually do it during the first DPlay8 object instantiation.  New functions
 *                      Pools_Pre_Init() and Pools_Deinit() are called from DNet.dll's DllMain.  
 *
 ****************************************************************************/

#include "dnproti.h"

class DIRECTNETOBJECT;

/*
**		GLOBAL VARIABLES
**
**			There are two kinds of global variables.  Instance specific globals
**	(not really global,  i know) which are members of the ProtocolData structure,
**	and true globals which are shared amonst all instances.  The following
**	definitions are true globals,  such as FixedPools and Timers.
*/

LPFPOOL			ChkPtPool = NULL;	// Pool of CheckPoint data structure
LPFPOOL			EPDPool = NULL;		// Pool of End Point descriptors
LPFPOOL			MSDPool = NULL;		// Pool of Message Descriptors
LPFPOOL			FMDPool = NULL;		// Pool of Frame Descriptors
LPFPOOL			RCDPool = NULL;		// Pool of Receive Descriptors

LPFPOOL			BufPool = NULL;		// Pool of buffers to store rcvd frames
LPFPOOL			MedBufPool = NULL;
LPFPOOL			BigBufPool = NULL;

BOOL volatile   g_bFirstTime;
DNCRITICAL_SECTION  g_FirstTimeCritSec;
extern CThreadPool *g_pThreadPool2;

HRESULT			TimerWorkaround = DPNERR_UNINITIALIZED;


/*
**		Pools Pre-Initialization
**
**		This procedure should be called by DllMain at startup time before
**      DPlay8 object instantiation.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Pools_Pre_Init"

void  Pools_Pre_Init()
{
    g_bFirstTime = TRUE;
    DNInitializeCriticalSection(&g_FirstTimeCritSec);
}

/*
**		Pools Initialization
**
**		This procedure should be called once only at DPlay8 object instantiation.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Pools_Init"

BOOL  Pools_Init()
{

	if((ChkPtPool = FPM_Create(sizeof(CHKPT), NULL, NULL, NULL, NULL)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((EPDPool = FPM_Create(sizeof(EPD), EPD_Allocate, EPD_Get, EPD_Release, EPD_Free)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((MSDPool = FPM_Create(sizeof(MSD), MSD_Allocate, MSD_Get, MSD_Release, MSD_Free)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((FMDPool = FPM_Create(sizeof(FMD), FMD_Allocate, FMD_Get, FMD_Release, FMD_Free)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((RCDPool = FPM_Create(sizeof(RCD), RCD_Allocate, RCD_Get, RCD_Release, RCD_Free)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((BufPool = FPM_Create(sizeof(BUF), Buf_Allocate, Buf_Get, NULL, NULL)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((MedBufPool = FPM_Create(sizeof(MEDBUF), Buf_Allocate, Buf_GetMed, NULL, NULL)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((BigBufPool = FPM_Create(sizeof(BIGBUF), Buf_Allocate, Buf_GetBig, NULL, NULL)) == NULL){
		Pools_Deinit();
		return FALSE;
	}
	if((TimerWorkaround = InitTimerWorkaround()) != DPN_OK){
		Pools_Deinit();
		return FALSE;
	}


    return TRUE;
}

/*
**		Pools Deinitialization
**
**		This procedure should be called by DllMain at shutdown time after
**      DPlay8 object release.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Pools_Deinit"

void  Pools_Deinit()
{

	if(TimerWorkaround == DPN_OK){
		FiniTimerWorkaround();
		TimerWorkaround = DPNERR_UNINITIALIZED;
	}
	if(ChkPtPool != NULL){
		ChkPtPool->Fini(ChkPtPool);
		ChkPtPool = NULL;
	}
	if(EPDPool != NULL){
		EPDPool->Fini(EPDPool);
		EPDPool = NULL;
	}
	if(MSDPool != NULL){
		MSDPool->Fini(MSDPool);
		MSDPool = NULL;
	}
	if(FMDPool != NULL){
		FMDPool->Fini(FMDPool);
		FMDPool = NULL;
	}
	if(RCDPool != NULL){
		RCDPool->Fini(RCDPool);
		RCDPool = NULL;
	}
	if(BufPool != NULL){
		BufPool->Fini(BufPool);
		BufPool = NULL;
	}
	if(MedBufPool != NULL){
		MedBufPool->Fini(MedBufPool);
		MedBufPool = NULL;
	}
	if(BigBufPool != NULL){
		BigBufPool->Fini(BigBufPool);
		BigBufPool = NULL;
	}

    DNDeleteCriticalSection(&g_FirstTimeCritSec);

    return;
}


/*
**		Protocol Initialize
**
**		This procedure should be called by DirectPlay at startup time before
**	any other calls in the protocol are made.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolInitialize"

HRESULT DNPProtocolInitialize(PVOID pCoreContext, PProtocolData pPData, PDN_PROTOCOL_INTERFACE_VTBL pVtbl)
{
	HRESULT			hr;
	UINT			InitState = 0;
    BOOL            bOK;

	LOGPF(2, "Parameters: pCoreContext[%p], pPData[%p], pVtbl[%p]", pCoreContext, pPData, pVtbl);

    //  8/15/00(RichGr) - Bug #41363: Timer and memory pool initialization is triggered at DLL startup,
    //     but actually done during the first DPlay8 object instantiation.
    if (g_bFirstTime)
    {
        DNEnterCriticalSection(&g_FirstTimeCritSec);
        bOK = TRUE;

        // Ask again in case 2 threads got thru the first "if" test.
        if (g_bFirstTime)
            bOK = Pools_Init();

        g_bFirstTime = FALSE;
        DNLeaveCriticalSection(&g_FirstTimeCritSec);

        if ( !bOK)
	    {
			LOGPF(0, "Returning DPNERR_OUTOFMEMORY - Couldn't initialize pools");
    	    return DPNERR_OUTOFMEMORY;
        }
    }

	pPData->ulProtocolFlags = 0;
	pPData->Parent = pCoreContext;	// Changed this for debug ONLY - MJN
	pPData->pfVtbl = pVtbl;
	pPData->Sign = PD_SIGN;

	pPData->lSPActiveCount = 0;
	
	// Init 1,  allocate End Point Descriptor stuff

	srand(GETTIMESTAMP());
	pPData->dwNextSessID = rand() | (rand() << 16);			// build a 32 bit value out of two 16 bit values

	pPData->tIdleThreshhold = DEFAULT_KEEPALIVE_INTERVAL;	// 60 second keep-alive interval
	pPData->dwConnectTimeout = CONNECT_DEFAULT_TIMEOUT;
	pPData->dwConnectRetries = CONNECT_DEFAULT_RETRIES;
	
	pPData->ulProtocolFlags |= PFLAGS_PROTOCOL_INITIALIZED;

	return DPN_OK;
}

/*
**		Protocol Shutdown
**
**		This procedure should be called at termination time,  and should be the
**	last call made to the protocol.
**
**		All SPs should have been removed prior to this call which in turn means
**	that we should not have any sends pending in a lower layer.
*/

#ifdef	DEBUG
extern	long ThreadsInReceive;
extern	long BuffersInReceive;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolShutdown"

HRESULT DNPProtocolShutdown(PProtocolData pPData)
{
	LOGPF(2, "Parameters: pPData[%p]", pPData);

	if(pPData->lSPActiveCount != 0)
	{
		LOGPF(0, "Returning DPNERR_INVALIDCOMMAND - There are still active SPs, DNPRemoveSP wasn't called");
		return DPNERR_INVALIDCOMMAND;					// Must remove Service Providers first
	}

#ifdef DEBUG
	if (BuffersInReceive != 0)
	{
		LOGPF(0, "*** %d receive buffers were leaked", BuffersInReceive);	
	}
#endif

	pPData->ulProtocolFlags = 0;

	return	DPN_OK;
}

/*
**		Add Service Provider
**
**		This procedure is called by Direct Play to bind us to a service provider.
**	We can bind up to 256 service providers at one time,  although I would not ever
**	expect to do so.  This procedure will fail if Protocol Initialize has not
**	been called.
**
**
**		We check the size of the SP table to make sure we have a slot free.  If table
**	is full we double the table size until we reach maximum size.  If table cannot grow
**	then we fail the AddServiceProvider call.
*/

extern	IDP8SPCallbackVtbl DNPLowerEdgeVtbl;

#undef DPF_MODNAME
#define DPF_MODNAME "DNPAddServiceProvider"

HRESULT DNPAddServiceProvider(PProtocolData pPData, IDP8ServiceProvider *pISP, HANDLE *pContext)
{
	int			NewSize;
	PSPD		*pNewTable = NULL;
	PSPD		pSPD=0;
	SPINITIALIZEDATA	SPInitData;
	SPGETCAPSDATA		SPCapsData;
	HRESULT		hr;

	*pContext = NULL;

	LOGPF(2, "Parameters: pPData[%p], pISP[%p], pContext[%p]", pPData, pISP, pContext);

	if(pPData->ulProtocolFlags & PFLAGS_PROTOCOL_INITIALIZED)
	{
		if (SALLOC(pSPD, SPD, 1) == NULL)
		{
			LOGPF(0, "Returning DPNERR_OUTOFMEMORY - couldn't allocate SP Descriptor");
			return DPNERR_OUTOFMEMORY;
		}

		// MAKE THE INITIALIZE CALL TO THE Service Provider...  give him our Object

		MEMSET(pSPD, 0, sizeof(SPD));				// init to zero

		pSPD->LowerEdgeVtable = &DNPLowerEdgeVtbl;	// Put Vtbl into the interface Object
		pSPD->Sign = SPD_SIGN;

		SPInitData.pIDP = (IDP8SPCallback *) pSPD;
		SPInitData.dwFlags = 0;

		LOGPF(3, "Calling SP->Initialize");
		if((hr = IDP8ServiceProvider_Initialize(pISP, &SPInitData)) != DPN_OK)
		{
			FREE(pSPD);
			LOGPF(0, "Returning hr=%x - SP->Initialize failed", hr);
			return hr;
		}

		INITCRITSEC(&pSPD->SendQLock);
		pSPD->blSendQueue.Initialize();
		pSPD->blPendingQueue.Initialize();
		pSPD->blPipeQueue.Initialize();
		pSPD->blListenList.Initialize();
		pSPD->blEPDActiveList.Initialize();
		pSPD->blMessageList.Initialize();
		

		// MAKE THE SP GET CAPS CALL TO FIND FRAMESIZE AND LINKSPEED

		SPCapsData.dwSize = sizeof(SPCapsData);
		SPCapsData.hEndpoint = INVALID_HANDLE_VALUE;
		
		LOGPF(3, "Calling SP->GetCaps");
		if((hr = IDP8ServiceProvider_GetCaps(pISP, &SPCapsData)) != DPN_OK)
		{
			LOGPF(3, "Calling SP->Close");
			IDP8ServiceProvider_Close(pISP);
			DELETECRITSEC(&pSPD->SendQLock);
			FREE(pSPD);

			LOGPF(0, "Returning hr=%x - SP->GetCaps failed", hr);
			return hr;
		}

		pSPD->uiLinkSpeed = SPCapsData.dwLocalLinkSpeed;
		pSPD->uiFrameLength = SPCapsData.dwUserFrameSize;
		pSPD->uiUserFrameLength = pSPD->uiFrameLength - DNP_MAX_HEADER_SIZE;

		//	Place new SP in table

		LOGPF(3, "Calling SP->AddRef");
		IDP8ServiceProvider_AddRef(pISP);
		pSPD->IISPIntf = pISP;
		pSPD->pPData = pPData;
		InterlockedIncrement(&pPData->lSPActiveCount);
	}
	else
	{
		LOGPF(0, "Returning DPNERR_UNINITIALIZED - DNPInitialize has not been called");
		return DPNERR_UNINITIALIZED;
	}

	*pContext = pSPD;

	return DPN_OK;
}

/*
**		Remove Service Provider
**
**			It is higher layer's responsibility to make sure that there are no pending commands
**		when this function is called,  although we can do a certain amount of cleanup ourselves.
**		For the moment will we ASSERT that everything is in fact finished up.
**
**			SPTable stuff...  Since we use the table slot as the SP identiier,  we must not compact
**		the SP table upon removal.  Therefore,  we must have a way of validating the SP index,  and
**		we may not want to re-use table slots after an SP is removed.  Since we have virtually
**		unlimited space in the table,  and SPs are generally not intended to be transitory,  its
**		probably safe to invalidate the old table slot and just keep increasing the IDs.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPRemoveServiceProvider"

HRESULT DNPRemoveServiceProvider(PProtocolData pPData,  HANDLE hSPHandle)
{
	PSPD	pSPD = NULL;
	PEPD	pEPD;
	PMSD	pMSD;
	PFMD	pFMD;
	CBilink	*pLink;
	UINT	i;


	pSPD = (PSPD) hSPHandle;

	LOGPF(2, "Parameters: pPData[%p], hSPHandle[%x]", pPData, hSPHandle);
	
	if(pSPD == NULL)
	{
		LOGPF(0, "Returning DPNERR_INVALIDOBJECT - SP Handle is NULL");
		return DPNERR_INVALIDOBJECT;
	}

	pSPD->ulSPFlags |= SPFLAGS_TERMINATING;				// Nothing new gets in...

	// First cancel any pending listen
	while(!pSPD->blListenList.IsEmpty())
	{
		pLink = pSPD->blListenList.GetNext();
		pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
		LOGPF(1, "Pending Listen found when removing SP, pMSD[%p]", pMSD);

		if (FAILED(DNPCancelCommand(pPData, pMSD)))
		{
			// Cancel failed, so we don't want to sit in this loop forever
			pLink->RemoveFromList();
		}

		// EPDs may still hold a reference to the MSD.  It will be released below.
	}

	// Next we drop any open connections.  Drop code will cancel any pending sends.
/*	Lock(&pSPD->SendQLock);

#ifdef	DEBUG
	if(!pSPD->blEPDActiveList.IsEmpty())
	{
		for(pLink = pSPD->blEPDActiveList.GetNext(); pLink != &pSPD->blEPDActiveList; pLink = pLink->GetNext())
		{
			pEPD = CONTAINING_RECORD(pLink, EPD, blActiveLinkage);
			LOGPF(1, "Shutting down with Active EPD (%p) refcount=%d", pEPD, pEPD->uiRefCnt);
		}
	}
#endif

	Unlock(&pSPD->SendQLock);
	
	// Most likely reason that EPDs are not closed is that there are sends that haven't returned from the SP.
	// This is typical when apps shutdown immediately after Disconnect completes.  Best way to deal with this 
	// is to chill for a little while and see if things don't clean themselves up...

	for(i=0; (!pSPD->blEPDActiveList.IsEmpty()) && i<1000; i++)
	{
		if(i == 999)
		{
			LOGPF(1, "EPDs still active after waiting 10 seconds");
		}
		Sleep(10);
	}
*/
	// See if we still have a Send Event pending

	Lock(&pSPD->SendQLock);
	
	if(pSPD->SendHandle != NULL)
	{
		LOGPF(1, "Shutting down with send event still pending, cancelling, pSPD=[%p]", pSPD);
		
		if(CancelMyTimer(pSPD->SendHandle, pSPD->SendHandleUnique) == DPN_OK)
		{
			pSPD->SendHandle = NULL;
			pSPD->ulSPFlags &= ~(SPFLAGS_SEND_THREAD_SCHEDULED);
		}
		else 
		{
			LOGPF(1, "Failed to cancel send event", pSPD);
		}
	}

	while(!pSPD->blSendQueue.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pSPD->blSendQueue.GetNext(), FMD, blQLinkage);
		ASSERT_FMD(pFMD);

		LOGPF(1, "Cleaning FMD off of SendQueue pSPD=%p, pFMD=%p", pSPD, pFMD);

		pFMD->blQLinkage.RemoveFromList();
		RELEASE_EPD_LOCKED(pFMD->pEPD, "UNLOCK (Releasing Leftover CMD FMD)"); // SendQLock already held
		RELEASE_FMD(pFMD);
	}

	Unlock(&pSPD->SendQLock);

	while(pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)
	{
		Sleep(10);
	}
	
	Lock(&pSPD->SendQLock);
	
	pLink = pSPD->blEPDActiveList.GetNext();
	while(pLink != &pSPD->blEPDActiveList)
	{
		BOOL fNeedToResetList = FALSE;
		pEPD = CONTAINING_RECORD(pLink, EPD, blActiveLinkage);
		pLink = pLink->GetNext();  // Set up for the next iteration
		ASSERT_EPD(pEPD);
		if(LOCK_EPD(pEPD, "LOCK (EPD LOOP)"))
		{
			if(!(pEPD->ulEPFlags & EPFLAGS_ABORT))
			{
				fNeedToResetList = TRUE;
				Unlock(&pSPD->SendQLock);
				Lock(&pEPD->EPLock);
				LOGPF(1, "Active EPD (%p) refcount=%d being forced closed", pEPD, pEPD->uiRefCnt);
				pEPD->ulEPFlags |= EPFLAGS_ABORT;
				DropLink(pEPD);				// Releases EPLock
				Lock(&pSPD->SendQLock);
			}

			RELEASE_EPD_LOCKED(pEPD, "UNLOCK (EPD LOOP)"); // SendQLock already held

			if (fNeedToResetList)
			{
				pLink = pSPD->blEPDActiveList.GetNext();
			}

		}
	}
	Unlock(&pSPD->SendQLock);

	// Sessions will not get cleaned up until any sends in SP complete (we have cancelled them if possible).
	// They will also wait to be cleared from the SendPipeline.

	for(i=0; (!pSPD->blEPDActiveList.IsEmpty()) && i<500; i++)
	{
#ifdef DPLAY_DOWORK
		if (g_pThreadPool2 != NULL)
		{
			g_pThreadPool2->PrimaryWin9xThread();
		}
#endif
		Sleep(10);
	}

	// By this time everything pending had better be gone!
	ASSERT(pSPD->blEPDActiveList.IsEmpty());
	ASSERT(pSPD->blSendQueue.IsEmpty());			// Should not be any frames on sendQ.

	Lock(&pSPD->SendQLock);
	while (!pSPD->blPendingQueue.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pSPD->blPendingQueue.GetNext(), FMD, blQLinkage);
		ASSERT_FMD(pFMD);

		pFMD->blQLinkage.RemoveFromList();

		LOGPF(1, "Cancelling Frame (%p) still on the pending queue", pFMD);
		Unlock(&pSPD->SendQLock);
		LOGPF(3, "Calling SP->CancelCommand");
		(void) IDP8ServiceProvider_CancelCommand(pSPD->IISPIntf, pFMD->SendDataBlock.hCommand, pFMD->SendDataBlock.dwCommandDescriptor);
		Lock(&pSPD->SendQLock);
	}
	Unlock(&pSPD->SendQLock);

	ASSERT(pSPD->blPendingQueue.IsEmpty());

	Lock(&pSPD->SendQLock);
	while ((pLink = pSPD->blMessageList.GetNext()) != &pSPD->blMessageList)
	{
		pMSD = CONTAINING_RECORD(pLink, MSD, blSPLinkage);
		ASSERT_MSD(pMSD);
		ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST);
		LOGPF(0, "There are un-cancelled commands remaining on the Command List, Core didn't clean up properly - pMSD[%p], Context[%x]", pMSD, pMSD->Context);
		ASSERT(0);
	}
	Unlock(&pSPD->SendQLock);

	// Now that all frames are cleared out of SP,  there should be no more End Points waiting around to close
	//
	// If there are EPDs still active,  its because customer didnt issue a Disconnect or Abort.  Since all
	// commands and sends should be done,  there should be only ONE reference on any leftover EPDs.

	LOGPF(3, "Calling SP->Close");
	IDP8ServiceProvider_Close(pSPD->IISPIntf);
	LOGPF(3, "Calling SP->Release");
	IDP8ServiceProvider_Release(pSPD->IISPIntf);

	pSPD->ulSPFlags |= SPFLAGS_TERMINATED;				// Nothing new gets in...

	DELETECRITSEC(&pSPD->SendQLock);

	FREE(pSPD);

	ASSERT(pPData->lSPActiveCount > 0);
	InterlockedDecrement(&pPData->lSPActiveCount);

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\mytimer.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    MYTIMER.H

Abstract:

	Include For
	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

#ifndef	_MYTIMER_INCLUDED_
#define	_MYTIMER_INCLUDED_

typedef void CALLBACK MYTIMERCALLBACK (PVOID uID, UINT uMsg, PVOID dwUser);

typedef enum _TimerState {
	NotInUse,
	WaitingForTimeout,
	QueuedForThread,
	InCallBack,
	End
} eTimerState;

typedef struct _MyTimer {
	CBilink	Bilink;
	eTimerState TimerState;
	DWORD	TimeOut;
	PVOID   Context;
	MYTIMERCALLBACK *CallBack;
	DWORD   Unique;
} MYTIMER, *PMYTIMER;

VOID 	SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, PVOID UserContext, PVOID *pHandle, PUINT pUnique);
HRESULT InitTimerWorkaround();
VOID 	FiniTimerWorkaround();
HRESULT CancelMyTimer(PVOID pTimer, DWORD Unique);
VOID	ScheduleTimerThread(MYTIMERCALLBACK, PVOID, PVOID *, PUINT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\internal.h ===
/*
**		Direct Network Protocol
**
**		This file contains internal prototypes and global definitions.
*/


#ifndef	_DNINTERNAL_INCLUDED_
#define	_DNINTERNAL_INCLUDED_

//	Global Constants
#define		DNET_VERSION_NUMBER				0x00010000

#define		DELAYED_ACK_TIMEOUT				100			// Delay before sending dedicated ACK packet
#define		SHORT_DELAYED_ACK_TIMEOUT		20			// Delay before sending dedicated NACK packet
#define		DELAYED_SEND_TIMEOUT			40			// Delay before sending dedicated SEND_INFO packet

#define		CONNECT_DEFAULT_TIMEOUT		(200)		// At .1 we saw too many retries, users can set in SetCaps
#define		CONNECT_DEFAULT_RETRIES			8			// Lowering this from 10 to accomodate timeout change, users can set in SetCaps

#define		STANDARD_LONG_TIMEOUT_VALUE		30000
#define		DEFAULT_KEEPALIVE_INTERVAL		60000
#define		ENDPOINT_BACKGROUND_INTERVAL	STANDARD_LONG_TIMEOUT_VALUE		// this is really what its for...

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_PROTOCOL

typedef	void CALLBACK LPCB(UINT, UINT, DWORD, DWORD, DWORD);

//	Global Variable definitions

extern LPFPOOL	ChkPtPool;
extern LPFPOOL	EPDPool;
extern LPFPOOL	MSDPool;
extern LPFPOOL	FMDPool;
extern LPFPOOL	RCDPool;
extern LPFPOOL	BufPool;
extern LPFPOOL	MedBufPool;
extern LPFPOOL	BigBufPool;

//	Internal function prototypes

VOID			AbortSendsOnConnection(PEPD);
ULONG WINAPI 	BackgroundThread(PVOID);
BOOL			Buf_Allocate(PVOID);
VOID			Buf_Get(PVOID);
VOID			Buf_GetMed(PVOID);
VOID			Buf_GetBig(PVOID);
HRESULT			DoCancel(PMSD, HRESULT);
VOID 			CompleteConnect(PMSD, PSPD, PEPD, HRESULT);
VOID 			CompleteDatagramSend(PSPD, PMSD, HRESULT);
VOID			CompleteReliableSend(PSPD, PMSD, HRESULT);
VOID			CompleteSPConnect(PMSD, PSPD, HRESULT);
VOID CALLBACK	ConnectRetryTimeout(PVOID, UINT, PVOID);
VOID CALLBACK	DelayedAckTimeout(PVOID, UINT, PVOID);
VOID			DisconnectConnection(PEPD);
VOID			DropLink(PEPD);
VOID			ReleaseEndPoint(PEPD, BOOL);
PMSD			BuildDisconnectFrame(PEPD);
VOID			EndPointDroppedFrame(PEPD, DWORD);
VOID CALLBACK	EndPointBackgroundProcess(PVOID, UINT, PVOID);
VOID			EnqueueMessage(PMSD, PEPD);
BOOL			EPD_Allocate(PVOID);
VOID			EPD_Free(PVOID);
VOID			EPD_Get(PVOID);
VOID			EPD_Release(PVOID);
VOID 			FlushCheckPoints(PEPD);
BOOL			FMD_Allocate(PVOID);
VOID			FMD_Free(PVOID);
VOID			FMD_Get(PVOID);
VOID			FMD_Release(PVOID);
VOID 			InitLinkParameters(PEPD, UINT, UINT, UINT);
VOID			KillConnection(PEPD);
PCHKPT			LookupCheckPoint(PEPD, BYTE);
BOOL			MSD_Allocate(PVOID);
VOID			MSD_Free(PVOID);
VOID			MSD_Get(PVOID);
VOID			MSD_Release(PVOID);
PEPD			NewEndPoint(PSPD, HANDLE);
VOID			PerformCheckpoint(PEPD);
BOOL			RCD_Allocate(PVOID);
VOID			RCD_Free(PVOID);
VOID			RCD_Get(PVOID);
VOID			RCD_Release(PVOID);
VOID			ReceiveComplete(PEPD);
VOID			RejectConnection(PEPD);
VOID CALLBACK	RetryTimeout(PVOID, UINT, PVOID);
VOID CALLBACK	ScheduledSend(PVOID, UINT, PVOID);
VOID			SendAckFrame(PEPD, BOOL);
HRESULT			SendCommandFrame(PEPD, BYTE, BYTE);
VOID			SendDisconnectedFrame(PEPD);
ULONG WINAPI 	SendThread(PVOID);
VOID			ServiceCmdTraffic(PSPD);
VOID			ServiceEPD(PSPD, PEPD);
VOID CALLBACK	TimeoutConnect(PVOID, UINT, PVOID);
VOID CALLBACK	TimeoutSend(PVOID, UINT, PVOID);
VOID 			UpdateEndPoint(PEPD, UINT, UINT, UINT, DWORD);
VOID			UpdateXmitState(PEPD, BYTE, PSACKFRAME, ULONG, ULONG, DWORD);

#ifdef	DEBUG
VOID			KeepConnectStats(PEPD);
#endif

//	Internal Macro definitions

#define	MALLOC			DNMalloc
#define	FREE			DNFree
#define MEMCPY			memcpy
#define	MEMSET			memset
#define	GETTIMESTAMP()	timeGetTime()

#define	INITCRITSEC(P)		DNInitializeCriticalSection(P);DebugSetCriticalSectionRecursionCount(P,0)
#define	DELETECRITSEC(P)	DNDeleteCriticalSection(P)

#define	Lock(P)			DNEnterCriticalSection(P)
#define	Unlock(P)		DNLeaveCriticalSection(P)

#define	ASSERT_SPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == SPD_SIGN)
#define	ASSERT_EPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == EPD_SIGN)
#define	ASSERT_MSD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == MSD_SIGN)
#define	ASSERT_FMD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == FMD_SIGN)
#define	ASSERT_RCD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == RCD_SIGN)

#define	INTER_INC(PTR)	(InterlockedIncrement(reinterpret_cast<LONG*>( &((PTR)->uiRefCnt) )))
#define	INTER_DEC(PTR)	(InterlockedDecrement(reinterpret_cast<LONG*>( &((PTR)->uiRefCnt) )))

#ifdef DEBUG

BOOL	LockEPD(PEPD, PCHAR);
VOID	ReleaseEPD(PEPD, PCHAR);
VOID	ReleaseEPDLocked(PEPD, PCHAR);
VOID	LockMSD(PMSD, PCHAR);
VOID	ReleaseMSD(PMSD, PCHAR);
VOID	DecrementMSD(PMSD, PCHAR);

#define	LOCK_EPD(a, b)				LockEPD(a, b)
#define	RELEASE_EPD(a, b)			ReleaseEPD(a, b)
#define	RELEASE_EPD_LOCKED(a, b)	ReleaseEPDLocked(a, b)
#define	LOCK_MSD(a, b)				LockMSD(a, b)
#define RELEASE_MSD(a, b)			ReleaseMSD(a, b)
#define DECREMENT_MSD(a, b)			DecrementMSD(a, b)

#else

BOOL	LockEPD(PEPD);
VOID	ReleaseEPD(PEPD);
VOID	ReleaseEPDLocked(PEPD);
VOID	LockMSD(PMSD);
VOID	ReleaseMSD(PMSD);
VOID	DecrementMSD(PMSD);

#define	LOCK_EPD(a, b)				LockEPD(a)
#define	RELEASE_EPD(a, b)			ReleaseEPD(a)
#define	RELEASE_EPD_LOCKED(a, b)	ReleaseEPDLocked(a)
#define	LOCK_MSD(a, b)				LockMSD(a)
#define RELEASE_MSD(a, b)			ReleaseMSD(a)
#define DECREMENT_MSD(a, b)			DecrementMSD(a)

#endif

#define	LOCK_FMD(PTR)		(INTER_INC(PTR))
#define	RELEASE_FMD(PTR)	ASSERT((PTR)->uiRefCnt > 0); if( INTER_DEC(PTR) == 0) { FMDPool->Release(FMDPool, (PTR)); }

#define	LOCK_RCD(PTR)		(INTER_INC(PTR))
#define	RELEASE_RCD(PTR)	ASSERT((PTR)->uiRefCnt > 0); if( INTER_DEC(PTR) == 0) { RCDPool->Release(RCDPool, (PTR)); }

#define		RELEASE_SP_BUFFER(PTR)	if(PTR != NULL){ (PTR)->pNext = pRcvBuff; pRcvBuff = (PTR); }

#ifndef	CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (UINT_PTR)(&((type *)0)->field)))
#endif

#define	RIGHT_SHIFT_64(HIGH_MASK, LOW_MASK) { ((LOW_MASK) >>= 1); if((HIGH_MASK) & 1){ (LOW_MASK) |= 0x80000000; } ((HIGH_MASK) >>= 1); }

#define	MAX(A, B)		( (A) > (B) ?  (A) : (B) )
#define	MIN(A, B)		( (A) < (B) ?  (A) : (B) )
#define	ABS(A)			( (A) < 0 ? -(A) : (A) )

//	CONVERT TO AND FROM 16.16 FIXED POINT REPRESENTATION

#define	TO_FP(X)		((X) << 16)
#define	FP_INT(X)		((X) >> 16)


#define	SALLOC(PTR, TYPE, NUMBER)	((PTR) = (TYPE *) MALLOC(sizeof(TYPE) * (NUMBER)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\sources.inc ===
!include ..\..\sources.inc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnproti.h
PRECOMPILED_PCH=dnproti.pch
PRECOMPILED_OBJ=dnproti.obj

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DASSUME_VALID_PARAMETERS
!else
C_DEFINES=$(C_DEFINES) -DDEBUG
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Od
!endif

SOURCES= ..\backend.cpp \
	 ..\command.cpp \
	 ..\connectp.cpp \
	 ..\endpt.cpp \
         ..\Enum.cpp \
	 ..\initialize.cpp \
         ..\lower_mn.cpp \
 	 ..\receivep.cpp \
	 ..\send.cpp \
	 ..\timer.cpp

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\send.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Send.c
 *  Content:	This file contains code which implements the front end of the
 *				SendData API.  It also contains code to Get and Release Message
 *				Descriptors (MSD) with the FPM package.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *
 ****************************************************************************/


/*
**		Direct Net Protocol  --  Send Data
**
**		Data is always address to a PlayerID,  which is represented internally
**	by an End Point Descriptor (EPD).
**
**		Data can be sent reliably or unreliably using the same API with the appropriate
**	class of service flag set.
**
**		Sends are never delivered directly to the SP because there will always be
**	a possibility that the thread might block.  So to guarentee immediate return
**	we will always queue the packet and submit it on our dedicated sending thread.
*/

#include "dnproti.h"

#if (DN_SENDFLAGS_SET_USER_FLAG - PACKET_COMMAND_USER_1)
This will not compile.  Flags must be equal
#endif
#if (DN_SENDFLAGS_SET_USER_FLAG_TWO - PACKET_COMMAND_USER_2)
This will not compile.  Flags must be equal
#endif


//	locals

VOID	SendDatagram(PMSD, PEPD);
VOID	SendReliable(PMSD, PEPD);

#undef		DPF_MODNAME
#define		DPF_MODNAME		"PROTOCOL"

/*
**		Send Data
**
**		This routine will initiate a data transfer with the specified endpoint.  It will
**	normally start the operation and then return immediately,  returning a handle used to
**	indicate completion of the operation at a later time.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPSendData"

HRESULT
DNPSendData(	PProtocolData pPData,
				HANDLE hDestination,
				UINT uiBufferCount,
				PBUFFERDESC pBufferDesc,
				UINT uiPriority,
				UINT uiTimeout,
				ULONG ulFlags,
				PVOID pvContext,				// User context returned upon completion
				PHANDLE phHandle)				// Returned completion handle
{
	PEPD 			pEPD;
	PMSD			pMSD;
	PFMD			pFMD;
	UINT			i;
	UINT			Length = 0;
	PSPD			pSPD;
	ULONG			ulFrameFlags;
	BYTE			bCommand;
	//  Following variables are used for mapping buffers to frames
	PBUFFERDESC		FromBuffer, ToBuffer;
	UINT			TotalRemain, FromRemain, ToRemain, size;
	PCHAR			FromPtr;
#ifdef	DEBUG
	INT				FromBufferCount;
#endif
	// End of variables for mapping frames

	LOGPF(6, "Parameters: pPData[%p], hDestination[%x], uiBufferCount[%x], pBufferDesc[%p], uiPriority[%x], uiTimeout[%x], ulFlags[%x], pvContext[%p], phHandle[%p]", pPData, hDestination, uiBufferCount, pBufferDesc, uiPriority, uiTimeout, ulFlags, pvContext, phHandle);

	//* Unified Send Processing -- Do this for all classes of service
	
	// BUGBUG - Find out how many descriptors I might ever need worst case
	
	// Count the bytes in all user buffers
	for(i=0; i < uiBufferCount; i++)
	{
		Length += pBufferDesc[i].dwBufferSize;
	}

	pEPD = (PEPD) hDestination;
	
	ASSERT(pEPD != NULL);	
	ASSERT_EPD(pEPD);
	
	// Bump reference count on this baby
	if(!LOCK_EPD(pEPD, "LOCK (SEND)"))
	{
		LOGPF(0, "(%p) Rejecting Send on unreferenced EPD, returning DPNERR_INVALIDENDPOINT", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	if( ((pEPD->ulEPFlags & (EPFLAGS_END_POINT_IN_USE | EPFLAGS_CONNECTED)) !=
														(EPFLAGS_END_POINT_IN_USE | EPFLAGS_CONNECTED))
														|| ((pEPD->ulEPFlags & EPFLAGS_TERMINATING) != 0)) 
	{
		RELEASE_EPD(pEPD, "UNLOCK (invalid EP)"); // SendQLock not already held
		LOGPF(0, "(%p) Rejecting Send on invalid EPD, returning DPNERR_INVALIDENDPOINT", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	pSPD = pEPD->pSPD;
	
	ASSERT(pSPD != NULL);
	
	// Allocate and fill out a Message Descriptor for this operation
	if( (pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		RELEASE_EPD(pEPD, "UNLOCK (no memory)"); // SendQLock not already held
		LOGPF(0, "Failed to allocate MSD, returning DPNERR_OUTOFMEMORY");
		return DPNERR_OUTOFMEMORY;
	}

	// Copy SendData parameters into the Message Descriptor
	pMSD->pSPD = pSPD;
	pMSD->pEPD = pEPD;
	pMSD->ulSendFlags = ulFlags;					// Store the actual flags passed into the API call
	pMSD->Context = pvContext;
	pMSD->iMsgLength = Length;
	pMSD->tSubmitTime = GETTIMESTAMP();

	pMSD->uiFrameCount = (Length + pEPD->uiUserFrameLength - 1) / pEPD->uiUserFrameLength; // round up

	if(ulFlags & DN_SENDFLAGS_RELIABLE)
	{
		pMSD->CommandID = COMMAND_ID_SEND_RELIABLE;
		ulFrameFlags = FFLAGS_RELIABLE;
		bCommand = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE;
	}
	else 
	{
		pMSD->CommandID = COMMAND_ID_SEND_DATAGRAM;
		ulFrameFlags = 0;
		bCommand = PACKET_COMMAND_DATA;
	}

	if(!(ulFlags & DN_SENDFLAGS_NON_SEQUENTIAL))
	{
		ulFrameFlags |= FFLAGS_SEQUENTIAL;
		bCommand |= PACKET_COMMAND_SEQUENTIAL;
	}

	bCommand |= (ulFlags & (DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO));	// preserve user flag values

	// Map user buffers directly into frame's buffer descriptors
	//
	//	We will loop through each required frame,  filling out buffer descriptors
	// from those provided as parameters.  Frames may span user buffers or vica-versa...

	TotalRemain = Length;
#ifdef	DEBUG
	FromBufferCount = uiBufferCount - 1;				// sanity check
#endif
	FromBuffer = pBufferDesc;
	FromRemain = FromBuffer->dwBufferSize;
	FromPtr = reinterpret_cast<PCHAR>( (FromBuffer++)->pBufferData );				// note post-increment to next descriptor
	
	for(i=0; i<pMSD->uiFrameCount; i++)
	{
		ASSERT(TotalRemain > 0);						// BUGBUG: Double check our math
		
		// Grab a new frame
		if( (pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
		{	
			// FAILED - Return resources and fail the send
			Lock(&pMSD->CommandLock);
			RELEASE_MSD(pMSD, "Release On FMD Get Failed");	// MSD Release operation will also free frames
			LOGPF(0, "Failed to allocate FMD, returning DPNERR_OUTOFMEMORY");
			return DPNERR_OUTOFMEMORY;
		}

		pFMD->pMSD = pMSD;								// Link frame back to message
		pFMD->pEPD = pEPD;
		pFMD->CommandID = pMSD->CommandID;
		pFMD->bPacketFlags = bCommand;					// save packet flags for each frame
		pFMD->blMSDLinkage.InsertBefore( &pMSD->blFrameList);
		ToRemain = pEPD->uiUserFrameLength;
		ToBuffer = pFMD->rgBufferList;					// Address first user buffer desc
		//FrameDescCount = 0;							// Only necessary if we allow >12 user buffers
		
		pFMD->uiFrameLength = pEPD->uiUserFrameLength;	// Assume we fill frame- only need to change size of last one
		pFMD->ulFFlags = ulFrameFlags;					// Set control flags for frame (Sequential, Reliable)

		// Until this frame is full
		while((ToRemain != 0) && (TotalRemain != 0))
		{	
 			size = MIN(FromRemain, ToRemain);			// choose smaller of framesize or buffersize
			FromRemain -= size;
			ToRemain -= size;
			TotalRemain -= size;

			ToBuffer->dwBufferSize = size;				// Fill in the next frame descriptor
			(ToBuffer++)->pBufferData = reinterpret_cast<BYTE*>( FromPtr );		// note post-increment
			pFMD->SendDataBlock.dwBufferCount++;		// Count buffers as we add them
			//FrameDescCount++;

			// Get next user buffer
			if((FromRemain == 0) && (TotalRemain != 0))
			{
				FromRemain = FromBuffer->dwBufferSize;
				FromPtr = reinterpret_cast<PCHAR>( (FromBuffer++)->pBufferData );	// note post-increment to next descriptor
#ifdef	DEBUG		
				FromBufferCount--;						// Keep this code honest...
				ASSERT(FromBufferCount >= 0);
#endif
			}
			else {										// Either filled this frame,  or have mapped the whole send
				FromPtr += size;						// advance ptr to start next frame (if any)
				pFMD->uiFrameLength = pEPD->uiUserFrameLength - ToRemain;		// wont be full at end of message
			}
		}	// While (frame not full)
	}  // For (each frame in message)

	pFMD->ulFFlags |= FFLAGS_END_OF_MESSAGE;			// Mark last frame with EOM
	pFMD->bPacketFlags |= PACKET_COMMAND_END_MSG;		// Set EOM in frame
	
#ifdef	DEBUG
	ASSERT(FromBufferCount == 0);
#endif
	ASSERT(TotalRemain == 0);

	// hang the message off a global command queue for timeout and cancel tracking

	Lock(&pMSD->pSPD->SendQLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pMSD->pSPD->SendQLock);

	*phHandle = pMSD;									// We will use the MSD as our handle.

	//	To implement priority-based sending I have unified the Datagram and Reliable traffic into a single set of
	//  three priority based queues.  Therefore we will insert new messages in the back of the appropriate queue
	//	regardless of their reliability.


	Lock(&pEPD->EPLock);												// LOCK ALL SEND QUEUES WITH SINGLE CRIT SEC
	
	if(uiTimeout != 0)
	{
		LOCK_MSD(pMSD, "Send Timeout Timer");							// Add reference for timer
		LOGPF(7, "(%p) Setting Timeout Send Timer", pEPD);
		SetMyTimer(uiTimeout, 100, TimeoutSend, pMSD, &pMSD->TimeoutTimer, &pMSD->TimeoutTimerUnique);
	}
	
	EnqueueMessage(pMSD, pEPD);
	Unlock(&pEPD->EPLock);

	return DPNERR_PENDING;
}

/*
**		Enqueue Message
**
**		Add complete MSD to the appropriate send queue,  and kick start sending process if necessary.
**
**		** This routine is called and returns with EPD->EPLOCK held **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EnqueueMessage"

VOID
EnqueueMessage(PMSD pMSD, PEPD pEPD)
{
	//	Place Message in appriopriate priority queue.  Datagrams get enqueued twice (!).  They get put in the Master
	// queue where they are processed FIFO with all messages of the same priority.  Datagrams also get placed in a priority
	// specific queue of only datagrams which is drawn from when the reliable stream is blocked.
	
	if(pMSD->ulSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
	{
		LOGPF(7, "(%p) Placing message on High Priority Q", pEPD);
		pMSD->blQLinkage.InsertBefore( &pEPD->blHighPriSendQ);
		pEPD->uiMsgSentHigh++;
	}
	else if (pMSD->ulSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
	{
		LOGPF(7, "(%p) Placing message on Low Priority Q", pEPD);
		pMSD->blQLinkage.InsertBefore( &pEPD->blLowPriSendQ);
		pEPD->uiMsgSentLow++;
	}
	else
	{
		LOGPF(7, "(%p) Placing message on Normal Priority Q", pEPD);
		pMSD->blQLinkage.InsertBefore( &pEPD->blNormPriSendQ);
		pEPD->uiMsgSentNorm++;
	}

	pMSD->ulMsgFlags2 |= MFLAGS_TWO_ENQUEUED;

	pEPD->uiQueuedMessageCount++;
	pEPD->ulEPFlags |= EPFLAGS_SDATA_READY;							// Note that there is *something* in one or more queues

	// If the session is not currently in the send pipeline then we will want to insert it here as long as the
	// the stream is not blocked.

	if(((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0) && (pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED))
	{
		ASSERT(pEPD->SendTimer == NULL);
		LOGPF(7, "(%p) Send On Idle Link -- Returning to pipeline", pEPD);
	
		pEPD->uiTotalIdleTime += ( GETTIMESTAMP() - pEPD->tStartIdle );

#ifdef	DEBUG
		ASSERT(pEPD->tStartIdle != -1);
		pEPD->tStartIdle = -1;
#endif

		pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
		LOCK_EPD(pEPD, "LOCK (pipeline)");								// Add Ref for pipeline Q

		// We dont call send on users thread,  but we dont have a dedicated send thread either. Use a thread
		// from the timer-worker pool to submit the sends to SP

		LOGPF(7, "(%p) Scheduling Timer Thread", pEPD);
		ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "TimeoutSend"

VOID CALLBACK
TimeoutSend(PVOID uID, UINT uMsg, PVOID dwUser)
{
	PMSD	pMSD = (PMSD) dwUser;
	PEPD	pEPD = pMSD->pEPD;
	ULONG	Flags = pMSD->ulSendFlags;

	LOGPF(7, "Timeout Send pMSD=%p,  RefCnt=%d", pMSD, pMSD->uiRefCnt);

	Lock(&pMSD->CommandLock);
	
	pMSD->TimeoutTimer = NULL;

	if((pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_TIMEDOUT)) || (pMSD->ulMsgFlags2 & MFLAGS_TWO_COMPLETE))
	{
		LOGPF(7, "Timed out send has completed pMSD=%p", pMSD);
		RELEASE_MSD(pMSD, "Send Timout Timer");
		return;
	}

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_TIMEDOUT;

	DECREMENT_MSD(pMSD, "Send Timout Timer");							// Release Ref for timer
	
	LOGPF(7, "Calling DoCancel to cancel pMSD=%p", pMSD);

	if(DoCancel(pMSD, DPNERR_TIMEDOUT) == DPN_OK)
	{
		if(Flags & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pEPD->uiMsgTOHigh++;
		}
		else if(Flags & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pEPD->uiMsgTOLow++;
		}
		else
		{
			pEPD->uiMsgTONorm++;
		}
	}
	else
	{
		LOGPF(7, "DoCancel did not succeed pMSD=%p", pMSD);
	}
}


/***********************
========SPACER==========
************************/

/*
**		MSD Pool support routines
**
**		These are the functions called by Fixed Pool Manager as it handles MSDs.
*/

#define	pELEMENT		((PMSD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Allocate"

BOOL MSD_Allocate(PVOID pElement)
{
	ZeroMemory(pELEMENT, sizeof(messagedesc));

	INITCRITSEC(&pELEMENT->CommandLock);
	
	pELEMENT->blFrameList.Initialize();
	pELEMENT->blQLinkage.Initialize();
	pELEMENT->blSPLinkage.Initialize();
	pELEMENT->Sign = MSD_SIGN;
	pELEMENT->uiRefCnt = -1;

	return TRUE;
}

//	Get is called each time an MSD is used


#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Get"

VOID MSD_Get(PVOID pElement)
{
	ASSERT(pELEMENT->uiRefCnt == -1);
	
	LOGPF(5, "CREATING MSD %p", pELEMENT);

	pELEMENT->CommandID = COMMAND_ID_NONE;
	pELEMENT->ulMsgFlags1 = MFLAGS_ONE_IN_USE;	// Dont need InUse flag since we have RefCnt
	pELEMENT->uiRefCnt = 0;
}

/*
**	MSD Release
**
**		This is called with the CommandLock held.  The Lock should not be
**	freed until the INUSE flag is cleared.  This is to synchronize with
**	last minute Cancel threads waiting on lock.
**
**		When freeing a message desc we will free all frame descriptors
**	attached to it first.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Release"

VOID MSD_Release(PVOID pElement)
{
	CBilink	*pLink;
	PFMD	pFMD;

	ASSERT_MSD(pELEMENT);

	LOGPF(5, "RELEASING MSD %p", pELEMENT);

	ASSERT(pELEMENT->ulMsgFlags1 & MFLAGS_ONE_IN_USE);
	ASSERT(pELEMENT->uiRefCnt == -1);
	ASSERT((pELEMENT->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)==0);

	while( (pLink = pELEMENT->blFrameList.GetNext()) != &pELEMENT->blFrameList){
		pLink->RemoveFromList();							// remove from bilink

		pFMD = CONTAINING_RECORD(pLink, FMD, blMSDLinkage);
		RELEASE_FMD(pFMD);								// If this is still submitted it will be referenced and wont be released here.
	}
	pELEMENT->ulMsgFlags1 = 0;
	pELEMENT->ulMsgFlags2 = 0;
	Unlock(&pELEMENT->CommandLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Free"

VOID MSD_Free(PVOID pElement)
{
	DELETECRITSEC(&pELEMENT->CommandLock);
}

#undef	pELEMENT

/*
**		FMD Pool support routines
*/

#define	pELEMENT		((PFMD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Allocate"

BOOL FMD_Allocate(PVOID pElement)
{
	pELEMENT->Sign = FMD_SIGN;
	pELEMENT->ulFFlags = 0;
	pELEMENT->uiRefCnt = 0;
	
	return TRUE;
}

//	Get is called each time an MSD is used
//
//	Probably dont need to do this everytime,  but some random SP might
//	munch the parameters someday and that could be bad if I dont...

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Get"

VOID FMD_Get(PVOID pElement)
{
	LOGPF(5, "CREATING FMD %p", pELEMENT);

	pELEMENT->CommandID = 0;
	pELEMENT->lpImmediatePointer = (LPVOID) pELEMENT->ImmediateData;
	pELEMENT->SendDataBlock.pBuffers = (PBUFFERDESC) &pELEMENT->uiImmediateLength;
	pELEMENT->SendDataBlock.dwBufferCount = 1;				// always count one buffer for immediate data
	pELEMENT->SendDataBlock.dwFlags = 0;
	pELEMENT->SendDataBlock.pvContext = pElement;
	pELEMENT->SendDataBlock.hCommand = 0;
	pELEMENT->ulFFlags = FFLAGS_IN_USE;
	pELEMENT->bSubmitted = FALSE;
	
	ASSERT(pELEMENT->uiRefCnt == 0);
	pELEMENT->uiRefCnt = 1;						// Assign first reference
}

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Release"

VOID FMD_Release(PVOID pElement)
{
	LOGPF(5, "RELEASING FMD %p", pELEMENT);

	ASSERT_FMD(pELEMENT);
	ASSERT(pELEMENT->uiRefCnt == 0);
	ASSERT(pELEMENT->bSubmitted == FALSE);
	pELEMENT->ulFFlags &= ~FFLAGS_IN_USE;	
	pELEMENT->pMSD = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Free"

VOID FMD_Free(PVOID pElement)
{
}

#undef	pELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\timer.cpp ===
/*++

Copyright (c) 1996,2000  Microsoft Corporation

Module Name:

    TIMER.C

Abstract:

	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   	Author  Description
   ======  	======  ============================================================
   6/04/98 	aarono  Original
   10/13/99	a-evsch	Adding support for standard long-timers
   8/16/00  RichGr  Removed InitCount global as InitTimerWorkaround() is now guaranteed
                    to be called only once, triggered by DllMain.
   8/20/00  aarono  More intelligent multiproc timer management for dnet
   9/30/00  RichGr  Bug #46064: Track timer thread handles in an array for clean shutdown. 

--*/

/*
**		Quick Insert Optimizers
**
**		In a very high user system there are going to be many timers being set and cancelled.  Timer
**	cancels and timer fires are already optimized,  but as the timer list grows the SetTimer operations
**	become higher and higher overhead as we walk through a longer and longer chain for our insertion-sort.
**
**		Front First for Short Timers
**
**		When very short timers are being set we can assume that they will insert towards the front of the
**	timer list.  So it would be smarter to walk the list front-to-back instead of the back-to-front default
**	behavior which correctly assumes that most new timers will be firing after timers already set.  If the
**	the Timeout value of a new timer is near the current timer resolution then we will try the front-first
**	insertion-sort instead.  This will hopefully reduce short timer sets to fairly quick operations
**
**		Standard Long Timers
**
**		Standard means that they will all have the same duration.  If we keep a seperate chain
**	for all these timers with a constant duration they can be trivally inserted at the end of the chain.  This
**	will be used for the periodic background checks run on each endpoint every couple of seconds.
**
**		Quick Set Timer Array
**
**		The really big optimization is an array of timeout lists, with a current pointer.  Periodic timeout
**	will walk the array a number of slots corresponding to the interval since it was last run.  All events
**	on those lists will be scheduled.  This turns all SetTimer ops into constant time operations
**	no matter how many timers are running in the system.  This can be used for all timers within the
**	range of the array (resolution X number of slots) which may be 4ms * 256 slots or a 1K ms range.  We expect
**	most link timers to fall into this range, although it can be doubled or quadrupled quite trivially.
**
**	I plan to run QST algorithm on any server platform,  which will replace Front First Short Timers for
**	obvious reasons.  Client or Peer servers will use FFS instead.  Both configs will benefit from StdLTs
**	unless the range of the QST array grows to encompass the standard length timeout.
*/

#include "dnproti.h"


#define DEFAULT_TIME_RESOLUTION 20	/* ms */
#ifndef DPLAY_DOWORK
#define MIN_TIMER_THREADS		1
#define MAX_TIMER_THREADS_PER_PROCESSOR 8
#endif

VOID QueueTimeout(PMYTIMER pTimer);
#ifndef DPLAY_DOWORK
DWORD WINAPI TimerWorkerThread(LPVOID foo);
#endif


// Timer Resolution adjustments;
DWORD dwOldPeriod=DEFAULT_TIME_RESOLUTION;
DWORD dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
DWORD dwPeriodInUse=DEFAULT_TIME_RESOLUTION;

//	EJS - There are now two timer lists.  The original random-access timer list (MyTimerList) and the
//  new StdTimerList.  On each PeriodicTimeout both lists will now be checked for timer expirations.

CBilink MyTimerList;			// Random Timer List
CBilink StdTimerList;			// Standard Length Timer List
CRITICAL_SECTION MyTimerListLock;							// One lock will guard both lists

LPFPOOL pTimerPool=NULL;
#ifndef DPLAY_DOWORK
DWORD uWorkaroundTimerID;
#endif

LONG g_Running = 0;		// is the timer system up and running

DWORD Unique=0;


CRITICAL_SECTION ThreadListLock;		// locks ALL this stuff.

CBilink ThreadList;	// ThreadPool grabs work from here.

DWORD nThreads=0;		// number of running threads.
DWORD ActiveReq=0;		// number of requests being processed.
DWORD PeakReqs=0;
DWORD bShutDown=FALSE;
#ifndef DPLAY_DOWORK
DWORD KillCount=0;
#endif
DWORD ExtraSignals=0;
#ifdef	DEBUG
DWORD MaxPeakReqs = 0;
#endif

#ifndef DPLAY_DOWORK
HANDLE hWorkToDoSem;

#endif

PVOID uAdjustResTimer=0;
UINT AdjustResUnique=0;

PVOID uAdjustThreadsTimer=0;
UINT AdjustThreadsUnique=0;

#ifndef DPLAY_DOWORK
DWORD   MAX_TIMER_THREADS = MAX_TIMER_THREADS_PER_PROCESSOR;

//  9/30/00(RichGr) - Bug #46064: Track thread handles in an array so we have an accurate count of how many need
//     to be closed at shutdown.
HANDLE *g_phTimerThreadHandles = NULL;

#endif

/***
*
*	QUICK-START TIMER SUPPORT
*
***/

#define	QST_SLOTCOUNT		2048					// 2048 seperate timer queues
#define	QST_GRANULARITY		4						// 4 ms clock granularity * 2048 slots == 8192 ms max timeout value
#define	QST_MAX_TIMEOUT		(QST_SLOTCOUNT * QST_GRANULARITY)
#define	QST_MOD_MASK		(QST_SLOTCOUNT - 1)		// Calculate a quick modulo operation for wrapping around the array

#if	( (QST_GRANULARITY - 1) & QST_GRANULARITY )
This Will Not Compile -- ASSERT that QST_GRANULARITY is power of 2!
#endif
#if	( (QST_SLOTCOUNT - 1) & QST_SLOTCOUNT )
This Will Not Compile -- ASSERT that QST_SLOTCOUNT is power of 2!
#endif

#define	QST

#ifdef	QST
CBilink	*rgQSTimerArray = NULL;

UINT	QST_CurrentIndex;				// Last array slot that was executed
DWORD	QST_LastRunTime;				// Tick count when QSTs last ran
#endif

/*
*	END OF QST SUPPORT
*/


#undef	Lock
#undef	Unlock
#define	Lock	EnterCriticalSection
#define	Unlock	LeaveCriticalSection

/*
**		Periodic Timer
**
**		This runs every RESOLUTION millisecs and checks for expired timers. It must check two lists
**	for expired timers,  plus a variable number of slots in the QST array.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "PeriodicTimer"

#ifndef DPLAY_DOWORK
void CALLBACK PeriodicTimer (UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
#else
void PeriodicTimer (void)
#endif
{
	DWORD  		time;
	PMYTIMER  	pTimerWalker;
	CBilink 		*pBilink;
	DWORD 		dwReleaseCount=0;
#ifdef	QST
	INT 		interval;
	DWORD		slot_count;
#endif

	if(g_Running == FALSE)
		return;
		
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	if(g_Running == FALSE){
		Unlock(&ThreadListLock);
		Unlock(&MyTimerListLock);
		return;
	}
		
	time=timeGetTime()+(dwCurrentPeriod/2);

	//   service QST lists:  Calculate how many array slots have expired and
	// service any timers in those slots.

#ifdef	QST

	interval = (INT) (time - QST_LastRunTime);

	if( (interval) > 0){

		slot_count = ((DWORD) interval) / QST_GRANULARITY;
		slot_count = MIN(slot_count, QST_SLOTCOUNT);

		if(slot_count < QST_SLOTCOUNT){
			QST_LastRunTime += (slot_count * QST_GRANULARITY);
		}
		else{
			// If there was a LONG delay in scheduling this, (longer then the range of the whole array)
			// then we must complete everything that is on the array and then re-synchronize the times

			slot_count = QST_SLOTCOUNT;
			QST_LastRunTime = time;
		}

		while(slot_count--){

			while( (pBilink = rgQSTimerArray[QST_CurrentIndex].GetNext()) != &rgQSTimerArray[QST_CurrentIndex] ){
				pTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
				pBilink->RemoveFromList();

				pTimerWalker->Bilink.InsertBefore( &ThreadList);
				pTimerWalker->TimerState=QueuedForThread;
				dwReleaseCount++;
			}
			QST_CurrentIndex = (QST_CurrentIndex + 1) & QST_MOD_MASK;
		}

	}
#endif

	//	Walk the sorted timer list.  Expired timers will all be at the front of the
	// list so we can stop checking as soon as we find any un-expired timer.

	pBilink=MyTimerList.GetNext();

	while(pBilink!=&MyTimerList){

		pTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink=pBilink->GetNext();

		if(((INT)(time-pTimerWalker->TimeOut) > 0)){
			pTimerWalker->Bilink.RemoveFromList();
			pTimerWalker->Bilink.InsertBefore( &ThreadList);
			pTimerWalker->TimerState=QueuedForThread;
			dwReleaseCount++;
		} else {
			break;
		}

	}

	//  Next walk the Standard Length list.   Same rules apply

	pBilink=StdTimerList.GetNext();
	while(pBilink != &StdTimerList){
		pTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink=pBilink->GetNext();

		if(((INT)(time-pTimerWalker->TimeOut) > 0)){
			pTimerWalker->Bilink.RemoveFromList();
			pTimerWalker->Bilink.InsertBefore( &ThreadList);
			pTimerWalker->TimerState=QueuedForThread;
			dwReleaseCount++;
		} else {
			break;
		}
	}

	ActiveReq += dwReleaseCount;
	if(ActiveReq > PeakReqs){
		PeakReqs=ActiveReq;
	}

#ifndef DPLAY_DOWORK
	ReleaseSemaphore(hWorkToDoSem,dwReleaseCount,NULL);
#endif

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);

}

#define min(a,b)            (((a) < (b)) ? (a) : (b))

#undef DPF_MODNAME
#define DPF_MODNAME "AdjustTimerResolution"

VOID CALLBACK AdjustTimerResolution(PVOID uID, UINT uMsg, PVOID dwUser)
{
	DWORD dwWantPeriod;

	if (!g_Running)
		return;

	Lock(&MyTimerListLock);

	if (!g_Running){
		Unlock(&MyTimerListLock);
		return;
	}

	dwWantPeriod=min(dwCurrentPeriod,dwOldPeriod);
	dwOldPeriod=dwCurrentPeriod;
	dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;

	if(dwPeriodInUse != dwWantPeriod){
		dwPeriodInUse=dwWantPeriod;
#ifndef DPLAY_DOWORK
		timeKillEvent(uWorkaroundTimerID);
		LOGPF(9, "PERIODIC TIMER ADJUSTED TO %dms", dwPeriodInUse);
		uWorkaroundTimerID=timeSetEvent(dwPeriodInUse, dwPeriodInUse, PeriodicTimer, 0, TIME_PERIODIC);
#endif
	}

	Unlock(&MyTimerListLock);

	SetMyTimer(1000,100,AdjustTimerResolution,0,&uAdjustResTimer,&AdjustResUnique);
}

#undef DPF_MODNAME
#define DPF_MODNAME "AdjustThreads"

VOID CALLBACK AdjustThreads(PVOID uID, UINT uMsg, PVOID dwUser)
{
	Lock(&ThreadListLock);
#ifndef DPLAY_DOWORK
	if((PeakReqs < nThreads) && nThreads){
		KillCount=nThreads-PeakReqs;
		ReleaseSemaphore(hWorkToDoSem, KillCount, NULL);
	}
#endif
#ifdef	DEBUG
	if(PeakReqs > MaxPeakReqs){
		MaxPeakReqs = PeakReqs;
	}
#endif
	PeakReqs=0;
	Unlock(&ThreadListLock);

	SetMyTimer(60000,500,AdjustThreads,0,&uAdjustThreadsTimer,&AdjustThreadsUnique);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetTimerResolution"

VOID SetTimerResolution(UINT msResolution)
{
	if (!g_Running)
		return;

	Lock(&MyTimerListLock);

	if (!g_Running){
		Unlock(&MyTimerListLock);
		return;
	}

	if(msResolution < dwPeriodInUse){
		dwCurrentPeriod = dwPeriodInUse=msResolution;
#ifndef DPLAY_DOWORK
		timeKillEvent(uWorkaroundTimerID);
		LOGPF(9, "SETTING TIMER RESOLUTION TO %dms", dwPeriodInUse);
		uWorkaroundTimerID=timeSetEvent(dwPeriodInUse, dwPeriodInUse, PeriodicTimer, 0, TIME_PERIODIC);
#endif
	}
	else if(msResolution < dwCurrentPeriod){
		dwCurrentPeriod=msResolution;
	}

	Unlock(&MyTimerListLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ScheduleTimerThread"

VOID ScheduleTimerThread(MYTIMERCALLBACK TimerCallBack, PVOID UserContext, PVOID *pHandle, PUINT pUnique)
{
	PMYTIMER pTimer;

	if (!g_Running){
		*pHandle = 0;
		*pUnique = 0;
		return;
	}

	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	if( (!g_Running) || ((pTimer = static_cast<PMYTIMER>( pTimerPool->Get(pTimerPool) ))== NULL)){
		Unlock(&ThreadListLock);
		Unlock(&MyTimerListLock);
		*pHandle = 0;
		*pUnique = 0;
		return;
	}

	pTimer->CallBack = TimerCallBack;
	pTimer->Context = UserContext;

	*pUnique = ++Unique;
	if(Unique == 0){
		*pUnique = ++Unique;
	}
	
	*pHandle = pTimer;
	pTimer->Unique = *pUnique;

	
	pTimer->Bilink.InsertBefore( &ThreadList);
	pTimer->TimerState = QueuedForThread;

	ActiveReq++;
	if(ActiveReq > PeakReqs){
		PeakReqs = ActiveReq;
	}
	
#ifndef DPLAY_DOWORK	
	ReleaseSemaphore(hWorkToDoSem,1,NULL);
#endif

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetMyTimer"

VOID SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, PVOID UserContext, PVOID *pHandle, PUINT pUnique)
{
	CBilink *pBilink;
	PMYTIMER pMyTimerWalker,pTimer;
	DWORD time;
	BOOL bInserted=FALSE;
#ifdef	QST
	UINT	Offset;
	UINT	Index;
#endif

	if( (g_Running == FALSE) || ((pTimer = static_cast<PMYTIMER>( pTimerPool->Get(pTimerPool) ))== NULL)){
		*pHandle = 0;
		*pUnique = 0;
		return;
	}

	pTimer->CallBack=TimerCallBack;
	pTimer->Context=UserContext;

	if(TimerRes){
		SetTimerResolution(TimerRes);
	}

	Lock(&MyTimerListLock);

		++Unique;
		if(Unique==0){
			++Unique;
		}
		*pUnique=Unique;

		pTimer->Unique=Unique;
		*pHandle = (PVOID) pTimer;

		time=GETTIMESTAMP();
		pTimer->TimeOut=time+dwTimeOut;
		pTimer->TimerState=WaitingForTimeout;

#ifdef	QST
		if(dwTimeOut < QST_MAX_TIMEOUT){
			Offset = (dwTimeOut + (QST_GRANULARITY/2)) / QST_GRANULARITY;	// Round nearest and convert time to slot offset
			Index = (Offset + QST_CurrentIndex) & QST_MOD_MASK;				// Our index will be Current + Offset MOD TableSize
			pTimer->Bilink.InsertBefore( &rgQSTimerArray[Index]);			// Its called Quick-Start for a reason.
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
			LOGPF(9, "SET TIMER QST handle=%p; Bucket=%d; CurrentBucket=%d",pTimer, Index, QST_CurrentIndex);
		}
		else
#endif	QST

		// OPTIMIZE FOR STANDARD TIMER
		//
		// Rather then calling a special API for StandardLongTimers as described above,  we can just pull out
		// any timer with the correct Timeout value and stick it on the end of the StandardTimerList.  I believe
		// this is the most straightforward way to do it.  Now really,  we could put anything with a TO +/- resolution
		// on the standard list too,  but that might not be all that useful...

		if(dwTimeOut == STANDARD_LONG_TIMEOUT_VALUE){
			// This is a STANDARD TIMEOUT so add it to the end of the standard list.

			pTimer->Bilink.InsertBefore( &StdTimerList);
		}

		// OPTIMIZE FOR SHORT TIMERS  !! DONT NEED TO DO THIS IF USING Quick Start Timers !!
		//
		// If the timer has a very small Timeout value (~20ms) lets insert from the head of the list
		// instead of from the tail.
#ifndef	QST		
		else if (dwTimeOut < 25){
			pBilink=MyTimerList.GetNext();
			while(pBilink != &MyTimerList){
				pMyTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
				pBilink=pBilink->GetNext();

				if((int)(pMyTimerWalker->TimeOut-pTimer->TimeOut) > 0 ){
					pTimer->Bilink.InsertBefore( &pMyTimerWalker->Bilink);
					bInserted=TRUE;
					break;
				}
			}

			if(!bInserted){
				pTimer->Bilink.InsertBefore( &MyTimerList);
			}
		}
#endif	// ! QST
		else
		{

		//	DEFAULT - Assume new timers will likely sort to the end of the list.
		//
		// Insert this guy in the sorted list by timeout time,  walking from the tail forward.

			pBilink=MyTimerList.GetPrev();
			while(pBilink != &MyTimerList){
				pMyTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
				pBilink=pBilink->GetPrev();

				if((int)(pTimer->TimeOut-pMyTimerWalker->TimeOut) > 0 ){
					pTimer->Bilink.InsertAfter( &pMyTimerWalker->Bilink);
					bInserted=TRUE;
					break;
				}
			}

			if(!bInserted){
				pTimer->Bilink.InsertAfter( &MyTimerList);
			}
		}	
	Unlock(&MyTimerListLock);

	return;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CancelMyTimer"

HRESULT CancelMyTimer(PVOID dwTimer, DWORD Unique)
{
	PMYTIMER pTimer=(PMYTIMER)dwTimer;
	HRESULT hr=DPNERR_GENERIC;

	if(pTimer == 0){
		return DPN_OK;
	}

	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	if(pTimer->Unique == Unique){
		switch(pTimer->TimerState){
			case WaitingForTimeout:
				pTimer->Bilink.RemoveFromList();
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				hr=DPN_OK;
				break;

			case QueuedForThread:
				pTimer->Bilink.RemoveFromList();
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				if(ActiveReq)ActiveReq--;
				ExtraSignals++;
				hr=DPN_OK;
				break;

			default:
				break;
		}
	}

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitQST"

HRESULT InitQST(void)
{
#ifdef	QST
	int		i;

	if( SALLOC(rgQSTimerArray, CBilink, QST_SLOTCOUNT) == NULL ){	// Allocate the timer table
		return DPNERR_OUTOFMEMORY;
	}

	for(i=0; i<QST_SLOTCOUNT; i++){
		rgQSTimerArray[i].Initialize();
	}

	QST_CurrentIndex = 0;
	QST_LastRunTime = GETTIMESTAMP();
#endif
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitTimerWorkaround"

HRESULT InitTimerWorkaround()
{
	DWORD   dwJunk;


    pTimerPool = NULL;
    nThreads = 0;		// number of running threads.
    ActiveReq = 0;		// number of requests being processed.
    PeakReqs = 0;
    bShutDown = FALSE;
#ifndef DPLAY_DOWORK
    KillCount = 0;
#endif
	ExtraSignals = 0;

#ifndef DPLAY_DOWORK
	MAX_TIMER_THREADS = MAX_TIMER_THREADS_PER_PROCESSOR;

    //  9/30/00(RichGr) - Bug #46064: Track thread handles in an array so we have an accurate count of how many need
    //     to be closed at shutdown.
    if ( (g_phTimerThreadHandles = new HANDLE[MAX_TIMER_THREADS]) == NULL)
		return DPNERR_OUTOFMEMORY;

    memset(g_phTimerThreadHandles, 0, sizeof HANDLE * MAX_TIMER_THREADS);
#endif

	MyTimerList.Initialize();
	StdTimerList.Initialize();
	ThreadList.Initialize();

	if(InitQST() != DPN_OK){
		return DPNERR_OUTOFMEMORY;
	}

#ifndef DPLAY_DOWORK
	hWorkToDoSem = CreateSemaphoreA(NULL, 0, 65535, NULL);
#endif

	InitializeCriticalSection(&MyTimerListLock);
	InitializeCriticalSection(&ThreadListLock);

	pTimerPool=FPM_Create(sizeof(MYTIMER),NULL,NULL,NULL,NULL);


#ifndef DPLAY_DOWORK
	if(!hWorkToDoSem || !pTimerPool){
		FiniTimerWorkaround();
		return DPNERR_OUTOFMEMORY;
	}

	uWorkaroundTimerID=timeSetEvent(DEFAULT_TIME_RESOLUTION, DEFAULT_TIME_RESOLUTION, PeriodicTimer, 0, TIME_PERIODIC);

	if(!uWorkaroundTimerID){
#else
	if(!pTimerPool){
#endif
		FiniTimerWorkaround();
		return DPNERR_OUTOFMEMORY;
	}

    Lock(&ThreadListLock);
	nThreads = 1;
#ifndef DPLAY_DOWORK
    //  9/30/00(RichGr) - Bug #46064: Pass a pointer to the destination for the thread handle to TimerWorkerThread
    //     so the handle will be available to be closed on thread exit.
	g_phTimerThreadHandles[0] = CreateThread(NULL, 4096, TimerWorkerThread, &g_phTimerThreadHandles[0], 0, &dwJunk);
#endif
    Unlock(&ThreadListLock);

#ifndef DPLAY_DOWORK
	if( !g_phTimerThreadHandles[0])
    {
		nThreads = 0;
		FiniTimerWorkaround();
		return DPNERR_OUTOFMEMORY;
	}
#endif

	InterlockedIncrement(&g_Running);

	SetMyTimer(1000,500,AdjustTimerResolution,0,&uAdjustResTimer,&AdjustResUnique);
	SetMyTimer(60000,500,AdjustThreads,0,&uAdjustThreadsTimer,&AdjustThreadsUnique);


	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "PurgeTimerList"

VOID PurgeTimerList(CBilink *pList)
{
	PMYTIMER	pTimer;

	while(!pList->IsEmpty()){
		pTimer=CONTAINING_RECORD(pList->GetNext(), MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		pTimer->Bilink.RemoveFromList();
		pTimerPool->Release(pTimerPool, pTimer);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "FiniQST"

void FiniQST(void)
{
#ifdef	QST
	UINT	index;
	CBilink	*pLink;

	if(rgQSTimerArray){

		pLink = rgQSTimerArray;
		for(index=0; index<QST_SLOTCOUNT; index++){
			PurgeTimerList(pLink++);
		}

		FREE(rgQSTimerArray);
		rgQSTimerArray = NULL;
	}
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "FiniTimerWorkaround"

VOID FiniTimerWorkaround()
{
    DWORD   nThreadHandleCount;
    int     i;
    int     slowcount;
    DWORD   dwSuspendCount;


	// Set our running state to false
	EnterCriticalSection(&MyTimerListLock);
	g_Running = FALSE;
	LeaveCriticalSection(&MyTimerListLock);

	// At this point:
	// 1) AdjustTimerResolution will not reschedule the winmm timer
	// 2) SetTimerResolution will not reschedule the winmm timer
	// 3) PeriodicTimer will not do anything if it fires
	// 4) ScheduleTimerThread will not do anything if it fires
	// 5) Any thread waiting in PeriodicTimer will see Running == FALSE and won't do anything
	// 6) Any thread waiting in ScheduleTimerThread will see Running == FALSE and won't do anything

#ifndef DPLAY_DOWORK
	// Kill the timer so it never fires again
	if(uWorkaroundTimerID){
		timeKillEvent(uWorkaroundTimerID);
	}	
#endif
	
	// At this point:
	// 1) The winmm timer will not fire again and therefore PeriodicTimer will not be called again

	// Cancel the timers we started
	CancelMyTimer(uAdjustResTimer, AdjustResUnique);
	CancelMyTimer(uAdjustThreadsTimer, AdjustThreadsUnique);

	// Tell all remaining timer threads to shutdown
	Lock(&ThreadListLock);
	bShutDown = TRUE;
#ifndef DPLAY_DOWORK
	ReleaseSemaphore(hWorkToDoSem, 60000, NULL);
#endif
	Unlock(&ThreadListLock);
    Sleep(0);

	// At this point:
	// 1) No threads should be waiting in TimerWorkerThread and no new ones will be scheduled

#ifndef DPLAY_DOWORK
    if (nThreads > 0)
    {
        //  9/30/00(RichGr) - Bug #46064: Count the remaining threads and reset nThreads accordingly.
        nThreadHandleCount = 0;
    
        Lock(&ThreadListLock);

        for (i = 0; i < (int)MAX_TIMER_THREADS; i++)
        {
            if (g_phTimerThreadHandles[i])
            {
                // Use SuspendThread() to tell us whether the thread is still alive,
                // and if it's accessible then resume it.
                dwSuspendCount = SuspendThread(g_phTimerThreadHandles[i]);

                if (dwSuspendCount == (DWORD)-1)
                {
                    g_phTimerThreadHandles[i] = 0;
                }
                else
                {
                    dwSuspendCount = ResumeThread(g_phTimerThreadHandles[i]);
                    nThreadHandleCount++;
                }
            }
        }

        if (nThreadHandleCount < nThreads)  // We only care if we found less threads.
        {
            LOGPF(9, "Remaining thread count at cleanup is being reset from %d to %d", nThreads, nThreadHandleCount);
            nThreads = nThreadHandleCount;
        }

        Unlock(&ThreadListLock);

	    // Wait for the threads to finish
	    slowcount = 0;

	    while (nThreads && slowcount < (60000/100))	// don't wait more than 60 seconds.
        {
		    slowcount++;
		    Sleep(100);
	    }
    }

	CloseHandle(hWorkToDoSem);
#endif
	DeleteCriticalSection(&MyTimerListLock);
	DeleteCriticalSection(&ThreadListLock);

	PurgeTimerList(&MyTimerList);
	PurgeTimerList(&StdTimerList);
	PurgeTimerList(&ThreadList);

	FiniQST();

	if(pTimerPool){
		pTimerPool->Fini(pTimerPool);
	}

#ifndef DPLAY_DOWORK
    delete g_phTimerThreadHandles;
#endif
}


#undef DPF_MODNAME
#define DPF_MODNAME "TimerWorkerThread"

#ifndef DPLAY_DOWORK
DWORD WINAPI TimerWorkerThread(LPVOID lpv)  // lpv points to g_phTimerThreadHandles[i].
#else
DWORD TimerWorkerThread(VOID)
#endif
{
#ifndef DPLAY_DOWORK
    HANDLE     *phCurrentThreadHandle = (HANDLE*)lpv;
#endif
	CBilink    *pBilink;
	PMYTIMER    pTimer;
#ifndef DPLAY_DOWORK
	DWORD       dwJunk;
    int         i;


	while (1){

		WaitForSingleObject(hWorkToDoSem, INFINITE);

#endif
		Lock(&ThreadListLock);

			if(bShutDown){
				Unlock(&ThreadListLock);
#ifndef DPLAY_DOWORK
				break;	
			}

			if(KillCount && nThreads > 1){
				KillCount--;
				Unlock(&ThreadListLock);
				Sleep(1000); // stay around a sec to let I/O complete.
				break;	
#else
				return 1;	
#endif
			}

			if(ExtraSignals){
				ExtraSignals--;
				Unlock(&ThreadListLock);
#ifndef DPLAY_DOWORK
				continue;
			}

			if(KillCount){
				KillCount--; //keeps us from trying to continually evaluate killing last thread.
				Unlock(&ThreadListLock);
				continue;
			}

			if (ActiveReq > nThreads && nThreads < MAX_TIMER_THREADS)
            {
                //  9/30/00(RichGr) - Bug #46064: Find the first empty slot.
                for (i = 0; i < (int)MAX_TIMER_THREADS; i++)
                {
                    if (g_phTimerThreadHandles[i] == 0)
                        break;
                }

                // In case of an illogical error, just use the last slot anyway.  The cleanup code that
                // uses the array is failsafe.
                if (i >= (int)MAX_TIMER_THREADS)
                {
    			    DNASSERT("NO SLOTS LEFT IN TIMER THREAD HANDLE TABLE!");
                    i = MAX_TIMER_THREADS - 1;
                }

                // Pass a pointer to the destination for the thread handle to TimerWorkerThread
                // so the handle will be available to be closed on thread exit.
				g_phTimerThreadHandles[i] = CreateThread(NULL, 4096, TimerWorkerThread, &g_phTimerThreadHandles[i], 0, &dwJunk);

				if (g_phTimerThreadHandles[i])
                {
					nThreads++;
				}
#else
				return 0;
#endif
			}

			pBilink=ThreadList.GetNext();

			if(pBilink == &ThreadList) {
				Unlock(&ThreadListLock);
#ifndef DPLAY_DOWORK
				continue;
#else
				return 1;
#endif
			};

			pBilink->RemoveFromList();	// pull off the list.

			pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);

			// Call a callback

			pTimer->TimerState=InCallBack;

		Unlock(&ThreadListLock);

		(pTimer->CallBack)(pTimer, (UINT) pTimer->Unique, pTimer->Context);

		pTimer->Unique=0;
		pTimer->TimerState=End;
		pTimerPool->Release(pTimerPool, pTimer);

		if (!g_Running)
#ifndef DPLAY_DOWORK
			break;
#else
			return 1;
#endif

		Lock(&ThreadListLock);

		if(ActiveReq)ActiveReq--;

		Unlock(&ThreadListLock);
#ifndef DPLAY_DOWORK
	}	


    //  9/30/00(RichGr) - Bug #46064: We certainly should have the handle.  Close it and set it to 0, which will
    //     update the thread handle array.
	Lock(&ThreadListLock);

    if (*phCurrentThreadHandle)
    {
		CloseHandle(*phCurrentThreadHandle);
        *phCurrentThreadHandle = 0;
    }

    // This used to be decremented earlier in this function, but that can give a misleading count
    // if we are cleaning up, so decrement it here.
	nThreads--;
	Unlock(&ThreadListLock);

    // Thread is terminating.
#endif
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\protocol\receivep.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Receive.c
 *  Content:	This file contains code which receives indications of incoming data
 *				from a ServiceProvider,  cracks the data,  and handles it appropriately.
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  09/29/2000	masonb	Fixed Sequence issue with Out-of-order Receives
 *
 ****************************************************************************/

#include "dnproti.h"

#ifdef	DEBUG
BOOL	UsePollDelay = FALSE;
#endif

// local protos

BOOL	CancelFrame(PEPD, BYTE);
VOID	CompleteSends(PEPD);
VOID 	DropReceive(PEPD, PRCD);
HRESULT IndicateReceive(PSPD, PSPIE_DATA);
HRESULT	IndicateConnect(PSPD, PSPIE_CONNECT);
HRESULT	ProcessEnumQuery( PSPD, PSPIE_QUERY );
HRESULT	ProcessQueryResponse( PSPD, PSPIE_QUERYRESPONSE );
VOID	ProcessConnectedResponse(PSPD, PEPD, PCFRAME);
VOID	ProcessConnectRequest(PSPD, PEPD, PCFRAME);
VOID	ProcessDisconnectedFrame(PSPD, PEPD, PCFRAME);
VOID	ProcessEndOfStream(PEPD);
VOID	ProcessListenStatus(PSPD, PSPIE_LISTENSTATUS);
VOID	ProcessConnectAddressInfo(PSPD, PSPIE_CONNECTADDRESSINFO);
VOID	ProcessEnumAddressInfo(PSPD, PSPIE_ENUMADDRESSINFO);
VOID	ProcessListenAddressInfo(PSPD, PSPIE_LISTENADDRESSINFO);
VOID	ProcessSendMask(PEPD, BYTE, ULONG, ULONG);
VOID	ProcessSPDisconnect(PSPD, PSPIE_DISCONNECT);
VOID 	ReceiveInOrderFrame(PEPD, PRCD);
VOID 	ReceiveOutOfOrderFrame(PEPD, PRCD, ULONG);
VOID	RejectFrame(PEPD, PDFRAME);


HRESULT	CrackCommand(PSPD, PEPD, PSPRECEIVEDBUFFER);
HRESULT	CrackDataFrame(PSPD, PEPD, PSPRECEIVEDBUFFER, DWORD);

 /*
**		Indicate Receive
**
**			Service Provider calls this entry when data arrives on the network.
**		We will quickly validate the frame and then figure what to do with it...
**
**			Poll/Response activity should be handled before data is indicated to
**		clients.  We want to measure the network latency up to delivery,  not including
**		delivery.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_IndicateEvent"

HRESULT WINAPI DNSP_IndicateEvent(IDP8SPCallback *pIDNSP, SP_EVENT_TYPE Opcode, PVOID DataBlock)
{
	PSPD			pSPD = (PSPD) pIDNSP;
	ASSERT_SPD(pSPD);
	
	switch(Opcode)
	{
		case	SPEV_DATA:
			return IndicateReceive(pSPD, (PSPIE_DATA) DataBlock);

		case	SPEV_CONNECT:
			return IndicateConnect(pSPD, (PSPIE_CONNECT) DataBlock);

		case	SPEV_ENUMQUERY:
			return ProcessEnumQuery( pSPD, (PSPIE_QUERY) DataBlock );

		case	SPEV_QUERYRESPONSE:
			return ProcessQueryResponse( pSPD, (PSPIE_QUERYRESPONSE) DataBlock );

		case	SPEV_DISCONNECT:
			ProcessSPDisconnect(pSPD, (PSPIE_DISCONNECT) DataBlock);
			break;

		case	SPEV_LISTENSTATUS:
			ProcessListenStatus(pSPD, (PSPIE_LISTENSTATUS) DataBlock);
			break;

		case	SPEV_LISTENADDRESSINFO:
			ProcessListenAddressInfo(pSPD, (PSPIE_LISTENADDRESSINFO) DataBlock);
			break;

		case	SPEV_CONNECTADDRESSINFO:
			ProcessConnectAddressInfo(pSPD, (PSPIE_CONNECTADDRESSINFO) DataBlock);
			break;

		case	SPEV_ENUMADDRESSINFO:
			ProcessEnumAddressInfo(pSPD, (PSPIE_ENUMADDRESSINFO) DataBlock);
			break;

		//
		// SP passed something unexpected
		//
		default:
			LOGPF(0, "Unknown Event indicated by SP");
			break;
	}

	return DPN_OK;
}


/*
**	Indicate Connect
**
**		This event is indicated for both calling and listening sides.  The
**	calling side will do most of its work when the SP Connect call completes
**	and the listening side will do most of its work when the CONNECT frame
**	gets delivered.  All we do here is allocate the EPD and attach it to the
**	MSD (for calling case)
**
**		Since we have a connect protocol,  there will always be a CONNECT
**	frame following closely on the heels of this indication.  Therefore,
**	there is not a whole lot of stuff that we need to do here.  We will
**	allocate the EndPoint and leave it dormant.
**
**		Synchronization Issue:  We have decided that if an SP Listen command is cancelled,
**	the cancel call will not complete until all ConnectIndications have returned from the
**	protocol.  This means that we are GUARANTEED that the Listen command in the context
**	will be valid throughout this call.  This is important because now we can add a reference
**	to the Listen's MSD here and now and we will know that it wont disappear on us before we
**	do it.  Truth,  however,  is that there will be a race until SP fixes itself to follow
**	this behavior.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "IndicateConnect"

HRESULT	IndicateConnect(PSPD pSPD, PSPIE_CONNECT pConnData)
{
	PEPD	pEPD;
	PMSD	pMSD;

	pMSD = (PMSD) pConnData->pCommandContext;
	ASSERT_MSD(pMSD);

	LOGPF(2, "Parameters: pSPD[%p], pConnData[%p] - pMSD[%p]", pSPD, pConnData, pMSD);

	Lock(&pMSD->CommandLock);
	
	LOCK_MSD(pMSD, "EPD Ref");				// Place a reference on the listen object.  This prevents it from
														// going away during the Connect Protocol,  an assumption which simplifies
														// life extraordinarily.  We will want to ASSERT this fact,  however,  to make
														// sure that SP is playing by our rules.

	ASSERT((pMSD->CommandID == COMMAND_ID_CONNECT)||(pMSD->CommandID == COMMAND_ID_LISTEN));
	
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		LOGPF(2, "Connect Rejected - Listen is cancelling, returning DPNERR_ABORTED");
		RELEASE_MSD(pMSD, "EPD Ref");
		return DPNERR_ABORTED;
	}

	if((pEPD = NewEndPoint(pSPD, pConnData->hEndpoint)) == NULL)
	{
		LOGPF(0, "Failed to allocate new EPD, returning DPNERR_ABORTED");
		RELEASE_MSD(pMSD, "EPD Ref");
		return DPNERR_ABORTED;	// This error will implicitly DISCONNECT from Endpoint
	}

	pEPD->ulEPFlags |= EPFLAGS_END_POINT_DORMANT;		// Not connecting yet
	pEPD->pCommand = pMSD;								// Associate the context with our data structure

	if(pMSD->CommandID == COMMAND_ID_CONNECT)
	{
		LOGPF(5, "INDICATE CONNECT (CALLING) -- EPD = %p", pEPD);
		pMSD->pEPD = pEPD;
	}
	else
	{
		LOGPF(5, "INDICATE CONNECT (LISTENING) -- EPD = %p", pEPD);
	}

	pConnData->pEndpointContext = pEPD;

	Unlock(&pMSD->CommandLock);

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RejectConnection"

VOID
RejectConnection(PEPD pEPD)
{
	PMSD	pMSD;
	
	Lock(&pEPD->EPLock);
	if( (pMSD = pEPD->pCommand) != NULL)
	{
		pEPD->pCommand = NULL;
	}
	pEPD->ulEPFlags |= EPFLAGS_TERMINATING;
	
	Unlock(&pEPD->EPLock);

	if(pMSD)
	{
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "EPD Ref");
	}

	KillConnection(pEPD);
}

/*
**		Indicate Receive
**
**		A frame has been delivered by the service provider.  We are Guaranteed to
**	have an active Endpoint in our hash table (or else something is wrong).  I have not
**	decided whether I will respond to POLL bits at this high level or else let
**	each handler repond in its own particular... eh...  idiom.
**
**		Our return value controls whether SP will recycle the receive buffer, or whether
**	we can keep the buffer around until we are ready to indicate it to higher levels
**	later on.   If we return DPN_OK then we are done with the buffer and it will be recycled.
**	If we return DPNERR_PENDING then we may hold on to the buffer until we release them later.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "IndicateReceive"

HRESULT IndicateReceive(PSPD pSPD, PSPIE_DATA pDataBlock)
{
	PEPD 				pEPD = static_cast<PEPD>( pDataBlock->pEndpointContext );
	HRESULT				hr;
	PPacketHeader		pFrame = (PPacketHeader) pDataBlock->pReceivedData->BufferDesc.pBufferData;
	DWORD				tNow = GETTIMESTAMP();

	LOGPF(6, "Parameters: pSPD[%p], pDataBlock[%p] - pEPD[%p]", pSPD, pDataBlock, pEPD);

#ifdef	FRAME_DROPS
	if(pFrame->State == DROP_STATE)
	{
		LOGPF(1, "(%p) DROP FRAME, returning DPN_OK", pEPD);
		return DPN_OK;
	}

#endif
	// BUGBUG: No lock held
	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		LOGPF(1, "(%p) SP is terminating, returning DPN_OK", pEPD);
		return DPN_OK;
	}

	ASSERT_EPD(pEPD);

	if(LOCK_EPD(pEPD, "LOCK (IND RECEIVE)") == 0)
	{
		LOGPF(1, "(%p) Rejecting receive on unreferenced EPD, returning DPN_OK", pEPD);
		return DPN_OK;
	}

	pEPD->tLastPacket = tNow;						// Track last time each guy writes to us

#ifdef DEBUG
		// copy this frame to buffer in EPD so we can look after a break.
		DWORD dwLen = MIN(32, pDataBlock->pReceivedData->BufferDesc.dwBufferSize);
		memcpy(pEPD->LastPacket, pDataBlock->pReceivedData->BufferDesc.pBufferData, dwLen);
#endif

	if(pFrame->bCommand & PACKET_COMMAND_DATA)
	{
		hr = CrackDataFrame(pSPD, pEPD, pDataBlock->pReceivedData, tNow);
	}
	else
	{
		hr = CrackCommand(pSPD, pEPD, pDataBlock->pReceivedData);
	}

	RELEASE_EPD(pEPD, "UNLOCK (IND RCV DONE)"); // SendQLock not already held

	LOGPF(6, "Returning hr[%x]", hr);
	return hr;
}


/*
**		Process Enum Query
**
**		A frame has been delivered by the service provider representing an enumereation
**	query.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEnumQuery"

HRESULT ProcessEnumQuery( PSPD pSPD, PSPIE_QUERY pQueryBlock )
{
	MSD		*pMSD;
	PROTOCOL_ENUM_DATA	EnumData;

	pMSD = static_cast<MSD*>( pQueryBlock->pUserContext );

	LOGPF(2, "Parameters: pSPD[%p], pQueryBlock[%p] - pMSD[%p]", pSPD, pQueryBlock, pMSD);

	EnumData.pSenderAddress = pQueryBlock->pAddressSender;
	EnumData.pDeviceAddress = pQueryBlock->pAddressDevice;
	EnumData.ReceivedData.pBufferData = pQueryBlock->pReceivedData->BufferDesc.pBufferData;
	EnumData.ReceivedData.dwBufferSize = pQueryBlock->pReceivedData->BufferDesc.dwBufferSize;
	EnumData.hEnumQuery = pQueryBlock;

	DBG_CASSERT( sizeof( &EnumData ) == sizeof( PBYTE ) );

	LOGPF(3, "Calling Core->IndicateEnumQuery");
	pSPD->pPData->pfVtbl->IndicateEnumQuery(	pSPD->pPData->Parent,
												pMSD->Context,
												pMSD,
												reinterpret_cast<PBYTE>( &EnumData ),
												sizeof( EnumData ));

	return	DPN_OK;
}

/*
**		Process Query Response
**
**		A frame has been delivered by the service provider representing a response to an enum.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ProcessQueryResponse"

HRESULT ProcessQueryResponse( PSPD pSPD, PSPIE_QUERYRESPONSE pQueryResponseBlock)
{
	MSD		*pMSD;
	PROTOCOL_ENUM_RESPONSE_DATA	EnumResponseData;

	pMSD = static_cast<MSD*>( pQueryResponseBlock->pUserContext );

	LOGPF(2, "Parameters: pSPD[%p], pQueryResponseBlock[%p] - pMSD[%p]", pSPD, pQueryResponseBlock, pMSD);

	EnumResponseData.pSenderAddress = pQueryResponseBlock->pAddressSender;
	EnumResponseData.pDeviceAddress = pQueryResponseBlock->pAddressDevice;
	EnumResponseData.ReceivedData.pBufferData = pQueryResponseBlock->pReceivedData->BufferDesc.pBufferData;
	EnumResponseData.ReceivedData.dwBufferSize = pQueryResponseBlock->pReceivedData->BufferDesc.dwBufferSize;
	EnumResponseData.dwRoundTripTime = pQueryResponseBlock->dwRoundTripTime;

	DBG_CASSERT( sizeof( &EnumResponseData ) == sizeof( PBYTE ) );
	
	LOGPF(3, "Calling Core->IndicateEnumResponse");
	pSPD->pPData->pfVtbl->IndicateEnumResponse(	pSPD->pPData->Parent,
												pMSD,
												pMSD->Context,
												reinterpret_cast<PBYTE>( &EnumResponseData ),
												sizeof( EnumResponseData ));

	return	DPN_OK;
}

/*
**		Crack Command
**
**			This frame is a maintainance frame containing no user data
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CrackCommand"

HRESULT CrackCommand(PSPD pSPD, PEPD pEPD, PSPRECEIVEDBUFFER pRcvBuffer)
{
	DWORD 		dwDataLength = pRcvBuffer->BufferDesc.dwBufferSize;
	ULONG		*array_ptr;
	ULONG		mask1, mask2;
	
	union {
		PCFRAME			pCFrame;
		PSFBIG			pSack;
		}		pData;

	pData.pCFrame = (PCFRAME) pRcvBuffer->BufferDesc.pBufferData;

	// Drop short frames (should not happen)
	if(dwDataLength < MIN(sizeof(CFRAME), sizeof(SACKFRAME)))
	{		
		LOGPF(0, "(%p) Dropping short frame", pEPD);
		return DPN_OK;
	}

	switch(pData.pCFrame->bExtOpcode)
	{
		case FRAME_EXOPCODE_SACK:
			LOGPF(7, "(%p) SACK Frame Received", pEPD);

			if(pEPD->ulEPFlags & EPFLAGS_END_POINT_DORMANT)
			{
				LOGPF(0, "(%p) Endpoint is dormant, rejecting connection", pEPD);
				RejectConnection(pEPD);
				break;
			}
			if( pData.pSack->bFlags & SACK_FLAGS_RESPONSE )
			{
				LOGPF(7, "(%p) ACK RESP RCVD: Rty=%d,N(R)=0x%x", pEPD, pData.pSack->bRetry, pData.pSack->bNRcv);
			}
			if(pData.pSack->bFlags & (SACK_FLAGS_SACK_MASK1 | SACK_FLAGS_SACK_MASK2 | SACK_FLAGS_SEND_MASK1 | SACK_FLAGS_SEND_MASK2))
			{
				LOGPF(7, "(%p) *MASKS IN SACK* flags=%x", pEPD, pData.pSack->bFlags);
			}

			array_ptr = pData.pSack->rgMask;
			mask1 = pData.pSack->bFlags & SACK_FLAGS_SACK_MASK1 ? *array_ptr++ : 0;
			mask2 = pData.pSack->bFlags & SACK_FLAGS_SACK_MASK2 ? *array_ptr++ : 0;
			
			Lock(&pEPD->EPLock);
			
			UpdateXmitState(pEPD, pData.pSack->bNRcv, (PSACKFRAME) pData.pSack, mask1, mask2, GETTIMESTAMP());

			mask1 = pData.pSack->bFlags & SACK_FLAGS_SEND_MASK1 ? *array_ptr++ : 0;
			mask2 = pData.pSack->bFlags & SACK_FLAGS_SEND_MASK2 ? *array_ptr++ : 0;

			if(mask1 | mask2)
			{
				ProcessSendMask(pEPD, pData.pSack->bNSeq, mask1, mask2);

				if( (!pEPD->blCompleteList.IsEmpty()) && ((pEPD->ulEPFlags & EPFLAGS_IN_RECEIVE_COMPLETE) == FALSE))
				{
					pEPD->ulEPFlags |= EPFLAGS_IN_RECEIVE_COMPLETE;	// ReceiveComplete will clear this flag when done
					ReceiveComplete(pEPD); 							// Deliver the goods,  returns with EPLock released
				}
				else 
				{
					Unlock(&pEPD->EPLock);
				}
			}
			else 
			{
				Unlock(&pEPD->EPLock);
			}
			
			if(pEPD->ulEPFlags & EPFLAGS_COMPLETE_SENDS)
			{
				CompleteSends(pEPD);
			}
			break;

		case FRAME_EXOPCODE_CONNECT:
			LOGPF(7, "(%p) CONNECT Frame Received", pEPD);
			ProcessConnectRequest(pSPD, pEPD, pData.pCFrame);
			break;

		case FRAME_EXOPCODE_CONNECTED:
			LOGPF(7, "(%p) CONNECTED Frame Received", pEPD);
			ProcessConnectedResponse(pSPD, pEPD, pData.pCFrame);
			break;

		case FRAME_EXOPCODE_DISCONNECTED:
			LOGPF(7, "(%p) DISCONNECTED Frame Received", pEPD);
			ProcessDisconnectedFrame(pSPD, pEPD, pData.pCFrame);
			break;

		default:
			LOGPF(1, "(%p) RECEIVED INVALID FRAME, Data: %x, rejecting connection", pEPD, *((DWORD*)pRcvBuffer->BufferDesc.pBufferData));
			RejectConnection(pEPD);
			break;
	}

	return DPN_OK;
}

/*
**		Crack Data Frame
**
**			In addition to delivering data contained in the frame,  we also must
**	use the included state info to drive the transmission process.  We will update
**	our link state according to this info and see if we need to put this session
**	back into the sending pipeline.
**
**		Of course, data will only be delivered if we have completed an entire message.
**
**	CRITICAL SECTION NOTE -- It might seem rather lavish the way we hold the EPD->StateLock
**		thru this entire routine,  but anything less would require an obscene level of complexity
**		to keep ironed out.  This is why I defer all ReceiveIndications and buffer mappings until
**		the end of the routine when the Lock can be released.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CrackDataFrame"

HRESULT CrackDataFrame(PSPD pSPD, PEPD pEPD, PSPRECEIVEDBUFFER pRcvBuffer, DWORD tNow)
{
	LPVOID 	pData = pRcvBuffer->BufferDesc.pBufferData;
	DWORD 	dwDataLength = pRcvBuffer->BufferDesc.dwBufferSize;
	PDFBIG	pFrame = (PDFBIG) pData;
	PRCD	pRCD;
	PRCD	pThisRCD;
	CBilink	*pLink;
	BYTE	bSeq = pFrame->bSeq;
	BOOL	flag;
	ULONG	bit;
	UINT	count;
	ULONG	*array_ptr;
	ULONG	MaskArray[4];
	UINT	header_size;
	ULONG	mask;


	LOGPF(7, "(%p) Data Frame Arrives Seq=%x; NRcv=%x", pEPD, bSeq, pFrame->bNRcv);

	// Determine how large the variable length header is
	mask = (pFrame->bControl & PACKET_CONTROL_VARIABLE_MASKS) / PACKET_CONTROL_SACK_MASK1;
	
	Lock(&pEPD->EPLock);
	
	//	Data on an unconnected link
	//
	//	There are two possibilities (as I see it today).  Either we have dropped our link because partner
	//	went silent,  but now he has started sending again.  OR We have disconnected and are now reconnecting
	//  but there are some old data frames bouncing around (less likely).
	//
	//	If we have dropped and partner is just figuring it out,  we must kill the endpoint or else it will hang
	//	around forever after partner stops bothering us.  We can help out partner by sending him a DISC frame
	//  so he knows that we arent playing anymore,  buts its not technically necessary.
	//
	//	In the second case,  we do not want to close the EP because that will crush the session startup that
	//	is supposedly in progress.  Therefore,  if we are not in a DORMANT state,  then we know a session
	//	startup is in progress,  and we will let the EP remain open.

	if(!(pEPD->ulEPFlags & EPFLAGS_CONNECTED))
	{				
		// CODEWORK - send some sort of rejection frame...
		LOGPF(0, "Received data on unconnected link");
		if(pEPD->ulEPFlags & EPFLAGS_END_POINT_DORMANT)
		{
			Unlock(&pEPD->EPLock);
			LOGPF(0, "Rejecting connection on dormant link that received data");
			RejectConnection(pEPD);
		}
		else
		{
			Unlock(&pEPD->EPLock);
		}
		return DPN_OK;										// do not accept data before we have connected
	}

	// Make sure that new frame is within our receive window
	if((BYTE)(bSeq - pEPD->bNextReceive) >= (BYTE) MAX_FRAME_OFFSET)
	{	
		LOGPF(1, "(%p) Rejecting frame that is out of receive window SeqN=%x", pEPD, bSeq);
		RejectFrame(pEPD, (PDFRAME) pFrame);		// This unlocks the EPLock
		return DPN_OK;								// REJECT Frame
	}

	if(mask)
	{
		array_ptr = pFrame->rgMask;
		for(count = 0; count < 4; count++, mask >>= 1)
		{
			MaskArray[count] = (mask & 1) ? *array_ptr++ : 0;
		}
		
		header_size = (UINT) ((UINT_PTR) array_ptr - (UINT_PTR) pFrame);

		// See if this frame Acknowledges any of our outstanding data
		LOGPF(7, "(%p) UpdateXmitState - Mask %x %x", pEPD, MaskArray[1], MaskArray[0]);
		UpdateXmitState(pEPD, pFrame->bNRcv, NULL, MaskArray[0], MaskArray[1], tNow);				// Do this before taking StateLock
	}
	else 
	{
		header_size = sizeof(DFRAME);
		LOGPF(7, "(%p) UpdateXmitState - No Mask", pEPD);
		UpdateXmitState(pEPD, pFrame->bNRcv, NULL, 0, 0, tNow);			// Do this before taking StateLock
	}

	// Determine if there is a SendMask in this frame which identifies dropped frames as unreliable
	if(pFrame->bControl & (PACKET_CONTROL_SEND_MASK1 | PACKET_CONTROL_SEND_MASK2))
	{
		LOGPF(7, "(%p) Processing Send Mask %x %x", pEPD, MaskArray[3], MaskArray[2]);
		ProcessSendMask(pEPD, pFrame->bSeq, MaskArray[2], MaskArray[3]);
	}

	// NOTE: ProcessSendMask may have advanced N(R)

	// We can receive this frame.   Copy relevant info into Receive descriptor
	if((pThisRCD = pRCD = static_cast<PRCD>( RCDPool->Get(RCDPool) )) == NULL)
	{
		LOGPF(0, "(%p) Failed to allocate new RCD", pEPD);
		Unlock(&pEPD->EPLock);
		return DPN_OK;
	}

	pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;	// State has changed.  Make sure it gets sent.

 	pRCD->bSeq = bSeq;
	pRCD->bFrameFlags = pFrame->bCommand;
 	pRCD->bFrameControl = pFrame->bControl;
	pRCD->pbData = (PBYTE) (((PBYTE) pFrame) + header_size);
	pRCD->uiDataSize = dwDataLength - header_size;
	pRCD->tTimestamp = tNow;
	pRCD->pRcvBuff = pRcvBuffer;

	// Update our receiving state info.
	//
	//	RCDs go onto one of two queues.  If it is the next numbered (expected) frame then it is
	// placed on the ReceiveList (in EPD).  If this frame completes a message it can now be
	// indicated.  If this frame fills a hole left by previous frames then a condensation with
	// the second list must occur.
	//	If it is not the next numbered frame then it is placed,  in order,  on the MisOrdered frame
	// list,  and the bitmask is updated.
	//
	//	Condensation of lists is performed by testing the LSB of the ReceiveMask. Each time LSB is set,
	// the first frame on the list can be moved to the ReceiveList, and the mask is shifted right.
	// As each frame is moved to the ReceiveList,  the EOM flag must be checked for and if set,  then
	// everything on the ReceiveList should be moved to the CompleteList for indication to the user.

	pEPD->uiBytesReceived += dwDataLength;				// track statistics

	if(bSeq == pEPD->bNextReceive)
	{
		// Frame is the next expected # in sequence

		LOGPF(7, "(%p) Receiving In-Order Frame, pRCD[%p]", pEPD, pRCD);
		ReceiveInOrderFrame(pEPD, pRCD);				// Build frame into message AND move adjacent frames off OddFrameList

		// See if we need to respond right away...
		//
		//	Because there are lots of way to generate POLL bits (full window, empty queue, poll count) we sometimes find ourselves
		// generating too much dedicated ack-traffic.  Therefore,  we will treat the POLL not as Respond-Immediately but instead as
		// Respond-Soon. We will not wait the full Delayed_Ack_Timeout interval but we will wait long enough to allow a quick piggyback
		// response (say 5ms) (we may want this longer on a slow connection...)

		// Is he asking for an instant response?
		if(pFrame->bControl & PACKET_CONTROL_CORRELATE)
		{
			LOGPF(7, "(%p) Sending Ack Frame", pEPD);
			SendAckFrame(pEPD, 0);						// Send Ack w/timing info
		}
		// Is he asking for a response soon?
		else if(pFrame->bCommand & PACKET_COMMAND_POLL)
		{
			if(pEPD->ulEPFlags & EPFLAGS_USE_POLL_DELAY)
			{		
				if(pEPD->DelayedAckTimer != NULL)
				{
					LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
					if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique)!= DPN_OK)
					{
						LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
						LOCK_EPD(pEPD, "LOCK (re-start delayed ack timer)");
					}
				}
				else 
				{
					LOCK_EPD(pEPD, "LOCK (start short delayed ack timer)");
				}
				LOGPF(7, "Delaying POLL RESP");
				pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

				LOGPF(7, "(%p) Setting Delayed Ack Timer", pEPD);
				SetMyTimer(4, 4, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
			}
			else 
			{
				LOGPF(7, "(%p) Sending Ack Frame", pEPD);
				SendAckFrame(pEPD, 0);						// Send Ack w/timing info
			}
		}
		else if(pEPD->DelayedAckTimer == 0){			// If timer is not running better start it now
			LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");	// Bump RefCnt for timer
			SetMyTimer(DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}
	}		// IF frame is in order

	// Frame arrives out of order
	else 
	{	
		bit = (BYTE) ((bSeq - pEPD->bNextReceive) - 1);						// bit location in mask for this frame

		// Make sure this is not a duplicate frame
		if( ((bit < 32) && (pEPD->ulReceiveMask & (1 << bit))) || ((bit > 31) && (pEPD->ulReceiveMask2 & (1 << (bit - 32)))) ) 
		{
			LOGPF(3, "(%p) REJECT DUPLICATE OUT-OF-ORDER Frame Seq=%x", pEPD, bSeq);
		
			Unlock(&pEPD->EPLock);
			RCDPool->Release(RCDPool, pRCD);
			return DPN_OK;
		}
		
		LOGPF(7, "(%p) Receiving Out-of-Order Frame, pRCD[%p]", pEPD, pRCD);
		ReceiveOutOfOrderFrame(pEPD, pRCD, bit);

		if(pFrame->bCommand & PACKET_COMMAND_POLL)
		{
			if(pEPD->DelayedAckTimer != NULL)
			{
				LOGPF(7, "(%p) Cancelling Delayed Ack Timer", pEPD);
				if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique)!= DPN_OK)
				{
					LOGPF(7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					LOCK_EPD(pEPD, "LOCK (re-start delayed ack timer)");
				}

				// Start an abreviated delayed ack timer in case NACK gets cancelled
			}
			else 
			{
				LOCK_EPD(pEPD, "LOCK (start short delayed ack timer)");
			}

			LOGPF(7, "Delaying POLL RESP");
			pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

			LOGPF(7, "(%p) Setting Delayed Ack Timer", pEPD);
			SetMyTimer(5, 5, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}

	}	
	// EPD->StateLock is still HELD
	//
	// We use a FLAG for exclusive access to ReceiveComplete routine. This is safe because the flag is only
	// tested and modified while holding the EPD->StateLock.  Lets be sure to keep it that way...

	if( (!pEPD->blCompleteList.IsEmpty()) && ((pEPD->ulEPFlags & EPFLAGS_IN_RECEIVE_COMPLETE) == FALSE))
	{
		LOGPF(7, "(%p) Completing Receives", pEPD);
		pEPD->ulEPFlags |= EPFLAGS_IN_RECEIVE_COMPLETE;	// ReceiveComplete will clear this flag when done
		ReceiveComplete(pEPD); 							// Deliver the goods,  returns with EPLock released
	}
	else 
	{
		Unlock(&pEPD->EPLock);
	}

	if(pEPD->ulEPFlags & EPFLAGS_COMPLETE_SENDS)
	{
		LOGPF(7, "(%p) Completing Sends", pEPD);
		CompleteSends(pEPD);
	}

	return DPNERR_PENDING;
}

/*
**		Receive In Order Frame
**
**		The interesting part of this function is moving frames off of the OddFrameList that
**	the new frame adjoins.  This may also be called with a NULL frame which will happen when
**	a cancelled frame is the next-in-order receive.
**
**		One result of having cancelled frames running around is that we may miss the SOM or EOM
**	flags which delimit messages.  Therefore, we must watch as we assemble messages that we do not
**	see unexpected flags,  ie a new message w/o an SOM on first frame which means that part of the
**	message must have been lost,  and the whole thing must be trashed...
**
**	** EPLOCK is HELD through this entire function **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveInOrderFrame"

VOID
ReceiveInOrderFrame(PEPD pEPD, PRCD pRCD)
{
	CBilink	*pLink;
	UINT	flag;

	// Condensing Loop  WHILE (Next In-Order Frame has been received)
	do 
	{	
		// BUGBUG: Note that we may be stuffing an older time into tLastDataFrame, is that okay?
		pEPD->tLastDataFrame = pRCD->tTimestamp;		// Always keep the receive time of (N(R) - 1)
		pEPD->bLastDataRetry = (pRCD->bFrameControl & PACKET_CONTROL_RETRY);
#ifdef	DEBUG
		pEPD->bLastDataSeq = pRCD->bSeq;
#endif
		pRCD->pMsgLink = NULL;
		if(pEPD->pNewMessage == NULL)
		{				
			// Add this frame to the in-order rcv list
			ASSERT(pEPD->pNewTail ==  NULL);		// pNewMessage implies we have no current message, head or tail

			pEPD->pNewMessage = pRCD;				// Even if we get rid of it, we will need this below

			if((pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)==0)
			{
				// Oops!  There is no NEW_MESSAGE flag on the first frame we see. Bad news guys.  We must
				// have lost the first frame.  This had better be an UNRELIABLE message and we can throw
				// this frame away...

				ASSERT(!(pRCD->bFrameFlags & PACKET_COMMAND_RELIABLE));	// we better not have a RELIABLE fragment in here
				LOGPF(7, "(%p) Scrapping frame (%x)", pEPD, pRCD->bSeq);
				pRCD->ulRFlags |= RFLAGS_FRAME_LOST;
				pRCD->bFrameFlags |= PACKET_COMMAND_END_MSG;			// Turn this on so we will release buffer right away
			}
			else
			{
				pRCD->uiFrameCount = 1;
				pRCD->uiMsgSize = pRCD->uiDataSize;
				pEPD->pNewTail = pRCD;
				LOGPF(7, "(%p) Queuing Frame (NEW MESSAGE) (%x)", pEPD, pRCD->bSeq);
			}
		}
		else 
		{
			ASSERT((!(pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)) || (pRCD->ulRFlags & RFLAGS_FRAME_LOST));
			ASSERT((pEPD->pNewTail->bSeq) == (BYTE)(pRCD->bSeq - 1)); // Make sure they stay sequential
			
			pEPD->pNewTail->pMsgLink = pRCD;
			pEPD->pNewMessage->uiFrameCount++;
			pEPD->pNewMessage->uiMsgSize += pRCD->uiDataSize;
			pEPD->pNewMessage->ulRFlags |= (pRCD->ulRFlags & RFLAGS_FRAME_LOST);// UNION FRAME_LOST flag from all message elements
			pEPD->pNewTail = pRCD;
			LOGPF(7, "(%p) Queuing Frame (ON TAIL) (%x)", pEPD, pRCD->bSeq);
		}

		if(pRCD->bFrameFlags & PACKET_COMMAND_END_MSG) 
		{
			// Either this frame completes a message or we decided to drop this one above

			// All frames on the ReceiveList should now be removed and delivered

			// Get either the message we are dropping above, or the beginning of the sequence of messages we are completing
			pRCD = pEPD->pNewMessage;
			pEPD->pNewMessage = NULL;

			if(pRCD->ulRFlags & RFLAGS_FRAME_LOST)
			{
				// We need to throw this away
				LOGPF(7, "(%p) Throwing away message with missing frames Seq=%x", pEPD, pRCD->bSeq);
				pEPD->pNewTail = NULL;
				DropReceive(pEPD, pRCD);
			}
			else
			{
				// We need to complete this sequence
				pRCD->blCompleteLinkage.InsertBefore( &pEPD->blCompleteList);	// place on end of Completion list
				LOGPF(7, "(%p) Adding msg to complete list FirstSeq=%x, LastSeq=%x QueueSize=%d", 
																pEPD, pRCD->bSeq, pEPD->pNewTail->bSeq, pEPD->uiCompleteMsgCount);
				pEPD->pNewTail = NULL;
				pEPD->uiCompleteMsgCount++;
			}
		}

		// 		Since we are allowing out of order indication of receives it is possible that frames later than
		// the new one have already been indicated.  This means that there may be bits set in the ReceiveMask
		// whose correlating frames do not need to be indicated.  The most straightforward way to implement this
		// is to leave the early-indicated frames in the list,  but mark them as INDICATED_NONSEQ.  So inside this
		// master DO loop there will be an inner DO loop which passes over INDICATED frames and just takes them off
		// the list.
		//
		//		Now its possible that a NonSeq indicated frame is still sitting on the CompleteList awaiting indication,
		// so I am using a ref count.  An extra ref is added when a frame is completed non-seq.  When a completed frame
		// is removed below we will release one reference,  and the indication code will release one reference when it
		// finishes on that end.  Happily,  we can release the actual buffers while the RCD turd is still sitting on the
		// OddFrameList.

		BOOL fIndicatedNonSeq = FALSE;
		do 
		{
			flag = pEPD->ulReceiveMask & 1;				// set flag if next frame in stream is present

			pEPD->bNextReceive += 1;					// Update receive window
			RIGHT_SHIFT_64(pEPD->ulReceiveMask2, pEPD->ulReceiveMask);// shift mask because base has changed
			LOGPF(7, "(%p) N(R) incremented to %x, Mask %x %x", pEPD, pEPD->bNextReceive, pEPD->ulReceiveMask2, pEPD->ulReceiveMask);

			if(flag) 
			{
				// The next frame in the sequence has arrived already since low bit of ulReceiveMask was set

				// Several things can happen here:
				// 1) We are in the middle of a message, in which case, its next piece is on the out of order list
				// 2) We have just finished a message, which leaves two subcases:
				//		a) We are beginning a new message.  In this case our first piece is on the out of order list
				//		b) Out-of-order non-sequential messages have completed while we were completing our in-order message
				//		   In this case there are some already indicated RCDs on the out of order list, and a new partial
				//		   message may or may not follow.
				pLink = pEPD->blOddFrameList.GetNext();

				ASSERT(pLink != &pEPD->blOddFrameList); // Make sure we didn't run out of RCDs on the list
				pRCD = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
				pLink->RemoveFromList();							// take next frame out of OddFrameList

				pRCD->ulRFlags &= ~(RFLAGS_ON_OUT_OF_ORDER_LIST);
				
				// Make sure everything previous got removed from the odd frame list, and it is sorted correctly
				ASSERT(pRCD->bSeq == pEPD->bNextReceive);

				if (pRCD->ulRFlags & RFLAGS_FRAME_INDICATED_NONSEQ)
				{
					fIndicatedNonSeq = TRUE;

					LOGPF(7, "(%p) Pulling Indicated-NonSequential message off of Out-of-Order List Seq=%x", pEPD, pRCD->bSeq);

					pEPD->tLastDataFrame = pRCD->tTimestamp;		// Always keep the receive time of (N(R) - 1)
					pEPD->bLastDataRetry = (pRCD->bFrameControl & PACKET_CONTROL_RETRY);
					DEBUG_ONLY(pEPD->bLastDataSeq = pRCD->bSeq);

					RELEASE_RCD(pRCD);
				}
				else
				{
					// In the case of cancelling one of the messages in the middle of a large message,
					// we will drop all previous, drop that one, and then we will get to a situation where we aren't
					// currently working on a new message (pNewMessage was NULL'ed in the cancelling) and the current 
					// message does not have the NEW_MSG flag, in which case we scrap it above.
//					ASSERT(!fIndicatedNonSeq || (pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG));
					ASSERT(!fIndicatedNonSeq || (pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG) ||
						(!pEPD->pNewMessage && !(pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)));

					// go ahead and move this to the receive list
					LOGPF(7, "(%p) Moving OutOfOrder frame to received list Seq=%x", pEPD, pRCD->bSeq);
					break;
				}
			}
		} 
		while (flag);	// DO WHILE (There are still in order frames that have already arrived with no incomplete messages)
	} 
	while (flag);		// DO WHILE (There are still in order frames that have already arrived with an incomplete message)

	if((pEPD->ulReceiveMask | pEPD->ulReceiveMask2)==0)
	{
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
		if(((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)&&(pEPD->DelayedMaskTimer != NULL))
		{
			LOGPF(7, "(%p) Cancelling Delayed Mask Timer", pEPD);
			if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
			{
				RELEASE_EPD(pEPD, "UNLOCK (cancel DelayedMask)"); // SendQLock not already held
				pEPD->DelayedMaskTimer = 0;
			}
			else
			{
				LOGPF(7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
			}
		}
	}
}

/*
**		Receive Out Of Order Frame
**
**		Its like the title says.  We must set the appropriate bit in the 64-bit ReceiveMask
**	and then place it into the OddFrameList in its proper sorted place.  After that,  we must
**	scan to see if a complete message has been formed and see if we are able to indicate it
**	early.
**
**	** EPLOCK is HELD through this entire function **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveOutOfOrderFrame"

VOID
ReceiveOutOfOrderFrame(PEPD pEPD, PRCD pRCD, ULONG bit)
{
	PRCD	pRCD1;
	PRCD	pRCD2;
	CBilink	*pLink;
	BYTE	NextSeq;
	BYTE	mask;
	ULONG	highbit;
	ULONG	Mask;
	ULONG	WorkMaskHigh;
	ULONG	WorkMaskLow;
	ULONG	MaskHigh;
	ULONG	MaskLow;
	BOOL	nack = FALSE;
	UINT	count;
	BOOL	lost = FALSE;

	UINT	frame_count = 0;
	UINT	msg_length = 0;

	//	RECEIVE OUT OF ORDER FRAME
	//
	//  DO WE SEND IMMEDIATE ACK FOR THIS OUT OF ORDER FRAME?
	//
	//		When we receive an OutOfOrder frame it is almost certainly because the missing frame has been lost.
	// So we can accelerate the re-transmission process greatly by telling partner right away that frames
	// are missing. HOWEVER,  with a large send window we will get many mis-ordered frames for each drop,
	// but we only want to send a Negative Ack once.  SO, we will only initiate a NACK here if we have
	// created a NEW HOLE in our receive mask!
	//
	// 		First,  we will not have created a new hole unless we added to the END of the OddFrameList.
	//		Second, we will not have created a new hole unless the FIRST BIT TO THE RIGHT of the new bit
	//	is CLEAR.
	//
	//	So we will only generate an immediate NACK frame if both of the above cases are true!
	//	NOTE - if this is the only OoO frame, then we should always send a NACK
	//
	//  ANOTHER NOTE.  SP  implementation has been changed so that it frequently misorders receives in close
	// proximity.  One effect of this is that we must not immediately send a NACK for an out of order frame, but
	// instead should wait a short period (say ~5ms) and see if the missing frame hasnt showed up.  What a drag...

	// Make sure this RCD is within the receive window
//	ASSERT((BYTE)(pRCD->bSeq - pEPD->bNextReceive) < (BYTE)MAX_FRAME_OFFSET);
		
	pRCD->ulRFlags |= (RFLAGS_FRAME_OUT_OF_ORDER | RFLAGS_ON_OUT_OF_ORDER_LIST);
	
	
	// We will insert frame in OddFrameList maintaining sort by Seq number
	//
	// We can optimize for most likely case,  which is new frames are added to END of list.  We can
	// check for this first case by investigating whether the new bit is the left-most bit in the mask.
	// If it is LMB,  then it trivially gets added to the END of the list.
	//
	// Please note that both this and the following algorithms assume that we have already verified
	// that the new frame is NOT already in the list

	MaskLow = pEPD->ulReceiveMask;					// Get scratch copy of Mask
	MaskHigh = pEPD->ulReceiveMask2;

	if(bit < 32)
	{									
		// Frame is within 32 of N(Rcv)	
		WorkMaskLow = 1 << bit;						// Find bit in mask for new frame
		WorkMaskHigh = 0;
		pEPD->ulReceiveMask |= WorkMaskLow;			// Set appropriate bit in mask

		if( (MaskLow & (WorkMaskLow >> 1)) == 0){	// check immediately preceeding bit for NACK determination
			nack = TRUE;							// preceeding bit is not set
		}
	}
	else {
		highbit = bit - 32;
		WorkMaskHigh = 1 << highbit;
		WorkMaskLow = 0;
		pEPD->ulReceiveMask2 |= WorkMaskHigh;		// Set appropriate bit in mask

		if(highbit){
			if( (MaskHigh & (WorkMaskHigh >> 1)) == 0){	// check preceeding bit for NACK determination
				nack = TRUE;						// preceeding bit is not set
			}
		}
		else{
			if( (MaskLow & 0x80000000) == 0){
				nack = TRUE;
			}
		}
	}

	// Insert frame in sorted OddFrameList.
	//
	//		First test for trivial insert at tail condition.  True if new bit is LEFTMOST set bit in
	// both masks.

	if( (WorkMaskHigh > MaskHigh) || ( (MaskHigh == 0) && (WorkMaskLow > MaskLow) ) )
	{	
		// TAIL INSERTION
		LOGPF(7, "(%p) Received %x OUT OF ORDER - INSERT AT TAIL NRcv=%x MaskL=%x MaskH=%x",
							pEPD, pRCD->bSeq, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
		pLink = &pEPD->blOddFrameList;

		// Make sure this is either the only RCD in the list, or it is farther in the window than the last one
//		ASSERT(pLink->IsEmpty() || ((BYTE)(CONTAINING_RECORD(pLink->GetPrev(), RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));
		pRCD->blOddFrameLinkage.InsertBefore( pLink);

		// Check to see if we should NACK (negative acknowledge) any frames.  We only want to NACK a given
		// frame once so we will NACK if this is the first frame added to the OOF list,  or if the immediately
		// preceeding frame is missing.  First condition is trivial to test.

		if( ((MaskLow | MaskHigh) == 0) || (nack == 1) )
		{
			pEPD->ulEPFlags |= EPFLAGS_DELAYED_NACK;
			
			if(pEPD->DelayedMaskTimer == 0)
			{
				LOGPF(7, "(%p) Setting Delayed Mask Timer", pEPD);
				LOCK_EPD(pEPD, "LOCK (DelayedMaskTimer)");	// Bump RefCnt for timer
				SetMyTimer(SHORT_DELAYED_ACK_TIMEOUT, 5, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
				pEPD->tReceiveMaskDelta = GETTIMESTAMP();
			}
			else 
			{
				LOGPF(7, "(%p) *** DELAYED NACK *** Timer already running", pEPD);
			}
		}
	}
	else 
	{	
		// NOT TAIL INSERTION

		// This is the non-trivial case,  ie new frame goes at beginning or in middle of OddFrameList.
		// So we need to count the ONE bits that are to the RIGHT of the new bit in the ReceiveMask.
		// We will mask off bits higher then the New Bit and then do a quick bit-count...

		LOGPF(7, "(%p) Receive OUT OF ORDER - Walking Frame List (Seq=%x, NRcv=%x) MaskL=%x MaskH=%x", 	pEPD, pRCD->bSeq, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);

		// If we are inserting into high mask,  we must count all one-bits in low mask
		//
		// We will test for the special case of all-bits-set at the outset...

		pLink = pEPD->blOddFrameList.GetNext();			// pLink = First frame in list; we will walk list as we count

		if(WorkMaskHigh)
		{
			// new frame in high mask. only count bits to right of new bit
			WorkMaskHigh -= 1;						// Convert to mask preserving all bits to right of new bit
			WorkMaskHigh &= MaskHigh;				// WMH now represents all bits to right of new bit
			while(WorkMaskHigh)
			{
				// Make sure this is farther in the window than the one we are skipping
//				ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

				// Count bits in WMH
				Mask = WorkMaskHigh - 1;
				WorkMaskHigh &= Mask;
				pLink = pLink->GetNext();
			}
			if(MaskLow == 0xFFFFFFFF)
			{
				// special case if low mask is full
				for(count = 0; count < 32; count++)
				{
					// Make sure this is farther in the window than the one we are skipping
//					ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

					pLink = pLink->GetNext();
				}
			}
			else
			{					
				// else count all bits in lower mask
				while(MaskLow)
				{
					// Make sure this is farther in the window than the one we are skipping
//					ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

					Mask = MaskLow - 1;
					MaskLow &= Mask;			// Mask off low 1-bit
					pLink = pLink->GetNext();
				}
			}
		}
		else 
		{
			WorkMaskLow -= 1;
			WorkMaskLow &= MaskLow;					// WML == bits to the right of new bit

			while(WorkMaskLow)
			{
				// Make sure this is farther in the window than the one we are skipping
//				ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

				Mask = WorkMaskLow - 1;
				WorkMaskLow &= Mask;				// Mask off low 1-bit
				pLink = pLink->GetNext();
			}
		}

		// Make sure this is farther in the window than the last one
//		ASSERT(((BYTE)(CONTAINING_RECORD(pLink->GetPrev(), RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

		pRCD->blOddFrameLinkage.InsertBefore( pLink);		// Insert new frame in sorted list
	}  // Receive not at tail

	// 	**	Non-Sequential Indication
	//
	//		This is the Non-Trivial implementation of non-sequential receive indication.
	//	We will work from the assumption that we  only need to complete messages that are touched by the new frame.
	//	So we must back up in the OddFrame list until we see either a gap or a Start of Message marker. Then we must work
	// 	forward looking for an End of Message...
	//
	//		One more complication is the fact that dropped packets might in the list via place-holding dummies.  Since we
	//	do not know what SOM/EOM flags would have been present on a dropped frame,  we can consider them to have BOTH flags.
	//	Then we also need to be aware that frames bordering on dropped frames without a delimiter (SOM or EOM) are fragments
	//	and therefore count as dropped data too.  I think to keep this from getting too complex,  we wont probe further for
	//	neighbors of lost data frames.  We will discover them when we are building a message later.
	//
	//	pLink = Item after new element in Out of Order list
	//	pRCD  = new Item

	// IF this frame is not marked as SEQUENTIAL
	if((pRCD->bFrameFlags & PACKET_COMMAND_SEQUENTIAL)==0)
	{	
		LOGPF(7, "(%p) Received Non-Seq %x out of order; flags=%x", pEPD, pRCD->bSeq, pRCD->bFrameFlags);
		NextSeq = pRCD->bSeq;
			
		// NOTE: The first pLink will be the passed in RCD so we will have included that in the frame_count and msg_length after leaving this while
		while ( (pLink = pLink->GetPrev()) != &pEPD->blOddFrameList )
		{
			pRCD1 = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);

			frame_count++;
			msg_length += pRCD1->uiDataSize;

			if((pRCD1->bFrameFlags & PACKET_COMMAND_NEW_MSG) || (pRCD1->bSeq != NextSeq))
			{
				break;		// Stop probing when we find a NEW_MSG flag OR a gap in the frame sequence numbers
			}
			--NextSeq;
		}

		// We have either found a NEW_MSG or a sequence gap.  If its a NEW_MSG, then we probe forward for an END_MSG
		if((pRCD1->bFrameFlags & PACKET_COMMAND_NEW_MSG) && (pRCD1->bSeq == NextSeq))
		{
			// So far so good.  We have a sequential message start frame
			//
			//	pRCD  = frame just arrived
			//	pRCD1 = Start of message frame
			//	pLink = Start of message linkage

			pLink = &pRCD->blOddFrameLinkage;
			NextSeq = pRCD->bSeq;

			// Look for the message end or a sequence gap
			while ( ( (pRCD->bFrameFlags & PACKET_COMMAND_END_MSG)==0 ) && (pRCD->bSeq == NextSeq))
			{
				// Stop if we hit the end of the OddFrameList
				if((pLink = pLink->GetNext()) == &pEPD->blOddFrameList)
				{
					break;
				}

				// NOTE: the first pLink here will be the one after the passed in RCD.  If there is a gap that won't 
				// matter because we are out of here after the next if.  If it is the next message we will continue until
				// we hit the END_MSG and have a proper frame_count and msg_length.
				pRCD = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
				frame_count++;
				msg_length += pRCD->uiDataSize;
				NextSeq++;
			}

			// pLink should not be used after this point due to the way the above while could have left it either valid
			// or at &pEPD->blOddFrameList.
			pLink = NULL;

			if((pRCD->bFrameFlags & PACKET_COMMAND_END_MSG) && (pRCD->bSeq == NextSeq))
			{
				// We have completed a message
				//
				// pRCD1 = First frame in message
				// pRCD = Last frame in message

				LOGPF(7, "(%p) Completed Non-Seq Msg: First=%x, Last=%x", pEPD, pRCD1->bSeq, pRCD->bSeq);

				lost = FALSE;

				pRCD->ulRFlags |= RFLAGS_FRAME_INDICATED_NONSEQ;
				pRCD->pMsgLink = NULL;
				lost |= pRCD->ulRFlags & RFLAGS_FRAME_LOST;
				
				// Get the pointer to the next to last message so we can remove the last
				pLink = pRCD->blOddFrameLinkage.GetPrev();
				LOCK_RCD(pRCD); // ReceiveInOrderFrame must remove this

				// Walk from the last message to the first message accumulating lost flags, linking messages, 
				// setting indicated flag, and pulling off of the odd frame list
				while (pRCD != pRCD1)
				{
					ASSERT(pLink != &pEPD->blOddFrameList); // Make sure we didn't run out of RCDs on the list
					pRCD2 = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
					pRCD2->pMsgLink = pRCD;
					LOCK_RCD(pRCD2); // ReceiveInOrderFrame must remove this

					pRCD2->ulRFlags |= RFLAGS_FRAME_INDICATED_NONSEQ;
					lost |= pRCD2->ulRFlags & RFLAGS_FRAME_LOST;
					pLink = pRCD2->blOddFrameLinkage.GetPrev();

					pRCD = pRCD2;
				}
				
				// Both RCD and RCD1 point to the first message now

				// If any were lost, drop the receive, otherwise complete it
				if(!lost)
				{
					pRCD->uiFrameCount = frame_count;
					pRCD->uiMsgSize = msg_length;
					pRCD->blCompleteLinkage.InsertBefore( &pEPD->blCompleteList);
					pEPD->uiCompleteMsgCount++;
				}
				else
				{
					LOGPF(7, "(%p) Complete Non-Seq MSG is dropped due to missing frames", pEPD);
					DropReceive(pEPD, pRCD);
				}
			}
		} // else  there is nothing to complete at this time...
	}	// IF NON SEQUENTIAL
}

/*
**		Drop Receive
**
**			One or more frames composing a message have been dropped,  so the entire message can be scrapped.
**		If this was determined during an out of order receive then the RCDs will remain on the OddFrameList
**		as usual.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DropReceive"

VOID
DropReceive(PEPD pEPD, PRCD pRCD)
{
	PRCD 					pNext;
	PSPRECEIVEDBUFFER		pRcvBuff = NULL;
	
	while(pRCD != NULL)
	{
		LOGPF(7, "(%p) dropping receive frame %x", pEPD, pRCD->bSeq);

		if(pRCD->pRcvBuff)
		{
			RELEASE_SP_BUFFER(pRCD->pRcvBuff);
		}

		pNext = pRCD->pMsgLink;
		RELEASE_RCD(pRCD);
		pRCD = pNext;
	}
	if(pRcvBuff != NULL)
	{
		LOGPF(6, "(%p) Calling SP->ReturnReceiveBuffers", pEPD);
		IDP8ServiceProvider_ReturnReceiveBuffers(pEPD->pSPD->IISPIntf, pRcvBuff);
	}
}

/*
**		Receive Complete
**
**		We have received an entire reliable message,  potentially spanning
**	multiple messages.  We are still on the receive thread right now so depending
**	upon our desired indication behavior we will either indicate it directly or
**	else queue it to be indicated on a background thread of some sort.
**
**		Messages spanning multiple frames (for now) will be copied into a contiguous
**	buffer for delivery.  CODEWORK -- Server implementations should be able to receive
**	large messages as buffer chains (or arrays of BufDescs).
**
**		This is also where we must notice that an End Of Stream flag is set in a message,
**	indicating that the connection is being closed.
**
**	*** CALLED WITH EPD->STATELOCK HELD *** RETURNS WITH STATELOCK RELEASED  ***
*/

#ifdef	DEBUG
	// For Debugging we will track the total number of receives outstanding in the higher layers
	// at all times.
LONG	ThreadsInReceive	= 0;
LONG	BuffersInReceive	= 0;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveComplete"

VOID
ReceiveComplete(PEPD pEPD)
{
	CBilink					*pLink;
	PRCD					pRCD;
	PRCD					pNext;
	PSPRECEIVEDBUFFER		pRcvBuff = NULL;
	PBIGBUF					pBuf;
	PBYTE					write;
	UINT					length;
	UINT					frames;
	DWORD					flag;
	UINT					MsgSize;
	HRESULT					hr;


	while((pLink = pEPD->blCompleteList.GetNext()) != &pEPD->blCompleteList)
	{
		pLink->RemoveFromList();
		ASSERT(pEPD->uiCompleteMsgCount > 0);
		pEPD->uiCompleteMsgCount--;
		
		Unlock(&pEPD->EPLock);
		pRCD = CONTAINING_RECORD(pLink, RCD, blCompleteLinkage);
		
		// Handle easy case first
		if(pRCD->uiFrameCount == 1)
		{						
			if(pRCD->uiDataSize > 0)
			{
				pEPD->uiMessagesReceived++;
				
				if(pRCD->bFrameFlags & PACKET_COMMAND_RELIABLE)
				{
					pEPD->uiGuaranteedFramesReceived++;
					pEPD->uiGuaranteedBytesReceived += pRCD->uiDataSize;
				}
				else
				{
					pEPD->uiDatagramFramesReceived++;
					pEPD->uiDatagramBytesReceived += pRCD->uiDataSize;
				}
				
				pRCD->pRcvBuff->dwProtocolData = RBT_SERVICE_PROVIDER_BUFFER;
				pRCD->pRcvBuff->pServiceProviderDescriptor = pEPD->pSPD;
				flag = (((DWORD) pRCD->bFrameFlags) & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);

				DEBUG_ONLY(InterlockedIncrement(&ThreadsInReceive));
				DEBUG_ONLY(InterlockedIncrement(&BuffersInReceive));
				LOGPF(6, "(%p) Calling Core->IndicateReceive, pRCD[%p]", pEPD, pRCD);
				if(pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pRCD->pbData, pRCD->uiDataSize, pRCD->pRcvBuff, flag) == DPN_OK)
				{
					RELEASE_SP_BUFFER(pRCD->pRcvBuff);		// Really only queues it to be released
					DEBUG_ONLY(InterlockedDecrement(&BuffersInReceive));
					DEBUG_ONLY(InterlockedDecrement(&ThreadsInReceive));
				}
				DEBUG_ONLY(InterlockedDecrement(&ThreadsInReceive));
			}
			else 
			{
				//	If DataSize == 0 & EOS is not set,  then this was a keep alive message and is ignored
				if(pRCD->bFrameControl & PACKET_CONTROL_END_STREAM)
				{  
					// END OF STREAM indicated
					LOGPF(7, "(%p) Processing EndOfStream, pRCD[%p]", pEPD, pRCD);
					ProcessEndOfStream(pEPD);
				}
				
				RELEASE_SP_BUFFER(pRCD->pRcvBuff);			// Really only queues it to be released
			}
			
			RELEASE_RCD(pRCD);								// Release reference for Complete Processing
		}
		else 
		{											
			// Multiple buffers.  Need to copy data into contiguous buffer.
			if((MsgSize = pRCD->uiMsgSize) <= SMALL_BUFFER_SIZE)
			{
				pBuf = static_cast<PBIGBUF>( BufPool->Get(BufPool) );
			}
			else if (MsgSize <= MEDIUM_BUFFER_SIZE)
			{
				pBuf = static_cast<PBIGBUF>( MedBufPool->Get(MedBufPool) );
			}
			else if (MsgSize <= LARGE_BUFFER_SIZE)
			{
				pBuf = static_cast<PBIGBUF>( BigBufPool->Get(BigBufPool) );
			}
			else
			{
				LOGPF(7, "(%p) RECEIVE HUGE MESSAGE", pEPD);
				// Receive is larger then our biggest static receive buffer.  This means we have to allocate a dynamic buffer.
				pBuf = (PBIGBUF) MALLOC(MsgSize + sizeof(DYNBUF));
				if(pBuf)
				{
					pBuf->Type = RBT_DYNAMIC_BUFFER;
				}	
			}
			
			if(pBuf == NULL)
			{
				LOGPF(0, "MEMORY ALLOC FAILED.  Cannot deliver data");
				while(pRCD != NULL)
				{
					pNext = pRCD->pMsgLink;
					RELEASE_SP_BUFFER(pRCD->pRcvBuff);
					RELEASE_RCD(pRCD);
					pRCD = pNext;
				}
				Lock(&pEPD->EPLock);
				continue;								// blow it off!
			}
			write = pBuf->data;							// initialize write pointer
			length = 0;
			frames = 0;
			while(pRCD != NULL)
			{
				memcpy(write, pRCD->pbData, pRCD->uiDataSize);
				write += pRCD->uiDataSize;
				length += pRCD->uiDataSize;
				frames++;
				pNext = pRCD->pMsgLink;
				flag = (DWORD) pRCD->bFrameFlags;
				RELEASE_SP_BUFFER(pRCD->pRcvBuff);
				RELEASE_RCD(pRCD);
				pRCD = pNext;
			}
			
			pEPD->uiMessagesReceived++;
			if(flag & PACKET_COMMAND_RELIABLE)
			{
				pEPD->uiGuaranteedFramesReceived += frames;
				pEPD->uiGuaranteedBytesReceived += length;
			}
			else
			{
				pEPD->uiDatagramFramesReceived += frames;
				pEPD->uiDatagramBytesReceived += length;
			}
			
			flag = (flag & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);
			LOGPF(6, "(%p) Calling Core->IndicateReceive", pEPD);
			hr = pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pBuf->data, length, pBuf, flag);

			// BUGBUG: Don't we still need to free on fail?
			if(hr == DPN_OK)
			{
				if(pBuf->Type == RBT_PROTOCOL_BUFFER)
				{
					pBuf->Owner->Release(pBuf->Owner, pBuf);
				}
				else 
				{
					FREE(pBuf);
				}
			}
		}
		Lock(&pEPD->EPLock);
	}

	pEPD->ulEPFlags &= ~(EPFLAGS_IN_RECEIVE_COMPLETE);	// Clear this before releasing Lock final time
	Unlock(&pEPD->EPLock);

	if(pRcvBuff != NULL)
	{
		LOGPF(6, "(%p) Calling SP->ReleaseReceiveBuffers", pEPD);
		IDP8ServiceProvider_ReturnReceiveBuffers(pEPD->pSPD->IISPIntf, pRcvBuff);
	}
}


/*
**		Process Send Mask
**
**		The send mask is what our partner uses to tell us to stop waiting for particular frames.
**	This will happen after an Unreliable frame is dropped.  Instead of retransmitting the unreliable
**	frame,  the sender will forward the appropriate bit in a send mask.  In this routine,  we attempt
**	to update our receive state pursuant to the newly received mask.
**
**		THIS IS CALLED WITH STATELOCK HELD AND RETURNS WITH STATELOCK HELD
**
**		suffice it to say that we should not release statelock anywhere in the following
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessSendMask"

VOID
ProcessSendMask(PEPD pEPD, BYTE bSeq, ULONG MaskLow, ULONG MaskHigh)
{
	INT		deltaS;
	ULONG	workmaskS;
	BYTE	bThisFrame;
	UINT	skip;
	BOOL	receive = FALSE;

	ASSERT(MaskLow | MaskHigh);

	LOGPF(7, "(%p) PROCESS SEND MASK  N(R)=%x, bSeq=%x, MaskL=%x, MaskH=%x", pEPD, pEPD->bNextReceive, bSeq, MaskLow, MaskHigh);

	// The mask can only refer to frames earlier than the Seq number in this frame.  So if this frame
	// is the next In-Order then the mask can have nothing interesting in it.
	//
	// The SendMask is coded with decending frame numbers starting at the Seq in this frame - 1.
	// The ReceiveMask is coded with ascending frame numbers start at N(Rcv) + 1.
	//
	// We will walk forward through the rcvmask and backward through the sendmask looking for the magic combo
	// of a bit clear in the rcvmask and the corresponding bit set in the sendmask.  For each of these matches,
	// a dummy cancel frame can be 'received' for that sequence number.
	//
	// This would be fairly straightforward if it wasn't for the fact that both masks are 64 bits so the code has
	// to track which DWORD of each mask we are dealing with at any given time. 

top:

	if (bSeq != pEPD->bNextReceive)
	{
		deltaS = (INT) (((BYTE)(bSeq - pEPD->bNextReceive)) - 1);			// count of frames between first missing frame and sequence base of mask
		bThisFrame = pEPD->bNextReceive;

		if ( deltaS < ( MAX_FRAME_OFFSET - 1 ) ) 
		{
			// If the difference is greater then 32 frames then we need to look at the high mask first and
			// then fall through to the low mask.  Otherwise,  we can ignore the highmask and start with the low.
			while((deltaS > 31) && (MaskHigh)) // Any work to do in the upper bits?
			{
				workmaskS = 1 << (deltaS - 32); 	// walks bit positions backward in send mask
				
				// See if the next frame we are interested in is covered by this mask
				if(workmaskS & MaskHigh)
				{
					receive |= CancelFrame(pEPD, bThisFrame);
					MaskHigh &= ~workmaskS;

					// N(R) may have been bumped up multiple times by CancelFrame, reset to make sure we work with
					// up to date information.
					goto top;
				}
				else
				{
					bThisFrame++;
					deltaS--;
				}
			}

			if(deltaS > 31)
			{
				skip = deltaS - 31;								// how many bit positions did we skip
				bThisFrame += (BYTE) skip;
				deltaS -= skip;
			}

			while((deltaS >= 0) && (MaskLow)) // Any work to do in the lower bits?
			{
				workmaskS = 1 << deltaS;

				if(workmaskS & MaskLow)
				{
					receive |= CancelFrame(pEPD, bThisFrame);
					MaskLow &= ~workmaskS;

					// N(R) may have been bumped up multiple times by CancelFrame, reset to make sure we work with
					// up to date information.
					goto top;
				}
				else
				{
					bThisFrame++;
					deltaS--;
				}
			}
		}
	}
	else
	{
		LOGPF(7, "(%p) bSeq == N(R) = %x, nothing to do", pEPD, pEPD->bNextReceive);
	}

	// If timer is not running better start it now
	if((receive)&&(pEPD->DelayedAckTimer == 0))
	{	
		LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");		// Bump RefCnt for timer
		pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;
		LOGPF(7, "(%p) Setting Delayed Ack Timer", pEPD);
		SetMyTimer(DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "BuildCancelledRCD"

PRCD
BuildCancelledRCD(PEPD pEPD, BYTE bSeq)
{
	PRCD	pRCD;
	
	if((pRCD = static_cast<PRCD> (RCDPool->Get(RCDPool))) == NULL)
	{
		LOGPF(0, "Failed to allocate RCD");
		return NULL;
	}
	
 	pRCD->bSeq = bSeq;
	pRCD->bFrameFlags = PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG;
 	pRCD->bFrameControl = 0;
	pRCD->pbData = NULL;
	pRCD->uiDataSize = 0;
	pRCD->tTimestamp = GETTIMESTAMP();
	pRCD->pRcvBuff = NULL;
	pRCD->ulRFlags = RFLAGS_FRAME_LOST;

	return pRCD;
}

/*			Cancel Frame
**
**		An unreliable frame has been reported as lost by sender.  This means we should consider it acknowledged
**	and remove it from our receive window.  This may require us to place a dummy receive descriptor in the OddFrameList
**	to hold its place until the window moves past it.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CancelFrame"

BOOL
CancelFrame(PEPD pEPD, BYTE bSeq)
{
	PRCD	pRCD;
	ULONG	bit;

	LOGPF(7, "(%p) CANCEL FRAME: Seq=%x", pEPD, bSeq);

	// Trivial case is when the cancelled frame is at the front of the window.  In this case we can complete not only
	// this frame but any contiguous frames following it in the OddFrameList
	
	if(pEPD->bNextReceive == bSeq)
	{
		if((pRCD = BuildCancelledRCD(pEPD, bSeq)) == NULL)
		{
			return FALSE;
		}
		ReceiveInOrderFrame(pEPD, pRCD);
	}

	// Here we have to place a dummy node on the OddFrameList to represent this frame.
	else 
	{
		bit = (bSeq - pEPD->bNextReceive) - 1;							// bit location in mask for this frame

		// Make sure this is not a duplicate frame
		if( ((bit < 32) && (pEPD->ulReceiveMask & (1 << bit))) || ((bit > 31) && (pEPD->ulReceiveMask2 & (1 << (bit - 32)))) ) 
		{
			LOGPF(7, "(%p) Received CancelMask for frame that's already received Seq=%x", pEPD, bSeq);
			return FALSE;
		}
		
		if((pRCD = BuildCancelledRCD(pEPD, bSeq)) == NULL)
		{
			return FALSE;
		}
		ReceiveOutOfOrderFrame(pEPD, pRCD, bit);
	}

	return TRUE;
}


/*
**		Release Receive Buffer
**
**		The core calls this function to return buffers previously handed
**	over in an IndicateUserData call.  This call may be made before the
**	actual indication returns.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPReleaseReceiveBuffer"

HRESULT
DNPReleaseReceiveBuffer(HANDLE hBuffer)
{
	union {
		PBIGBUF 			pBuf;
		PSPRECEIVEDBUFFER	pRcvBuff;
	}					pBuffer;

	PSPD				pSPD;

	pBuffer.pBuf = (PBIGBUF) hBuffer;
	
	switch(pBuffer.pBuf->Type)
	{
		case RBT_SERVICE_PROVIDER_BUFFER:
			DEBUG_ONLY(InterlockedDecrement(&BuffersInReceive));

			pSPD = (PSPD) pBuffer.pRcvBuff->pServiceProviderDescriptor;
			pBuffer.pRcvBuff->pNext = NULL;

			LOGPF(6, "Calling SP->ReturnReceiveBuffers, pRcvBuff[%p]", pBuffer.pRcvBuff);
			IDP8ServiceProvider_ReturnReceiveBuffers(pSPD->IISPIntf, pBuffer.pRcvBuff);
			break;
			
		case RBT_PROTOCOL_BUFFER:
			pBuffer.pBuf->Owner->Release(pBuffer.pBuf->Owner, pBuffer.pBuf);
			break;

		case RBT_DYNAMIC_BUFFER:
			FREE(hBuffer);
			break;

		default:
			LOGPF(0, "RELEASE RECEIVE BUFFER CALLED WITH BAD PARAMETER");
			return DPNERR_INVALIDPARAM;
	}
	
	return DPN_OK;
}

/*
**		Complete Sends
**
**		Reliable sends are completed upon acknowlegement.  Acknowlegements are discovered inside
**	the UpdateXmitState routine while walking through the pending window.  Since the actual completion
**	event requires the user to be called,  state can change.  So the easiest thing to do is defer these
**	completion callbacks until we are finished walking and can release any state locks.  Also,  this way
**	we can defer the callbacks until after we have indicated any data which the acks were piggybacking on,
**	something which ought to have priority anyway.
**
**		So we will place all completed reliable sends onto a complete list and after all other processing
**	we will come here and callback everything on the list.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSends"

VOID CompleteSends(PEPD pEPD)
{
	PMSD	pMSD;
	CBilink	*pLink;

	Lock(&pEPD->EPLock);

	while( (pLink = pEPD->blCompleteSendList.GetNext()) != &pEPD->blCompleteSendList)
	{
		pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);

		if(pMSD->ulMsgFlags2 & MFLAGS_TWO_COMPLETE)
		{
			pLink->RemoveFromList();

			Unlock(&pEPD->EPLock);
			Lock(&pMSD->CommandLock);
			CompleteReliableSend(pEPD->pSPD, pMSD, DPN_OK);
			
			Lock(&pEPD->EPLock);
		}
		else 
		{
			break;		// These will complete in order, so stop checking when we see one that's not Complete.
		}
	}

	pEPD->ulEPFlags &= ~(EPFLAGS_COMPLETE_SENDS);
	
	Unlock(&pEPD->EPLock);
}

/*
**		Lookup CheckPoint
**
**		Walk the EndPoint's list of active CPs looking for one with the provided
**	response correlator.
**		We keep the CKPT queue sorted by age so the matches should be at the front
**	of the queue.  So as we pass by entries at the head we will check the age of each
**	and timeout the ones that are 4(RTT) or greater.
**		Since DG drops are reported by the partner,  we dont need to do any booking about
**	the orphaned checkpoints.
**
**		*!* This link's StateLock must be held on entry
*/

#ifdef	DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "DumpChkPtList"

VOID
DumpChkPtList(PEPD pEPD)
{
	CBilink	*pLink;
	PCHKPT	pCP;

	LOGPF(1, "==== DUMPING CHECKPOINT LIST ==== (pEPD = %p)", pEPD);
	
	pLink = pEPD->blChkPtQueue.GetNext();
	while(pLink != &pEPD->blChkPtQueue) 
	{
		pCP = CONTAINING_RECORD(pLink, CHKPT, blLinkage);
		LOGPF(1, "(%p) MsgID=%x; Timestamp=%x", pEPD, pCP->bMsgID, pCP->tTimestamp);
		pLink = pLink->GetNext();
	}
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "LookupCheckPoint"

PCHKPT LookupCheckPoint(PEPD pEPD, BYTE bRspID)
{
	CBilink	*pLink;
	PCHKPT	pCP;

	pCP = CONTAINING_RECORD((pLink = pEPD->blChkPtQueue.GetNext()), CHKPT, blLinkage);
	while(pLink != &pEPD->blChkPtQueue) 
	{
		// Look for checkpoint that matches correlator
		if(pCP->bMsgID == bRspID)
		{	
			pLink->RemoveFromList();
			return pCP;		
		}
		// We have passed the spot for this correlator!		
		else if ((bRspID - pCP->bMsgID) & 0x80)
		{				
			LOGPF(1, "(%p) CHECKPOINT NOT FOUND - Later Chkpt found in list (%x)", pEPD, bRspID);
			return NULL;
		}
		else 
		{
			pLink = pLink->GetNext();								// Remove ChkPts prior to the one received
			pCP->blLinkage.RemoveFromList();							// ..target and remove the stale ones.
			ChkPtPool->Release(ChkPtPool, pCP);					// we expect them to complete in order of queue
			pCP = CONTAINING_RECORD(pLink, CHKPT, blLinkage);
		}
	}

	LOGPF(1, "(%p) CHECKPOINT NOT FOUND -  EXHAUSTED LIST W/O MATCH (%x)", pEPD, bRspID);
#ifdef	DEBUG
	DumpChkPtList(pEPD);
#endif
	return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushCheckPoints"

VOID FlushCheckPoints(PEPD pEPD)
{
	PCHKPT	pCP;

	while(!pEPD->blChkPtQueue.IsEmpty())
	{
		pCP = CONTAINING_RECORD(pEPD->blChkPtQueue.GetNext(), CHKPT, blLinkage);
		pCP->blLinkage.RemoveFromList();
		ChkPtPool->Release(ChkPtPool, pCP);
	}
}

/*
**		Process End Of Stream
**
**		Our partner has initiated an orderly link termination.  He will not be
**	sending us any more data.  We are allowed to finish sending any data in our
**	pipeline, but should not allow any new sends to be accepted.  When our send
**	pipeline is emptied,  we should send an EOS frame and take down our
**	link.  Easiest way to do this is enqueue the EOS at the end of send queue now.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEndOfStream"

VOID ProcessEndOfStream(PEPD pEPD)
{
	PMSD	pMSD;

	Lock(&pEPD->EPLock);
	
	LOGPF(7, "(%p) Process EndOfStream", pEPD);

	// Have we started closing on this side?
	if((pEPD->ulEPFlags & EPFLAGS_TERMINATING)==0)
	{			
		// Our side has not started closing yet,  so our partner must have initiated a Disconnect.
		// We are allowed to finish sending all data in our pipeline,  but we should not accept
		// any new data.  We must deliver an indication to the application telling him that
		// Disconnection is now underway.
		//
		// Please note that we do not set the TERMINATING flag until the Disconnecting indication
		// returns.  This allows the application to send any final messages (last words) before
		// the gate is slammed shut.

		LOGPF(7, "(%p) Partner Disconnect received (refcnt=%d)", pEPD, pEPD->uiRefCnt);

		Unlock(&pEPD->EPLock);

		LOGPF(3, "(%p) Calling Core->IndicateDisconnect", pEPD);
		pEPD->pSPD->pPData->pfVtbl->IndicateDisconnect(pEPD->pSPD->pPData->Parent, pEPD->Context);

		Lock(&pEPD->EPLock);
		
		pEPD->ulEPFlags |= (EPFLAGS_TERMINATING | EPFLAGS_RECEIVED_DISCONNECT);	

		if((pEPD->ulEPFlags & EPFLAGS_SENT_DISCONNECT)==0)
		{
			if((pMSD = BuildDisconnectFrame(pEPD)) == NULL)
			{	
				DropLink(pEPD);									// DROPLINK will release SendQLock for us
				return;
			}

			pEPD->ulEPFlags |= EPFLAGS_SENT_DISCONNECT;

			LOCK_EPD(pEPD, "LOCK (DISC RESP)");					// Add reference for this frame
			pMSD->CommandID = COMMAND_ID_DISC_RESPONSE;			// Mark MSD so we know its not a user command
			pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_LOW_PRIORITY; // Priority is LOW so all previously submitted traffic will be sent

			LOGPF(7, "(%p) Responding to Disconnect. pMSD=0x%p", pEPD, pMSD);
			EnqueueMessage(pMSD, pEPD);							// Enqueue the DISC frame at end of sendQ
		}

		//	We will fall thru to the already closing case below.  We do this because lots might have happened while we
		// were in our IndicateDisconnect call above.  Like he might have called Disconnect API and hung around a while
		// so that our DISC frame was acknowledged already.  This would mean we are ready to Complete the Disco
	}

	// This side is already closing.  There are three ways that this can happen:
	//
	// 1 - We originated the Disconnect and our parner is now done transmitting
	// 2 - Both sides Disconnected and Disc frames crossed	
	// 3 - We are in the process of aborting our link
	//
	// 1 & 2 can be handled identically.  Case 3 can be ignored, we are dropping abnormally anyway.
	//
	//	THE TRICKY PART  --  What if this EOS frame's ACK gets lost?  We will not respond to retries
	//		because we will have closed the endpoint when the link was dropped.  This leaves partner
	//		flapping in the breeze until he times out and drops abnormally.
	// Possible solutions:
	//		* we can achieve Pretty Good results by always xmitting the final ACK 3 times.  This
	//		fails 1/8000 with the %5 drop rate.
	//		* we can delay disconnecting the endpoint for several seconds (some multiple of RTT). This
	// 		allows us to respond to EOS retries (reset delay timer each time a retry is sent).  This
	//		is only a problem if user immediately re-connects from the same port... doesnt have to be
	//		a problem,  actually,  just a special case.
	//
	//	And the answer is -- second solution is more work but more robust.  I will implement easy
	//		solution for the time being,  but will upgrade to better solution if resource permits.
	//
	//  To tell the truth,  first solution is worse. 1-in-8000 assumes an even distribution of packet
	//	loss,  which is almost certainly not the reality...
	//
	//  But look,  if we respond to frames with DISC when we are unconnected then the problem goes away...
	//
	//	** EPD->EPLOCK is Held at this point

	pEPD->ulEPFlags |= EPFLAGS_RECEIVED_DISCONNECT;		// Note that we have seen partner's DISC

	if(pEPD->ulEPFlags & EPFLAGS_DISCONNECT_ACKED)
	{		
		// He has seen our discon,  we are free to close

		// This is the typical Close path for the initiating side...
		pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

		// CODEWORK -- Handle THE TRICKY PART as described above...

		pMSD = pEPD->pCommand;
		pEPD->pCommand = NULL;
		PSPD pSPD = pEPD->pSPD;      					// Keep the SPD for use below

		SendAckFrame(pEPD, 1);							// Make sure we transmit an ack for this
														// This unlocks the EPLock since param 2 is 1
														 
		ASSERT_MSD(pMSD);								// Its Guaranteed to be here
		ASSERT(pMSD->CommandID == COMMAND_ID_DISCONNECT);

		pMSD->blQLinkage.RemoveFromList();
		
		ASSERT(pEPD->blHighPriSendQ.IsEmpty());
		ASSERT(pEPD->blNormPriSendQ.IsEmpty());
		ASSERT(pEPD->blLowPriSendQ.IsEmpty());

		Lock(&pMSD->CommandLock);						// Must be held for the following call

		CompleteReliableSend(pSPD, pMSD, DPN_OK);
	}
	else 
	{
		Unlock(&pEPD->EPLock);
	}
}

/*
**		Process Disconnected Frame
**
**			We have received a DISCONNECTED frame which means that the link to
**		this End Point is closed.  This may be a response to our DISCONNECT
**		frame or it might be a unilateral signal of an abnormally aborted link.
**		Doesnt really matter either way-  the conversation is over.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessDisconnectedFrame"

VOID ProcessDisconnectedFrame(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame)
{
	PMSD	pMSD;

	if(pCFrame->dwSessID != pEPD->dwSessID)
	{
		LOGPF(7, "(%p) Received DISCONNECTED frame with incorrect SessID. (%x)", pEPD, pCFrame->dwSessID);
		if(pEPD->ulEPFlags & EPFLAGS_END_POINT_DORMANT)
		{
			LOGPF(7, "(%p) Rejecting Connection on dormant Endpoint", pEPD);
			RejectConnection(pEPD);
		}
		return;
	}

	Lock(&pEPD->EPLock);

	// Did we ever achieve connected status?
	if(pEPD->ulEPFlags & (EPFLAGS_CONNECTED | EPFLAGS_CONNECTING))
	{	
		LOGPF(7, "(%p) Disconnect Frame Received, Dropping Link", pEPD);
		DropLink(pEPD);										// releases SendQLock
	}
	else 
	{
		LOGPF(7, "(%p) Disconnect Frame Received on unconnected link, Rejecting Connection", pEPD);
		Unlock(&pEPD->EPLock);
		RejectConnection(pEPD);
	}
}

/*
**		Process SP Disconnect
**
**		Service Provider has told us that an endpoint has gone away.  This is probably
**	because we have Disconnected it ourselves, in which case the IN_USE flag will be
**	clear.  Otherwise,  we need to clean this thing up ourselves...
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessSPDisconnect"

VOID
ProcessSPDisconnect(PSPD pSPD, PSPIE_DISCONNECT pDataBlock)
{
	PEPD 	pEPD = static_cast<PEPD>( pDataBlock->pEndpointContext );

	LOGPF(2, "Parameters: pSPD[%p], pDataBlock[%p] - pEPD[%p]", pSPD, pDataBlock, pEPD);

	if(pEPD->ulEPFlags & EPFLAGS_END_POINT_IN_USE)
	{
		if(pEPD->ulEPFlags & EPFLAGS_CONNECTED)
		{
			LOGPF(5, "(%p) SP DROPS CONNECTED ENDPOINT", pEPD);
			Lock(&pEPD->EPLock);
			DropLink(pEPD);								// DropLink releases SendQLock
		}
		else
		{
			LOGPF(5, "(%p) SP DROPS DISCONNECTED ENDPOINT", pEPD);
		}
	}
	else 
	{
		LOGPF(5, "(%p) SP REPORTS CONNECTION CLOSED", pEPD);
	}
}

/*
**		Process Listen Status
**
**		This call tells us that a submitted Listen command has become active.  Truth is, we
**	dont care.  We are just interested in seeing the Connect indications as they arrive.  What we
**	do care about,  however, is the Endpoint handle associated with this listen in case we are
**	later asked about the address associated with the listen.  So we will pull it out of the
**	data block and save it in our MSD.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessListenStatus"

VOID
ProcessListenStatus(PSPD pSPD, PSPIE_LISTENSTATUS pDataBlock)
{
	PMSD	pMSD;
	
	LOGPF(2, "Parameters: pSPD[%p], pDataBlock[%p] - hr=%x", pSPD, pDataBlock, pDataBlock->hResult);

	pMSD = (PMSD) pDataBlock->pUserContext;

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);

	pMSD->hListenEndpoint = pDataBlock->hEndpoint;

	LOGPF(3, "Calling Core->CompleteListen, pMSD[%p]", pMSD);
	pSPD->pPData->pfVtbl->CompleteListen(pSPD->pPData->Parent, &pMSD->Context, pDataBlock->hResult, pDataBlock->hEndpoint);
	
	if(pDataBlock->hResult != DPN_OK)
	{
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Release On Complete");
	}

	return;
}

/*
**		Process Connect Address Info
**
**		This call tells us what addressing information has been used to start a connect.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectAddressInfo"

VOID
ProcessConnectAddressInfo(PSPD pSPD, PSPIE_CONNECTADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	LOGPF(2, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->CommandID == COMMAND_ID_CONNECT);

	LOGPF(3, "Calling Core->AddressInfoConnect");
	pSPD->pPData->pfVtbl->AddressInfoConnect( pSPD->pPData->Parent,
											  pMSD->Context,
											  pDataBlock->hCommandStatus,
											  pDataBlock->pHostAddress,
											  pDataBlock->pDeviceAddress );
	
	return;
}


/*
**		Process Enum Address Info
**
**		This call tells us what addressing information has been used to start an enum.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEnumAddressInfo"

VOID
ProcessEnumAddressInfo(PSPD pSPD, PSPIE_ENUMADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	LOGPF(2, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);
	
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->CommandID == COMMAND_ID_ENUM );

	LOGPF(3, "Calling Core->AddressInfoEnum");
	pSPD->pPData->pfVtbl->AddressInfoEnum( pSPD->pPData->Parent,
										   pMSD->Context,
										   pDataBlock->hCommandStatus,
										   pDataBlock->pHostAddress,
										   pDataBlock->pDeviceAddress );
	
	return;
}

/*
**		Process Listen Address Info
**
**		This call tells us what addressing information has been used to start a listen.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessListenAddressInfo"

VOID
ProcessListenAddressInfo(PSPD pSPD, PSPIE_LISTENADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	LOGPF(2, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN );

	LOGPF(3, "Calling Core->AddressInfoListen");
	pSPD->pPData->pfVtbl->AddressInfoListen( pSPD->pPData->Parent,
											 pMSD->Context,
											 pDataBlock->hCommandStatus,
											 pDataBlock->pDeviceAddress );
	
	return;
}

/*
**		Reject Frame
**
**		We have received a frame that is outside of our receive window.  It is most
**	likely a retransmitted frame which we ACK'd,  but the ACK was lost.  Best thing
**	we can do is send another ACK pretty soon.
**
**	** CALLED WITH EPLOCK, LEAVES WITH EPLOCK RELEASED **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RejectFrame"

VOID
RejectFrame(PEPD pEPD, PDFRAME pFrame)
{
	pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

	if(pFrame->bCommand & PACKET_COMMAND_POLL)
	{
		// Is he asking for an immediate response
		LOGPF(7, "(%p) Sending Ack Frame", pEPD);
		SendAckFrame(pEPD, 1); 						// This unlocks the EPLock since param 2 is 1
	}
	else if(pEPD->DelayedAckTimer == 0)
	{	
		// If timer is not running better start it now
		LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");								// Bump RefCnt for new timer
		LOGPF(7, "(%p) Setting Delayed Ack Timer", pEPD);
		SetMyTimer(SHORT_DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		Unlock(&pEPD->EPLock);		
	}
	else
	{
		Unlock(&pEPD->EPLock);		
	}
}

/*************************************
**
**		RECEIVE BUFFER MANAGEMENT
**
**		When multiple frame messages arrive we *may* have to copy them in to a  single contiguous
**	buffer.  We are supporting an OPTIONAL scatter-receive option which would allow sophisticated
**	clients to receive a BUFFER_DESCRIPTOR array instead of a single cont-buffer,  and avoiding
**	a large datacopy.
**
**		For clients which dont support scatter-receive,  we need a pooling strategy for large receive
**	buffers.  We will only need buffers LARGER then our frame limit because smaller receives are delivered
**	in the SPs buffer.
**
**		Try placing receives into generally sized buffers.  If frame size is usu 1.4K bytes, 2K is a small
**	buffer, 4K, 16K, 32K, 64K.  If frame size is <1K we can have 1K buffers too.
**
**
*************************************/


#undef DPF_MODNAME
#define DPF_MODNAME "GetReceiveBuffer"

VOID
GetReceiveBuffer(UINT size)
{
}


/***********************
========SPACER==========
************************/

/*
**		RCD Pool support routines
**
**		These are the functions called by Fixed Pool Manager as it handles RCDs.
*/

#define	pELEMENT		((PRCD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Allocate"

BOOL RCD_Allocate(PVOID pElement)
{
	pELEMENT->blOddFrameLinkage.Initialize();
	pELEMENT->blCompleteLinkage.Initialize();
	pELEMENT->Sign = RCD_SIGN;

	return TRUE;
}

//	Get is called each time an MSD is used

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Get"

VOID RCD_Get(PVOID pElement)
{
	LOGPF(5, "CREATING RCD %p", pELEMENT);

	pELEMENT->pRcvBuff = NULL;
	pELEMENT->uiRefCnt = 1;
	pELEMENT->ulRFlags = 0;
}

//	RCD Release  --  This release call will release an entire chain of RCDs
// 	that are linked together... or then again maybe not.

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Release"

VOID RCD_Release(PVOID pElement)
{
	ASSERT_RCD(pELEMENT);

	LOGPF(5, "RELEASING RCD %p", pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Free"

VOID RCD_Free(PVOID pElement)
{
}

#undef	pELEMENT

/*
**		Buffer pool support
**
**
*/

#define	pELEMENT		((PBUF) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_Allocate"

BOOL	Buf_Allocate(PVOID pElement)
{
	pELEMENT->Type = RBT_PROTOCOL_BUFFER;

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_Get"

VOID Buf_Get(PVOID pElement)
{
	pELEMENT->Owner = BufPool;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_GetMed"

VOID Buf_GetMed(PVOID pElement)
{
	pELEMENT->Owner = MedBufPool;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_GetBig"

VOID Buf_GetBig(PVOID pElement)
{
	pELEMENT->Owner = BigBufPool;
}

#undef	pELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\classfacs.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.cpp
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#include	"wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef struct GPCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD					dwRefCnt;
   CLSID					clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;

//
// function prototype for CoLockPbjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GP_QueryInterface
 */
STDMETHODIMP GP_QueryInterface(
                LPCLASSFACTORY This,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
	HRESULT hr;

    pcf = (LPGPCLASSFACTORY)This;
    *ppvObj = NULL;


        pcf->dwRefCnt++;
        *ppvObj = This;
		hr = S_OK;

	return hr;

} /* GP_QueryInterface */

#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Initialize"

/*
 * GP_AddRef
 */
STDMETHODIMP_(ULONG) GP_AddRef( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY pcf;

    pcf = (LPGPCLASSFACTORY)This;
    pcf->dwRefCnt++;
    return pcf->dwRefCnt;
} /* GP_AddRef */



#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Initialize"

/*
 * GP_Release
 */
STDMETHODIMP_(ULONG) GP_Release( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY	pcf;

    pcf = (LPGPCLASSFACTORY)This;
    pcf->dwRefCnt--;

    if( pcf->dwRefCnt != 0 )
    {
        return pcf->dwRefCnt;
    }

    DNFree( pcf );
    return 0;

} /* GP_Release */




/*
 * GP_CreateInstance
 *
 * Creates an instance of a DNServiceProvider object
 */
STDMETHODIMP GP_CreateInstance(
                LPCLASSFACTORY This,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT					hr = S_OK;
    LPGPCLASSFACTORY		pcf;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	pcf = (LPGPCLASSFACTORY) This;
	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(This, pUnkOuter, pcf->clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GP_CreateInstance */



/*
 * GP_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GP_LockServer(
                LPCLASSFACTORY This,
                BOOL fLock
				)
{
	return S_OK;

} /* GP_LockServer */

static IClassFactoryVtbl GPClassFactoryVtbl =
{
        GP_QueryInterface,
        GP_AddRef,
        GP_Release,
        GP_CreateInstance,
        GP_LockServer
};


/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
HRESULT  SPDllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * create a class factory object
     */
    pcf = static_cast<GPCLASSFACTORY*>( DNMalloc( sizeof( *pcf ) ) );
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

	pcf->lpVtbl = &GPClassFactoryVtbl;
    pcf->dwRefCnt = 0;
	pcf->clsid = rclsid;

    hr = GP_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DNFree ( pcf );
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
HRESULT SPDllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\cmddata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CmdData.cpp
 *  Content:	Class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/1999	jtk		Derived from SPData.h
 *	01/19/2000	jtk		Derived from CommandData.h
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::CCommandData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::CCommandData"

CCommandData::CCommandData():
	m_State( COMMAND_STATE_UNKNOWN ),
	m_dwDescriptor( NULL_DESCRIPTOR ),
	m_dwNextDescriptor( NULL_DESCRIPTOR + 1 ),
	m_Type( COMMAND_TYPE_UNKNOWN ),
	m_pEndpoint( NULL ),
	m_pUserContext( NULL ),
	m_pOwningPool( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::CCommandData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::~CCommandData"

CCommandData::~CCommandData()
{
	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::Reset - reset this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::Reset"

void	CCommandData::Reset( void )
{
	SetState( COMMAND_STATE_UNKNOWN );
	m_dwDescriptor = NULL_DESCRIPTOR;
	SetType( COMMAND_TYPE_UNKNOWN );
	SetEndpoint( NULL );
	SetUserContext( NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolAllocFunction - called when a pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolAllocFunction"

BOOL	CCommandData::PoolAllocFunction( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	DNASSERT( m_pOwningPool == NULL );
	
	//
	// initialize critical section and set recursin depth to 0
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

Exit:
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolInitFunction - called when a pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolInitFunction"

BOOL	CCommandData::PoolInitFunction( void )
{
	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	DNASSERT( m_pOwningPool == NULL );
	
	SetDescriptor();
	
	return	TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolReleaseFunction - called when item is returned to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolReleaseFunction"

void	CCommandData::PoolReleaseFunction( void )
{
	Reset();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::Denitialize - deinitialization function for command data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolDeallocFunction"

void	CCommandData::PoolDeallocFunction( void )
{
	DNDeleteCriticalSection( &m_Lock );
	m_State = COMMAND_STATE_UNKNOWN;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::ReturnSelfToPool - return this item to a pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::ReturnSelfToPool"

void	CCommandData::ReturnSelfToPool( void )
{
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\adapterentry.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AdapterEntry.cpp
 *  Content:	Structure used in the list of active sockets
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/07/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CAdapterEntry::CAdapterEntry - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::CAdapterEntry"

CAdapterEntry::CAdapterEntry():
// BUGBUG: [mgere] [xbox] Temporarily remove RSIP support.
//	m_pRsip( NULL ),
	m_pOwningPool( NULL )
{
	m_AdapterListLinkage.Initialize();
	m_ActiveSocketPorts.Initialize();
	memset( &m_BaseSocketAddress, 0x00, sizeof( m_BaseSocketAddress ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::~CAdapterEntry - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::~CAdapterEntry"

CAdapterEntry::~CAdapterEntry()
{
// BUGBUG: [mgere] [xbox] RSIP Removed
//	DNASSERT( m_pRsip == NULL );
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::StartRsip - start Rsip for this adapter
//
// Entry:		Pointer to adapter address
//				Pointer to thread pool
//				Boolean indicating whether this is an Rsip server machine
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::StartRsip"

HRESULT	CAdapterEntry::StartRsip( const SOCKADDR *const pAdapterAddress,
								  CThreadPool *const pThreadPool,
								  const BOOL fIsRsipServer )
{
	HRESULT	hr;


	DNASSERT( pAdapterAddress != NULL );
/* BUGBUG: [mgere] [xbox] Removed RSIP support

	//
	// initialize
	//
	hr = DPN_OK;
	if ( RsipModule() == NULL )
	{
		m_pRsip = CreateRsip();
		if ( m_pRsip == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPF( 0, "Failed to create Rsip object!" );
			goto Failure;
		}

		if ( m_pRsip->Initialize( pThreadPool, pAdapterAddress, fIsRsipServer ) == FALSE )
		{
			hr = DPNERR_NOCONNECTION;
			DPF( 0, "Failed Rsip init!" );
			goto Failure;
		}
	}

Exit:
	return	hr;

Failure:
	if ( m_pRsip != NULL )
	{
		m_pRsip->DecRef();
		m_pRsip = NULL;
	}

	goto Exit;	
*/ return E_FAIL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolAllocFunction - called when item is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolAllocFunction"

BOOL	CAdapterEntry::PoolAllocFunction( void )
{
	BOOL	fReturn;


	//
	// initialie
	//
	fReturn = TRUE;

// BUGBUG: [mgere] [xbox] RSIP Removed
//	DNASSERT( RsipModule() == NULL );
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );

	return	fReturn;
}
//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolInitFunction - called when item is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolInitFunction"

BOOL	CAdapterEntry::PoolInitFunction( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;
	
// BUGBUG: [mgere] [xbox] RSIP Removed
//	DNASSERT( RsipModule() == NULL );
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolReleaseFunction - called when item is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolReleaseFunction"

void	CAdapterEntry::PoolReleaseFunction( void )
{
// BUGBUG: [mgere] [xbox] RSIP Removed
//	DNASSERT( RsipModule() == NULL );
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolDeallocFunction - called when this item is freed from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolDeallocFunction"

void	CAdapterEntry::PoolDeallocFunction( void )
{
// BUGBUG: [mgere] [xbox] RSIP Removed
//	DNASSERT( RsipModule() == NULL );
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::ReturnSelfToPool"

void	CAdapterEntry::ReturnSelfToPool( void )
{
/* BUGBUG: [mgere] [xbox] Remove RSIP support
	if ( m_pRsip != NULL )
	{
		m_pRsip->Deinitialize();
		m_pRsip->DecRef();
		m_pRsip = NULL;
	}
*/

	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\cmddata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CommandData.h
 *  Content:	Declaration of class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/99	jtk		Derived from SPData.h
 ***************************************************************************/

#ifndef __COMMAND_DATA_H__
#define __COMMAND_DATA_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

typedef	enum
{
	COMMAND_STATE_UNKNOWN,					// unknown state
	COMMAND_STATE_PENDING,					// command waiting to be processed
	COMMAND_STATE_INPROGRESS,				// command is executing
	COMMAND_STATE_INPROGRESS_CANNOT_CANCEL,	// command is executing, can't be cancelled
	COMMAND_STATE_CANCELLING,				// command is already being cancelled
} COMMAND_STATE;

typedef	enum
{	
	COMMAND_TYPE_UNKNOWN,		// unknown command
	COMMAND_TYPE_CONNECT,		// connect command
	COMMAND_TYPE_LISTEN,		// listen command
	COMMAND_TYPE_ENUM_QUERY,	// enum command
	COMMAND_TYPE_SEND,			// data send command (enum, enum query, send)
} COMMAND_TYPE;

#define	NULL_DESCRIPTOR		0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CEndpoint;
class	CCommandData;
class	CSPData;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// the following funtion must be defined
//
void	ReturnCommand( CCommandData *const pCommandData );

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
class	CCommandData : public CLockedPoolItem
{
	STDNEWDELETE

	public:
		CCommandData();
		~CCommandData();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }


		DWORD	GetDescriptor( void ) const { return m_dwDescriptor; }
		void	SetDescriptor( void )
		{
			m_dwDescriptor = m_dwNextDescriptor;
			m_dwNextDescriptor++;
			if ( m_dwNextDescriptor == NULL_DESCRIPTOR )
			{
				m_dwNextDescriptor++;
			}
			
			SetState( COMMAND_STATE_UNKNOWN );
		}

		COMMAND_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetState"
		void			SetState( const COMMAND_STATE State )
		{
			DNASSERT( ( m_State == COMMAND_STATE_UNKNOWN ) ||
					  ( State == COMMAND_STATE_UNKNOWN ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_INPROGRESS ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_CANCELLING ) ) ||
					  ( ( m_State == COMMAND_STATE_INPROGRESS ) && ( State == COMMAND_STATE_CANCELLING ) ) ||
					  ( ( m_State == COMMAND_STATE_INPROGRESS ) && ( State == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL ) ) ||
					  ( ( m_State == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL ) && ( State == COMMAND_STATE_INPROGRESS ) ) ||
					  ( ( m_State == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL ) && ( State == COMMAND_STATE_PENDING ) ) );
			m_State = State;
		}

		COMMAND_TYPE	GetType( void ) const { return m_Type; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetType"
		void			SetType( const COMMAND_TYPE Type )
		{
			DNASSERT( ( m_Type == COMMAND_TYPE_UNKNOWN ) || ( Type == COMMAND_TYPE_UNKNOWN ) );
			m_Type = Type;
		}

		CEndpoint	*GetEndpoint( void ) const { return m_pEndpoint; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetEndpoint"
		void		SetEndpoint( CEndpoint *const pEndpoint )
		{
			DNASSERT( ( m_pEndpoint == NULL ) || ( pEndpoint == NULL ) );
			m_pEndpoint = pEndpoint;
		}

		void	*GetUserContext( void ) const { return m_pUserContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetUserContext"
		void	SetUserContext( void *const pUserContext )
		{
			DNASSERT( ( m_pUserContext == NULL ) || ( pUserContext == NULL ) );
			m_pUserContext = pUserContext;
		}

		void	Reset( void );

		//
		// pool fnctions
		//
		BOOL	PoolAllocFunction( void );
		BOOL	PoolInitFunction( void );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetOwningPool"
		void	SetOwningPool( CLockedPool< CCommandData > *const pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		DWORD				m_dwDescriptor;
		DWORD				m_dwNextDescriptor;
		COMMAND_STATE		m_State;
		COMMAND_TYPE		m_Type;
		CEndpoint			*m_pEndpoint;
		void				*m_pUserContext;

		CLockedPool< CCommandData >	*m_pOwningPool;
		
		void	ReturnSelfToPool( void );

		//
		// prevent unwarranted copies
		//
		CCommandData( const CCommandData & );
		CCommandData& operator=( const CCommandData & );
};

#undef DPF_MODNAME

#endif	// __COMMAND_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\debugutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DebugUtils.cpp
 *  Content:	Winsock service provider debug utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "wsockspi.h"

#ifdef	_DEBUG

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// HexDump - perform a hex dump of information
//
// Entry:		Pointer to data
//				Data size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "HexDump"

void	HexDump( PVOID pData, UINT32 uDataSize )
{
	DWORD	uIdx = 0;


	// go through all data
	while ( uIdx < uDataSize )
	{
		// output character
		DPF( 0, "0x%2x ", ( (LPBYTE) pData )[ uIdx ] );

		// increment index
		uIdx++;

		// are we off the end of a line?
		if ( ( uIdx % 12 ) == 0 )
		{
			DPF( 0, "\n" );
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DumpSocketAddress - dump a socket address
//
// Entry:		Debug level
//				Pointer to socket address
//				Socket family
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DumpSocketAddress"

void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily )
{
	switch ( dwFamily )
	{
		case AF_INET:
		{
			const SOCKADDR_IN	*const pInetAddress = reinterpret_cast<const SOCKADDR_IN*>( pSocketAddress );

			DPF( dwDebugLevel, "IP socket:\tAddress: %d.%d.%d.%d\tPort: %d",
					pInetAddress->sin_addr.S_un.S_un_b.s_b1,
					pInetAddress->sin_addr.S_un.S_un_b.s_b2,
					pInetAddress->sin_addr.S_un.S_un_b.s_b3,
					pInetAddress->sin_addr.S_un.S_un_b.s_b4,
				 	p_ntohs( pInetAddress->sin_port )
					);
			break;
		}

		default:
		{
			DPF( 0, "Unknown socket type!" );
			INT3;
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DumpAddress - convert an address to a URL and output via debugger
//
// Entry:		Debug level
//				Pointer to base message string
//				Pointer to address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DumpAddress"

void	DumpAddress( const DWORD dwDebugLevel, const char *const pBaseString, IDirectPlay8Address *const pAddress )
{
	HRESULT	hr;
	char	*pURL;
	DWORD	dwURLSize;


	DNASSERT( pBaseString != NULL );
	DNASSERT( pAddress != NULL );
	
	pURL = NULL;
	dwURLSize = 0;

	hr = IDirectPlay8Address_GetURLA( pAddress, pURL, &dwURLSize );
	if ( hr != DPNERR_BUFFERTOOSMALL )
	{
		goto Failure;
	}
	
	pURL = static_cast<char*>( DNMalloc( dwURLSize ) );
	if ( pURL == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	hr = IDirectPlay8Address_GetURLA( pAddress, pURL, &dwURLSize );
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	DNASSERT( pURL != NULL );
	DPF( dwDebugLevel, "%s%s", pBaseString, pURL );

Exit:
	if ( pURL != NULL )
	{
		DNFree( pURL );
		pURL = NULL;
	}

	return;

Failure:
	DPF( dwDebugLevel, "Failing DumpAddress:" );
	DisplayDNError( dwDebugLevel, hr );

	goto Exit;
}

#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\adapterentry.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AdapterEntry.h
 *  Content:	Strucutre definitions for IO data blocks
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/07/2000	jtk		Dereived from IOData.cpp
 ***************************************************************************/

#ifndef __ADAPTER_ENTRY_H__
#define __ADAPTER_ENTRY_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
// BUGBUG: [mgere] [xbox] Removed RSIP
//class	CRsip;
class	CThreadPool;


//
// class containing all data for an adapter list
//
class	CAdapterEntry : public CLockedPoolItem
{
	STDNEWDELETE

	public:
		CAdapterEntry();
		~CAdapterEntry();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AddToAdapterList"
		void	AddToAdapterList( CBilink *const pAdapterList )
		{
			DNASSERT( pAdapterList != NULL );
			m_AdapterListLinkage.InsertBefore( pAdapterList );
		}

		void	RemoveFromAdapterList( void ) { m_AdapterListLinkage.RemoveFromList(); }
	
		CBilink	*SocketPortList( void ) { return &m_ActiveSocketPorts; }
// BUGBUG: [mgere] [xbox] Removed RSIP
//		CRsip	*RsipModule( void ) const { return m_pRsip; }
		const SOCKADDR	*BaseAddress( void ) const { return &m_BaseSocketAddress; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::SetBAseAddress"
		void	SetBaseAddress( const SOCKADDR *const pSocketAddress )
		{
			DBG_CASSERT( sizeof( m_BaseSocketAddress ) == sizeof( *pSocketAddress ) );
			memcpy( &m_BaseSocketAddress, pSocketAddress, sizeof( m_BaseSocketAddress ) );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AdapterEntryFromAdapterLinkage"
		static	CAdapterEntry	*AdapterEntryFromAdapterLinkage( CBilink *const pLinkage )
		{
			DNASSERT( pLinkage != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pLinkage ) );
			DBG_CASSERT( sizeof( CAdapterEntry* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CAdapterEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CAdapterEntry, m_AdapterListLinkage ) ] );
		}

		HRESULT	StartRsip( const SOCKADDR *const pAdapterAddress,
						   CThreadPool *const pThreadPool,
						   const BOOL fIsRsipServer );
		
		//
		// pool fnctions
		//
		BOOL	PoolAllocFunction( void );
		BOOL	PoolInitFunction( void );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::SetOwningPool"
		void	SetOwningPool( CLockedPool< CAdapterEntry > *const pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}

	protected:

	private:
// BUGBUG: [mgere] [xbox] Removed RSIP
//		CRsip			*m_pRsip;					// pointer to Rsip module (may be NULL)
		CBilink			m_AdapterListLinkage;		// linkage to other adapters
		CBilink			m_ActiveSocketPorts;		// linkage to active socket ports
		SOCKADDR		m_BaseSocketAddress;		// socket address for this port class

		CLockedPool< CAdapterEntry >	*m_pOwningPool;
		
		void	ReturnSelfToPool( void );
		
		// prevent unwarranted copies
		CAdapterEntry( const CAdapterEntry & );
		CAdapterEntry& operator=( const CAdapterEntry & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __ADAPTER_ENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\endpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Endpoint.cpp
 *  Content:	Winsock endpoint base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CEndpoint"

CEndpoint::CEndpoint():
	m_State( ENDPOINT_STATE_UNINITIALIZED ),
	m_fConnectSignalled( FALSE ),
	m_EndpointType( ENDPOINT_TYPE_UNKNOWN ),
	m_pRemoteMachineAddress( NULL ),
	m_pSPData( NULL ),
	m_pSocketPort( NULL ),
	m_pUserEndpointContext( NULL ),
	m_fListenStatusNeedsToBeIndicated( FALSE ),
	m_Handle( INVALID_HANDLE_VALUE ),
	m_lCommandRefCount( 0 ),
	m_fCommandPending( FALSE ),
	m_hDisconnectIndicationHandle( INVALID_HANDLE_VALUE ),
	m_pActiveCommandData( NULL ),
	m_dwEnumSendIndex( 0 )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	DEBUG_ONLY( m_fEndpointOpen = FALSE );
	memset( &m_PendingCommandData, 0x00, sizeof( m_PendingCommandData ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::~CEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::~CEndpoint"

CEndpoint::~CEndpoint()
{
	DNASSERT( m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( m_fConnectSignalled == FALSE );
	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( m_pRemoteMachineAddress == NULL );
	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_pSocketPort == NULL );
	DNASSERT( m_pUserEndpointContext == NULL );
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_Handle == INVALID_HANDLE_VALUE );
	DNASSERT( m_lCommandRefCount == 0 );
	DNASSERT( m_fCommandPending == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( m_pActiveCommandData == NULL );
	DNASSERT( m_dwEnumSendIndex == 0 );

	DNASSERT( m_EnumKey.GetKey() == INVALID_ENUM_KEY );
	DNASSERT( m_fEndpointOpen == FALSE );
	DNASSERT( m_fInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Initialize - initialize an endpoint
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Initialize"

HRESULT	CEndpoint::Initialize( void )
{
	HRESULT	hr;


	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_fInitialized == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// attempt to initialize the internal critical section
	//
	if ( DNInitializeCriticalSection( &m_Lock )	== FALSE )
	{
		DPF( 0, "Problem initializing critical section for this endpoint!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Deinitilize - deinitialize an endpoint
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Deinitialize"

void	CEndpoint::Deinitialize( void )
{
	DNDeleteCriticalSection( &m_Lock );
	DNASSERT( m_pSPData == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Open - open endpoint for use
//
// Entry:		Type of endpoint
//				Pointer to address to of remote machine
//				Pointer to socket address of remote machine
//
// Exit:		Nothing
//
// Note:	Any call to Open() will require an associated call to Close().
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Open"

HRESULT	CEndpoint::Open( const ENDPOINT_TYPE EndpointType,
						 IDirectPlay8Address *const pDP8Address,
						 const CSocketAddress *const pSocketAddress
						 )
{
	HRESULT	hr;


//	DNASSERT( pSocketPort != NULL );
	DNASSERT( ( pDP8Address != NULL ) ||
			  ( pSocketAddress != NULL ) ||
			  ( ( EndpointType == ENDPOINT_TYPE_LISTEN ) ||
				( EndpointType == ENDPOINT_TYPE_MULTICAST ) )
			  );
	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_fEndpointOpen == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;
	DEBUG_ONLY( m_fEndpointOpen = TRUE );

//	DNASSERT( m_pSocketPort == NULL );
//	m_pSocketPort = pSocketPort;
//	pSocketPort->EndpointAddRef();

	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	m_EndpointType = EndpointType;

	//
	// determine the endpoint type so we know how to handle the input paramters
	//
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_ENUM:
		{
//			m_EnumKey.SetKey( pSocketPort->GetEnumKey() );
			//
			// NOTE: THIS CASE FALLS THROUGH!!
			//
		}

		//
		// standard endpoint creation, attempt to parse the input address
		//
		case ENDPOINT_TYPE_CONNECT:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address != NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pDP8Address, SP_ADDRESS_TYPE_HOST );
			if ( hr != DPN_OK )
			{
				DPF( 0, "Problem converting DNAddress to IP address in Initialize!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

		//
		// listen, there should be no input DNAddress
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );

			break;
		}

		//
		// new endpoint spawned from a listen, copy the input address and
		// note that this endpoint is really just a connection
		//
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			DNASSERT( pSocketAddress != NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			m_pRemoteMachineAddress->CopyAddressSettings( *pSocketAddress );
			m_EndpointType = ENDPOINT_TYPE_CONNECT;
			m_State = ENDPOINT_STATE_ATTEMPTING_CONNECT;

			break;
		}

		//
		// endpoint is being created for multicasts
		//
		case ENDPOINT_TYPE_MULTICAST:
		{
			DNASSERT( pSocketAddress != NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			m_pRemoteMachineAddress->CopyAddressSettings( *pSocketAddress );
			m_EndpointType = ENDPOINT_TYPE_MULTICAST;
			m_State = ENDPOINT_STATE_MULTICAST;

			break;
		}

		//
		// unknown type
		//
		default:
		{
			DNASSERT( FALSE );
			break;

		}
	}

Exit:
	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Close - close an endpoint
//
// Entry:		Error code for active command
//
// Exit:		Error code
//
// Note:	This code does not disconnect an endpoint from its associated
//			socket port.  That is the responsibility of the code that is
//			calling this function.  This function assumes that this endpoint
//			is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Close"

void	CEndpoint::Close( const HRESULT hActiveCommandResult )
{
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	DNASSERT( m_fEndpointOpen != FALSE );
	DNASSERT( m_fInitialized != FALSE );

	//
	// is there an active command?
	//
	if ( CommandPending() != FALSE )
	{
		m_hPendingCommandResult = hActiveCommandResult;
	}

	DEBUG_ONLY( m_fEndpointOpen = FALSE );

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ChangeLoopbackAlias - change the loopback alias to a real address
//
// Entry:		Pointer to real address to use
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ChangeLoopbackAlias"

void	CEndpoint::ChangeLoopbackAlias( const CSocketAddress *const pSocketAddress ) const
{
	DNASSERT( m_pRemoteMachineAddress != NULL );
	m_pRemoteMachineAddress->ChangeLoopBackToLocalAddress( pSocketAddress );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyConnectData - copy data for connect command
//
// Entry:		Pointer to job information
//				Pointer to device address
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyConnectData"

void	CEndpoint::CopyConnectData( const SPCONNECTDATA *const pConnectData, IDirectPlay8Address *const pDeviceAddress )
{
	DNASSERT( pConnectData != NULL );
	DNASSERT( pDeviceAddress != NULL );

	DNASSERT( pConnectData->hCommand != NULL );
	DNASSERT( pConnectData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_fCommandPending == FALSE );
	DNASSERT( m_pActiveCommandData == FALSE );

	DBG_CASSERT( sizeof( m_PendingCommandData.ConnectData ) == sizeof( *pConnectData ) );
	memcpy( &m_PendingCommandData, pConnectData, sizeof( m_PendingCommandData.ConnectData ) );
	m_PendingCommandData.ConnectData.pAddressHost = NULL;
	m_PendingCommandData.ConnectData.pAddressDeviceInfo = pDeviceAddress;
	IDirectPlay8Address_AddRef( pDeviceAddress );

	m_fCommandPending = TRUE;
	m_pActiveCommandData = static_cast<CCommandData*>( m_PendingCommandData.ConnectData.hCommand );
	m_pActiveCommandData->SetUserContext( pConnectData->pvContext );
	m_State = ENDPOINT_STATE_ATTEMPTING_CONNECT;
};
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ConnectJobCallback - asynchronous callback wrapper from work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ConnectJobCallback"

void	CEndpoint::ConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	// initialize
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_fCommandPending != FALSE );
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->m_PendingCommandData.ConnectData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->m_PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->m_PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteConnect();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem completing connect in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!
	//

Exit:
	pThisEndpoint->DecRef();
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelConnectJobCallback - cancel for connect job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelConnectJobCallback"

void	CEndpoint::CancelConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	pThisEndpoint->m_pActiveCommandData->Lock();
	DNASSERT( ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pActiveCommandData->Unlock();
	
	//
	// clean up
	//
	DNASSERT( pThisEndpoint->m_PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->m_PendingCommandData.ConnectData.pAddressDeviceInfo );

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->m_pSPData->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteConnect - complete connection
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteConnect"

HRESULT	CEndpoint::CompleteConnect( void )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	SPIE_CONNECT	ConnectIndicationData;
	BOOL			fEndpointBound;
	SPIE_CONNECTADDRESSINFO	ConnectAddressInfo;
	IDirectPlay8Address	*pDeviceAddress;


	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointBound = FALSE;
	memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
	pDeviceAddress = m_PendingCommandData.ConnectData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );

	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );
	DNASSERT( m_fCommandPending != FALSE );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( m_PendingCommandData.ConnectData.hCommand == m_pActiveCommandData );
	DNASSERT( m_PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );
	

	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_CONNECT );
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is still pending, mark it as in-progress and uninterruptable
		//
		case COMMAND_STATE_INPROGRESS:
		case COMMAND_STATE_PENDING:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPF( 0, "User cancelled connect!" );

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GATEWAY_BIND_TYPE_DEFAULT );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	
	//
	// attempt to indicate addressing to a higher layer
	//
	ConnectAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
	ConnectAddressInfo.pHostAddress = GetRemoteHostDP8Address();
	ConnectAddressInfo.hCommandStatus = DPN_OK;
	ConnectAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

	if ( ( ConnectAddressInfo.pHostAddress == NULL ) ||
		 ( ConnectAddressInfo.pDeviceAddress == NULL ) )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
												SPEV_CONNECTADDRESSINFO,				// event type
												&ConnectAddressInfo						// pointer to data
												);
	DNASSERT( hTempResult == DPN_OK );
	
	//
	// Inform user of connection.  Assume that the user will accept and everything
	// will succeed so we can set the user context for the endpoint.  If the
	// connection fails, clear the user endpoint context.
	//
	memset( &ConnectIndicationData, 0x00, sizeof( ConnectIndicationData ) );
	DBG_CASSERT( sizeof( ConnectIndicationData.hEndpoint ) == sizeof( this ) );
	ConnectIndicationData.hEndpoint = GetHandle();
	ConnectIndicationData.pCommandContext = m_PendingCommandData.ConnectData.pvContext;
	SetUserEndpointContext( ConnectIndicationData.pEndpointContext );
	hr = SignalConnect( &ConnectIndicationData );
	if ( hr != DPN_OK )
	{
		DNASSERT( hr == DPNERR_ABORTED );
		DPF( 0, "User refused connect in CompleteConnect!" );
		DisplayDNError( 0, hr );
		SetUserEndpointContext( NULL );
		goto Failure;
	}

	//
	// we're done and everyone's happy, complete the command, this
	// will clear all of our internal command data
	//
	CompletePendingCommand( hr );
	DNASSERT( m_fCommandPending == FALSE );
	DNASSERT( m_pActiveCommandData == NULL );

Exit:
	if ( ConnectAddressInfo.pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( ConnectAddressInfo.pHostAddress );
		ConnectAddressInfo.pHostAddress = NULL;
	}

	if ( ConnectAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( ConnectAddressInfo.pDeviceAddress );
		ConnectAddressInfo.pDeviceAddress = NULL;
	}

	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );	
	
	return	hr;

Failure:
	//
	// we've failed to complete the connect, clean up and return this endpoint
	// to the pool
	//
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Disconnect - disconnect an endpoint
//
// Entry:		Old endpoint handle
//
// Exit:		Error code
//
// Notes:	This function assumes that the endpoint is locked.  If this
//			function completes successfully (returns DPN_OK), the endpoint
//			is no longer locked (it was returned to the pool).
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Disconnect"

HRESULT	CEndpoint::Disconnect( const HANDLE hOldEndpointHandle )
{
	HRESULT	hr;


	DNASSERT( hOldEndpointHandle != INVALID_HANDLE_VALUE );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPNERR_PENDING;

	Lock();
	switch ( GetState() )
	{
		//
		// connected endpoint
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT	hTempResult;


			DNASSERT( m_fCommandPending == FALSE );
			DNASSERT( m_pActiveCommandData == NULL );

			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();

			//
			// Unlock this endpoint before calling to a higher level.  The endpoint
			// has already been labeled as DISCONNECTING so nothing will happen to it.
			//
			Unlock();

			//
			// Note the old endpoint handle so it can be used in the disconnect
			// indication that will be given just before this endpoint is returned
			// to the pool.  Need to release the reference that was added for the
			// connection at this point or the endpoint will never be returned to
			// the pool.
			//
			SetDisconnectIndicationHandle( hOldEndpointHandle );
			DecRef();

			//
			// release reference from just after setting state
			//
			DecCommandRef();
			Close( DPN_OK );
			DecRef();

			break;
		}

		//
		// some other endpoint state
		//
		default:
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPF( 0, "Attempted to disconnect endpoint that's not connected!" );
			switch ( m_State )
			{
				case ENDPOINT_STATE_UNINITIALIZED:
				{
					DPF( 0, "ENDPOINT_STATE_UNINITIALIZED" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_CONNECT:
				{
					DPF( 0, "ENDPOINT_STATE_ATTEMPTING_CONNECT" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_LISTEN:
				{
					DPF( 0, "ENDPOINT_STATE_ATTEMPTING_LISTEN" );
					break;
				}

				case ENDPOINT_STATE_ENUM:
				{
					DPF( 0, "ENDPOINT_STATE_ENUM" );
					break;
				}

				case ENDPOINT_STATE_DISCONNECTING:
				{
					DPF( 0, "ENDPOINT_STATE_DISCONNECTING" );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			Unlock();
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}

Exit:
	return	hr;

Failure:
	// nothing to do
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::StopEnumCommand - stop a running enum command
//
// Entry:		Command result
//
// Exit:		Nothing
//
// Notes:	This function assumes that the endpoint is locked.  If this
//			function completes successfully (returns DPN_OK), the endpoint
//			is no longer locked (it was returned to the pool).
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::StopEnumCommand"

void	CEndpoint::StopEnumCommand( const HRESULT hCommandResult )
{
	Lock();
	DNASSERT( GetState() == ENDPOINT_STATE_DISCONNECTING );
		//
		// Don't hold the lock when cancelling a timer job because the
		// job might be in progress and attempting to use this endpoint!
		//
		Unlock();
		m_pSPData->GetThreadPool()->StopTimerJob( m_pActiveCommandData, hCommandResult );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyListenData - copy data for listen command
//
// Entry:		Pointer to job information
//				Pointer to device address
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyListenData"

void	CEndpoint::CopyListenData( const SPLISTENDATA *const pListenData, IDirectPlay8Address *const pDeviceAddress )
{
	DNASSERT( pListenData != NULL );
	DNASSERT( pDeviceAddress != NULL );
	
	DNASSERT( pListenData->hCommand != NULL );
	DNASSERT( pListenData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_fCommandPending == FALSE );
	DNASSERT( m_pActiveCommandData == NULL );
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );

	DBG_CASSERT( sizeof( m_PendingCommandData.ListenData ) == sizeof( *pListenData ) );
	memcpy( &m_PendingCommandData.ListenData, pListenData, sizeof( m_PendingCommandData.ListenData ) );
	m_PendingCommandData.ListenData.pAddressDeviceInfo = pDeviceAddress;
	IDirectPlay8Address_AddRef( pDeviceAddress );

	m_fCommandPending = TRUE;
	m_fListenStatusNeedsToBeIndicated = TRUE;
	m_pActiveCommandData = static_cast<CCommandData*>( m_PendingCommandData.ListenData.hCommand );
	m_pActiveCommandData->SetUserContext( pListenData->pvContext );
	m_State = ENDPOINT_STATE_ATTEMPTING_LISTEN;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ListenJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ListenJobCallback"

void	CEndpoint::ListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_fCommandPending != NULL );
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->m_PendingCommandData.ListenData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->m_PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->m_PendingCommandData.ListenData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteListen();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem completing listen in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelListenJobCallback - cancel for listen job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelListenJobCallback"

void	CEndpoint::CancelListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	pThisEndpoint->m_pActiveCommandData->Lock();
	DNASSERT( ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pActiveCommandData->Unlock();
	
	//
	// clean up
	//
	DNASSERT( pThisEndpoint->m_PendingCommandData.ListenData.pAddressDeviceInfo != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->m_PendingCommandData.ListenData.pAddressDeviceInfo );

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->m_pSPData->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteListen - complete listen process
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteListen"

HRESULT	CEndpoint::CompleteListen( void )
{
	HRESULT					hr;
	HRESULT					hTempResult;
	SPIE_LISTENSTATUS		ListenStatus;
	BOOL					fEndpointLocked;
	SPIE_LISTENADDRESSINFO	ListenAddressInfo;
	IDirectPlay8Address		*pDeviceAddress;
	GATEWAY_BIND_TYPE		GatewayBindType;


	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
	memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
	pDeviceAddress = m_PendingCommandData.ListenData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );

	if ( ( m_PendingCommandData.ListenData.dwFlags & DPNSPF_BINDLISTENTOGATEWAY ) != 0 )
	{
		GatewayBindType = GATEWAY_BIND_TYPE_SPECIFIC;
	}
	else
	{
		GatewayBindType = GATEWAY_BIND_TYPE_DEFAULT;
	}

	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( m_fCommandPending != FALSE );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( m_PendingCommandData.ListenData.hCommand == m_pActiveCommandData );
	DNASSERT( m_PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_LISTEN );
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is pending, mark as in-progress
		//
		case COMMAND_STATE_PENDING:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
			
			Lock();
			fEndpointLocked = TRUE;
			
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPF( 0, "User cancelled listen!" );

			break;
		}

		//
		// other state
		//
		default:
		{
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// note that this endpoint is officially listening before adding it to the
	// socket port because it may get used immediately
	//
	m_State = ENDPOINT_STATE_LISTEN;

	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GatewayBindType );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to bind endpont!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// attempt to indicate addressing to a higher layer
	//
	ListenAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
	ListenAddressInfo.hCommandStatus = DPN_OK;
	ListenAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

	if ( ListenAddressInfo.pDeviceAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
												SPEV_LISTENADDRESSINFO,					// event type
												&ListenAddressInfo						// pointer to data
												);
	DNASSERT( hTempResult == DPN_OK );
	
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

Exit:
	//
	// report the listen status
	//
	if ( m_fListenStatusNeedsToBeIndicated != FALSE )
	{
		m_fListenStatusNeedsToBeIndicated = FALSE;
		ListenStatus.hResult = hr;
		DNASSERT( m_pActiveCommandData == m_PendingCommandData.ListenData.hCommand );
		ListenStatus.hCommand = m_PendingCommandData.ListenData.hCommand;
		ListenStatus.pUserContext = m_PendingCommandData.ListenData.pvContext;
		ListenStatus.hEndpoint = GetHandle();

		//
		// if the listen binding failed, there's no socket port to dereference so
		// return GUID_NULL as set by the memset.
		//
		if ( GetSocketPort() != NULL )
		{
			GetSocketPort()->GetNetworkAddress()->GuidFromInternalAddressWithoutPort( ListenStatus.ListenAdapter );
		}

		//
		// it's possible that this endpoint was cleaned up so its internal pointers to the
		// COM and data interfaces may have been wiped, use the cached pointer
		//
		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callback interface
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);
		DNASSERT( hTempResult == DPN_OK );
	}

	if ( ListenAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( ListenAddressInfo.pDeviceAddress );
		ListenAddressInfo.pDeviceAddress = NULL;
	}
	
	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );
	
	return	hr;

Failure:
	//
	// we've failed to complete the listen, clean up and return this
	// endpoint to the pool
	//
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyEnumQueryData - copy data for enum query command
//
// Entry:		Pointer to command data
//				Pointer to device address
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyEnumQueryData"

void	CEndpoint::CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData, IDirectPlay8Address *const pDeviceAddress )
{
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( pDeviceAddress != NULL );

	DNASSERT( pEnumQueryData->hCommand != NULL );
	DNASSERT( pEnumQueryData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_fCommandPending == FALSE );
	DNASSERT( m_pActiveCommandData == NULL );

	DBG_CASSERT( sizeof( m_PendingCommandData.EnumQueryData ) == sizeof( *pEnumQueryData ) );
	memcpy( &m_PendingCommandData.EnumQueryData, pEnumQueryData, sizeof( m_PendingCommandData.EnumQueryData ) );
	m_PendingCommandData.EnumQueryData.pAddressHost = NULL;
	m_PendingCommandData.EnumQueryData.pAddressDeviceInfo = pDeviceAddress;
	IDirectPlay8Address_AddRef( pDeviceAddress );

	m_fCommandPending = TRUE;
	m_pActiveCommandData = static_cast<CCommandData*>( m_PendingCommandData.EnumQueryData.hCommand );
	m_pActiveCommandData->SetUserContext( pEnumQueryData->pvContext );
	m_State = ENDPOINT_STATE_ATTEMPTING_ENUM;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumQueryJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryJobCallback"

void	CEndpoint::EnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	// initialize
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_fCommandPending != FALSE );
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->m_PendingCommandData.EnumQueryData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->m_PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteEnumQuery();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem completing enum query in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned to the pool!!!!
	//
Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelEnumQueryJobCallback - cancel for enum query job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelEnumQueryJobCallback"

void	CEndpoint::CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	pThisEndpoint->m_pActiveCommandData->Lock();
	DNASSERT( ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_INPROGRESS ) ||
			  ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pActiveCommandData->Unlock();
	
	//
	// clean up
	//
	DNASSERT( pThisEndpoint->m_PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->m_PendingCommandData.EnumQueryData.pAddressDeviceInfo );

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->m_pSPData->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteEnumQuery - complete enum query process
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteEnumQuery"

HRESULT	CEndpoint::CompleteEnumQuery( void )
{
	HRESULT		hr;
	HRESULT		hTempResult;
	BOOL		fEndpointLocked;
	UINT_PTR	uRetryCount;
	BOOL		fRetryForever;
	DN_TIME		RetryInterval;
	BOOL		fWaitForever;
	DN_TIME		IdleTimeout;
	SPIE_ENUMADDRESSINFO	EnumAddressInfo;
	IDirectPlay8Address		*pDeviceAddress;


	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	IdleTimeout.Time32.TimeHigh = 0;
	IdleTimeout.Time32.TimeLow = 0;
	memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );
	pDeviceAddress = m_PendingCommandData.EnumQueryData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );

	DNASSERT( m_pSPData != NULL );

	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );
	DNASSERT( m_fCommandPending != FALSE );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( m_PendingCommandData.EnumQueryData.hCommand == m_pActiveCommandData );
	DNASSERT( m_PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );

	//
	// Since this endpoint will be passed off to the timer thread, add a reference
	// for the thread.  If the handoff fails, DecRef()
	//
	AddRef();
	
	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_ENUM_QUERY );
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is still pending, mark it as in-progress
		//
		case COMMAND_STATE_PENDING:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
			
			Lock();
			fEndpointLocked = TRUE;
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPF( 0, "User cancelled enum query!" );

			break;
		}
	
		//
		// command is in progress (probably came here from a dialog)
		//
		case COMMAND_STATE_INPROGRESS:
		{
			Lock();
			fEndpointLocked = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// Submit job to the work thread.  Mark the endpoint as enuming in case the
	// enum thread takes off immediately.  If the endpoint fails to submit the enum
	// job it will be closed so changing the state was just a waste of a clock cycle.
	//
	m_State = ENDPOINT_STATE_ENUM;
	
	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GATEWAY_BIND_TYPE_DEFAULT );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Submit job to the work thread.  Mark the endpoint as enuming in case the
	// enum thread takes off immediately.  If the endpoint fails to submit the enum
	// job it will be closed so changing the state was just a waste of a clock cycle.
	//
	m_State = ENDPOINT_STATE_ENUM;
	
	EnumAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
	EnumAddressInfo.pHostAddress = GetRemoteHostDP8Address();
	EnumAddressInfo.hCommandStatus = DPN_OK;
	EnumAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

	if ( ( EnumAddressInfo.pHostAddress == NULL ) ||
		 ( EnumAddressInfo.pDeviceAddress == NULL ) )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
												SPEV_ENUMADDRESSINFO,					// event type
												&EnumAddressInfo						// pointer to data
												);
	DNASSERT( hTempResult == DPN_OK );
	
	//
	// check retry count to determine if we're enumerating forever
	//
	switch ( m_PendingCommandData.EnumQueryData.dwRetryCount )
	{
		//
		// let SP determine retry count
		//
		case 0:
		{
			uRetryCount = DEFAULT_ENUM_RETRY_COUNT;
			fRetryForever = FALSE;
			break;
		}

		//
		// retry forever
		//
		case INFINITE:
		{
			uRetryCount = 1;
			fRetryForever = TRUE;
			break;
		}

		//
		// other
		//
		default:
		{
			uRetryCount = m_PendingCommandData.EnumQueryData.dwRetryCount;
			fRetryForever = FALSE;
			break;
		}
	}
	
	//
	// check interval for default
	//
	RetryInterval.Time32.TimeHigh = 0;
	if ( m_PendingCommandData.EnumQueryData.dwRetryInterval == 0 )
	{
		RetryInterval.Time32.TimeLow = DEFAULT_ENUM_RETRY_INTERVAL;
	}
	else
	{
		RetryInterval.Time32.TimeLow = m_PendingCommandData.EnumQueryData.dwRetryInterval;
	}

	//
	// check timeout to see if we're enumerating forever
	//
	switch ( m_PendingCommandData.EnumQueryData.dwTimeout )
	{
		//
		// wait forever
		//
		case INFINITE:
		{
			fWaitForever = TRUE;
			IdleTimeout.Time32.TimeHigh = -1;
			IdleTimeout.Time32.TimeLow = -1;
			break;
		}

		//
		// possible default
		//
		case 0:
		{
			fWaitForever = FALSE;
			IdleTimeout.Time32.TimeHigh = 0;
			IdleTimeout.Time32.TimeLow = DEFAULT_ENUM_TIMEOUT;	
			break;
		}

		//
		// other
		//
		default:
		{
			fWaitForever = FALSE;
			IdleTimeout.Time32.TimeHigh = 0;
			IdleTimeout.Time32.TimeLow = m_PendingCommandData.EnumQueryData.dwTimeout;
			break;
		}
	}

	memset( m_dwEnumSendTimes, 0x00, sizeof( m_dwEnumSendTimes ) );
	m_dwEnumSendIndex = 0;

	hr = m_pSPData->GetThreadPool()->SubmitTimerJob( uRetryCount,						// number of times to retry command
													 fRetryForever,						// retry forever
													 RetryInterval,						// retry interval
													 fWaitForever,						// wait forever after all enums sent
													 IdleTimeout,						// timeout to wait after command complete
													 CEndpoint::EnumTimerCallback,		// function called when timer event fires
													 CEndpoint::EnumCompleteWrapper,	// function called when timer event expires
													 m_pActiveCommandData );			// context
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to spool enum job on work thread!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( m_fCommandPending != FALSE );
	DNASSERT( m_pActiveCommandData != NULL );
	
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

Exit:
	if ( EnumAddressInfo.pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( EnumAddressInfo.pHostAddress );
		EnumAddressInfo.pHostAddress = NULL;
	}

	if ( EnumAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( EnumAddressInfo.pDeviceAddress );
		EnumAddressInfo.pDeviceAddress = NULL;
	}
	
	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );
	
	return	hr;

Failure:
	//
	// we've failed to complete the enum query, clean up and return this
	// endpoint to the pool
	//
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	//
	// remove timer thread reference
	//
	DecRef();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumCompleteWrapper - wrapper when enum has completed
//
// Entry:		Error code from enum command
//				Pointer to context	
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumCompleteWrapper"

void	CEndpoint::EnumCompleteWrapper( const HRESULT hResult, void *const pContext )
{
	CCommandData	*pCommandData;


	DNASSERT( pContext != NULL );
	pCommandData = static_cast<CCommandData*>( pContext );
	pCommandData->GetEndpoint()->EnumComplete( hResult );
	pCommandData->GetEndpoint()->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumComplete - enum has completed
//
// Entry:		Error code from enum command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumComplete"

void	CEndpoint::EnumComplete( const HRESULT hResult )
{
	Lock();
	switch ( m_State )
	{
		//
		// enumerating, note that this endpoint is disconnecting
		//
		case ENDPOINT_STATE_ENUM:
		{
			SetState( ENDPOINT_STATE_DISCONNECTING );
			break;
		}

		//
		// disconnecting (command was probably cancelled)
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	Unlock();

	m_dwEnumSendIndex = 0;
	m_pSPData->CloseEndpointHandle( this );
	Close( hResult );

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CleanUpCommand - clean up this endpoint and unbind from CSocketPort
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CleanupCommand"

void	CEndpoint::CleanUpCommand( void )
{
	//
	// There is an 'EndpointRef' that the endpoint holds against the
	// socket port since it was created and always must be released.
	// If the endpoint was bound it needs to be unbound.
	//
	if ( GetSocketPort() != NULL )
	{
		DNASSERT( m_pSPData != NULL );
		m_pSPData->UnbindEndpoint( this );
	}
	
	//
	// If we're bailing here it's because the UI didn't complete.  There is no
	// adapter guid to return because one may have not been specified.  Return
	// a bogus endpoint handle so it can't be queried for addressing data.
	//
	if ( m_fListenStatusNeedsToBeIndicated != FALSE )
	{
		HRESULT				hTempResult;
		SPIE_LISTENSTATUS	ListenStatus;
		

		m_fListenStatusNeedsToBeIndicated = FALSE;
		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hCommand = m_pActiveCommandData;
		ListenStatus.hEndpoint = INVALID_HANDLE_VALUE;
		ListenStatus.hResult = m_hPendingCommandResult;
		memset( &ListenStatus.ListenAdapter, 0x00, sizeof( ListenStatus.ListenAdapter ) );
		ListenStatus.pUserContext = m_pActiveCommandData->GetUserContext();

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);
		DNASSERT( hTempResult == DPN_OK );
	}
	
	m_State = ENDPOINT_STATE_UNINITIALIZED;
	SetHandle( INVALID_HANDLE_VALUE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumData - process received enum data
//
// Entry:		Pointer to received buffer
//				Associated enum key
//				Pointer to return address
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumData"

void	CEndpoint::ProcessEnumData( SPRECEIVEDBUFFER *const pBuffer, const DWORD dwEnumKey, const CSocketAddress *const pReturnSocketAddress )
{
	DNASSERT( pBuffer != NULL );
	DNASSERT( pReturnSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// we're listening, this is the only way to detect enums
		//
		case ENDPOINT_STATE_LISTEN:
		{
			ENDPOINT_ENUM_QUERY_CONTEXT	QueryContext;
			HRESULT		hr;


			//
			// initialize
			//
			DNASSERT( m_pActiveCommandData != NULL );
			DEBUG_ONLY( memset( &QueryContext, 0x00, sizeof( QueryContext ) ) );

			//
			// set callback data
			//
			QueryContext.hEndpoint = GetHandle();
			QueryContext.dwEnumKey = dwEnumKey;
			QueryContext.pReturnAddress = pReturnSocketAddress;
			
			QueryContext.EnumQueryData.pReceivedData = pBuffer;
			QueryContext.EnumQueryData.pUserContext = m_pActiveCommandData->GetUserContext();

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
			QueryContext.EnumQueryData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress();
			QueryContext.EnumQueryData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );

			if ( ( QueryContext.EnumQueryData.pAddressSender != NULL ) &&
				 ( QueryContext.EnumQueryData.pAddressDevice != NULL ) )
			{
				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_ENUMQUERY,							// data type
												   &QueryContext.EnumQueryData				// pointer to data
												   );
				if ( hr != DPN_OK )
				{
					DPF( 0, "User returned unexpected error from enum query indication!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}
			}

			if ( QueryContext.EnumQueryData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressSender );
				QueryContext.EnumQueryData.pAddressSender = NULL;
 			}
			
			if ( QueryContext.EnumQueryData.pAddressDevice != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressDevice );
				QueryContext.EnumQueryData.pAddressDevice = NULL;
 			}

			break;
		}

		//
		// we're disconnecting, ignore this message
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumResponseData - process received enum response data
//
// Entry:		Pointer to received data
//				Pointer to address of sender
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumResponseData"

void	CEndpoint::ProcessEnumResponseData( SPRECEIVEDBUFFER *const pBuffer,
											const CSocketAddress *const pReturnSocketAddress,
											const UINT_PTR uRTTIndex )
{
	DNASSERT( pBuffer != NULL );
	DNASSERT( pReturnSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// endpoint is enuming, it can handle enum responses
		//
		case ENDPOINT_STATE_ENUM:
		{
			SPIE_QUERYRESPONSE	QueryResponseData;
			HRESULT	hr;


			//
			// initialize
			//
			DNASSERT( m_pActiveCommandData != NULL );
			DEBUG_ONLY( memset( &QueryResponseData, 0x00, sizeof( QueryResponseData ) ) );

			//
			// set message data
			//
			QueryResponseData.pAddressSender = NULL;
			QueryResponseData.pReceivedData = pBuffer;
			QueryResponseData.dwRoundTripTime = timeGetTime() - m_dwEnumSendTimes[ uRTTIndex ];
			QueryResponseData.pUserContext = m_pActiveCommandData->GetUserContext();

			//
			// attempt to build a DPlay8Addresses for the user, if we can't allocate
			// the memory ignore this enum
			//
			QueryResponseData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress();
			QueryResponseData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
			
			if ( ( QueryResponseData.pAddressSender != NULL ) &&
				 ( QueryResponseData.pAddressDevice != NULL ) )
			{
				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_QUERYRESPONSE,						// data type
												   &QueryResponseData						// pointer to data
												   );
				if ( hr != DPN_OK )
				{
					DPF( 0, "User returned unknown error when indicating query response!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}
			}

			if ( QueryResponseData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
				QueryResponseData.pAddressSender = NULL;
			}

			if ( QueryResponseData.pAddressDevice != NULL )
			{
				IDirectPlay8Address_Release( QueryResponseData.pAddressDevice );
				QueryResponseData.pAddressDevice = NULL;
			}

			break;
		}

		//
		// endpoint is disconnecting, ignore data
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserData - process received user data
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserData"

void	CEndpoint::ProcessUserData( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );

	switch ( m_State )
	{
		//
		// endpoint is connected
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT		hr;
			SPIE_DATA	UserData;


			//
			// it's possible that the user wants to keep the data, add a
			// reference to keep it from going away
			//
			pReadData->AddRef();
			DEBUG_ONLY( DNASSERT( pReadData->m_fRetainedByHigherLayer == FALSE ) );
			DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = TRUE );

			//
			// we're connected report the user data
			//
			DEBUG_ONLY( memset( &UserData, 0x00, sizeof( UserData ) ) );
			UserData.hEndpoint = GetHandle();
			UserData.pEndpointContext = GetUserEndpointContext();
			UserData.pReceivedData = pReadData->ReceivedBuffer();

			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to interface
											   SPEV_DATA,								// user data was received
											   &UserData								// pointer to data
											   );
			switch ( hr )
			{
				//
				// user didn't keep the data, remove the reference added above
				//
				case DPN_OK:
				{
					DNASSERT( pReadData != NULL );
					DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
					pReadData->DecRef();
					break;
				}

				//
				// The user kept the data buffer, they will return it later.
				// Leave the reference to prevent this buffer from being returned
				// to the pool.
				//
				case DPNERR_PENDING:
				{
					break;
				}


				//
				// Unknown return.  Remove the reference added above.
				//
				default:
				{
					DNASSERT( pReadData != NULL );
					DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
					pReadData->DecRef();

					DPF( 0, "User returned unknown error when indicating user data!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// Endpoint disconnecting, or we haven't finished acknowledging a connect,
		// ignore data.
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserDataOnListen - process received user data on a listen
//		port that may result in a new connection
//
// Entry:		Pointer to received data
//				Pointer to socket address that data was received from
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserDataOnListen"

void	CEndpoint::ProcessUserDataOnListen( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress )
{
	HRESULT			hr;
	CEndpoint		*pNewEndpoint;
	SPIE_CONNECT	ConnectData;


	DNASSERT( pReadData != NULL );
	DNASSERT( pSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	DPF( 8, "Reporting connect on a listen!" );

	//
	// initialize
	//
	pNewEndpoint = NULL;

	switch ( m_State )
	{
		//
		// this endpoint is still listening
		//
		case ENDPOINT_STATE_LISTEN:
		{
			break;
		}

		//
		// we're unable to process this user data, exti
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// get a new endpoint from the pool
	//
	pNewEndpoint = m_pSPData->GetNewEndpoint();
	if ( pNewEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Could not create new endpoint for new connection on listen!" );
		goto Failure;
	}

	//
	// open this endpoint as a new connection, since the new endpoint
	// is related to 'this' endpoint, copy local information
	//
	hr = pNewEndpoint->Open( ENDPOINT_TYPE_CONNECT_ON_LISTEN,
							 NULL,
							 pSocketAddress
							 );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem initializing new endpoint when indicating connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = m_pSPData->BindEndpoint( pNewEndpoint, NULL, GetSocketPort()->GetNetworkAddress(), GATEWAY_BIND_TYPE_DEFAULT );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to bind new endpoint for connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Indicate connect on this endpoint.
	//
	DEBUG_ONLY( memset( &ConnectData, 0x00, sizeof( ConnectData ) ) );
	DBG_CASSERT( sizeof( ConnectData.hEndpoint ) == sizeof( pNewEndpoint ) );
	ConnectData.hEndpoint = pNewEndpoint->GetHandle();

	DNASSERT( m_fCommandPending != FALSE );
	DNASSERT( m_pActiveCommandData != NULL );
	ConnectData.pCommandContext = m_PendingCommandData.ListenData.pvContext;

	DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
	hr = pNewEndpoint->SignalConnect( &ConnectData );
	switch ( hr )
	{
		//
		// user accepted new connection
		//
		case DPN_OK:
		{
			//
			// fall through to code below
			//

			break;
		}

		//
		// user refused new connection
		//
		case DPNERR_ABORTED:
		{
			DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
			DPF( 8, "User refused new connection!" );
			goto Failure;

			break;
		}

		//
		// other
		//
		default:
		{
			DPF( 0, "Unknown return when indicating connect event on new connect from listen!" );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );

			break;
		}
	}

	//
	// note that a connection has been establised and send the data received
	// through this new endpoint
	//
	pNewEndpoint->ProcessUserData( pReadData );

Exit:
	return;

Failure:
	if ( pNewEndpoint != NULL )
	{
		//
		// closing endpoint decrements reference count and may return it to the pool
		//
		pNewEndpoint->Close( hr );
		m_pSPData->CloseEndpointHandle( pNewEndpoint );
		pNewEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumTimerCallback - timed callback to send enum data
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumTimerCallback"

void	CEndpoint::EnumTimerCallback( void *const pContext )
{
	CCommandData	*pCommandData;
	CEndpoint		*pThisObject;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CWriteIOData	*pWriteData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pCommandData = static_cast<CCommandData*>( pContext );
	pThisObject = pCommandData->GetEndpoint();
	pWriteData = NULL;

	pThisObject->Lock();

	switch ( pThisObject->m_State )
	{
		//
		// we're enumerating (as expected)
		//
		case ENDPOINT_STATE_ENUM:
		{
			break;
		}

		//
		// this endpoint is disconnecting, bail!
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			pThisObject->Unlock();
			goto Exit;

			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	pThisObject->Unlock();

	//
	// attempt to get a new IO buffer for this endpoint
	//
	pWriteData = pThisObject->m_pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
	if ( pWriteData == NULL )
	{
		DPF( 0, "Failed to get write data for an enum!" );
		goto Failure;
	}

	//
	// Set all data for the write.  Since this is an enum and we
	// don't care about the outgoing data so don't send an indication
	// when it completes.
	//
	DNASSERT( pThisObject->m_fCommandPending != FALSE );
	DNASSERT( pThisObject->m_pActiveCommandData != NULL );
	DNASSERT( pThisObject->GetState() == ENDPOINT_STATE_ENUM );
	pWriteData->m_pBuffers = pThisObject->m_PendingCommandData.EnumQueryData.pBuffers;
	pWriteData->m_uBufferCount = pThisObject->m_PendingCommandData.EnumQueryData.dwBufferCount;
	pWriteData->m_pDestinationSocketAddress = pThisObject->GetRemoteAddressPointer();
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_NONE;

	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->m_pCommand->GetUserContext() == NULL );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );

	DNASSERT( pThisObject->GetSocketPort() != NULL );
	pThisObject->m_dwEnumSendIndex++;
	pThisObject->m_dwEnumSendTimes[ ( pThisObject->m_dwEnumSendIndex & ENUM_RTT_MASK ) ] = timeGetTime();
	pThisObject->GetSocketPort()->SendEnumQueryData( pWriteData,
													 ( pThisObject->GetEnumKey()->GetKey() | ( pThisObject->m_dwEnumSendIndex & ENUM_RTT_MASK ) ) );

Exit:
	return;

Failure:
	// nothing to clean up at this time

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalConnect - note connection
//
// Entry:		Pointer to connect data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalConnect"

HRESULT	CEndpoint::SignalConnect( SPIE_CONNECT *const pConnectData )
{
	HRESULT	hr;


	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hEndpoint == GetHandle() );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	switch ( m_State )
	{
		//
		// disconnecting, nothing to do
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;
			break;
		}

		//
		// we're attempting to connect
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DNASSERT( m_fConnectSignalled == FALSE );
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
											   SPEV_CONNECT,							// event type
											   pConnectData								// pointer to data
											   );
			switch ( hr )
			{
				//
				// connection accepted
				//
				case DPN_OK:
				{
					//
					// note that we're connected
					//
					SetUserEndpointContext( pConnectData->pEndpointContext );
					m_fConnectSignalled = TRUE;
					m_State = ENDPOINT_STATE_CONNECT_CONNECTED;
					AddRef();

					break;
				}

				//
				// user aborted connection attempt, nothing to do, just pass
				// the result on
				//
				case DPNERR_ABORTED:
				{
					DNASSERT( GetUserEndpointContext() == NULL );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// states where we shouldn't be getting called
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalDisconnect - note disconnection
//
// Entry:		Old endpoint handle
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint's data is locked!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalDisconnect"

void	CEndpoint::SignalDisconnect( const HANDLE hOldEndpointHandle )
{
	HRESULT	hr;
	SPIE_DISCONNECT	DisconnectData;


	// tell user that we're disconnecting
	DNASSERT( m_fConnectSignalled != FALSE );
	DBG_CASSERT( sizeof( DisconnectData.hEndpoint ) == sizeof( this ) );
	DisconnectData.hEndpoint = hOldEndpointHandle;
	DisconnectData.pEndpointContext = GetUserEndpointContext();
	m_fConnectSignalled = FALSE;
	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
									   SPEV_DISCONNECT,							// event type
									   &DisconnectData							// pointer to data
									   );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with SignalDisconnect!" );
		DisplayDNError( 0, hr );
		DNASSERT( FALSE );
	}

	SetDisconnectIndicationHandle( INVALID_HANDLE_VALUE );

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompletePendingCommand - complete a pending command
//
// Entry:		Error code returned for command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompletePendingCommand"

void	CEndpoint::CompletePendingCommand( const HRESULT hCommandResult )
{
	DNASSERT( m_fCommandPending != FALSE );
	DNASSERT( m_pActiveCommandData != NULL );

	IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet
									m_pActiveCommandData,						// command handle
									hCommandResult,								// return
									m_pActiveCommandData->GetUserContext()		// user cookie
									);

	memset( &m_PendingCommandData, 0x00, sizeof( m_PendingCommandData ) );
	m_fCommandPending = FALSE;
	m_pActiveCommandData->DecRef();
	m_pActiveCommandData = NULL;

	//
	// Now that the command is done, release the interface reference we were
	// holding.
	//
	IDP8ServiceProvider_Release( m_pSPData->COMInterface() );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\debugutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DebugUtils.h
 *  Content:	Winsock service provider debug utilitiy functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/01/98	jtk		Created
 *  01/10/20000	rmt		Updated to build with Millenium build process
 ***************************************************************************/

#ifndef __DEBUG_UTILS_H__
#define __DEBUG_UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct sockaddr SOCKADDR;
typedef struct IDirectPlay8Address	IDirectPlay8Address;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifdef	_DEBUG

//#ifndef	_X86_
//	#define	INT3    DebugBreak()
//#else	// _X86_
//	#define	INT3    _asm{ int 3 }
//#endif	// _X86_
#define	INT3	DNASSERT( FALSE )

void	HexDump( PVOID pData, UINT32 uDataSize );
void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily );
void	DumpAddress( const DWORD dwDebugLevel, const char *const pBaseString, IDirectPlay8Address *const pAddress );

#else	// _DEBUG

#define	INT3
#define HexDump( x, y )
#define DumpSocketAddress( x, y, z )
#define	DumpAddress( x, y, z )

#endif	// _DEBUG

#endif	// __DEBUG_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\handletables.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		HandleTable.cpp
 *  Content:	Handle table
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/28/2000	jtk		Copied from Modem service provider
 ***************************************************************************/

#include "wsockspi.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	HANDLE_GROW_COUNT		32
#define	INVALID_HANDLE_INDEX	WORD_MAX

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_HANDLE_TABLE_ENTRY
{
	DWORD_PTR	dwHandleIndex;
	void		*pContext;
} HANDLE_TABLE_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::CHandleTable - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CHandleTable"

CHandleTables::CHandleTables():
	m_AllocatedEntries( 0 ),
	m_EntriesInUse( 0 ),
	m_FreeIndex( INVALID_HANDLE_INDEX ),
	m_pEntries( NULL ),
	m_fLockInitialized( FALSE )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::~CHandleTable - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::~CHandleTable"

CHandleTables::~CHandleTables()
{
	DNASSERT( m_AllocatedEntries == 0 );
	DNASSERT( m_EntriesInUse == 0 );
	DNASSERT( m_FreeIndex == INVALID_HANDLE_INDEX );
	DNASSERT( m_pEntries == NULL );
	DNASSERT( m_fLockInitialized == FALSE );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Initialize - initialization function
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Initialize"

HRESULT	CHandleTables::Initialize( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	DNASSERT( m_fLockInitialized == FALSE );
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to initialize handle table lock!" );
		goto Failure;
	}
	m_fLockInitialized = TRUE;

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return hr;

Failure:
	Deinitialize();	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Deinitialize - deinitialization function
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Deinitialize"

void	CHandleTables::Deinitialize( void )
{
	DNASSERT( m_EntriesInUse == 0 );

	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	if ( m_pEntries != NULL )
	{
		DNFree( m_pEntries );
		m_pEntries = NULL;
	}
	
	m_AllocatedEntries = 0;
	m_FreeIndex = WORD_MAX;

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::CreateHandle - create a handle
//
// Entry:		Pointer to handle destination
//				Pointer to handle context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CreateHandle"

HRESULT	CHandleTables::CreateHandle( HANDLE *const pHandle, void *const pContext )
{
	HRESULT		hr;
	HANDLE		hReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DNASSERT( pHandle != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	hReturn = INVALID_HANDLE_VALUE;

	//
	// grow table if applicable
	//
	if ( m_EntriesInUse == m_AllocatedEntries )
	{
		hr = Grow();
		if ( hr != DPN_OK )
		{
			DPF( 0, "Failed to grow handle table!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

	//
	// build a handle
	//
	DNASSERT( m_FreeIndex < INVALID_HANDLE_INDEX );
	DBG_CASSERT( sizeof( hReturn ) == sizeof( m_FreeIndex ) );
	hReturn = reinterpret_cast<HANDLE>( m_FreeIndex );
	
	DBG_CASSERT( sizeof( hReturn ) == sizeof( DWORD_PTR ) );
	hReturn = reinterpret_cast<HANDLE>( reinterpret_cast<DWORD_PTR>( hReturn ) | ( ( m_pEntries[ m_FreeIndex ].dwHandleIndex & WORD_MAX ) << 16 ) );
	
	//
	// adjust free handle list before setting handle context
	//
	DBG_CASSERT( sizeof( m_FreeIndex ) == sizeof( m_pEntries[ m_FreeIndex ].pContext ) );
	Index = m_FreeIndex;
	m_FreeIndex = reinterpret_cast<DWORD_PTR>( m_pEntries[ m_FreeIndex ].pContext );
	DNASSERT( m_FreeIndex <= INVALID_HANDLE_INDEX );
	
	m_pEntries[ Index ].pContext = pContext;

	m_EntriesInUse++;

	DNASSERT( hReturn != INVALID_HANDLE_VALUE );
	DNASSERT( hReturn != reinterpret_cast<HANDLE>( INVALID_HANDLE_INDEX ) );
	
	*pHandle = hReturn;
	DNASSERT( hr == DPN_OK );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::InvalidateHandle - invalidate a handle
//
// Entry:		Handle
//
// Exit:		Boolean indicating whether the handle was invalidated in this
//				operation
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::InvalidateHandle"

BOOL	CHandleTables::InvalidateHandle( const HANDLE Handle )
{
	BOOL		fReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DBG_CASSERT( sizeof( Index ) == sizeof( Handle ) );
	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	Index = reinterpret_cast<DWORD_PTR>( Handle ) & WORD_MAX;

	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	if ( ( Index < m_AllocatedEntries ) &&
		 ( ( m_pEntries[ Index ].dwHandleIndex & WORD_MAX ) == ( ( reinterpret_cast<DWORD_PTR>( Handle ) >> 16 ) & WORD_MAX ) ) )
	{
		m_pEntries[ Index ].dwHandleIndex++;
		DBG_CASSERT( sizeof( void* ) == sizeof( m_FreeIndex ) );
		m_pEntries[ Index ].pContext = reinterpret_cast<void*>( m_FreeIndex );
		m_EntriesInUse--;
		m_FreeIndex = Index;
		fReturn = TRUE;
	}
	else
	{
		DNASSERT( Handle == INVALID_HANDLE_VALUE );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::GetAssociatedData - get data associated with the handle
//
// Entry:		Handle
//
// Exit:		Associated data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GetAssociatedData"

void	*CHandleTables::GetAssociatedData( const HANDLE Handle ) const
{
	void		*pReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	pReturn = NULL;
	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	Index = reinterpret_cast<DWORD_PTR>( Handle ) & WORD_MAX;
	if ( ( Index < m_AllocatedEntries ) &&
		 ( ( m_pEntries[ Index ].dwHandleIndex & WORD_MAX ) == ( ( reinterpret_cast<DWORD_PTR>( Handle ) >> 16 ) & WORD_MAX ) ) )
	{
		pReturn = m_pEntries[ Index ].pContext;
	}

	DNASSERT( pReturn != INVALID_HANDLE_VALUE );
	DNASSERT( pReturn != reinterpret_cast<HANDLE>( INVALID_HANDLE_INDEX ) );
	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Grow - grow handle table
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Grow"

HRESULT	CHandleTables::Grow( void )
{
	HRESULT	hr;
	void	*pTemp;


	hr = DPN_OK;
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DNASSERT( m_FreeIndex == WORD_MAX );
	
	if ( m_pEntries == NULL )
	{
		pTemp = DNMalloc( sizeof( *m_pEntries ) * ( m_AllocatedEntries + HANDLE_GROW_COUNT ) );
	}
	else
	{
		pTemp = DNRealloc( m_pEntries, sizeof( *m_pEntries ) * ( m_AllocatedEntries + HANDLE_GROW_COUNT ) );
	}
	
	if ( pTemp == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to grow handle table!" );
	}
	else
	{
		DWORD_PTR	Index;


		//
		// Table was enlarged, link all of the entires at the end of the list
		// into the free list.  Make sure the free list is properly terminated.
		//
		m_pEntries = static_cast<HANDLE_TABLE_ENTRY*>( pTemp );
		Index = m_AllocatedEntries;
		m_FreeIndex = m_AllocatedEntries;
		
		m_AllocatedEntries += HANDLE_GROW_COUNT;
		while ( Index < m_AllocatedEntries )
		{
			DBG_CASSERT( sizeof( Index ) == sizeof( void* ) );
			m_pEntries[ Index ].dwHandleIndex = 0;
			m_pEntries[ Index ].pContext = reinterpret_cast<void*>( Index + 1 );
			Index++;
		}
		
		m_pEntries[ m_AllocatedEntries - 1 ].pContext = reinterpret_cast<void*>( WORD_MAX );
	}

	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\endpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Endpoint.h
 *  Content:	Winsock endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __ENDPOINT_H__
#define __ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of types of endpoints
//
typedef	enum	_ENDPOINT_TYPE
{
	ENDPOINT_TYPE_UNKNOWN = 0,				// unknown
	ENDPOINT_TYPE_CONNECT,					// endpoint is for connect
	ENDPOINT_TYPE_LISTEN,					// endpoint is for enum
	ENDPOINT_TYPE_ENUM,						// endpoint is for listen
	ENDPOINT_TYPE_CONNECT_ON_LISTEN,		// endpoint is for new connect coming from a listen
	ENDPOINT_TYPE_MULTICAST					// endpoint is for multicasting
} ENDPOINT_TYPE;

//
// enumeration of the states an endpoint can be in
//
typedef	enum
{
	ENDPOINT_STATE_UNINITIALIZED = 0,		// uninitialized state
	ENDPOINT_STATE_ATTEMPTING_ENUM,			// attempting to enum
	ENDPOINT_STATE_ENUM,					// endpoint is supposed to enum connections
	ENDPOINT_STATE_ATTEMPTING_CONNECT,		// attempting to connect
	ENDPOINT_STATE_CONNECT_CONNECTED,		// endpoint is supposed to connect and is connected
	ENDPOINT_STATE_ATTEMPTING_LISTEN,		// attempting to listen
	ENDPOINT_STATE_LISTEN,					// endpoint is supposed to listen for connections
	ENDPOINT_STATE_DISCONNECTING,			// endpoint is disconnecting
	ENDPOINT_STATE_MULTICAST,				// endpoint is multicast

	ENDPOINT_STATE_MAX
} ENDPOINT_STATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSocketPort;
class	CSocketAddress;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;

//
// context structure used to get endpoints from the pool
//
typedef	struct	_ENDPOINT_POOL_CONTEXT
{
	CSPData	*pSPData;
} ENDPOINT_POOL_CONTEXT;

//
// structure to bind extra information to an enum query to be used on enum reponse
//
typedef	struct	_ENDPOINT_ENUM_QUERY_CONTEXT
{
	SPIE_QUERY				EnumQueryData;
	HANDLE					hEndpoint;
	DWORD					dwEnumKey;
	const CSocketAddress	*pReturnAddress;
} ENDPOINT_ENUM_QUERY_CONTEXT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// class to act as a key for the enum lists in socket ports
//
class	CEndpointEnumKey
{
	STDNEWDELETE

	public:
		CEndpointEnumKey() { };
		~CEndpointEnumKey() { };

		const UINT_PTR	GetKey( void ) const { return ( m_uKey & ~( ENUM_RTT_MASK ) ); }
		void	SetKey( const UINT_PTR uNewKey ) { m_uKey = uNewKey; };

		const INT_PTR	CompareFunction( const CEndpointEnumKey *const OtherKey ) const
		{
			INT_PTR	iReturn;


			if ( GetKey() == OtherKey->GetKey() )
			{
				iReturn = 0;
			}
			else
			{
				if ( GetKey() < OtherKey->GetKey() )
				{
					iReturn = -1;
				}
				else
				{
					iReturn = 1;
				}
			}

			return iReturn;
		}

		const INT_PTR	HashFunction( const UINT_PTR HashBitCount ) const
		{
			INT_PTR		iReturn;
			UINT_PTR	Temp;


			//
			// initialize
			//
			iReturn = 0;

			//
			// hash enum key
			//
			Temp = GetKey();
			do
			{
				iReturn ^= Temp & ( ( 1 << HashBitCount ) - 1 );
				Temp >>= HashBitCount;
			} while ( Temp != 0 );

			return	 iReturn;
		}

	private:
		UINT_PTR	m_uKey;
};

//
// class for an endpoint
//
class	CEndpoint : public CLockedContextFixedPoolItem< ENDPOINT_POOL_CONTEXT* >
{
	STDNEWDELETE

	public:
		//
		// we need a virtual destructor to guarantee we call destructors in base classes
		//
		CEndpoint();
		virtual	~CEndpoint();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Lock"
		void	Lock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

//		void	AddRef( void )
//		{
//		    DNInterlockedIncrement( &m_iRefCount );
//		}
//
//		void	DecRef( void )
//		{
//		    DNASSERT( m_iRefCount != 0 );
//		    if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
//		    {
//		    	ReturnSelfToPool();
//		    }
//		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::AddCommandRef"
		void	AddCommandRef( void )
		{
			DNInterlockedIncrement( &m_lCommandRefCount );
			AddRef();
//			DNInterlockedIncrement( &m_iRefCount );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::DecCommandRef"
		void	DecCommandRef( void )
		{
			if ( DNInterlockedDecrement( &m_lCommandRefCount ) == 0 )
			{
				CleanUpCommand();
			}

			DecRef();
//			DNASSERT( m_iRefCount != 0 );
//			if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
//			{
//			    ReturnSelfToPool();
//			}
		}

		HANDLE	GetHandle( void ) const { return m_Handle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetHandle"
		void	SetHandle( const HANDLE Handle )
		{
			DNASSERT( ( m_Handle == INVALID_HANDLE_VALUE ) || ( Handle == INVALID_HANDLE_VALUE ) );
			m_Handle = Handle;
		}

		HRESULT	Open( const ENDPOINT_TYPE EndpointType,
					  IDirectPlay8Address *const pDP8Address,
					  const CSocketAddress *const pSocketAddress );
		void	Close( const HRESULT hActiveCommandResult );
		void	ReinitializeWithBroadcast( void ) { m_pRemoteMachineAddress->InitializeWithBroadcastAddress(); }

		void	*GetUserEndpointContext( void ) const { return m_pUserEndpointContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetUserEndpointContext"
		void	SetUserEndpointContext( void *const pUserEndpointContext )
		{
			DNASSERT( ( m_pUserEndpointContext == NULL ) ||
					  ( pUserEndpointContext == NULL ) );
			m_pUserEndpointContext = pUserEndpointContext;
		}

		const ENDPOINT_TYPE		GetType( void ) const { return m_EndpointType; }
		
		const ENDPOINT_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetState"
		void	SetState( const ENDPOINT_STATE EndpointState )
		{
			DNASSERT( EndpointState == ENDPOINT_STATE_DISCONNECTING );
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			m_State = EndpointState;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetWritableRemoteAddressPointer"
		CSocketAddress	*GetWritableRemoteAddressPointer( void ) const
		{
		    DNASSERT( m_pRemoteMachineAddress != NULL );
		    return m_pRemoteMachineAddress;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetRemoteAddressPointer"
		const CSocketAddress	*GetRemoteAddressPointer( void ) const
		{
		    DNASSERT( m_pRemoteMachineAddress != NULL );
		    return m_pRemoteMachineAddress;
		}
		
		void	ChangeLoopbackAlias( const CSocketAddress *const pSocketAddress ) const;

		const CEndpointEnumKey	*GetEnumKey( void ) const { return &m_EnumKey; }
		void	SetEnumKey( const UINT_PTR uKey ) { m_EnumKey.SetKey( uKey ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetLocalAdapterDP8Address"
		IDirectPlay8Address *GetLocalAdapterDP8Address( const SP_ADDRESS_TYPE AddressType ) const
		{
			DNASSERT( m_fInitialized != FALSE );
			DNASSERT( GetSocketPort() != NULL );
			return	GetSocketPort()->GetDP8BoundNetworkAddress( AddressType );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetRemoteHostDP8Address"
		IDirectPlay8Address *GetRemoteHostDP8Address( void ) const
		{
			DNASSERT( m_fInitialized != FALSE );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			return	m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
		}

		CSocketPort	*GetSocketPort( void ) const { return m_pSocketPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetSocketPort"
		void		SetSocketPort( CSocketPort *const pSocketPort )
		{
			DNASSERT( ( m_pSocketPort == NULL ) || ( pSocketPort == NULL ) );
			m_pSocketPort = pSocketPort;
		}

		void	CopyConnectData( const SPCONNECTDATA *const pConnectData, IDirectPlay8Address *const pDeviceAddress );
		static	void	ConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteConnect( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::CleanupConnect"
		void	CleanupConnect( void )
		{
			DNASSERT( m_PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );
			IDirectPlay8Address_Release( m_PendingCommandData.ConnectData.pAddressDeviceInfo );
		}

		BOOL	ConnectHasBeenSignalled( void ) const { return m_fConnectSignalled; }
		void	SignalDisconnect( const HANDLE hOldEndpointHandle );
		HANDLE	GetDisconnectIndicationHandle( void ) const { return this->m_hDisconnectIndicationHandle; }
		void	SetDisconnectIndicationHandle( const HANDLE hDisconnectIndicationHandle )
		{
			DNASSERT( ( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE ) ||
					  ( hDisconnectIndicationHandle == INVALID_HANDLE_VALUE ) );
			m_hDisconnectIndicationHandle = hDisconnectIndicationHandle;
		}

		HRESULT	Disconnect( const HANDLE hOldEndpointHandle );
		void	StopEnumCommand( const HRESULT hCommandResult );

		void	CopyListenData( const SPLISTENDATA *const pListenData, IDirectPlay8Address *const pDeviceAddress );
		static	void	ListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteListen( void );

		void	CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData, IDirectPlay8Address *const pDeviceAddress );
		static	void	EnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );			// delayed job callback
		static	void	CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );	// cancel delayed job callback
		HRESULT	CompleteEnumQuery( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::CleanupEnumQuery"
		void	CleanupEnumQuery( void )
		{
			DNASSERT( m_PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );
			IDirectPlay8Address_Release( m_PendingCommandData.EnumQueryData.pAddressDeviceInfo );
		}

		void	ProcessEnumData( SPRECEIVEDBUFFER *const pBuffer, const DWORD dwEnumKey, const CSocketAddress *const pReturnSocketAddress );
		void	ProcessEnumResponseData( SPRECEIVEDBUFFER *const pBuffer,
										 const CSocketAddress *const pReturnSocketAddress,
										 const UINT_PTR uRTTIndex );
		void	ProcessUserData( CReadIOData *const pReadData );
		void	ProcessUserDataOnListen( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendUserData"
		void	SendUserData( CWriteIOData *const pWriteData )
		{
			DNASSERT( ( m_State == ENDPOINT_STATE_CONNECT_CONNECTED ) ||
					  ( m_State == ENDPOINT_STATE_MULTICAST ) );
			DNASSERT( GetSocketPort() != NULL );
			DNASSERT( pWriteData->SocketPort() == NULL );

			GetSocketPort()->SendUserData( pWriteData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendEnumResponseData"
		void	SendEnumResponseData( CWriteIOData *const pWriteData, const UINT_PTR uEnumKey )
		{
			DNASSERT( GetSocketPort() != NULL );
			GetSocketPort()->SendEnumResponseData( pWriteData, uEnumKey );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendProxiedEnumData"
		void	SendProxiedEnumData( CWriteIOData *const pWriteData, const CSocketAddress *const pReturnAddress, const UINT_PTR uOldEnumKey )
		{
			DNASSERT( pWriteData != NULL );
			DNASSERT( pReturnAddress != NULL );

			DNASSERT( m_State == ENDPOINT_STATE_LISTEN );
			DNASSERT( GetSocketPort() != NULL );

			GetSocketPort()->SendProxiedEnumData( pWriteData, pReturnAddress, uOldEnumKey );
		}


		//
		// pool functions
		//
		virtual	BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext ) = 0;
		virtual	BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext ) = 0;
		virtual	void	PoolReleaseFunction( void ) = 0;
		virtual	void	PoolDeallocFunction( void ) = 0;

	protected:
		volatile	ENDPOINT_STATE		m_State;					// endpoint state
		volatile	BOOL				m_fConnectSignalled;		// Boolean indicating whether we've indicated a connection on this endpoint

		ENDPOINT_TYPE		m_EndpointType;				// type of endpoint
		CSocketAddress		*m_pRemoteMachineAddress;	// pointer to address of remote machine

		CSPData				*m_pSPData;					// pointer to SPData
		CSocketPort			*m_pSocketPort;				// pointer to associated socket port

		CEndpointEnumKey	m_EnumKey;					// key used for enums
		void				*m_pUserEndpointContext;	// context passed back with endpoint handles

		BOOL	m_fListenStatusNeedsToBeIndicated;


		HRESULT	Initialize( void );
		void	Deinitialize( void );
		
		BOOL	CommandPending( void ) const { return m_fCommandPending; }
		HRESULT	PendingCommandResult( void ) const { return m_hPendingCommandResult; }
		void	CompletePendingCommand( const HRESULT hCommandResult );

		HRESULT	SignalConnect( SPIE_CONNECT *const pConnectData );

		DEBUG_ONLY(	BOOL	m_fInitialized );
		DEBUG_ONLY( BOOL	m_fEndpointOpen );

	private:
		DNCRITICAL_SECTION	m_Lock;				// critical section
		HANDLE			m_Handle;				// endpoint handle returned when queried
		volatile LONG	m_lCommandRefCount;		// Command ref count.  When this goes to
												// zero, the endpoint is unbound from
												// the CSocketPort

		BOOL		m_fCommandPending;				// Boolean indicating that there's a pending command
		HRESULT		m_hPendingCommandResult;		// result for pending command
		HANDLE		m_hDisconnectIndicationHandle;	// handle to be returned when disconnect is finally signalled

		union									// Local copy of the pending command data.
		{										// This data contains the pointers to the
			SPCONNECTDATA		ConnectData;	// active command, and the user context.
			SPLISTENDATA		ListenData;		//
			SPENUMQUERYDATA		EnumQueryData;	//
		} m_PendingCommandData;					//

		CCommandData		*m_pActiveCommandData;		// pointer to command data that's imbedded in m_ActiveCommandData
														// We don't know where in the union the command data really is, and
														// finding iteach time  programmatically would blost the code.

		DWORD	m_dwEnumSendIndex;						//
		DWORD	m_dwEnumSendTimes[ 16 ];				//

		static void		EnumCompleteWrapper( const HRESULT hCompletionCode, void *const pContext );	
		static void		EnumTimerCallback( void *const pContext );
		void	EnumComplete( const HRESULT hCompletionCode );	
		void	CleanUpCommand( void );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CEndpoint( const CEndpoint & );
		CEndpoint& operator=( const CEndpoint & );
};

#undef DPF_MODNAME

#endif	// __ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\iodata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.cpp
 *  Content:	Functions for IO structures
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 *	02/11/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CIOData::CIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIOData::CIOData"

CIOData::CIOData():
	m_pSocketPort( NULL )
{
	memset( &m_Overlap, 0x00, sizeof( m_Overlap ) );
	memset( &m_Flags, 0x00, sizeof( m_Flags ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIOData::~CIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIOData::~CIOData"

CIOData::~CIOData()
{
	DNASSERT( OverlapEvent() == NULL );
	DNASSERT( SocketPort() == NULL );
	DNASSERT( Win9xOperationPending() == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::CReadIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::CReadIOData"

CReadIOData::CReadIOData():
    m_iSocketAddressSize( 0 ),
    m_pSourceSocketAddress( NULL ),
	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
    m_dwOverlappedBytesReceived( 0 ),
	m_dwBytesRead( 0 ),
	m_dwReadFlags( 0 ),
	m_lRefCount( 0 ),
	m_pThreadPool( NULL )
{
	m_OutstandingReadListLinkage.Initialize();
	DEBUG_ONLY( memset( &m_ReceivedData, 0x00, sizeof( m_ReceivedData ) ) );
	DEBUG_ONLY( m_fRetainedByHigherLayer = FALSE );
	DNASSERT( IsReadOperation() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::~CReadIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::~CReadIOData"

CReadIOData::~CReadIOData()
{
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_iSocketAddressSize == 0 );
	DNASSERT( m_pSourceSocketAddress == NULL );
	
	//
	// don't bother looking at the WSA error or bytes received
	//

	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool == NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer ==  FALSE ) );
	DNASSERT( IsReadOperation() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Alloc - called when new CReadIOData is allocated
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Alloc"

BOOL	CReadIOData::ReadIOData_Alloc( READ_IO_DATA_POOL_CONTEXT *const pContext )
{
	BOOL			fReturn;
	CSocketAddress	*pSocketAddress;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pSocketAddress = NULL;

	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_iSocketAddressSize == 0 );
	DNASSERT( m_pSourceSocketAddress == NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );

	//
	// attempt to get a socket address for this item
	//
	pSocketAddress = CreateIPAddress();

	if ( pSocketAddress == NULL )
	{
		DPF( 0, "Problem allocating a new socket address when creating ReadIOData pool item" );
		fReturn = FALSE;
		goto Exit;
	}

	pSocketAddress->SetAddressType( SP_ADDRESS_TYPE_READ_HOST );
	m_pSourceSocketAddress = pSocketAddress;
	m_iSocketAddressSize = pSocketAddress->GetAddressSize();

   	DNASSERT( OverlapEvent() == NULL );
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_lRefCount == 0 );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Get - called when new CReadIOData is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Get"

void	CReadIOData::ReadIOData_Get( READ_IO_DATA_POOL_CONTEXT *const pContext )
{
	DNASSERT( pContext != NULL );

	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_pSourceSocketAddress != NULL );
	DNASSERT( m_iSocketAddressSize == m_pSourceSocketAddress->GetAddressSize() );
	DNASSERT( SocketPort() == NULL );
	DNASSERT( Win9xOperationPending() == FALSE );

	DNASSERT( pContext->pThreadPool != NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );

	m_pSourceSocketAddress->Reset();
	m_pThreadPool = pContext->pThreadPool;
	SetOverlapEvent( pContext->pThreadPool->GetWinsock2ReceiveCompleteEvent() );

	DNASSERT( m_lRefCount == 0 );
	
	//
	// Initialize internal SPRECEIVEDDATA.  When data is received, it's possible
	// that the pointers in the SPRECEIVEDDATA block were manipulated.  Reset
	// them to reflect that the entire buffer is available.
	//
	m_SPReceivedBuffer.BufferDesc.pBufferData = m_ReceivedData;
	m_SPReceivedBuffer.BufferDesc.dwBufferSize = sizeof( m_ReceivedData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Release - called when CReadIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Release"

void	CReadIOData::ReadIOData_Release( void )
{
	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_pSourceSocketAddress != NULL );
	DNASSERT( Win9xOperationPending() == FALSE );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );

	DNASSERT( m_dwOverlappedBytesReceived == 0 );
	m_pThreadPool = NULL;
	SetOverlapEvent( NULL );
	SetSocketPort( NULL );

	DEBUG_ONLY( memset( &m_ReceivedData, 0x00, sizeof( m_ReceivedData ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Dealloc - called when CReadIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Dealloc"

void	CReadIOData::ReadIOData_Dealloc( void )
{
#pragma	TODO( johnkan, "Make SPAddresses have a ref count!" )
	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pSourceSocketAddress != NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );
	ReturnIPAddress( static_cast<CIPAddress*>( m_pSourceSocketAddress ) );
	m_pSourceSocketAddress = NULL;
	m_iSocketAddressSize = 0;

	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReturnSelfToPool"

void	CReadIOData::ReturnSelfToPool( void )
{
	CThreadPool	*pThreadPool;


	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool != NULL );

	pThreadPool = m_pThreadPool;
	pThreadPool->ReturnReadIOData( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::CWriteIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::CWriteIOData"

CWriteIOData::CWriteIOData():
	m_pNext( NULL ),
	m_pDestinationSocketAddress( NULL ),
	m_pBuffers( NULL ),
	m_uBufferCount( 0 ),
	m_pCommand( NULL ),
	m_SendCompleteAction( SEND_COMPLETE_ACTION_UNKNOWN ),
	m_Win9xSendHResult( DPN_OK ),
	m_dwOverlappedBytesSent( 0 ),
	m_dwBytesSent( 0 ),
	m_pProxiedEnumReceiveBuffer( NULL )
{
	m_OutstandingWriteListLinkage.Initialize();
	memset( &m_PrependBuffer, 0x00, sizeof( m_PrependBuffer ) );
	SetWriteOperation();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::~CWriteIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::~CWriteIOData"

CWriteIOData::~CWriteIOData()
{
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_pProxiedEnumReceiveBuffer == NULL );
	DNASSERT( IsWriteOperation() != FALSE );

	//
	// don't bother checking the send hResult or the count of byes sent
	//
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Alloc - called when new CWriteIOData is allocated
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = allocation succeeded
//				FALSE = allocation failed
//
// Note:	We always want a command structure associated with CWriteIOData
//			so we don't need to grab a new command from the command pool each
//			time a CWriteIOData entry is removed from its pool.  This is done
//			for speed.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Alloc"

BOOL	CWriteIOData::WriteIOData_Alloc( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
{
	BOOL	fReturn;
	CCommandData	*pCommand;


	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( pContext != NULL );
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	//
	// initialize
	//
	fReturn = TRUE;

	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		DPF( 0, "Could not get command when allocating new CWriteIOData!" );
		fReturn = FALSE;
		goto Exit;
	}

	//
	// associate this command with the WriteData, clear the command descriptor
	// because the command isn't really being used yet, and it'll
	// cause an ASSERT when it's removed from the WriteIOData pool.
	//
	m_pCommand = pCommand;
	DNASSERT( OverlapEvent() == NULL );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Get - called when new CWriteIOData is removed from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Get"

void	CWriteIOData::WriteIOData_Get( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
{
	DNASSERT( pContext != NULL );

	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );

	DNASSERT( m_pCommand != NULL );
	m_pCommand->SetDescriptor();

	DNASSERT( m_pCommand->GetDescriptor() != NULL_DESCRIPTOR );
	DNASSERT( m_pCommand->GetUserContext() == NULL );
	
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( SocketPort() == NULL );
	DNASSERT( Win9xOperationPending() == FALSE );

	DNASSERT( m_PrependBuffer.GenericHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
	SetOverlapEvent( pContext->hOverlapEvent );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Release - called when CWriteIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Release"

void	CWriteIOData::WriteIOData_Release( void )
{
	DNASSERT( m_pCommand != NULL );
	m_pCommand->Reset();

	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( Win9xOperationPending() == FALSE );

	SetOverlapEvent( NULL );

	m_pBuffers = NULL;
	m_uBufferCount = 0;
	m_pDestinationSocketAddress = NULL;
	m_pNext = NULL;
	SetSocketPort( NULL );
	m_SendCompleteAction = SEND_COMPLETE_ACTION_UNKNOWN;

	DEBUG_ONLY( memset( &m_PrependBuffer, 0x00, sizeof( m_PrependBuffer ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Dealloc - called when new CWriteIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Dealloc"

void	CWriteIOData::WriteIOData_Dealloc( void )
{
	DNASSERT( m_pCommand != NULL );
	m_pCommand->DecRef();
	m_pCommand = NULL;

	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
	SetOverlapEvent( NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\handletables.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		HandleTable.h
 *  Content:	DNSerial communications handle table
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/15/2000	jtk		Created
 ***************************************************************************/

#ifndef __HANDLE_TABLE_H__
#define __HANDLE_TABLE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward srtucture references
//
typedef	struct	_HANDLE_TABLE_ENTRY	HANDLE_TABLE_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CHandleTables
{
	STDNEWDELETE

	public:
		CHandleTables();
		virtual	~CHandleTables();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CHandleTable::Lock"
		void	Lock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CHandleTable::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		HRESULT	Initialize( void );
		void	Deinitialize( void );

		HRESULT	CreateHandle( HANDLE *const pHandle, void *const pContext );
		BOOL	InvalidateHandle( const HANDLE Handle );
		void	*GetAssociatedData( const HANDLE Handle ) const;

	private:
		DNCRITICAL_SECTION	m_Lock;	   		// critical section
		
		DWORD_PTR	m_AllocatedEntries;
		DWORD_PTR	m_EntriesInUse;
		DWORD_PTR	m_FreeIndex;
		HANDLE_TABLE_ENTRY	*m_pEntries;

		//
		// initialization state booleans
		//
		BOOL	m_fLockInitialized;
		
		HRESULT	Grow( void );
		
		
		DEBUG_ONLY(	BOOL	m_fInitialized );
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CHandleTables( const CHandleTables & );
		CHandleTables& operator=( const CHandleTables & );
};

#undef DPF_MODNAME

#endif	// __HANDLE_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\ipendpt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPEndpoint.cpp
 *  Content:	IP endpoint class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::CIPEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::CIPEndpoint"

CIPEndpoint::CIPEndpoint():
	m_pOwningPool( NULL )
{
	m_pRemoteMachineAddress = &m_IPAddress;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::~CIPEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::~CIPEndpoint"

CIPEndpoint::~CIPEndpoint()
{
	DEBUG_ONLY( m_pRemoteMachineAddress = NULL );
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolAllocFunction"

BOOL	CIPEndpoint::PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;
	HRESULT	hr;


	DNASSERT( pContext != NULL );
	
	//
	// initialize
	//
	fReturn = TRUE;
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	
	hr = Initialize();
	if ( hr != DPN_OK )
	{
		fReturn = FALSE;
		DPF( 0, "Failed to initialize base endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolInitFunction - function called when item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolInitFunction"

BOOL	CIPEndpoint::PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;


	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData != NULL );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pSPData == NULL );
	m_pSPData = pContext->pSPData;
	m_pSPData->ObjectAddRef();

	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	
	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolReleaseFunction - function called when item is returning
//		to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolReleaseFunction"

void	CIPEndpoint::PoolReleaseFunction( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DEBUG_ONLY( DNASSERT( m_fEndpointOpen == FALSE ) );

	m_EndpointType = ENDPOINT_TYPE_UNKNOWN;
	m_EnumKey.SetKey( INVALID_ENUM_KEY );

	DNASSERT( m_fConnectSignalled == FALSE );
	DNASSERT( m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( m_pRemoteMachineAddress != NULL );

	DNASSERT( m_pSPData != NULL );
	m_pSPData->ObjectDecRef();
	m_pSPData = NULL;

	m_pRemoteMachineAddress->Reset();

	DNASSERT( GetSocketPort() == NULL );
	DNASSERT( m_pUserEndpointContext == NULL );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );

	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolDeallocFunction - function called when item is deallocated
//		from the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolDeallocFunction"

void	CIPEndpoint::PoolDeallocFunction( void )
{
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	Deinitialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::ReturnSelfToPool - return this endpoint to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::ReturnSelfToPool"

void	CIPEndpoint::ReturnSelfToPool( void )
{
	if ( CommandPending() != FALSE )
	{
		CompletePendingCommand( PendingCommandResult() );
	}

	if ( ConnectHasBeenSignalled() != FALSE )
	{
		SignalDisconnect( GetDisconnectIndicationHandle() );
	}
	
	DNASSERT( ConnectHasBeenSignalled() == FALSE );

	SetUserEndpointContext( NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\ipaddress.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPAddress.cpp
 *  Content:	Winsock IP address class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// length of IP address string including NULL  "xxx.xxx.xxx.xxx\0"
//
#define	IP_ADDRESS_STRING_LENGTH		16

//
// multicast address to use
//
#pragma	BUGBUG( johnkan, "Hard-coded group ID!" )
#define	IP_MULTICAST_ADDRESS	0xE2E2E2E2

//
// default size of buffers when parsing
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//
// default broadcast and listen addresses
//
const WCHAR	g_IPBroadcastAddress[] = L"255.255.255.255";
const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
static const WCHAR	g_IPListenAddress[] = L"0.0.0.0";

//
// string for IP helper API
//
static const char	g_MultipleIPTemplate[] = "%s - %s";

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::InitializeWithBroadcastAddress - initialize with the IP broadcast address
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CIPAddress::InitializeWithBroadcastAddress( void )
{
	m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = p_htonl( INADDR_BROADCAST );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::InitializeWithAnyAddress - initialize with the IP Any address
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CIPAddress::InitializeWithAnyAddress( void )
{
	m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = p_htonl( INADDR_ANY );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::SetAddressFromSOCKADDR - set address from a socket address
//
// Entry:		Reference to address
//				Size of address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::SetAddressFromSOCKADDR"

void	CIPAddress::SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize )
{
	DNASSERT( iAddressSize == GetAddressSize() );
	memcpy( &m_SocketAddress.SocketAddress, &Address, iAddressSize );

	//
	// Since Winsock won't guarantee that the sin_zero part of an IP address is
	// really zero, we ned to do it ourself.  If we don't, it'll make a mess out
	// of the Guid<-->Address code.
	//
	DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress.sin_zero[ 0 ] ) == sizeof( DWORD* ) );
	DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress.sin_zero[ sizeof( DWORD ) ] ) == sizeof( DWORD* ) );
	*reinterpret_cast<DWORD*>( &m_SocketAddress.IPSocketAddress.sin_zero[ 0 ] ) = 0;
	*reinterpret_cast<DWORD*>( &m_SocketAddress.IPSocketAddress.sin_zero[ sizeof( DWORD ) ] ) = 0;
	DNASSERT( SinZeroIsZero( &m_SocketAddress.IPSocketAddress ) != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::SocketAddressFromDP8Address - convert a DP8Address to a socket address
//
// Entry:		Pointer to address
//				Address type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::SocketAddressFromDP8Address"

HRESULT	CIPAddress::SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
												 const SP_ADDRESS_TYPE AddressType )
{
	HRESULT		hr;
	DWORD		dwAddressSize;
	IDirectPlay8Address		*pDuplicateAddress;
	SOCKADDR	*pSocketAddresses;


	DNASSERT( pDP8Address != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pDuplicateAddress = NULL;
	pSocketAddresses = NULL;

	//
	// reset internal flags
	//
	Reset();

	switch ( AddressType )
	{
		//
		// local device address, ask for the device guid and port to build a socket
		// address
		//
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		case SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET:
		{
			HRESULT	hTempResult;
			DWORD	dwTempSize;
			GUID	AdapterGuid;
			DWORD	dwPort;
			DWORD	dwDataType;
			union
			{
				SOCKADDR	SocketAddress;
				SOCKADDR_IN	INetAddress;
			} INetSocketAddress;


			//
			// Ask for the port.  If none is found, choose a default.
			//
			dwTempSize = sizeof( dwPort );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// port present, nothing to do
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
					break;
				}

				//
				// port not present, fill in the appropriate default
				//
				case DPNERR_DOESNOTEXIST:
				{
					DNASSERT( hr == DPN_OK );
					switch ( AddressType )
					{
						case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
						{
							dwPort = ANY_PORT;
							break;
						}

						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					break;
				}

				//
				// other error, fail
				//
				default:
				{
					hr = hTempResult;
					goto Failure;
					break;
				}
			}
			DNASSERT( sizeof( dwPort ) == dwTempSize );

// BUGBUG: [mgere] [xbox] New stuff added here.

		char	CharBuffer[1000];
        	HOSTENT			*pHostData;

            if ( p_gethostname( CharBuffer, sizeof( CharBuffer ) ) == SOCKET_ERROR )
	        {
		        DWORD	dwWinsockError;

		        hr = DPNERR_GENERIC;
		        dwWinsockError = p_WSAGetLastError();
		        DPF( 0, "Failed to get host name into static buffer!" );
		        DisplayWinsockError( 0, dwWinsockError );
		        DNASSERT( FALSE );
		        goto Failure;
	        }

	        pHostData = p_gethostbyname( CharBuffer );
	        if ( pHostData == NULL )
	        {
		        DWORD	dwWinsockError;

		        hr = DPNERR_GENERIC;
		        dwWinsockError = p_WSAGetLastError();
		        DPF( 0, "Failed to get host data!" );
		        DisplayWinsockError( 0, dwWinsockError );
		        DNASSERT( FALSE );
		        goto Failure;
	        }

	IN_ADDR			TempAddresses;

	memcpy( &TempAddresses, pHostData->h_addr_list[0], sizeof(TempAddresses) );

// BUGBUG: [mgere] [xbox] End new stuff
            
/* BUGBUG: [mgere] [xbox] Removed temporarily
			//
			// if this is a proxied enum, check for the all-adapters address
			// being passed because it's not a valid target (it needs to be
			// remapped to the local loopback).
			//
			if ( ( AddressType == SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET ) &&
				 ( INetSocketAddress.INetAddress.sin_addr.S_un.S_addr == p_htonl( INADDR_ANY ) ) )
			{
				m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = p_htonl( INADDR_LOOPBACK );
			}
			else
			{
				m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = INetSocketAddress.INetAddress.sin_addr.S_un.S_addr;
			}
*/

//          m_SocketAddress.SockAddr.sa_family = GetFamily();
	        m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = TempAddresses.S_un.S_addr;
//	        m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = NULL;

            m_SocketAddress.IPSocketAddress.sin_port = p_htons( static_cast<WORD>( dwPort ) );
			break;
		}

		//
		// hostname
		//
		case SP_ADDRESS_TYPE_HOST:
		{
			HRESULT	hTempResult;
			DWORD	dwPort;
			DWORD	dwTempSize;
			DWORD	dwDataType;



			//
			// duplicate the input address because it might need to be modified
			//
			DNASSERT( pDuplicateAddress == NULL );
			IDirectPlay8Address_Duplicate( pDP8Address, &pDuplicateAddress );
			if ( pDuplicateAddress == NULL )
			{
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}

			//
			// Ask for the port.  If none is found, choose a default.
			//
			dwTempSize = sizeof( dwPort );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// port present, nothing to do
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
					m_SocketAddress.IPSocketAddress.sin_port = p_htons( static_cast<WORD>( dwPort ) );
					break;
				}

				//
				// port not present, fill in the appropriate default
				//
				case DPNERR_DOESNOTEXIST:
				{
					const DWORD	dwTempPort = DPNA_DPNSVR_PORT;


					m_SocketAddress.IPSocketAddress.sin_port = p_htons( static_cast<const WORD>( dwTempPort ) );
					hTempResult = IDirectPlay8Address_AddComponent( pDuplicateAddress,
																	DPNA_KEY_PORT,
																	&dwTempPort,
																	sizeof( dwTempPort ),
																	DPNA_DATATYPE_DWORD
																	);
					if ( hTempResult != DPN_OK )
					{
						hr = hTempResult;
						goto Failure;
					}

					break;
				}

				//
				// remap everything else to an addressing failure
				//
				default:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
				}
			}

			//
			// attempt to determine the host name
			//
			dwAddressSize = 0;
			DNASSERT( pSocketAddresses == NULL );
			
RegetSocketAddressData:
			memset( pSocketAddresses, 0x00, dwAddressSize );
			hr = IDirectPlay8Address_GetSockAddress( pDuplicateAddress, pSocketAddresses, &dwAddressSize );
			switch ( hr )
			{
				//
				// conversion succeeded, check the size of the data returned
				// before setting the information in the local address structure.
				//
				case DPN_OK:
				{
					if ( dwAddressSize < sizeof( *pSocketAddresses ) )
					{
						hr = DPNERR_ADDRESSING;
						goto Failure;
					}
					
					SetAddressFromSOCKADDR( *pSocketAddresses, sizeof( *pSocketAddresses ) );					

					break;
				}

				//
				// Buffer too small, if there is no buffer, allocate one.  If
				// there is a buffer, resize it to containt the data before
				// attempting to get the data again.
				//
				case DPNERR_BUFFERTOOSMALL:
				{
					if ( pSocketAddresses == NULL )
					{
						pSocketAddresses = static_cast<SOCKADDR*>( DNMalloc( dwAddressSize ) );
						if ( pSocketAddresses == NULL )
						{
							hr = DPNERR_OUTOFMEMORY;
							goto Failure;
						}
					}
					else
					{
						void	*pTemp;


						pTemp = DNRealloc( pSocketAddresses, dwAddressSize );
						if ( pTemp == NULL )
						{
							hr = DPNERR_OUTOFMEMORY;
							goto Failure;
						}
					
						pSocketAddresses = static_cast<SOCKADDR*>( pTemp );
					}

					goto RegetSocketAddressData;
					break;
				}

				//
				// Incomplete address, set the address type and return.  It's
				// up to the caller to decide if this is really a problem.
				//
				case DPNERR_INCOMPLETEADDRESS:
				{
					break;
				}

				//
				// pass these error returns untouched
				//
				case DPNERR_OUTOFMEMORY:
				{
					goto Failure;
					break;
				}
			
				//
				// other problem, map it to an addressing error
				//
				default:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
					break;
				}
			}

			break;
		}

		//
		// unknown address type
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	DNASSERT( SinZeroIsZero( &m_SocketAddress.IPSocketAddress ) != FALSE );

	//
	// now that the address has been completely parsed, set the address type
	//
	m_AddressType = AddressType;

Exit:
	if ( pDuplicateAddress != NULL )
	{
		IDirectPlay8Address_Release( pDuplicateAddress );
		pDuplicateAddress = NULL;
	}

	if ( pSocketAddresses != NULL )
	{
		DNFree( pSocketAddresses );
		pSocketAddresses = NULL;
	}

	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with IPAddress::SocketAddressFromDNAddress()" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::DP8AddressFromSocketAddress - convert a socket address to a DP8Address
//
// Entry:		Nothing
//
// Exit:		Pointer to DP8Address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::DP8AddressFromSocketAddress"

IDirectPlay8Address *CIPAddress::DP8AddressFromSocketAddress( void ) const
{
	HRESULT		hr;
	IDirectPlay8Address		*pDP8Address;


	DNASSERT( ( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_DEVICE ] != SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED ) &&
			  ( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] != SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED ) &&
			  ( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_PORT ] != SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED ) );


	//
	// intialize
	//
	hr = DPN_OK;
	pDP8Address = NULL;

	//
	// create and initialize the address
	//
	hr = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pDP8Address, NULL );
	if ( hr != S_OK )
	{
		DPF( 0, "DP8AddressFromSocketAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	switch ( m_AddressType )
	{
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		{
			GUID		DeviceGuid;


			GuidFromInternalAddressWithoutPort( DeviceGuid );
			hr = IDirectPlay8Address_BuildLocalAddress( pDP8Address,
														  &DeviceGuid,
														  p_ntohs( m_SocketAddress.IPSocketAddress.sin_port )
														  );
			break;
		}

		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		case SP_ADDRESS_TYPE_READ_HOST:
		case SP_ADDRESS_TYPE_HOST:
		{
			hr = IDirectPlay8Address_BuildFromSockAddr( pDP8Address, &m_SocketAddress.SocketAddress );
			break;
		}

		default:
		{
			INT3;
			break;
		}
	}

Exit:

	return	pDP8Address;

Failure:

	if ( pDP8Address != NULL )
	{
		IDirectPlay8Address_Release( pDP8Address );
		pDP8Address = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CompareFunction - compare against another address
//
// Entry:		Pointer to other address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CompareFunction"

INT_PTR	CIPAddress::CompareFunction( const CSocketAddress *const pOtherAddress ) const
{
	INT_PTR	iReturn;
	const CIPAddress *const pIPAddress = static_cast<const CIPAddress*>( pOtherAddress );


	DNASSERT( pOtherAddress != NULL );
	DNASSERT( m_SocketAddress.IPSocketAddress.sin_family == pIPAddress->m_SocketAddress.IPSocketAddress.sin_family );

	//
	// we need to compare the IP address and port to guarantee uniqueness
	//
	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == pIPAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr )
	{
		if ( m_SocketAddress.IPSocketAddress.sin_port == pIPAddress->m_SocketAddress.IPSocketAddress.sin_port )
		{
			iReturn = 0;
		}
		else
		{
			if ( m_SocketAddress.IPSocketAddress.sin_port < pIPAddress->m_SocketAddress.IPSocketAddress.sin_port )
			{
				iReturn = -1;
			}
			else
			{
				iReturn = 1;
			}
		}
	}
	else
	{
		if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr < pIPAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr )
		{
			iReturn = -1;
		}
		else
		{
			iReturn = 1;
		}
	}

	return	iReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CreateBroadcastAddress - create DP8Address used for broadcast sends
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateBroadcastAddress"

IDirectPlay8Address *CIPAddress::CreateBroadcastAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;


	//
	// initialize
	//
	pDPlayAddress = NULL;

	hr = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pDPlayAddress, NULL );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPF( 0, "CreateBroadcastAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_BuildAddress( pDPlayAddress, g_IPBroadcastAddress, DPNA_DPNSVR_PORT );
	if ( hr != DPN_OK )
	{
		DPF( 0, "CreateBroadcastAddress: Failed to set hostname and port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CreateListenAddress - create DP8Address used for listens
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateListenAddress"

IDirectPlay8Address *CIPAddress::CreateListenAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;


	//
	// initialize
	//
	pDPlayAddress = NULL;

	hr = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pDPlayAddress, NULL );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPF( 0, "CreateListenAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_BuildAddress( pDPlayAddress, g_IPListenAddress, ANY_PORT );
	if ( hr != DPN_OK )
	{
		DPF( 0, "CreateListenAddress: Failed to set hostname and port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CreateGenericAddress - create a generic address
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateGenericAddress"

IDirectPlay8Address *CIPAddress::CreateGenericAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;


	//
	// initialize
	//
	pDPlayAddress = NULL;

	hr = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pDPlayAddress, NULL );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPF( 0, "CreateGenericAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_BuildAddress( pDPlayAddress, g_IPListenAddress, ANY_PORT );
	if ( hr != DPN_OK )
	{
		DPF( 0, "CreateGenericAddress: Failed to set hostname and port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CompareToBaseAddress - compare this address to a 'base' address
//		of this class
//
// Entry:		Pointer to base address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CompareToBaseAddress"

INT_PTR	CIPAddress::CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const
{
	const SOCKADDR_IN	*pBaseIPAddress;
	DNASSERT( pBaseAddress != NULL );

	
	DNASSERT( pBaseAddress->sa_family == m_SocketAddress.SocketAddress.sa_family );
	pBaseIPAddress = reinterpret_cast<const SOCKADDR_IN*>( pBaseAddress );
	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == pBaseIPAddress->sin_addr.S_un.S_addr )
	{
		return 0;
	}
	else
	{
		if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr < pBaseIPAddress->sin_addr.S_un.S_addr )
		{
			return	1;
		}
		else
		{
			return	-1;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::HashFunction - hash address to N bits
//
// Entry:		Count of bits to hash to
//
// Exit:		Hashed value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::HashFunction"

INT_PTR	CIPAddress::HashFunction( const INT_PTR iHashBitCount ) const
{
	INT_PTR		iReturn;
	UINT_PTR	Temp;


	DNASSERT( iHashBitCount != 0 );

	//
	// initialize
	//
	iReturn = 0;

	//
	// hash IP address
	//
	Temp = m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;
	do
	{
		iReturn ^= Temp & ( ( 1 << iHashBitCount ) - 1 );
		Temp >>= iHashBitCount;
	} while ( Temp != 0 );

	//
	// hash IP port
	//
	Temp = m_SocketAddress.IPSocketAddress.sin_port;
	do
	{
		iReturn^= Temp & ( ( 1 << iHashBitCount ) - 1 );
		Temp >>= iHashBitCount;
	}
	while ( Temp != 0 );

	return iReturn;
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CIPAddress::CreateMulticastGroup - create a multicast group on IP.
//
// Entry:		Reference to adapter GUID
//				Pointer to socket address of multicast group (may be NULL)
//				Pointer to group data to fill
//				Pointer to size of group data
//
// Exit:		Error code
//
// Note:	Since IP multicast groups exist at all times (you need to join them).
//			This code will choose a multicast address for future use and return
//			the data.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateMulticastGroup"

HRESULT	CIPAddress::CreateMulticastGroup( const GUID &AdapterGuid,
										  const CSocketAddress *pMulticastGroupAddress,
										  void *const pGroupData,
										  DWORD *const pdwGroupDataSize
										  ) const
{
	HRESULT			hr;
	MULTICAST_DATA	*pMulticastData;
	union
	{
		SOCKADDR	SocketAddress;
		SOCKADDR_IN	INetAddress;
	} MulticastAddress;


	DNASSERT( pdwGroupDataSize != NULL );
	DNASSERT( ( pGroupData != NULL ) || ( *pdwGroupDataSize == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;
	pMulticastData = NULL;

	//
	// check for sufficient output space
	//
	if ( *pdwGroupDataSize < sizeof( *pMulticastData ) )
	{
		hr = DPNERR_BUFFERTOOSMALL;
		*pdwGroupDataSize = sizeof( *pMulticastData );
		DPF( 8, "Insufficient buffer space for creating multicast group data!" );
		goto Failure;
	}

	//
	// If we have a valid multicast group address, use it.  Otherwise, choose a
	// default.
	//
	pMulticastData = static_cast<MULTICAST_DATA*>( pGroupData );
	memset( &MulticastAddress, 0x00, sizeof( MulticastAddress ) );
	MulticastAddress.SocketAddress.sa_family = GetFamily();
	if ( pMulticastGroupAddress != NULL )
	{
		const	SOCKADDR_IN	*pINetSocketAddress;


		INT3;
		DBG_CASSERT( sizeof( SOCKADDR ) == sizeof( SOCKADDR_IN ) );
		pINetSocketAddress = reinterpret_cast<const SOCKADDR_IN*>( pMulticastGroupAddress->GetAddress() );
		MulticastAddress.INetAddress.sin_addr = pINetSocketAddress->sin_addr;
		MulticastAddress.INetAddress.sin_port = pINetSocketAddress->sin_port;
	}
	else
	{
#pragma	BUGBUG( johnkan, "Hard-coded multicast address!" )
		MulticastAddress.INetAddress.sin_addr.S_un.S_addr = p_htonl( IP_MULTICAST_ADDRESS );
	}

	//
	// If a port isn't specified, use the default DNet port.
	//
	if ( MulticastAddress.INetAddress.sin_port == 0 )
	{
		MulticastAddress.INetAddress.sin_port = p_htons( DPNA_DPNSVR_PORT );
	}

	GuidFromAddress( pMulticastData->MulticastAddressGuid, MulticastAddress.SocketAddress );
	*pdwGroupDataSize = sizeof( *pMulticastData );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::DeleteMulticastGroup - delete a multicast group in IP.
//
// Entry:		Reference to GUID of adapter to use to delete group
//				Pointer to group data
//				Size of group data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::DeleteMulticastGroup"

HRESULT	CIPAddress::DeleteMulticastGroup( const GUID &AdapterGuid,
										  const void *const pGroupData,
										  const DWORD dwGroupDataSize ) const
{
	HRESULT	hr;


	DNASSERT( pGroupData != NULL );
	DNASSERT( dwGroupDataSize == sizeof( MULTICAST_DATA ) );

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// Since IP multicast groups exist at all times (you cannot delete them), there
	// is nothing to do for this function.
	//

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::AddToMulticastGroup - join a multicast group
//
// Entry:		Pointer to group data
//				Size of group data
//				Socket to use
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::AddToMulticastGroup"

HRESULT	CIPAddress::AddToMulticastGroup( const void *const pGroupData,
										 const DWORD dwGroupDataSize,
										 const SOCKET &Socket
										 ) const
{
	HRESULT	hr;
	ip_mreq	MulticastRequest;
	int		SocketOption;
	const MULTICAST_DATA	*pMulticastData;
	union
	{
		SOCKADDR	SocketAddress;
		SOCKADDR_IN	INetAddress;
	} MulticastSocketAddress;
	UINT_PTR	WSAReturn;


	DNASSERT( pGroupData != NULL );
	DNASSERT( dwGroupDataSize == sizeof( *pMulticastData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	memset( &MulticastRequest, 0x00, sizeof( MulticastRequest ) );

	//
	// convert multicast address GUID to a pure address and build our multiacast
	// join request
	//
	pMulticastData = static_cast<const MULTICAST_DATA*>( pGroupData );
	AddressFromGuid( pMulticastData->MulticastAddressGuid, MulticastSocketAddress.SocketAddress );
	DPF( 8, "Socket address for multicast destination" );
	DumpSocketAddress( 8, &MulticastSocketAddress.SocketAddress, GetFamily() );
	MulticastRequest.imr_multiaddr = MulticastSocketAddress.INetAddress.sin_addr;
	MulticastRequest.imr_interface = m_SocketAddress.IPSocketAddress.sin_addr;

		//
		// Winsock2, or greater, use the IP_ADD_MEMBERSHIP value for Winsock2
		// see WS2TCPIP.H
		//
			SocketOption = 12;

	DBG_CASSERT( sizeof( &MulticastRequest ) == sizeof( char* ) );
	WSAReturn = p_setsockopt( Socket,											// socket
							  IPPROTO_IP,										// level (TCP/IP)
							  SocketOption,										// option (join multicast group)
							  reinterpret_cast<char*>( &MulticastRequest ),		// option data
							  sizeof( MulticastRequest )						// size of option data
							  );
	if ( WSAReturn == SOCKET_ERROR )
	{
		hr = DPNERR_GENERIC;
		DPF( 0, "Failed to join IP multicast group!" );
		DisplayWinsockError( 0, p_WSAGetLastError() );
		goto Failure;
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::RemoveFromMulticastGroup - leave a multicast group
//
// Entry:		Pointer to group data
//				Size of group data
//				Socket to use
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::RemoveFromMulticastGroup"

HRESULT	CIPAddress::RemoveFromMulticastGroup( const void *const pGroupData,
											  const DWORD dwGroupDataSize,
											  const SOCKET &Socket
											  ) const
{
	HRESULT	hr;
	ip_mreq	MulticastRequest;
	int		SocketOption;
	const MULTICAST_DATA	*pMulticastData;
	union
	{
		SOCKADDR	SocketAddress;
		SOCKADDR_IN	INetAddress;
	} MulticastSocketAddress;
	UINT_PTR	WSAReturn;


	DNASSERT( pGroupData != NULL );
	DNASSERT( dwGroupDataSize == sizeof( *pMulticastData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	memset( &MulticastRequest, 0x00, sizeof( MulticastRequest ) );

	//
	// convert multicast address GUID to a pure address and build our multiacast
	// join request
	//
	pMulticastData = static_cast<const MULTICAST_DATA*>( pGroupData );
	AddressFromGuid( pMulticastData->MulticastAddressGuid, MulticastSocketAddress.SocketAddress );
	MulticastRequest.imr_multiaddr = MulticastSocketAddress.INetAddress.sin_addr;
	MulticastRequest.imr_interface = m_SocketAddress.IPSocketAddress.sin_addr;

		//
		// Winsock2, or greater, use the IP_DROP_MEMBERSHIP value for Winsock2
		// see WS2TCPIP.H
		//
			SocketOption = 13;

	DBG_CASSERT( sizeof( &MulticastRequest ) == sizeof ( char* ) );
	WSAReturn = p_setsockopt( Socket,											// socket to work with
							  IPPROTO_IP,										// level (TCPIP)
							  SocketOption,										// option (remove from multicast group)
							  reinterpret_cast<char*>( &MulticastRequest ),		// option data
							  sizeof( MulticastRequest )						// size of option data
							  );
	if ( WSAReturn == SOCKET_ERROR )
	{
		hr = DPNERR_GENERIC;
		DPF( 0, "Failed to leave IP multicast group!" );
		DisplayWinsockError( 0, p_WSAGetLastError() );
		goto Failure;
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::GuidFromInternalAddressWithoutPort - get a guid from the internal
//		address without a port.
//
// Entry:		Reference to desintation GUID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::GuidFromInternalAddressWithoutPort"

void	CIPAddress::GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const
{
	union
	{
		SOCKADDR	SockAddr;
		SOCKADDR_IN	IPSockAddr;
	} TempSocketAddress;


	DBG_CASSERT( sizeof( TempSocketAddress.SockAddr ) == sizeof( m_SocketAddress.SocketAddress ) );
	memcpy( &TempSocketAddress.SockAddr, &m_SocketAddress.SocketAddress, sizeof( TempSocketAddress.SockAddr ) );
	TempSocketAddress.IPSockAddr.sin_port = 0;
	GuidFromAddress( OutputGuid, TempSocketAddress.SockAddr );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::ImportMulticastAdapterAddress - set this address to the adapter
//		address used to manipulate a multicast group address
//
// Entry:		Reference to base adapter address
//				Pointer to group data
//				Size of group data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::ImportMulticastAdapterAddress"

void	CIPAddress::ImportMulticastAdapterAddress( const GUID &AdapterGuid, const void *const pGroupData, const UINT_PTR GroupDataSize )
{
	const	MULTICAST_DATA	*pMulticastData;
	union
	{
		SOCKADDR	SocketAddress;
		SOCKADDR_IN	IPSocketAddress;
	} TempAddress;


	//
	// combine the given adapter address with the port specified in the
	// multicast address
	//
	DNASSERT( pGroupData != NULL );
	DNASSERT( GroupDataSize == sizeof( *pMulticastData ) );
	pMulticastData = static_cast<const MULTICAST_DATA*>( pGroupData );
	AddressFromGuid( AdapterGuid, *GetWritableAddress() );
	memset( &TempAddress, 0x00, sizeof( TempAddress ) );
	AddressFromGuid( pMulticastData->MulticastAddressGuid, TempAddress.SocketAddress );
	m_SocketAddress.IPSocketAddress.sin_port = TempAddress.IPSocketAddress.sin_port;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::IsUndefinedHostAddress - determine if this is an undefined host
//		address
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether this is an undefined host address
//				TRUE = this is an undefined address
//				FALSE = this is not an undefined address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::IsUndefinedHostAddress"

BOOL	CIPAddress::IsUndefinedHostAddress( void ) const
{
	BOOL	fReturn;


	fReturn = FALSE;
	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == p_htonl( INADDR_ANY ) )
	{
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::ChangeLoopBackToLocalAddress - change loopback to a local address
//
// Entry:		Pointer to other address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::ChangeLoopBackToLocalAddress"

void	CIPAddress::ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherSocketAddress )
{
	const CIPAddress	*pOtherIPAddress;

	
	DNASSERT( pOtherSocketAddress != NULL );
	pOtherIPAddress = static_cast<const CIPAddress*>( pOtherSocketAddress );

	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == p_htonl( INADDR_LOOPBACK ) )
	{
		m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = pOtherIPAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CopyInternalSocketAddressWithoutPort - copy socket address
//		without the port field.
//
// Entry:		Reference to destination address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CopyInternalSocketAddressWithoutPort"

void	CIPAddress::CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const
{
	SOCKADDR_IN	*pIPSocketAddress;


	DNASSERT( SinZeroIsZero( &m_SocketAddress.IPSocketAddress ) != FALSE );

	//
	// copy address and zero out the port
	//
	DBG_CASSERT( sizeof( AddressDestination ) == sizeof( m_SocketAddress.SocketAddress ) );
	memcpy( &AddressDestination, &m_SocketAddress.SocketAddress, sizeof( AddressDestination ) );

	DBG_CASSERT( sizeof( SOCKADDR_IN* ) == sizeof( &AddressDestination ) );
	pIPSocketAddress = reinterpret_cast<SOCKADDR_IN*>( &AddressDestination );
	pIPSocketAddress->sin_port = p_htons( 0 );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\jobqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		JobQueue.cpp
 *  Content:	Job queue for use in the thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/21/2000	jtk		Created
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::CJobQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::CJobQueue"

CJobQueue::CJobQueue():
	m_pQueueHead( NULL ),
	m_pQueueTail( NULL ),
	m_hPendingJob( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::~CJobQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::~CJobQueue"

CJobQueue::~CJobQueue()
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNASSERT( m_hPendingJob == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Initialize - initialize
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Initialize"

BOOL	CJobQueue::Initialize( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		DPF( 0, "Failed to initialize critical section on job queue!" );
		goto Failure;
	}

	m_hPendingJob = CreateEvent( NULL,		// pointer to security attributes (none)
								 TRUE,		// manual reset
								 FALSE,		// start unsignalled
								 NULL );	// pointer to name (none)
	if ( m_hPendingJob == NULL )
	{
		DPF( 0, "Failed to create event for pending job!" );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Deinitialize"

void	CJobQueue::Deinitialize( void )
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNDeleteCriticalSection( &m_Lock );

	if ( m_hPendingJob != NULL )
	{
		if ( CloseHandle( m_hPendingJob ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Problem closing job queue handle" );
			DisplayErrorCode( 0, dwError );
		}

		m_hPendingJob = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::SignalPendingJob - set flag to signal a pending job
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::SignalPendingJob"

BOOL	CJobQueue::SignalPendingJob( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( SetEvent( GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Cannot set event for pending job!" );
		DisplayErrorCode( 0, dwError );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::EnqueueJob - add a job to the job list
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::EnqueueJob"

void	CJobQueue::EnqueueJob( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	if ( m_pQueueTail != NULL )
	{
		DNASSERT( m_pQueueHead != NULL );
		DNASSERT( m_pQueueTail->pNext == NULL );
		m_pQueueTail->pNext = pJob;
	}
	else
	{
		m_pQueueHead = pJob;
	}

	m_pQueueTail = pJob;
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::DequeueJob - remove job from job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::DequeueJob"

THREAD_POOL_JOB	*CJobQueue::DequeueJob( void )
{
	THREAD_POOL_JOB	*pJob;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	
	pJob = NULL;
	
	if ( m_pQueueHead != NULL )
	{
		pJob = m_pQueueHead;
		m_pQueueHead = pJob->pNext;
		if ( m_pQueueHead == NULL )
		{
			DNASSERT( m_pQueueTail == pJob );
			m_pQueueTail = NULL;
		}

		DEBUG_ONLY( pJob->pNext = NULL );
	}

	return	pJob;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\ipendpt.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPEndpt.h
 *  Content:	IP endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 ***************************************************************************/

#ifndef __IP_ENDPOINT_H__
#define __IP_ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CIPEndpoint : public CEndpoint
{
	STDNEWDELETE

	public:
		//
		// we need a virtual destructor to guarantee we call destructors in base classes
		//
		CIPEndpoint();
		~CIPEndpoint();

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );
		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPEndpoint::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* > *pOwningPool )
		{
			DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) );
			m_pOwningPool = pOwningPool;
		}

	protected:

	private:
		CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* >	*m_pOwningPool;
		
		CIPAddress	m_IPAddress;
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CIPEndpoint( const CIPEndpoint & );
		CIPEndpoint& operator=( const CIPEndpoint & );
};

#undef DPF_MODNAME

#endif	// __IP_ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\locals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.cpp
 *  Content:	Global variables for the DNWsock service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces
//
volatile LONG	g_lOutstandingInterfaceCount = 0;

//
// invalid adapter guid
//
const GUID	g_InvalidAdapterGuid = { 0 };

//
// thread count
//
UINT_PTR	g_uThreadCount = 0;

//
// Winssock receive buffer size
//
BOOL	g_fWinsockReceiveBufferSizeOverridden = FALSE;
INT		g_iWinsockReceiveBufferSize = 0;

//
// Winsock receive buffer multiplier
//
DWORD_PTR		g_dwWinsockReceiveBufferMultiplier = 1;



//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\iodata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.h
 *  Content:	Strucutre definitions for IO data blocks
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __IODATA_H__
#define __IODATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated types for what action to take when a send completes
//
typedef	enum	_SEND_COMPLETE_ACTION
{
	SEND_COMPLETE_ACTION_UNKNOWN = 0,				// unknown value
	SEND_COMPLETE_ACTION_NONE,						// no action
	SEND_COMPLETE_ACTION_COMPLETE_COMMAND,			// complete command
	SEND_COMPLETE_ACTION_PROXIED_ENUM_CLEANUP		// clean up proxied enum data
} SEND_COMPLETE_ACTION;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure and class references
//
class	CCommandData;
class	CEndpoint;
class	CIOData;
class	CSocketPort;
class	CSocketAddress;
class	CThreadPool;

//
// structures used to get I/O data from the pools
//
typedef	struct	_READ_IO_DATA_POOL_CONTEXT
{
	CThreadPool	*pThreadPool;
}READ_IO_DATA_POOL_CONTEXT;

typedef	struct	_WRITE_IO_DATA_POOL_CONTEXT
{
	HANDLE	hOverlapEvent;
}WRITE_IO_DATA_POOL_CONTEXT;

//
// class containing all data for I/O completion
//
class	CIOData
{
	STDNEWDELETE

	public:
		CIOData();
		virtual ~CIOData();


		CSocketPort	*SocketPort( void ) const { return m_pSocketPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetSocketPort"
		void	SetSocketPort( CSocketPort *const pSocketPort )
		{
			DNASSERT( ( m_pSocketPort == NULL ) || ( pSocketPort == NULL ) );
			m_pSocketPort = pSocketPort;
		}

		BOOL	Win9xOperationPending( void ) const { return m_Flags.fWin9xOperationPending; }
		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_Flags.fWin9xOperationPending = fOperationPending; }

		void	SetWriteOperation( void ) { m_Flags.fWriteOperation = TRUE; }
		BOOL	IsReadOperation( void ) const { return ( m_Flags.fWriteOperation == FALSE ); }
		BOOL	IsWriteOperation( void ) const { return m_Flags.fWriteOperation; }

		OVERLAPPED	*Overlap( void ) { return &m_Overlap; }
		HANDLE	OverlapEvent( void ) const { return m_Overlap.hEvent; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetOverlapEvent"
		void	SetOverlapEvent( const HANDLE hEvent )
		{
			DNASSERT( ( m_Overlap.hEvent == NULL ) || ( hEvent == NULL ) );
			m_Overlap.hEvent = hEvent;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::IODataFromOverlap"
		static	CIOData	*IODataFromOverlap( OVERLAPPED *const pOverlap )
		{
			DNASSERT( pOverlap != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pOverlap ) );
			DBG_CASSERT( sizeof( CIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CIOData*>( &reinterpret_cast<BYTE*>( pOverlap )[ -OFFSETOF( CIOData, m_Overlap ) ] );
		}

	protected:

	private:
		OVERLAPPED	m_Overlap;		// overlapped I/O structure

		CSocketPort		*m_pSocketPort;				// pointer to socket port associated with this IO request
		struct
		{
			BOOL	fWin9xOperationPending : 1;		// this structure has been initialized and the operation is pending on Win9x
			BOOL	fWriteOperation : 1;			// this is a write operation
		} m_Flags;

		// prevent unwarranted copies
		CIOData( const CIOData & );
		CIOData& operator=( const CIOData & );
};

//
// all data for a read operation
//
class	CReadIOData : public CIOData
{
	STDNEWDELETE

	public:
		CReadIOData();
		~CReadIOData();

		void	AddRef( void ) { DNInterlockedIncrement( &m_lRefCount ); }

		void	DecRef( void )
		{
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CBilink				m_OutstandingReadListLinkage;	// links to the unbound list
		INT					m_iSocketAddressSize;			// size of received socket address (from Winsock)
		CSocketAddress		*m_pSourceSocketAddress;		// pointer to socket address class that's bound to the
															// local 'SocketAddress' element and is used to get the
															// address of the machine that originated the datagram

		INT		m_Win9xReceiveWSAReturn;		
		DWORD	m_dwOverlappedBytesReceived;

		DWORD	m_dwBytesRead;
		DWORD	m_dwReadFlags;
		DEBUG_ONLY( BOOL	m_fRetainedByHigherLayer );

		SPRECEIVEDBUFFER	*ReceivedBuffer( void ) { DNASSERT( m_pThreadPool != NULL ); return &m_SPReceivedBuffer; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromBilink"
		static CReadIOData	*ReadDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CReadIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CReadIOData, m_OutstandingReadListLinkage ) ] );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromSPReceivedBuffer"
    	static CReadIOData	*ReadDataFromSPReceivedBuffer( SPRECEIVEDBUFFER *const pSPReceivedBuffer )
    	{
    		DNASSERT( pSPReceivedBuffer != NULL );
    		DBG_CASSERT( sizeof( BYTE* ) == sizeof( pSPReceivedBuffer ) );
    		DBG_CASSERT( sizeof( CReadIOData* ) == sizeof( BYTE* ) );
    		return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pSPReceivedBuffer )[ -OFFSETOF( CReadIOData, m_SPReceivedBuffer ) ] );
    	}

		//
		// functions for managing read IO data pool
		//
		BOOL	ReadIOData_Alloc( READ_IO_DATA_POOL_CONTEXT *const pContext );
		void	ReadIOData_Get( READ_IO_DATA_POOL_CONTEXT *const pContext );
		void	ReadIOData_Release( void );
		void	ReadIOData_Dealloc( void );

	private:
		void	ReturnSelfToPool( void );
		
		volatile LONG	m_lRefCount;
		CThreadPool		*m_pThreadPool;
	
		SPRECEIVEDBUFFER	m_SPReceivedBuffer;
		BYTE				m_ReceivedData[ MAX_MESSAGE_SIZE ];
		

		// prevent unwarranted copies
		CReadIOData( const CReadIOData & );
		CReadIOData& operator=( const CReadIOData & );
};

//
// all data for a write operation
//
class	CWriteIOData : public CIOData
{
	STDNEWDELETE

	public:
		CWriteIOData();
		~CWriteIOData();

		CWriteIOData			*m_pNext;							// link to next write in the send queue (see CSendQueue)

		CBilink					m_OutstandingWriteListLinkage;		// links to the outstanding write list
		const CSocketAddress	*m_pDestinationSocketAddress;		// pointer to socket address of destination
		BUFFERDESC				*m_pBuffers;						// pointer to outgoing buffers
		UINT_PTR				m_uBufferCount;						// count of outgoing buffers
		CCommandData			*m_pCommand;						// associated command

		SEND_COMPLETE_ACTION	m_SendCompleteAction;	// enumerated value indicating the action to take
														// when a send completes

		HRESULT	m_Win9xSendHResult;
		DWORD	m_dwOverlappedBytesSent;
		DWORD	m_dwBytesSent;

		//
		// since the following is a packed structure, put it at the end
		// to preserve as much alignment as possible with the
		// above fields
		//
		PREPEND_BUFFER	m_PrependBuffer;				// optional data that may be prepeded on a write
		BUFFERDESC		m_ProxyEnumSendBuffers[ 2 ];	// static buffers used to send data in a proxied enum

		CReadIOData		*m_pProxiedEnumReceiveBuffer;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CWriteIOData::WriteDataFromBilink"
		static CWriteIOData	*WriteDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CWriteIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CWriteIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CWriteIOData, m_OutstandingWriteListLinkage ) ] );
		}

		//
		// functions for managing write IO data pool
		//
		BOOL	WriteIOData_Alloc( WRITE_IO_DATA_POOL_CONTEXT *const pContext );
		void	WriteIOData_Get( WRITE_IO_DATA_POOL_CONTEXT *const pContext );
		void	WriteIOData_Release( void );
		void	WriteIOData_Dealloc( void );

	private:

		// prevent unwarranted copies
		CWriteIOData( const CWriteIOData & );
		CWriteIOData& operator=( const CWriteIOData & );

};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __IODATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\jobqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       JobQueue.h
 *  Content:	Job queue for thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/24/2000	jtk		Created
 ***************************************************************************/

#ifndef __JOB_QUEUE_H__
#define __JOB_QUEUE_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CSocketPort;
typedef	enum	_JOB_TYPE	JOB_TYPE;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );

//
// structure for job to start monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;	// pointer to associated socket port

} DATA_ADD_SOCKET;

//
// structure for job to stop monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;		// pointer to associated socket port

} DATA_REMOVE_SOCKET;

//
// structure for job to connect
//
typedef struct
{
	JOB_FUNCTION	*pCommandFunction;	// pointer to function for the command
	void			*pContext;			// user context (i.e. CEndpoint pointer)
	UINT_PTR		uData;				// user data
} DATA_DELAYED_COMMAND;

//
// structure for job to refresh enums
//
typedef	struct
{
	UINT_PTR	uDummy;			// dummy variable to prevent compiler from whining
} DATA_REFRESH_TIMED_JOBS;

//
// structure encompassing information for a job for the workhorse thread
//
typedef struct	_THREAD_POOL_JOB
{
	THREAD_POOL_JOB		*pNext;					// pointer to next job
	JOB_TYPE			JobType;				// type of job
	JOB_FUNCTION		*pCancelFunction;		// function for cancelling job

//	DWORD		dwCommandID;			// unique ID used to identify this command
//	FUNCTION	*pProcessFunction;		// function for performing job

	union
	{
		DATA_DELAYED_COMMAND	JobDelayedCommand;
		DATA_REMOVE_SOCKET		JobRemoveSocket;
		DATA_ADD_SOCKET			JobAddSocket;
		DATA_REFRESH_TIMED_JOBS	JobRefreshTimedJobs;
	} JobData;

} THREAD_POOL_JOB;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );


//**********************************************************************
// Class prototypes
//**********************************************************************


//
// class to encapsultate a job queue
//
class	CJobQueue
{
	STDNEWDELETE

	public:
		CJobQueue();
		~CJobQueue();

		BOOL	Initialize( void );
		void	Deinitialize( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CJobQueue::GetPendingJobHandle"
		HANDLE	GetPendingJobHandle( void ) const
		{
			DNASSERT( m_hPendingJob != NULL );
			return	m_hPendingJob;
		}

		BOOL	SignalPendingJob( void );

		BOOL	IsEmpty( void ) const { return ( m_pQueueHead == NULL ); }

		void	EnqueueJob( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*DequeueJob( void );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;			// lock
		THREAD_POOL_JOB		*m_pQueueHead;	// head of job queue
		THREAD_POOL_JOB		*m_pQueueTail;	// tail of job queue
		HANDLE				m_hPendingJob;	// event indicating a pending job

		//
		// prevent unwarranted copies
		//
		CJobQueue( const CJobQueue & );
		CJobQueue& operator=( const CJobQueue & );
};

#undef DPF_MODNAME

#endif	// __JOB_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\ipaddress.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPAddress.h
 *  Content:	IP address class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __IP_ADDRESS_H__
#define __IP_ADDRESS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// external variables
//
extern const WCHAR	g_IPBroadcastAddress[];
extern const DWORD	g_dwIPBroadcastAddressSize;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CIPAddress : public CSocketAddress
{
	STDNEWDELETE

	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::CIPAddress"
		CIPAddress()
		{
			DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress ) == sizeof( SOCKADDR* ) );
			m_iSocketAddressSize = sizeof( m_SocketAddress.IPSocketAddress );
			m_SocketAddress.IPSocketAddress.sin_family = AF_INET;
			m_iSocketProtocol = IPPROTO_UDP;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::~CIPAddress"
		~CIPAddress()
		{
			DNASSERT( m_iSocketAddressSize == sizeof( m_SocketAddress.IPSocketAddress ) );
			DNASSERT( m_SocketAddress.IPSocketAddress.sin_family == AF_INET );
			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
		}

		void	InitializeWithBroadcastAddress( void );
		void	InitializeWithAnyAddress( void );
		void	SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize );

		HRESULT	SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
											 const SP_ADDRESS_TYPE AddressType );

		IDirectPlay8Address	*DP8AddressFromSocketAddress( void ) const;

		INT_PTR	CompareFunction( const CSocketAddress *const pOtherAddress ) const;
		INT_PTR	HashFunction( const INT_PTR HashBitcount ) const;
		INT_PTR	CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const;

		HRESULT	CreateMulticastGroup( const GUID &AdapterGuid,
									  const CSocketAddress *const pMulticastGroupAddress,
									  void *const pGroupData,
									  DWORD *const pdwGroupDataSize
									  ) const;

		HRESULT	DeleteMulticastGroup( const GUID &AdatperGuid,
									  const void *const pGroupData,
									  const DWORD dwGroupDataSize ) const;

		HRESULT	AddToMulticastGroup( const void *const pGroupData,
									 const DWORD dwGroupDataSize,
									 const SOCKET &Socket
									 ) const;

		HRESULT	RemoveFromMulticastGroup( const void *const pGroupData,
										  const DWORD dwGroupDataSize,
										  const SOCKET &Socket
										  ) const;

		void	GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const;
		
		void	ImportMulticastAdapterAddress( const GUID &AdapterGuid,
											   const void *const pGroupData,
											   const UINT_PTR GroupDataSize );

		BOOL	IsUndefinedHostAddress( void ) const;
		void	ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherSocketAddress );
		
		WORD	GetPort( void ) const { return m_SocketAddress.IPSocketAddress.sin_port; }
		void	SetPort( const WORD wPort ) { m_SocketAddress.IPSocketAddress.sin_port = wPort; }

		//
		// functions to create default addresses
		//
		IDirectPlay8Address *CreateBroadcastAddress( void );
		IDirectPlay8Address *CreateListenAddress( void );
		IDirectPlay8Address *CreateGenericAddress( void );

	private:
		void	CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::GuidFromAddress"
		static void	GuidFromAddress( GUID &OutputGuid, const SOCKADDR &SocketAddress )
		{
			const SOCKADDR_IN	*pSocketAddress = reinterpret_cast<const SOCKADDR_IN*>( &SocketAddress );


		    DBG_CASSERT( sizeof( OutputGuid ) == sizeof( SocketAddress ) );
			memcpy( &OutputGuid, &SocketAddress, ( sizeof( OutputGuid ) - sizeof( pSocketAddress->sin_zero ) ) );
			memset( &( reinterpret_cast<BYTE*>( &OutputGuid )[ OFFSETOF( SOCKADDR_IN, sin_zero ) ] ), 0, sizeof( pSocketAddress->sin_zero ) );
			DNASSERT( SinZeroIsZero( reinterpret_cast<SOCKADDR_IN*>( &OutputGuid ) ) );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::SinZeroIsZero"
		static BOOL	SinZeroIsZero( const SOCKADDR_IN *const pSocketAddress )
		{
			if ( ( ( reinterpret_cast<const DWORD*>( &pSocketAddress->sin_zero[ 0 ] )[ 0 ] == 0 ) &&
				   ( reinterpret_cast<const DWORD*>( &pSocketAddress->sin_zero[ 0 ] )[ 1 ] == 0 ) ) != FALSE )
			{
				return	TRUE;
			}

			return	FALSE;
		}
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CIPAddress( const CIPAddress & );
		CIPAddress& operator=( const CIPAddress & );
};

#undef DPF_MODNAME

#endif	// __IP_ADDRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\messagestructures.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MessageStructures.h
 *  Content:	Message strucutre definitions for messages on the wire
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/20/2000	jtk		Derived from IOData.h
 ***************************************************************************/

#ifndef __MESSAGE_STRUCTURES_H__
#define __MESSAGE_STRUCTURES_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	SP_HEADER_LEAD_BYTE			0x00
#define	ESCAPED_USER_DATA_PAD_VALUE	0x0000

//
// Data types used by service provider messages.  Note, the high-order bit
// is reserved for future use and should not be set!
//
#define	ESCAPED_USER_DATA_KIND		0x01
#define	ENUM_DATA_KIND				0x02
#define	ENUM_RESPONSE_DATA_KIND		0x03
#define	PROXIED_ENUM_DATA_KIND		0x04

//
// DPlay port limits (inclusive) scanned to find an available port.
// Exclude 2300 and 2301 because there are network broadcasts on 2301
// that we may receive.
//
#define	BASE_DPLAY8_PORT	((WORD) 2302)
#define	MAX_DPLAY8_PORT		((WORD) 2400)

//
// mask for RTT sequence number
//
#define	ENUM_RTT_MASK	0X0F

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// Structure used to prepend data to a send, this structure is byte aligned to
// save bandwidth.  The goal is to keep all data DWORD aligned so the structure
// elements should be sized such that any payload passed to a higher layer is
// DWORD aligned.  In the case of the proxied enum query, the full SOCKADDR
// structure is used to keep alignment.
//
#pragma	pack( push, 1 )
typedef union	_PREPEND_BUFFER
{
	struct	_GENERIC_HEADER				// generic header to determine data kind
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
	} GenericHeader;					//

	struct _ESCAPED_USER_DATA_HEADER	// header used when escaping user data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
		WORD	wPad;					// used to keep message DWORD aligned
	} EscapedUserDataHeader;			//

	struct	_ENUM_DATA_HEADER			// header used to indicate enum query data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
		WORD	wEnumPayload;			// combination of RTT sequence and enum key
	} EnumDataHeader;					//

	struct	_ENUM_RESPONSE_DATA_HEADER	// header used to indicate enum response data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
		WORD	wEnumResponsePayload;	// combination of RTT sequence and enum key
	} EnumResponseDataHeader;			//

	struct	_PROXIED_ENUM_DATA_HEADER	// header used to indicate proxied enum data
	{									//
		BYTE		bSPLeadByte;		//
		BYTE		bSPCommandByte;		//
		WORD		wEnumKey;			// key from the original enum
		SOCKADDR	ReturnAddress;		// real socket address to return the data to
	} ProxiedEnumDataHeader;			//

} PREPEND_BUFFER;
#pragma	pack( pop )

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


#endif	// __MESSAGE_STRUCTURES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\locals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.h
 *  Content:	Global information for the DNWSock service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __LOCALS_H__
#define __LOCALS_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// define for any port
//
#define	ANY_PORT	((WORD) 0)

#define	BITS_PER_BYTE	8

//
// Maximum size of a receved message (1500 byte ethernet frame - 28 byte UDP
// header).  The SP will have a bit reserved in the received data by the protocol
// so it knows that the data is a 'user datagram'.  If that bit is not set, the
// data is SP-specific (enum query, enum response, proxied enum query).
//
#define	MAX_MESSAGE_SIZE	1472

//
// maximum data size in bytes
//
#define	MAX_USER_PAYLOAD	( MAX_MESSAGE_SIZE )

#define	MAX_ACTIVE_WIN9X_ENDPOINTS	25

//
// enumerated constants for IO completion returns
//
typedef	enum
{
	IO_COMPLETION_KEY_UNKNONW = 0,		// invalid value
	IO_COMPLETION_KEY_SP_CLOSE,			// SP is closing, bail on completion threads
	IO_COMPLETION_KEY_IO_COMPLETE,		// IO operation complete
	IO_COMPLETION_KEY_NEW_JOB,			// new job notification
} IO_COMPLETION_KEY;


//
// maximum value of a 32-bit unsigned variable
//
#define	UINT32_MAX	((DWORD) 0xFFFFFFFF)
#define	WORD_MAX	((WORD) 0xFFFF)

//
// default enum retries for Winsock SP and retry time (milliseconds)
//
#define	DEFAULT_ENUM_RETRY_COUNT		5
#define	DEFAULT_ENUM_RETRY_INTERVAL		1500
#define	DEFAULT_ENUM_TIMEOUT			1500
#define	ENUM_RTT_ARRAY_SIZE				16

//**********************************************************************
// Macro definitions
//**********************************************************************

//
// macro for length of array
//
#define	LENGTHOF( arg )		( sizeof( arg ) / sizeof( arg[ 0 ] ) )

//
// macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
//
#define OFFSETOF(s,m)	( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure and class references
//
typedef	struct	IDP8ServiceProvider	IDP8ServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces
//
extern volatile	LONG	g_lOutstandingInterfaceCount;

//
// invalid adapter guid
//
extern const GUID	g_InvalidAdapterGuid;

//
// thread count
//
extern	UINT_PTR	g_uThreadCount;

//
// Winsock receive buffer size
//
extern	BOOL	g_fWinsockReceiveBufferSizeOverridden;
extern	INT		g_iWinsockReceiveBufferSize;

//
// Winsock receive buffer multiplier
//
extern	DWORD_PTR		g_dwWinsockReceiveBufferMultiplier;

extern	INT		g_iWinsockReceiveBufferSize;

//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNInterlockedIncrement - Interlocked increment
//
// Entry:		Pointer to value to increment
//
// Exit:		New value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInterlockedIncrement"

inline LONG	DNInterlockedIncrement( volatile LONG *const pValue )
{
	DNASSERT( pValue != NULL );
	DNASSERT( *pValue != -1 );
	return	InterlockedIncrement( const_cast<LONG*>( pValue ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNInterlockedDecrement - interlocked decrement wrapper
//
// Entry:		Pointer to value to decrement
//
// Exit:		New value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInterlockedDecrement"

inline LONG	DNInterlockedDecrement( volatile LONG *const pValue )
{
	DNASSERT( pValue != NULL );
	DNASSERT( *pValue != 0 );
	return	InterlockedDecrement( const_cast<LONG*>( pValue ) );
}
//**********************************************************************

#undef DPF_MODNAME

#endif	// __LOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\poolss.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:	Pool functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from utils.h
 ***************************************************************************/

#ifndef __POOLS_H__
#define __POOLS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CAdapterEntry;
class	CCommandData;
class	CIPAddress;
class	CIPEndpoint;
// BUGBUG: [mgere] [xbox] Removed RSIP
//class	CRsip;
class	CSocketPort;
class	CSPData;
class	CThreadPool;

typedef	struct	_ENDPOINT_POOL_CONTEXT	ENDPOINT_POOL_CONTEXT;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitializePools( void );
void	DeinitializePools( void );

CAdapterEntry	*CreateAdapterEntry( void );
void	ReturnAdapterEntry( CAdapterEntry *const pAdapterEntry );

CCommandData	*CreateCommand( void );
void	ReturnCommand( CCommandData *const pCommandData );

CIPAddress	*CreateIPAddress( void );
void	ReturnIPAddress( CIPAddress *const pIPAddress );


CIPEndpoint		*CreateIPEndpoint( ENDPOINT_POOL_CONTEXT *pContext );

// BUGBUG: [mgere] [xbox] Removed RSIP
//CRsip	*CreateRsip( void );
//void	ReturnRsip( CRsip *const pRsipObject );

CSocketPort	*CreateSocketPort( void );
void	ReturnSocketPort( CSocketPort *const pSocketPort );

CThreadPool	*CreateThreadPool( void );
void	ReturnThreadPool( CThreadPool *const pThreadPool );

#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\poolss.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Pool utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from Utils.h
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// pool for adapter entries
//
static	CLockedPool< CAdapterEntry >	*g_pAdapterEntryPool = NULL;

//
// pool for command data
//
static	CLockedPool< CCommandData >	*g_pCommandDataPool = NULL;

//
// Pools for addresses.  Since these pools don't
// see a lot of action, they share one lock
//
static	DNCRITICAL_SECTION	g_AddressLock;
static	CFixedPool< CIPAddress >	*g_pIPAddressPool = NULL;

static	CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPEndpointPool = NULL;

//
// pool for Rsip objects
//
// BUGBUG: [mgere] [xbox] Removed RSIP
//static	CLockedFixedPool< CRsip >	*g_pRsipPool = NULL;

//
// pool for socket ports
//
static	CLockedFixedPool< CSocketPort >	*g_pSocketPortPool = NULL;

//
// pool for thread pools
//
static	CLockedFixedPool< CThreadPool >	*g_pThreadPoolPool = NULL;



//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializePools - initialize pools
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitializePools"

BOOL	InitializePools( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	//
	// AdapterEntry object pool
	//
	DNASSERT( g_pAdapterEntryPool == NULL );
	g_pAdapterEntryPool = new CLockedPool< CAdapterEntry >;
	if ( g_pAdapterEntryPool != NULL )
	{
		if ( g_pAdapterEntryPool->Initialize() == FALSE )
		{
			delete	g_pAdapterEntryPool;
			g_pAdapterEntryPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}
	
	
	//
	// command data pool
	//
	DNASSERT( g_pCommandDataPool == NULL );
	g_pCommandDataPool = new CLockedPool< CCommandData >;
	if ( g_pCommandDataPool != NULL )
	{
		if ( g_pCommandDataPool->Initialize() == FALSE )
		{
			delete	g_pCommandDataPool;
			g_pCommandDataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}

	//
	// initialize lock for address and endpoint pools
	//
	if ( DNInitializeCriticalSection( &g_AddressLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &g_AddressLock, 0 );

	//
	// address pools
	//
	DNASSERT( g_pIPAddressPool == NULL );
	g_pIPAddressPool = new CFixedPool< CIPAddress >;
	if ( g_pIPAddressPool == NULL )
	{
		goto Failure;
	}

	//
	// endpoint pools
	//
	DNASSERT( g_pIPEndpointPool == NULL );
	g_pIPEndpointPool = new CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* >;
	if ( g_pIPEndpointPool != NULL )
	{
		if ( g_pIPEndpointPool->Initialize() == FALSE )
		{
			delete	g_pIPEndpointPool;
			g_pIPEndpointPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}

	//
	// Rsip object pool
	//
// BUGBUG: [mgere] [xbox] Removed RSIP
//	DNASSERT( g_pRsipPool == NULL );
//	g_pRsipPool = new CLockedFixedPool< CRsip >;
//	if ( g_pRsipPool != NULL )
//	{
//		if ( g_pRsipPool->Initialize() == FALSE )
//		{
//			delete	g_pRsipPool;
//			g_pRsipPool = NULL;
//			goto Failure;
//		}
//	}
//	else
//	{
//		goto Failure;
//	}


	//
	// socket port pool
	//
	DNASSERT( g_pSocketPortPool == NULL );
	g_pSocketPortPool = new CLockedFixedPool< CSocketPort >;
	if ( g_pSocketPortPool != NULL )
	{
		if ( g_pSocketPortPool->Initialize() == FALSE )
		{
			delete	g_pSocketPortPool;
			g_pSocketPortPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// thread pool pool
	//
	DNASSERT( g_pThreadPoolPool == NULL );
	g_pThreadPoolPool = new CLockedFixedPool< CThreadPool >;
	if ( g_pThreadPoolPool != NULL )
	{
		if ( g_pThreadPoolPool->Initialize() == FALSE )
		{
			delete	g_pThreadPoolPool;
			g_pThreadPoolPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	DeinitializePools();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializePools - deinitialize the pools
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitializePools"

void	DeinitializePools( void )
{
	//
	// thread pool pool
	//
	if ( g_pThreadPoolPool != NULL )
	{
		g_pThreadPoolPool->Deinitialize();
		delete	g_pThreadPoolPool;
		g_pThreadPoolPool = NULL;
	}

	//
	// socket port pool
	//
	if ( g_pSocketPortPool != NULL )
	{
		g_pSocketPortPool->Deinitialize();
		delete	g_pSocketPortPool;
		g_pSocketPortPool = NULL;
	}

	//
	// Rsip pool
	//
// BUGBUG: [mgere] [xbox] Removed RSIP
/*
	if ( g_pRsipPool != NULL )
	{
		g_pRsipPool->Deinitialize();
		delete	g_pRsipPool;
		g_pRsipPool = NULL;
	}
*/

//	//
//	// receive buffer pool
//	//
//	if ( g_pReceiveBufferPool != NULL )
//	{
//	    g_pReceiveBufferPool->Deinitialize();
//	    delete	g_pReceiveBufferPool;
//	    g_pReceiveBufferPool = NULL;
//	}

	//
	// endpoint pools
	//
	if ( g_pIPEndpointPool != NULL )
	{
		g_pIPEndpointPool->Deinitialize();
		delete	g_pIPEndpointPool;
		g_pIPEndpointPool = NULL;
	}

	//
	// address pools
	//
	if ( g_pIPAddressPool != NULL )
	{
		delete	g_pIPAddressPool;
		g_pIPAddressPool = NULL;
	}

	//
	// remove lock for endpoint and address pools
	//
	DNDeleteCriticalSection( &g_AddressLock );

	//
	// command data pool
	//
	if ( g_pCommandDataPool != NULL )
	{
		g_pCommandDataPool->Deinitialize();
		delete	g_pCommandDataPool;
		g_pCommandDataPool = NULL;
	}
	
	//
	// AdapterEntry pool
	//
	if ( g_pAdapterEntryPool != NULL )
	{
		g_pAdapterEntryPool->Deinitialize();
		delete	g_pAdapterEntryPool;
		g_pAdapterEntryPool = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateAdapterEntry - create an adapter entry
//
// Entry:		Nothing
//
// Exit:		Poiner to entry (NULL = out of memory)
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateAdapterEntry"

CAdapterEntry	*CreateAdapterEntry( void )
{
	DNASSERT( g_pAdapterEntryPool != NULL );
	return	g_pAdapterEntryPool->Get();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnAdapterEntry - return an adapter entry to the pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnAdapterEntry"

void	ReturnAdapterEntry( CAdapterEntry *const pAdapterEntry )
{
	INT3;
	DNASSERT( pAdapterEntry != NULL );
	DNASSERT( g_pAdapterEntryPool != NULL );
	g_pAdapterEntryPool->Release( pAdapterEntry );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateCommand - create command
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateCommand"

CCommandData	*CreateCommand( void )
{
	DNASSERT( g_pCommandDataPool != NULL );
	return	g_pCommandDataPool->Get();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnCommand - return a command
//
// Entry:		Pointer to command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnCommand"

void	ReturnCommand( CCommandData *const pCommand )
{
	DNASSERT( pCommand != NULL );
	DNASSERT( g_pCommandDataPool != NULL );
	g_pCommandDataPool->Release( pCommand );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPAddress - create IP address
//
// Entry:		Nothing
//
// Exit:		Pointer to IP address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateIPAddress"

CIPAddress	*CreateIPAddress( void )
{
	CIPAddress	*pReturnAddress;

	
	DNASSERT( g_pIPAddressPool != NULL );

	DNEnterCriticalSection( &g_AddressLock );
	pReturnAddress = g_pIPAddressPool->Get();
	DNLeaveCriticalSection( &g_AddressLock );
	return	pReturnAddress;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnIPAddress - return an IP address
//
// Entry:		Pointer to IP address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnIPAddress"

void	ReturnIPAddress( CIPAddress *const pIPAddress )
{
	DNASSERT( pIPAddress != NULL );
	DNASSERT( g_pIPAddressPool != NULL );
	DNEnterCriticalSection( &g_AddressLock );
	g_pIPAddressPool->Release( pIPAddress );
	DNLeaveCriticalSection( &g_AddressLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPEndpoint - create IP endpoint
//
// Entry:		Pointer to context
//
// Exit:		Pointer to IP endpoint
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateEndpoint"

CIPEndpoint	*CreateIPEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
{
	DNASSERT( g_pIPEndpointPool != NULL );
	return	g_pIPEndpointPool->Get( pContext );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateRsip - create an Rsip object
//
// Entry:		Nothing
//
// Exit:		Pointer to Rsip object
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateRsip"
/* BUGBUG: [mgere] [xbox] Removed RSIP support
CRsip	*CreateRsip( void )
{
	CRsip	*pRsip;


	DNASSERT( g_pRsipPool != NULL );
	pRsip = g_pRsipPool->Get();
	if ( pRsip != NULL )
	{
		pRsip->AddRef();
	}

	return	pRsip;
}
*/
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnRsip - return Rsip object to pool
//
// Entry:		Pointer to Rsip Object
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnRsip"

// BUGBUG: [mgere] [xbox] Removed RSIP
/*
void	ReturnRsip( CRsip *const pRsip )
{
	DNASSERT( pRsip != NULL );
	DNASSERT( g_pRsipPool != NULL );
	g_pRsipPool->Release( pRsip );
}
*/
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSocketPort - create a socket port
//
// Entry:		Nothing
//
// Exit:		Pointer to socket port
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateSocketPort"

CSocketPort	*CreateSocketPort( void )
{
	CSocketPort	*pReturn;


	DNASSERT( g_pSocketPortPool != NULL );

	pReturn = g_pSocketPortPool->Get();
	if ( pReturn != NULL )
	{
		pReturn->AddRef();
	}
	
	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnSocketPort - return socket port to pool
//
// Entry:		Pointer to socket port
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnSocketPort"

void	ReturnSocketPort( CSocketPort *const pSocketPort )
{
	DNASSERT( pSocketPort != NULL );
	DNASSERT( g_pSocketPortPool != NULL );
	g_pSocketPortPool->Release( pSocketPort );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateThreadPool - create a thread pool
//
// Entry:		Nothing
//
// Exit:		Pointer to thread pool
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateThreadPool"

CThreadPool	*CreateThreadPool( void )
{
	CThreadPool	*pReturn;


	DNASSERT( g_pThreadPoolPool != NULL );
	pReturn = g_pThreadPoolPool->Get();
	if ( pReturn != NULL )
	{
		pReturn->AddRef();
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnThreadPool - return a thread pool
//
// Entry:		Pointer to thread pool
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnThreadPool"

void	ReturnThreadPool( CThreadPool *const pThreadPool )
{
	DNASSERT( pThreadPool != NULL );
	DNASSERT( g_pThreadPoolPool != NULL );
	g_pThreadPoolPool->Release( pThreadPool );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\rsip.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Rsip.cpp
 *  Content:	Realm Specific IP Support
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  12/7/99		aarono	Original
 *  03/17/2000	johnkan	Converted to class for DPlay8
 *
 *  Notes:
 *
 *  Could optimize the building of messages with pre-initialized
 *  structures for each command, since most of the command is the same
 *  on every request anyway.
 *
 ***************************************************************************/


#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

/*
 * Whats implemented:
 *  as_req_rsap(localaddr=0,localports=4-a:b:c:d,
 *              remaddr=0,remports=0)
 *  as_res_rsap(localaddr=24.128.34.21,localports=4-A:B:C:D,
 *              remaddr=0,remports=0)
 *  where a,b,c,d are listening ports on the client (192.168.0.2)
 *        and A,B,C,D are the associated ports visible
 *        on the external IP address 24.128.34.21.
 *
 * Operation: When packet from the outside is destined for
 *            24.128.34.21:A is recieved, the ip->dst and udp->dst
 *            (or tcp->dst) fields are changed to 192.168.0.2:a
 *            and then sent along - unencapsulated.
 *            When a packet is sent out from the client, the
 *            app (e.g. dplay) uses 192.168.0.2:a as in the
 *            IP+UDP/TCP header but uses 24.128.34.21:A for
 *            any information encoded in the data portion of
 *            the packet.
 */
#define RSIP_VERSION 1
#define RSIP_HOST_PORT 2234

// How often we scan the list for liscence renewals
#define RSIP_RENEW_TEST_INTERVAL 60000

/* start RSIP retry timer at 12.5 ms */
#define RSIP_tuRETRY_START	12500
/* max starting retry is 100 ms */
#define RSIP_tuRETRY_MAX	100000

#define RESP_BUF_SIZE	100

enum { /* TUNNELS */
  TUNNEL_RESERVED = 0,
  TUNNEL_IP_IP = 1,
  TUNNEL_GRE = 2, /* PPTP */
  TUNNEL_L2TP = 3,
  /*TUNNEL_NONE = 4, /* THIS IS NOT PART OR THE SPEC */
};
enum { /* METHODS */
  METHOD_RESERVED = 0,
  RSA_IP = 1,
  RSAP_IP = 2,
  RSA_IP_IPSEC = 3,
  RSAP_IP_IPSEC = 4,
};
enum { /* FLOWS */
  FLOW_RESERVED = 0,
  FLOW_MACRO = 1,
  FLOW_MICRO = 2,
  FLOW_NONE = 3,
};
enum { /* ERROR CODES */
  UNKNOWNERROR = 1,
  BADBINDID = 2,
  BADCLIENTID = 3,
  MISSINGPARAM = 4,
  DUPLICATEPARAM = 5,
  ILLEGALPARAM = 6,
  ILLEGALMESSAGE = 7,
  REGISTERFIRST = 8,
  BADMESSAGEID = 9,
  ALREADYREGISTERED = 10,
  ALREADYUNREGISTERED = 11,
  BADTUNNELTYPE = 12,
  ADDRUNAVAILABLE = 13,
  PORTUNAVAILABLE = 14,
};

enum { /* MESSAGES */
  RSIP_ERROR_RESPONSE = 1,
  RSIP_REGISTER_REQUEST = 2,
  RSIP_REGISTER_RESPONSE = 3,
  RSIP_DEREGISTER_REQUEST = 4,
  RSIP_DEREGISTER_RESPONSE = 5,
  RSIP_ASSIGN_REQUEST_RSA_IP = 6,
  RSIP_ASSIGN_RESPONSE_RSA_IP = 7,
  RSIP_ASSIGN_REQUEST_RSAP_IP = 8,
  RSIP_ASSIGN_RESPONSE_RSAP_IP = 9,
  RSIP_EXTEND_REQUEST = 10,
  RSIP_EXTEND_RESPONSE = 11,
  RSIP_FREE_REQUEST = 12,
  RSIP_FREE_RESPONSE = 13,
  RSIP_QUERY_REQUEST = 14,
  RSIP_QUERY_RESPONSE = 15,
  RSIP_DEALLOCATE = 16,
  RSIP_OK = 17,
  RSIP_LISTEN_REQUEST = 18,
  RSIP_LISTEN_RESPONSE = 19,
};
enum { /* PARAMETERS */
  RSIP_ADDRESS_CODE = 1,
  RSIP_PORTS_CODE = 2,
  RSIP_LEASE_CODE = 3,
  RSIP_CLIENTID_CODE = 4,
  RSIP_BINDID_CODE = 5,
  RSIP_MESSAGEID_CODE = 6,
  RSIP_TUNNELTYPE_CODE = 7,
  RSIP_RSIPMETHOD_CODE = 8,
  RSIP_ERROR_CODE = 9,
  RSIP_FLOWPOLICY_CODE = 10,
  RSIP_VENDOR_CODE = 11,
};

/*
 * MS specific Vendor Codes
 */
#define RSIP_MS_VENDOR_ID 734
enum {
  RSIP_NO_TUNNEL = 1,
  RSIP_TCP_PORT = 2,
  RSIP_UDP_PORT = 3,
  RSIP_SHARED_UDP_LISTENER = 4,
  RSIP_QUERY_MAPPING = 5,
};

#define	ANY_PORT	0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack(push,1)

typedef struct _RSIP_MSG_HDR {
	CHAR	version;
	CHAR	msgtype;
} RSIP_MSG_HDR, *PRSIP_MSG_HDR;

typedef struct _RSIP_PARAM {
	CHAR	code;
	WORD	len;
} RSIP_PARAM, *PRSIP_PARAM;

typedef struct _RSIP_MESSAGEID{
	CHAR	code;
	WORD	len;
	DWORD   msgid;	
} RSIP_MESSAGEID, *PRSIP_MESSAGEID;

typedef struct _RSIP_CLIENTID {
	CHAR 	code;
	WORD	len;
	DWORD	clientid;
} RSIP_CLIENTID, *PRSIP_CLIENTID;

typedef struct _RSIP_ADDRESS {
	CHAR 	code;
	WORD	len;
	CHAR    version;	// 1==v4
	DWORD	addr;
} RSIP_ADDRESS, *PRSIP_ADDRESS;

typedef struct _RSIP_PORT {
	CHAR	code;
	WORD 	len;
	CHAR	nports;		// we only do 1 port at a time
	WORD	port;
} RSIP_PORT, *PRSIP_PORT;

typedef struct _RSIP_LEASE {
	CHAR	code;
	WORD	len;
	DWORD	leasetime;
} RSIP_LEASE, *PRSIP_LEASE;

typedef struct _RSIP_BINDID {
	CHAR	code;
	WORD	len;
	DWORD	bindid;
} RSIP_BINDID, *PRSIP_BINDID;

typedef struct _RSIP_TUNNEL {
	CHAR	code;
	WORD	len;
	CHAR	tunneltype;
} RSIP_TUNNEL, *PRSIP_TUNNEL;

// Vendor Specific structures

typedef struct _RSIP_MSVENDOR_CODE {
	CHAR	code;
	WORD	len;
	WORD	vendorid;
	WORD	option;
}RSIP_MSVENDOR_CODE, *PRSIP_MSVENDOR_CODE;

//
// RSIP Message templates
//

typedef struct _MSG_RSIP_REGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_REGISTER, *PMSG_RSIP_REGISTER;

typedef struct _MSG_RSIP_DEREGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID   clientid;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_DEREGISTER, *PMSG_RSIP_DEREGISTER;

typedef struct _MSG_RSIP_ASSIGN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;

	RSIP_MSVENDOR_CODE  porttype;
	RSIP_MSVENDOR_CODE  tunneloptions;
} MSG_RSIP_ASSIGN_PORT, *PMSG_RSIP_ASSIGN_PORT;

typedef struct _MSG_RSIP_LISTEN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;

	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE tunneloptions;
	RSIP_MSVENDOR_CODE listentype;
} MSG_RSIP_LISTEN_PORT, *PMSG_RSIP_LISTEN_PORT;


typedef struct _MSG_RSIP_EXTEND_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID		bindid;
	RSIP_LEASE		lease;
	RSIP_MESSAGEID	msgid;
} MSG_RSIP_EXTEND_PORT, *PMSG_RSIP_EXTEND_PORT;

typedef struct _MSG_RSIP_FREE_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID     bindid;
	RSIP_MESSAGEID	msgid;	
} MSG_RSIP_FREE_PORT, *PMSG_RSIP_FREE_PORT;

typedef struct _MSG_RSIP_QUERY {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	address;
	RSIP_PORT		port;

	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE querytype;

	RSIP_MESSAGEID	msgid;
} MSG_RSIP_QUERY, *PMSG_RSIP_QUERY;

typedef struct _RSIP_RESPONSE_INFO {
	DWORD	clientid;
	DWORD	messageid;
	DWORD	bindid;
	DWORD	leasetime;
	CHAR    version;
	CHAR    msgtype;
	CHAR	tunneltype;
	CHAR	rsipmethod;
	DWORD	lAddressV4;	
	WORD	lPort;
	DWORD   rAddressV4;
	WORD    rPort;
	WORD	error;
} RSIP_RESPONSE_INFO, *PRSIP_RESPONSE_INFO;

#pragma pack(pop)

typedef struct _RSIP_LEASE_RECORD {
	struct _RSIP_LEASE_RECORD * pNext;
	DWORD   dwRefCount;
	BOOL    ftcp_udp;
	DWORD	tExpiry;
	DWORD   bindid;
	DWORD   addrV4; // remote IP address
	SHORT   rport; 	// remote port
	SHORT	port;	// local port
} RSIP_LEASE_RECORD, *PRSIP_LEASE_RECORD;

// Cache of queried address mappings so we don't
// need to requery the mappings over and over
typedef struct _ADDR_ENTRY {
	struct _ADDR_ENTRY *pNext;
	BOOL	ftcp_udp;
	DWORD	tExpiry;
	DWORD	addr;
	DWORD	raddr;
	WORD	port;
	WORD	rport;
} ADDR_ENTRY, *PADDR_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

#if 0
static const char *rsip_error_strs[]={
  "RESERVED",
  "UNKNOWNERROR",
  "BADBINDID",
  "BADCLIENTID",
  "MISSINGPARAM",
  "DUPLICATEPARAM",
  "ILLEGALPARAM",
  "ILLEGALMESSAGE",
  "REGISTERFIRST",
  "BADMESSAGEID",
  "ALREADYREGISTERED",
  "ALREADYUNREGISTERED",
  "BADTUNNELTYPE",
  "ADDRUNAVAILABLE",
  "PORTUNAVAILABLE",
  (char *)0
};
#endif

//
// initialization of static member
//
LONG CRsip::m_MsgID = 0;

//**********************************************************************
// Function prototypes
//**********************************************************************
//typedef unsigned __int64 ULONGLONG;
typedef DWORD (WINAPI *LpFnGetAdaptersInfo)(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
typedef DWORD (WINAPI *LpFnGetBestInterface)( const UINT IPAddr, ULONG *const pIndex );
typedef DWORD (WINAPI *LpFnIpRenewAddress)(PIP_ADAPTER_INDEX_MAP AdapterInfo);


//**********************************************************************
// Function definitions
//**********************************************************************


/*=============================================================================

	CRsip::CRsip - constructor

    Description:

		Constructor

    Parameters:

    	Nothing.

    Return Values:

		Nothing.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::CRsip"

CRsip::CRsip():
	m_iRefCount( 0 ),
	m_sRsip( INVALID_SOCKET ),
	m_ClientID( 0 ),
	m_pRsipLeaseRecords( NULL ),
	m_pAddrEntry( NULL ),
	m_tuRetry( 0 ),
	m_pThreadPool( NULL ),
	m_fLockInitialized( FALSE )
{
	
}

/*=============================================================================

	CRsip::~CRsip - destructor

    Description:

		Destructor

    Parameters:

    	Nothing.

    Return Values:

		Nothing.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::~CRsip"

CRsip::~CRsip()
{
	DNASSERT( m_iRefCount == 0 );
	DNASSERT( m_sRsip == INVALID_SOCKET );
	DNASSERT( m_ClientID == 0 );
	DNASSERT( m_pRsipLeaseRecords == NULL );
	DNASSERT( m_pAddrEntry == NULL );
	DNASSERT( m_tuRetry == 0 );
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_fLockInitialized == FALSE );
}

/*=============================================================================

	CRsip::Initialize - Initialize RSIP support.  If this function succeeds then there
			   is an RSIP gateway on the network and the SP should call the
			   RSIP services when creating and destroying sockets that need
			   to be accessed from machines outside the local realm.

    Description:

		Looks for the Gateway, then check to see if it is RSIP enabled.

    Parameters:

		Pointer to thread pool
		Pointer to base socket address
			Used to take SP guid to look up gateway on Win95.  Since this
			only works on Win9x, the GUID is hard-coded in the function call
			because old DPlay is guaranteed to be available on a Win9x system.
			Any new systems won't care because they'll support the GetAdaptersInfo
			call.
		Boolean indicating that this is an Rsip host

    Return Values:

		TRUE  - found and RSIP gateway and initialized.
		FALSE - no RSIP gateway found.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::Initialize"

BOOL	CRsip::Initialize( CThreadPool *const pThreadPool, const SOCKADDR *const pBaseSocketAddress, const BOOL fIsRsipServer )
{
//	HRESULT		hr;
//	char		gwipaddr[32];
	BOOL		bReturn = TRUE;
	BOOL		fBroadcastFlag;
	INT_PTR		iReturnValue;
	SOCKADDR_IN saddr;
	DN_TIME		RsipRetryTime;
	DN_TIME		RsipTimeoutTime;


	DNASSERT( ( pThreadPool != NULL ) || ( fIsRsipServer != FALSE ) );
	DNASSERT( m_pThreadPool == NULL );
	m_pThreadPool = pThreadPool;

	RsipRetryTime.Time32.TimeHigh = 0;
	RsipRetryTime.Time32.TimeLow = RSIP_RENEW_TEST_INTERVAL;
	RsipTimeoutTime.Time32.TimeHigh = 0;
	RsipTimeoutTime.Time32.TimeLow = 0;

	DNASSERT( m_fLockInitialized == FALSE );
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		bReturn = FALSE;
		goto Exit;
	}
	m_fLockInitialized = TRUE;

//	// find the default gateway
//	hr = FindGateway( p_inet_addr(AN_IP_ADDRESS), gwipaddr );
//	if(hr!=DPN_OK){
//
//	    hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
//
//	    if(hr != DPN_OK){
//	    	bReturn=FALSE;
//	    	goto Exit;
//	    }
//
//	    DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
//	}

	// create a SOCKADDR to address the RSIP service on the gateway
	memset(&m_saddrGateway, 0, sizeof( m_saddrGateway ) );
	m_saddrGateway.sin_family		= AF_INET;
	m_saddrGateway.sin_port			= p_htons( RSIP_HOST_PORT );

	// create an address to specify the port to bind our datagram socket to.
	memset(&saddr,0,sizeof(SOCKADDR_IN));
	saddr.sin_family	  = AF_INET;
	saddr.sin_port        = p_htons(0);

	//
	// if this is the Rsip server, bind to all adapters and talk via loopback.
	// If not, bind to the particular adapter and use broadcast to find the
	// Rsip server
	//
	if ( fIsRsipServer != FALSE )
	{
		m_saddrGateway.sin_addr.S_un.S_addr = p_htonl( INADDR_LOOPBACK );
		saddr.sin_addr.s_addr = p_htonl( INADDR_ANY );
	}
	else
	{
		m_saddrGateway.sin_addr.S_un.S_addr = p_htonl( INADDR_BROADCAST );
		saddr.sin_addr.s_addr = reinterpret_cast<const SOCKADDR_IN*>( pBaseSocketAddress )->sin_addr.s_addr;
	}

	// create a datagram socket for talking to the RSIP facility on the gateway
	if( ( m_sRsip = p_socket( AF_INET, SOCK_DGRAM, 0 ) ) == INVALID_SOCKET ){
		DPF(0,"ERROR: rsipInit() socket call for RSIP listener failed\n");
		bReturn = FALSE;
		goto Exit;
	}

	//
	// set socket to allow broadcasts
	//
	fBroadcastFlag = TRUE;
	DBG_CASSERT( sizeof( &fBroadcastFlag ) == sizeof( char * ) );
	iReturnValue = p_setsockopt( m_sRsip,			// socket
	    						 SOL_SOCKET,		// level (set socket options)
	    						 SO_BROADCAST,		// set broadcast option
	    						 reinterpret_cast<char *>( &fBroadcastFlag ),	// allow broadcast
	    						 sizeof( fBroadcastFlag )	// size of parameter
	    						 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
	    DPF( 0, "Unable to set socket options!" );
	    DisplayWinsockError( 0, dwErrorCode );
		bReturn = FALSE;
	    goto Exit;
	}
	
	// bind the datagram socket to any local address and port.
	if( p_bind(m_sRsip, (PSOCKADDR)&saddr, sizeof(saddr) ) != 0){
		DPF(0,"ERROR: rsipInit() bind for RSIP listener failed\n");
		bReturn=FALSE;
		goto Exit;
	}

	m_tuRetry=12500; // start retry timer at 12.5 ms

	// find out if there is an rsip service and register with it.
	if ( Register() != DPN_OK )
	{
		bReturn=FALSE;
		goto Exit;
	}


	//
	// Attempt to add timer job.  If this fails, too bad.  Rsip might time out
	// the lease if there's no traffic.
	//
	if ( pThreadPool != NULL )
	{
		AddRef();
		m_fTimerJobSubmitted = TRUE;
		if ( pThreadPool->SubmitTimerJob( 1,
										  TRUE,
										  RsipRetryTime,
										  TRUE,
										  RsipTimeoutTime,
										  CRsip::RsipTimerFunction,
										  CRsip::RsipTimerComplete,
										  this ) != DPN_OK )
		{
			m_fTimerJobSubmitted = FALSE;
			DecRef();
			DPF( 0, "Failed to submit timer job to watch over Rsip!" );
		}
	}

Exit:
	if( bReturn == FALSE )
	{
		if( m_sRsip != INVALID_SOCKET )
		{
			p_closesocket( m_sRsip );
			m_sRsip = INVALID_SOCKET;
		}
	}

	return bReturn;
}


/*=============================================================================

	CRsip::Deinitialize - Shut down RSIP support

	   All threads that might access RSIP MUST be stopped before this
	   is called.

    Description:

		Deregisters with the Rsip Agent on the gateway, and cleans up
		the list of lease records.

    Parameters:

		Pointer to thread pool

    Return Values:

		None.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::Deinitialize"

void	CRsip::Deinitialize( void )
{
	RSIP_LEASE_RECORD	*pLeaseWalker;
	RSIP_LEASE_RECORD	*pNextLease;
	ADDR_ENTRY			*pAddrWalker;
	ADDR_ENTRY			*pNextAddr;


	if ( m_pThreadPool != NULL )
	{
		if ( m_fTimerJobSubmitted != FALSE )
		{
			m_pThreadPool->StopTimerJob( this, DPNERR_USERCANCEL );
			m_fTimerJobSubmitted = FALSE;
		}

		m_pThreadPool = NULL;
	}

	if(m_sRsip!=INVALID_SOCKET){
		Deregister();	
		p_closesocket(m_sRsip);
		m_sRsip=INVALID_SOCKET;
	}	
	
	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	// free the leases
	pLeaseWalker = m_pRsipLeaseRecords;
	while( pLeaseWalker ){
		pNextLease = pLeaseWalker->pNext;
		DNFree(pLeaseWalker);
		pLeaseWalker=pNextLease;
	}
	m_pRsipLeaseRecords=NULL;

	// free the cached address mappings
	pAddrWalker=m_pAddrEntry;
	while(pAddrWalker){
		pNextAddr=pAddrWalker->pNext;
		DNFree(pAddrWalker);
		pAddrWalker=pNextAddr;
	}
	m_pAddrEntry=NULL;

	m_MsgID = 0;
	m_tuRetry = 0;
	memset( &m_saddrGateway, 0x00, sizeof( m_saddrGateway ) );
}


//**********************************************************************
// ------------------------------
// CRsip::RsipIsRunningOnThisMachine - return Boolean indicating whether this machine
//		is an Rsip machine.
//
// Entry:		Pointer to socket address to be filled in with public address
//
// Exit:		Boolean
//				TRUE = this is Rsip machine
//				FALSE = this is not Rsip machine
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::RsipIsRunningOnThisMachine"

BOOL	CRsip::RsipIsRunningOnThisMachine( SOCKADDR *const pPublicSocketAddress )
{
	SOCKET		Socket;
	BOOL		fReturn;


	Socket = INVALID_SOCKET;
	fReturn = FALSE;
	
	//
	// Attempt to bind to the Rsip port.  If we can't bind to it, assume that
	// Rsip is running on this machine.
	//
	Socket = p_socket( AF_INET, SOCK_DGRAM, 0 );
	if ( Socket != INVALID_SOCKET )
	{
		SOCKADDR_IN	addr;
		

		memset( &addr, 0, sizeof(SOCKADDR_IN ) );
		addr.sin_family = AF_INET;
		addr.sin_addr.S_un.S_addr = p_htonl( INADDR_LOOPBACK );
		addr.sin_port = p_htons( RSIP_HOST_PORT );
		DBG_CASSERT( sizeof( addr ) == sizeof( SOCKADDR ) );
		
		if ( p_bind( Socket, reinterpret_cast<SOCKADDR*>( &addr ), sizeof( addr ) ) != 0 )
		{
			fReturn = TRUE;
		}

		p_closesocket( Socket );
		Socket = INVALID_SOCKET;
	}

	//
	// This is an Rsip server, create a local socket and bind it to the server
	// to find out what the public address is.
	//
	if ( fReturn != FALSE )
	{		
		HRESULT			hr;
		SOCKADDR_IN 	SocketAddress;
		INT				iBoundAddressSize;
		SOCKADDR_IN		BoundAddress;
		SOCKADDR		RsipAssignedAddress;
		DWORD			dwBindID;

			
		Socket = p_socket( AF_INET, SOCK_DGRAM, 0 );
		if ( Socket == INVALID_SOCKET )
		{
			fReturn = FALSE;
			goto Failure;
		}

		memset( &SocketAddress, 0x00, sizeof( SocketAddress ) );
		SocketAddress.sin_family = AF_INET;
		SocketAddress.sin_addr.S_un.S_addr = p_htonl( INADDR_ANY );
		SocketAddress.sin_port = p_htons( ANY_PORT );

		DBG_CASSERT( sizeof( SocketAddress ) == sizeof( SOCKADDR ) );
		if ( p_bind( Socket, reinterpret_cast<SOCKADDR*>( &SocketAddress ), sizeof( SocketAddress ) ) != 0 )
		{
			fReturn = FALSE;
			goto Failure;
		}

		iBoundAddressSize = sizeof( BoundAddress );
		DBG_CASSERT( sizeof( BoundAddress ) == sizeof( SOCKADDR ) );
		if ( p_getsockname( Socket, reinterpret_cast<SOCKADDR*>( &BoundAddress ), &iBoundAddressSize ) != 0 )
		{
			fReturn = FALSE;
			goto Failure;
		}
		DNASSERT( iBoundAddressSize == sizeof( BoundAddress ) );

		DBG_CASSERT( sizeof( SocketAddress ) == sizeof( SOCKADDR ) );
		if ( Initialize( NULL, reinterpret_cast<SOCKADDR*>( &SocketAddress ), TRUE ) == FALSE )
		{
			fReturn = FALSE;
			goto Failure;
		}

		hr = AssignPort( FALSE, BoundAddress.sin_port, &RsipAssignedAddress, &dwBindID );
		if ( hr != DPN_OK )
		{
			fReturn = FALSE;
			DPF( 0, "Failed to assign port when attempting to determine public network address!" );
			goto Failure;
		}

		DBG_CASSERT( sizeof( *pPublicSocketAddress ) == sizeof( RsipAssignedAddress ) );
		memcpy( pPublicSocketAddress, &RsipAssignedAddress, sizeof( *pPublicSocketAddress ) );
		
		FreePort( dwBindID );
	}

Exit:
	if ( Socket != INVALID_SOCKET )
	{
		p_closesocket( Socket );
		Socket = INVALID_SOCKET;
	}
	
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


///*=============================================================================
//
//    CRsip::FindGateway - find the address of the internet gateway (possibly RSIP
//    			  host) for this machine.
//
//
//    Description:
//
//    	Uses the ip helper api to find the default IP gateway.
//
//    Parameters:
//
//    	uint32 myip      - ip adapter to find default gateway for
//    	char   *gwipaddr - gateway address if found
//
//    Return Values:
//
//    	DPN_OK - found gateway
//    	DPNERR_GENERIC - failed.
//
//    Note: code stolen from Rick Lamb (rlamb)
//
//-----------------------------------------------------------------------------*/
//HRESULT CRsip::FindGateway( const UINT myip, char *const gwipaddr )
//{
//    PIP_ADAPTER_INFO	pAdapterInfo = NULL;
//    PIP_ADAPTER_INFO	p0AdapterInfo = NULL;
//    DWORD		error = 0;
//    DWORD		len = 0;
//    UINT		i;
//    HMODULE		hIpHlpApi;
//    ULONG		bindex;
//
//
//    IP_ADAPTER_INDEX_MAP ipaim;
//    LpFnGetAdaptersInfo	lpFnGetAdaptersInfo;
//    LpFnGetBestInterface lpFnGetBestInterface;
//    LpFnIpRenewAddress	 lpFnIpRenewAddress;
//
// /*
//     * See if there is an RSIP server running.
//     * If so, we must be running on the server itself
//     * so use the loopback interface.
//     */
//    if(gwipaddr) {
//    	SOCKET s;
//    	SOCKADDR_IN addr;
//
//    	if ( ( s = p_socket( AF_INET, SOCK_DGRAM, 0 ) ) != INVALID_SOCKET ) {
//    			memset(&addr,0,sizeof(SOCKADDR_IN));
//    			addr.sin_family = AF_INET;
//    			addr.sin_addr.s_addr = p_inet_addr(LOOPBACK_ADDR);
//    			addr.sin_port = p_htons(RSIP_HOST_PORT);
//    			if( p_bind(s,(struct sockaddr *)&addr,sizeof(addr)) < 0) {
//    		/*
//    	 	* Something is there already
//    		*/
//    		memcpy(gwipaddr,LOOPBACK_ADDR,sizeof(LOOPBACK_ADDR));
//    		DPF(0,"USING LOOPBACK: default gateway %s\n",gwipaddr);
//    		p_closesocket(s);
//    		goto done;
//    			}
//    			p_closesocket(s);
//    	}
//
//    }
//
//    hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
//    if(hIpHlpApi == NULL) {
//    	error = DPNERR_GENERIC;
//    	DPF(0,"[NET] failed to load IPHLPAIP.DLL\n");
//    goto done;
//    }
//
//    lpFnGetAdaptersInfo = (LpFnGetAdaptersInfo) GetProcAddress(hIpHlpApi, "GetAdaptersInfo");
//    if(lpFnGetAdaptersInfo == NULL) {
//    	DPF(0,"[NET] failed to find GetAdaptersInfo\n");
//    DNASSERT( FALSE );
//    error = DPNERR_GENERIC;
//    	goto done;
//    }
//
//    error = (*lpFnGetAdaptersInfo) (pAdapterInfo, &len);
//    if(error != ERROR_BUFFER_OVERFLOW) {
//    	DPF(0,"[NET] GetAdaptersInfo failed error 0x%lx\n", error);
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//
//    p0AdapterInfo = pAdapterInfo = static_cast<IP_ADAPTER_INFO*>( DNMalloc( len ) );
//    if(pAdapterInfo == NULL) {
//    	DPF(0,"[NET] memory allocation failed\n");
//    DNASSERT( FALSE );
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//
//    error = (*lpFnGetAdaptersInfo) (pAdapterInfo, &len);
//    if(error != 0) {
//    	DPF(0, "[NET] GetAdaptersInfo failed error 0x%lx\n", error);
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//
//    lpFnIpRenewAddress = (LpFnIpRenewAddress) GetProcAddress(hIpHlpApi,"IpRenewAddress");
//    if(lpFnIpRenewAddress == NULL) {
//    	DPF(0," failed to find IpRenewAddress\n");
//    DNASSERT( FALSE );
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//
//
//    lpFnGetBestInterface = (LpFnGetBestInterface) GetProcAddress(hIpHlpApi, "GetBestInterface");
//    if(lpFnGetBestInterface == NULL) {
//    	DPF(0," failed to find GetBestInterface\n");
//    DNASSERT( FALSE );
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//
//    error = (*lpFnGetBestInterface) (myip, &bindex);
//    if(error != 0) {
//    	DPF(0,"[NET] GetBestInterface failed error 0x%lx\n", error);
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//    /*printf("Renew Interface Index = %d\n",bindex);/**/
//
//    for(i = 0; pAdapterInfo != NULL; i++, pAdapterInfo = pAdapterInfo->Next) {
//    	DPF(8,"[NET] Adapter Info\n");
//    	DPF(8,"[NET] \t name %s\n",pAdapterInfo->AdapterName);
//    	DPF(8,"[NET] \t description %s\n",pAdapterInfo->Description);
//    	DPF(8,"[NET] \t index %d\n",pAdapterInfo->Index);
//    	DPF(8,"[NET] \t combo index %d\n",pAdapterInfo->ComboIndex);
//    	if(pAdapterInfo->Index == bindex) break;
//    }
//
//    if(pAdapterInfo == NULL) {
//    	DPF(8,"No match\n");
//    	error=DPNERR_GENERIC;
//    	goto done;
//    }
//
//    {
//    	PIP_ADDR_STRING ips;
//    	ips = &pAdapterInfo->GatewayList;
//    	if(gwipaddr) {
//    		strcpy(gwipaddr,ips->IpAddress.String);
//    		DPF(0,"default gateway %s\n",gwipaddr);
//    		goto done;
//    	}
//    }
//
//done:
//    if ( p0AdapterInfo != NULL )
//    {
//    	DNFree(p0AdapterInfo);
//    }
//
//    if( hIpHlpApi != NULL )
//    {
//    	FreeLibrary(hIpHlpApi);
//    }
//
//    DPF(8,"[NET] < FindGateway\n");
//    return error;
//}


/*=============================================================================

	CRsip::ExchangeAndParse - send a request to the rsip server and
						   wait for and parse the reply


    Description:

	Since there is almost no scenario where we don't immediately need to know
	the response to an rsipExchange, there is no point in doing this
	asynchronously.  The assumption is that an RSIP server is sufficiently
	local that long retries are not necessary.  We use the approach suggested
	in the IETF draft protocol specification, that is 12.5ms retry timer
	with 7-fold exponential backoff.  This can lead to up to a total 1.5
	second wait in the worst case.  (Note this section may no longer be
	available since the rsip working group decided to drop UDP support)

    Parameters:

		pRequest  - a fully formatted RSIP request buffer
		cbReq     - size of request buffer
		pRespInfo - structure that returns response parameters
		messageid - the message id of this request
		bConnect  - whether this is the register request, we use a different
					timer strategy on initial connect because we really
					don't want to miss it if there is a gateway.
		pRecvSocketAddress - pointer to recv address destination (needed for connect)

    Return Values:

		DPN_OK - exchange succeeded, reply is in the reply buffer.
		otw, failed, RespInfo is bubkas.

-----------------------------------------------------------------------------*/

#define MAX_RSIP_RETRY	6

struct timeval tv0={0,0};

#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::ExchangeAndParse"

HRESULT CRsip::ExchangeAndParse( PCHAR pRequest,
								 const UINT cbReq,
								 RSIP_RESPONSE_INFO *const pRespInfo,
								 const DWORD messageid,
								 const BOOL bConnect,
								 SOCKADDR *const pRecvSocketAddress )
{
	CHAR	RespBuffer[ RESP_BUF_SIZE ];
	DWORD	dwRespLen = sizeof( RespBuffer );
	INT		iRecvSocketAddressSize = sizeof( *pRecvSocketAddress );

	struct timeval tv;
	FD_SET readfds;
	INT    nRetryCount=0;
	int    rc;
	int    cbReceived;
	HRESULT hr=DPN_OK;

	
	DNASSERT( pRequest != NULL );
	DNASSERT( pRespInfo != NULL );
	DNASSERT( pRecvSocketAddress != NULL );

	DPF( 8, "==>RsipExchangeAndParse msgid %d\n", messageid );

	memset(RespBuffer, 0, RESP_BUF_SIZE);
	memset(pRespInfo, 0, sizeof(RSIP_RESPONSE_INFO));

	if(!bConnect){
		tv.tv_usec = m_tuRetry;
		tv.tv_sec  = 0;
		nRetryCount = 0;
	} else {
		// on a connect request we try twice with a 1 second total timeout
		tv.tv_usec = 500000;	// 0.5 seconds
		tv.tv_sec  = 0;
		nRetryCount = MAX_RSIP_RETRY-2;
	}


	FD_ZERO(&readfds);
	FD_SET(m_sRsip, &readfds);

	rc=0;

	// First clear out any extraneous responses.
	while( p_select( 0, &readfds, NULL, NULL, &tv0 ) )
	{
		cbReceived = p_recvfrom( m_sRsip, RespBuffer, dwRespLen, 0, NULL, NULL );
		switch ( cbReceived )
		{
			//
			// nothing received, try again
			//
			case 0:
			{
				break;
			}

			//
			// read failure, bail!
			//
			case SOCKET_ERROR:
			{
				rc = p_WSAGetLastError();
				DPF( 0, "Got sockets error %d trying to receive (clear incoming queue) on RSIP socket\n", rc );
				hr = DPNERR_GENERIC;
				
				break;
			}

			default:
			{
				DPF( 7, "Found extra response from previous RSIP request\n" );
				if( m_tuRetry < RSIP_tuRETRY_MAX )
				{
					// don't re-try so quickly
					m_tuRetry *= 2;
					DPF( 7, "rsip Set m_tuRetry to %d usec\n", m_tuRetry );
				}	
				
				break;
			}
		}
		
		FD_ZERO(&readfds);
		FD_SET(m_sRsip, &readfds);
	}


	// Now do the exchange, get a response to the request, does retries too.
	do{

		if(++nRetryCount > MAX_RSIP_RETRY) {
			break;
		}

		DPF( 7, "Sending RSIP Request to gateway, RetryCount=%d", nRetryCount );
		DBG_CASSERT( sizeof( m_saddrGateway ) == sizeof( SOCKADDR ) );
		DumpSocketAddress( 0, reinterpret_cast<SOCKADDR*>( &m_saddrGateway ), AF_INET);

		// First send off the request
		rc=p_sendto(m_sRsip, pRequest, cbReq, 0, (SOCKADDR *)&m_saddrGateway, sizeof(SOCKADDR) );

		if( rc == SOCKET_ERROR )
		{
			rc = p_WSAGetLastError();
			DPF( 0, "Got sockets error %d on sending to RSIP gateway\n", rc );
			hr = DPNERR_GENERIC;
			goto exit;
		}

		if( rc != (int)cbReq )
		{
			DPF( 0, "Didn't send entire datagram?  shouldn't happen\n" );
			hr=DPNERR_GENERIC;
			goto exit;
		}

		// Now see if we get a response.
select_again:		
		FD_ZERO(&readfds);
		FD_SET(m_sRsip, &readfds);

		rc=p_select(0,&readfds,NULL,NULL,&tv);

		if(rc==SOCKET_ERROR){
			rc=p_WSAGetLastError();
			DPF(0,"Got sockets error %d trying to select on RSIP socket\n",rc);
			hr=DPNERR_GENERIC;
		}

		DPF(0,"Return From Select %d",rc);

		
		//
		// there's only one item in the set, make sure of this, and if there
		// was a signalled socket, make sure it's our socket.
		//
		if( p___WSAFDIsSet(m_sRsip, &readfds)){
			break;
		}

		if(!bConnect){
			DPF( 7, "Didn't get response, increasing timeout value" );
			// don't use exponential backoff on initial connect
			tv.tv_usec *= 2;	// exponential backoff.
		}	

		DNASSERT(tv.tv_usec < 4000000);

	} while (rc==0); // keep retrying...


	if(rc == SOCKET_ERROR){
		DPF(0,"GotSocketError on select, extended error %d\n",p_WSAGetLastError());
		hr=DPNERR_GENERIC;
		goto exit;
	}

	if(rc)
	{
		// We Got Mail, err data....
		dwRespLen=RESP_BUF_SIZE;
		
		DPF( 7, "Receiving Data" );

		memset( pRecvSocketAddress, 0x00, sizeof( *pRecvSocketAddress ) );
		cbReceived=p_recvfrom(m_sRsip, RespBuffer, dwRespLen, 0, pRecvSocketAddress, &iRecvSocketAddressSize);

		// BUGBUG:Could get and check addrfrom to avoid spoofing, not that paranoid

		DPF( 7, "cbReceived = %d", cbReceived );

		if( ( cbReceived == 0 ) || ( cbReceived == SOCKET_ERROR ) )
		{
			rc=p_WSAGetLastError();
			DPF( 0, "Got sockets error %d trying to receive on RSIP socket\n", rc );
			hr=DPNERR_GENERIC;
		}
		else
		{
			DPF( 7, "Parsing Receive Buffer" );
			Parse( RespBuffer, cbReceived, pRespInfo );
			if(pRespInfo->messageid != messageid)
			{
				// Got a dup from a previous retry, go try again.
				DPF( 0, "Got messageid %d, expecting messageid %d\n", pRespInfo->messageid, messageid );
				goto select_again;
			}
		}
	}

	DPF( 8, "<==RsipExchangeAndParse hr=%x, Resp msgid %d\n", hr, pRespInfo->messageid );

exit:
	return hr;
}

/*=============================================================================

	CRsip::Parse - parses an RSIP request and puts fields into a struct.

    Description:

		This parser parses and RSIP request or response and extracts
		out the codes into a standard structure.  This is not completely
		general, as we know that we will only operate with v4 addresses
		and our commands will never deal with more than 1 address at a
		time.  If you need to handle multiple address requests
		and responses, then you will need to change this function.

	Limitations:

		This function only deals with single address/port responses.
		Rsip allows for multiple ports to be allocated in a single
		request, but we do not take advantage of this feature.

    Parameters:

		pBuf  		- buffer containing an RSIP request or response
		cbBuf 		- size of buffer in bytes
		pRespInfo   - a structure that is filled with the parameters
					  from the RSIP buffer.

    Return Values:

		DPN_OK - connected to the RSIP server.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::Parse"

HRESULT CRsip::Parse( CHAR *pBuf, DWORD cbBuf, PRSIP_RESPONSE_INFO pRespInfo )
{
	// character pointer version of parameter pointer.

	BOOL bGotlAddress=FALSE;
	BOOL bGotlPort   =FALSE;

	DWORD code;
	DWORD codelen;

	PRSIP_MSG_HDR pHeader;
	PRSIP_PARAM   pParam,pNextParam;
	CHAR          *pc;

	CHAR *pBufEnd = pBuf+cbBuf;

	if(cbBuf < 2){
		return DPNERR_INVALIDPARAM;
	}	

	pHeader=(PRSIP_MSG_HDR)pBuf;

	pRespInfo->version = pHeader->version;
	pRespInfo->msgtype = pHeader->msgtype;

	DPF(0,"rsipParse: version %d msgtype %d\n",pRespInfo->version, pRespInfo->msgtype);

	pParam = (PRSIP_PARAM)(pHeader+1);

	while((CHAR*)(pParam+1) < pBufEnd)
	{
		pc=(CHAR *)(pParam+1);
		pNextParam = (PRSIP_PARAM)(pc + pParam->len);

		if((CHAR *)pNextParam > pBufEnd){
			break;
		}	

		switch(pParam->code){

			case RSIP_ADDRESS_CODE:

				// Addresses are type[1]|addr[?]

				switch(*pc){
					case 1:
						if(!bGotlAddress){
							DPF(0,"rsipParse: lAddress %s\n",p_inet_ntoa(*((PIN_ADDR)(pc+1))));
							memcpy((char *)&pRespInfo->lAddressV4, pc+1, 4);
							bGotlAddress=TRUE;
						} else {	
							bGotlPort=TRUE; // just in case there wasn't a local port
							DPF(0,"rsipParse: rAddress %s,",p_inet_ntoa(*((PIN_ADDR)(pc+1))));
							memcpy((char *)&pRespInfo->rAddressV4, pc+1, 4);
						}	
						break;
					case 0:
					case 2:
					case 3:
					case 4:
					case 5:
						DPF(0,"Unexpected RSIP address code type %d\n",*pc);
					break;
				}
				break;

			case RSIP_PORTS_CODE:

				// Ports are Number[1]|Port[2]....Port[2]
				// BUGBUG: I think ports are backwards.
				if(!bGotlPort){
					DPF(0,"rsipParse lPort: %d\n", *((WORD *)(pc+1)));
					memcpy((char *)&pRespInfo->lPort, pc+1,2);
				} else {
					DPF(0,"rsipParse rPort: %d\n", *((WORD *)(pc+1)));
					memcpy((char *)&pRespInfo->rPort, pc+1,2);
					bGotlPort=TRUE;					
				}
				break;

  			case RSIP_LEASE_CODE:
				if(pParam->len == 4){
					memcpy((char *)&pRespInfo->leasetime,pc,4);
					DPF(0,"rsipParse Lease: %d\n",pRespInfo->leasetime);
				}	
  				break;

  			case RSIP_CLIENTID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->clientid,pc,4);
					DPF(0,"rsipParse clientid: %d\n",pRespInfo->clientid);
  				}
  				break;

  			case RSIP_BINDID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->bindid,pc,4);
					DPF(0,"rsipParse bindid: %x\n",pRespInfo->bindid);
  				}
  				break;

  			case RSIP_MESSAGEID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->messageid,pc,4);
					DPF(0,"rsipParse messageid: %d\n",pRespInfo->messageid);
  				}
  				break;

  			case RSIP_TUNNELTYPE_CODE:
  				DPF(0,"rsipParse Got Tunnel Type %d, ignoring\n",*pc);
  				break;

  			case RSIP_RSIPMETHOD_CODE:
  				DPF(0,"rsipParse Got RSIP Method %d, ignoring\n",*pc);
  				break;

  			case RSIP_ERROR_CODE:
  				if(pParam->len==2){
  					memcpy((char *)&pRespInfo->error,pc,2);
  				}
  				DPF(0,"rsipParse Got RSIP error %d\n",pRespInfo->error);
  				break;

  			case RSIP_FLOWPOLICY_CODE:
  				DPF(0,"rsipParse Got RSIP Flow Policy local %d remote %d, ignoring\n",*pc,*(pc+1));
  				break;

  			case RSIP_VENDOR_CODE:
  				break;

  			default:
  				DPF(0,"Got unknown parameter code %d, ignoring\n",pParam->code);
  				break;
		}

		pParam=pNextParam;

	}

	return DPN_OK;
}

/*=============================================================================

	CRsip::Register - register with the RSIP server on the gateway (if present)

    Description:

		Trys to contact the RSIP service on the gateway.

		Doesn't require lock since this is establishing the link during
		startup.  So no-one is racing with us.

    Parameters:

    	None.

    Return Values:

		DPN_OK 		  - connected to the RSIP server.
		DPNERR_GENERIC - can't find the RSIP service on the gateway.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::Register"

HRESULT	CRsip::Register( void )
{
	HRESULT		hr;
	SOCKADDR	RecvSocketAddress;
	MSG_RSIP_REGISTER  RegisterReq;
	RSIP_RESPONSE_INFO RespInfo;


	DPF( 8, "==>RSIP Register\n" );

	// Initialize the message sequencing.  Each message response pair
	// is numbered sequentially to allow differentiation over UDP link.

	m_MsgID = 0;
	
	// Build the request

	RegisterReq.version    	= RSIP_VERSION;
	RegisterReq.command    	= RSIP_REGISTER_REQUEST;
	RegisterReq.msgid.code 	= RSIP_MESSAGEID_CODE;
	RegisterReq.msgid.len  	= sizeof(DWORD);
	RegisterReq.msgid.msgid = InterlockedIncrement( &m_MsgID );

	hr = ExchangeAndParse( (PCHAR)&RegisterReq,
						   sizeof(RegisterReq),
						   &RespInfo,
						   RegisterReq.msgid.msgid,
						   TRUE,
						   &RecvSocketAddress );
	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_REGISTER_RESPONSE){
		DPF(0,"Failing registration, response was message type %d",RespInfo.msgtype);
		goto error_exit;
	}

	m_ClientID = RespInfo.clientid;
	DBG_CASSERT( sizeof( m_saddrGateway ) == sizeof( RecvSocketAddress ) );
	memcpy( &m_saddrGateway, &RecvSocketAddress, sizeof( m_saddrGateway ) );

	DPF( 8, "<==RSIP Register, ClientId %d", m_ClientID );

exit:
	return hr;

error_exit:
	DPF( 8, "<==RSIP Register FAILED" );
	return DPNERR_GENERIC;

}

/*=============================================================================

	CRsip::Deregister - close connection to RSIP gateway.

    Description:

    	Shuts down the registration of this application with the RSIP
    	gateway.  All port assignments are implicitly freed as a result
    	of this operation.

		- must be called with lock held.

    Parameters:

		None.

    Return Values:

		DPN_OK - successfully deregistered with the RSIP service.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::Deregister"

HRESULT	CRsip::Deregister( void )
{
	HRESULT 	hr;
	SOCKADDR	RecvSocketAddress;

	MSG_RSIP_DEREGISTER  DeregisterReq;
	RSIP_RESPONSE_INFO RespInfo;

	DPF( 8, "==>RSIP Deregister\n" );

	// Build the request

	DeregisterReq.version    	    = RSIP_VERSION;
	DeregisterReq.command    	    = RSIP_DEREGISTER_REQUEST;

	DeregisterReq.clientid.code     = RSIP_CLIENTID_CODE;
	DeregisterReq.clientid.len      = sizeof(DWORD);
	DeregisterReq.clientid.clientid = m_ClientID;

	DeregisterReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	DeregisterReq.msgid.len  	    = sizeof(DWORD);
	DeregisterReq.msgid.msgid       = InterlockedIncrement( &m_MsgID );

	hr=ExchangeAndParse( (PCHAR)&DeregisterReq,
						 sizeof(DeregisterReq),
						 &RespInfo,
						 DeregisterReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );
	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_DEREGISTER_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	DPF( 8, "<==RSIP Deregister Succeeded\n" );

exit:
	m_ClientID = 0;
	return hr;

error_exit:
	DPF( 8, "<==RSIP Deregister Failed\n" );
	hr = DPNERR_GENERIC;
	goto exit;
}

/*=============================================================================

	CRsip::AssignPort - assign a port mapping with the rsip server

    Description:

		Asks for a public realm port that is an alias for the local port on
		this local realm node.  After this request succeeds, all traffic
		directed to the gateway on the public side at the allocated public
		port, which the gateway provides and specifies in the response, will
		be directed to the specified local port.

		This function also adds the lease for the port binding to a list of
		leases and will renew the lease before it expires if the binding
		hasn't been released by a call to rsipFree first.

    Parameters:


		WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend
    							lease and/or release the binding (OPTIONAL).

    Return Values:

		DPN_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.

		DPNERR_GENERIC - assignment of a public port could not be made.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::AssignPort"

HRESULT	CRsip::AssignPort( const BOOL fTCP_UDP, const WORD wPort, SOCKADDR *const psaddr, DWORD *const pdwBindid )
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)

	HRESULT hr;

	MSG_RSIP_ASSIGN_PORT AssignReq;
	RSIP_RESPONSE_INFO RespInfo;
	PRSIP_LEASE_RECORD pLeaseRecord;
	SOCKADDR	RecvSocketAddress;


	Lock();

	DPF( 8, "==>RSIP Assign Port %d\n", p_htons( wPort ) );

	if(m_sRsip == INVALID_SOCKET){
		DPF(0,"rsipAssignPort: m_sRsip is invalid, bailing...\n");
		Unlock();
		return DPNERR_GENERIC;
	}

	if(pLeaseRecord=FindLease( fTCP_UDP, wPort )){

		// hey, we've already got a lease for this port, so use it.
		pLeaseRecord->dwRefCount++;

		if(psaddr_in){
			psaddr_in->sin_family = AF_INET;
			psaddr_in->sin_addr.s_addr = pLeaseRecord->addrV4;
			psaddr_in->sin_port		   = pLeaseRecord->rport;
		}	

		if(pdwBindid != NULL )
		{
			*pdwBindid = pLeaseRecord->bindid;
		}

		DPF( 7, "<==Rsip Assign, already have lease Bindid %d\n", pLeaseRecord->bindid );

		Unlock();

		hr=DPN_OK;


		goto exit;
	}

	// Build the request.

	AssignReq.version    		= RSIP_VERSION;
	AssignReq.command    		= RSIP_ASSIGN_REQUEST_RSAP_IP;

	AssignReq.clientid.code 	= RSIP_CLIENTID_CODE;
	AssignReq.clientid.len 		= sizeof(DWORD);
	AssignReq.clientid.clientid = m_ClientID;

	// Local Address (will be returned by RSIP server, us don't care value)

	AssignReq.laddress.code		= RSIP_ADDRESS_CODE;
	AssignReq.laddress.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	AssignReq.laddress.version	= 1; // IPv4
	AssignReq.laddress.addr		= 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	AssignReq.lport.code		= RSIP_PORTS_CODE;
	AssignReq.lport.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	AssignReq.lport.nports      = 1;
	AssignReq.lport.port		= p_htons( wPort );

	// Remote Address (not used with our flow control policy, use don't care value)

	AssignReq.raddress.code		= RSIP_ADDRESS_CODE;
	AssignReq.raddress.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	AssignReq.raddress.version  = 1; // IPv4
	AssignReq.raddress.addr     = 0; // Don't care

	AssignReq.rport.code		= RSIP_PORTS_CODE;
	AssignReq.rport.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	AssignReq.rport.nports      = 1;
	AssignReq.rport.port		= 0; // Don't care

	// Following parameters are optional according to RSIP spec...

	// Lease code, ask for an hour, but don't count on it.

	AssignReq.lease.code		 = RSIP_LEASE_CODE;
	AssignReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	AssignReq.lease.leasetime    = 3600;

	// Tunnell Type is IP-IP

	AssignReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	AssignReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	AssignReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.

	AssignReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	AssignReq.msgid.len  		 = sizeof(DWORD);
	AssignReq.msgid.msgid   	 = InterlockedIncrement( &m_MsgID );

	// Vendor specific - need to specify port type and no-tunneling

	AssignReq.porttype.code     	 = RSIP_VENDOR_CODE;
	AssignReq.porttype.len      	 = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	AssignReq.porttype.vendorid 	 = RSIP_MS_VENDOR_ID;
	AssignReq.porttype.option   	 = (fTCP_UDP)?RSIP_TCP_PORT:RSIP_UDP_PORT;

	AssignReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	AssignReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	AssignReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	AssignReq.tunneloptions.option   = RSIP_NO_TUNNEL;


	hr=ExchangeAndParse( (PCHAR)&AssignReq,
						 sizeof(AssignReq),
						 &RespInfo,
						 AssignReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );
	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_ASSIGN_RESPONSE_RSAP_IP){
		DPF(0,"Assignment failed? Response was %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port		   = p_htons(RespInfo.lPort);
	}

	if( pdwBindid != NULL )
	{
		*pdwBindid = RespInfo.bindid;
	}

	AddLease( RespInfo.bindid,
			  fTCP_UDP,
			  RespInfo.lAddressV4,
			  p_htons(RespInfo.lPort),
			  wPort,
			  RespInfo.leasetime);

	DPF( 8, "RSIP Port Assigned: " );
	DumpSocketAddress( 8, reinterpret_cast<SOCKADDR*>( psaddr_in ), psaddr_in->sin_family );
	DPF( 8, "<== BindId %d\n", RespInfo.bindid );

exit:
	return hr;

error_exit:
	DPF( 8, "<==Assign Port Failed\n" );
	return DPNERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	CRsip::ExtendPort - extend a port mapping

    Description:

		Extends the lease on a port mapping.

    Parameters:

    	DWORD        Bindid - binding identifier specified by the rsip service.
    	DWORD        ptExtend - amount of extra lease time granted.

    Return Values:

		DPN_OK - lease extended.
		DPNERR_GENERIC - couldn't extend the lease.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::ExtendPort"

HRESULT CRsip::ExtendPort( const DWORD Bindid, DWORD *const ptExtend )
{
	HRESULT hr;

	MSG_RSIP_EXTEND_PORT  ExtendReq;
	RSIP_RESPONSE_INFO RespInfo;
	SOCKADDR	RecvSocketAddress;


	Lock();

	DPF( 8, "==>Extend Port, Bindid %d\n", Bindid );

	if(m_sRsip == INVALID_SOCKET){
		DPF(0,"rsipExtendPort: m_sRsip is invalid, bailing...\n");
		Unlock();
		return DPNERR_GENERIC;
	}

	// Build the request

	ExtendReq.version    		= RSIP_VERSION;
	ExtendReq.command    		= RSIP_EXTEND_REQUEST;

	ExtendReq.clientid.code 	= RSIP_CLIENTID_CODE;
	ExtendReq.clientid.len 		= sizeof(DWORD);
	ExtendReq.clientid.clientid = m_ClientID;

	ExtendReq.bindid.code 		= RSIP_BINDID_CODE;
	ExtendReq.bindid.len 		= sizeof(DWORD);
	ExtendReq.bindid.bindid 	= Bindid;

	// Lease code, ask for an hour, but don't count on it.

	ExtendReq.lease.code		= RSIP_LEASE_CODE;
	ExtendReq.lease.len			= sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ExtendReq.lease.leasetime   = 3600;

	ExtendReq.msgid.code 		= RSIP_MESSAGEID_CODE;
	ExtendReq.msgid.len  		= sizeof(DWORD);
	ExtendReq.msgid.msgid   	= InterlockedIncrement( &m_MsgID );

	hr=ExchangeAndParse( (PCHAR)&ExtendReq,
						 sizeof(ExtendReq),
						 &RespInfo,
						 ExtendReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );

	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_EXTEND_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	*ptExtend=RespInfo.leasetime;

	DPF( 8, "<==Extend Port, Bindid %d Succeeded, extra lease time %d\n", Bindid, *ptExtend );

exit:
	return hr;

error_exit:
	DPF( 8, "<==Extend Port, Failed" );
	return DPNERR_GENERIC;

}

/*=============================================================================

	CRsip::FreePort - release a port binding

    Description:

		Removes the lease record for our port binding (so we don't renew it
		after we actually release the binding from the gateway).  Then informs
		the gateway that we are done with the binding.

    Parameters:

    	DWORD        Bindid - gateway supplied identifier for the binding

    Return Values:

		DPN_OK - port binding released.
		DPNERR_GENERIC - failed.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::FreePort"

HRESULT	CRsip::FreePort( const DWORD dwBindid )
{
	HRESULT hr;

	MSG_RSIP_FREE_PORT  FreeReq;
	RSIP_RESPONSE_INFO RespInfo;
	SOCKADDR	RecvSocketAddress;


	Lock();

	DPF( 8, "==>Release Port, Bindid %d\n", dwBindid );

	if(m_sRsip == INVALID_SOCKET){
		DPF(0,"rsipFreePort: m_sRsip is invalid, bailing...\n");
		Unlock();
		return DPNERR_GENERIC;
	}

	RemoveLease( dwBindid );

	FreeReq.version    			= RSIP_VERSION;
	FreeReq.command    			= RSIP_FREE_REQUEST;

	FreeReq.clientid.code 		= RSIP_CLIENTID_CODE;
	FreeReq.clientid.len 		= sizeof(DWORD);
	FreeReq.clientid.clientid 	= m_ClientID;

	FreeReq.bindid.code 		= RSIP_BINDID_CODE;
	FreeReq.bindid.len 			= sizeof(DWORD);
	FreeReq.bindid.bindid 		= dwBindid;

	FreeReq.msgid.code 			= RSIP_MESSAGEID_CODE;
	FreeReq.msgid.len  			= sizeof(DWORD);
	FreeReq.msgid.msgid   		= InterlockedIncrement( &m_MsgID );

	hr=ExchangeAndParse( (PCHAR)&FreeReq,
						 sizeof(FreeReq),
						 &RespInfo,
						 FreeReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );

	Unlock();


	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_FREE_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

exit:
	DPF( 8, "<==Release Port, Succeeded" );
	return hr;

error_exit:
	DPF( 8, "<==Release Port, Failed" );
	return DPNERR_GENERIC;

}

/*=============================================================================

	CRsip::QueryLocalAddress - get the local address of a public address

    Description:

    	Before connecting to anyone we need to see if there is a local
    	alias for its global address.  This is because the gateway will
    	not loopback if we try and connect to the global address, so
    	we need to know the local alias.

    Parameters:

    	BOOL		 ftcp_udp - whether we are querying a UDP or TCP port
    	SOCKADDR     saddrquery - the address to look up
    	SOCKADDR     saddrlocal - local alias if one exists

    Return Values:

		DPN_OK - got a local address.
		other - no mapping exists.

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::QueryLocalAddress"

HRESULT CRsip::QueryLocalAddress( BOOL ftcp_udp, const SOCKADDR *const saddrquery, SOCKADDR *const saddrlocal )
{
	#define saddrquery_in ((const SOCKADDR_IN *)saddrquery)
	#define saddrlocal_in ((SOCKADDR_IN *)saddrlocal)
	HRESULT hr;

	MSG_RSIP_QUERY  QueryReq;
	RSIP_RESPONSE_INFO RespInfo;

	PADDR_ENTRY pAddrEntry;
	SOCKADDR	RecvSocketAddress;


	Lock();

	DPF( 8, "==>RSIP QueryLocalAddress" );
	DumpSocketAddress( 8, saddrquery, saddrquery->sa_family );

	if(m_sRsip == INVALID_SOCKET){
		DPF(0,"rsipQueryLocalAddress: m_sRsip is invalid, bailing...\n");
		Unlock();
		return DPNERR_GENERIC;
	}

	// see if we have a cached entry.

	if(pAddrEntry=FindCacheEntry(ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port)){
		if(pAddrEntry->raddr){
			saddrlocal_in->sin_family      = AF_INET;
			saddrlocal_in->sin_addr.s_addr = pAddrEntry->raddr;
			saddrlocal_in->sin_port        = pAddrEntry->rport;
			Unlock();
			DPF( 8, "<==Found Local address in cache.\n" );
			return DPN_OK;
		} else {
			DPF( 8, "<==Found lack of local address in cache\n" );
			Unlock();
			return DPNERR_GENERIC;
		}
	}		

	// Build the request

	QueryReq.version    		= RSIP_VERSION;
	QueryReq.command    		= RSIP_QUERY_REQUEST;

	QueryReq.clientid.code 		= RSIP_CLIENTID_CODE;
	QueryReq.clientid.len 		= sizeof(DWORD);
	QueryReq.clientid.clientid 	= m_ClientID;

	QueryReq.address.code		= RSIP_ADDRESS_CODE;
	QueryReq.address.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	QueryReq.address.version	= 1; // IPv4
	QueryReq.address.addr		= saddrquery_in->sin_addr.s_addr;

	QueryReq.port.code			= RSIP_PORTS_CODE;
	QueryReq.port.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	QueryReq.port.nports      	= 1;
	QueryReq.port.port			= p_htons(saddrquery_in->sin_port);

	QueryReq.porttype.code      = RSIP_VENDOR_CODE;
	QueryReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	QueryReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	QueryReq.porttype.option    = (ftcp_udp)?RSIP_TCP_PORT:RSIP_UDP_PORT;

	QueryReq.querytype.code	    = RSIP_VENDOR_CODE;
	QueryReq.querytype.len	    = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	QueryReq.querytype.vendorid = RSIP_MS_VENDOR_ID;
	QueryReq.querytype.option   = RSIP_QUERY_MAPPING;

	QueryReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	QueryReq.msgid.len  	    = sizeof(DWORD);
	QueryReq.msgid.msgid   		= InterlockedIncrement( &m_MsgID );

	hr=ExchangeAndParse( (PCHAR)&QueryReq,
						 sizeof(QueryReq),
						 &RespInfo,
						 QueryReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );

	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_QUERY_RESPONSE){
		DPF(0,"Failing query, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	saddrlocal_in->sin_family      = AF_INET;
	saddrlocal_in->sin_addr.s_addr = RespInfo.lAddressV4;
	saddrlocal_in->sin_port        = p_htons(RespInfo.lPort);

	//rsipAddCacheEntry(pgd,ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port,RespInfo.lAddressV4,p_htons(RespInfo.lPort));

	DPF( 8, "<==RSIP QueryLocalAddress, local alias is" );
	DumpSocketAddress( 8, reinterpret_cast<SOCKADDR*>( saddrlocal_in ), saddrlocal_in->sin_family );

exit:
	return hr;

error_exit:
	AddCacheEntry(ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port,0,0);
	DPF( 8, "<==RSIP QueryLocalAddress, NO Local alias\n" );
	return DPNERR_GENERIC;

	#undef saddrlocal_in
	#undef saddrquery_in
}

/*=============================================================================

	CRsip::ListenPort - assign a port mapping with the rsip server with a fixed
					 port.

    Description:

		Only used for the host server port (the one that is used for enums).
		Other than the fixed port this works the same as an rsipAssignPort.

		Since the port is fixed, the local and public port address are
		obviously the same.

    Parameters:

    	WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend
    							lease and/or release the binding (OPTIONAL).
    Return Values:

		DPN_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.

		DPNERR_GENERIC - assignment of a public port could not be made.


-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::ListenPort"

HRESULT CRsip::ListenPort( BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid )
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)

	HRESULT hr;
	SOCKADDR	RecvSocketAddress;

	MSG_RSIP_LISTEN_PORT ListenReq;
	RSIP_RESPONSE_INFO RespInfo;

	Lock();

	DPF( 8, "RSIP Listen Port %d\n", p_htons( port ) );

	if(m_sRsip == INVALID_SOCKET){
		DPF(0,"rsipListenPort: m_sRsip is invalid, bailing...\n");
		Unlock();
		return DPNERR_GENERIC;
	}

	// Build the request

	ListenReq.version    		  = RSIP_VERSION;
	ListenReq.command    		  = RSIP_LISTEN_REQUEST;

	ListenReq.clientid.code 	  = RSIP_CLIENTID_CODE;
	ListenReq.clientid.len 		  = sizeof(DWORD);
	ListenReq.clientid.clientid   = m_ClientID;

	// Local Address (will be returned by RSIP server, us don't care value)

	ListenReq.laddress.code		  = RSIP_ADDRESS_CODE;
	ListenReq.laddress.len		  = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.laddress.version	  = 1; // IPv4
	ListenReq.laddress.addr		  = 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	ListenReq.lport.code		 = RSIP_PORTS_CODE;
	ListenReq.lport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.lport.nports       = 1;
	ListenReq.lport.port		 = p_htons(port);//->little endian for wire

	// Remote Address (not used with our flow control policy, use don't care value)

	ListenReq.raddress.code		 = RSIP_ADDRESS_CODE;
	ListenReq.raddress.len		 = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.raddress.version   = 1; // IPv4
	ListenReq.raddress.addr      = 0; // Don't care

	ListenReq.rport.code		 = RSIP_PORTS_CODE;
	ListenReq.rport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.rport.nports       = 1;
	ListenReq.rport.port		 = 0; // Don't care

	// Following parameters are optional according to RSIP spec...

	// Lease code, ask for an hour, but don't count on it.

	ListenReq.lease.code		 = RSIP_LEASE_CODE;
	ListenReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ListenReq.lease.leasetime    = 3600;

	// Tunnell Type is IP-IP

	ListenReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	ListenReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	ListenReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.

	ListenReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	ListenReq.msgid.len  		 = sizeof(DWORD);
	ListenReq.msgid.msgid   	 = InterlockedIncrement( &m_MsgID );

	// Vendor specific - need to specify port type and no-tunneling

	ListenReq.porttype.code      = RSIP_VENDOR_CODE;
	ListenReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	ListenReq.porttype.option    = (ftcp_udp)?(RSIP_TCP_PORT):(RSIP_UDP_PORT);

	ListenReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	ListenReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.tunneloptions.option   = RSIP_NO_TUNNEL;

	ListenReq.listentype.code     = RSIP_VENDOR_CODE;
	ListenReq.listentype.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.listentype.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.listentype.option   = RSIP_SHARED_UDP_LISTENER;


	hr=ExchangeAndParse( (PCHAR)&ListenReq,
						 sizeof(ListenReq),
						 &RespInfo,
						 ListenReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );
	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_LISTEN_RESPONSE){
		DPF(0,"Assignment failed? Response was %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family      = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port        = p_htons(RespInfo.lPort);// currently little endian on wire

		DPF( 8, "RSIP Listen, public address is" );
		DumpSocketAddress( 8, reinterpret_cast<SOCKADDR*>( psaddr_in ), psaddr_in->sin_family );
	}

	if(pBindid){
		*pBindid = RespInfo.bindid;
	}	

	// remember the lease so we will renew it when necessary.
	AddLease(RespInfo.bindid,ftcp_udp,RespInfo.lAddressV4,p_htons(RespInfo.lPort),port,RespInfo.leasetime);


exit:
	DPF( 8, "<==RSIP Listen succeeded\n" );
	return hr;

error_exit:
	DPF( 8, "<==RSIP Listen failed\n" );
	return DPNERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	CRsip::FindLease - see if we already have a lease for a local port.

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::FindLease"

PRSIP_LEASE_RECORD CRsip::FindLease( BOOL ftcp_udp, WORD port)
{
	PRSIP_LEASE_RECORD pLeaseWalker;

	pLeaseWalker = m_pRsipLeaseRecords;

	while(pLeaseWalker){
		if( ( pLeaseWalker->ftcp_udp == ftcp_udp ) && ( pLeaseWalker->port == port ) )
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	return pLeaseWalker;
}

/*=============================================================================

	CRsip::AddLease - adds a lease record to our list of leases

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::AddLease"

void	CRsip::AddLease( DWORD bindid, BOOL ftcp_udp, DWORD addrV4, WORD rport, WORD port, DWORD tLease)
{
	RSIP_LEASE_RECORD	*pLeaseWalker;
	RSIP_LEASE_RECORD	*pNewLease;
	DWORD	tNow;

	tNow=timeGetTime();

	// First see if we already have a lease for this port;
	Lock();

	// first make sure there isn't already a lease for this port
	pLeaseWalker = m_pRsipLeaseRecords;
	while(pLeaseWalker){
		if(pLeaseWalker->ftcp_udp == ftcp_udp &&
		   pLeaseWalker->port     == port     &&
		   pLeaseWalker->bindid   == bindid
		)
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	if(pLeaseWalker){
		pLeaseWalker->dwRefCount++;
		pLeaseWalker->tExpiry = tNow+(tLease*1000);
	} else {
		pNewLease = static_cast<RSIP_LEASE_RECORD*>( DNMalloc( sizeof( *pNewLease ) ) );
		if(pNewLease){
			pNewLease->dwRefCount = 1;
			pNewLease->ftcp_udp   = ftcp_udp;
			pNewLease->tExpiry    = tNow+(tLease*1000);
			pNewLease->bindid     = bindid;
			pNewLease->port		  = port;
			pNewLease->rport      = rport;
			pNewLease->addrV4     = addrV4;
			pNewLease->pNext	  = m_pRsipLeaseRecords;
			m_pRsipLeaseRecords= pNewLease;
		} else {
			DPF(0,"rsip: Couldn't allocate new lease block for port %x\n",port);
		}
	}

	Unlock();
}

/*=============================================================================

	CRsip::RemoveLease - removes a lease record from our list of leases

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::RemoveLease"

void	CRsip::RemoveLease( DWORD bindid )
{
	PRSIP_LEASE_RECORD pLeaseWalker, pLeasePrev;

	DPF( 7, "==>rsipRemoveLease bindid %d\n", bindid );

	Lock();

	pLeaseWalker = m_pRsipLeaseRecords;
	pLeasePrev=(PRSIP_LEASE_RECORD)&m_pRsipLeaseRecords; //sneaky.

	while(pLeaseWalker){
		if(pLeaseWalker->bindid==bindid){
			--pLeaseWalker->dwRefCount;
			if(!pLeaseWalker->dwRefCount){
				// link over it
				pLeasePrev->pNext=pLeaseWalker->pNext;
				DPF( 7, "rsipRemove: removing bindid %d\n", bindid );
				DNFree(pLeaseWalker);
			} else {
				DPF( 7, "rsipRemove: refcount on bindid %d is %d\n", bindid, pLeaseWalker->dwRefCount );
			}
			break;
		}
		pLeasePrev=pLeaseWalker;
		pLeaseWalker=pLeaseWalker->pNext;
	}

	Unlock();

	DPF( 7, "<==rsipRemoveLease bindid %d\n", bindid );
}

/*=============================================================================

	CRsip::PortExtend - checks if port leases needs extension and extends
					 them if necessary

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::PortExtend"

void	CRsip::PortExtend( const DWORD time )
{
	PRSIP_LEASE_RECORD pLeaseWalker;
	DWORD tExtend;
	HRESULT hr;


	Lock();

	pLeaseWalker = m_pRsipLeaseRecords;
	while(pLeaseWalker){

		if((int)(pLeaseWalker->tExpiry - time) < 180000){
			// less than 2 minutes left on lease.
			hr=ExtendPort(pLeaseWalker->bindid, &tExtend);			
			if(hr != DPN_OK){
				// this binding is now gone!
				DPF(0,"Couldn't renew lease on bindid %d, port %x\n",pLeaseWalker->bindid, pLeaseWalker->port);
			} else {
				pLeaseWalker->tExpiry=time+(tExtend*1000);
				DPF( 8, "rsip: Extended Lease of Port %x by %d seconds\n", pLeaseWalker->bindid, tExtend );
				DNASSERT(tExtend > 180);
			}
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	Unlock();
}


/*=============================================================================

	CRsip::FindCacheEntry

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::FindCacheEntry"

PADDR_ENTRY CRsip::FindCacheEntry( BOOL ftcp_udp, DWORD addr, WORD port)
{
	PADDR_ENTRY pAddrWalker;

	pAddrWalker = m_pAddrEntry;

	while(pAddrWalker){
		if(pAddrWalker->ftcp_udp == ftcp_udp &&
		   pAddrWalker->port     == port     &&
		   pAddrWalker->addr     == addr
		)
		{
			// if he looked it up, give it another minute to time out.
			pAddrWalker->tExpiry=timeGetTime()+60*1000;
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
			DPF( 8, "Returning Cache Entry Addr:Port (%p:%d)  Alias Addr:(Port %p:%d)\n",
				pAddrWalker->addr,
				p_htons(pAddrWalker->port),
				pAddrWalker->raddr,
				p_htons(pAddrWalker->rport));
			break;
		}
		pAddrWalker=pAddrWalker->pNext;
	}

	return pAddrWalker;


}

/*=============================================================================

	CRsip::AddCacheEntry - adds a cache entry or updates timeout on existing one.

    Description:

    	Adds an address mapping from public realm to local realm (or the
    	lack of such a mapping) to the cache of mappings.

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::AddCacheEntry"

void	CRsip::AddCacheEntry( BOOL ftcp_udp, DWORD addr, WORD port, DWORD raddr, WORD rport)
{
	ADDR_ENTRY	*pAddrWalker;
	ADDR_ENTRY	*pNewAddr;
	DWORD		tNow;


	tNow=timeGetTime();

	// First see if we already have a lease for this port;
	Lock();

	// first make sure there isn't already a lease for this port
	pAddrWalker = m_pAddrEntry;
	while(pAddrWalker){
		if(pAddrWalker->ftcp_udp == ftcp_udp &&
		   pAddrWalker->port     == port     &&
		   pAddrWalker->addr     == addr
		)
		{
			break;
		}
		pAddrWalker=pAddrWalker->pNext;
	}

	if(pAddrWalker){
		pAddrWalker->tExpiry = tNow+(60*1000); // keep for 60 seconds or 60 seconds from last reference
	} else {
		pNewAddr = static_cast<ADDR_ENTRY*>( DNMalloc( sizeof( *pNewAddr ) ) );
		if(pNewAddr){
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
			DPF( 8, "Added Cache Entry Addr:Port (%p:%d)  Alias Addr:(Port %p:%d)\n", addr, p_htons( port ), raddr, p_htons( rport ) );
			pNewAddr->ftcp_udp   = ftcp_udp;
			pNewAddr->tExpiry    = tNow+(60*1000);
			pNewAddr->port		 = port;
			pNewAddr->addr		 = addr;
			pNewAddr->rport      = rport;
			pNewAddr->raddr      = raddr;
			pNewAddr->pNext	     = m_pAddrEntry;
			m_pAddrEntry		 = pNewAddr;
		} else {
			DPF(0,"rsip: Couldn't allocate new lease block for port %x\n",port);
		}
	}

	Unlock();
}


/*=============================================================================

	CRsip::CacheClear - checks if cached mappings are old and deletes them.

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::CacheClear"

void CRsip::CacheClear( const DWORD time )
{
	PADDR_ENTRY pAddrWalker, pAddrPrev;


	Lock();

	pAddrWalker = m_pAddrEntry;
	pAddrPrev=(PADDR_ENTRY)&m_pAddrEntry; //sneaky.

	while(pAddrWalker){

		if((int)(pAddrWalker->tExpiry - time) < 0){
			// cache entry expired.
			pAddrPrev->pNext=pAddrWalker->pNext;
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
			DPF( 7, "rsipRemove: removing cached address entry %p\n", pAddrWalker );
			DNFree(pAddrWalker);
		} else {
			pAddrPrev=pAddrWalker;
		}	
		pAddrWalker=pAddrPrev->pNext;
	}

	Unlock();
}

//**********************************************************************
// ------------------------------
// CRsip::RsipTimerComplete - Rsip timer job has completed
//
// Entry:		Timer result code
//				Context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::RsipTimerComplete"

void	CRsip::RsipTimerComplete( const HRESULT hResult, void *const pContext )
{
	CRsip	*pThisRsip;

	
	DNASSERT( pContext != NULL );
	pThisRsip = static_cast<CRsip*>( pContext );

	pThisRsip->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CRsip::RsipTimerFunction - Rsip timer job needs service
//
// Entry:		Context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::RsipTimerFunction"

void	CRsip::RsipTimerFunction( void *const pContext )
{
	CRsip	*pThisRsip;
	DWORD	dwTime;


	DNASSERT( pContext != NULL );
	dwTime = timeGetTime();
	pThisRsip = static_cast<CRsip*>( pContext );
	pThisRsip->PortExtend( dwTime );
	pThisRsip->CacheClear( dwTime );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CRsip::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CRsip::ReturnSelfToPool"

void	CRsip::ReturnSelfToPool( void )
{
	Deinitialize();
	ReturnRsip( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\sendqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SendQueue.cpp
 *  Content:	Queue to manage outgoing sends on socket port
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::CSendQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::CSendQueue"

CSendQueue::CSendQueue():m_pHead( NULL ),m_pTail( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::~CSendQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::~CSendQueue"

CSendQueue::~CSendQueue()
{
	DNASSERT( m_pHead == NULL );
	DNASSERT( m_pTail == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::Initialize - initialize this send queue
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::Initialize"

HRESULT	CSendQueue::Initialize( void )
{
	HRESULT	hr;


	hr = DPN_OK;
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Could not initialize critical section for SendQueue!" );
	}
	else
	{
		DebugSetCriticalSectionRecursionCount( &m_Lock, 1 );
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::FindNextByEndpoint - find next entry in send queue given an endpoint
//
// Entry:		Pointer to handle (initialized to NULL to start scanning)
//				Pointer to endpoint to find
//
// Exit:		Pointer to next item referring to given endpoint
//				NULL = no item found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::FindNextByEndpoint"

CWriteIOData	*CSendQueue::FindNextByEndpoint( HANDLE *const pHandle, const CEndpoint *const pEndpoint )
{
	CWriteIOData	*pReturn;


	DNASSERT( pEndpoint != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );

	//
	// initialize
	//
	pReturn = NULL;
	if ( *pHandle == NULL )
	{
		pReturn = m_pHead;
	}

	//
	// loop until we find something
	//
	while ( pReturn != NULL )
	{
		if ( pReturn->m_pCommand->GetEndpoint() == pEndpoint )
		{
			goto Exit;
		}

		pReturn = pReturn->m_pNext;
	}

Exit:
	*pHandle = pReturn;
	return	pReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\rsip.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Rsip.h
 *  Content:	Realm Specific IP Support header
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  12/7/99		rlamb	Original
 *  12/8/99     aarono  added function prototypes for rsip support in SP
 *  03/16/2000	johnkan	Converted to class for DPlay 8 Winsock
 *
 ***************************************************************************/


#ifndef __RSIP_H__
#define __RSIP_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CThreadPool;
typedef	struct	_RSIP_RESPONSE_INFO		RSIP_RESPONSE_INFO;
typedef struct	_RSIP_LEASE_RECORD		RSIP_LEASE_RECORD;
typedef struct	_ADDR_ENTRY				ADDR_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

class	CRsip
{
	STDNEWDELETE

	public:
		CRsip();
		~CRsip();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		void	AddRef( void ) { DNInterlockedIncrement( &m_iRefCount ); }
		void	DecRef( void )
		{
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		BOOL	Initialize( CThreadPool *const pThreadPool,
							const SOCKADDR *const pBaseSocketAddress,
							const BOOL fIsRsipServer );

		void	Deinitialize( void );

		BOOL	RsipIsRunningOnThisMachine( SOCKADDR *const pPublicSocketAddress );
		
		HRESULT	AssignPort( const BOOL fTCP_UDP,
							const WORD wPort,
							SOCKADDR *const pSocketAddress,
							DWORD *const pdwBindID );	// gets address on RSIP box
		
		HRESULT FreePort( const DWORD dwBindID );		// when port is done
		
		HRESULT QueryLocalAddress( const BOOL fTCP_UDP,
								   const SOCKADDR *const pQueryAddress,
								   SOCKADDR *const pLocalAddress) ;	// called to map remote to local
		
		HRESULT ListenPort( const BOOL fTCP_UDP,
							const WORD wPort,
							SOCKADDR *const pListenAddress,
							DWORD *const pBindID );		// called for ROD

	protected:

	private:
		DNCRITICAL_SECTION		m_Lock;
		volatile	LONG		m_iRefCount;
		volatile	SOCKET  	m_sRsip;
		volatile	BOOL		m_fTimerJobSubmitted;

		SOCKADDR_IN		m_saddrGateway;
		static LONG		m_MsgID;		// NOTE: there is only one instance of this for ALL CRsip objects!!!
		DWORD			m_ClientID;

		RSIP_LEASE_RECORD	*m_pRsipLeaseRecords;	// list of leases.
		ADDR_ENTRY        	*m_pAddrEntry;			// cache of mappings.
		DWORD 		 		m_tuRetry;				// microseconds starting retry time.
		CThreadPool			*m_pThreadPool;			// thread pool
		BOOL				m_fLockInitialized;		// Boolean indicating initialization of lock	

		// Local Functions
		HRESULT	FindGateway( const UINT myip, char *const gwipaddr);
		HRESULT	Register( void );
		HRESULT	Deregister( void );
		
		HRESULT	ExchangeAndParse( PCHAR pRequest,
								  const UINT cbReq,
								  RSIP_RESPONSE_INFO *const pRespInfo,
								  const DWORD messageid,
								  const BOOL bConnect,
								  SOCKADDR *const pRecvSocketAddress );
		
		HRESULT	Parse( CHAR *pBuf, DWORD cbBuf, RSIP_RESPONSE_INFO *const pRespInfo );
		HRESULT ExtendPort( const DWORD Bindid, DWORD *const ptExtend );
		void	RemoveLease( const DWORD dwBindID );
		void	AddLease( const DWORD dwBindID, const BOOL fTCP_UDP, const DWORD addrV4, const WORD lport, const WORD port, const DWORD tLease);
		RSIP_LEASE_RECORD	*FindLease( const BOOL fTCP_UDP, const WORD port );
		void	AddCacheEntry( const BOOL fTCP_UDP, const DWORD addr, const WORD port, const DWORD raddr, const WORD rport);
		ADDR_ENTRY	*FindCacheEntry( const BOOL fTCP_UDP, const DWORD addr, const WORD port);
		
		
		static void		RsipTimerComplete( const HRESULT hCompletionCode, void *const pContext );	
		static void		RsipTimerFunction( void *const pContext );
		void 	PortExtend( const DWORD dwTime );		// every 2 minutes
		void 	CacheClear( const DWORD dwTime );		// every 2 minutes
		
		void	ReturnSelfToPool( void );

		// prevent unwarranted copies
		CRsip( const CRsip & );
		CRsip& operator=( const CRsip & );

};

#endif /* __RSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\spaddress.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPAddress.cpp
 *  Content:	Winsock address base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\spdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.cpp
 *  Content:	Global variables for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Dereived from Locals.cpp
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "wsockspi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

// default number of command descriptors to create
#define	DEFAULT_COMMAND_POOL_SIZE	20
#define	COMMAND_POOL_GROW_SIZE		5

#define	PORT_STRING_LENGTH	20
//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSPData::CSPData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::CSPData"

CSPData::CSPData():
	m_lRefCount( 0 ),
	m_lObjectRefCount( 0 ),
	m_hShutdownEvent( NULL ),
	m_SPState( SPSTATE_UNINITIALIZED ),
	m_fIsRsipServer( FALSE ),
	m_pBroadcastAddress( NULL ),
	m_pListenAddress( NULL ),
	m_pGenericAddress( NULL ),
	m_pThreadPool( NULL ),
	m_fHandleTableInitialized( FALSE ),
	m_fLockInitialized( FALSE ),
	m_fSocketPortDataLockInitialized( FALSE ),
	m_fSocketPortListInitialized( FALSE ),
	m_fInterfaceGlobalsInitialized( FALSE ),
	m_fDefaultAddressesBuilt( FALSE )
{
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );
	DNInterlockedIncrement( &g_lOutstandingInterfaceCount );
	m_ActiveAdapterList.Initialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::~CSPData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::~CSPData"

CSPData::~CSPData()
{
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( m_hShutdownEvent == NULL );
	DNASSERT( m_SPState == SPSTATE_UNINITIALIZED );
	DNASSERT( m_fIsRsipServer == FALSE );
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_ActiveSocketPortList.IsEmpty() != FALSE );
	DNASSERT( m_fHandleTableInitialized == FALSE );
	DNASSERT( m_fLockInitialized == FALSE );
	DNASSERT( m_fSocketPortDataLockInitialized == FALSE );
	DNASSERT( m_fSocketPortListInitialized == FALSE );
	DNASSERT( m_fInterfaceGlobalsInitialized == FALSE );
	DNASSERT( m_fDefaultAddressesBuilt == FALSE );
	DNASSERT( m_ActiveAdapterList.IsEmpty() );
	DNInterlockedDecrement( &g_lOutstandingInterfaceCount );
	memset( &m_PublicSocketAddress, 0x00, sizeof( m_PublicSocketAddress ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Initialize - intialize
//
// Entry:		Class ID
//				SP type
//				Pointer to SP COM vtable
//
// Exit:		Error code
//
// Note:	This function assumes that someone else preventing reentry!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Initialize"

HRESULT	CSPData::Initialize( const CLSID *const pClassID,
							 IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT			hr;


	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( m_lRefCount == 1 );
	DNASSERT( m_lObjectRefCount == 0 );

	DNASSERT( m_COMInterface.m_pCOMVtbl == NULL );
	m_COMInterface.m_pCOMVtbl = pVtbl;

	//
	// attempt to initialize shutdown event
	//
	DNASSERT( m_hShutdownEvent == NULL );
	m_hShutdownEvent = CreateEvent( NULL,		// pointer to security (none)
									TRUE,		// manual reset
									TRUE,		// start signalled (so close can be called without any endpoints being created)
									NULL		// pointer to name (none)
									);
	if ( m_hShutdownEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to create event for shutting down spdata!" );
		DisplayErrorCode( 0, dwError );
	}

	//
	// attempt to check for Rsip
	//
// BUGBUG: [mgere] [xbox] Removed RSIP
/*
	DNASSERT( m_fIsRsipServer == FALSE );
		CRsip	*pRsip;
		
	
		pRsip = CreateRsip();
		if ( pRsip != NULL )
		{
			m_fIsRsipServer = pRsip->RsipIsRunningOnThisMachine( &m_PublicSocketAddress );		
			pRsip->DecRef();
			pRsip = NULL;
		}
*/	
	
	DNASSERT( m_fLockInitialized == FALSE );
	DNASSERT( m_fSocketPortDataLockInitialized == FALSE );
	DNASSERT( m_fSocketPortListInitialized == FALSE );
	DNASSERT( m_fInterfaceGlobalsInitialized == FALSE );
	DNASSERT( m_fDefaultAddressesBuilt == FALSE );

	hr = m_HandleTables.Initialize();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to initialize handle table!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fHandleTableInitialized = TRUE;
	
	//
	// initialize internal critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Problem initializing main critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	m_fLockInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_SocketPortDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Problem initializing SocketPortDataLock critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_SocketPortDataLock, 0 );
	m_fSocketPortDataLockInitialized = TRUE;

	//
	// initialize hash table for socket ports with 64 etries and a multiplier of 32
	//
	if ( m_ActiveSocketPortList.Initialize( 6, 5 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Could not initialize socket port list!" );
		goto Failure;
	}
	m_fSocketPortListInitialized = TRUE;

	//
	// get a thread pool
	//
	DNASSERT( m_pThreadPool == NULL );
	hr = InitializeInterfaceGlobals( this );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to create thread pool!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fInterfaceGlobalsInitialized = TRUE;

	//
	// build default addresses
	//
	hr = BuildDefaultAddresses();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem building default addresses!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fDefaultAddressesBuilt = TRUE;

Exit:
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with CSPData::Initialize" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Shutdown - shut down this set of SP data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Shutdown"

void	CSPData::Shutdown( void )
{
	BOOL	fLooping;


	//
	// Unbind this interface from the globals.  This will cause a closure of all
	// of the I/O which will release endpoints, socket ports and then this data.
	//
	if ( m_fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_fInterfaceGlobalsInitialized = FALSE;
	}

	SetState( SPSTATE_CLOSING );
	
	DNASSERT( m_hShutdownEvent != NULL );
	
	fLooping = TRUE;
	while ( fLooping != FALSE )
	{
		switch ( WaitForSingleObjectEx( m_hShutdownEvent, INFINITE, TRUE ) )
		{
			case WAIT_OBJECT_0:
			{
				fLooping = FALSE;
				break;
			}

			case WAIT_IO_COMPLETION:
			{
				break;
			}

			default:
			{
				INT3;
				break;
			}
		}
	}

	if ( CloseHandle( m_hShutdownEvent ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to close shutdown event!" );
		DisplayErrorCode( 0, dwError );
	}
	m_hShutdownEvent = NULL;

	if ( DP8SPCallbackInterface() != NULL)
	{
		IDP8SPCallback_Release( DP8SPCallbackInterface() );
		memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	This function assumes that someone else is preventing reentry.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Deinitialize"

void	CSPData::Deinitialize( void )
{
	CBilink	*pTempBilink;


	DPF( 9, "Entering CSPData::Deinitialize" );

	//
	// return any outstanding adatper entries
	//
	pTempBilink = m_ActiveAdapterList.GetNext();
	while ( pTempBilink != &m_ActiveAdapterList )
	{
		CAdapterEntry	*pAdapterEntry;


		pAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pTempBilink );
		pTempBilink = pTempBilink->GetNext();
		
		pAdapterEntry->RemoveFromAdapterList();
		pAdapterEntry->DecRef();
	}

	if ( m_fDefaultAddressesBuilt != FALSE )
	{
		FreeDefaultAddresses();
		m_fDefaultAddressesBuilt = FALSE;
	}

	//
	// release our reference to the global SP objects
	//
	if ( m_fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_fInterfaceGlobalsInitialized = FALSE;
	}

	//
	// clean up lists and pools
	//
	if ( m_fSocketPortListInitialized != FALSE )
	{
		if ( m_ActiveSocketPortList.IsEmpty() == FALSE )
		{
			CSocketPort				*pSocketPort;

			DPF( 1, "Attempt to close interface with active connections!" );

			//
			// All of the threads have stopped so we can force close the socket ports
			// by cancelling all IO requests and unbinding all endpoints.
			//
			while ( m_ActiveSocketPortList.RemoveLastEntry( &pSocketPort ) != FALSE )
			{
				DNASSERT( pSocketPort != NULL );

				//
				// disconnect all endpoints
				//
				pSocketPort->DisconnectAllEndpoints();
			}
		}
		
		m_ActiveSocketPortList.Deinitialize();
		m_fSocketPortListInitialized = FALSE;
	}

	if ( m_fSocketPortDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_SocketPortDataLock );
		m_fSocketPortDataLockInitialized = FALSE;
	}

	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	if ( m_fHandleTableInitialized != FALSE )
	{
		m_HandleTables.Deinitialize();
		m_fHandleTableInitialized = FALSE;
	}

	SetState( SPSTATE_UNINITIALIZED );
	m_fIsRsipServer = FALSE;
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );
	
	DPF( 9, "Leaving CSPData::Deinitialize" );

	if ( GetThreadPool() != NULL )
	{
		GetThreadPool()->DecRef();
		SetThreadPool( NULL );
	}

	if ( m_hShutdownEvent != NULL )
	{
		if ( CloseHandle( m_hShutdownEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Failed to close shutdown handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hShutdownEvent = NULL;
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::SetCallbackData - set data for SP callbacks to application
//
// Entry:		Pointer to initialization data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::SetCallbackData"

void	CSPData::SetCallbackData( const SPINITIALIZEDATA *const pInitData )
{
	DNASSERT( pInitData != NULL );

	DNASSERT( pInitData->dwFlags == 0 );
	m_InitData.dwFlags = pInitData->dwFlags;

	DNASSERT( pInitData->pIDP != NULL );
	m_InitData.pIDP = pInitData->pIDP;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::BindEndpoint - unbind an endpoint to a socket port
//
// Entry:		Pointer to endpoint
//				Pointer to IDirectPlay8Address for socket port
//				Pointer to CSocketAddress for socket port
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::BindEndpoint"

HRESULT	CSPData::BindEndpoint( CEndpoint *const pEndpoint,
							   IDirectPlay8Address *const pDeviceAddress,
							   const CSocketAddress *const pSocketAddress,
							   const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT			hr;
	CSocketAddress	*pDeviceSocketAddress;
	CSocketPort		*pSocketPort;
	BOOL			fSocketCreated;
	BOOL			fExtraEndpointReferenceAdded;
	BOOL			fSocketPortDataLocked;
	BOOL			fAdapterEntryCreated;
	BOOL			fSocketPortInActiveList;
	BOOL			fBindReferenceAdded;
	CBilink			*pAdapterBilink;
	CAdapterEntry	*pAdapterEntry;


	DNASSERT( pEndpoint != NULL );
	DNASSERT( ( pDeviceAddress != NULL ) || ( pSocketAddress != NULL ) );

	//
	// initialize
	//
	hr = DPN_OK;
	pDeviceSocketAddress = NULL;	
	pSocketPort = NULL;
	fSocketCreated = FALSE;
	fExtraEndpointReferenceAdded = FALSE;
	fSocketPortDataLocked = FALSE;
	fAdapterEntryCreated = FALSE;
	fSocketPortInActiveList = FALSE;
	fBindReferenceAdded = FALSE;
	pAdapterEntry = NULL;
	
	//
	// create and initialize a device address to be used for this socket port
	//
	pDeviceSocketAddress = GetNewAddress();
	if ( pDeviceSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to allocate address for new socket port!" );
		goto Failure;
	}

	//
	// Initialize the socket address with the provided base addresses.  If there
	// is a public address, override the base address.
	//
	if ( pDeviceAddress != NULL )
	{
		DNASSERT( pSocketAddress == NULL );
		hr = pDeviceSocketAddress->SocketAddressFromDP8Address( pDeviceAddress, SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
		if ( hr != DPN_OK )
		{
			DPF( 0, "Failed to parse device address!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
	else
	{
		DNASSERT( pSocketAddress != NULL );
		pDeviceSocketAddress->CopyAddressSettings( *pSocketAddress );
	}

	LockSocketPortData();
	fSocketPortDataLocked = TRUE;	

	//
	// Find the base adapter entry for this network address.  If none is found,
	// create a new one.  If a new one cannot be created, fail.
	//
	pAdapterBilink = m_ActiveAdapterList.GetNext();
	while ( pAdapterBilink != &m_ActiveAdapterList )
	{
		CAdapterEntry	*pTempAdapterEntry;
	
		
		pTempAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pAdapterBilink );
		if ( pDeviceSocketAddress->CompareToBaseAddress( pTempAdapterEntry->BaseAddress() ) == 0 )
		{
			DNASSERT( pAdapterEntry == NULL );
			pAdapterEntry = pTempAdapterEntry;
		}
	
		pAdapterBilink = pAdapterBilink->GetNext();
	}

	if ( pAdapterEntry == NULL )
	{
		pAdapterEntry = CreateAdapterEntry();
		if ( pAdapterEntry == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPF( 0, "Failed to create a new adapter entry!" );
			goto Failure;
		}
		fAdapterEntryCreated = TRUE;
	
		pAdapterEntry->SetBaseAddress( pDeviceSocketAddress->GetAddress() );
		pAdapterEntry->AddToAdapterList( &m_ActiveAdapterList );
	}

	//
	// Start Rsip on IP interface if this is the first time this adapter is
	// being referenced.  If Rsip doesn't start it's not a major failure.
	//
//BUGBUG: [mgere] [xbox] Remove RSIP support.
/*
	if ( fAdapterEntryCreated != FALSE )
	{
		HRESULT	hTempResult;


		hTempResult = pAdapterEntry->StartRsip( pDeviceSocketAddress->GetAddress(), GetThreadPool(), IsRsipServer() );
		if ( hTempResult != DPN_OK )
		{
			DPF( 0, "Failed to start Rsip on adapter entry!" );
			DisplayDNError( 0, hTempResult );
		}
	}
*/

	//
	// if no port is specified, check the list of active adapters for a matching
	// base address and reuse that CSocketPort.
	//
	if ( pDeviceSocketAddress->GetPort() == ANY_PORT )
	{
		if ( pAdapterEntry->SocketPortList()->IsEmpty() == FALSE )
		{
			pSocketPort = CSocketPort::SocketPortFromBilink( pAdapterEntry->SocketPortList()->GetNext() );
			DNASSERT( pSocketPort != NULL );
		}
	}

	//
	// If a socket port has not been found, attempt to look it up by network
	// address.  If that fails, attempt to create a new socket port.
	//
	if ( pSocketPort == NULL )
	{
		if ( m_ActiveSocketPortList.Find( pDeviceSocketAddress, &pSocketPort ) == FALSE )
		{
			CSocketPort	*pDuplicateSocket;


			//
			// No socket port found.  Create a new one, initialize it and attempt
			// to add it to the list (may result in a duplicate).  Whatever happens
			// there will be a socket port to bind the endpoint to.  Save the
			// reference on the CSocketPort from the call to 'Create' until the
            // socket port is removed from the active list.
			//

			UnlockSocketPortData();
			fSocketPortDataLocked = FALSE;

            pDuplicateSocket = NULL;

    	    DNASSERT( pSocketPort == NULL );
    	    pSocketPort = CreateSocketPort();
    	    if ( pSocketPort == NULL )
    	    {
    	    	hr = DPNERR_OUTOFMEMORY;
    	    	DPF( 0, "Failed to create new socket port!" );
    	    	goto Failure;
    	    }
    	    fSocketCreated = TRUE;

			//
			// Everything up to this point has been working with the expected
			// network address for this socket.  If this is the Rsip host, the
			// network socket needs to be bound to 'all adapters', not the
			// expected address (which is currently the public adapter address).
			//
			if ( GetPublicSocketAddress() != NULL )
			{
				pDeviceSocketAddress->InitializeWithAnyAddress();
			}

    	    hr = pSocketPort->Initialize( this, pDeviceSocketAddress );
    	    if ( hr != DPN_OK )
    	    {
    	    	DPF( 0, "Failed to initialize new socket port!" );
    	    	DisplayDNError( 0, hr );
    	    }
    	    pDeviceSocketAddress = NULL;

			pSocketPort->SetAdapterEntry( pAdapterEntry );
    	
			hr = pSocketPort->BindToNetwork( GatewayBindType );
    	    if ( hr != DPN_OK )
    	    {
				pSocketPort->SetAdapterEntry( NULL );

    	    	DPF( 0, "Failed to bind new socket port to network!" );
    	    	DisplayDNError( 0, hr );
    	    	goto Failure;
    	    }
    	    pSocketPort->EndpointAddRef();
    	    fExtraEndpointReferenceAdded = TRUE;

    	    LockSocketPortData();
			fSocketPortDataLocked = TRUE;
			
			//
			// The only way to get here is to have the socket bound to the
			// network.  The socket can't be bound twice, if there was a
			// race to bind the socket, Winsock would have decided which
			// thread lost and failed 'BindToNetwork'.
			//
			DNASSERT( m_ActiveSocketPortList.Find( pSocketPort->GetNetworkAddress(), &pDuplicateSocket ) == FALSE );
   	    	if ( m_ActiveSocketPortList.Insert( pSocketPort->GetNetworkAddress(), pSocketPort ) == FALSE )
   	    	{
                   hr = DPNERR_OUTOFMEMORY;
   	    		DPF( 0, "Could not add new socket port to list!" );
   	    		goto Failure;
   	    	}

			pSocketPort->AddToActiveList( pAdapterEntry->SocketPortList() );
			fSocketPortInActiveList = TRUE;
		}
	}
	
	//
	// bind the endpoint to whatever socketport we have
	//
	DNASSERT( pSocketPort != NULL );
	pSocketPort->EndpointAddRef();
	fBindReferenceAdded = TRUE;

	switch ( pEndpoint->GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_ENUM:
		{
			pSocketPort->MungeAddressWithPAST( pEndpoint->GetWritableRemoteAddressPointer() );
			break;
		}

		default:
		{
			break;
		}
	}
	
	hr = pSocketPort->BindEndpoint( pEndpoint );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	
Exit:
	if ( fExtraEndpointReferenceAdded != FALSE )
	{
		DNASSERT( pSocketPort != NULL );
		pSocketPort->EndpointDecRef();
		fExtraEndpointReferenceAdded = FALSE;
	}

	if ( fSocketPortDataLocked != FALSE )
	{
		UnlockSocketPortData();
		fSocketPortDataLocked = FALSE;
	}
	
	if ( pDeviceSocketAddress != NULL )
	{
		ReturnAddress( pDeviceSocketAddress );
		pDeviceSocketAddress = NULL;
	}
	
	return	hr;

Failure:
	//
	// If we're failing and cleanup will require removal of some resources.
	// This requires the socket port data lock.
	//
	if ( fSocketPortDataLocked == FALSE )
	{
		LockSocketPortData();
		fSocketPortDataLocked = TRUE;
	}

	if ( fSocketPortInActiveList != FALSE )
	{
		pSocketPort->RemoveFromActiveList();
		fSocketPortInActiveList = FALSE;
	}

	if ( pSocketPort != NULL )
	{
		if ( fBindReferenceAdded != FALSE )
		{
			pSocketPort->EndpointDecRef();
			fBindReferenceAdded = FALSE;
		}

		if ( fExtraEndpointReferenceAdded != FALSE )
		{
			pSocketPort->EndpointDecRef();
			fExtraEndpointReferenceAdded = FALSE;
		}
	
		if ( fSocketCreated != FALSE )
		{
			pSocketPort->DecRef();
			fSocketCreated = FALSE;
			pSocketPort = NULL;
		}
	}

	if ( fAdapterEntryCreated != FALSE )
	{
		if ( pAdapterEntry->SocketPortList()->IsEmpty() != FALSE )
		{
			pAdapterEntry->RemoveFromAdapterList();
		}
		
		pAdapterEntry->DecRef();
		pAdapterEntry = NULL;
		fAdapterEntryCreated = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::UnbindEndpoint - unbind an endpoint from a socket port
//
// Entry:		Pointer to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::UnbindEndpoint"

void	CSPData::UnbindEndpoint( CEndpoint *const pEndpoint )
{
	CSocketPort	*pSocketPort;
	BOOL		fCleanUpSocketPort;


	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	pSocketPort = pEndpoint->GetSocketPort();
	fCleanUpSocketPort = FALSE;

	LockSocketPortData();
	
	pSocketPort->UnbindEndpoint( pEndpoint );
	if ( pSocketPort->EndpointDecRef() == 0 )
	{
		m_ActiveSocketPortList.Remove( pSocketPort->GetNetworkAddress() );
		fCleanUpSocketPort = TRUE;
		pSocketPort->RemoveFromActiveList();
		pSocketPort->SetAdapterEntry( NULL );
	}

	UnlockSocketPortData();

	if ( fCleanUpSocketPort != FALSE )
	{
		pSocketPort->DecRef();
		fCleanUpSocketPort = FALSE;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetNewEndpoint - get a new endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to new endpoint
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetNewEndpoint"

CEndpoint	*CSPData::GetNewEndpoint( void )
{
	HRESULT		hTempResult;
	CEndpoint	*pEndpoint;
	HANDLE		hEndpoint;
	ENDPOINT_POOL_CONTEXT	PoolContext;

	
	//
	// initialize
	//
	pEndpoint = NULL;
	hEndpoint = INVALID_HANDLE_VALUE;
	memset( &PoolContext, 0x00, sizeof( PoolContext ) );

	PoolContext.pSPData = this;
			pEndpoint = CreateIPEndpoint( &PoolContext );
	
	if ( pEndpoint == NULL )
	{
		DPF( 0, "Failed to create endpoint!" );
		goto Failure;
	}
	
	m_HandleTables.Lock();
	hTempResult = m_HandleTables.CreateHandle( &hEndpoint, pEndpoint );
	m_HandleTables.Unlock();
	
	if ( hTempResult != DPN_OK )
	{
		DNASSERT( hEndpoint == INVALID_HANDLE_VALUE );
		DPF( 0, "Failed to create endpoint handle!" );
		DisplayDNError( 0, hTempResult );
		goto Failure;
	}

	pEndpoint->SetHandle( hEndpoint );
	pEndpoint->AddCommandRef();
	pEndpoint->DecRef();

Exit:
	return	pEndpoint;

Failure:
	if ( hEndpoint != INVALID_HANDLE_VALUE )
	{
		m_HandleTables.Lock();
		m_HandleTables.InvalidateHandle( hEndpoint );
		m_HandleTables.Unlock();
	
		hEndpoint = INVALID_HANDLE_VALUE;
	}

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::EndpointFromHandle - get endpoint from handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::EndpointFromHandle"

CEndpoint	*CSPData::EndpointFromHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;


	pEndpoint = NULL;
	m_HandleTables.Lock();
	
	pEndpoint = static_cast<CEndpoint*>( m_HandleTables.GetAssociatedData( hEndpoint ) );
	if ( pEndpoint != NULL )
	{
		pEndpoint->AddCommandRef();
	}
	
	m_HandleTables.Unlock();

	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::CloseEndpointHandle - close endpoint handle
//
// Entry:		Poiner to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::CloseEndpointHandle"

void	CSPData::CloseEndpointHandle( CEndpoint *const pEndpoint )
{
	HANDLE	Handle;
	BOOL	fCloseReturn;


	DNASSERT( pEndpoint != NULL );
	Handle = pEndpoint->GetHandle();
	
	m_HandleTables.Lock();
	fCloseReturn = m_HandleTables.InvalidateHandle( Handle );
	m_HandleTables.Unlock();

	if ( fCloseReturn != FALSE )
	{
		pEndpoint->DecCommandRef();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetEndpointAndCloseHandle - get endpoint from handle and close the
//		handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint (it needs a call to 'DecCommandRef' when done)
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetEndpointAndCloseHandle"

CEndpoint	*CSPData::GetEndpointAndCloseHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;
	BOOL	fCloseReturn;


	//
	// initialize
	//
	pEndpoint = NULL;
	fCloseReturn = FALSE;
	m_HandleTables.Lock();
	
	pEndpoint = static_cast<CEndpoint*>( m_HandleTables.GetAssociatedData( hEndpoint ) );
	if ( pEndpoint != NULL )
	{
		pEndpoint->AddRef();
		pEndpoint->AddCommandRef();
		fCloseReturn = m_HandleTables.InvalidateHandle( hEndpoint );
		DNASSERT( fCloseReturn != FALSE );
	}
	
	m_HandleTables.Unlock();

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
	}
	
	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::SetBufferSizeOnAllSockets - set buffer size on all sockets
//
// Entry:		New buffer size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::SetWinsockBufferSizeOnAllSockets"
void	CSPData::SetWinsockBufferSizeOnAllSockets( const INT iBufferSize )
{
	CBilink		*pAdapterEntryLink;

	
	LockSocketPortData();
	
	pAdapterEntryLink = m_ActiveAdapterList.GetNext();
	while ( pAdapterEntryLink != &m_ActiveAdapterList )
	{
		CAdapterEntry	*pAdapterEntry;
		CBilink			*pSocketPortList;


		pAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pAdapterEntryLink );
		pSocketPortList = pAdapterEntry->SocketPortList()->GetNext();
		while ( pSocketPortList != pAdapterEntry->SocketPortList() )
		{
			CSocketPort	*pSocketPort;


			pSocketPort = CSocketPort::SocketPortFromBilink( pSocketPortList );
			pSocketPort->SetWinsockBufferSize( iBufferSize );

			pSocketPortList = pSocketPortList->GetNext();
		}

		pAdapterEntryLink = pAdapterEntryLink->GetNext();
	}
	
	UnlockSocketPortData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::BuildDefaultAddresses - construct default addresses
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	This function is initializing with default values that should always
//			work.  If this function asserts, fix it!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::BuildDefaultAddresses"

HRESULT	CSPData::BuildDefaultAddresses( void )
{
	HRESULT			hr;
	CSocketAddress	*pSPAddress;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// create appropriate address
	//
	pSPAddress = GetNewAddress();
	if ( pSPAddress == NULL )
	{
		DPF( 0, "Failed to get address when building default addresses!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// query for broadcast address
	//
	DNASSERT( m_pBroadcastAddress == NULL );
	m_pBroadcastAddress = pSPAddress->CreateBroadcastAddress();
	if ( m_pBroadcastAddress == NULL )
	{
		DPF( 0, "Failed to create template for broadcast address." );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// query for listen address
	//
	DNASSERT( m_pListenAddress == NULL );
	m_pListenAddress = pSPAddress->CreateListenAddress();
	if ( m_pListenAddress == NULL )
	{
		DPF( 0, "Failed to create template for listen address." );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// query for generic address
	//
	DNASSERT( m_pGenericAddress == NULL );
	m_pGenericAddress = pSPAddress->CreateGenericAddress();
	if ( m_pGenericAddress == NULL )
	{
		DPF( 0, "Failed to create template for generic address." );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

Exit:
	if ( pSPAddress != NULL )
	{
		ReturnAddress( pSPAddress );
		pSPAddress = NULL;
	}

	return	hr;

Failure:
	if ( m_pGenericAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pGenericAddress );
		m_pGenericAddress = NULL;
	}

	if ( m_pListenAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pListenAddress );
		m_pListenAddress = NULL;
	}

	if ( m_pBroadcastAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pBroadcastAddress );
		m_pBroadcastAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::FreeDefaultAddresses - free default addresses
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::FreeDefaultAddresses"

void	CSPData::FreeDefaultAddresses( void )
{
	if ( m_pBroadcastAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pBroadcastAddress );
		m_pBroadcastAddress = NULL;
	}

	if ( m_pListenAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pListenAddress );
		m_pListenAddress = NULL;
	}

	if ( m_pGenericAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pGenericAddress );
		m_pGenericAddress = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::DestroyThisObject - destroy this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::DestroyThisObject"
void	CSPData::DestroyThisObject( void )
{
	Deinitialize();
	delete	this;		// maybe a little too extreme......
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetNewAddress - get a new address
//
// Entry:		Nothing
//
// Exit:		Pointer to new address
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetNewAddress"

CSocketAddress	*CSPData::GetNewAddress( void )
{
	return CreateIPAddress();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::ReturnAddress - return address to list
//
// Entry:		Poiner to address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::ReturnAddress"

void	CSPData::ReturnAddress( CSocketAddress *const pAddress )
{
	DNASSERT( pAddress != NULL );

	pAddress->Reset();

			ReturnIPAddress( static_cast<CIPAddress*>( pAddress ) );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\spaddress.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPAddress.h
 *  Content:	Winsock address base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/11/1999	jtk		Split out to make a base class
 *  01/10/2000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SP_ADDRESS_H__
#define __SP_ADDRESS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values for noting which components have been initialized
//
typedef enum
{
	SPADDRESS_PARSE_KEY_DEVICE = 0,
	SPADDRESS_PARSE_KEY_HOSTNAME,
	SPADDRESS_PARSE_KEY_PORT,

	// this must be the last item
	SPADDRESS_PARSE_KEY_MAX
} SPADDRESS_PARSE_KEY_INDEX;

//
// these are only for the debug build, but make sure they don't match
// any legal values, anyway
//
#define	INVALID_SOCKET_FAMILY		0
#define	INVALID_SOCKET_PROTOCOL		5000

//
// types of addresses
//
typedef	enum
{
	SP_ADDRESS_TYPE_UNKNOWN = 0,				// unknown
	SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,		// address is for local device and dynamically bind to a port
	SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET,	// address is for a proxied enum, map IP 'all-adapters' to 'loopback'
	SP_ADDRESS_TYPE_HOST,						// address is for a remote host (default port always used if none specified)
	SP_ADDRESS_TYPE_READ_HOST,					// address is for a remote host address from a socket read
	SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS			// public address for this host
} SP_ADDRESS_TYPE;

//
// initialization states of address components
//
typedef	enum
{
	SP_ADDRESS_COMPONENT_UNINITIALIZED = 0,
	SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED,
	SP_ADDRESS_COMPONENT_INITIALIZED
} SP_ADDRESS_COMPONENT_STATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// data encapsulating a multicast address
//
typedef	struct
{
	GUID	MulticastAddressGuid;		// address used for multicasting
} MULTICAST_DATA;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// This class assumes that the size of a SOCKADDR is constant, and equal to
// the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
// This is a virtual base class, you cannot instantiate one of these!
//
class	CSocketAddress
{
	STDNEWDELETE

	public:
		//
		// We need a virtual destructor to guarantee we call destructors in the bass classes.
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::CSocketAddress"
		CSocketAddress():m_AddressType( SP_ADDRESS_TYPE_UNKNOWN )
		{
			//
			// if the following ASSERT breaks down, revisit this class and all of its derived
			// classes to make sure they still work!!!
			//
			DBG_CASSERT( ( sizeof( m_SocketAddress ) == sizeof( m_SocketAddress.SocketAddress ) ) &&
						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
			
			memset( &m_ComponentInitializationState, 0x00, sizeof( m_ComponentInitializationState ) );
			memset( &m_SocketAddress, 0x00, sizeof( m_SocketAddress ) );
			m_SocketAddress.SocketAddress.sa_family = INVALID_SOCKET_FAMILY;
		}
		virtual	~CSocketAddress(){};

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::SetAddressType"
		void	SetAddressType( const SP_ADDRESS_TYPE AddressType )
		{
			DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_DEVICE ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
			m_AddressType = AddressType;

			if ( ( AddressType == SP_ADDRESS_TYPE_READ_HOST ) || ( AddressType == SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS ) )
			{
				DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
				m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] = SP_ADDRESS_COMPONENT_INITIALIZED;
				DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_PORT ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
				m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_PORT ] = SP_ADDRESS_COMPONENT_INITIALIZED;
			}
		}
		const SOCKADDR *GetAddress( void ) const { return	&m_SocketAddress.SocketAddress; }

		virtual	void	InitializeWithBroadcastAddress( void ) = 0;
		virtual	void	InitializeWithAnyAddress( void ) = 0;
		virtual	void	SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize ) = 0;
		SOCKADDR	*GetWritableAddress( void ) { return &m_SocketAddress.SocketAddress; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetAddressSize"
		const INT	GetAddressSize( void ) const
		{
			DNASSERT( m_iSocketAddressSize != 0 );
			return	m_iSocketAddressSize;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::Reset"
		void	Reset( void )
		{
			//
			// don't clear the family, protocol, or socket address size because they're only
			// set once, in the constructor!!
			//
			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
			memset( &m_SocketAddress.SocketAddress.sa_data, 0x00, sizeof( m_SocketAddress.SocketAddress.sa_data ) );
			memset( &m_ComponentInitializationState, 0x00, sizeof( m_ComponentInitializationState ) );
		};

		//
		// address manipulations
		//
		virtual	HRESULT	SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address, const SP_ADDRESS_TYPE AddressType ) = 0;
		virtual	IDirectPlay8Address *DP8AddressFromSocketAddress( void ) const = 0;
		virtual	INT_PTR	CompareFunction( const CSocketAddress *const pOtherAddress ) const = 0;
		virtual	INT_PTR	HashFunction( const INT_PTR iHashBitCount ) const = 0;
		virtual INT_PTR	CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const = 0;

		//
		// multicast group managment
		// NOTE: Since there is nothing that needs to be done to delete a multicast group at this
		//		time (unsupported on IPX, and you can't delete them on IP), I've left off the
		//		AdapterGuid paramter out of DeleteMulticastGroup().  This simplifies the code.
		//		If another protocol is added it may be necessary to actually pass an AdpaterGuid.
		//
		virtual	HRESULT	CreateMulticastGroup( const GUID &AdapterGuid,								// GUID of adapter to use
											  const CSocketAddress *const pMulticastGroupAddress,	// pointer to multicast group address
											  void *const pGroupData,								// pointer to group data
											  DWORD *const pdwGroupDataSize							// size of group data
											  ) const = 0;

		virtual HRESULT	DeleteMulticastGroup( const GUID &AdapterGuid,			// GUID of adapter to use
											  const void *const pGroupData,		// pointer to group data
											  const DWORD dwGroupDataSize		// size of group data
											  ) const = 0;

		virtual	HRESULT	AddToMulticastGroup( const void *const pGroupData,			// pointer to group data
											 const DWORD dwGroupDataSize,			// group data size
											 const SOCKET &Socket					// socket to use
											 ) const = 0;

		virtual	HRESULT	RemoveFromMulticastGroup( const void *const pGroupData,			// pointer to group data
												  const DWORD dwGroupDataSize,			// group data size
												  const SOCKET &Socket					// socket to use
												  ) const = 0;

		virtual void	GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const = 0;
		
		virtual	void	ImportMulticastAdapterAddress( const GUID &AdapterGuid,
													   const void *const pGroupData,
													   const UINT_PTR GroupDataSize ) = 0;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::ImportMulticastTargetAddress"
		void	ImportMulticastTargetAddress( const void *const pGroupData, const UINT_PTR GroupDataSize )
		{
			const MULTICAST_DATA	*pMulticastData;


			DNASSERT( pGroupData != NULL );
			DNASSERT( GroupDataSize == sizeof( *pMulticastData ) );
			pMulticastData = static_cast<const MULTICAST_DATA*>( pGroupData );
		    AddressFromGuid( pMulticastData->MulticastAddressGuid, *GetWritableAddress() );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::CopyAddressSettings"
		void	CopyAddressSettings( const CSocketAddress &OtherAddress )
		{
			DBG_CASSERT( sizeof( m_SocketAddress ) == sizeof( OtherAddress.m_SocketAddress ) );

			DNASSERT( GetFamily() == OtherAddress.GetFamily() );
			memcpy( &m_SocketAddress, &OtherAddress.m_SocketAddress, sizeof( m_SocketAddress ) );
			m_AddressType = OtherAddress.m_AddressType;
			m_iSocketAddressSize = OtherAddress.m_iSocketAddressSize;

			DBG_CASSERT( sizeof( m_ComponentInitializationState ) == sizeof( OtherAddress.m_ComponentInitializationState ) );
			memcpy( &m_ComponentInitializationState, &OtherAddress.m_ComponentInitializationState, sizeof( m_ComponentInitializationState ) );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetFamily"
		USHORT	GetFamily( void ) const
		{
			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPSocketAddress.sin_family ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IN, sin_family ) );

			DNASSERT( m_SocketAddress.SocketAddress.sa_family != INVALID_SOCKET_FAMILY );
			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
			return	m_SocketAddress.SocketAddress.sa_family;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetProtocol"
		INT	GetProtocol( void ) const
		{
			DNASSERT( m_iSocketProtocol != INVALID_SOCKET_PROTOCOL );
			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
			return	m_iSocketProtocol;
		}

		virtual	BOOL	IsUndefinedHostAddress( void ) const = 0;
		virtual	void	ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherAddress ) = 0;

		//
		// the following functions work in NETWORK BYTE ORDER!!!
		//
		virtual WORD	GetPort( void ) const = 0;
		virtual void	SetPort( const WORD wPort ) = 0;

		//
		// functions to create default addresses
		//
		virtual IDirectPlay8Address *CreateBroadcastAddress( void ) = 0;
		virtual IDirectPlay8Address *CreateListenAddress( void ) = 0;
		virtual IDirectPlay8Address *CreateGenericAddress( void ) = 0;

	protected:
		//
		// combine all of the SOCKADDR variants into one item, we assume that
		// they're all the same size (or close in the case of IPX)
		//
		union
		{
			SOCKADDR		SocketAddress;
			SOCKADDR_IN		IPSocketAddress;
		} m_SocketAddress;

		INT				m_iSocketAddressSize;
		INT				m_iSocketProtocol;
		SP_ADDRESS_TYPE	m_AddressType;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::AddressFromGuid"
		void	AddressFromGuid( const GUID &InputGuid, SOCKADDR &SocketAddress ) const
		{
			DBG_CASSERT( sizeof( InputGuid ) == sizeof( SocketAddress ) );
			memcpy( &SocketAddress, &InputGuid, sizeof( SocketAddress ) );

			//
			// in the custom case of ALL_ADAPTERS_GUID, fix up the address family
			//
			if ( SocketAddress.sa_family == 0 )
			{
				DNASSERT( InputGuid == g_InvalidAdapterGuid );
				SocketAddress.sa_family = GetFamily();
			}
		}

		virtual void	CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const = 0;

		//
		// Booleans indicating which components have been initialized
		//
		SP_ADDRESS_COMPONENT_STATE	m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_MAX ];

	private:
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CSocketAddress( const CSocketAddress & );
		CSocketAddress& operator=( const CSocketAddress & );
};

#undef DPF_MODNAME

#endif	// __SP_ADDRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\socketport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		CSocketPort.h
 *  Content:	Winsock socket port that manages data flow on a given adapter,
 *				address and port.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SOCKET_PORT_H__
#define __SOCKET_PORT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// states of socket port
//
typedef	enum
{
	SOCKET_PORT_STATE_UNKNOWN = 0,
	SOCKET_PORT_STATE_INITIALIZED,
	SOCKET_PORT_STATE_UNBOUND,
} SOCKET_PORT_STATE;

//
// enumeration of socket types
//
typedef	enum	_GATEWAY_BIND_TYPE
{
	GATEWAY_BIND_TYPE_UNKNOWN = 0,		// uninitialized
	GATEWAY_BIND_TYPE_SPECIFIC,			// map the local port to the same port on the Rsip server (DPNSVR listen socket port)
	GATEWAY_BIND_TYPE_DEFAULT,			// map the local port to any random port on the Rsip server
	GATEWAY_BIND_TYPE_NONE				// don't map the local port on the Rsip server
} GATEWAY_BIND_TYPE;

//
// value used to designate an invalid enum key
//
#define	INVALID_ENUM_KEY	0

//
// enumerated type to indicate how a send completed
//
typedef enum
{
	SEND_UNKNOWN,					// unknown state
	SEND_FAILED,					// send failed
	SEND_IN_PROGRESS,				// send is pending in Winsock
	SEND_WINSOCK_BUSY,				// send couldn't be queued (we'll need to buffer ourselves)
	SEND_COMPLETED_IMMEDIATELY_WS1	// send completed immediately (Winsock1 only)

} SEND_COMPLETION_CODE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSocketPort;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// send function pointer
//
typedef	SEND_COMPLETION_CODE	(CSocketPort::*PSEND_FUNCTION)( CWriteIOData *const pWriteData );
typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );

//**********************************************************************
// Class definition
//**********************************************************************

//
// reference to other classes and structures
//
class	CAdapterEntry;
class	CEndpoint;
class	CEndpointEnumKey;
class	CSPData;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;

//
// main class definition
//
class	CSocketPort
{
	STDNEWDELETE

	public:
		CSocketPort();
		~CSocketPort();

		HRESULT	Initialize( CSPData *const pSPData, CSocketAddress *const pAddress );
		HRESULT	Deinitialize( void );
		HRESULT	BindToNetwork( const GATEWAY_BIND_TYPE GatewayBindType );
		HRESULT	UnbindFromNetwork( void );

		const CSocketAddress *const	GetNetworkAddress( void ) const { return m_pNetworkSocketAddress; }
		const SOCKET	GetSocket( void ) const { return m_Socket; }

		void	AddRef( void ) { DNInterlockedIncrement( &m_iRefCount ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_State != SOCKET_PORT_STATE_UNKNOWN );

			//
			// Decrement the reference counts and return this item to the pool if nobody
			// is referencing it anymore.
			//
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				HRESULT	hr;


				DNASSERT( m_iEndpointRefCount == 0 );

				//
				// There's no need to lock this socket port because this is the last
				// reference to it, nobody else will access it.
				//
				hr = Deinitialize();
				if ( hr != DPN_OK )
				{
					DPF( 0, "Problem deinitializing socket port in DecRef!" );
					DisplayDNError( 0, hr );
				}

				ReturnSelfToPool();
			}
		}
		
		void	EndpointAddRef( void );
		DWORD	EndpointDecRef( void );
		
		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	BindEndpoint( CEndpoint *const pEndpoint );
		void	UnbindEndpoint( CEndpoint *const pEndpoint );
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetEnumKey"
		const DWORD	GetEnumKey( void )
		{
			DWORD	dwReturn;


			DBG_CASSERT( ENUM_RTT_MASK == 0x0F );
			Lock();
			m_iEnumKey++;
			dwReturn = m_iEnumKey << 4;
			Unlock();

			return	dwReturn;
		}

		void	DisconnectAllEndpoints( void );
		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SendUserData"
		void	SendUserData( CWriteIOData *const pWriteData )
		{
			//
			// check for need to escape user data
			//
			switch ( pWriteData->m_pBuffers[ 0 ].pBufferData[ 0 ] )
			{
				case SP_HEADER_LEAD_BYTE:
				{
					//
					// possible token interpretation problem, escape user data by prepending a buffer
					//
					pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
					pWriteData->m_uBufferCount++;
					DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.EscapedUserDataHeader ) == sizeof( BYTE* ) ) ;
					pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.EscapedUserDataHeader );
					pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.EscapedUserDataHeader );
					
					DNASSERT( pWriteData->m_PrependBuffer.EscapedUserDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
					pWriteData->m_PrependBuffer.EscapedUserDataHeader.bSPCommandByte = ESCAPED_USER_DATA_KIND;
					pWriteData->m_PrependBuffer.EscapedUserDataHeader.wPad = ESCAPED_USER_DATA_PAD_VALUE;

					break;
				}

				default:
				{
					//
					// Assume user data.  There's no need to prepend a buffer because the
					// receiving machine will reailze that it's not a 'special' message and
					// will default the contents to 'user data'.
					//
					break;
				}
			}

			SendData( pWriteData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SendEnumResponseData"
		void	SendEnumResponseData( CWriteIOData *const pWriteData, const UINT_PTR uEnumResponseKey )
		{
			//
			// inlined to keep servers fast
			//
			pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
			pWriteData->m_uBufferCount++;
			DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.EnumResponseDataHeader ) == sizeof( BYTE* ) );
			pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.EnumResponseDataHeader );
			pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.EnumResponseDataHeader );
			
			DNASSERT( pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
			pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPCommandByte = ENUM_RESPONSE_DATA_KIND;

			DNASSERT( uEnumResponseKey <= WORD_MAX );
			pWriteData->m_PrependBuffer.EnumResponseDataHeader.wEnumResponsePayload = static_cast<WORD>( uEnumResponseKey );

			SendData( pWriteData );
		}

		void	SendEnumQueryData( CWriteIOData *const pWriteData, const UINT_PTR uEnumKey );
		void	SendProxiedEnumData( CWriteIOData *const pWriteData, const CSocketAddress *const pReturnAddress, const UINT_PTR uOldEnumKey );

		CSocketAddress	*GetBoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const;
		IDirectPlay8Address	*GetDP8BoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const;
		void	MungeAddressWithPAST( CSocketAddress *const pSocketAddress ) const;


		HRESULT	AddToMulticastGroup( const void *const pGroupData, const UINT_PTR uGroupDataSize );
		HRESULT	RemoveFromMulticastGroup( const void *const pGroupData, const UINT_PTR uGroupDataSize );

		//
		// set the Rsip module for this socket port
		//
		CAdapterEntry	*GetAdapterEntry( void ) const { return m_pAdapterEntry; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SetAdapterEntry"
		void	SetAdapterEntry( CAdapterEntry *const pAdapterEntry )
		{
			DNASSERT( ( m_pAdapterEntry == NULL ) || ( pAdapterEntry == NULL ) );
			m_pAdapterEntry = pAdapterEntry;
		}

		void	Winsock2ReceiveComplete( CReadIOData *const pReadData );
		void	CancelReceive( CReadIOData *const pRead );

		//
		// Public service functions for Winsock1 since we can't get asynchronous
		// notification.
		//
		BOOL	SendFromWriteQueue( void );
		void	SendComplete( CWriteIOData *const pWriteData, const HRESULT hResult );

		//
		// functions for active list
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::AddToActiveList"
		void	AddToActiveList( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			m_ActiveListLinkage.InsertBefore( pBilink );
		}

		void	RemoveFromActiveList( void ) { m_ActiveListLinkage.RemoveFromList(); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SocketPortFromBilink"
		static CSocketPort	*SocketPortFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CSocketPort* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CSocketPort*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CSocketPort, m_ActiveListLinkage ) ] );
		}

		void	SetWinsockBufferSize( const INT iBufferSize ) const;

	protected:

	private:
		CSPData						*m_pSPData;					// pointer to SPData
		CThreadPool					*m_pThreadPool;				// pointer to thread pool
		DNCRITICAL_SECTION			m_Lock;						// thread lock
		volatile LONG				m_iRefCount;				// count of all outstanding references (endpoint and I/O)
		volatile LONG				m_iEndpointRefCount;		// count of outstanding endpoint references
		volatile SOCKET_PORT_STATE	m_State;					// state of socket port
		
		volatile SOCKET				m_Socket;					// communications socket
		CSocketAddress				*m_pNetworkSocketAddress;	// network address this socket is bound to
		CSocketAddress				*m_pPASTSocketAddress;		// external network address visible via PAST server
																// this may be the same as the m_NetworkSocketAddress
		
		CAdapterEntry	*m_pAdapterEntry;		// pointer to adapter entry to use
		DWORD			m_dwPASTBindID;			// RSIP bind ID associated with this socket
		CBilink			m_ActiveListLinkage;	// linkage to list of active socket ports

		DNCRITICAL_SECTION								m_EndpointDataLock;			// lock for endpoint data
		CClassHash< HANDLE, const CSocketAddress* >		m_ConnectEndpointList;		// list of connect endpoints
		CClassHash< HANDLE, const CEndpointEnumKey* >	m_EnumEndpointList;			// list of enum endpoints
		HANDLE											m_hListenEndpoint;			// associated listen endpoint (there can only be one!)

		volatile LONG	m_iEnumKey;						// current 'key' to be assigned to an enum
		CSendQueue		m_SendQueue;					// outgoing send queue
		THREAD_POOL_JOB	*m_pRemoveSocketPortData;		// pointer to preallocated job for removing socket port
		PSEND_FUNCTION	m_pSendFunction;				// pointer to appropriate send function

		DEBUG_ONLY(	BOOL	m_fInitialized );


		void	LockEndpointData( void ) { DNEnterCriticalSection( &m_EndpointDataLock ); }
		void	UnlockEndpointData( void ) { DNLeaveCriticalSection( &m_EndpointDataLock ); }

		HRESULT	BindToNextAvailablePort( const CSocketAddress *const pNetworkSocketAddress ) const;
		
		HRESULT	BindToPASTServer( const CSocketAddress *const pBoundSocketAddress,
								  CSocketAddress *const pPASTSocketAddress,
								  const GATEWAY_BIND_TYPE GatewayBindType );
		
		HRESULT	StartReceiving( void );

		SEND_COMPLETION_CODE	Winsock2Send( CWriteIOData *const pWriteData );
		HRESULT					Winsock2Receive( void );

		void	SendData( CWriteIOData *const pWriteData );
		void	ProcessReceivedData( CReadIOData *const pReadData );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CSocketPort( const CSocketPort & );
		CSocketPort& operator=( const CSocketPort & );
};

#undef DPF_MODNAME

#endif	// __SOCKET_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\sendqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CSendQueue.h
 *  Content:	Queue to manage outgoing sends on socket port
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#ifndef __SEND_QUEUE_H__
#define __SEND_QUEUE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// forward structure references
//
class	CEndpoint;
class	CWriteIOData;

//
// main class definition
//
class	CSendQueue
{
	STDNEWDELETE

	public:
		CSendQueue();
		~CSendQueue();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	Initialize( void );
		void	Deinitialize( void ) { DNDeleteCriticalSection( &m_Lock ); }

		//
		// add item to end of queue
		//
		void	Enqueue( CWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pTail == NULL )
			{
				m_pHead = pWriteData;
			}
			else
			{
				m_pTail->m_pNext = pWriteData;
			}

			m_pTail = pWriteData;
			pWriteData->m_pNext = NULL;
		}

		//
		// add item to front of queue
		//
		void	AddToFront( CWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead != NULL )
			{
				pWriteData->m_pNext = m_pHead;
			}
			else
			{
				m_pTail = pWriteData;
				pWriteData->m_pNext = NULL;
			}

			m_pHead = pWriteData;
		}

		//
		// remove item from queue
		//
		CWriteIOData	*Dequeue( void )
		{
			CWriteIOData	*pReturn;


			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			pReturn = m_pHead;
			if ( m_pHead != NULL )
			{
				m_pHead = m_pHead->m_pNext;
				if ( m_pHead == NULL )
				{
					m_pTail = NULL;
				}

				DEBUG_ONLY( pReturn->m_pNext = NULL );
			}

			return	pReturn;
		};

		//
		// determine if queue is empty
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CWriteIOData::IsEmpty"
		BOOL	IsEmpty( void )	const
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead == NULL )
			{
				DNASSERT( m_pTail == NULL );
				return	TRUE;
			}
			else
			{
				return	FALSE;
			}
		}

		CWriteIOData	*FindNextByEndpoint( HANDLE *const pHandle, const CEndpoint *const pEndpoint );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;		// critical section
		CWriteIOData		*m_pHead;	// pointer to queue head
		CWriteIOData		*m_pTail;	// pointer to queue tail
};

#undef DPF_MODNAME

#endif	// __SEND_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\spdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		SPData.h
 *  Content:	Global information for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/1999	jtk		Derived from Locals.h
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SPDATA_H__
#define __SPDATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_ADDRESS_BUFFER_SIZE	151

//
// enumeration of the states the SP can be in
//
typedef enum
{
	SPSTATE_UNKNOWN = 0,		// uninitialized state
	SPSTATE_UNINITIALIZED = 0,	// uninitialized state
	SPSTATE_INITIALIZED,		// service provider has been initialized
	SPSTATE_CLOSING				// service provider is closing
} SPSTATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// forward structure and class references
class	CCommandData;
class	CEndpoint;
class	CIPEndpoint;
class	CIPAddress;
// BUGBUG: [mgere] [xbox] Removed RSIP
//class	CRsip;
class	CSocketAddress;
class	CSocketPort;
class	CThreadPool;
class	CWriteIOData;
typedef	enum	_ENDPOINT_TYPE		ENDPOINT_TYPE;
typedef	enum	_GATEWAY_BIND_TYPE	GATEWAY_BIND_TYPE;
typedef	struct	_SPRECEIVEDBUFFER	SPRECEIVEDBUFFER;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );
typedef	void	DNADDRESS, *PDNADDRESS;

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for information used by the provider
//
class	CSPData
{	
	STDNEWDELETE

	public:
		CSPData();
		~CSPData();
		
		DWORD	AddRef( void ) { return DNInterlockedIncrement( &m_lRefCount ); }
		
		DWORD	DecRef( void )
		{
			DWORD	dwReturn;
			
				
			dwReturn = DNInterlockedDecrement( &m_lRefCount );
			if ( dwReturn == 0 )
			{
				//
				// WARNING, the following function deletes this object!!!
				//
				DestroyThisObject();
			}

			return	dwReturn;
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectAddRef"
		void	ObjectAddRef( void )
		{
			AddRef();
			
			Lock();
			if ( DNInterlockedIncrement( &m_lObjectRefCount ) == 1 )
			{
				DNASSERT( m_hShutdownEvent != NULL );
				if ( ResetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPF( 0, "Failed to reset shutdown event!" );
					DisplayErrorCode( 0, dwError );
				}
			}

			Unlock();
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectDecRef"
		void	ObjectDecRef( void )
		{
			Lock();

			if ( DNInterlockedDecrement( &m_lObjectRefCount ) == 0 )
			{
				if ( SetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPF( 0, "Failed to set shutdown event!" );
					DisplayErrorCode( 0, dwError );
				}
			}
			
			Unlock();
			
			DecRef();
		}
		

		HRESULT	Initialize( const CLSID *const pClassID,
							IDP8ServiceProviderVtbl *const pVtbl );
		void	Shutdown( void );
		void	Deinitialize( void );

		void	SetCallbackData( const SPINITIALIZEDATA *const pInitData );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		const SPSTATE	GetState( void ) const { return m_SPState; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetState"
		void SetState( const SPSTATE NewState )
		{
			DNASSERT( ( NewState == SPSTATE_UNINITIALIZED ) ||
					  ( NewState == SPSTATE_INITIALIZED ) ||
					  ( NewState == SPSTATE_CLOSING ) );

			m_SPState = NewState;
		}

		BOOL	IsRsipServer( void ) const { return m_fIsRsipServer; }
		const SOCKADDR	*GetPublicSocketAddress( void ) const
		{
			const SOCKADDR	*pReturn;
			

			pReturn = NULL;
			if ( IsRsipServer() != FALSE )
			{
				pReturn = &m_PublicSocketAddress;
			}

			return	pReturn;
		}

		CThreadPool	*GetThreadPool( void ) const { return m_pThreadPool; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetThreadPool"
		void	SetThreadPool( CThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}


		//
		// functions to manage the socket port list
		//
		void	LockSocketPortData( void ) { DNEnterCriticalSection( &m_SocketPortDataLock ); }
		void	UnlockSocketPortData( void ) { DNLeaveCriticalSection( &m_SocketPortDataLock ); }
		HRESULT	BindEndpoint( CEndpoint *const pEndpoint,
							  IDirectPlay8Address *const pDeviceAddress,
							  const CSocketAddress *const pSocketAddress,
							  const GATEWAY_BIND_TYPE GatewayBindType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint );

		//
		// address pool functions
		//
		CSocketAddress	*GetNewAddress( void );
		void			ReturnAddress( CSocketAddress *const pAddress );

		//
		// endpoint pool management
		//
		CEndpoint	*GetNewEndpoint( void );
		CEndpoint	*EndpointFromHandle( const HANDLE hEndpoint );
		void		CloseEndpointHandle( CEndpoint *const pEndpoint );
		CEndpoint	*GetEndpointAndCloseHandle( const HANDLE hEndpoint );

		//
		// generic address functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::GetBroadcastHostAddress"
		IDirectPlay8Address *GetBroadcastHostAddress( void ) const
		{
			DNASSERT( m_pBroadcastAddress != NULL );
			return	m_pBroadcastAddress;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "GetListenDeviceAddress"
		IDirectPlay8Address *GetListenDeviceAddress( void ) const
		{
			DNASSERT( m_pListenAddress != NULL );
			IDirectPlay8Address_AddRef( m_pListenAddress );
			return	m_pListenAddress;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::GetGenericDeviceAddress"
		IDirectPlay8Address	 *GetGenericDeviceAddress( void ) const
		{
			DNASSERT( m_pGenericAddress != NULL );
			IDirectPlay8Address_AddRef( m_pGenericAddress );
			return	m_pGenericAddress;
		}

//		CRsip	*RsipModule( void ) const { return m_pRsip; }
//		void	SetRsipModule( CRsip *const pRsip )
//		{
//		    DNASSERT( ( m_pRsip == NULL ) || ( pRsip == NULL ) );
//		    m_pRsip = pRsip;
//		}

		IDP8SPCallback	*DP8SPCallbackInterface( void ) { return reinterpret_cast<IDP8SPCallback*>( m_InitData.pIDP ); }
		IDP8ServiceProvider	*COMInterface( void ) { return reinterpret_cast<IDP8ServiceProvider*>( &m_COMInterface ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SPDataFromCOMInterface"
		static	CSPData	*SPDataFromCOMInterface( IDP8ServiceProvider *const pCOMInterface )
		{
			DNASSERT( pCOMInterface != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pCOMInterface ) );
			DBG_CASSERT( sizeof( CSPData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CSPData*>( &reinterpret_cast<BYTE*>( pCOMInterface )[ -OFFSETOF( CSPData, m_COMInterface ) ] );
		}

		void	SetWinsockBufferSizeOnAllSockets( const INT iBufferSize );

	private:
		DNCRITICAL_SECTION	m_Lock;					// lock
		volatile LONG		m_lRefCount;			// reference count
		volatile LONG		m_lObjectRefCount;		// reference count of outstanding objects (CEndpoint, CSocketPort, etc.)
		HANDLE				m_hShutdownEvent;		// handle for shutdown
		SPSTATE				m_SPState;				// what state is the SP in?
		SPINITIALIZEDATA	m_InitData;				// initialization data
		BOOL				m_fIsRsipServer;		// Boolean indication status of Rsip on this machine
		SOCKADDR			m_PublicSocketAddress;	// public socket address to be returned to user

		//
		// job management
		//
		CThreadPool		*m_pThreadPool;

		//
		// List of active adapters.  This encapsulates active device addresses
		// so sockets can be reused when possible and contains a CRsip interface
		// for each adapter (if applicable)
		//
		CBilink	m_ActiveAdapterList;

		//
		// default addresses
		//
		IDirectPlay8Address	*m_pBroadcastAddress;	// broadcast address for this protocol
		IDirectPlay8Address	*m_pListenAddress;		// listen address for this protocol
		IDirectPlay8Address	*m_pGenericAddress;		// generic address for this protocol (allows protocol
													// to choose address and port)

		CHandleTables			m_HandleTables;			// handle table for endpoints
		DNCRITICAL_SECTION		m_SocketPortDataLock;	// lock for socket port list
		CClassHash< CSocketPort*, const CSocketAddress* >	m_ActiveSocketPortList;	// list of active socket ports

		//
		// initialization state Booleans
		//
		BOOL	m_fHandleTableInitialized;
		BOOL	m_fLockInitialized;
		BOOL	m_fSocketPortDataLockInitialized;
		BOOL	m_fSocketPortListInitialized;
		BOOL	m_fInterfaceGlobalsInitialized;
		BOOL	m_fDefaultAddressesBuilt;

		struct
		{
			IDP8ServiceProviderVtbl	*m_pCOMVtbl;
		} m_COMInterface;

		HRESULT	BuildDefaultAddresses( void );
		void	FreeDefaultAddresses( void );
		void	DestroyThisObject( void );
		
		//
		// prevent unwarranted copies
		//
		CSPData( const CSPData & );
		CSPData& operator=( const CSPData & );
};

#undef DPF_MODNAME

#endif	// __SPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\socketport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SocketPort.cpp
 *  Content:	Winsock socket port that manages data flow on a given adapter,
 *				address and port.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "wsockspi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	INVALID_PAST_BIND_ID	0

#define	SOCKET_RECEIVE_BUFFER_SIZE		( 128 * 1024 )

//
// DPlay port limits (inclusive) scanned to find an available port.
// Exclude 2300 and 2301 because there are network broadcasts on 2301
// that we may receive.
//
static const WORD	g_wBaseDPlayPort = 2302;
static const WORD	g_wMaxDPlayPort = 2400;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

extern CRITICAL_SECTION g_csSocketAccessLock;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::CSocketPort - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::CSocketPort"

CSocketPort::CSocketPort():
	m_pSPData( NULL ),
	m_pThreadPool( NULL ),
	m_iRefCount( 0 ),
	m_iEndpointRefCount( 0 ),
	m_State( SOCKET_PORT_STATE_UNKNOWN ),
	m_pNetworkSocketAddress( NULL ),
	m_pPASTSocketAddress( NULL ),
	m_pAdapterEntry( NULL ),
	m_dwPASTBindID( INVALID_PAST_BIND_ID ),
	m_Socket( INVALID_SOCKET ),
	m_hListenEndpoint( INVALID_HANDLE_VALUE ),
	m_iEnumKey( INVALID_ENUM_KEY ),
	m_pRemoveSocketPortData( NULL ),
	m_pSendFunction( NULL )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	m_ActiveListLinkage.Initialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::~CSocketPort - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::~CSocketPort"

CSocketPort::~CSocketPort()
{
	//
	// m_pThis needs to be around for the life of the endpoint
	// it should be part of the constructor, but can't be since we're using
	// a pool manager
	//
	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_fInitialized == FALSE );

	DNASSERT( m_iRefCount == 0 );
	DNASSERT( m_iEndpointRefCount == 0 );
	DNASSERT( m_State == SOCKET_PORT_STATE_UNKNOWN );
	DNASSERT( GetSocket() == INVALID_SOCKET );
	DNASSERT( m_pNetworkSocketAddress == NULL );
	DNASSERT( m_pPASTSocketAddress == NULL );
	DNASSERT( m_pAdapterEntry == NULL );
	DNASSERT( m_dwPASTBindID == INVALID_PAST_BIND_ID );
	DNASSERT( m_ActiveListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_hListenEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_iEnumKey == INVALID_ENUM_KEY );
	DNASSERT( m_pRemoveSocketPortData == NULL );
	DNASSERT( m_pSendFunction == NULL );
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_pSPData == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Initialize - initialize this socket port
//
// Entry:		Pointer to CSPData
//				Pointer to address to bind to
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Initialize"

HRESULT	CSocketPort::Initialize( CSPData *const pSPData, CSocketAddress *const pAddress )
{
	HRESULT	hr;
	HRESULT	hTempResult;


	DNASSERT( pSPData != NULL );
	DNASSERT( pAddress != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	m_pSPData = pSPData;
	m_pSPData->ObjectAddRef();
	m_pThreadPool = m_pSPData->GetThreadPool();

	DEBUG_ONLY( m_fInitialized = TRUE );
	DNASSERT( m_State != SOCKET_PORT_STATE_INITIALIZED );
	m_State = SOCKET_PORT_STATE_INITIALIZED;

	//
	// attempt to initialize the internal critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to initialize critical section for socket port!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	if ( DNInitializeCriticalSection( &m_EndpointDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to initialize EndpointDataLock critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_EndpointDataLock, 0 );

	//
	// attempt to initialize the contained send queue
	//
	hr = m_SendQueue.Initialize();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem initializing send queue!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// initialize the endpoint list with 64 entries and grow by a factor of 16
	//
	DNASSERT( hr == DPN_OK );
	if ( m_ConnectEndpointList.Initialize( 6, 4 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Could not initialize the connect endpoint list!" );
		goto Failure;
	}

	//
	// initialize enum list with 16 entries and grow by a factor of 4
	//
	DNASSERT( hr == DPN_OK );
	if ( m_EnumEndpointList.Initialize( 4, 2 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Could not initialize the enum endpoint list!" );
		goto Failure;
	}

	//
	// allocate addresses:
	//		local address this socket is binding to
	//		address of received messages
	//
	DNASSERT( m_pNetworkSocketAddress == NULL );
	DNASSERT( m_pPASTSocketAddress == NULL );
	m_pNetworkSocketAddress = pAddress;

	DNASSERT( m_pSendFunction == NULL );
		m_pSendFunction = Winsock2Send;

Exit:
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem in CSocketPort::Initialize()" );
		DisplayDNError( 0, hr );
	}

	return hr;

Failure:
	DEBUG_ONLY( m_fInitialized = FALSE );

	hTempResult = Deinitialize();
	if ( hTempResult != DPN_OK )
	{
		DPF( 0, "Problem deinitializing CSocketPort on failed Initialize!" );
		DisplayDNError( 0, hTempResult );
	}

	m_pNetworkSocketAddress = NULL;

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Deinitialize - deinitialize this socket port
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Deinitialize"

HRESULT	CSocketPort::Deinitialize( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	Lock();
	DNASSERT( ( m_State == SOCKET_PORT_STATE_INITIALIZED ) ||
			  ( m_State == SOCKET_PORT_STATE_UNBOUND ) );
	DEBUG_ONLY( m_fInitialized = FALSE );

	DNASSERT( m_iEndpointRefCount == 0 );
	DNASSERT( m_iRefCount == 0 );

	//
	// return base network socket addresses
	//
	if ( m_pNetworkSocketAddress != NULL )
	{
		m_pSPData->ReturnAddress( m_pNetworkSocketAddress );
		m_pNetworkSocketAddress = NULL;
	}

	//
	// if we've been involved with PAST, return the network address and bind ID
	//
	if ( m_pPASTSocketAddress != NULL )
	{
		m_pSPData->ReturnAddress( m_pPASTSocketAddress );
		m_pPASTSocketAddress = NULL;
	}
	DNASSERT( m_dwPASTBindID == INVALID_PAST_BIND_ID );

	m_pSendFunction = NULL;
	m_iEnumKey = INVALID_ENUM_KEY;

	m_SendQueue.Deinitialize();

	m_EnumEndpointList.Deinitialize();
	m_ConnectEndpointList.Deinitialize();

	Unlock();

	DNDeleteCriticalSection( &m_EndpointDataLock );
	DNDeleteCriticalSection( &m_Lock );

	DNASSERT( m_pSPData != NULL );
	m_pSPData->ObjectDecRef();
	m_pSPData = NULL;
	m_pThreadPool = NULL;

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::EndpointAddRef - increment endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	This function should not be called without having the SP's SocketPort
//			data locked to make sure we're the only ones playing with socket ports!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::EndpointAddRef"

void	CSocketPort::EndpointAddRef( void )
{
	Lock();

	//
	// add a global reference and then add an endpoint reference
	//
	DNASSERT( m_iEndpointRefCount != -1 );
	m_iEndpointRefCount++;
	AddRef();

	Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::EndpointDecRef - decrement endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Endpoint reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::EndpointDecRef"

DWORD	CSocketPort::EndpointDecRef( void )
{
	DWORD	dwReturn;


	Lock();

	DNASSERT( m_iEndpointRefCount != 0 );

	m_iEndpointRefCount--;
	dwReturn = m_iEndpointRefCount;
	if ( m_iEndpointRefCount == 0 )
	{
		HRESULT	hr;


		//
		// No more endpoints are referencing this item, unbind this socket port
		// from the network and then remove it from the active socket port list.
		// If we're on Winsock1, tell the other thread that this socket needs to
		// be removed so we can get rid of our outstanding I/O reference.
		//
		hr = UnbindFromNetwork();
		if ( hr != DPN_OK )
		{
			DPF( 0, "Problem unbinding from network when final endpoint has disconnected" );
			DisplayDNError( 0, hr );
		}

		m_State = SOCKET_PORT_STATE_UNBOUND;
		DNASSERT( m_pNetworkSocketAddress != NULL );
	}

	Unlock();

	//
	// Decrement global reference count.  This may result in this socketport
	// being returned to the pool!
	//
	DecRef();

	return	dwReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindEndpoint - add an endpoint to this SP's list
//
// Entry:		Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindEndpoint"

HRESULT	CSocketPort::BindEndpoint( CEndpoint *const pEndpoint )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_iRefCount != 0 );

//	EndpointAddRef();

	pEndpoint->ChangeLoopbackAlias( GetNetworkAddress() );

	LockEndpointData();

	switch ( pEndpoint->GetType() )
	{
		//
		// Treat 'connect' and 'multicast' endpoints as the same type (multicast is just
		// a custom subset of addresses).  We don't care how many connections are made
		// through this socket port, just make sure we're not connecting to the same
		// person more than once
		//
		case ENDPOINT_TYPE_MULTICAST:
		case ENDPOINT_TYPE_CONNECT:
		{
			HANDLE	hExistingEndpoint;


			if ( m_ConnectEndpointList.Find( pEndpoint->GetRemoteAddressPointer() , &hExistingEndpoint ) != FALSE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPF( 0, "Attempted to connect twice to the same endpoint!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			if ( m_ConnectEndpointList.Insert( pEndpoint->GetRemoteAddressPointer(), pEndpoint->GetHandle() ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPF( 0, "Problem adding endpoint to socket port list!" );
				goto Failure;
			}

			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// we only allow one listen endpoint on a socket port
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPF( 0, "Attempted to listen more than once on a given SocketPort!" );
				goto Failure;
			}

			m_hListenEndpoint = pEndpoint->GetHandle();
			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// we don't allow duplicate enum endpoints
		//
		case ENDPOINT_TYPE_ENUM:
		{
			HANDLE	hExistingEndpoint;


			pEndpoint->SetEnumKey( GetEnumKey() );
			if ( m_EnumEndpointList.Find( pEndpoint->GetEnumKey(), &hExistingEndpoint ) != FALSE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPF( 0, "Attempted to enum twice to the same endpoint!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			if ( m_EnumEndpointList.Insert( pEndpoint->GetEnumKey(), pEndpoint->GetHandle() ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPF( 0, "Problem adding endpoint to socket port list!" );
				goto Failure;
			}

			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// unknown endpoint type
		//
		default:
		{
			INT3;
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	
	UnlockEndpointData();

Exit:
	return	hr;

Failure:
	UnlockEndpointData();
	
//	EndpointDecRef();
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::UnbindEndpoint - remove an endpoint from the SP's list
//
// Entry:		Pointer to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::UnbindEndpoint"

void	CSocketPort::UnbindEndpoint( CEndpoint *const pEndpoint )
{
	DEBUG_ONLY( HANDLE	hFindTemp );


	LockEndpointData();

	//
	// adjust any special pointers before removing endpoint
	//
	switch ( pEndpoint->GetType() )
	{
		//
		// Multicast and connect endpoints are the same (multicast is a reserved subset
		// of the connect address space).  Remove endpoint from connect list.
		//
		case ENDPOINT_TYPE_MULTICAST:
		case ENDPOINT_TYPE_CONNECT:
		{
			DEBUG_ONLY( DNASSERT( m_ConnectEndpointList.Find( pEndpoint->GetRemoteAddressPointer(), &hFindTemp ) != FALSE ) );
			m_ConnectEndpointList.Remove( pEndpoint->GetRemoteAddressPointer() );
			pEndpoint->SetSocketPort( NULL );
			pEndpoint->DecRef();
			break;
		}

		//
		// make sure this is really the active listen and then remove it
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( m_hListenEndpoint != INVALID_HANDLE_VALUE );
			m_hListenEndpoint = INVALID_HANDLE_VALUE;
			pEndpoint->SetSocketPort( NULL );
			pEndpoint->DecRef();
			break;
		}

		//
		// remove endpoint from enum list
		//
		case ENDPOINT_TYPE_ENUM:
		{
			DEBUG_ONLY( DNASSERT( m_EnumEndpointList.Find( pEndpoint->GetEnumKey(), &hFindTemp ) != FALSE ) );
			m_EnumEndpointList.Remove( pEndpoint->GetEnumKey() );
			pEndpoint->SetSocketPort( NULL );
			pEndpoint->DecRef();
			break;
		}

		default:
		{
			INT3;
			break;
		}
	}

	UnlockEndpointData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::DisconnectAllEndpoints - disconnect all endpoints bound to this
//		socket port
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::DisconnectAllEndpoints"

void	CSocketPort::DisconnectAllEndpoints( void )
{
	INT3;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::ReturnSelfToPool"

void	CSocketPort::ReturnSelfToPool( void )
{
	m_State = SOCKET_PORT_STATE_UNKNOWN;
	DNASSERT( m_pSPData == NULL );
	ReturnSocketPort( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendEnumQueryData - send data for an enum query
//
// Entry:		Pointer to write data
//				Enum key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendEnumQueryData"

void	CSocketPort::SendEnumQueryData( CWriteIOData *const pWriteData, const UINT_PTR uEnumKey )
{
	pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
	pWriteData->m_uBufferCount++;
	DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.EnumDataHeader ) == sizeof( BYTE* ) );
	pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.EnumDataHeader );
	pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.EnumDataHeader );
	
	DNASSERT( pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE);
	pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPCommandByte = ENUM_DATA_KIND;

	DNASSERT( uEnumKey <= WORD_MAX );
	pWriteData->m_PrependBuffer.EnumResponseDataHeader.wEnumResponsePayload = static_cast<WORD>( uEnumKey );

	SendData( pWriteData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendData - send data
//
// Entry:		Pointer to write data
//				Pointer to return address (real address the message should be returned to)
//				Enum key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendProxiedEnumData"

void	CSocketPort::SendProxiedEnumData( CWriteIOData *const pWriteData, const CSocketAddress *const pReturnAddress, const UINT_PTR uOldEnumKey )
{
	DNASSERT( pWriteData != NULL );
	DNASSERT( pReturnAddress != NULL );

	pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
	pWriteData->m_uBufferCount++;

	//
	// We could save 2 bytes on IPX by only passing 14 bytes for the
	// SOCKADDR structure but it's not worth it, especially since it's
	// looping back in the local network stack.  SOCKADDR structures are also
	// 16 bytes so reducing the data passed to 14 bytes would destroy alignment.
	//
	DBG_CASSERT( sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) == 16 );
	DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.ProxiedEnumDataHeader ) == sizeof( BYTE* ) );
	pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.ProxiedEnumDataHeader );
	pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader );
	
	DNASSERT( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
	pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.bSPCommandByte = PROXIED_ENUM_DATA_KIND;
	
	DNASSERT( uOldEnumKey <= WORD_MAX );
	pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.wEnumKey = static_cast<WORD>( uOldEnumKey );

	DBG_CASSERT( sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) == sizeof( *pReturnAddress->GetAddress() ) );
	memcpy( &pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress,
			pReturnAddress->GetAddress(),
			sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) );

	SendData( pWriteData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendData - send data
//
// Entry:		Pointer to write data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendData"

void	CSocketPort::SendData( CWriteIOData *const pWriteData )
{
	DNASSERT( pWriteData != NULL );
	DNASSERT( pWriteData->SocketPort() == NULL );

	pWriteData->SetSocketPort( this );

	m_SendQueue.Lock();

	//
	// If the send queue is not empty, add this item to the end of the queue and
	// then attempt to send as much as possible.  Otherwise attempt to send this
	// data immediatly.
	//
	if ( m_SendQueue.IsEmpty() == FALSE )
	{
		BOOL	fIOServiced;


		m_SendQueue.Enqueue( pWriteData );
		m_SendQueue.Unlock();
		fIOServiced = SendFromWriteQueue();
	}
	else
	{
		SEND_COMPLETION_CODE	SendCompletionCode;


		//
		// there are no items in the queue, attempt to send
		//
		m_SendQueue.Unlock();

		DPF(8, "WriteData %x", pWriteData);
		
		pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );

		SendCompletionCode = (this->*m_pSendFunction)( pWriteData );
		switch ( SendCompletionCode )
		{
			//
			// Send has been spooled to Winsock, nothing to do
			//
			case SEND_IN_PROGRESS:
			{
				DPF( 8, "SendInProgress, will complete later" );
				break;
			}

			//
			// Send can't be submitted, spool it so it will go out the next
			// time someone tries to send.  Reset the command state to allow the
			// user to cancel the command.
			//
			case SEND_WINSOCK_BUSY:
			{
				DPF( 8, "Winsock Busy - Requeueing Send" );
				pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
				m_SendQueue.Lock();
				m_SendQueue.AddToFront( pWriteData );
				m_SendQueue.Unlock();
				break;
			}

			//
			// something went wrong, tell the user that their send barfed and
			// that the connection is probably going bye-bye
			//
			case SEND_FAILED:
			{
				SendComplete( pWriteData, DPNERR_CONNECTIONLOST );
				break;
			}

			//
			// invalid return
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2Send - send data in a Winsock 2.0 fashion
//
// Entry:		Pointer to write data
//
// Exit:		Send completion code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2Send"

SEND_COMPLETION_CODE	CSocketPort::Winsock2Send( CWriteIOData *const pWriteData )
{
	SEND_COMPLETION_CODE	SendCompletionCode;
	INT			iWSAReturn;


	DNASSERT( pWriteData != NULL );

	//
	// initialize
	//
	SendCompletionCode = SEND_IN_PROGRESS;

	//
	// note an I/O reference before submitting command
	//
	AddRef();

	DBG_CASSERT( sizeof( pWriteData->m_pBuffers ) == sizeof( WSABUF* ) );
	DBG_CASSERT( sizeof( *pWriteData->m_pBuffers ) == sizeof( WSABUF ) );
	DNASSERT( pWriteData->OverlapEvent() != NULL );
	DNASSERT( pWriteData->m_pDestinationSocketAddress != NULL );

	DPF( 8, "Winsock2 sending to socket:" );
	DumpSocketAddress( 8, pWriteData->m_pDestinationSocketAddress->GetAddress(), pWriteData->m_pDestinationSocketAddress->GetFamily() );

	//
	// lock the 'pending operation' list over the call to Winsock to prevent the
	// operation from being completed while it's being set up.
	//
		m_pSPData->GetThreadPool()->LockWriteData();
	
	//
	// Note that this operation is now in a 'pending' status.  It really
	// isn't yet, but Windows should alert us to that if we attempt to query
	// for I/O completion before the operation has been submitted.  Only assert
	// the 'pending' flag on Win9x.
	//
	DNASSERT( pWriteData->m_dwOverlappedBytesSent == 0 );
	DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
	pWriteData->SetWin9xOperationPending( TRUE );

	DNASSERT( pWriteData->m_uBufferCount <= UINT32_MAX );

	DNEnterCriticalSection(&g_csSocketAccessLock);
	iWSAReturn = p_WSASendTo( GetSocket(),													// socket
							  reinterpret_cast<WSABUF*>( pWriteData->m_pBuffers ),			// buffers
							  static_cast<DWORD>( pWriteData->m_uBufferCount ),				// count of buffers
							  &pWriteData->m_dwBytesSent,									// pointer to number of bytes sent
							  0,															// send flags
							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
							  pWriteData->m_pDestinationSocketAddress->GetAddressSize(),	// size of destination address
							  pWriteData->Overlap(),										// pointer to overlap structure
							  NULL															// APC callback (unused)
							  );
	DNLeaveCriticalSection(&g_csSocketAccessLock);

		m_pSPData->GetThreadPool()->UnlockWriteData();

	if ( iWSAReturn == SOCKET_ERROR )
	{
		DWORD	dwWSAError;


		dwWSAError = p_WSAGetLastError();
		switch ( dwWSAError )
		{
			//
			// I/O is pending, note that the command cannot be cancelled,
			// wait for completion
			//
			case WSA_IO_PENDING:
			{
				DNASSERT( SendCompletionCode == SEND_IN_PROGRESS );
				break;
			}

			//
			// could not submit another overlapped I/O request, indicate that
			// the send was busy so someone above us spools the send for later
			//
			case WSAEWOULDBLOCK:
			{
				DPF( 8 , "Got WSAEWOULDBLOCK on Send " );
				pWriteData->SetWin9xOperationPending( FALSE );
				SendCompletionCode = SEND_WINSOCK_BUSY;
				DecRef();
				break;
			}

			//
			// socket was closed on us
			//
			case WSAENOTSOCK:
			default:
			{
				SendCompletionCode = SEND_FAILED;

				DPF( 8 , "Failing Send " );

				//
				// the operation was assumed to be pending and it's definitely
				// not going to be sent now
				//
				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
				pWriteData->SetWin9xOperationPending( FALSE );

				switch ( dwWSAError )
				{
					//
					// WSAENOTSOCK: another thread closed the socket
					// WSAENOBUFS: machine out of memory
					//
					case WSAENOTSOCK:
					case WSAENOBUFS:
					{
						break;
					}

					default:
					{
						//
						// something bad happened, stop and take a look
						//
						DisplayWinsockError( 0, dwWSAError );
						DNASSERT( FALSE );
						break;
					}
				}

				DecRef();
				break;
			}
		}
	}
	else
	{
		//
		// Send completed immediately.  There's nothing to do because the
		// delayed I/O completion notification will still be given and will do
		// final processing at that time.
		//
		DNASSERT( SendCompletionCode == SEND_IN_PROGRESS );
	}

	return	SendCompletionCode;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2Receive - receive data in a Winsock 2.0 fashion
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2Receive"

HRESULT	CSocketPort::Winsock2Receive( void )
{
	HRESULT			hr;
	INT				iWSAReturn;
	READ_IO_DATA_POOL_CONTEXT	PoolContext;
	CReadIOData		*pReadData;


	//
	// initialize
	//
	hr = DPN_OK;

	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
	if ( pReadData == NULL )
	{
#pragma	BUGBUG( johnkan, "Handle this!" )
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Out of memory attempting Winsock2 read!" );
		INT3;
		goto Exit;
	}

	//
	// note the IO reference before attempting the read
	//
	AddRef();

	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );
	DNASSERT( pReadData->SocketPort() == NULL );

	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc ) == sizeof( WSABUF ) );
	DBG_CASSERT( OFFSETOF( BUFFERDESC, dwBufferSize ) == OFFSETOF( WSABUF, len ) );
	DBG_CASSERT( OFFSETOF( BUFFERDESC, pBufferData ) == OFFSETOF( WSABUF, buf ) );

	DNASSERT( pReadData->OverlapEvent() != NULL );

	pReadData->m_dwReadFlags = 0;
	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
	pReadData->SetSocketPort( this );

	DPF( 8, "Reading from socket.  Current read buffer:" );
	DumpSocketAddress( 8, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily() );

	//
	// lock the 'pending operation' list over the call to Winsock to prevent the
	// operation from being completed while it's being set up.
	//
		m_pSPData->GetThreadPool()->LockReadData();

	//
	// Note that this operation is 'pending'.  It really isn't, but Windows
	// should let us know if we query for completion status and this operation
	// isn't complete.  Only assert state on Win9x because NT doesn't use the
	// 'pending' field.
	//
	DNASSERT( pReadData->m_dwOverlappedBytesReceived == 0 );
	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
	pReadData->SetWin9xOperationPending( TRUE );

Reread:
	if (GetSocket() == INVALID_SOCKET)
	{
					m_pSPData->GetThreadPool()->UnlockReadData();

				hr = DPNERR_GENERIC;

				DNASSERT( pReadData != NULL );

				DNASSERT( pReadData->Win9xOperationPending() != FALSE );
				pReadData->SetWin9xOperationPending( FALSE );
				pReadData->DecRef();
				pReadData = NULL;

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
    }

	DNEnterCriticalSection(&g_csSocketAccessLock);
	iWSAReturn = p_WSARecvFrom( GetSocket(),							// socket
								reinterpret_cast<WSABUF*>( &pReadData->ReceivedBuffer()->BufferDesc ),	// pointer to receive buffers
								1,										// number of receive buffers
								&pReadData->m_dwBytesRead,				// pointer to bytes received (if command completes immediately)
								&pReadData->m_dwReadFlags,				// flags (none)
								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
								&pReadData->m_iSocketAddressSize,		// size of address of sending socket
								pReadData->Overlap(),					// pointer to overlapped structure
								NULL									// APC callback (unused)
								);	
	DNLeaveCriticalSection(&g_csSocketAccessLock);

	if ( iWSAReturn == 0 )
	{
			//
			// function completed immediately, do nothing, wait for IOCompetion
			// notification	to be processed
			//
				m_pSPData->GetThreadPool()->UnlockReadData();
	}
	else
	{
		DWORD	dwWSAReceiveError;


		//
		// failure, check for pending operation
		//
		dwWSAReceiveError = p_WSAGetLastError();
		switch ( dwWSAReceiveError )
		{
			//
			// the send is pending, nothing to do
			//
			case WSA_IO_PENDING:
			{
					m_pSPData->GetThreadPool()->UnlockReadData();

				break;
			}

            case WSAEINPROGRESS:		// BUGBUG: [mgere] [xbox] Added this to handle overlapped Recv error.  Make sure this is the proper place for it.
			{
					m_pSPData->GetThreadPool()->UnlockReadData();

				break;
			}

			//
			// Since this is a UDP socket, this is an indication
			// that a previous send failed.  Ignore it and move
			// on.
			//
			case WSAECONNRESET:
			{
				DPF( 8, "WSARecvFrom issued a WSACONNRESET!" );
				goto Reread;
				break;
			}

			case WSAENOTSOCK:
			{
					m_pSPData->GetThreadPool()->UnlockReadData();

				hr = DPNERR_GENERIC;

				DNASSERT( pReadData != NULL );

				DNASSERT( pReadData->Win9xOperationPending() != FALSE );
				pReadData->SetWin9xOperationPending( FALSE );
				pReadData->DecRef();
				pReadData = NULL;

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
			}

			//
			// there was a problem, no completion notification will
			// be given, decrement our IO reference count
			//
			default:
			{
					m_pSPData->GetThreadPool()->UnlockReadData();

				hr = DPNERR_GENERIC;
				
				//
				// 'Known Errors' that we don't want to ASSERT on.
				//
				// WSAENOTSOCKET: the socket has been closed
				// WSAESHUTDOWN: the socket has been shut down and is about to be closed
				//
				switch ( dwWSAReceiveError )
				{
					case WSAENOTSOCK:
					case WSAESHUTDOWN:
					{
						break;
					}

					default:
					{
						DPF( 0, "Problem with initial read in SocketPort::StartReceiving" );
						DisplayWinsockError( 0, dwWSAReceiveError );
						DNASSERT( FALSE );
					}
				}

				DNASSERT( pReadData != NULL );

				DNASSERT( pReadData->Win9xOperationPending() != FALSE );
				pReadData->SetWin9xOperationPending( FALSE );
				pReadData->DecRef();
				pReadData = NULL;

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
			}
		}
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendComplete - a Wisock send is complete, clean up and
//			notify user
//
// Entry:		Pointer to write data
//				Error code for this operation
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendComplete"

void	CSocketPort::SendComplete( CWriteIOData *const pWriteData, const HRESULT hResult )
{
	DNASSERT( pWriteData != NULL );
	DNASSERT( pWriteData->Win9xOperationPending() == FALSE );

#pragma	BUGBUG( johnkan, "Inline this function (except that everyone will need to know about the thread pool)!!!" )

	//
	// only signal user if requested
	//
	switch ( pWriteData->m_SendCompleteAction )
	{
		//
		// send command completion to user (most common case)
		//
		case SEND_COMPLETE_ACTION_COMPLETE_COMMAND:
		{
			DPF(8,"Completing Send Command hr %x Context %x",hResult,pWriteData->m_pCommand->GetUserContext() );
			IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet
											pWriteData->m_pCommand,						// command handle
											hResult,									// error code
											pWriteData->m_pCommand->GetUserContext()	// user cookie
											);
			break;
		}

		//
		// no action
		//
		case SEND_COMPLETE_ACTION_NONE:
		{
			if(pWriteData->m_pCommand){
				DPF(8,"Not Completing Send Command hr %x Context %x",hResult,pWriteData->m_pCommand->GetUserContext() );
			} else {
				DPF(8,"Not Completing Send Command hr %x Context NULL",hResult );
			}
			break;
		}

		//
		// Clean up after proxied enum.  The proxied enum will remove the
		// reference on the leave the receive buffer that came in on the enum.
		// The destination address that was supplied needs to be released
		// because it was allocated specifically for this task.
		//
		case SEND_COMPLETE_ACTION_PROXIED_ENUM_CLEANUP:
		{
			DNASSERT( pWriteData->m_pProxiedEnumReceiveBuffer != NULL );
			DNASSERT( pWriteData->m_pDestinationSocketAddress != NULL );

			pWriteData->m_pProxiedEnumReceiveBuffer->DecRef();
			pWriteData->m_pProxiedEnumReceiveBuffer = NULL;

			//
			// We know that this address was allocated specifically for this
			// proxied enum and we need to free it.
			//
			m_pSPData->ReturnAddress( const_cast<CSocketAddress*>( pWriteData->m_pDestinationSocketAddress ) );
			pWriteData->m_pDestinationSocketAddress = NULL;

			break;
		}

		//
		// unknown case
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	m_pThreadPool->ReturnWriteIOData( pWriteData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SetWinsockBufferSize -  set the buffer size used by Winsock for
//			this socket.
//
// Entry:		Buffer size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SetWinsockBufferSize"

void	CSocketPort::SetWinsockBufferSize( const INT iBufferSize ) const
{
	INT	iReturnValue;


	DPF( 3, "Setting socket receive buffer size to: %d", g_iWinsockReceiveBufferSize );

	iReturnValue = p_setsockopt( GetSocket(),
								 SOL_SOCKET,
								 SO_RCVBUF,
								 reinterpret_cast<char*>( &g_iWinsockReceiveBufferSize ),
								 sizeof( g_iWinsockReceiveBufferSize )
								 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		DPF( 0, "Failed to set the socket buffer receive size!" );
		DisplayWinsockError( 0, dwErrorCode );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindToNetwork - bind this socket port to the network
//
// Entry:		Handle of I/O completion port (NT only)
//				Type of socket
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToNetwork"

HRESULT	CSocketPort::BindToNetwork( const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT			hr;
	INT				iReturnValue;
	BOOL			fBroadcastFlag;
	BOOL			fBoundToNetwork;
	INT				iSendBufferSize;
	DWORD			dwBlockValue;
	CSocketAddress	*pBoundSocketAddress;


	//
	// initialize
	//
	hr = DPN_OK;
	fBoundToNetwork = FALSE;
	pBoundSocketAddress = NULL;

	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );

	//
	// get a socket for this socket port
	//
	DNASSERT( GetSocket() == INVALID_SOCKET );
	m_Socket = p_socket( m_pNetworkSocketAddress->GetFamily(),		// address family
						  SOCK_DGRAM,								// datagram (connectionless) socket
						  m_pNetworkSocketAddress->GetProtocol()	// protocol
						  );
	if ( GetSocket() == INVALID_SOCKET )
	{
		hr = DPNERR_NOCONNECTION;
		DPF( 0, "Failed to bind to socket!" );
		goto Failure;
	}

	//
	// set socket to allow broadcasts
	//
	fBroadcastFlag = TRUE;
	DBG_CASSERT( sizeof( &fBroadcastFlag ) == sizeof( char * ) );
	iReturnValue = p_setsockopt( GetSocket(),		// socket
	    						 SOL_SOCKET,		// level (set socket options)
	    						 SO_BROADCAST,		// set broadcast option
	    						 reinterpret_cast<char *>( &fBroadcastFlag ),	// allow broadcast
	    						 sizeof( fBroadcastFlag )	// size of parameter
	    						 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
	    DPF( 0, "Unable to set socket options!" );
	    DisplayWinsockError( 0, dwErrorCode );
	    hr = DPNERR_GENERIC;
	    goto Failure;
	}

	//
	// set socket receive buffer space if the user overrode it
	// Failing this is a preformance hit so ignore and errors.
	//
	if ( g_fWinsockReceiveBufferSizeOverridden != FALSE )
	{
		SetWinsockBufferSize( g_iWinsockReceiveBufferSize) ;
	}
	
	//
	// set socket send buffer space to 0 (we will supply all buffers).
	// Failing this is a preformance hit so ignore and errors.
	//
	iSendBufferSize = 0;
	iReturnValue = p_setsockopt( GetSocket(),
								 SOL_SOCKET,
								 SO_SNDBUF,
								 reinterpret_cast<char*>( &iSendBufferSize ),
								 sizeof( iSendBufferSize )
								 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		DPF( 0, "Failed to set the socket buffer send size!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

	//
	// put socket into non-block mode
	//
	dwBlockValue = 1;
	iReturnValue = p_ioctlsocket( GetSocket(),		// socket
	    						  FIONBIO,			// I/O option to set (blocking mode)
	    						  &dwBlockValue		// I/O option value (non-zero puts socked into non-block mode)
	    						  );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
	    DPF( 0, "Could not set socket into non-blocking mode!" );
	    DisplayWinsockError( 0, dwErrorCode );
	    hr = DPNERR_GENERIC;
	    goto Failure;
	}

	//
	// bind socket
	//
	DPF( 1, "Binding to socket addess:" );
	DumpSocketAddress( 1, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
	
	DNASSERT( GetSocket() != INVALID_SOCKET );
	hr = BindToNextAvailablePort( m_pNetworkSocketAddress );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Failed to bind to network!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fBoundToNetwork = TRUE;

	//
	// Find out what address we really bound to.  This information is needed to
	// talk to the PAST server and will be needed when someone above querys for
	// what the local network address is.  If we are on the PAST server, munge
	// the address to be the 'public' address, but keep the port.
	//
	pBoundSocketAddress = GetBoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
	if ( pBoundSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to get bound adapter address!" );
		goto Failure;
	}
	DPF( 1, "Socket we really bound to:" );
	DumpSocketAddress( 1, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );
	
	if ( m_pSPData->IsRsipServer() != FALSE )
	{
	    DNASSERT( m_pNetworkSocketAddress != NULL );
	    DNASSERT( m_pSPData->GetPublicSocketAddress() != NULL );
	    m_pNetworkSocketAddress->SetAddressFromSOCKADDR( *m_pSPData->GetPublicSocketAddress(),
	    												 sizeof( *( m_pSPData->GetPublicSocketAddress() ) ) );
	    m_pNetworkSocketAddress->SetPort( pBoundSocketAddress->GetPort() );
	}
	else
	{
		m_pSPData->ReturnAddress( m_pNetworkSocketAddress );
		m_pNetworkSocketAddress = pBoundSocketAddress;
		pBoundSocketAddress = NULL;
	}

	//
	// Attempt to bind to the PAST server.  If this fails, assume no PAST server
	// is present and fall back to plain NetworkSocketAddress.
	//
	DNASSERT( m_pNetworkSocketAddress != NULL );
	DNASSERT( m_pPASTSocketAddress == NULL );
	m_pPASTSocketAddress = m_pSPData->GetNewAddress();
	if ( m_pPASTSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to allocate address for PAST binding!" );
		goto Failure;
	}
	m_pPASTSocketAddress->SetAddressType( SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS );

	if ( BindToPASTServer( m_pNetworkSocketAddress, m_pPASTSocketAddress, GatewayBindType ) != DPN_OK )
	{
		m_pSPData->ReturnAddress( m_pPASTSocketAddress );
		m_pPASTSocketAddress = NULL;
		DNASSERT( m_dwPASTBindID == INVALID_PAST_BIND_ID );
	}

	//
	// start processing input messages
	// It's possible that messages will arrive before an endpoint is officially
	// bound to this socket port, but that's not a problem, the contents will
	// be lost
	//
	hr = StartReceiving();
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem starting endpoint receiving!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem in CSocketPort::Initialize()" );
		DisplayDNError( 0, hr );
	}

	if ( pBoundSocketAddress != NULL )
	{
		m_pSPData->ReturnAddress( pBoundSocketAddress );
		pBoundSocketAddress = NULL;
	}

	return hr;

Failure:
	DEBUG_ONLY( m_fInitialized = FALSE );
	if ( fBoundToNetwork != FALSE )
	{
		UnbindFromNetwork();
	}
	else
	{
		//
		// If we were bound to network, m_Socket will be reset to INVALID_SOCKET.
		// Otherwise, we will take care of this ourselves (!)
		//
		iReturnValue = p_closesocket( m_Socket );
		if ( iReturnValue == SOCKET_ERROR )
		{
			DWORD	dwErrorCode;


			dwErrorCode = p_WSAGetLastError();
			DPF( 0, "Problem closing socket!" );
			DisplayWinsockError( 0, dwErrorCode );
		}
		m_Socket = INVALID_SOCKET;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::UnbindFromNetwork - unbind this socket port from the network
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	It is assumed that this socket port's information is locked!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::UnbindFromNetwork"

HRESULT	CSocketPort::UnbindFromNetwork( void )
{
	HRESULT			hr;
	INT				iWSAReturn;
	SOCKET			TempSocket;


	//
	// initialize
	//
	hr = DPN_OK;

	TempSocket = GetSocket();
	m_Socket = INVALID_SOCKET;
	DNASSERT( TempSocket != INVALID_SOCKET );

	iWSAReturn = p_shutdown( TempSocket, SD_BOTH );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		DPF( 0, "Problem shutting down socket!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

	iWSAReturn = p_closesocket( TempSocket );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		DPF( 0, "Problem closing socket!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

	if ( m_dwPASTBindID != INVALID_PAST_BIND_ID )
	{
		DNASSERT( m_pAdapterEntry != NULL );
// BUGBUG: [mgere] [xbox] Remove RSIP
//		DNASSERT( m_pAdapterEntry->RsipModule() != NULL );
//		m_pAdapterEntry->RsipModule()->FreePort( m_dwPASTBindID );
		m_dwPASTBindID = INVALID_PAST_BIND_ID;
	}
	
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindToNextAvailablePort - bind to next available port
//
// Entry:		Pointer adapter address to bind to
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToNextAvailablePort"

HRESULT	CSocketPort::BindToNextAvailablePort( const CSocketAddress *const pNetworkAddress ) const
{
	HRESULT	hr;
	CSocketAddress	*pDuplicateNetworkAddress;

	
	DNASSERT( pNetworkAddress != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pDuplicateNetworkAddress = NULL;

	//
	// If a port was specified, try to bind to that port.  If no port was
	// specified, start walking the reserved DPlay port range looking for an
	// available port.  If none is found, let Winsock choose the port.
	//
	if ( pNetworkAddress->GetPort() != ANY_PORT )
	{
		INT	iSocketReturn;

		
		iSocketReturn = p_bind( GetSocket(),
								pNetworkAddress->GetAddress(),
								pNetworkAddress->GetAddressSize()
								);
		if ( iSocketReturn == SOCKET_ERROR )
		{
			DWORD	dwErrorCode;


			hr = DPNERR_ALREADYINITIALIZED;
			dwErrorCode = p_WSAGetLastError();
			DPF( 0, "Failed to bind socket!" );
			DisplayWinsockError( 0, dwErrorCode );
			goto Failure;
		}
	}
	else
	{
		WORD	wPort;
		INT		iSocketReturn;
		BOOL	fBound;


		fBound = FALSE;
		DNASSERT( pDuplicateNetworkAddress == NULL );
		pDuplicateNetworkAddress = m_pSPData->GetNewAddress();
		if ( pDuplicateNetworkAddress == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPF( 0, "Failed to get address for walking reserved DPlay ports!" );
			goto Failure;
		}
	
		pDuplicateNetworkAddress->CopyAddressSettings( *pNetworkAddress );

		wPort = g_wBaseDPlayPort;
		while ( ( wPort <= g_wMaxDPlayPort ) && ( fBound == FALSE ) )
		{
			pDuplicateNetworkAddress->SetPort( p_htons( wPort ) );
			iSocketReturn = p_bind( GetSocket(),
									pDuplicateNetworkAddress->GetAddress(),
									pDuplicateNetworkAddress->GetAddressSize()
									);
			if ( iSocketReturn == SOCKET_ERROR )
			{
				DWORD	dwErrorCode;


				dwErrorCode = p_WSAGetLastError();
				switch ( dwErrorCode )
				{
					case WSAEADDRINUSE:
					{
						DPF( 8, "Port in use, skipping to next port!" );
						break;
					}

					default:
					{
						hr = DPNERR_NOCONNECTION;
						DPF( 0, "Failed to bind socket!" );
						DisplayWinsockError( 0, dwErrorCode );
						goto Failure;
						
						break;
					}
				}
			}
			else
			{
				DNASSERT( hr == DPN_OK );
				fBound = TRUE;
			}

			wPort++;
		}
	
		//
		// For some reason, all of the default DPlay ports were in use, let
		// Winsock choose.  We can use the network address passed because it
		// has 'ANY_PORT'.
		//
		if ( fBound == FALSE )
		{
			INT	iSocketReturn;


			DNASSERT( pNetworkAddress->GetPort() == ANY_PORT );
			iSocketReturn = p_bind( GetSocket(),
									pNetworkAddress->GetAddress(),
									pNetworkAddress->GetAddressSize()
									);
			if ( iSocketReturn == SOCKET_ERROR )
			{
				DWORD	dwErrorCode;


				hr = DPNERR_NOCONNECTION;
				dwErrorCode = p_WSAGetLastError();
				DPF( 0, "Failed to bind socket!" );
				DisplayWinsockError( 0, dwErrorCode );
				goto Failure;
			}
		}
	}

Exit:
	if ( pDuplicateNetworkAddress != NULL )
	{
		m_pSPData->ReturnAddress( pDuplicateNetworkAddress );
		pDuplicateNetworkAddress = NULL;
	}

	return	hr;

Failure:
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindToPASTServer - bind to PAST server
//
// Entry:		Pointer to SocketAddress we bound to
//				Pointer to PAST network address to be filled in
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToPASTServer"

HRESULT	CSocketPort::BindToPASTServer( const CSocketAddress *const pBoundSocketAddress,
									   CSocketAddress *const pPASTSocketAddress,
									   const GATEWAY_BIND_TYPE GatewayBindType )
{
// BUGBUG: [mgere] [xbox] Removed RSIP
/*
	HRESULT	hr;


	DNASSERT( pBoundSocketAddress != NULL );
	DNASSERT( pPASTSocketAddress != NULL );

	hr = DPNERR_UNSUPPORTED;
	DNASSERT( GetAdapterEntry() != NULL );
	if ( GetAdapterEntry()->RsipModule() != NULL )
	{
		switch ( GatewayBindType )
		{
			//
			// ask the PAST server to listen for us (DPNSVR)
			//
			case GATEWAY_BIND_TYPE_SPECIFIC:
			{
				DPF( 0, "PAST: binding listen on server!" );
				DNASSERT( m_dwPASTBindID == INVALID_PAST_BIND_ID );
				hr = m_pAdapterEntry->RsipModule()->ListenPort( FALSE,
																pBoundSocketAddress->GetPort(),
																pPASTSocketAddress->GetWritableAddress(),
																&m_dwPASTBindID );
				if ( hr != DPN_OK )
				{
					DPF( 0, "PAST: Failed to bind listen!" );
					DumpSocketAddress( 0, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
					DisplayDNError( 0, hr );
					goto Failure;
				}
				
				DPF( 0, "Bound SPECIFIC to PAST:" );
				DumpSocketAddress( 0, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
				DumpSocketAddress( 0, pPASTSocketAddress->GetWritableAddress(), pPASTSocketAddress->GetFamily() );

				break;
			}

			//
			// just ask the server to open a generic socket for us (connect, listen, enum)
			//
			case GATEWAY_BIND_TYPE_DEFAULT:
			{
				DPF( 0, "PAST: binding to server!" );
				DNASSERT( m_dwPASTBindID == INVALID_PAST_BIND_ID );
				hr = m_pAdapterEntry->RsipModule()->AssignPort( FALSE,
																pBoundSocketAddress->GetPort(),
																pPASTSocketAddress->GetWritableAddress(),
																&m_dwPASTBindID );
				if ( hr != DPN_OK )
				{
					DPF( 0, "PAST: Failed to acquire assigned port!" );
					DumpSocketAddress( 0, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
					DisplayDNError( 0, hr );
					goto Failure;
				}
				
				DPF( 0, "Bound DEFAULT to PAST:" );
				DumpSocketAddress( 0, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
				DumpSocketAddress( 0, pPASTSocketAddress->GetWritableAddress(), pPASTSocketAddress->GetFamily() );

				break;
			}


			//
			// no binding
			//
			case GATEWAY_BIND_TYPE_NONE:
			{
				DNASSERT( hr == DPNERR_UNSUPPORTED );
				break;
			}

			//
			// unknown condition, someone broke the code!
			//
			default:
			{
				INT3;
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	DNASSERT( m_dwPASTBindID == INVALID_PAST_BIND_ID );
	goto Exit;
*/
	return E_FAIL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::StartReceiving - start receiving data on this socket port
//
// Entry:		Handle of I/O completion port to bind to (used on NT only)
//
// Exit:		Error code
//
// Notes:	There is no 'Failure' label in this function because failures need
//			to be cleaned up for each OS variant.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::StartReceiving"

HRESULT	CSocketPort::StartReceiving( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

				//
				// we're using Winsock2, call for two outstanding reads per socket.
				//
				hr = Winsock2Receive();
				if ( hr != DPN_OK )
				{
					DPF( 0, "Problem issuing Win9x read in StartReceiving!" );
					DisplayDNError( 0, hr );
					INT3;
				}
// BUGBUG: [mgere] [xbox] Calling twice doesn't work on Xbox
//
/*
				hr = Winsock2Receive();
				if ( hr != DPN_OK )
				{
					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
					DisplayDNError( 0, hr );
					INT3;
				}
*/

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::MungeAddressWithPAST - munge a socket address with PAST to turn
//		it into a local address.
//
// Entry:		Pointer to address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::MungeAddressWithPAST"

void	CSocketPort::MungeAddressWithPAST( CSocketAddress *const pSocketAddress ) const
{
	DNASSERT( pSocketAddress != NULL );

	DNASSERT( m_pAdapterEntry != NULL );
// BUGBUG: [mgere] [xbox] Removed RSIP
/*
	if ( m_pAdapterEntry->RsipModule() != NULL )
	{
		HRESULT		hr;
		SOCKADDR	SocketAddress;


		DBG_CASSERT( sizeof( SocketAddress ) == sizeof( *pSocketAddress->GetAddress() ) );
		memcpy( &SocketAddress, pSocketAddress->GetAddress(), sizeof( SocketAddress ) );
		hr = m_pAdapterEntry->RsipModule()->QueryLocalAddress( FALSE,
															   pSocketAddress->GetAddress(),
															   &SocketAddress );
		if ( hr == DPN_OK )
		{
			pSocketAddress->SetAddressFromSOCKADDR( SocketAddress, sizeof( SocketAddress ) );
		}
	}
*/
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendFromWriteQueue - send as many items as possible from the
//		write queue
//
// Entry:		Nothing
//
// Exit:		Boolean indicating that something was sent
//				TRUE = data was sent
//				FALSE = no data was sent
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendFromWriteQueue"

BOOL	CSocketPort::SendFromWriteQueue( void )
{
	BOOL					fDataSent;
	CWriteIOData			*pWriteData;
	SEND_COMPLETION_CODE	TempCompletionCode;	


	DPF(8,"SendFromWriteQueue");

	//
	// initialize
	//
	fDataSent = FALSE;
	TempCompletionCode = SEND_IN_PROGRESS;

	m_SendQueue.Lock();
	pWriteData = m_SendQueue.Dequeue();
	DPF(8,"WriteData %p",pWriteData);
	m_SendQueue.Unlock();

	while ( ( pWriteData != NULL ) && ( TempCompletionCode == SEND_IN_PROGRESS ) )
	{
		pWriteData->m_pCommand->Lock();
		switch ( pWriteData->m_pCommand->GetState() )
		{
			//
			// command is still pending, attempt to send the data
			//
			case COMMAND_STATE_PENDING:
			{
				DPF(8,"COMMAND_STATE_PENDING");
				TempCompletionCode = (this->*m_pSendFunction)( pWriteData );
				DPF(8,"TempCompletionCode %x",TempCompletionCode);
				switch ( TempCompletionCode )
				{
					//
					// We managed to get this send going.  It's already been removed
					// from the queue.  Get the next item from the queue and restart
					// the loop.
					//
					case SEND_IN_PROGRESS:
					{
						DPF(8,"Send In Progress, going ok, so getting another");
						pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pWriteData->m_pCommand->Unlock();
						
						m_SendQueue.Lock();
						pWriteData = m_SendQueue.Dequeue();
						DPF(8,"(SIP) WriteData %p",pWriteData);
						m_SendQueue.Unlock();

						fDataSent = TRUE;
						break;
					}

					//
					// Winsock is still busy, put this item back at the front of
					// the queue.  Clear 'pWriteData' to stop the loop.
					//
					case SEND_WINSOCK_BUSY:
					{
						DPF(8,"Winsock Busy, requeuing for later");
						DNASSERT( pWriteData->m_pCommand->GetState() == COMMAND_STATE_PENDING );
						m_SendQueue.Lock();
						m_SendQueue.AddToFront( pWriteData );
						m_SendQueue.Unlock();
						pWriteData->m_pCommand->Unlock();
						pWriteData = NULL;

						break;
					}

					//
					// send failed, try sending the next item
					//
					case SEND_FAILED:
					{
						DPF(8,"Send Failed");
						pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pWriteData->m_pCommand->Unlock();

						SendComplete( pWriteData, DPNERR_GENERIC );

						m_SendQueue.Lock();
						pWriteData = m_SendQueue.Dequeue();
						m_SendQueue.Unlock();

						break;
					}

					//
					// invalid return
					//
					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}

				break;
			}

			//
			// This command is to be cancelled, remove it from the queue
			// and issue completion notification to caller.  Then we can
			// look at the next item.
			//
			case COMMAND_STATE_CANCELLING:
			{
				pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
				pWriteData->m_pCommand->Unlock();

				SendComplete( pWriteData, DPNERR_USERCANCEL );

				m_SendQueue.Lock();
				pWriteData = m_SendQueue.Dequeue();
				m_SendQueue.Unlock();

				break;
			}

			//
			// invalid command state
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	return	fDataSent;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::AddToMulticastGroup - add a socket to a multicast group
//
// Entry:		Pointer to multicast group data
//				Size of multicast group data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::AddToMulticastGroup"

HRESULT	CSocketPort::AddToMulticastGroup( const void *const pGroupData, const UINT_PTR uGroupDataSize )
{
	HRESULT			hr;


	DNASSERT( pGroupData != NULL );
	DNASSERT( uGroupDataSize != 0 );

	DNASSERT( uGroupDataSize <= UINT32_MAX );
	hr = m_pNetworkSocketAddress->AddToMulticastGroup( pGroupData,
													   static_cast<DWORD>( uGroupDataSize ),
													   GetSocket() );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem adding socket port to multicast group!" );
		DisplayDNError( 0, hr );
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::GetBoundNetworkAddress - get the full network address that
//		this socket port was really bound to
//
// Entry:		Address type for bound address
//
// Exit:		Pointer to network address
//
// Note:	Since this function creates a local address to derive the network
//			address from, it needs to know what kind of address to derive.  This
//			address type is supplied as the function parameter.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::GetBoundNetworkAddress"

CSocketAddress	*CSocketPort::GetBoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const
{
	HRESULT			hr;
	CSocketAddress	*pTempSocketAddress;
	SOCKADDR		BoundSocketAddress;
	INT_PTR			iReturnValue;
	INT				iBoundSocketAddressSize;


#pragma	BUGBUG( johnkan, "Speed this up!" )

	//
	// initialize
	//
	pTempSocketAddress = NULL;

	//
	// create addresses
	//
	pTempSocketAddress = m_pSPData->GetNewAddress();
	if ( pTempSocketAddress == NULL )
	{
		DPF( 0, "GetBoundNetworkAddress: Failed to create socket address!" );
		goto Failure;
	}

	//
	// find out what address we really bound to and reset the information for
	// this socket port
	//
	iBoundSocketAddressSize = pTempSocketAddress->GetAddressSize();
	iReturnValue = p_getsockname( GetSocket(), &BoundSocketAddress, &iBoundSocketAddressSize );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		hr = DPNERR_GENERIC;
		DPF( 0, "GetBoundNetworkAddress: Failed to get local socket name after bind!" );
		DisplayWinsockError( 0, dwErrorCode );
		goto Failure;
	}
	pTempSocketAddress->SetAddressFromSOCKADDR( BoundSocketAddress, iBoundSocketAddressSize );
	DNASSERT( iBoundSocketAddressSize == pTempSocketAddress->GetAddressSize() );

	//
	// Since this address was created locally, we need to tell it what type of
	// address to export according to the input.
	//
	pTempSocketAddress->SetAddressType( AddressType );

	switch ( AddressType )
	{
		//
		//  known types
		//
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		case SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET:
		case SP_ADDRESS_TYPE_HOST:
		case SP_ADDRESS_TYPE_READ_HOST:
		{
			break;
		}

		//
		// if we're looking for a public address, we need to make sure that this
		// is not an undefined address.  If it is, don't return an address.
		// Otherwise, remap the address type to a 'host' address.
		//
		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		{
			if ( pTempSocketAddress->IsUndefinedHostAddress() != FALSE )
			{
				m_pSPData->ReturnAddress( pTempSocketAddress );
				pTempSocketAddress = NULL;
			}
			else
			{
				pTempSocketAddress->SetAddressType( SP_ADDRESS_TYPE_HOST );
			}

			break;
		}

		//
		// unknown address type, fix the code!
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}

	}

Exit:
	return	pTempSocketAddress;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::GetDP8BoundNetworkAddress - get the network address this machine
//		is bound to according to the input paramter.  If the requested address
//		is a public address and PAST is available, use the PAST address.  If a
//		public address is requested and PAST is unavailable, fall back to the
//		bound network address.
//
// Entry:		Type of address to get (local adapter vs. host)
//
// Exit:		Pointer to network address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::GetDP8BoundNetworkAddress"

IDirectPlay8Address *CSocketPort::GetDP8BoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const
{
	IDirectPlay8Address	*pAddress;


	//
	// initialize
	//
	pAddress = NULL;
	
	if ( ( m_pPASTSocketAddress != NULL ) &&
		 ( ( AddressType == SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS ) ||
		   ( AddressType == SP_ADDRESS_TYPE_HOST ) ) )		
	{
		pAddress = m_pPASTSocketAddress->DP8AddressFromSocketAddress();
	}
	else
	{
		DNASSERT( m_pNetworkSocketAddress != NULL );
		switch ( AddressType )
		{
			case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
			{
				pAddress = m_pNetworkSocketAddress->DP8AddressFromSocketAddress();
				break;
			}

			case SP_ADDRESS_TYPE_HOST:
			case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
			{
				CSocketAddress	*pTempAddress;


				pTempAddress = m_pSPData->GetNewAddress();
				if ( pTempAddress != NULL )
				{
					pTempAddress->CopyAddressSettings( *m_pNetworkSocketAddress );
					pTempAddress->SetAddressType( SP_ADDRESS_TYPE_HOST );
					pAddress = pTempAddress->DP8AddressFromSocketAddress();
				
					m_pSPData->ReturnAddress( pTempAddress );
				}
				else
				{
					DNASSERT( pAddress == NULL );
				}

				break;
			}

			//
			// shouldn't be here
			//
			default:
			{
				INT3;
				break;
			}
		}
	}

	return	pAddress;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::RemoveFromMulticastGroup - remove socket from multicast group
//
// Entry:		Pointer to group data
//				Size of group data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::RemoveFromMulticastGroup"

HRESULT	CSocketPort::RemoveFromMulticastGroup( const void *const pGroupData, const UINT_PTR uGroupDataSize )
{
	HRESULT	hr;


	DNASSERT( pGroupData != NULL );
	DNASSERT( uGroupDataSize != 0 );

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( uGroupDataSize <= UINT32_MAX );
	hr = m_pNetworkSocketAddress->RemoveFromMulticastGroup( pGroupData,
															static_cast<DWORD>( uGroupDataSize ),
															GetSocket() );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem removing socket port from multicast group!" );
		DisplayDNError( 0, hr );
	}

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2ReceiveComplete - a Winsock2 socket receive completed
//
// Entry:		Poiner to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2ReceiveComplete"

void	CSocketPort::Winsock2ReceiveComplete( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );

	//
	// initialize
	//
	DNASSERT( pReadData->Win9xOperationPending() == FALSE );

	//
	// figure out what's happening with this socket port
	//
	switch ( m_State )
	{
		//
		// we're unbound, discard this message and don't ask for any more
		//
		case SOCKET_PORT_STATE_UNBOUND:
		{
			goto Exit;
			break;
		}

		//
		// we're initialized, process input data and submit a new receive if
		// applicable
		//
		case SOCKET_PORT_STATE_INITIALIZED:
		{
			switch ( pReadData->m_Win9xReceiveWSAReturn )
			{
				//
				// the socket was closed on an outstanding read, stop
				// receiving
				//
				case WSAENOTSOCK:					// WinNT return for closed socket
				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
				{
					break;
				}

				//
				// other error, perform another receive and process data if
				// applicable
				//
				default:
                {
					//
					// stop if the error isn't 'expected'
					//
					switch ( pReadData->m_Win9xReceiveWSAReturn )
					{
						// BUGBUG: [mgere] [xbox] WSAEINPROGRESS indicates a second overlapped receive was not allowed.
						// Ignore this but don't start another receive.  Make sure this works.
						case WSAEINPROGRESS:
						{
							break;
						}

						//
						// ERROR_SUCCESS = no problem (process received data)
						// WSAECONNRESET = previous send failed
						// ERROR_PORT_UNREACHABLE = previous send failed
						// ERROR_MORE_DATA = datagram was sent that was too large
						// ERROR_FILE_NOT_FOUND = socket was closed or previous send failed
						//
						case WSAECONNRESET:
						case ERROR_SUCCESS:
						case ERROR_PORT_UNREACHABLE:
						case ERROR_MORE_DATA:
						case ERROR_FILE_NOT_FOUND:
						{
							Winsock2Receive();
							break;
						}

						default:
						{
							DPF( 0, "Unexpected return from WSARecvFrom()" );
							DisplayErrorCode( 0, pReadData->m_Win9xReceiveWSAReturn );
							INT3;
							break;
						}
					}

					if ( pReadData->m_Win9xReceiveWSAReturn == ERROR_SUCCESS )
                    {
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
						ProcessReceivedData( pReadData );
					}

					break;
				}
			}

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	//
	// Return the current data to the pool and note that this I/O operation is
	// complete.  Clear the overlapped bytes received so they aren't misinterpreted
	// if this item is reused from the pool.
	//
	DNASSERT( pReadData != NULL );
	pReadData->m_dwOverlappedBytesReceived = 0;	
	pReadData->DecRef();	
	DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::CancelReceive - cancel a pending receive
//
// Entry:		Poiner to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::CancelReceive"

void	CSocketPort::CancelReceive( CReadIOData *const pRead )
{
	DNASSERT( pRead != NULL );

	pRead->DecRef();
	DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::ProcessReceivedData - process received data
//
// Entry:		Pointer to CReadIOData
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::ProcessReceivedData"

void	CSocketPort::ProcessReceivedData( CReadIOData *const pReadData )
{
	PREPEND_BUFFER	*pPrependBuffer;
	HANDLE		hEndpoint;
	CEndpoint	*pEndpoint;


	DNASSERT( pReadData != NULL );

//	DPF( 0, "Processing data from:" );
//	DumpSocketAddress( 0, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily() );
	
	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( PREPEND_BUFFER* ) );
	pPrependBuffer = reinterpret_cast<PREPEND_BUFFER*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData );

	//
	// Check data for integrity and decide what to do with it.  If there is
	// enough data to determine an SP command type, try that.  If there isn't
	// enough data, and it looks spoofed, reject it.
	//
	if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->GenericHeader ) )
	{
		if ( pPrependBuffer->GenericHeader.bSPLeadByte != SP_HEADER_LEAD_BYTE )
		{
			goto ProcessUserData;
		}
		else
		{
			switch ( pPrependBuffer->GenericHeader.bSPCommandByte )
			{
				//
				// Normal data, the user's first byte matched the service
				// provider tag byte.  Check for a non-zero payload and skip the
				// header that was added.
				//
				case ESCAPED_USER_DATA_KIND:
				{
					if ( ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EscapedUserDataHeader ) ) &&
						 ( pPrependBuffer->EscapedUserDataHeader.wPad == ESCAPED_USER_DATA_PAD_VALUE ) )
					{
						pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EscapedUserDataHeader ) ];
						DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EscapedUserDataHeader ) );
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EscapedUserDataHeader );
						goto ProcessUserData;
					}

					break;
				}

				//
				// Enum data, send it to the active listen (if there's one).  Allow users to send
				// enum requests that contain no data.
				//
				case ENUM_DATA_KIND:
				{
					if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumDataHeader ) )
					{
						LockEndpointData();
						if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
						{
							CEndpoint	*pEndpoint;


							//
							// add a reference to this endpoint so it doesn't go away while we're processing
							// this data
							//
							pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
							UnlockEndpointData();
							
							if ( pEndpoint != NULL )
							{
								//
								// skip prepended enum header
								//
								pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EnumDataHeader ) ];
								DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumDataHeader ) );
								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EnumDataHeader );

								//
								// process data
								//
								pEndpoint->ProcessEnumData( pReadData->ReceivedBuffer(),
															pPrependBuffer->EnumDataHeader.wEnumPayload,
															pReadData->m_pSourceSocketAddress );
								pEndpoint->DecCommandRef();
							}
						}
						else
						{
							//
							// there's no listen active, return the receive buffer to the pool
							//
							UnlockEndpointData();
						}
					}

					break;
				}

				//
				// Enum response data, find the appropriate enum and pass it on.  Allow users to send
				// enum responses that contain no data.
				//
				case ENUM_RESPONSE_DATA_KIND:
				{
					if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumResponseDataHeader ) )
					{
						CEndpointEnumKey	Key;
						HANDLE				hEndpoint;


						Key.SetKey( pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload );
						LockEndpointData();
						if ( m_EnumEndpointList.Find( &Key, &hEndpoint ) != FALSE )
						{
							CEndpoint	*pEndpoint;


							UnlockEndpointData();

							DNASSERT( hEndpoint != INVALID_HANDLE_VALUE );
							pEndpoint = m_pSPData->EndpointFromHandle( hEndpoint );
							if ( pEndpoint != NULL )
							{
								pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EnumResponseDataHeader ) ];
								DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EnumResponseDataHeader ) );
								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EnumResponseDataHeader );

								pEndpoint->ProcessEnumResponseData( pReadData->ReceivedBuffer(),
																	pReadData->m_pSourceSocketAddress,
																	( pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload & ENUM_RTT_MASK ) );
								pEndpoint->DecCommandRef();
							}
						}
						else
						{
							//
							// the associated ENUM doesn't exist, return the receive buffer
							//
							UnlockEndpointData();
						}
					}
	
					break;
				}

				//
				// proxied query data, this data was forwarded from another port.  Munge
				// the return address, modify the buffer pointer and then send it up
				// through the normal enum data processing pipeline.
				//
				case PROXIED_ENUM_DATA_KIND:
				{
					if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->ProxiedEnumDataHeader ) )
					{
						LockEndpointData();
						if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
						{
							CEndpoint	*pEndpoint;


							//
							// add a reference to this endpoint so it doesn't go
							// away while we're processing this data
							//
							pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
							UnlockEndpointData();
	
							if ( pEndpoint != NULL )
							{
								pReadData->m_pSourceSocketAddress->SetAddressFromSOCKADDR( pPrependBuffer->ProxiedEnumDataHeader.ReturnAddress,
																						   pReadData->m_pSourceSocketAddress->GetAddressSize() );

								pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->ProxiedEnumDataHeader ) ];

								DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->ProxiedEnumDataHeader ) );
								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->ProxiedEnumDataHeader );

								pEndpoint->ProcessEnumData( pReadData->ReceivedBuffer(),
															pPrependBuffer->ProxiedEnumDataHeader.wEnumKey,
															pReadData->m_pSourceSocketAddress );
								pEndpoint->DecCommandRef();
							}
						}
						else
						{
							//
							// there's no listen active, return the receive buffer to the pool
							//
							UnlockEndpointData();
						}
					}
		
					break;
				}
			}
		}
	}
	else	// pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->GenericHeader
	{
		if ( ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize == 1 ) &&
			 ( pPrependBuffer->GenericHeader.bSPLeadByte != SP_HEADER_LEAD_BYTE ) )
		{
			goto ProcessUserData;
		}
	}

Exit:
	return;

ProcessUserData:
	//	
	// If there's an active connection, send it to the connection.  If there's
	// no active connection, send it to an available 'listen' to indicate a
	// potential new connection.	
	//
	LockEndpointData();
	DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize != 0 );
	
	if ( m_ConnectEndpointList.Find( pReadData->m_pSourceSocketAddress, &hEndpoint ) != FALSE )
	{
		UnlockEndpointData();
		
		DNASSERT( hEndpoint != INVALID_HANDLE_VALUE );
		pEndpoint = m_pSPData->EndpointFromHandle( hEndpoint );

		if ( pEndpoint != NULL )
		{
			pEndpoint->ProcessUserData( pReadData );
			pEndpoint->DecCommandRef();
		}
	}
	else
	{
		if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
		{
			CEndpoint	*pEndpoint;


			pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
			UnlockEndpointData();

			if ( pEndpoint != NULL )
			{
				pEndpoint->ProcessUserDataOnListen( pReadData, pReadData->m_pSourceSocketAddress );
				pEndpoint->DecCommandRef();
			}
		}
		else
		{
			//
			// nobody claimed this data, return the receive buffer to the
			// pool before exiting because we're supposed to.
			//
			UnlockEndpointData();
		}
	}

	goto Exit;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\threadpool.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ThreadPool.cpp
 *  Content:	main job thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// events for threads
//
enum
{
	EVENT_INDEX_STOP_ALL_THREADS = 0,
	EVENT_INDEX_PENDING_JOB = 1,
	EVENT_INDEX_WAKE_NT_TIMER_THREAD = 1,
	EVENT_INDEX_WINSOCK_2_SEND_COMPLETE = 2,
	EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE = 3,

	EVENT_INDEX_MAX
};

//
// times to wait in milliseconds when polling for work thread shutdown
//
#define	WORK_THREAD_CLOSE_SLEEP_TIME	100

//
// select polling period for writes (milliseconds)
//
static const DWORD	g_dwSelectTimeSlice = 2;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct	_TIMER_OPERATION_ENTRY
{
	CBilink		Linkage;			// list links
	void		*pContext;			// user context passed back in timer events

	//
	// timer information
	//
	UINT_PTR	uRetryCount;		// number of times to retry this event
	BOOL		fRetryForever;		// Boolean for retrying forever
	DN_TIME		RetryInterval;		// time between enums (milliseconds)
	DN_TIME		IdleTimeout;		// time at which the command sits idle after all retrys are complete
	BOOL		fIdleWaitForever;	// Boolean for waiting forever in idle state
	DN_TIME		NextRetryTime;		// time at which this event will fire next (milliseconds)

	TIMER_EVENT_CALLBACK	*pTimerCallback;	// callback for when this event fires
	TIMER_EVENT_COMPLETE	*pTimerComplete;	// callback for when this event is complete

	#undef DPF_MODNAME
	#define	DPF_MODNAME	"_TIMER_OPERATION_ENTRY::TimerOperationFromLinkage"
	static TIMER_OPERATION_ENTRY	*TimerOperationFromLinkage( CBilink *const pLinkage )
	{
		DNASSERT( pLinkage != NULL );
		DBG_CASSERT( OFFSETOF( _TIMER_OPERATION_ENTRY, Linkage ) == 0 );
		return	reinterpret_cast<_TIMER_OPERATION_ENTRY*>( pLinkage );
	}

} TIMER_OPERATION_ENTRY;

//
// structure for common data in Win9x thread
//
typedef	struct	_WIN9X_CORE_DATA
{
	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
	DWORD		dwTimeToNextJob;					// time to next job
	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
	BOOL		fLooping;							// Boolean indicating that this thread is still running

} WIN9X_CORE_DATA;

//
// information passed to the Win9x workhorse thread
//
typedef struct	_WIN9X_THREAD_DATA
{
	CThreadPool		*pThisThreadPool;	// pointer to this object
} WIN9X_THREAD_DATA;


//**********************************************************************
// Variable definitions
//**********************************************************************

extern CRITICAL_SECTION g_csSocketAccessLock;
extern CThreadPool *g_pThreadPool2;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CThreadPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CThreadPool"

CThreadPool::CThreadPool():
		m_iRefCount( 0 ),
		m_hStopAllThreads( NULL ),
		m_hWinsock2SendComplete( NULL ),
		m_hWinsock2ReceiveComplete( NULL ),
                m_hThreadCloseEvent( NULL ),
		m_uReservedSocketCount( 0 )
{
	memset( &m_SocketSet, 0x00, sizeof( m_SocketSet ) );
	m_OutstandingReadList.Initialize();
	m_OutstandingWriteList.Initialize();
	m_TimerJobList.Initialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::~CThreadPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::~CThreadPool"

CThreadPool::~CThreadPool()
{
	DNASSERT( m_iRefCount == 0 );
	DNASSERT( m_hStopAllThreads == NULL );
	DNASSERT( m_hWinsock2SendComplete == NULL );
	DNASSERT( m_hWinsock2ReceiveComplete == NULL );

	DNASSERT( m_uReservedSocketCount == 0 );
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( m_TimerJobList.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Initialize - initialize work threads
//
// Entry:		Nothing
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Initialize"

HRESULT	CThreadPool::Initialize( void )
{
	HRESULT			hr;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );


	if ( DNInitializeCriticalSection( &m_ReadDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Win9x has poor APC support and as part of the workaround, the read data
	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
	//
	DEBUG_ONLY( 
						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
	)


	if ( DNInitializeCriticalSection( &m_WriteDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Win9x has poor APC support and as part of the workaround, the write data
	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
	//
	DEBUG_ONLY(
						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
	)


	if ( DNInitializeCriticalSection( &m_JobDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_JobDataLock, 0 );

	if ( DNInitializeCriticalSection( &m_TimerDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_TimerDataLock, 1 );

	//
	// initialize job queue
	//
	if ( m_JobQueue.Initialize() == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// initialize pools
	//

	// pool of IP read requests
	m_IPReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
								   CReadIOData::ReadIOData_Get,
								   CReadIOData::ReadIOData_Release,
								   CReadIOData::ReadIOData_Dealloc
								   );

	// pool of write requests
	m_WriteIODataPool.Initialize( CWriteIOData::WriteIOData_Alloc,
								  CWriteIOData::WriteIOData_Get,
								  CWriteIOData::WriteIOData_Release,
								  CWriteIOData::WriteIOData_Dealloc
								  );

	// job pool
	if ( FPM_Initialize( &m_JobPool,					// pointer to pool
						 sizeof( THREAD_POOL_JOB ),		// size of pool entry
						 WorkThreadJob_Alloc,			// function called on pool entry initial allocation
						 WorkThreadJob_Get,				// function called on entry extraction from pool
						 WorkThreadJob_Release,			// function called on entry return to pool
						 WorkThreadJob_Dealloc			// function called on entry free
						 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// enum entry pool
	if ( FPM_Initialize( &m_TimerEntryPool,					// pointer to pool
						 sizeof( TIMER_OPERATION_ENTRY ),	// size of pool entry
						 TimerEntry_Alloc,					// function called on pool entry initial allocation
						 TimerEntry_Get,					// function called on entry extraction from pool
						 TimerEntry_Release,				// function called on entry return to pool
						 TimerEntry_Dealloc					// function called on entry free
						 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Create event to stop all threads.  Win9x needs this to stop processing
	// and the NT enum thread uses this to stop processing
	//
	DNASSERT( m_hStopAllThreads == NULL );
	m_hStopAllThreads = CreateEvent( NULL,		// pointer to security (none)
									 TRUE,		// manual reset
									 FALSE,		// start unsignalled
									 NULL );	// pointer to name (none)
	if ( m_hStopAllThreads == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to create event to stop all threads!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

			hr = Win9xInit();
			if ( hr != DPN_OK )
			{
				goto Failure;
			}

Exit:
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with CreateWorkThreads" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	StopAllThreads();
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Win9xInit - initialize Win9x components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Win9xInit"

HRESULT	CThreadPool::Win9xInit( void )
{
	HRESULT				hr;
#ifndef DPLAY_DOWORK
	HANDLE				hPrimaryThread;
	DWORD				dwPrimaryThreadID;
	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
	hPrimaryThread = NULL;
	pPrimaryThreadInput = NULL;
#endif

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// Win9x requires completion events for Winsock2.  Always allocate the
	// events even though the they might not be used.
	//
	DNASSERT( m_hWinsock2SendComplete == NULL );
	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
										   TRUE,	// manual reset
										   FALSE,	// start unsignalled
										   NULL		// pointer to name (none)
										   );
	if ( m_hWinsock2SendComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to create event for Winsock2Send!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
											  TRUE,		// manual reset
											  FALSE,	// start unsignalled
											  NULL		// pointer to name (none)
											  );
	if ( m_hWinsock2ReceiveComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to create event for Winsock2Receive!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	m_hThreadCloseEvent = CreateEvent( NULL,		// pointer to security (none)
											  TRUE,		// manual reset
											  FALSE,	// start unsignalled
											  NULL		// pointer to name (none)
											  );
	if ( m_hThreadCloseEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to create event for ThreadClose!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	ResetEvent(m_hThreadCloseEvent);


#ifndef DPLAY_DOWORK
	//
	// create parameters to worker threads
	//
	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
	if ( pPrimaryThreadInput == NULL )
	{
		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
	pPrimaryThreadInput->pThisThreadPool = this;
	
	//
	// Create one worker thread and boost its priority.  If the primary thread
	// can be created and boosted, create a secondary thread.  Do not create a
	// secondary thread if the primary could not be boosted because the system
	// is probably low on resources.
	//
	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
								   0,						// stack size (default)
								   PrimaryWin9xThread,		// pointer to thread function
								   pPrimaryThreadInput,		// pointer to input parameter
								   0,						// let it run
								   &dwPrimaryThreadID		// pointer to destination of thread ID
								   );
	if ( hPrimaryThread == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Problem creating Win9x thread!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;

		goto Failure;
	}
	pPrimaryThreadInput = NULL;

	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: 1", dwPrimaryThreadID);
	DNASSERT( hPrimaryThread != NULL );
	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
		DisplayErrorCode( 0, dwError );
	}
#endif

Exit:
#ifndef DPLAY_DOWORK
	if ( pPrimaryThreadInput != NULL )
	{
		DNFree( pPrimaryThreadInput );
		pPrimaryThreadInput = NULL;
	}

	if ( hPrimaryThread != NULL )
	{
		if ( CloseHandle( hPrimaryThread ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Problem closing Win9x thread hanle!" );
			DisplayErrorCode( 0, dwError );
		}

		hPrimaryThread = NULL;
	}
#endif

	return	hr;

Failure:
	SetEvent(m_hThreadCloseEvent);

	DPF( 0, "Failed Win9x Initialization!" );
	DisplayDNError( 0, hr );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopAllThreads - stop all work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:		This function blocks until all threads complete!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopAllThreads"

void	CThreadPool::StopAllThreads( void )
{
	//
	// stop all non-I/O completion threads
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( SetEvent( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Failed to set event to stop all threads!" );
			DisplayErrorCode( 0, dwError );
		}
	}
#ifdef DPLAY_DOWORK
	//
	// check for outstanding threads (no need to lock thread pool count)
	//
	while (1)
	{
		switch (WaitForSingleObject(m_hThreadCloseEvent,0))
		{
			case WAIT_TIMEOUT:
			{
            	if (g_pThreadPool2 != NULL)
	            {
		            g_pThreadPool2->PrimaryWin9xThread();
	            }
				break;
			}

            case WAIT_OBJECT_0:
			{
				return;
			}
		}
	}
#else
	WaitForSingleObject(m_hThreadCloseEvent,INFINITE);
#endif
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelOutstandingJobs - cancel outstanding jobs
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CancelOutstandingJobs"

void	CThreadPool::CancelOutstandingJobs( void )
{
	m_JobQueue.Lock();

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pJob;


		pJob = m_JobQueue.DequeueJob();
		DNASSERT( pJob != NULL );
		DNASSERT( pJob->pCancelFunction != NULL );
		pJob->pCancelFunction( pJob );
		pJob->JobType = JOB_UNINITIALIZED;
		m_JobPool.Release( &m_JobPool, pJob );
	};

	m_JobQueue.Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelOutstandingIO - cancel outstanding IO
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CancelOutstandingIO"

void	CThreadPool::CancelOutstandingIO( void )
{
	CBilink	*pTemp;

	//
	// stop any receives with the notification that Winsock is shutting down.
	//
	pTemp = m_OutstandingReadList.GetNext();
	while ( pTemp != &m_OutstandingReadList )
	{
		CReadIOData	*pReadData;


		pReadData = CReadIOData::ReadDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pReadData->m_OutstandingReadListLinkage.RemoveFromList();
		
		DEBUG_ONLY( if ( pReadData->m_fRetainedByHigherLayer != FALSE )
					{
						INT3;
					}
				  );		
		DNASSERT( pReadData->Win9xOperationPending() != FALSE );
		pReadData->SetWin9xOperationPending( FALSE );
		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
		pReadData->m_dwOverlappedBytesReceived = 0;
		pReadData->SocketPort()->CancelReceive( pReadData );
	}

	//
	// stop any pending writes with the notification that the user cancelled it.
	//
	pTemp = m_OutstandingWriteList.GetNext();
	while ( pTemp != &m_OutstandingWriteList )
	{
		CWriteIOData	*pWriteData;
		CSocketPort		*pSocketPort;


		pWriteData = CWriteIOData::WriteDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();

		DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
		pWriteData->SetWin9xOperationPending( FALSE );
		pSocketPort = pWriteData->SocketPort();
		pSocketPort->SendComplete( pWriteData, DPNERR_USERCANCEL );
		pSocketPort->DecRef();
	}

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pJob;


		pJob = m_JobQueue.DequeueJob();
		DNASSERT( pJob != NULL );
		DNASSERT( pJob->pCancelFunction != NULL );
		pJob->pCancelFunction( pJob );
		pJob->JobType = JOB_UNINITIALIZED;
		m_JobPool.Release( &m_JobPool, pJob );
	};
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ReturnSelfToPool"

void	CThreadPool::ReturnSelfToPool( void )
{
	Deinitialize();
	ReturnThreadPool( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Deinitialize - destroy work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Deinitialize"

void	CThreadPool::Deinitialize( void )
{
	g_pThreadPool2 = NULL;

	DNASSERT( m_JobQueue.IsEmpty() != FALSE );

	//
	// close StopAllThreads handle
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( CloseHandle( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Failed to close StopAllThreads handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hStopAllThreads = NULL;
	}

	//
	// close handles for I/O events
	//
	if ( m_hWinsock2SendComplete != NULL )
	{
		if ( CloseHandle( m_hWinsock2SendComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Problem closing Winsock2SendComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hWinsock2SendComplete = NULL;
	}

	if ( m_hWinsock2ReceiveComplete != NULL )
	{
		if ( CloseHandle( m_hWinsock2ReceiveComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Problem closing Winsock2ReceiveComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hWinsock2ReceiveComplete = NULL;
	}

//	//
//	// Now that all of the threads are stopped, clean up any outstanding I/O.
//	// this can be done without taking any locks
//	//
//	CancelOutstandingIO();	

	//
	// deinitialize pools
	//

	// timer entry pool
	FPM_Deinitialize( &m_TimerEntryPool );

	// job pool
	FPM_Deinitialize( &m_JobPool );

	// write data pool
	DNASSERT( m_OutstandingWriteList.IsEmpty() != FALSE );
	m_WriteIODataPool.Deinitialize();

	// read data pool
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
	m_IPReadIODataPool.Deinitialize();

	//
	// deinitialize job queue
	//
	m_JobQueue.Deinitialize();

	DNDeleteCriticalSection( &m_TimerDataLock );
	DNDeleteCriticalSection( &m_JobDataLock );
	DNDeleteCriticalSection( &m_WriteDataLock );
	DNDeleteCriticalSection( &m_ReadDataLock );
	DNDeleteCriticalSection( &m_Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopAllIO - stop all IO from the thread pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopAllIO"

void	CThreadPool::StopAllIO( void )
{

	StopAllThreads();

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pThreadPoolJob;


		pThreadPoolJob = GetWorkItem();
		DNASSERT( pThreadPoolJob != NULL );
		pThreadPoolJob->pCancelFunction( pThreadPoolJob );
		pThreadPoolJob->JobType = JOB_UNINITIALIZED;

		m_JobPool.Release( &m_JobPool, pThreadPoolJob );
	}

	//
	// Now that all of the threads are stopped, clean up any outstanding I/O.
	// this can be done without taking any locks
	//
	CancelOutstandingIO();	
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetNewReadIOData - get new read request from pool
//
// Entry:		Pointer to context
//
// Exit:		Pointer to new read request
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetNewReadIOData"

CReadIOData	*CThreadPool::GetNewReadIOData( READ_IO_DATA_POOL_CONTEXT *const pContext )
{
	CReadIOData		*pTempReadData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pTempReadData = NULL;
	pContext->pThreadPool = this;

	LockReadData();

			pTempReadData = m_IPReadIODataPool.Get( pContext );
	
	if ( pTempReadData == NULL )
	{
		DPF( 0, "Failed to get new ReadIOData from pool!" );
		goto Failure;
	}

	//
	// we have data, immediately add a reference to it
	//
	pTempReadData->AddRef();

	DNASSERT( pTempReadData->m_pSourceSocketAddress != NULL );

	//
	// now that the read data is initialized, add it to the
	// unbound list
	//
	pTempReadData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );

Exit:
	UnlockReadData();

	return pTempReadData;

Failure:
	if ( pTempReadData != NULL )
	{
		pTempReadData->DecRef();
		pTempReadData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnReadIOData - return read data item to pool
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ReturnReadIOData"

void	CThreadPool::ReturnReadIOData( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );
	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );

	//
	// remove this item from the unbound list and return it to the pool
	//
	LockReadData();

	pReadData->m_OutstandingReadListLinkage.RemoveFromList();
	DNASSERT( pReadData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	
	switch ( pReadData->m_pSourceSocketAddress->GetFamily() )
	{
		//
		// IP
		//
		case AF_INET:
		{
			m_IPReadIODataPool.Release( pReadData );
			break;
		}

		//
		// unknown type (shouldn't be here!)
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	UnlockReadData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTimerJobs - process timed jobs
//
// Entry:		Pointer to job list
//				Pointer to destination for time of next job
//
// Exit:		Boolean indicating active timer jobs exist
//				TRUE = there are active jobs
//				FALSE = there are no active jobs
//
// Notes:	The input job queue is expected to be locked for the duration
//			of this function call!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessTimerJobs"

BOOL	CThreadPool::ProcessTimerJobs( const CBilink *const pJobList, DN_TIME *const pNextJobTime )
{
	BOOL		fReturn;
	CBilink		*pWorkingEntry;
	INT_PTR		iActiveTimerJobCount;
	DN_TIME		CurrentTime;


	DNASSERT( pJobList != NULL );
	DNASSERT( pNextJobTime != NULL );

	//
	// Initialize.  Set the next job time to be infinitely far in the future
	// so this thread will wake up for any jobs that need to completed before
	// then.
	//
	fReturn = FALSE;
	DBG_CASSERT( OFFSETOF( TIMER_OPERATION_ENTRY, Linkage ) == 0 );
	pWorkingEntry = pJobList->GetNext();
	iActiveTimerJobCount = 0;
	memset( pNextJobTime, 0xFF, sizeof( *pNextJobTime ) );
	DNTimeGet( &CurrentTime );

	//
	// loop through all timer items
	//
	while ( pWorkingEntry != pJobList )
	{
		TIMER_OPERATION_ENTRY	*pTimerEntry;
		BOOL	fJobActive;


		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pWorkingEntry );
		pWorkingEntry = pWorkingEntry->GetNext();
		
		fJobActive = ProcessTimedOperation( pTimerEntry, &CurrentTime, pNextJobTime );
		DNASSERT( ( fJobActive == FALSE ) || ( fJobActive == TRUE ) );
		
		fReturn |= fJobActive;

		if ( fJobActive == FALSE )
		{
			RemoveTimerOperationEntry( pTimerEntry, DPN_OK );
		}
	}

	DNASSERT( ( fReturn == FALSE ) || ( fReturn == TRUE ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTimedOperation - process a timed operation
//
// Entry:		Pointer to job information
//				Pointer to current time
//				Pointer to time to be updated
//
// Exit:		Boolean indicating that the job is still active
//				TRUE = operation active
//				FALSE = operation not active
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessTimedOperation"

BOOL	CThreadPool::ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pTimedJob,
											const DN_TIME *const pCurrentTime,
											DN_TIME *const pNextJobTime )
{
	BOOL	fEnumActive;


	DNASSERT( pTimedJob != NULL );
	DNASSERT( pCurrentTime != NULL );
	DNASSERT( pNextJobTime != NULL );

	//
	// Assume that this enum will remain active.  If we retire this enum, this
	// value will be reset.
	//
	fEnumActive = TRUE;

	//
	// If this enum has completed sending enums and is waiting only
	// for responses, decrement the wait time (assuming it's not infinite)
	// and remove the enum if the we've exceed its wait time.
	//
	if ( pTimedJob->uRetryCount == 0 )
	{
		if ( DNTimeCompare( &pTimedJob->IdleTimeout, pCurrentTime ) <= 0 )
		{
			fEnumActive = FALSE;
		}
		else
		{
			//
			// This enum isn't complete, check to see if it's the next enum
			// to need service.
			//
			if ( DNTimeCompare( &pTimedJob->IdleTimeout, pNextJobTime ) < 0 )
			{
				DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->IdleTimeout ) );
				memcpy( pNextJobTime, &pTimedJob->IdleTimeout, sizeof( *pNextJobTime ) );
			}
		}
	}
	else
	{
		//
		// This enum is still sending.  Determine if it's time to send a new enum
		// and adjust the wakeup time if appropriate.
		//
		if ( DNTimeCompare( &pTimedJob->NextRetryTime, pCurrentTime ) <= 0 )
		{
			HRESULT	hTempResult;


			//
			// Timeout, execute this timed item
			//
			pTimedJob->pTimerCallback( pTimedJob->pContext );

			//
			// If this job isn't running forever, decrement the retry count.
			// If there are no more retries, set up wait time.  If the job
			// is waiting forever, set max wait timeout.
			//
			if ( pTimedJob->fRetryForever == FALSE )
			{
				pTimedJob->uRetryCount--;
				if ( pTimedJob->uRetryCount == 0 )
				{
					if ( pTimedJob->fIdleWaitForever == FALSE )
					{
						//
						// Compute stopping time for this job's 'Timeout' phase and
						// see if this will be the next job to need service.  ASSERT
						// if the math wraps.
						//
						DNTimeAdd( &pTimedJob->IdleTimeout, pCurrentTime, &pTimedJob->IdleTimeout );
						DNASSERT( pTimedJob->IdleTimeout.Time32.TimeHigh >= pCurrentTime->Time32.TimeHigh );
						if ( DNTimeCompare( &pTimedJob->IdleTimeout, pNextJobTime ) < 0 )
						{
							DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->IdleTimeout ) );
							memcpy( pNextJobTime, &pTimedJob->IdleTimeout, sizeof( *pNextJobTime ) );
						}
					}
					else
					{
						//
						// We're waiting forever for enum returns.  ASSERT that we
						// have the maximum timeout and don't bother checking to see
						// if this will be the next enum to need service (it'll never
						// need service).  The following code needs to be revisited for
						// 64-bits.
						//
						DNASSERT( pTimedJob->IdleTimeout.Time32.TimeLow == -1 );
						DNASSERT( pTimedJob->IdleTimeout.Time32.TimeHigh == -1 );
					}

					goto SkipNextRetryTimeComputation;
				}
			}

			DNTimeAdd( pCurrentTime, &pTimedJob->RetryInterval, &pTimedJob->NextRetryTime );
		}

		//
		// is this the next enum to fire?
		//
		if ( DNTimeCompare( &pTimedJob->NextRetryTime, pNextJobTime ) < 0 )
		{
			DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->NextRetryTime ) );
			memcpy( pNextJobTime, &pTimedJob->NextRetryTime, sizeof( *pNextJobTime ) );
		}

SkipNextRetryTimeComputation:
		//
		// the following blank line is there to shut up the compiler
		//
		;
	}

	return	fEnumActive;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitWorkItem - submit a work item for processing and inform
//		work thread that another job is available
//
// Entry:		Pointer to job information
//
// Exit:		Error code
//
// Note:	This function assumes that the job data is locked.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitWorkItem"

HRESULT	CThreadPool::SubmitWorkItem( THREAD_POOL_JOB *const pJobInfo )
{
	HRESULT	hr;


	DNASSERT( pJobInfo != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );
	DNASSERT( pJobInfo->pCancelFunction != NULL );


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// add job to queue and tell someone that there's a job available
	//
	m_JobQueue.Lock();
	m_JobQueue.EnqueueJob( pJobInfo );
	m_JobQueue.Unlock();

		//
		// Win9x, set event that the work thread will listen for
		//
			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
			if ( m_JobQueue.SignalPendingJob() == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPF( 0, "Failed to signal pending job!" );
				goto Failure;
			}

Exit:
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with SubmitWorkItem!" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetWorkItem - get a work item from the job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job information (may be NULL)
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetWorkItem"

THREAD_POOL_JOB	*CThreadPool::GetWorkItem( void )
{
	THREAD_POOL_JOB	*pReturn;


	//
	// initialize
	//
	pReturn = NULL;

	m_JobQueue.Lock();
	pReturn = m_JobQueue.DequeueJob();

	//
	// if we're under Win9x (we have a 'pending job' handle),
	// see if the handle needs to be reset
	//
	if ( m_JobQueue.IsEmpty() != FALSE )
	{
		DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
		if ( ResetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPF( 0, "Problem resetting event for pending Win9x jobs!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	m_JobQueue.Unlock();

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitTimerJob - add a timer job to the timer list
//
// Entry:		Retry count
//				Boolean indicating that we retry forever
//				Retry interval
//				Boolean indicating that we wait forever
//				Idle wait interval
//				Pointer to callback when event fires
//				Pointer to callback when event complete
//				User context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitTimerJob"

HRESULT	CThreadPool::SubmitTimerJob( const UINT_PTR uRetryCount,
									 const BOOL fRetryForever,
									 const DN_TIME RetryInterval,
									 const BOOL fIdleWaitForever,
									 const DN_TIME IdleTimeout,
									 TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
									 TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
									 void *const pContext )
{
	HRESULT					hr;
	TIMER_OPERATION_ENTRY	*pEntry;
	THREAD_POOL_JOB			*pJob;
	BOOL					fTimerJobListLocked;


	DNASSERT( uRetryCount != 0 );
	DNASSERT( pTimerCallbackFunction != NULL );
	DNASSERT( pTimerCompleteFunction != NULL );
	DNASSERT( pContext != NULL );				// must be non-NULL because it's the lookup key to remove job

	//
	// initialize
	//
	hr = DPN_OK;
	pEntry = NULL;
	pJob = NULL;
	fTimerJobListLocked = FALSE;

	LockJobData();

	//
	// allocate new enum entry
	//
	pEntry = static_cast<TIMER_OPERATION_ENTRY*>( m_TimerEntryPool.Get( &m_TimerEntryPool ) );
	if ( pEntry == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot allocate memory to add to timer list!" );
		goto Failure;
	}
	DNASSERT( pEntry->pContext == NULL );

	//
	// build timer entry block
	//
	pEntry->pContext = pContext;
	pEntry->uRetryCount = uRetryCount;
	pEntry->fRetryForever = fRetryForever;
	pEntry->RetryInterval = RetryInterval;
	pEntry->IdleTimeout = IdleTimeout;
	pEntry->fIdleWaitForever = fIdleWaitForever;
	pEntry->pTimerCallback = pTimerCallbackFunction;
	pEntry->pTimerComplete = pTimerCompleteFunction;

	//
	// set this enum to fire as soon as it gets a chance
	//
	memset( &pEntry->NextRetryTime, 0x00, sizeof( pEntry->NextRetryTime ) );

	pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot allocate memory for enum job!" );
		goto Failure;
	}

	//
	// Create job for work thread.
	//
	pJob->pCancelFunction = CancelRefreshTimerJobs;
	pJob->JobType = JOB_REFRESH_TIMER_JOBS;

	// set our dummy paramter to simulate passing data
	DEBUG_ONLY( pJob->JobData.JobRefreshTimedJobs.uDummy = 0 );

	LockTimerData();
	fTimerJobListLocked = TRUE;

	//
	// we can submit the 'ENUM_REFRESH' job before inserting the enum entry
	// into the active enum list because nobody will be able to pull the
	// 'ENUM_REFRESH' job from the queue since we have the queue locked
	//
	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem submitting enum work item" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// debug block to check for duplicate contexts
	//
	DEBUG_ONLY(
				{
					CBilink	*pTempLink;


					pTempLink = m_TimerJobList.GetNext();
					while ( pTempLink != &m_TimerJobList )
					{
						TIMER_OPERATION_ENTRY	*pTempTimerEntry;
					
						
						pTempTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempLink );
						DNASSERT( pTempTimerEntry->pContext != pContext );
						pTempLink = pTempLink->GetNext();
					}
				}
			);

	//
	// link to rest of list
	//
	pEntry->Linkage.InsertAfter( &m_TimerJobList );

Exit:
	if ( fTimerJobListLocked != FALSE )
	{
		UnlockTimerData();
		fTimerJobListLocked = FALSE;
	}

	UnlockJobData();

	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with SubmitEnumJob" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	if ( pEntry != NULL )
	{
		m_TimerEntryPool.Release( &m_TimerEntryPool, pEntry );
		DEBUG_ONLY( pEntry = NULL );
	}

	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
		DEBUG_ONLY( pJob = NULL );
	}

	//
	// It's possible that the enum thread has been started for this enum.
	// Since there's no way to stop it without completing the enums or
	// closing the SP, leave it running.
	//

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelRefreshTimerJobs - cancel job to refresh timer jobs
//
// Entry:		Job data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CancelRefreshTimerJobs"

void	CThreadPool::CancelRefreshTimerJobs( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	//
	// this function doesn't need to do anything
	//
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopTimerJob - remove timer job from list
//
// Entry:		Pointer to job context (these MUST be uniquie for jobs)
//				Command result
//
// Exit:		Nothing
//
// Note:	This function is for the forced removal of a job from the timed job
//			list.  It is assumed that the caller of this function will clean
//			up any messes.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopTimerJob"

void	CThreadPool::StopTimerJob( void *const pContext, const HRESULT hCommandResult )
{
	CBilink	*pTempEntry;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	LockTimerData();

	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		TIMER_OPERATION_ENTRY	*pTimerEntry;


		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			RemoveTimerOperationEntry( pTimerEntry, hCommandResult );

			//
			// terminate loop
			//
			pTempEntry = &m_TimerJobList;
		}
		else
		{
			pTempEntry = pTempEntry->GetNext();
		}
	}

	UnlockTimerData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitDelayedCommand - submit request to enum query to remote session
//
// Entry:		Pointer to callback function
//				Pointer to cancel function
//				Pointer to callback context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitDelayedCommand"

HRESULT	CThreadPool::SubmitDelayedCommand( JOB_FUNCTION *const pFunction, JOB_FUNCTION *const pCancelFunction, void *const pContext )
{
	HRESULT			hr;
	THREAD_POOL_JOB	*pJob;
	BOOL			fJobDataLocked;


	DNASSERT( pFunction != NULL );
	DNASSERT( pCancelFunction != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pJob = NULL;
	fJobDataLocked = FALSE;

	pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot allocate job for DelayedCommand!" );
		goto Failure;
	}

	pJob->JobType = JOB_DELAYED_COMMAND;
	pJob->pCancelFunction = pCancelFunction;
	pJob->JobData.JobDelayedCommand.pCommandFunction = pFunction;
	pJob->JobData.JobDelayedCommand.pContext = pContext;

	LockJobData();
	fJobDataLocked = TRUE;

	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem submitting DelayedCommand job!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fJobDataLocked != FALSE )
	{
		UnlockJobData();
		fJobDataLocked = FALSE;
	}

	return	hr;

Failure:
	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::AddSocketPort - add a socket to the Win9x watch list
//
// Entry:		Pointer to SocketPort
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::AddSocketPort"

HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
{
	HRESULT	hr;
	BOOL	fSocketAdded;

	
	DNASSERT( pSocketPort != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	fSocketAdded = FALSE;

	Lock();

	//
	// We're capped by the number of sockets we can use for Winsock1.  Make
	// sure we don't allocate too many sockets.
	//
	if ( m_uReservedSocketCount == FD_SETSIZE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "There are too many sockets allocated on Winsock1!" );
		goto Failure;
	}

	m_uReservedSocketCount++;
	
	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
	m_SocketSet.fd_count++;
	fSocketAdded = TRUE;

	//
	// add a reference to note that this socket port is being used by the thread
	// pool
	//
	pSocketPort->AddRef();

	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

Exit:
	Unlock();
	
	return	hr;

Failure:
	if ( fSocketAdded != FALSE )
	{
		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
		m_SocketSet.fd_count--;
		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
		fSocketAdded = FALSE;
	}

	m_uReservedSocketCount--;

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
//
// Entry:		Pointer to socket port to remove
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::RemoveSocketPort"

void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
{
	UINT_PTR	uIndex;


	DNASSERT( pSocketPort != NULL );
	
	Lock();

	uIndex = m_SocketSet.fd_count;
	DNASSERT( uIndex != 0 );
	while ( uIndex != 0 )
	{
		uIndex--;

		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
		{
			m_uReservedSocketCount--;
			m_SocketSet.fd_count--;

			memmove( &m_pSocketPorts[ uIndex ],
					 &m_pSocketPorts[ uIndex + 1 ],
					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );

			memmove( &m_SocketSet.fd_array[ uIndex ],
					 &m_SocketSet.fd_array[ uIndex + 1 ],
					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );

			//
			// clear last entry which is now unused
			//
			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );

			//
			// end the loop
			//
			uIndex = 0;
		}
	}

	Unlock();
	
	pSocketPort->DecRef();

	//
	// It's really not necessary to signal a new job here because there were
	// active sockets on the last iteration of the Win9x thread.  That means the
	// Win9x thread was in a polling mode to check for sockets and the next time
	// through it will notice that there is a missing socket.  By signalling the
	// job event we reduce the time needed for the thread to figure out that the
	// socket is gone.
	//
	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::RemoveTimerOperationEntry - remove timer operation job	from list
//
// Entry:		Pointer to timer operation
//				Result code to return
//
// Exit:		Nothing
//
// Note:	This function assumes that the list is appropriately locked
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::RemoveTimerOperationEntry"

void	CThreadPool::RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerEntry, const HRESULT hJobResult )
{
	DNASSERT( pTimerEntry != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_TimerDataLock, TRUE );

	//
	// remove this link from the list, tell owner that the job is complete and
	// return the job to the pool
	//
	pTimerEntry->Linkage.RemoveFromList();
	pTimerEntry->pTimerComplete( hJobResult, pTimerEntry->pContext );
	m_TimerEntryPool.Release( &m_TimerEntryPool, pTimerEntry );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CompleteOutstandingSends - check for completed sends and
//		indicate send completion for them.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CompleteOutstandingSends"

void	CThreadPool::CompleteOutstandingSends( void )
{
	CBilink		*pCurrentOutstandingWrite;
	CBilink		WritesToBeProcessed;


	WritesToBeProcessed.Initialize();
	LockWriteData();

	//
	// Loop through the list out outstanding sends.  Any completed sends are
	// removed from the list and processed after we release the write data lock.
	//
	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
	{
		CSocketPort		*pSocketPort;
		CWriteIOData	*pWriteIOData;
		DWORD			dwFlags;
		BOOL	fGetOverlappedResult;


		//
		// note this send and advance pointer to the next pending send
		//
		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();

		if ( pWriteIOData->Win9xOperationPending() != FALSE )
		{
			DNEnterCriticalSection(&g_csSocketAccessLock);
			fGetOverlappedResult = p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
										   pWriteIOData->Overlap(),
										   &pWriteIOData->m_dwOverlappedBytesSent,
										   FALSE,
										   &dwFlags
										   );
			DNLeaveCriticalSection(&g_csSocketAccessLock);

			if ( fGetOverlappedResult != FALSE )
			{
				//
				// Overlapped results will complete with success and zero bytes
				// transferred when the overlapped structure is checked BEFORE
				// the operation has really been subnitted.  This is a possibility
				// with the current code.  To combat this, check the sent bytes
				// for zero (we'll never send zero bytes).
				//
				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
				{
					goto SkipSendCompletion;
				}

				pWriteIOData->m_Win9xSendHResult = DPN_OK;
				pWriteIOData->m_dwOverlappedBytesSent = 0;
			}
			else
			{
				DWORD	dwWSAError;


				dwWSAError = p_WSAGetLastError();
				switch( dwWSAError )
				{
					//
					// this I/O operation is incomplete, don't send notification to the user
					//
					case ERROR_IO_PENDING:
					case WSA_IO_INCOMPLETE:
					{
						goto SkipSendCompletion;
						break;
					}

                    case WSAEINPROGRESS:		// BUGBUG: [mgere] [xbox] Added handler for new Winsock error message.  Check to see if this is correct.
					{
						goto SkipSendCompletion;
						break;
					}

					//
					// WSAENOTSOCK = the socket has been closed, most likely
					// as a result of a command completing or being cancelled.
					//
					case WSAENOTSOCK:
					{
						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
						break;
					}

					//
					// other error, stop and look
					//
					default:
					{
						INT3;
						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
						DisplayWinsockError( 0, dwWSAError );

						break;
					}
				}
			}

			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
			pWriteIOData->SetWin9xOperationPending( FALSE );

			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( &WritesToBeProcessed );
		}

SkipSendCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	UnlockWriteData();

	//
	// process all writes that have been pulled to the side.
	//
	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
	{
		BOOL			fIOServiced;
		CWriteIOData	*pTempWrite;
		CSocketPort		*pSocketPort;


		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
		pSocketPort = pTempWrite->SocketPort();
		DNASSERT( pSocketPort != NULL );

		fIOServiced = pSocketPort->SendFromWriteQueue();
		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
		pSocketPort->DecRef();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CompleteOutstandingReceives - check for completed receives and
//		indicate completion for them.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CompleteOutstandingReceives"

void	CThreadPool::CompleteOutstandingReceives( void )
{
	CBilink		*pCurrentOutstandingRead;
	CBilink		ReadsToBeProcessed;


	ReadsToBeProcessed.Initialize();
	LockReadData();

	//
	// Loop through the list of outstanding reads and pull out the ones that need
	// to be serviced.  We don't want to service them while the read data lock
	// is taken.
	//
	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
	{
		CSocketPort		*pSocketPort;
		CReadIOData		*pReadIOData;
		DWORD			dwFlags;
		BOOL		fGetOverlappedResult;


		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();

		//
		// Make sure this operation is really pending before attempting to check
		// for completion.  It's possible that the read was added to the list, but
		// we haven't actually called Winsock yet.
		//
		if ( pReadIOData->Win9xOperationPending() != FALSE )
		{
			if (pReadIOData->SocketPort()->GetSocket() != INVALID_SOCKET)
			{

			DNEnterCriticalSection(&g_csSocketAccessLock);
			fGetOverlappedResult = p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
										   pReadIOData->Overlap(),
										   &pReadIOData->m_dwOverlappedBytesReceived,
										   FALSE,
										   &dwFlags
										   );
			DNLeaveCriticalSection(&g_csSocketAccessLock);

			if ( fGetOverlappedResult != FALSE )
			{
				//
				// Overlapped results will complete with success and zero bytes
				// transferred when the overlapped structure is checked BEFORE
				// the operation has really been subnitted.  This is a possibility
				// with the current code.  To combat this, check the received bytes
				// for zero (the return when the overlapped request was checked before
				// it was sent) and check the return address (it's possible that someone
				// really sent zero bytes).
				//
				DBG_CASSERT( ERROR_SUCCESS == 0 );
				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
				{
					pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
				}
				else
				{
					goto SkipReceiveCompletion;
				}
			}
			else
			{
				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
				switch( pReadIOData->m_Win9xReceiveWSAReturn )
				{
					//
					// If this I/O operation is incomplete, don't send notification to the user.
					//
					case WSA_IO_INCOMPLETE:
					{
						goto SkipReceiveCompletion;
						break;
					}

						case WSAEINPROGRESS:		// BUGBUG: [mgere] [xbox] Added handler for new Winsock error message.  Check to see if this is correct.
					{
					goto SkipReceiveCompletion;
						break;
					}

					//
					// socket was closed with an outstanding read, no problem
					// Win9x reports 'WSAENOTSOCK'
					// WinNT reports 'ERROR_OPERATION_ABORTED'
					//
					// If this is an indication that the connection was reset,
					// pass it on to the socket port so it can issue another
					// read
					//
					case ERROR_OPERATION_ABORTED:
					case WSAENOTSOCK:
					case WSAECONNRESET:
					{
						break;
					}

					default:
					{
						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
							// debug me!
						DNASSERT( FALSE );
							break;
					}
				}
			}

			}

			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
			pReadIOData->SetWin9xOperationPending( FALSE );

			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( &ReadsToBeProcessed );
		}

SkipReceiveCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	UnlockReadData();

	//
	// loop through the list of reads that have completed and dispatch them
	//
	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
	{
		CReadIOData		*pTempRead;
		CSocketPort		*pSocketPort;


		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();

		pSocketPort = pTempRead->SocketPort();
		DNASSERT( pSocketPort != NULL );
		pSocketPort->Winsock2ReceiveComplete( pTempRead );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
//		supposed to do under Win9x.
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PrimaryWin9xThread"
#ifdef DPLAY_DOWORK
DWORD CThreadPool::PrimaryWin9xThread( void )
{
	static WIN9X_CORE_DATA		CoreData;
	static DN_TIME				CurrentTime;
	static DWORD				dwMaxWaitTime;
	static DN_TIME				DeltaT;
	static BOOL fFirstRun = TRUE;
	DWORD	dwWaitReturn;
	DWORD dwNoMoreWork = 0;

	if (fFirstRun == TRUE)
	{
		fFirstRun = FALSE;

		//
		// initialize
		//
		memset( &CoreData, 0x00, sizeof CoreData );

		//
		// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
		// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
		// structure definition.
		//
		DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
		DNASSERT( CoreData.fTimerJobsActive == FALSE );

		//
		// set enums to happen infinitely in the future
		//
		memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );

		//
		// set wait handles
		//
		CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = m_hStopAllThreads;
		CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = m_JobQueue.GetPendingJobHandle();
		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = GetWinsock2SendCompleteEvent();
		CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = GetWinsock2ReceiveCompleteEvent();
	
		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
		DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );

		CoreData.fLooping = TRUE;
	}

	//
	// Update the job time so we know how long to wait.  We can
	// only get here if a socket was just added to the socket list, or
	// we've been servicing sockets.
	//
	DNTimeGet( &CurrentTime );
	if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
	{
		LockTimerData();
		CoreData.fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList,
								&CoreData.NextTimerJobTime );
		if ( CoreData.fTimerJobsActive != FALSE )
		{
			DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
		}
		UnlockTimerData();
	}
	DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
	dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );

	//
	// go until we're told to stop
	//
	if ( CoreData.fLooping == FALSE )
	{
		SetEvent(m_hThreadCloseEvent);
		fFirstRun = TRUE;
		return 1;
	}

	//
	// Check Winsock2 sockets.
	//
	dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
								 CoreData.hWaitHandles,					// handles to wait on
								 FALSE,									// don't wait for all to be signalled
								 0,							// wait timeout
//								 0,							// wait timeout
								 TRUE									// we're alertable for APCs
								 );
	switch ( dwWaitReturn )
	{
		//
		// timeout, don't do anything, we'll probably process timer jobs on
		// the next loop
		//
		case WAIT_TIMEOUT:
		{
			dwNoMoreWork = 1;
			break;
		}
			
		case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
		case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
		case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
		case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
		{
			ProcessWin9xEvents( &CoreData );
			break;
		}

		//
		// wait failed
		//
		case WAIT_FAILED:
		{
			DWORD	dwError;

			dwNoMoreWork = 1;
			dwError = GetLastError();
			DPF( 0, "Primary Win9x thread wait failed!" );
			DisplayDNError( 0, dwError );
			break;
		}

		//
		// problem
		//
		default:
		{
			DWORD	dwError;

			dwNoMoreWork = 1;
			dwError = GetLastError();
			DPF( 0, "Primary Win9x thread unknown problem in wait!" );
			DisplayDNError( 0, dwError );
			DNASSERT( FALSE );
			break;
		}
	}

	return	dwNoMoreWork;
}
#else
DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
{
	WIN9X_CORE_DATA		CoreData;
	DN_TIME				CurrentTime;
	DWORD				dwMaxWaitTime;
	DN_TIME				DeltaT;
	BOOL				fComInitialized;

	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;

	
	DNASSERT( pParam != NULL );
	DNASSERT( pThisThreadPool != NULL );
	DNASSERT( pSocketSet != NULL );

	//
	// initialize
	//
	memset( &CoreData, 0x00, sizeof CoreData );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPF( 0, "Primary Win9x thread failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
	// structure definition.
	//
	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
//#ifdef	_WIN32
//	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
//#endif	// _WIN32
//	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
//	DNASSERT( pSocketSet->fd_count == 0 );
	DNASSERT( CoreData.fTimerJobsActive == FALSE );

	//
	// set enums to happen infinitely in the future
	//
	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );

	//
	// set wait handles
	//
	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
	
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
	
	//
	// go until we're told to stop
	//
	CoreData.fLooping = TRUE;
	while ( CoreData.fLooping != FALSE )
	{
		DWORD	dwWaitReturn;

		
		//
		// Update the job time so we know how long to wait.  We can
		// only get here if a socket was just added to the socket list, or
		// we've been servicing sockets.
		//
		DNTimeGet( &CurrentTime );
		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
		{
			pThisThreadPool->LockTimerData();
			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
																		   &CoreData.NextTimerJobTime );
			if ( CoreData.fTimerJobsActive != FALSE )
			{
				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
			}
			pThisThreadPool->UnlockTimerData();
		}

		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
#pragma	BUGBUG( johnkan, "Busted Win64!" )
		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );


		//
		// Check Winsock2 sockets.
		//
		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
												 CoreData.hWaitHandles,					// handles to wait on
												 FALSE,									// don't wait for all to be signalled
												 dwMaxWaitTime,							// wait timeout
												 TRUE									// we're alertable for APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// timeout, don't do anything, we'll probably process timer jobs on
			// the next loop
			//
			case WAIT_TIMEOUT:
			{
				break;
			}
			
			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
			{
				pThisThreadPool->ProcessWin9xEvents( &CoreData );
				break;
			}

			//
			// There are I/O completion routines scheduled on this thread.
			// This is not a good thing!
			//
			case WAIT_IO_COMPLETION:
			{
				DPF( 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPF( 0, "Primary Win9x thread wait failed!" );
				DisplayDNError( 0, dwError );
				break;
			}

			//
			// problem
			//
			default:
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPF( 0, "Primary Win9x thread unknown problem in wait!" );
				DisplayDNError( 0, dwError );
				DNASSERT( FALSE );
				break;
			}
		}
	}

	DNFree( pParam );

	SetEvent(pThisThreadPool->m_hThreadCloseEvent);

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
#endif
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessWin9xEvents - process Win9x events
//
// Entry:		Pointer to core data
//				Thread type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessWin9xEvents"

void	CThreadPool::ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData )
{
	DNASSERT( pCoreData != NULL );

	//
	// If delayed jobs are to be processed, process one.  Otherwise sleep and
	// let another thread pick up the jobs.
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_PENDING_JOB ], 0 ) )
	{
		case WAIT_TIMEOUT:
		{
			break;
		}

		case WAIT_OBJECT_0:
		{
					DPF( 8, "Primary Win9x thread has a pending job!" );
					ProcessWin9xJob( pCoreData );

			break;
		}

		default:
		{
			INT3;
			break;
		}
	}

	//
	// send complete
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			//
			// reset the event so it will be signalled again if anything
			// completes while we're scanning the pending write list
			//
			if ( ResetEvent( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPF( 0, "Failed to reset Winsock2 send event!" );
				DisplayErrorCode( 0, dwError );
			}

			CompleteOutstandingSends();
			
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			INT3;
			break;
		}
	}

	//
	// receive complete
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			//
			// reset the event so it will be signalled again if anything
			// completes while we're scanning the pending read list
			//
			if ( ResetEvent( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPF( 0, "Failed to reset Winsock2 receive event!" );
				DisplayErrorCode( 0, dwError );
			}

			CompleteOutstandingReceives();
			
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			INT3;
			break;
		}
	}

	//
	// stop all threads
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPF( 8, "Win9x thread exit because SP closing!" );
			pCoreData->fLooping = FALSE;
			break;
		}
	
		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			INT3;
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessWin9xJob - process a Win9x job
//
// Entry:		Pointer core data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessWin9xJob"

void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
{
	THREAD_POOL_JOB	*pJobInfo;


	//
	// Remove and process a single job from the list.  If there is no job, skip
	// to the end of the function.
	//
	pJobInfo = GetWorkItem();

	if ( pJobInfo == NULL )
	{
		goto Exit;
	}

	switch ( pJobInfo->JobType )
	{
		//
		// enum refresh
		//
		case JOB_REFRESH_TIMER_JOBS:
		{
			DPF( 8, "WorkThread job REFRESH_ENUM" );
			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
			LockTimerData();
			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
			UnlockTimerData();

			if ( pCoreData->fTimerJobsActive != FALSE )
			{
				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
			}

			break;
		}

		//
		// issue callback for this job
		//
		case JOB_DELAYED_COMMAND:
		{
			DPF( 8, "WorkThread job DELAYED_COMMAND" );
			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
			break;
		}

		//
		// other job
		//
		default:
		{
			DPF( 0, "WorkThread Win9x job unknown!" );
			DNASSERT( FALSE );
			break;
		}
	}

	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
	m_JobPool.Release( &m_JobPool, pJobInfo );

Exit:
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Alloc - allocate a new job
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Alloc"

BOOL	CThreadPool::WorkThreadJob_Alloc( void *pItem )
{
	BOOL			fReturn;
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	fReturn = TRUE;
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );

	DEBUG_ONLY( memset( pJob, 0x00, sizeof( *pJob ) ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Get - a job is being removed from the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Get"

void	CThreadPool::WorkThreadJob_Get( void *pItem )
{
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );
	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );

	//
	// cannot ASSERT the the following because the pool manager uses that memory
	//
//	DNASSERT( pJob->pNext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Release - a job is being returned to the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Release"

void	CThreadPool::WorkThreadJob_Release( void *pItem )
{
	THREAD_POOL_JOB	*pJob;


	DNASSERT( pItem != NULL );
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );

	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Dealloc - return job to memory manager
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Dealloc"

void	CThreadPool::WorkThreadJob_Dealloc( void *pItem )
{
	// don't do anything
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Alloc - allocate a new timer job entry
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Alloc"

BOOL	CThreadPool::TimerEntry_Alloc( void *pItem )
{
	BOOL					fReturn;
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );
	DEBUG_ONLY( memset( pTimerEntry, 0x00, sizeof( *pTimerEntry ) ) );
	pTimerEntry->pContext = NULL;
	pTimerEntry->Linkage.Initialize();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Get - get new timer job entry from pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Get"

void	CThreadPool::TimerEntry_Get( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );

	pTimerEntry->Linkage.Initialize();
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Release - return timer job entry to pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Release"

void	CThreadPool::TimerEntry_Release( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );
	pTimerEntry->pContext= NULL;

	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Dealloc - deallocate a timer job entry
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Dealloc"

void	CThreadPool::TimerEntry_Dealloc( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );

	//
	// return associated poiner to write data
	//
// can't DNASSERT on Linkage because pool manager stomped on it
//	DNASSERT( pEnumEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\utils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.h
 *  Content:	Utilitiy functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __UTILS_H__
#define __UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CPackedBuffer;
// BUGBUG: [mgere] [xbox] Removed RSIP
//class	CRsip;
class	CSPData;
class	CThreadPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitProcessGlobals( void );
void	DeinitProcessGlobals( void );

HRESULT	CreateSPData( CSPData **const ppSPData,
					  const CLSID *const pClassID,
					  IDP8ServiceProviderVtbl *const pVtbl );

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CSPData *const pSPData );

//HRESULT	ApplyDeviceAddressDefaults( IDirectPlay8Address *const pInputAddress,
//									IDirectPlay8Address *const pDefaultAddress,
//									IDirectPlay8Address **const ppModifiedDeviceAddress );

/* BUGBUG: [mgere] [xbox] Removed -- multiple adapters not supported on xbox
HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
								   const char *const pAdapterName,
								   const GUID *const pAdapterGUID );
*/

#endif	// __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\threadpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ThreadPool.h
 *  Content:	Functions to manage a thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/01/99	jtk		Derived from Utils.h
 ***************************************************************************/

#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// max handles that can be waited on for Win9x
//
#define	MAX_WIN9X_HANDLE_COUNT	64

//
// job definitions
//
typedef enum	_JOB_TYPE
{
	JOB_UNINITIALIZED,			// uninitialized value
	JOB_DELAYED_COMMAND,		// callback provided
	JOB_REFRESH_TIMER_JOBS		// revisit timer jobs
} JOB_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CSocketPort;
class	CThreadPool;
typedef struct	_THREAD_POOL_JOB		THREAD_POOL_JOB;
typedef	struct	_TIMER_OPERATION_ENTRY	TIMER_OPERATION_ENTRY;
typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );
typedef	void	TIMER_EVENT_CALLBACK( void *const pContext );
typedef	void	TIMER_EVENT_COMPLETE( const HRESULT hCompletionCode, void *const pContext );

//**********************************************************************
// Class prototypes
//**********************************************************************

//
// class for thread pool
//
class	CThreadPool
{
	STDNEWDELETE

	public:
		CThreadPool();
		~CThreadPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }
		void	LockReadData( void ) { DNEnterCriticalSection( &m_ReadDataLock ); }
		void	UnlockReadData( void ) { DNLeaveCriticalSection( &m_ReadDataLock ); }
		void	LockWriteData( void ) { DNEnterCriticalSection( &m_WriteDataLock ); }
		void	UnlockWriteData( void ) { DNLeaveCriticalSection( &m_WriteDataLock ); }


		void	AddRef( void ) { DNInterlockedIncrement( &m_iRefCount ); }
		void	DecRef( void )
		{
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		HRESULT	Initialize( void );
		void	Deinitialize( void );
		void	StopAllIO( void );

		CReadIOData	*GetNewReadIOData( READ_IO_DATA_POOL_CONTEXT *const pContext );
		void	ReturnReadIOData( CReadIOData *const pReadIOData );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetNewWriteIOData"
		CWriteIOData	*GetNewWriteIOData( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
		{
			CWriteIOData   *pTemp;


			DNASSERT( pContext != NULL );
			pContext->hOverlapEvent = GetWinsock2SendCompleteEvent();

			LockWriteData();

			//
			// attempt to get an entry from the pool, if one is gotten, put into
			// the pending write list
			//
			pTemp = m_WriteIODataPool.Get( pContext );
			if ( pTemp != NULL )
			{
				pTemp->m_OutstandingWriteListLinkage.InsertBefore( &m_OutstandingWriteList );
			}

			UnlockWriteData();

			return pTemp;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::ReturnWriteIOData"
		void	ReturnWriteIOData( CWriteIOData *const pWriteData )
		{
			DNASSERT( pWriteData != NULL );

			LockWriteData();

			pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();
			DNASSERT( pWriteData->m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
			m_WriteIODataPool.Release( pWriteData );

			UnlockWriteData();
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetWinsock2SendCompleteEvent"
		HANDLE	GetWinsock2SendCompleteEvent( void ) const
		{
			DNASSERT( m_hWinsock2SendComplete != NULL );
			return m_hWinsock2SendComplete;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetWinsock2ReceiveCompleteEvent"
		HANDLE	GetWinsock2ReceiveCompleteEvent( void ) const
		{
			DNASSERT( m_hWinsock2ReceiveComplete != NULL );
			return m_hWinsock2ReceiveComplete;
		}


		HRESULT	SubmitDelayedCommand( JOB_FUNCTION *const pFunction,
									  JOB_FUNCTION *const pCancelFunction,
									  void *const pContext );

		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
		void	RemoveSocketPort( CSocketPort *const pSocketPort );

		HRESULT	SubmitTimerJob( const UINT_PTR uRetryCount,
								const BOOL fRetryForever,
								const DN_TIME RetryInterval,
								const BOOL fIdleWaitForever,
								const DN_TIME IdleTimeout,
								TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
								TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
								void *const pContext );
		
		void	StopTimerJob( void *const pContext, const HRESULT hCommandResult );

#ifdef DPLAY_DOWORK
		DWORD PrimaryWin9xThread( void );
#endif

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;				// local lock

		volatile LONG	m_iRefCount;					// reference count

		HANDLE	m_hStopAllThreads;				// handle used to stop all non-I/O completion threads
		HANDLE	m_hWinsock2SendComplete;		// send complete on Winsock2
		HANDLE	m_hWinsock2ReceiveComplete;		// receive complete on Winsock2
		HANDLE	m_hThreadCloseEvent;		// Signal that the thread has been closed


		//
		// list of pending network operations, it doesn't really matter if they're
		// reads or writes, they're just pending.
		//
		DNCRITICAL_SECTION	m_ReadDataLock;		// lock for all read data
		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPReadIODataPool;		// pool for IP read data
		CBilink		m_OutstandingReadList;		// list of outstanding reads

		DNCRITICAL_SECTION	m_WriteDataLock;	// lock for all write data
		CContextFixedPool< CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT >	m_WriteIODataPool;	// pool for write data
		CBilink		m_OutstandingWriteList;		// list of outstanding writes

		//
		// The Job data lock covers all items through and including m_pSocketPorts
		//
		DNCRITICAL_SECTION	m_JobDataLock;		// lock for job queue/pool

		FPOOL		m_TimerEntryPool;			// pool for timed entries
		FPOOL		m_JobPool;					// pool of jobs for work threads

		CJobQueue	m_JobQueue;					// job queue

		//
		// Data used by the the timer thread.  This data is protected by m_TimerDataLock.
		// This data is cleaned by the timer thread.  Since only one timer thread
		// is allowed to run at any given time, the status of the NT timer thread
		// can be determined by m_fNTEnumThreadRunning.  Win9x doesn't have a timer
		// thread, the main thread loop is timed.
		//
		DNCRITICAL_SECTION	m_TimerDataLock;
		CBilink				m_TimerJobList;

		UINT_PTR		m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
		FD_SET			m_SocketSet;					// set of all sockets in use
		CSocketPort 	*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports

		void	LockJobData( void ) { DNEnterCriticalSection( &m_JobDataLock ); }
		void	UnlockJobData( void ) { DNLeaveCriticalSection( &m_JobDataLock ); }

		void	LockTimerData( void ) { DNEnterCriticalSection( &m_TimerDataLock ); }
		void	UnlockTimerData( void ) { DNLeaveCriticalSection( &m_TimerDataLock ); }

		static	UINT_PTR	SaturatedWaitTime( const DN_TIME &Time )
		{
				UINT_PTR	uReturn;

				if ( Time.Time32.TimeHigh != 0 )
				{
					uReturn = -1;
				}
				else
				{
					uReturn = Time.Time32.TimeLow;
				}

				return	uReturn;
		}

		HRESULT	Win9xInit( void );

		BOOL	ProcessTimerJobs( const CBilink *const pJobList, DN_TIME *const pNextJobTime);

		BOOL	ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pJob,
									   const DN_TIME *const pCurrentTime,
									   DN_TIME *const pNextJobTime );

		void	RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerOperationData, const HRESULT hReturnCode );
		void	CompleteOutstandingSends( void );
		void	CompleteOutstandingReceives( void );

#ifndef DPLAY_DOWORK
		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
#endif

		HRESULT	SubmitWorkItem( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*GetWorkItem( void );

		static	void	CancelRefreshTimerJobs( THREAD_POOL_JOB *const pJobData );
		void	ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData );
		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );

		void	StopAllThreads( void );
		void	CancelOutstandingJobs( void );
		void	CancelOutstandingIO( void );
		void	ReturnSelfToPool( void );

		//
		// functions for managing the job pool
		//
		static	BOOL	WorkThreadJob_Alloc( void *pItem );
		static	void	WorkThreadJob_Get( void *pItem );
		static	void	WorkThreadJob_Release( void *pItem );
		static	void	WorkThreadJob_Dealloc( void *pItem );

		//
		// functions for managing the timer data pool
		//
		static	BOOL	TimerEntry_Alloc( void *pItem );
		static	void	TimerEntry_Get( void *pItem );
		static	void	TimerEntry_Release( void *pItem );
		static	void	TimerEntry_Dealloc( void *pItem );

		//
		// prevent unwarranted copies
		//
		CThreadPool( const CThreadPool & );
		CThreadPool& operator=( const CThreadPool & );
};

#undef DPF_MODNAME

#endif	// __THREAD_POOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\unk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Unk.cpp
 *  Content:	IUnknown implementation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  08/06/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

static	STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj);

//**********************************************************************
// Function definitions
//**********************************************************************

// these are the vtables for IPX and IP.  One or the other is used depending on
// what is passed to DoCreateInstance.  The interfaces are presently the same,
// but are different structures to facilitate potential future changes.
static IDP8ServiceProviderVtbl	ipInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
	DNSP_CreateGroup,
	DNSP_DeleteGroup,
	DNSP_AddToGroup,
	DNSP_RemoveFromGroup,
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
	DNSP_IsApplicationSupported,
	DNSP_ProxyEnumQuery
};

//**********************************************************************
// ------------------------------
// DNSP_QueryInterface - query for interface
//
// Entry:		Pointer to current interface
//				GUID of desired interface
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

static	STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj)
{
	HRESULT hr = S_OK;
	 *ppvObj=NULL;

	// hmmm, switch would be cleaner...
		*ppvObj = lpDNSP;
		DNSP_AddRef(lpDNSP);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPInterface - create an IP interface
//
// Entry:		Pointer to pointer to SP interface
//				Pointer to associated SP data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateIPInterface"

static	HRESULT CreateIPInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
{
	HRESULT 	hr;
	CSPData		*pSPData;

	
	DNASSERT( ppiDNSP != NULL );
	DNASSERT( ppSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDNSP = NULL;
	*ppSPData = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData, &GUID_NULL, &ipInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData != NULL );
		DPF( 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDNSP = pSPData->COMInterface();
	*ppSPData = pSPData;

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DoCreateInstance - create an instance of an interface
//
// Entry:		Pointer to class factory
//				Pointer to unknown interface
//				Refernce of GUID of desired interface
//				Reference to another GUID?
//				Pointer to pointer to interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"

HRESULT DoCreateInstance( LPCLASSFACTORY This,
						  LPUNKNOWN pUnkOuter,
						  REFCLSID rclsid,
						  REFIID riid,
						  LPVOID *ppvObj )
{
	HRESULT			 	hr;
	IDP8ServiceProvider	**ppIDNSP;
	CSPData				*pSPData;


	DNASSERT( ppvObj != NULL );

	//
	// initialize
	//
	*ppvObj = NULL;
	ppIDNSP = NULL;
	pSPData = NULL;

	DBG_CASSERT( sizeof( ppvObj ) == sizeof( ppIDNSP ) );
	ppIDNSP = reinterpret_cast<IDP8ServiceProvider**>( ppvObj );
		hr = CreateIPInterface( ppIDNSP, &pSPData );

	if (hr == S_OK)
	{
		// get the right interface and bump the refcount
		hr = IDP8ServiceProvider_QueryInterface( *ppIDNSP, riid, ppvObj );
		DNASSERT( hr == S_OK );
	}

	//
	// release any outstanding reference on the SP data
	//
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IsClassImplemented - determine if a class is implemented in this .DLL
//
// Entry:		Reference to class GUID
//
// Exit:		Boolean indicating whether this .DLL implements the class
//				TRUE = this .DLL implements the class
//				FALSE = this .DLL doesn't implement the class
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"

BOOL IsClassImplemented(REFCLSID rclsid)
{
	return TRUE;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\utils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.cpp
 *  Content:	Serial service provider utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// global variables that are unique for the process
//
static	DNCRITICAL_SECTION	g_InterfaceGlobalsLock;

static volatile	LONG	g_iThreadPoolRefCount = 0;

CThreadPool		*g_pThreadPool = NULL;
CThreadPool		*g_pThreadPool2 = NULL;

static volatile LONG	g_iWinsockRefCount = 0;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitProcessGlobals - initialize the global items needed for the SP to operate
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitProcessGlobals"

BOOL	InitProcessGlobals( void )
{
	BOOL		fReturn;
	BOOL		fCriticalSectionInitialized;
	BOOL		fPoolsInitialized;


	//
	// initialize
	//
	fReturn = TRUE;
	fCriticalSectionInitialized = FALSE;
	fPoolsInitialized = FALSE;

	if ( DNInitializeCriticalSection( &g_InterfaceGlobalsLock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

	if ( InitializePools() == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

	DNASSERT( g_pThreadPool == NULL );


Exit:
	return	fReturn;

Failure:
	if ( fPoolsInitialized != FALSE )
	{
		DeinitializePools();
		fPoolsInitialized = FALSE;
	}

	if ( fCriticalSectionInitialized != FALSE )
	{
		DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
		fCriticalSectionInitialized = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitProcessGlobals - deinitialize the global items
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitProcessGlobals"

void	DeinitProcessGlobals( void )
{
	DNASSERT( g_pThreadPool == NULL );
	DNASSERT( g_iThreadPoolRefCount == 0 );

	DeinitializePools();
	DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSPData - create instance data for SP
//
// Entry:		Pointer to pointer to SPData
//				Pointer to class GUID
//				Interface type
//				Pointer to COM interface vtable
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateSPData"

HRESULT	CreateSPData( CSPData **const ppSPData,
					  const CLSID *const pClassID,
					  IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT		hr;
	CSPData		*pSPData;


	DNASSERT( ppSPData != NULL );
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	*ppSPData = NULL;
	pSPData = NULL;

	//
	// create data
	//
	pSPData = new CSPData;
	if ( pSPData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot create data for Winsock interface!" );
		goto Failure;
	}
	pSPData->AddRef();

	hr = pSPData->Initialize( pClassID, pVtbl );
	if ( hr != DPN_OK  )
	{
		DPF( 0, "Failed to intialize SP data!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem with CreateSPData!" );
		DisplayDNError( 0, hr );
	}

	*ppSPData = pSPData;

	return	hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;	
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializeInterfaceGlobals - perform global initialization for an interface.
//		This entails starting the thread pool and RSIP (if applicable).
//
// Entry:		Pointer to SPData
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitializeInterfaceGlobals"

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData )
{
	HRESULT	hr;
	CThreadPool	*pThreadPool;
// BUGBUG: [mgere] [xbox] Removed RSIP
//	CRsip		*pRsip;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThreadPool = NULL;
// BUGBUG: [mgere] [xbox] Removed RSIP
//	pRsip = NULL;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_pThreadPool == NULL )
	{
		DNASSERT( g_iThreadPoolRefCount == 0 );
		g_pThreadPool = CreateThreadPool();
		if ( g_pThreadPool != NULL )
		{
			hr = g_pThreadPool->Initialize();
			if ( hr != DPN_OK )
			{
				g_pThreadPool->DecRef();
				g_pThreadPool = NULL;
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
			else
			{
				g_iThreadPoolRefCount++;
				pThreadPool = g_pThreadPool;
			}
		}
	}
	else
	{
		DNASSERT( g_iThreadPoolRefCount != 0 );
		g_iThreadPoolRefCount++;
		g_pThreadPool->AddRef();
		pThreadPool = g_pThreadPool;
	}

	g_pThreadPool2 = g_pThreadPool;

Exit:
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	pSPData->SetThreadPool( g_pThreadPool );

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializeInterfaceGlobals - deinitialize thread pool and Rsip
//
// Entry:		Pointer to service provider
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitializeInterfaceGlobals"

void	DeinitializeInterfaceGlobals( CSPData *const pSPData )
{
	CThreadPool		*pThreadPool;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	pThreadPool = NULL;

	//
	// Process as little as possible inside the lock.  If any of the items
	// need to be released, pointers to them will be set.
	//
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_pThreadPool != NULL );
	DNASSERT( g_iThreadPoolRefCount != 0 );
	DNASSERT( g_pThreadPool == pSPData->GetThreadPool() );

	pThreadPool = pSPData->GetThreadPool();

	//
	// remove thread pool reference
	//
	DNASSERT( pThreadPool != NULL );
	g_iThreadPoolRefCount--;
	if ( g_iThreadPoolRefCount == 0 )
	{
		g_pThreadPool = NULL;
	}
	else
	{
		pThreadPool = NULL;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	//
	// Now that we're outside of the lock, clean up and pointers we have.
	// The thread pool will be cleaned up when all of the outstanding interfaces
	// close.
	//
	if ( pThreadPool != NULL )
	{
		pThreadPool->StopAllIO();
		pThreadPool = NULL;
	}
}
//**********************************************************************



/* BUGBUG: [mgere] [xbox] Removed -- multiple adapters not supported on xbox
//**********************************************************************
// ------------------------------
// AddNetworkAdapterToBuffer - add a network address to a packed buffer
//
// Entry:		Pointer to packed buffer
//				Pointer to adapter name
//				Pointer to adapter guid
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "AddNetworkAdapterToBuffer"

HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
								   const char *const pAdapterName,
								   const GUID *const pAdapterGUID )
{
	HRESULT	hr;
	DPN_SERVICE_PROVIDER_INFO	AdapterInfo;


	DNASSERT( pPackedBuffer != NULL );
	DNASSERT( pAdapterName != NULL );
	DNASSERT( pAdapterGUID != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	memset( &AdapterInfo, 0x00, sizeof( AdapterInfo ) );
	DNASSERT( AdapterInfo.dwFlags == 0 );
	DNASSERT( AdapterInfo.pvReserved == NULL );
	DNASSERT( AdapterInfo.dwReserved == NULL );

	AdapterInfo.guid = *pAdapterGUID;

	hr = pPackedBuffer->AddStringToBack( pAdapterName );
	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
	{
		DPF( 0, "Failed to add adapter name to buffer!" );
		goto Failure;
	}
	AdapterInfo.pwszName = static_cast<WCHAR*>( pPackedBuffer->GetTailAddress() );

	hr = pPackedBuffer->AddToFront( &AdapterInfo, sizeof( AdapterInfo ) );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\wsocksp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WSockSP.cpp
 *  Content:	Protocol-independent APIs for the DN Winsock SP
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/26/98	jwo		Created it.
 *	11/1/98		jwo		Un-subclassed everything (moved it to this generic
 *						file from IP and IPX specific ones
 *  03/22/20000	jtk		Updated with changes to interface names
 *	04/22/00	mjn		Allow all flags in DNSP_GetAddressInfo()
 *  08/06/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "wsockspi.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum bandwidth in bits per second
//
#define	UNKNOWN_BANDWIDTH	0

#define WAIT_FOR_CLOSE_TIMEOUT 30000		// milliseconds

#define	ADDRESS_ENCODE_KEY	0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Initialize initializes the instance of the SP.  It must be called
 *		at least once before using any other functions.  Further attempts
 *		to initialize the SP are ignored.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Initialize"

STDMETHODIMP DNSP_Initialize( IDP8ServiceProvider *pThis, SPINITIALIZEDATA *pData )
{
	HRESULT			hr;
	CSPData			*pSPData;
	SOCKET			TestSocket;

	DPF(9, "->DNSP_Initialize (0x%p, 0x%p)\n", pThis, pData);
	DNASSERT( pThis != NULL );
	DNASSERT( pData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	TestSocket = INVALID_SOCKET;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// prevent anyone else from messing with this interface
	//
	pSPData->Lock();

	//
	// check interface state
	//
	switch ( pSPData->GetState() )
	{
		//
		// uninitialized interface, we can initialize it
		//
		case SPSTATE_UNINITIALIZED:
		{
			break;
		}

		//
		// other state
		//
		case SPSTATE_INITIALIZED:
		case SPSTATE_CLOSING:
		default:
		{
			hr = DPNERR_ALREADYINITIALIZED;
			DPF( 0, "Attempted to reinitialize interface!" );
			DNASSERT( FALSE );

			goto Exit;
		}
	}


	//
	// Before we get too far, check for the existance of this protocol by
	// attempting to create a socket.
	//
			TestSocket = p_socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
	
	if ( TestSocket == INVALID_SOCKET )
	{
		DPF( 0, "Creating socket failed, is the protocol installed?" );
		hr = DPNERR_UNSUPPORTED;
		goto Failure;
	}
	
	//
	// remember our init data
	//
	pSPData->SetCallbackData( pData );

	//
	// Success from here on in
	//
	IDP8SPCallback_AddRef( pSPData->DP8SPCallbackInterface() );
	pSPData->SetState( SPSTATE_INITIALIZED );

	pSPData->Unlock();

	IDP8ServiceProvider_AddRef( pThis );

Exit:
	if ( TestSocket != INVALID_SOCKET )
	{
		p_closesocket( TestSocket );
		TestSocket = INVALID_SOCKET;
	}

	DPF(9, "<-DNSP_Initialize(0x%x)", hr);
	return hr;

Failure:
	pSPData->Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Close is the opposite of Initialize.  Call it when you're done
 *		using the SP
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Close"

STDMETHODIMP DNSP_Close( IDP8ServiceProvider *pThis )
{
	HRESULT		hr;
	CSPData		*pSPData;
	
	DNASSERT( pThis != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

			//
			// release our ref to the DPLAY callbacks
			//
			pSPData->Shutdown();
			

			IDP8ServiceProvider_Release( pThis );

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_AddRef - increment reference count
//
// Entry:		Pointer to interface
//
// Exit:		New reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider *pThis )
{	
	CSPData	*pSPData;


	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	return	pSPData->AddRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Release - decrement reference count
//
// Entry:		Pointer to interface
//
// Exit:		New reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider *pThis )
{
	CSPData	*pSPData;

	
	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	return	pSPData->DecRef();
}
//**********************************************************************

//**********************************************************************
/*
 *
 *	DNSP_EnumQuery  sends out the
 *		specified data to the specified address.  If the SP is unable to
 *		determine the address based on the input params, it checks to see
 *		if it's allowed to put up a dialog querying the user for address
 *		info.  If it is, it queries the user for address info.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumQuery"

STDMETHODIMP DNSP_EnumQuery( IDP8ServiceProvider *pThis, SPENUMQUERYDATA *pEnumQueryData)
{
	HRESULT					hr;
	HRESULT					hTempResult;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	CSocketAddress			*pLocalAddress;
//	CSocketPort				*pSocketPort;
	BOOL					fInterfaceReferenceAdded;
	BOOL					fEndpointOpen;
	IDirectPlay8Address		*pDeviceAddress;
	IDirectPlay8Address		*pHostAddress;
	IDirectPlay8Address		*pSPOnlyAddress;
	CSPData					*pSPData;


	DPF(9, "\nEnter:\tDNSP_EnumQuery (0x%p, 0x%p)", pThis, pEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );

	DBG_CASSERT( sizeof( pEnumQueryData->dwRetryInterval ) == sizeof( DWORD ) );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
//	pLocalAddress = NULL;
//	pSocketPort = NULL;
	fInterfaceReferenceAdded = FALSE;
	fEndpointOpen = FALSE;
	pDeviceAddress = NULL;
	pHostAddress = NULL;
	pSPOnlyAddress = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( pSPData != NULL );

	pEnumQueryData->hCommand = NULL;
	pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, "Enuming on device:", pEnumQueryData->pAddressDeviceInfo );
	DumpAddress( 8, "Enum destination:", pEnumQueryData->pAddressHost );

	//
	// duplicate device address
	//
	hTempResult = IDirectPlay8Address_Duplicate( pEnumQueryData->pAddressDeviceInfo, &pDeviceAddress );
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPF( 0, "Failed to duplicate device address!" );
		goto Failure;
	}

//	//
//	// take the device address and fill in any defaults
//	//
//	hTempResult = ApplyDeviceAddressDefaults( pEnumQueryData->pAddressDeviceInfo,
//	    									  pSPData->GetGenericDeviceAddress(),
//	    									  &pDeviceAddress );
//	if ( hTempResult != DPN_OK )
//	{
//	    hr = hTempResult;
//	    goto Failure;
//	}

	//
	// Use the host address supplied by the user.  If no address was supplied,
	// use the broadcast address only if we're not allowed to display a dialog
	// on TCP, or if we're using IPX.  If no address was supplied and we're
	// allowed to display a dialog build a base address with just an SP guid.
	//
	if ( pEnumQueryData->pAddressHost != NULL )
	{
		pHostAddress = pEnumQueryData->pAddressHost;
	}
	else
	{
			DPF( 8, "No host address supplied for enum, using broadcast." );
			pHostAddress = pSPData->GetBroadcastHostAddress();
	}

	//
	// check SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		// provider is initialized
		case SPSTATE_INITIALIZED:
		{
			//
			// no problem
			//
			DNASSERT( hr == DPNERR_PENDING );
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;

			break;
		}

		// provider is uninitialized
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "EnumQuery called on uninitialized SP!" );
			goto Failure;

			break;
		}

		// provider is closing
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "EnumQuery called while SP closing!" );
			goto Failure;

			break;
		}

		// unknown
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		goto Failure;
	}

//    //
//    // determine local adapter address
//    //
//    pLocalAddress = pSPData->GetNewAddress();
//    if ( pLocalAddress == NULL )
//    {
//    	hr = DPNERR_OUTOFMEMORY;
//    	DPF( 0, "Out of memory when attempting to get local address in DNSP_EnumQuery!" );
//    	goto Failure;
//    }
//
//    hr = pLocalAddress->SocketAddressFromDP8Address( pDeviceAddress, SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
//    if ( hr != DPN_OK )
//    {
//        DPF( 0, "Problem parsing adapter address in DNSP_EnumQuery!" );
//        DisplayDNError( 0, hr );
//        goto Failure;
//    }
//
//	//
//	// locate the SocketPort, create one if none are found
//	//
//	hr = pSPData->FindOrCreateSocketPort( pLocalAddress, &pSocketPort, SOCKET_TYPE_ENUM_OR_CONNECT );
//	if ( hr != DPN_OK )
//	{
//		DPF( 0, "Problem attempting to get socket port in DNSP_EnumQuery!" );
//		DisplayDNError( 0, hr );
//		goto Failure;
//	}
//	DNASSERT( pSocketPort != NULL );

	//
	// create and new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot create new endpoint in DNSP_EnumQuery!" );
		goto Failure;
	}

	//
	// get new command and initialize it
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot get command handle for DNSP_EnumQuery!" );
		goto Failure;
	}

	pEnumQueryData->hCommand = pCommand;
	pEnumQueryData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_ENUM_QUERY );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_ENUM, pHostAddress, NULL );
	switch ( hr )
	{
		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  If we're on IPX (no dialog available), don't attempt
		// to display the dialog, skip to checking for broadcast fallback.
		// Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
				if ( ( pEnumQueryData->dwFlags & DPNSPF_NOBROADCASTFALLBACK ) == 0 )
				{
					//
					// we're OK, reset the destination address and reset the
					// function return to 'pending'
					//
					pEndpoint->ReinitializeWithBroadcast();
					hr = DPNERR_PENDING;
					goto SubmitDelayedCommand;
				}
				else
				{
					goto Failure;
				}
			break;
		}

		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
SubmitDelayedCommand:
			//
			// Copy enum data and submit job to finish off enum.
			//
			DNASSERT( pSPData != NULL );
			pEndpoint->CopyEnumQueryData( pEnumQueryData, pDeviceAddress );
			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->EnumQueryJobCallback,
																 pEndpoint->CancelEnumQueryJobCallback,
																 pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPF( 0, "Failed to set delayed enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;

			break;
		}

		default:
		{
			//
			// this endpoint is screwed
			//
			DPF( 0, "Problem initializing endpoint in DNSP_EnumQuery!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
//	//
//	// if there was a socket port created, release our reference to it
//	//
//	if ( pSocketPort != NULL )
//	{
//	    pSocketPort->DecRef();
//	    pSocketPort = NULL;
//	}

//	//
//	// is there a temporary address to free?
//	//
//	if ( pLocalAddress != NULL )
//	{
//	    pSPData->ReturnAddress( pLocalAddress );
//	    pLocalAddress = NULL;
//	}

	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}
	
	DNASSERT( pEndpoint == NULL );

	if ( pSPOnlyAddress != NULL )
	{
		IDirectPlay8Address_Release( pSPOnlyAddress );
		pSPOnlyAddress = NULL;
	}

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPF( 0, "Problem with DNSP_EnumQuery()" );
		DisplayDNError( 0, hr );
	}

	DPF(9, "\nLeave:\tDNSP_EnumQuery\n" );

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pEnumQueryData->hCommand = NULL;
		pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}
		
		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		DNASSERT( pSPData != NULL );
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_EnumRespond  sends a response to an enum request by
 *		sending the specified data to the address provided (on
 *		unreliable transport).
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumRespond"

STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider *pThis, SPENUMRESPONDDATA *pEnumRespondData )
{
	HRESULT			hr;
	CEndpoint		*pEndpoint;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CWriteIOData	*pWriteData;
	CSPData			*pSPData;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEnumQueryContext;


	DNASSERT( pThis != NULL );
	DNASSERT( pEnumRespondData != NULL );
	DNASSERT( pEnumRespondData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEnumQueryContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pEnumRespondData->pQuery );
	pEndpoint = NULL;
	pWriteData = NULL;
	pEnumRespondData->hCommand = NULL;
	pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );
	IDP8ServiceProvider_AddRef( pThis );
	
	//
	// check for valid endpoint
	//
	pEndpoint = pSPData->EndpointFromHandle( pEnumQueryContext->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		DPF( 8, "Invalid endpoint handle in DNSP_EnumRespond" );
		goto Failure;
	}

	//
	// no need to poke at the thread pool here to lock down threads because we
	// can only really be here if there's an enum and that enum locked down the
	// thread pool.
	//

	pWriteData = pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot get new WRITE_IO_DATA for enum response!" );
		goto Failure;
	}

	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pEnumRespondData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	pWriteData->m_uBufferCount = pEnumRespondData->dwBufferCount;
	pWriteData->m_pBuffers = pEnumRespondData->pBuffers;
	pWriteData->m_pDestinationSocketAddress = pEnumQueryContext->pReturnAddress;

	pEnumRespondData->hCommand = pWriteData->m_pCommand;
	pEnumRespondData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data
	//
	pEndpoint->SendEnumResponseData( pWriteData, pEnumQueryContext->dwEnumKey );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	IDP8ServiceProvider_Release( pThis );

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		DNASSERT( pSPData != NULL );
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );

		pEnumRespondData->hCommand = NULL;
		pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;

		pWriteData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Connect "connects" to the specified address.  This doesn't
 *		necessarily mean a real (TCP) connection is made.  It could
 *		just be a virtual UDP connection
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Connect"

STDMETHODIMP DNSP_Connect( IDP8ServiceProvider *pThis, SPCONNECTDATA *pConnectData )
{
	HRESULT					hr;
	HRESULT					hTempResult;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	IDirectPlay8Address		*pDeviceAddress;
	BOOL					fInterfaceReferenceAdded;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;


	DPF(9, "\nEnter:\tDNSP_Connect (0x%p, 0x%p)", pThis, pConnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->pAddressHost != NULL );
	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
//	pLocalAddress = NULL;
//	pSocketPort = NULL;
	pDeviceAddress = NULL;
	fInterfaceReferenceAdded = FALSE;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	pConnectData->hCommand = NULL;
	pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, "Connecting on device:", pConnectData->pAddressDeviceInfo );
	DumpAddress( 8, "Connect destination:", pConnectData->pAddressHost );
	
	hTempResult = IDirectPlay8Address_Duplicate( pConnectData->pAddressDeviceInfo, &pDeviceAddress );
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPF( 0, "Failed to duplicate device address!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// check SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		// provider is initialized
		case SPSTATE_INITIALIZED:
		{
			//
			// no problem, add a reference and proceed
			//
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		// provider is uninitialized
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "Connect called on uninitialized SP!" );

			break;
		}

		// provider is closing
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "Connect called while SP closing!" );

			break;
		}

		// unknown
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}


	//
	// create and new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot create new endpoint in DNSP_Connect!" );
		goto Failure;
	}

	//
	// get new command and initialize it
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot get command handle for DNSP_Connect!" );
		goto Failure;
	}

	pConnectData->hCommand = pCommand;
	pConnectData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_CONNECT );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_CONNECT,
						  pConnectData->pAddressHost,
						  NULL );
	switch ( hr )
	{
		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
			//
			// Copy connection data and submit job to finish off connection.
			// Since we're going to hand off this endpoint, add it to the
			// unbound list so we don't lose track of it.
			//
			DNASSERT( pSPData != NULL );

			pEndpoint->CopyConnectData( pConnectData, pDeviceAddress );
			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ConnectJobCallback,
																 pEndpoint->CancelConnectJobCallback,
																 pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPF( 0, "Failed to set delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;

			break;
		}

		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
				goto Failure;

			break;
		}

		default:
		{
			DPF( 0, "Problem initializing endpoint in DNSP_Connect!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}
	
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPF( 0, "Problem with DNSP_Connect()" );
		DisplayDNError( 0, hr );
	}

	DPF(9, "\nLeave:\tDNSP_Connect\n" );

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pConnectData->hCommand = NULL;
		pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Disconnect disconnects an active connection
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Disconnect"

STDMETHODIMP DNSP_Disconnect( IDP8ServiceProvider *pThis, SPDISCONNECTDATA *pDisconnectData )
{
	HRESULT		hr;
	HRESULT		hTempResult;
	CEndpoint	*pEndpoint;
	CSPData		*pSPData;

	DPF(9, "->DNSP_Disconnect (0x%p, 0x%p)\n", pThis, pDisconnectData);


	DNASSERT( pThis != NULL );
	DNASSERT( pDisconnectData != NULL );
	DNASSERT( pDisconnectData->dwFlags == 0 );
	DNASSERT( pDisconnectData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( pDisconnectData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;
	pDisconnectData->hCommand = NULL;
	pDisconnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to poke at the thread pool here because there was already a connect
	// issued and that connect should have locked down the thread pool.
	//

	//
	// check service provider state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "Disconnect called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "Disconnect called on closing SP!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// look up the endpoint and if it's found, close its handle
	//
	pEndpoint = pSPData->GetEndpointAndCloseHandle( pDisconnectData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		goto Failure;
	}
	
	hTempResult = pEndpoint->Disconnect( pDisconnectData->hEndpoint );
	switch ( hTempResult )
	{
		//
		// endpoint disconnected immediately
		//
		case DPNERR_PENDING:
		case DPN_OK:
		{
			break;
		}

		//
		// Other return.  Since the disconnect didn't complete, we need
		// to unlock the endpoint.
		//
		default:
		{
			DPF( 0, "Error reported when attempting to disconnect endpoint in DNSP_Disconnect!" );
			DisplayDNError( 0, hTempResult );
			DNASSERT( FALSE );

			break;
		}
	}

Exit:
	//
	// remove outstanding reference from GetEndpointHandleAndClose()
	//
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	DPF(9, "<-DNSP_Disconnect(0x%x)", hr);

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Listen "listens" on the specified address/port.  This doesn't
 *		necessarily mean that a true TCP socket is used.  It could just
 *		be a UDP port that's opened for receiving packets
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Listen"

STDMETHODIMP DNSP_Listen( IDP8ServiceProvider *pThis, SPLISTENDATA *pListenData)
{
	HRESULT					hr;
	HRESULT					hTempResult;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	IDirectPlay8Address		*pDeviceAddress;
	BOOL					fInterfaceReferenceAdded;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;


	DPF(9, "->DNSP_Listen (0x%p, 0x%p)\n", pThis, pListenData);

	DNASSERT( pThis != NULL );
	DNASSERT( pListenData != NULL );
	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS |
										  DPNSPF_RELIABLE |
										  DPNSPF_UNRELIABLE |
										  DPNSPF_BINDLISTENTOGATEWAY ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
//	pLocalAddress = NULL;
//	pSocketPort = NULL;
	pDeviceAddress = NULL;
	fInterfaceReferenceAdded = FALSE;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	pListenData->hCommand = NULL;
	pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, "Listening on device:", pListenData->pAddressDeviceInfo );

	//
	// take the device address and fill in any defaults
	//
	hTempResult = IDirectPlay8Address_Duplicate( pListenData->pAddressDeviceInfo, &pDeviceAddress );
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPF( 0, "Failed to duplicate device address!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// check service provider state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "Disconnect called on uninitialized SP!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "Disconnect called on closing SP!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		goto Failure;
	}

	//
	// create and new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot create new endpoint in DNSP_Listen!" );
		goto Failure;
	}

	//
	// get new command and initialize it
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot get command handle for DNSP_Listen!" );
		goto Failure;
	}

	pListenData->hCommand = pCommand;
	pListenData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_LISTEN );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_LISTEN, NULL, NULL );
	switch ( hr )
	{
		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
			//
			// Copy listen data and submit job to finish off listen.
			//
			DNASSERT( pSPData != NULL );

			pEndpoint->CopyListenData( pListenData, pDeviceAddress );
			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ListenJobCallback,
																 pEndpoint->CancelListenJobCallback,
																 pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPF( 0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;

			break;
		}

		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
				goto Failure;

			break;
		}

		default:
		{
			DPF( 0, "Problem initializing endpoint in DNSP_Listen!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}

	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPF( 0, "Problem with DNSP_Listen()" );
		DisplayDNError( 0, hr );
	}

	DPF(9, "\nLeave:\tDNSP_Listen\n" );

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pListenData->hCommand = NULL;
		pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// clean up any outstanding references
	//

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_SendData sends data to the specified "player"
 *
 *	This call MUST BE HIGHLY OPTIMIZED
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_SendData"

STDMETHODIMP DNSP_SendData( IDP8ServiceProvider *pThis, SPSENDDATA *pSendData )
{
	HRESULT			hr;
	CEndpoint		*pEndpoint;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CWriteIOData	*pWriteData;
	CSPData			*pSPData;


	DPF(9, "->DNSP_SendData (0x%p, 0x%p)\n", pThis, pSendData);

	DNASSERT( pThis != NULL );
	DNASSERT( pSendData != NULL );
	DNASSERT( pSendData->pBuffers != NULL );
	DNASSERT( pSendData->dwBufferCount != 0 );
	DNASSERT( pSendData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( ( pSendData->dwFlags & ~( DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pSendData->hCommand = NULL;
	pSendData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pWriteData = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// No need to lock down the thread counts here because the user already has
	// a connect or something running or they wouldn't be calling this function.
	// That outstanding connect would have locked down the thread pool.
	//

	//
	// Attempt to grab the endpoint from the handle.  If this succeeds, the
	// endpoint can send.
	//
	pEndpoint = pSPData->EndpointFromHandle( pSendData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDHANDLE;
		DPF( 0, "Invalid endpoint handle on send!" );
		goto Failure;
	}
	
	//
	// send data from pool
	//
	pWriteData = pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Cannot get new write data from pool in SendData!" );
		goto Failure;
	}
	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->SocketPort() == NULL );

	//
	// set the command state and fill in the message information
	//
	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pSendData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	DNASSERT( pSendData->dwBufferCount != 0 );
	pWriteData->m_uBufferCount = pSendData->dwBufferCount;
	pWriteData->m_pBuffers = pSendData->pBuffers;
	pWriteData->m_pDestinationSocketAddress = pEndpoint->GetRemoteAddressPointer();

	pSendData->hCommand = pWriteData->m_pCommand;
	pSendData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data through the endpoint
	//
	pEndpoint->SendUserData( pWriteData );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );
		DEBUG_ONLY( pWriteData = NULL );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_CancelCommand cancels a command in progress
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_CancelCommand"

STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider *pThis, HANDLE hCommand, DWORD dwCommandDescriptor )
{
	HRESULT hr;
	CCommandData	*pCommandData;
	BOOL			fCommandLocked;
	BOOL			fReferenceAdded;
	CSPData			*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( hCommand != NULL );
	DNASSERT( dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// initialize
	//
	hr = DPN_OK;
	fCommandLocked = FALSE;
	fReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// No need to lock the thread pool counts because there's already some outstanding
	// connect or listen running that has done so.
	//

	//
	// check SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fReferenceAdded = TRUE;
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "CancelCommand called on uninitialized SP!" );
			DNASSERT( FALSE );
			goto Exit;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "CancelCommand called on closing SP!" );
			DNASSERT( FALSE );
			goto Exit;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Exit;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Exit;
	}

	pCommandData = static_cast<CCommandData*>( hCommand );
	pCommandData->Lock();
	fCommandLocked = TRUE;

	//
	// this should never happen
	//
	if ( pCommandData->GetDescriptor() != dwCommandDescriptor )
	{
		hr = DPNERR_INVALIDCOMMAND;
		DPF( 0, "Attempt to cancel command with mismatched command descriptor!" );
		goto Exit;
	}

	switch ( pCommandData->GetState() )
	{
		//
		// unknown command state
		//
		case COMMAND_STATE_UNKNOWN:
		{
			hr = DPNERR_INVALIDCOMMAND;
			DNASSERT( FALSE );
			break;
		}

		//
		// command is waiting to be processed, set command state to be cancelling
		// and wait for someone to pick it up
		//
		case COMMAND_STATE_PENDING:
		{
			pCommandData->SetState( COMMAND_STATE_CANCELLING );
			break;
		}

		//
		// command in progress, and can't be cancelled
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			hr = DPNERR_CANNOTCANCEL;
			break;
		}

		//
		// Command is already being cancelled.  This is not a problem, but shouldn't
		// be happening.
		//
		case COMMAND_STATE_CANCELLING:
		{
			DNASSERT( hr == DPN_OK );
			DNASSERT( FALSE );
			break;
		}

		//
		// command is in progress, find out what type of command it is
		//
		case COMMAND_STATE_INPROGRESS:
		{
			switch ( pCommandData->GetType() )
			{
				case COMMAND_TYPE_UNKNOWN:
				{
					// we should never be here
					INT3;
					break;
				}

				case COMMAND_TYPE_CONNECT:
				{
					// we should never be in this state!
					INT3;
					break;
				}

				case COMMAND_TYPE_LISTEN:
				{
					HRESULT		hTempResult;
					CEndpoint	*pEndpoint;


					//
					// Set this command to the cancel state before we shut down
					// this endpoint.  Make sure a reference is added to the
					// endpoint so it stays around for the cancel.
					//
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pEndpoint = pCommandData->GetEndpoint();
					pEndpoint->AddRef();
					pCommandData->Unlock();
					fCommandLocked = FALSE;

					pEndpoint->Lock();
					switch ( pEndpoint->GetState() )
					{
						//
						// endpoint is already disconnecting, no action needs to be taken
						//
						case ENDPOINT_STATE_DISCONNECTING:
						{
							pEndpoint->Unlock();
							pEndpoint->DecRef();
							goto Exit;
							break;
						}

						//
						// Endpoint is listening.  Flag it as Disconnecting and
						// add a reference so it doesn't disappear on us
						//
						case ENDPOINT_STATE_LISTEN:
						{
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							break;
						}

						//
						// other state
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					pEndpoint->Unlock();

					pSPData->CloseEndpointHandle( pEndpoint );
					pEndpoint->Close( DPNERR_USERCANCEL );
					pEndpoint->DecRef();

					break;
				}

				case COMMAND_TYPE_ENUM_QUERY:
				{
					CEndpoint	 *pEndpoint;


					pEndpoint = pCommandData->GetEndpoint();
					DNASSERT( pEndpoint != NULL );

					pEndpoint->AddRef();
					pEndpoint->Lock();
					pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
					pEndpoint->Unlock();

					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					fCommandLocked = FALSE;
						
					pEndpoint->StopEnumCommand( DPNERR_USERCANCEL );
					pEndpoint->DecRef();

					break;
				}

				case COMMAND_TYPE_SEND:
				{
					// we should never be here
					INT3;
					break;
				}

				default:
				{
					INT3;
					break;
				}
			}

			break;
		}

		//
		// other command state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	if ( fCommandLocked != FALSE  )
	{
		DNASSERT( pCommandData != NULL );
		pCommandData->Unlock();
		fCommandLocked = FALSE;
	}

	if ( fReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fReferenceAdded = FALSE;
	}

	return hr;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_CreateGroup creates a new group (duh)
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_CreateGroup"

STDMETHODIMP DNSP_CreateGroup( IDP8ServiceProvider *pThis, SPCREATEGROUPDATA *pCreateGroupData)
{
	HRESULT 		hr;
	CSocketAddress	*pLocalSocketAddress;
	CSocketAddress	*pMulticastGroupAddress;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pCreateGroupData != NULL );
	DNASSERT( pCreateGroupData->dwFlags == 0 );
	DNASSERT( pCreateGroupData->pAdapterGuid != NULL );
	DNASSERT( ( pCreateGroupData->pGroupData != NULL ) || ( pCreateGroupData->dwGroupDataSize == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;
	pLocalSocketAddress = NULL;
	pMulticastGroupAddress = NULL;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		// provider is initialized
		case SPSTATE_INITIALIZED:
		{
			//
			// no problem, add a reference and proceed
			//
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		// provider is uninitialized
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "CreateGroup called on uninitialized SP!" );

			break;
		}

		// provider is closing
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "CreateGroup called while SP closing!" );

			break;
		}

		// unknown
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// get an address from the pool
	//
	pLocalSocketAddress = pSPData->GetNewAddress();
	if ( pLocalSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to get new address for local socket when creating multicast group!" );
		goto Failure;
	}

	//
	// check for user specified multicast address and parse, if applicable
	//
	if ( pCreateGroupData->pGroupAddress != NULL )
	{
		pMulticastGroupAddress = pSPData->GetNewAddress();
		if ( pMulticastGroupAddress == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPF( 0, "Failed to get new addres for multicast address!" );
			goto Failure;
		}

		hr = pMulticastGroupAddress->SocketAddressFromDP8Address( pCreateGroupData->pGroupAddress, SP_ADDRESS_TYPE_HOST );
		if ( hr != DPN_OK )
		{
			DPF( 0, "Problem parsing user-specified group address in DNSP_CreateGroup!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

	hr = pLocalSocketAddress->CreateMulticastGroup( *pCreateGroupData->pAdapterGuid,
													pMulticastGroupAddress,
													pCreateGroupData->pGroupData,
													&pCreateGroupData->dwGroupDataSize
													);
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem creating multicast group on socket port!" );
		DisplayDNError( 0, hr );
	}

Exit:
	if ( pLocalSocketAddress != NULL )
	{
		pSPData->ReturnAddress( pLocalSocketAddress );
		pLocalSocketAddress = NULL;
	}

	if ( pMulticastGroupAddress != NULL )
	{
		pSPData->ReturnAddress( pMulticastGroupAddress );
		pMulticastGroupAddress = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_DeleteGroup deletes a specified group (duh)
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_DeleteGroup"

STDMETHODIMP DNSP_DeleteGroup( IDP8ServiceProvider *pThis, SPDELETEGROUPDATA *pDeleteGroupData)
{
	HRESULT 		hr;
	BOOL			fInterfaceReferenceAdded;
	CSocketAddress	*pSocketAddress;
	CSPData			*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pDeleteGroupData != NULL );
	DNASSERT( pDeleteGroupData->pAdapterGuid != NULL );
	DNASSERT( pDeleteGroupData->pGroupData != NULL );
	DNASSERT( pDeleteGroupData->dwGroupDataSize == sizeof( MULTICAST_DATA ) );
	DNASSERT( pDeleteGroupData->dwFlags == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSocketAddress = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell the thread pool to lock down the thread counts because
	// creating a group would have done so.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		// provider is initialized
		case SPSTATE_INITIALIZED:
		{
			//
			// no problem, add a reference and proceed
			//
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		// provider is uninitialized
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "DeleteGroup called on uninitialized SP!" );

			break;
		}

		// provider is closing
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "DeleteGroup called while SP closing!" );

			break;
		}

		// unknown
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	pSocketAddress = pSPData->GetNewAddress();
	if ( pSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Failed to get new socket address when destroying multicast group!" );
		goto Failure;
	}

	//
	// destroy multicast group
	//
	hr = pSocketAddress->DeleteMulticastGroup( *pDeleteGroupData->pAdapterGuid,
											   pDeleteGroupData->pGroupData,
											   pDeleteGroupData->dwGroupDataSize );
	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem deleting multicast group!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pSocketAddress != NULL )
	{
		pSPData->ReturnAddress( pSocketAddress );
		pSocketAddress = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_AddToGroup adds a player or group to a group
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_AddToGroup"

STDMETHODIMP DNSP_AddToGroup( IDP8ServiceProvider *pThis, SPADDTOGROUPDATA *pAddToGroupData)
{
	HRESULT	    	hr;
	BOOL	    	fInterfaceReferenceAdded;
	CSocketAddress	*pSocketAddress;
	CEndpoint   	*pEndpoint;
	BOOL	    	fEndpointBound;
	CSPData	    	*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pAddToGroupData != NULL );
	DNASSERT( pAddToGroupData->pAdapterGuid != NULL );
	DNASSERT( pAddToGroupData->pGroupData != 0 );
	DNASSERT( pAddToGroupData->dwGroupDataSize != 0 );
	DNASSERT( ( pAddToGroupData->dwFlags != 0 ) &&
			  ( ( pAddToGroupData->dwFlags & ~( SP_ADD_TO_MULTICAST_GROUP_RECEIVE | SP_ADD_TO_MULTICAST_GROUP_SEND ) ) == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSocketAddress = NULL;
	pEndpoint = NULL;
	fEndpointBound = FALSE;
	pAddToGroupData->hMulticastEndpoint = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized, fail
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing, fail
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// Check SP type
	//
		//
		// Multicast groups are allowed on IP.  Create a socket port and an endpoint
		// and then join the multicast group
		//
			pSocketAddress = pSPData->GetNewAddress();
			if ( pSocketAddress == NULL )
			{
			    hr = DPNERR_OUTOFMEMORY;
			    DPF( 0, "Could not get address to AddToGroup group!" );
			    goto Failure;
			}
			DNASSERT( pSocketAddress != NULL );
			pSocketAddress->ImportMulticastAdapterAddress( *pAddToGroupData->pAdapterGuid, pAddToGroupData->pGroupData, pAddToGroupData->dwGroupDataSize );

			pEndpoint = pSPData->GetNewEndpoint();
			if ( pEndpoint == NULL )
			{
			    hr = DPNERR_OUTOFMEMORY;
			    DPF( 0, "Could not create new endpoint when adding a multicast group!" );
			    goto Failure;
			}

			pSocketAddress->ImportMulticastTargetAddress( pAddToGroupData->pGroupData, pAddToGroupData->dwGroupDataSize );

			hr = pEndpoint->Open( ENDPOINT_TYPE_MULTICAST, NULL, pSocketAddress );
			if ( hr != DPN_OK )
			{
			    DPF( 0, "Failed to open endpoint for multicast!" );
			    DisplayDNError( 0, hr );
			    goto Failure;
			}

			DNASSERT( fEndpointBound == FALSE );
			hr = pSPData->BindEndpoint( pEndpoint, NULL, pSocketAddress, GATEWAY_BIND_TYPE_NONE );
			if ( hr != DPN_OK )
			{
			    DPF( 0, "Failed to bind endpoint to socket port!" );
			    DisplayDNError( 0, hr );
			    goto Failure;
			}
			fEndpointBound = TRUE;

			hr = pEndpoint->GetSocketPort()->AddToMulticastGroup( pAddToGroupData->pGroupData, pAddToGroupData->dwGroupDataSize );
			if ( hr != DPN_OK )
			{
			    DPF( 0, "Problem adding to multicast group!" );
			    DisplayDNError( 0, hr );
			    goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			pAddToGroupData->hMulticastEndpoint = pEndpoint->GetHandle();

Exit:
	if ( pSocketAddress != NULL )
	{
		pSPData->ReturnAddress( pSocketAddress );
		pSocketAddress = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return hr;

Failure:
	if ( pEndpoint != NULL )
	{
		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_RemoveFromGroup removes a player or group from the specified group
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_RemoveFromGroup"

STDMETHODIMP DNSP_RemoveFromGroup( IDP8ServiceProvider *pThis, SPREMOVEFROMGROUPDATA *pRemoveFromGroupData)
{
	HRESULT	    	hr;
	BOOL	    	fInterfaceReferenceAdded;
	CEndpoint   	*pEndpoint;
	CSPData	    	*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pRemoveFromGroupData != NULL );
	DNASSERT( pRemoveFromGroupData->hEndpoint != NULL );
	DNASSERT( pRemoveFromGroupData->pGroupData != NULL );
	DNASSERT( pRemoveFromGroupData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pEndpoint = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count because adding to or
	// creating the group would have done so.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// check SP type
	//
		//
		// Multicast groups are allowed on IP.  Unbind endpoint
		// and remove socket port from group.
		//
			CSocketPort		*pSocketPort;


			pEndpoint = pSPData->GetEndpointAndCloseHandle( pRemoveFromGroupData->hEndpoint );
			if ( pEndpoint != NULL )
			{
			    hr = DPNERR_INVALIDENDPOINT;
			    goto Failure;
			}

			pSocketPort = pEndpoint->GetSocketPort();
			DNASSERT( pSocketPort != NULL );

			pSocketPort->RemoveFromMulticastGroup( pRemoveFromGroupData->pGroupData, pRemoveFromGroupData->dwGroupDataSize );
			pSocketPort = NULL;

			pEndpoint->Close( DPNERR_USERCANCEL );
			pEndpoint->DecCommandRef();
			pEndpoint->DecRef();
			pEndpoint = NULL;

			DNASSERT( hr == DPN_OK );

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetCaps - get SP capabilities
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetCaps"

STDMETHODIMP	DNSP_GetCaps( IDP8ServiceProvider *pThis, SPGETCAPSDATA *pCapsData )
{
	HRESULT		hr;
	BOOL		fInterfaceReferenceAdded;
	CSPData		*pSPData;
	LONG		iIOThreadCount;
	

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// set flags
	//
	pCapsData->dwFlags = 0;
	pCapsData->dwFlags |= ( DPNSPCAPS_SUPPORTSDPNSRV |
							DPNSPCAPS_SUPPORTSBROADCAST |
							DPNSPCAPS_SUPPORTSALLADAPTERS );

	//
	// set frame sizes
	//
	pCapsData->dwUserFrameSize = MAX_USER_PAYLOAD;
	pCapsData->dwEnumFrameSize = 1000;

	//
	// Set link speed, no need to check for endpoint because
	// the link speed cannot be determined.
	//
	pCapsData->dwLocalLinkSpeed = UNKNOWN_BANDWIDTH;

// BUGBUG: [mgere] [xbox] Always 0 since we removed threads
	pCapsData->dwIOThreadCount = 0;

	//
	// set enumeration defaults
	//
	pCapsData->dwDefaultEnumRetryCount = DEFAULT_ENUM_RETRY_COUNT;
	pCapsData->dwDefaultEnumRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
	pCapsData->dwDefaultEnumTimeout = DEFAULT_ENUM_TIMEOUT;

	//
	// set buffering information
	//
	DNASSERT( g_dwWinsockReceiveBufferMultiplier <= UINT32_MAX );
	pCapsData->dwBuffersPerThread = static_cast<DWORD>( g_dwWinsockReceiveBufferMultiplier );
	pCapsData->dwSystemBufferSize = 8192;

	if ( g_fWinsockReceiveBufferSizeOverridden == FALSE )
	{
		SOCKET		TestSocket;
	
		
		TestSocket = INVALID_SOCKET;
				TestSocket = p_socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );

		if ( TestSocket != INVALID_SOCKET )
		{
			INT		iBufferSize;
			INT		iBufferSizeSize;
			INT		iWSAReturn;


			iBufferSizeSize = sizeof( iBufferSize );
			iWSAReturn = p_getsockopt( TestSocket,									// socket
									   SOL_SOCKET,									// socket level option
									   SO_RCVBUF,									// socket option
									   reinterpret_cast<char*>( &iBufferSize ),		// pointer to destination
									   &iBufferSizeSize								// pointer to destination size
									   );
			if ( iWSAReturn != SOCKET_ERROR )
			{
				pCapsData->dwSystemBufferSize = iBufferSize;
			}
			else
			{
				DPF( 0, "Failed to get socket receive buffer options!" );
				DisplayWinsockError( 0, iWSAReturn );
			}

			p_closesocket( TestSocket );
			TestSocket = INVALID_SOCKET;
		}
	}
	else
	{
		pCapsData->dwSystemBufferSize = g_iWinsockReceiveBufferSize;
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_SetCaps - set SP capabilities
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_SetCaps"

STDMETHODIMP	DNSP_SetCaps( IDP8ServiceProvider *pThis, SPSETCAPSDATA *pCapsData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );


	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// validate caps
	//
	if ( pCapsData->dwBuffersPerThread == 0 )
	{
		DPF( 0, "Failing SetCaps because dwBuffersPerThread == 0" );
		hr = DPNERR_INVALIDPARAM;
		goto Failure;
	}

// BUGBUG: [mgere] [xbox] No longer able to set thread count -- document this change
//	hr = GetThreadPool()->SetIOThreadCount( pCapsData->dwIOThreadCount );

	//
	// Only update the thread multiplier if there is a difference.  Give precedence
	// to any values in the registry.
	//
// BUGBUG: [mgere] [xbox] No more than 1 overlapped receive per socket.
/*
	if ( pCapsData->dwBuffersPerThread > g_dwWinsockReceiveBufferMultiplier )
	{
		DWORD	dwDelta;

		dwDelta = 0;

		DNASSERT( g_dwWinsockReceiveBufferMultiplier <= UINT32_MAX );
		dwDelta = pCapsData->dwBuffersPerThread - static_cast<DWORD>( g_dwWinsockReceiveBufferMultiplier );
		g_dwWinsockReceiveBufferMultiplier = pCapsData->dwBuffersPerThread;

		IncreaseOutstandingReceivesOnAllSockets( dwDelta );
	}
*/

	//
	// Only update the buffer size if there is a difference.  Give precedence to
	// any values in the registry.
	//
	DBG_CASSERT( sizeof( pCapsData->dwSystemBufferSize ) == sizeof( g_iWinsockReceiveBufferSize ) );
	if ( pCapsData->dwSystemBufferSize != static_cast<DWORD>( g_iWinsockReceiveBufferSize ) )
	{
		g_fWinsockReceiveBufferSizeOverridden = TRUE;
		g_iWinsockReceiveBufferSize = pCapsData->dwSystemBufferSize;
		pSPData->SetWinsockBufferSizeOnAllSockets( g_iWinsockReceiveBufferSize );
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_ReturnReceiveBuffers - return receive buffers to pool
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ReturnReceiveBuffers"

STDMETHODIMP	DNSP_ReturnReceiveBuffers( IDP8ServiceProvider *pThis, SPRECEIVEDBUFFER *pReceivedBuffers )
{
	SPRECEIVEDBUFFER	*pBuffers;


	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	DNASSERT( pThis != NULL );
	DNASSERT( pReceivedBuffers != NULL );

	pBuffers = pReceivedBuffers;
	while ( pBuffers != NULL )
	{
		SPRECEIVEDBUFFER	*pTemp;
		CReadIOData			*pReadData;


		pTemp = pBuffers;
		pBuffers = pBuffers->pNext;
		pReadData = CReadIOData::ReadDataFromSPReceivedBuffer( pTemp );
		DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
		pReadData->DecRef();
	}

	return	DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetAddressInfo - get address information for an endpoint
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetAddressInfo"

STDMETHODIMP	DNSP_GetAddressInfo( IDP8ServiceProvider *pThis, SPGETADDRESSINFODATA *pGetAddressInfoData )
{
	HRESULT		hr;
	CEndpoint	*pEndpoint;
	CSPData		*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pGetAddressInfoData != NULL );
	DNASSERT( pGetAddressInfoData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( ( pGetAddressInfoData->Flags & ~( SP_GET_ADDRESS_INFO_LOCAL_ADAPTER |
												SP_GET_ADDRESS_INFO_REMOTE_HOST |
												SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES |
												SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS ) ) == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( pGetAddressInfoData->hEndpoint ) );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//
	pEndpoint = pSPData->EndpointFromHandle( pGetAddressInfoData->hEndpoint );
	if ( pEndpoint != NULL )
	{
		switch ( pGetAddressInfoData->Flags )
		{
			case SP_GET_ADDRESS_INFO_REMOTE_HOST:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetRemoteHostDP8Address();
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_ADAPTER:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
				break;
			}

			case SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_HOST );
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS );
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	else
	{
		hr = DPNERR_INVALIDENDPOINT;
	}

	if ( hr != DPN_OK )
	{
		DPF( 0, "Problem getting DNAddress from endpoint!" );
		DisplayDNError( 0, hr );
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_IsApplicationSupported - determine if this application is supported by this
//		SP.
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_IsApplicationSupported"

STDMETHODIMP	DNSP_IsApplicationSupported( IDP8ServiceProvider *pThis, SPISAPPLICATIONSUPPORTEDDATA *pIsApplicationSupportedData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;


	DNASSERT( pThis != NULL );
	DNASSERT( pIsApplicationSupportedData != NULL );
	DNASSERT( pIsApplicationSupportedData->pApplicationGuid != NULL );
	DNASSERT( pIsApplicationSupportedData->dwFlags == 0 );

	//
	// initialize, we support all applications with this SP
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_ProxyEnumQuery - proxy an enum query
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ProxyEnumQuery"

STDMETHODIMP	DNSP_ProxyEnumQuery( IDP8ServiceProvider *pThis, SPPROXYENUMQUERYDATA *pProxyEnumQueryData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CSocketAddress	*pDestinationAddress;
	CSocketAddress	*pReturnAddress;
	CWriteIOData	*pWriteData;
	CEndpoint		*pEndpoint;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEndpointEnumContext;


	DNASSERT( pThis != NULL );
	DNASSERT( pProxyEnumQueryData != NULL );
	DNASSERT( pProxyEnumQueryData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEndpointEnumContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pProxyEnumQueryData->pIncomingQueryData );
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pDestinationAddress = NULL;
	pReturnAddress = NULL;
	pWriteData = NULL;
	pEndpoint = NULL;

	//
	// No need to tell thread pool to lock the thread count for this function
	// because there's already an outstanding enum that did.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPF( 0, "ProxyEnumQuery called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPF( 0, "ProxyEnumQuery called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// preallocate addresses
	//
	pDestinationAddress = pSPData->GetNewAddress();
	if ( pDestinationAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	pReturnAddress = pSPData->GetNewAddress();
	if ( pReturnAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// set the endpoint and send it along
	//
	pEndpoint = pSPData->EndpointFromHandle( pEndpointEnumContext->hEndpoint );
	if ( pEndpoint != NULL )
	{
		//
		// set destination address from the supplied data
		//
		hr = pDestinationAddress->SocketAddressFromDP8Address( pProxyEnumQueryData->pDestinationAdapter,
															   SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET );
		if ( hr != DPN_OK )
		{
			DPF( 0, "ProxyEnumQuery: Failed to convert target adapter address" );
			goto Failure;
		}
	
		//
		// set return address from incoming enum query
		//
	#pragma	BUGBUG( johnkan, "Add a reference to the address!!" )
		DBG_CASSERT( sizeof( *pReturnAddress->GetWritableAddress() ) == sizeof( *( pEndpointEnumContext->pReturnAddress->GetAddress() ) ) );
		memcpy( pReturnAddress->GetWritableAddress(),
				pEndpointEnumContext->pReturnAddress->GetAddress(),
				sizeof( *pReturnAddress->GetWritableAddress() ) );
	
		//
		// get write data from pool
		//
		pWriteData = pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
		if ( pWriteData == NULL )
		{
			DPF( 0, "ProxyEnumQuery: Failed to get write data!" );
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	
		//
		// a new address is allocated here and will be returned in the send complete
		// code
		//
		pWriteData->m_pDestinationSocketAddress = pDestinationAddress;
	
		//
		// Copy the input BUFFERDESC into the local buffers for sending proxied enum data.
		// The second local buffer is reserved for the SP to prepend data
		//
		pWriteData->m_pBuffers = &pWriteData->m_ProxyEnumSendBuffers[ 1 ];
		DBG_CASSERT( sizeof( pWriteData->m_ProxyEnumSendBuffers[ 1 ] ) == sizeof( pProxyEnumQueryData->pIncomingQueryData->pReceivedData->BufferDesc ) );
		memcpy( &pWriteData->m_ProxyEnumSendBuffers[ 1 ],
				&pProxyEnumQueryData->pIncomingQueryData->pReceivedData->BufferDesc,
				sizeof( pWriteData->m_ProxyEnumSendBuffers[ 1 ] ) );
		pWriteData->m_uBufferCount = 1;
		
		//
		// add a reference to the original receive buffer to prevent it from going
		// away while the enum response send is pending
		//
		pWriteData->m_pProxiedEnumReceiveBuffer = CReadIOData::ReadDataFromSPReceivedBuffer( pProxyEnumQueryData->pIncomingQueryData->pReceivedData );
		DNASSERT( pWriteData->m_pProxiedEnumReceiveBuffer != NULL );
		pWriteData->m_pProxiedEnumReceiveBuffer->AddRef();
	
		pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_PROXIED_ENUM_CLEANUP;
	
		pEndpoint->SendProxiedEnumData( pWriteData, pReturnAddress, pEndpointEnumContext->dwEnumKey );
		pEndpoint->DecCommandRef();
	}

Exit:
	if ( pReturnAddress != NULL )
	{
	    pSPData->ReturnAddress( pReturnAddress );
	    pReturnAddress = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\wsockspi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    SPWSOCK master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *  09/11/00	mgere	Converted to DPlay
 *
 ***************************************************************************/

#ifndef __SPWSOCKI_H__
#define __SPWSOCKI_H__

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#include <DPlay8p.h>
#include <DPSP8p.h>
#include <DPAddrp.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

#ifdef __cplusplus

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}

#define ADDREF(p) \
    __AddRef(p)

template <class type> void __Release(type **pp)
{
    type * p = *pp;

    if(p)
    {
        p->Release();
    }
}

#define RELEASE(p) \
    __Release(&(p))

#endif // __cplusplus

// WINSOCK DEFINES

#define p_ntohs ntohs
#define p_htonl htonl
#define p_gethostname gethostname
#define p_WSAGetLastError WSAGetLastError
#define p_gethostbyname gethostbyname
#define p_htons htons
#define p_setsockopt setsockopt
#define p_inet_addr inet_addr
#define p_socket socket
#define p_bind bind
#define p_closesocket closesocket
#define p_getsockname getsockname
#define p_select select
#define p_recvfrom recvfrom
#define p_sendto sendto
#define p___WSAFDIsSet __WSAFDIsSet
#define p_inet_ntoa inet_ntoa
#define p_WSASendTo WSASendTo
#define p_WSARecvFrom WSARecvFrom
#define p_ioctlsocket ioctlsocket
#define p_shutdown shutdown
#define p_WSAGetOverlappedResult WSAGetOverlappedResult
#define p_getsockopt getsockopt

//
// Private includes
//

#include "DNDbg.h"
#include "DNetErrors.h"
#include "debugutils.h"
#include "OSInd.h"
#include "comutil.h"
#include "ClassBilink.h"
#include "ClassFPM.h"
#include "FPM.h"
#include "ClassHash.h"
#include "ContextCFPM.h"
#include "LockedContextFixedPool.h"
#include "LockedPool.h"
#include "PackBuff.h"
#include "StrUtils.h"
#include "LockedCFPM.h"

#include "createin.h"
#include "wsocksp.h"
#include "locals.h"
#include "adapterentry.h"
#include "cmddata.h"
#include "messagestructures.h"
#include "handletables.h"
#include "iodata.h"
#include "poolss.h"
#include "spaddress.h"
#include "ipaddress.h"
#include "sendqueue.h"
//#include "rsip.h"
#include "socketport.h"
#include "jobqueue.h"
#include "threadpool.h"
#include "utils.h"
#include "spdata.h"
#include "endpoint.h"
#include "ipendpt.h"


#endif // __SPWSOCKI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sp\wsock\wsocksp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   WSockSP.h
 *  Content:	declaration of DN Winsock SP functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/26/98	jwo		Created it.
 ***************************************************************************/

#ifndef __WSOCKSP_H__
#define __WSOCKSP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#define VALID_SP_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( DNSPI_DNSP_INT )))
#define VALID_INIT_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPINITDATA )))
#define VALID_ENUMQUERY_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPENUMQUERYDATA )))
#define VALID_ENUMRESPOND_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPENUMRESPONDDATA )))
#define VALID_CONNECT_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPCONNECTDATA )))
#define VALID_DISCONNECT_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPDISCONNECTDATA )))
#define VALID_LISTEN_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPLISTENDATA )))
#define VALID_SENDDATA_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPSENDDATA )))
#define VALID_CREATEGROUP_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPCREATEGROUPDATA )))
#define VALID_ADDTOGROUP_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPADDTOGROUPDATA )))
#define VALID_REMOVEFROMGROUP_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPREMOVEFROMGROUPDATA )))
#define VALID_DELETEGROUP_PTR( ptr ) ( ptr && !IsBadWritePtr( ptr, sizeof( SPDELETEGROUPDATA )))

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
STDAPI DNSP_Initialize( IDP8ServiceProvider*, SPINITIALIZEDATA* );
STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider* pDNSP );
STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider* pDNSP );
STDMETHODIMP DNSP_Connect( IDP8ServiceProvider*, SPCONNECTDATA* );
STDMETHODIMP DNSP_Disconnect( IDP8ServiceProvider*, SPDISCONNECTDATA* );
STDMETHODIMP DNSP_Listen( IDP8ServiceProvider*, SPLISTENDATA* );
STDMETHODIMP DNSP_EnumQuery( IDP8ServiceProvider*, SPENUMQUERYDATA* );
STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider*, SPENUMRESPONDDATA* );
STDMETHODIMP DNSP_SendData( IDP8ServiceProvider*, SPSENDDATA* );
STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider*, HANDLE, DWORD );
STDMETHODIMP DNSP_Close( IDP8ServiceProvider* );
STDMETHODIMP DNSP_CreateGroup( IDP8ServiceProvider*, SPCREATEGROUPDATA* );
STDMETHODIMP DNSP_DeleteGroup( IDP8ServiceProvider*, SPDELETEGROUPDATA* );
STDMETHODIMP DNSP_AddToGroup( IDP8ServiceProvider*, SPADDTOGROUPDATA* );
STDMETHODIMP DNSP_RemoveFromGroup( IDP8ServiceProvider*, SPREMOVEFROMGROUPDATA* );
STDMETHODIMP DNSP_GetCaps( IDP8ServiceProvider*, SPGETCAPSDATA* );
STDMETHODIMP DNSP_SetCaps( IDP8ServiceProvider*, SPSETCAPSDATA* );
STDMETHODIMP DNSP_ReturnReceiveBuffers( IDP8ServiceProvider*, SPRECEIVEDBUFFER* );
STDMETHODIMP DNSP_GetAddressInfo( IDP8ServiceProvider*, SPGETADDRESSINFODATA* );
STDMETHODIMP DNSP_IsApplicationSupported( IDP8ServiceProvider*, SPISAPPLICATIONSUPPORTEDDATA* );
STDMETHODIMP DNSP_ProxyEnumQuery( IDP8ServiceProvider*, SPPROXYENUMQUERYDATA* );

#endif	// __WSOCKSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\simplepeer\netconnectres.h ===
#define IDD_MULTIPLAYER_CONNECT         10001
#define IDD_MULTIPLAYER_GAMES           10002
#define IDD_MULTIPLAYER_CREATE          10003
#define IDC_RETURN                      11001
#define IDC_PLAYER_NAME_EDIT            11002
#define IDC_GAMES_LIST                  11003
#define IDC_JOIN                        11004
#define IDC_CREATE                      11005
#define IDC_CONNECTION_LIST             11006
#define IDC_BACK                        11007
#define IDC_EDIT_SESSION_NAME           11009
#define IDC_SEARCH_CHECK                11010
#define IDC_WAIT_TEXT                   11012
#define IDC_MIGRATE_HOST                11013 
#define IDI_MAIN                        11014
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\join\test.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       test.cpp
 *  Content:    DirectPlay test app
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    mgere  Created.
 *
 ****************************************************************************/

#include <xtl.h>
#include <dplay8.h>
#include <dpaddr.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

DWORD WINAPI WorkerThread( void *pParam );
HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );

HANDLE			g_hEvent = NULL;
HANDLE			g_hConnectEvent = NULL;
LPDIRECTPLAY8ADDRESS        g_pConnectDeviceAddress;
LPDIRECTPLAY8ADDRESS        g_pConnectHostAddress;
DPN_APPLICATION_DESC        g_pConnectAppDesc;
LPDIRECTPLAY8PEER           pDP;
DPNHANDLE                   g_hEnumAsyncOp;
DPNID              g_dpnidLocalPlayer            = 0;       // DPNID of local player
LONG               g_lNumberOfActivePlayers      = 0;       // Number of players currently in game
TCHAR              g_strLocalPlayerName[MAX_PATH];          // Local player name
BOOL               g_fThreadRun = FALSE;

#define MAX_PLAYER_NAME         14

struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    TCHAR strPlayerName[MAX_PLAYER_NAME];   // Player name
};

#define GAME_MSGID_WAVE        1
struct GAMEMSG_GENERIC
{
    DWORD dwType;
};

void __cdecl main()
{
    HRESULT                     hr;
    LPDIRECTPLAY8ADDRESS        pDeviceAddress;
    LPDIRECTPLAY8ADDRESS        pHostAddress;
    DWORD                       dwItems     = 0;
    DWORD                       dwSize      = 0;
    DPN_SP_CAPS                 dpspCaps;
    DPN_APPLICATION_DESC        dnAppDesc;
    GUID                        guidApp = { 0x2ae836d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 } };
    INT                         err = 0;
    DWORD			dwPort = 2350;
    DPN_PLAYER_INFO dpPlayerInfo;
    WCHAR wszSessionName[MAX_PATH];
    DPNHANDLE                   hConnectAsyncOp;
    GAMEMSG_GENERIC msgWave;
    DPN_BUFFER_DESC bufferDesc;
    DPNHANDLE hAsync;
    DPNHANDLE hAsyncSetPeerInfo;
    TCHAR pwszURL[256];
    DWORD dwThreadID = 0;
    HANDLE hThread = NULL;

    __asm int 3

    g_hEvent = CreateEvent(NULL, TRUE, FALSE,NULL);
    g_hConnectEvent = CreateEvent(NULL, TRUE, FALSE,NULL);

    ResetEvent(g_hEvent);    

    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR)
        __asm int 3

    hr = DPlayInitialize();

    if (FAILED(hr))
    {
        __asm int 3;
    }

    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) &pDP, NULL);
    if( FAILED(hr) )
        __asm int 3

    g_fThreadRun = TRUE;

    hr = pDP->Initialize( NULL, DirectPlayMessageHandler, 0 );
    if( FAILED(hr) )
        __asm int 3

    hThread = CreateThread( NULL, 0, WorkerThread, 0, 0, &dwThreadID );

    // Create a device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pDeviceAddress, NULL);
    if( FAILED(hr) )
        __asm int 3

    // Create a host address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pHostAddress, NULL);
    if( FAILED(hr) )
        __asm int 3

    pHostAddress->BuildAddress(L"157.56.11.107", 2350);
//    pHostAddress->BuildAddress(L"157.56.10.90", 2350);

    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = guidApp;

    ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = L"MarkXboxJoiner";

    hr = pDP->SetPeerInfo( &dpPlayerInfo, NULL, &hAsyncSetPeerInfo, 0 );
    if( FAILED( hr ) )
        __asm int 3

    DWORD dwData = 42;

    hr = pDP->Connect( &dnAppDesc, pHostAddress, pDeviceAddress, NULL, NULL, (PVOID) &dwData,sizeof(DWORD), NULL, NULL, &hConnectAsyncOp, 0 );
    if (hr == DPNERR_INCOMPLETEADDRESS )
        __asm int 3;

    if (hr == DPNERR_INVALIDHOSTADDRESS )
        __asm int 3;

    if( hr != E_PENDING && FAILED(hr) )
        __asm int 3

    WaitForSingleObject(g_hConnectEvent, INFINITE);

    msgWave.dwType = GAME_MSGID_WAVE;
    bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
    bufferDesc.pBufferData  = (BYTE*) &msgWave;

    pDP->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1, 0, NULL, &hAsync, DPNSEND_NOLOOPBACK );

    SleepEx(15000, FALSE);

    pDP->Close(0);
    g_fThreadRun = FALSE;
    SleepEx(1000, FALSE);
    pDP->Release();
    pDeviceAddress->Release();
    pHostAddress->Release();

    hr = DPlayCleanup();

    if (FAILED(hr))
    {
        __asm int 3;
    }

    __asm int 3
}

DWORD WINAPI WorkerThread( void *pParam )
{
    while (1)
    {
	if (g_fThreadRun && pDP->DoWork(0) == S_FALSE)
	{
            SleepEx(10, FALSE);
	}
    }

    return 0;
}

HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer )
{
    switch( dwMessageId )
    {
        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            hr = pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL )
                return hr;

            pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
            ZeroMemory( pdpPlayerInfo, dwSize );
            pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
            hr = pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) )
                return hr;

            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->lRefCount   = 1;
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            delete pdpPlayerInfo;

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &g_lNumberOfActivePlayers );

            if (g_lNumberOfActivePlayers == 2){
//                SetEvent(g_hConnectEvent);
            }

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            if( pPlayerInfo )
            {
                pPlayerInfo->lRefCount--;
                if( pPlayerInfo->lRefCount <= 0 )
                    delete pPlayerInfo;
            }
            pPlayerInfo = NULL;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &g_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_HOST_MIGRATE:
        {
            PDPNMSG_HOST_MIGRATE pHostMigrateMsg;
            pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE)pMsgBuffer;

            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            HRESULT hr;
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;
            APP_PLAYER_INFO* pPlayerInfo2 = NULL;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            if( pMsg->dwType == GAME_MSGID_WAVE )
            {
                // This message is sent when a player has waved to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
/*
                hr = pDP->GetPlayerContext( pPlayerInfo->dpnidPlayer, (LPVOID* const) &pPlayerInfo2, 0);

                if( pPlayerInfo2 )
                    pPlayerInfo2->lRefCount++;

                if( FAILED(hr) || pPlayerInfo2 == NULL )
                {
                    // The player who sent this may have gone away before this 
                    // message was handled, so just ignore it
                    break;
                }
            
                // Make wave message and display it.
                TCHAR szWaveMessage[MAX_PATH];
                wsprintf( szWaveMessage, TEXT("%s just waved at you, %s!\r\n"), 
                          pPlayerInfo2->strPlayerName, g_strLocalPlayerName );

                if( pPlayerInfo2 )
                {
                    pPlayerInfo2->lRefCount--;
                    if( pPlayerInfo2->lRefCount <= 0 )
                         delete pPlayerInfo2;
                }
                pPlayerInfo2 = NULL;
*/
            }

            SetEvent(g_hEvent);

            break;
        }

        case DPN_MSGID_CONNECT_COMPLETE:
        {
            HRESULT hrConnectComplete;
            PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
            pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE)pMsgBuffer;

            hrConnectComplete = pConnectCompleteMsg->hResultCode;

//            SetEvent(g_hConnectEvent);

            break;
        }

        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
        {
            HRESULT hr = S_OK;
            PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg;
            pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE)pMsgBuffer;

            const DPN_APPLICATION_DESC* pResponseMsgAppDesc = pEnumHostsResponseMsg->pApplicationDescription;
            hr = pEnumHostsResponseMsg->pAddressDevice->Duplicate( &g_pConnectDeviceAddress );
            hr = pEnumHostsResponseMsg->pAddressSender->Duplicate( &g_pConnectHostAddress );
            memcpy( &g_pConnectAppDesc, pResponseMsgAppDesc, sizeof(DPN_APPLICATION_DESC) );

            pDP->CancelAsyncOperation( g_hEnumAsyncOp, 0 );

            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

            break;
        }

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\host\test.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       test.cpp
 *  Content:    DirectPlay Host Test App
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    mgere  Created.
 *
 ****************************************************************************/

#include <xtl.h>
#include <dplay8.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

DWORD WINAPI WorkerThread( void *pParam );
HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );

HANDLE			g_hEvent = NULL;
HANDLE			g_hConnectEvent = NULL;
LPDIRECTPLAY8ADDRESS        g_pConnectDeviceAddress;
LPDIRECTPLAY8ADDRESS        g_pConnectHostAddress;
DPN_APPLICATION_DESC        g_pConnectAppDesc;
LPDIRECTPLAY8PEER           pDP;
DPNHANDLE                   g_hEnumAsyncOp;
DPNID              g_dpnidLocalPlayer            = 0;       // DPNID of local player
LONG               g_lNumberOfActivePlayers      = 0;       // Number of players currently in game
TCHAR              g_strLocalPlayerName[MAX_PATH];          // Local player name
DPNID		g_dpnidOneOfThePlayers = 0;
BOOL            g_fThreadRun = FALSE;

#define MAX_PLAYER_NAME         14

struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    TCHAR strPlayerName[MAX_PLAYER_NAME];   // Player name
};

#define GAME_MSGID_WAVE        1
struct GAMEMSG_GENERIC
{
    DWORD dwType;
    CHAR blah[256];
};

void __cdecl main()
{
    HRESULT                     hr;
    LPDIRECTPLAY8ADDRESS        pDeviceAddress;
    LPDIRECTPLAY8ADDRESS        pHostAddress;
    DWORD                       dwItems     = 0;
    DWORD                       dwSize      = 0;
    DPN_SP_CAPS                 dpspCaps;
    DPN_APPLICATION_DESC        dnAppDesc;
    GUID                        guidApp = { 0x2ae836d, 0x9179, 0x485f, { 0x83, 0x43, 0x90, 0x1d, 0x32, 0x7c, 0xe7, 0x94 } };
    INT                         err = 0;
    DWORD			dwPort = 2350;
    DPN_PLAYER_INFO dpPlayerInfo;
    WCHAR wszSessionName[MAX_PATH];
    DPNHANDLE                   hConnectAsyncOp;
    GAMEMSG_GENERIC msgWave;
    DPN_BUFFER_DESC bufferDesc;
    DPNHANDLE hAsync;
    DWORD dwThreadID = 0;
    HANDLE hThread = NULL;
    DPN_GROUP_INFO dpngi;

    __asm int 3

    g_hEvent = CreateEvent(NULL, TRUE, FALSE,NULL);
    g_hConnectEvent = CreateEvent(NULL, TRUE, FALSE,NULL);

    ResetEvent(g_hEvent);    
    ResetEvent(g_hConnectEvent);    

    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR)
        __asm int 3

    hr = DPlayInitialize();
    if (FAILED(hr))
    {
        __asm int 3;
    }

    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) &pDP, NULL);
    if( FAILED(hr) )
        __asm int 3

    g_fThreadRun = TRUE;

    hr = pDP->Initialize( NULL, DirectPlayMessageHandler, 0 );
    if( FAILED(hr) )
        __asm int 3

    dpspCaps.dwSize = sizeof( DPN_SP_CAPS );

    pDP->GetSPCaps(NULL, &dpspCaps,0);
    dpspCaps.dwSystemBufferSize = 8192;
    pDP->SetSPCaps(NULL, &dpspCaps,0);
    pDP->SetSPCaps(NULL, &dpspCaps,0);

    hThread = CreateThread( NULL, 0, WorkerThread, 0, 0, &dwThreadID );

    // Create a device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &pDeviceAddress, NULL);
    if( FAILED(hr) )
        __asm int 3

    pDeviceAddress->AddComponent( L"port", (void*) &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD );

    ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
    dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = guidApp;
    dnAppDesc.pwszSessionName = L"MyGamexboxblah";
    dnAppDesc.dwMaxPlayers    = 5;
    dnAppDesc.dwFlags         = 0;

    hr = pDP->Host( &dnAppDesc, &pDeviceAddress, 1, NULL, NULL, NULL, 0 );
    if( FAILED( hr ) )
        __asm int 3

    WaitForSingleObject(g_hConnectEvent, INFINITE);

    msgWave.dwType = GAME_MSGID_WAVE;
    bufferDesc.dwBufferSize = sizeof(GAMEMSG_GENERIC);
    bufferDesc.pBufferData  = (BYTE*) &msgWave;

//    while (1)
    pDP->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1, 0, NULL, &hAsync, DPNSEND_NOLOOPBACK );

//    pDP->TerminateSession(NULL, 0, 0);

    SleepEx(15000, FALSE);

    g_fThreadRun = FALSE;
    pDP->Close(0);
//    SleepEx(1000, FALSE);
    pDP->Release();
    pDeviceAddress->Release();

    hr = DPlayCleanup();
    if (FAILED(hr))
    {
        __asm int 3;
    }

    __asm int 3
}

DWORD WINAPI WorkerThread( void *pParam )
{
    while (1)
    {
        if (g_fThreadRun && pDP->DoWork(0) == S_FALSE)
	{
            SleepEx(10, FALSE);
	}
    }

    return 0;
}

HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer )
{
    static HRESULT hrConnectResult = E_FAIL;

    switch( dwMessageId )
    {
        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            hr = pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL )
                return hr;

            pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
            ZeroMemory( pdpPlayerInfo, dwSize );
            pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
            hr = pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( FAILED(hr) )
                return hr;

            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->lRefCount   = 1;
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;

g_dpnidOneOfThePlayers = pPlayerInfo->dpnidPlayer;

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                g_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            delete pdpPlayerInfo;

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &g_lNumberOfActivePlayers );

            if (g_lNumberOfActivePlayers == 2){
                SetEvent(g_hConnectEvent);
            }

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            if( pPlayerInfo )
            {
                pPlayerInfo->lRefCount--;
                if( pPlayerInfo->lRefCount <= 0 )
                    delete pPlayerInfo;
            }
            pPlayerInfo = NULL;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &g_lNumberOfActivePlayers );

            SetEvent(g_hEvent);

            break;
        }

        case DPN_MSGID_HOST_MIGRATE:
        {
            PDPNMSG_HOST_MIGRATE pHostMigrateMsg;
            pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE)pMsgBuffer;

            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            HRESULT hr;
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;
            APP_PLAYER_INFO* pPlayerInfo2 = NULL;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            if( pMsg->dwType == GAME_MSGID_WAVE )
            {
                // This message is sent when a player has waved to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
/*
                hr = pDP->GetPlayerContext( pPlayerInfo->dpnidPlayer, (LPVOID* const) &pPlayerInfo2, 0);

                if( pPlayerInfo2 )
                    pPlayerInfo2->lRefCount++;

                if( FAILED(hr) || pPlayerInfo2 == NULL )
                {
                    // The player who sent this may have gone away before this 
                    // message was handled, so just ignore it
                    break;
                }
            
                // Make wave message and display it.
                TCHAR szWaveMessage[MAX_PATH];
                wsprintf( szWaveMessage, TEXT("%s just waved at you, %s!\r\n"), 
                          pPlayerInfo2->strPlayerName, g_strLocalPlayerName );

                if( pPlayerInfo2 )
                {
                    pPlayerInfo2->lRefCount--;
                    if( pPlayerInfo2->lRefCount <= 0 )
                         delete pPlayerInfo2;
                }
                pPlayerInfo2 = NULL;
*/
            }

            SetEvent(g_hEvent);

            break;
        }

        case DPN_MSGID_INDICATE_CONNECT:
        {
//            SetEvent(g_hConnectEvent);

		if (hrConnectResult == E_FAIL)
		{
			hrConnectResult = S_OK;
			return E_FAIL;
		}
            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

            break;
        }

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\test\simplepeer\netconnect.cpp ===
//-----------------------------------------------------------------------------
// File: NetConnect.cpp
//
// Desc: This is a class that given a IDirectPlay8Peer, then DoConnectWizard()
//       will enumerate service providers, enumerate hosts, and allow the
//       user to either join or host a session.  The class uses
//       dialog boxes and GDI for the interactive UI.  Most games will
//       want to change the graphics to use Direct3D or another graphics
//       layer, but this simplistic sample uses dialog boxes.  Feel 
//       free to use this class as a starting point for adding extra 
//       functionality.
//
//@@BEGIN_MSINTERNAL
//
// Hist: 10.26.99 - jasonsa - Created
//       01.15.00 - jasonsa - updated to dx8
//       02.24.00 - rodtoll - Fixed improper delete call and local port set
//       04.25.00 - jasonsa - various bug fixes along the way
//       05.11.00 - rodtoll - Added deep copy and lock of app desc
//
//@@END_MSINTERNAL
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <stdio.h>
#include <mmsystem.h>
#include <dplay8.h>
#include <dpaddr.h>
#include "NetConnect.h"
#include "NetConnectRes.h"
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
CNetConnectWizard* g_pNCW = NULL;           // Pointer to the net connect wizard




//-----------------------------------------------------------------------------
// Name: CNetConnectWizard
// Desc: Init the class
//-----------------------------------------------------------------------------
CNetConnectWizard::CNetConnectWizard( HINSTANCE hInst, TCHAR* strAppName,
                                      GUID* pGuidApp )
{
    g_pNCW              = this;
    m_hInst             = hInst;
    m_pDP               = NULL;
    m_guidApp           = *pGuidApp;
    m_hDlg              = NULL;
    m_bConnecting       = FALSE;
    m_hConnectAsyncOp   = NULL;
    m_pDeviceAddress    = NULL;
    m_pHostAddress      = NULL;
    m_hEnumAsyncOp      = NULL;
    m_dwEnumHostExpireInterval = 0;

    // Set the max players unlimited by default.  This can be changed by the app
    // by calling SetMaxPlayers()
    m_dwMaxPlayers   = 0;

    _tcscpy( m_strAppName, strAppName );
    _tcscpy( m_strPreferredProvider, TEXT("DirectPlay8 TCP/IP Service Provider") );

    InitializeCriticalSection( &m_csHostEnum );
    m_hConnectCompleteEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    // Setup the m_DPHostEnumHead circular linked list
    ZeroMemory( &m_DPHostEnumHead, sizeof( DPHostEnumInfo ) );
    m_DPHostEnumHead.pNext = &m_DPHostEnumHead;
}




//-----------------------------------------------------------------------------
// Name: ~CNetConnectWizard
// Desc: Cleanup the class
//-----------------------------------------------------------------------------
CNetConnectWizard::~CNetConnectWizard()
{
    DeleteCriticalSection( &m_csHostEnum );
    CloseHandle( m_hConnectCompleteEvent );

    SAFE_RELEASE( m_pDeviceAddress );
    SAFE_RELEASE( m_pHostAddress );
}



//-----------------------------------------------------------------------------
// Name: Init
// Desc:
//-----------------------------------------------------------------------------
VOID CNetConnectWizard::Init( IDirectPlay8Peer* pDP )
{
    m_pDP               = pDP;
}



//-----------------------------------------------------------------------------
// Name: DoConnectWizard
// Desc: This is the main external function.  This will launch a series of
//       dialog boxes that enumerate service providers, enumerate hosts,
//       and allow the user to either join or host a session
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::DoConnectWizard( BOOL bBackTrack )
{
    if( m_pDP == NULL )
        return E_INVALIDARG;

    int nStep;

    // If the back track flag is true, then the user has already been through
    // the connect process once, and has back tracked out of the main game
    // so start at the last dialog box
    if( bBackTrack )
        nStep = 1;
    else
        nStep = 0;

    // Show the dialog boxes to connect
    while( TRUE )
    {
        m_hrDialog = S_OK;

        switch( nStep )
        {
            case 0:
                // Display the multiplayer connect dialog box.
                DialogBox( m_hInst, MAKEINTRESOURCE(IDD_MULTIPLAYER_CONNECT),
                           NULL, (DLGPROC) StaticConnectionsDlgProc );
                break;

            case 1:
                // Display the multiplayer games dialog box.
                DialogBox( m_hInst, MAKEINTRESOURCE(IDD_MULTIPLAYER_GAMES),
                           NULL, (DLGPROC) StaticSessionsDlgProc );
                break;
        }

        if( FAILED( m_hrDialog ) ||
            m_hrDialog == NCW_S_QUIT )
            break;

        if( m_hrDialog == NCW_S_BACKUP )
            nStep--;
        else
            nStep++;

        // If we go beyond the last step in the wizard, then stop
        // and return.
        if( nStep == 2 )
            break;
    }

    // Depending upon a successful m_hrDialog the user has
    // either successfully join or created a game, depending on m_bHostPlayer
    m_pDP = NULL;
    return m_hrDialog;
}




//-----------------------------------------------------------------------------
// Name: StaticConnectionsDlgProc()
// Desc: Static msg handler which passes messages
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CNetConnectWizard::StaticConnectionsDlgProc( HWND hDlg, UINT uMsg,
                                                              WPARAM wParam, LPARAM lParam )
{
    if( g_pNCW )
        return g_pNCW->ConnectionsDlgProc( hDlg, uMsg, wParam, lParam );

    return FALSE; // Message not handled
}




//-----------------------------------------------------------------------------
// Name: ConnectionsDlgProc()
// Desc: Handles messages for the multiplayer connect dialog
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CNetConnectWizard::ConnectionsDlgProc( HWND hDlg, UINT msg,
                                                        WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
        case WM_INITDIALOG:
            {
                SetDlgItemText( hDlg, IDC_PLAYER_NAME_EDIT, m_strLocalPlayerName );

                // Load and set the icon
                HICON hIcon = LoadIcon( m_hInst, MAKEINTRESOURCE( IDI_MAIN ) );
                SendMessage( hDlg, WM_SETICON, ICON_BIG,   (LPARAM) hIcon );  // Set big icon
                SendMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIcon );  // Set small icon

                // Set the window title
                TCHAR strWindowTitle[256];
                wsprintf( strWindowTitle, TEXT("%s - Multiplayer Connect"), m_strAppName );
                SetWindowText( hDlg, strWindowTitle );

                // Fill the list box with the service providers
                if( FAILED( m_hrDialog = ConnectionsDlgFillListBox( hDlg ) ) )
                {
                    EndDialog( hDlg, 0 );
                }
            }
            break;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_CONNECTION_LIST:
                    if( HIWORD(wParam) != LBN_DBLCLK )
                        break;
                    // Fall through

                case IDOK:
                    if( FAILED( m_hrDialog = ConnectionsDlgOnOK( hDlg ) ) )
                    {
                        EndDialog( hDlg, 0 );
                    }
                    break;

                case IDCANCEL:
                    m_hrDialog = NCW_S_QUIT;
                    EndDialog( hDlg, 0 );
                    break;

                default:
                    return FALSE; // Message not handled
            }
            break;

        case WM_DESTROY:
            ConnectionsDlgCleanup( hDlg );
            break;

        default:
            return FALSE; // Message not handled
    }

    // Message was handled
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ConnectionsDlgFillListBox()
// Desc: Fills the DirectPlay connection listbox with service providers,
//       and also adds a "Wait for Lobby" connection option.
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::ConnectionsDlgFillListBox( HWND hDlg )
{
    HRESULT                     hr;
    int                         iLBIndex;
    DWORD                       dwItems     = 0;
    DPN_SERVICE_PROVIDER_INFO*  pdnSPInfo   = NULL;
    DWORD                       dwSize      = 0;
    HWND                        hWndListBox = GetDlgItem( hDlg, IDC_CONNECTION_LIST );
    TCHAR                       strName[MAX_PATH];

    // Enumerate all DirectPlay service providers, and store them in the listbox
    hr = m_pDP->EnumServiceProviders( NULL, NULL, pdnSPInfo, &dwSize,
                                      &dwItems, 0 );
    if( hr != DPNERR_BUFFERTOOSMALL )
        return hr;

    pdnSPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
    if( FAILED( hr = m_pDP->EnumServiceProviders( NULL, NULL, pdnSPInfo,
                                                  &dwSize, &dwItems, 0 ) ) )
        return hr;

    DPN_SERVICE_PROVIDER_INFO* pdnSPInfoEnum = pdnSPInfo;
    for ( DWORD i = 0; i < dwItems; i++ )
    {
        DXUtil_ConvertWideStringToGeneric( strName, pdnSPInfoEnum->pwszName );

        // Found a service provider, so put it in the listbox
        iLBIndex = (int)SendMessage( hWndListBox, LB_ADDSTRING, 0,
                                     (LPARAM)strName );
        if( iLBIndex == CB_ERR )
            return E_FAIL; // Error, stop enumerating

        // Store pointer to GUID in listbox
        GUID* pGuid = new GUID;
        memcpy( pGuid, &pdnSPInfoEnum->guid, sizeof(GUID) );
        SendMessage( hWndListBox, LB_SETITEMDATA, iLBIndex,
                     (LPARAM)pGuid );

        pdnSPInfoEnum++;
    }

    SAFE_DELETE( pdnSPInfo );

    SetFocus( hWndListBox );

    // Try to select the default preferred provider
    iLBIndex = (int)SendMessage( hWndListBox, LB_FINDSTRINGEXACT, (WPARAM)-1,
                                (LPARAM)m_strPreferredProvider );
    if( iLBIndex != LB_ERR )
        SendMessage( hWndListBox, LB_SETCURSEL, iLBIndex, 0 );
    else
        SendMessage( hWndListBox, LB_SETCURSEL, 0, 0 );


    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ConnectionsDlgOnOK()
// Desc: Stores the player name m_strPlayerName, and in creates a IDirectPlay
//       object based on the connection type the user selected.
//-----------------------------------------------------------------------------
HRESULT CNetConnectWizard::ConnectionsDlgOnOK( HWND hDlg )
{
    LRESULT iIndex;
    HRESULT hr;

    GetDlgItemText( hDlg, IDC_PLAYER_NAME_EDIT, m_strLocalPlayerName, MAX_PATH );

    if( _tcslen( m_strLocalPlayerName ) == 0 )
    {
        MessageBox( hDlg, TEXT("You must enter a valid player name."),
                    TEXT("DirectPlay Sample"), MB_OK );
        return S_OK;
    }

    HWND hWndListBox = GetDlgItem( hDlg, IDC_CONNECTION_LIST );

    iIndex = SendMessage( hWndListBox, LB_GETCURSEL, 0, 0 );
    SendMessage( hWndListBox, LB_GETTEXT, iIndex, (LPARAM)m_strPreferredProvider );

    GUID* pGuid = (GUID*) SendMessage( hWndListBox, LB_GETITEMDATA, iIndex, 0 );

    // Query for the enum host timeout for this SP
    DPN_SP_CAPS dpspCaps;
    ZeroMemory( &dpspCaps, sizeof(DPN_SP_CAPS) );
    dpspCaps.dwSize = sizeof(DPN_SP_CAPS);
    if( FAILED( hr = m_pDP->GetSPCaps( pGuid, &dpspCaps, 0 ) ) )
        return hr;

    // Set the host expire time to around 3 times
    // length of the dwDefaultEnumRetryInterval
    m_dwEnumHostExpireInterval = dpspCaps.dwDefaultEnumRetryInterval * 3;

    // Create a device address
    SAFE_RELEASE( m_pDeviceAddress );
    hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
                           IID_IDirectPlay8Address, (LPVOID*) &m_pDeviceAddress );
    if( FAILED(hr) )
        return hr;

    if( FAILED( hr = m_pDeviceAddress->SetSP( pGuid ) ) )
        return hr;

    // Create a host address
    SAFE_RELEASE( m_pHostAddress );
    hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
                           IID_IDirectPlay8Address, (LPVOID*) &m_pHostAddress );
    if( FAILED(hr) )
        return hr;

    if( FAILED( hr = m_pHostAddress->SetSP( pGuid ) ) )
        return hr;

    // The SP has been chosen, so move forward in the wizard
    m_hrDialog = NCW_S_FORWARD;
    EndDialog( hDlg, 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ConnectionsDlgCleanup()
// Desc: Deletes the connection buffers from the listbox
//-----------------------------------------------------------------------------
VOID CNetConnectWizard::ConnectionsDlgCleanup( HWND hDlg )
{
    GUID*   pGuid = NULL;
    DWORD   iIndex;
    DWORD   dwCount;

    HWND hWndListBox = GetDlgItem( hDlg, IDC_CONNECTION_LIST );

    dwCount = (DWORD)SendMessage( hWndListBox, LB_GETCOUNT, 0, 0 );
    for( iIndex = 0; iIndex < dwCount; iIndex++ )
    {
        pGuid = (GUID*) SendMessage( hWndListBox, LB_GETITEMDATA,
                                     iIndex, 0 );
        SAFE_DELETE( pGuid );
    }
}




//-----------------------------------------------------------------------------
// Name: StaticSessionsDlgProc()
// Desc: Static msg handler which passes messages
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CNetConnectWizard::StaticSessionsDlgProc( HWND hDlg, UINT uMsg,
                                                           WPARAM wParam, LPARAM lParam )
{
    if( g_pNCW )
        return g_pNCW->SessionsDlgProc( hDlg, uMsg, wParam, lParam );

    return FALSE; // Message not handled
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgProc()
// Desc: Handles messages fro the multiplayer games dialog
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CNetConnectWizard::SessionsDlgProc( HWND hDlg, UINT msg,
                                                     WPARAM wParam, LPARAM lParam )
{
    HRESULT hr;

    switch( msg )
    {
        case WM_INITDIALOG:
            {
                m_hDlg = hDlg;

                // Load and set the icon
                HICON hIcon = LoadIcon( m_hInst, MAKEINTRESOURCE( IDI_MAIN ) );
                SendMessage( hDlg, WM_SETICON, ICON_BIG,   (LPARAM) hIcon );  // Set big icon
                SendMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIcon );  // Set small icon

                // Set the window title
                TCHAR strWindowTitle[256];
                wsprintf( strWindowTitle, TEXT("%s - Multiplayer Games"), m_strAppName );
                SetWindowText( hDlg, strWindowTitle );

                // Init the search portion of the dialog
                m_bSearchingForSessions = FALSE;
                SetDlgItemText( hDlg, IDC_SEARCH_CHECK, TEXT("Start Search") );
                SessionsDlgInitListbox( hDlg );
            }
            break;

        case WM_TIMER:
            // Upon this timer message, then refresh the list of hosts
            // by expiring old hosts, and displaying the list in the
            // dialog box
            if( wParam == TIMERID_DISPLAY_HOSTS )
            {
                // Don't refresh if we are not enumerating hosts
                if( !m_bSearchingForSessions )
                    break;

                // Expire all of the hosts that haven't
                // refreshed in a certain period of time
                SessionsDlgExpireOldHostEnums();

                // Display the list of hosts in the dialog
                if( FAILED( hr = SessionsDlgDisplayEnumList( hDlg ) ) )
                {
                    KillTimer( hDlg, TIMERID_DISPLAY_HOSTS );
                    MessageBox( hDlg, TEXT("Error enumerating DirectPlay games."),
                                TEXT("DirectPlay Sample"),
                                MB_OK | MB_ICONERROR );
                }
            }
            else if( wParam == TIMERID_CONNECT_COMPLETE )
            {
                // Check to see if the MessageHandler has set an event to tell us the
                // DPN_MSGID_CONNECT_COMPLETE has been processed.  Now m_hrConnectComplete
                // is valid.
                if( WAIT_OBJECT_0 == WaitForSingleObject( m_hConnectCompleteEvent, 0 ) )
                {
                    if( FAILED( m_hrConnectComplete ) )
                    {
                        MessageBox( m_hDlg, TEXT("Unable to join game."),
                                    TEXT("DirectPlay Sample"),
                                    MB_OK | MB_ICONERROR );
                        m_bConnecting = FALSE;
                    }
                    else
                    {
                        // DirectPlay connect successful, so end dialog
                        m_hrDialog = NCW_S_FORWARD;
                        EndDialog( m_hDlg, 0 );
                    }

                    KillTimer( hDlg, TIMERID_CONNECT_COMPLETE );
                }
            }

            break;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_SEARCH_CHECK:
                    m_bSearchingForSessions = !m_bSearchingForSessions;

                    if( m_bSearchingForSessions )
                    {
                        SetDlgItemText( hDlg, IDC_SEARCH_CHECK, TEXT("Searching...") );

                        // Start the timer to display the host list every so often
                        SetTimer( hDlg, TIMERID_DISPLAY_HOSTS, DISPLAY_REFRESH_RATE, NULL );

                        // Start the async enumeration
                        if( FAILED( hr = SessionsDlgEnumHosts( hDlg ) ) )
                        {
                            KillTimer( hDlg, TIMERID_DISPLAY_HOSTS );
                            MessageBox( hDlg, TEXT("Error enumerating DirectPlay games."),
                                        TEXT("DirectPlay Sample"),
                                        MB_OK | MB_ICONERROR );
                        }
                    }
                    else
                    {
                        SetDlgItemText( hDlg, IDC_SEARCH_CHECK, TEXT("Start Search") );

                        // Stop the timer, and stop the async enumeration
                        KillTimer( hDlg, TIMERID_DISPLAY_HOSTS );

                        // Until the CancelAsyncOperation returns, it is possible
                        // to still receive host enumerations
                        if( m_hEnumAsyncOp )
                            m_pDP->CancelAsyncOperation( m_hEnumAsyncOp, 0 );

                        // Reset the search portion of the dialog
                        SessionsDlgInitListbox( hDlg );
                    }
                    break;

                case IDC_GAMES_LIST:
                    if( HIWORD(wParam) != LBN_DBLCLK )
                        break;
                    // Fall through

                case IDC_JOIN:
                    if( FAILED( hr = SessionsDlgJoinGame( hDlg ) ) )
                    {
                        MessageBox( hDlg, TEXT("Unable to join game."),
                                    TEXT("DirectPlay Sample"),
                                    MB_OK | MB_ICONERROR );
                    }
                    break;

                case IDC_CREATE:
                    if( FAILED( hr = SessionsDlgCreateGame( hDlg ) ) )
                    {
                        MessageBox( hDlg, TEXT("Unable to create game."),
                                    TEXT("DirectPlay Sample"),
                                    MB_OK | MB_ICONERROR );
                    }
                    break;

                case IDCANCEL: // The close button was press
                    m_hrDialog = NCW_S_QUIT;
                    EndDialog( hDlg, 0 );
                    break;

                case IDC_BACK: // Cancel button was pressed
                    m_hrDialog = NCW_S_BACKUP;
                    EndDialog( hDlg, 0 );
                    break;

                default:
                    return FALSE; // Message not handled
            }
            break;

        case WM_DESTROY:
        {
            KillTimer( hDlg, 1 );

            // Cancel the enum hosts search
            // if the enumeration is going on
            if( m_bSearchingForSessions && m_hEnumAsyncOp )
            {
                m_pDP->CancelAsyncOperation( m_hEnumAsyncOp, 0 );
                m_bSearchingForSessions = FALSE;
            }
            break;
        }

        default:
            return FALSE; // Message not handled
    }

    // Message was handled
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: SessionsDlgInitListbox()
// Desc: Initializes the listbox
//-----------------------------------------------------------------------------
VOID CNetConnectWizard::SessionsDlgInitListbox( HWND hDlg )
{
    HWND hWndListBox = GetDlgItem( hDlg, IDC_GAMES_LIST );

    // Clear the contents from the list box, and
    // display "Looking for games" text in listbox
    SendMessage( hWndListBox, LB_RESETCONTENT, 0, 0 );
    if( m_bSearchingForSe